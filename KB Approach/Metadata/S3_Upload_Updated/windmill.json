{
    "topic": "The mathematical concept being demonstrated is the International Mathematical Olympiad (IMO).",
    "code": [
        "from manim_imports_ext import *\n",
        "import json\n",
        "\n",
        "\n",
        "class IntroduceIMO(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_countries\": 130,\n",
        "        \"use_real_images\": True,\n",
        "        # \"use_real_images\": False,\n",
        "        \"include_labels\": False,\n",
        "        \"camera_config\": {\"background_color\": GREY_E},\n",
        "        \"random_seed\": 6,\n",
        "        \"year\": 2019,\n",
        "        \"n_flag_rows\": 10,\n",
        "        \"reorganize_students\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_flags()\n",
        "        self.show_students()\n",
        "        self.move_title()\n",
        "        self.isolate_usa()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            \"International \", \"Mathematical \", \"Olympiad\",\n",
        "        )\n",
        "        title.scale(1.25)\n",
        "        logo = ImageMobject(\"imo_logo\")\n",
        "        logo.set_height(1)\n",
        "\n",
        "        group = Group(logo, title)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(title, logo)\n",
        "        self.title = title\n",
        "        self.logo = logo\n",
        "\n",
        "    def show_flags(self):\n",
        "        flags = self.get_flags()\n",
        "        flags.set_height(6)\n",
        "        flags.to_edge(DOWN)\n",
        "        random_flags = Group(*flags)\n",
        "        random_flags.shuffle()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown, random_flags,\n",
        "                run_time=2,\n",
        "                lag_ratio=0.03,\n",
        "            )\n",
        "        )\n",
        "        self.remove(random_flags)\n",
        "        self.add(flags)\n",
        "        self.wait()\n",
        "\n",
        "        self.flags = flags\n",
        "\n",
        "    def show_students(self):\n",
        "        flags = self.flags\n",
        "\n",
        "        student_groups = VGroup()\n",
        "        all_students = VGroup()\n",
        "        for flag in flags:\n",
        "            group = self.get_students(flag)\n",
        "            student_groups.add(group)\n",
        "            for student in group:\n",
        "                student.preimage = VectorizedPoint()\n",
        "                student.preimage.move_to(flag)\n",
        "                all_students.add(student)\n",
        "        all_students.shuffle()\n",
        "\n",
        "        student_groups.generate_target()\n",
        "        student_groups.target.arrange_in_grid(\n",
        "            n_rows=self.n_flag_rows,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        # student_groups.target[-9:].align_to(student_groups.target[0], LEFT)\n",
        "        student_groups.target.match_height(flags)\n",
        "        student_groups.target.match_y(flags)\n",
        "        student_groups.target.to_edge(RIGHT, buff=0.25)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    student.preimage, student\n",
        "                )\n",
        "                for student in all_students\n",
        "            ],\n",
        "            run_time=2,\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        if self.reorganize_students:\n",
        "            self.play(\n",
        "                MoveToTarget(student_groups),\n",
        "                flags.space_out_submobjects, 0.75,\n",
        "                flags.to_edge, LEFT, MED_SMALL_BUFF,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.student_groups = student_groups\n",
        "\n",
        "    def move_title(self):\n",
        "        title = self.title\n",
        "        logo = self.logo\n",
        "\n",
        "        new_title = OldTexText(\"IMO\")\n",
        "        new_title.match_height(title)\n",
        "\n",
        "        logo.generate_target()\n",
        "        group = Group(logo.target, new_title)\n",
        "        group.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        group.match_y(title)\n",
        "        group.match_x(self.student_groups, UP)\n",
        "\n",
        "        title.generate_target()\n",
        "        for word, letter in zip(title.target, new_title[0]):\n",
        "            for nl in word:\n",
        "                nl.move_to(letter)\n",
        "            word.set_opacity(0)\n",
        "            word[0].set_opacity(1)\n",
        "            word[0].become(letter)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(title),\n",
        "            MoveToTarget(logo),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def isolate_usa(self):\n",
        "        flags = self.flags\n",
        "        student_groups = self.student_groups\n",
        "\n",
        "        us_flag = flags[0]\n",
        "        random_flags = Group(*flags[1:])\n",
        "        random_flags.shuffle()\n",
        "\n",
        "        old_height = us_flag.get_height()\n",
        "        us_flag.label.set_width(0.8 * us_flag.get_width())\n",
        "        us_flag.label.next_to(\n",
        "            us_flag, DOWN,\n",
        "            buff=0.2 * us_flag.get_height(),\n",
        "        )\n",
        "        us_flag.label.set_opacity(0)\n",
        "        us_flag.add(us_flag.label)\n",
        "        us_flag.generate_target()\n",
        "        us_flag.target.scale(1 / old_height)\n",
        "        us_flag.target.to_corner(UL)\n",
        "        us_flag.target[1].set_opacity(1)\n",
        "\n",
        "        self.remove(us_flag)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    FadeOut(flag, DOWN)\n",
        "                    for flag in random_flags\n",
        "                ],\n",
        "                lag_ratio=0.05,\n",
        "                run_time=1.5\n",
        "            ),\n",
        "            MoveToTarget(us_flag),\n",
        "            student_groups[1:].fade, 0.9,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_students(self, flag):\n",
        "        dots = VGroup(*[Dot() for x in range(6)])\n",
        "        dots.arrange_in_grid(n_cols=2, buff=SMALL_BUFF)\n",
        "        dots.match_height(flag)\n",
        "        dots.next_to(flag, RIGHT, SMALL_BUFF)\n",
        "        dots[flag.n_students:].set_opacity(0)\n",
        "\n",
        "        if isinstance(flag, ImageMobject):\n",
        "            rgba = random.choice(random.choice(flag.pixel_array))\n",
        "            if np.all(rgba < 100):\n",
        "                rgba = interpolate(rgba, 256 * np.ones(len(rgba)), 0.5)\n",
        "            color = rgba_to_color(rgba / 256)\n",
        "        else:\n",
        "            color = random_bright_color()\n",
        "        dots.set_color(color)\n",
        "        dots.set_stroke(WHITE, 1, background=True)\n",
        "\n",
        "        return dots\n",
        "\n",
        "    def get_flags(self):\n",
        "        year = self.year\n",
        "        file = \"{}_imo_countries.json\".format(year)\n",
        "        with open(os.path.join(\"assets\", file)) as fp:\n",
        "            countries_with_counts = json.load(fp)\n",
        "        with open(os.path.join(\"assets\", \"country_codes.json\")) as fp:\n",
        "            country_codes = json.load(fp)\n",
        "            country_to_code2 = dict([\n",
        "                (country.lower(), code2.lower())\n",
        "                for country, code2, code3 in country_codes\n",
        "            ])\n",
        "            country_to_code3 = dict([\n",
        "                (country.lower(), code3.lower())\n",
        "                for country, code2, code3 in country_codes\n",
        "            ])\n",
        "\n",
        "        images = Group()\n",
        "        for country, count in countries_with_counts:\n",
        "            country = country.lower()\n",
        "\n",
        "            alt_names = [\n",
        "                (\"united states of america\", \"united states\"),\n",
        "                (\"people's republic of china\", \"china\"),\n",
        "                (\"macau\", \"macao\"),\n",
        "                (\"syria\", \"syrian arab republic\"),\n",
        "                (\"north macedonia\", \"macedonia, the former yugoslav republic of\"),\n",
        "                (\"tanzania\", \"united republic of tanzania\"),\n",
        "                (\"vietnam\", \"viet nam\"),\n",
        "                (\"ivory coast\", \"cote d'ivoire\")\n",
        "            ]\n",
        "            for n1, n2 in alt_names:\n",
        "                if country == n1:\n",
        "                    country = n2\n",
        "\n",
        "            if country not in country_to_code2:\n",
        "                print(\"Can't find {}\".format(country))\n",
        "                continue\n",
        "            short_code = country_to_code2[country]\n",
        "            try:\n",
        "                image = ImageMobject(os.path.join(\"flags\", short_code))\n",
        "                image.set_width(1)\n",
        "                label = VGroup(*[\n",
        "                    OldTexText(l)\n",
        "                    for l in country_to_code3[country].upper()\n",
        "                ])\n",
        "                label.arrange(RIGHT, buff=0.05, aligned_edge=DOWN)\n",
        "                label.set_height(0.25)\n",
        "                if not self.use_real_images:\n",
        "                    rect = SurroundingRectangle(image, buff=0)\n",
        "                    rect.set_stroke(WHITE, 1)\n",
        "                    image = rect\n",
        "                image.label = label\n",
        "                image.n_students = count\n",
        "                images.add(image)\n",
        "            except OSError:\n",
        "                print(\"Failed on {}\".format(country))\n",
        "\n",
        "        n_rows = self.n_flag_rows\n",
        "        images.arrange_in_grid(\n",
        "            n_rows=n_rows,\n",
        "            buff=1.25,\n",
        "        )\n",
        "        images[-(len(images) % n_rows):].align_to(images[0], LEFT)\n",
        "        sf = 1.7\n",
        "        images.stretch(sf, 0)\n",
        "        for i, image in enumerate(images):\n",
        "            image.set_height(1)\n",
        "            image.stretch(1 / sf, 0)\n",
        "            image.label.next_to(image, DOWN, SMALL_BUFF)\n",
        "            if self.include_labels:\n",
        "                image.add(image.label)\n",
        "\n",
        "        images.set_width(FRAME_WIDTH - 1)\n",
        "        if images.get_height() > FRAME_HEIGHT - 1:\n",
        "            images.set_height(FRAME_HEIGHT - 1)\n",
        "        images.center()\n",
        "        return images\n",
        "\n",
        "\n",
        "class ShowTinyTao(IntroduceIMO):\n",
        "    CONFIG = {\n",
        "        \"reorganize_students\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_title()\n",
        "        self.show_flags()\n",
        "        self.show_students()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        image = ImageMobject(\"TerryTaoIMO\")\n",
        "        label = OldTexText(\"Terence Tao at 12\")\n",
        "        label.match_width(image)\n",
        "        label.next_to(image, DOWN, SMALL_BUFF)\n",
        "        image.add(label)\n",
        "\n",
        "        ausie = self.flags[17]\n",
        "        image.replace(ausie)\n",
        "        image.set_opacity(0)\n",
        "\n",
        "        self.play(image.set_opacity, 1)\n",
        "        self.play(\n",
        "            image.set_height, 5,\n",
        "            image.to_corner, DR, {\"buff\": MED_SMALL_BUFF},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(image))\n",
        "\n",
        "\n",
        "class FootnoteToIMOIntro(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"$^*$Based on data from 2019 test\")\n",
        "        self.play(FadeIn(words, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowTest(Scene):\n",
        "    def construct(self):\n",
        "        self.introduce_test()\n",
        "\n",
        "    def introduce_test(self):\n",
        "        test = self.get_test()\n",
        "        test.generate_target()\n",
        "        test.target.to_edge(UP)\n",
        "\n",
        "        # Time label\n",
        "        time_labels = VGroup(\n",
        "            OldTexText(\"Day 1\", \": 4.5 hours\"),\n",
        "            OldTexText(\"Day 2\", \": 4.5 hours\"),\n",
        "        )\n",
        "        time_labels.scale(1.5)\n",
        "        day_labels = VGroup()\n",
        "        hour_labels = VGroup()\n",
        "        for label, page in zip(time_labels, test.target):\n",
        "            label.next_to(page, DOWN)\n",
        "            label[0].save_state()\n",
        "            label[0].next_to(page, DOWN)\n",
        "            label[1][1:].set_color(YELLOW)\n",
        "            day_labels.add(label[0])\n",
        "            hour_labels.add(label[1])\n",
        "\n",
        "        # Problem descriptions\n",
        "        problem_rects = self.get_problem_rects(test.target[0])\n",
        "        proof_words = VGroup()\n",
        "        for rect in problem_rects:\n",
        "            word = OldTexText(\"Proof\")\n",
        "            word.scale(2)\n",
        "            word.next_to(rect, RIGHT, buff=3)\n",
        "            word.set_color(BLUE)\n",
        "            proof_words.add(word)\n",
        "\n",
        "        proof_words.space_out_submobjects(2)\n",
        "\n",
        "        proof_arrows = VGroup()\n",
        "        for rect, word in zip(problem_rects, proof_words):\n",
        "            arrow = Arrow(word.get_left(), rect.get_right())\n",
        "            arrow.match_color(word)\n",
        "            proof_arrows.add(arrow)\n",
        "\n",
        "        scores = VGroup()\n",
        "        for word in proof_words:\n",
        "            score = VGroup(Integer(0), OldTex(\"/\"), Integer(7))\n",
        "            score.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            score.scale(2)\n",
        "            score.move_to(word)\n",
        "            score.to_edge(RIGHT)\n",
        "            scores.add(score)\n",
        "            score[0].add_updater(lambda m: m.set_color(\n",
        "                interpolate_color(RED, GREEN, m.get_value() / 7)\n",
        "            ))\n",
        "\n",
        "        # Introduce test\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeIn(test[0], 2 * RIGHT),\n",
        "                FadeIn(test[1], 2 * LEFT),\n",
        "                lag_ratio=0.3,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(test, lag_ratio=0.2),\n",
        "            FadeIn(day_labels, UP, lag_ratio=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *map(Restore, day_labels),\n",
        "            FadeIn(hour_labels, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Discuss problems\n",
        "        self.play(\n",
        "            FadeOut(test[1]),\n",
        "            FadeOut(time_labels[1]),\n",
        "            LaggedStartMap(ShowCreation, problem_rects),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                FadeIn(word, LEFT)\n",
        "                for word in proof_words\n",
        "            ]),\n",
        "            LaggedStart(*[\n",
        "                GrowArrow(arrow)\n",
        "                for arrow in proof_arrows\n",
        "            ]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(scores))\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ChangeDecimalToValue(score[0], 7)\n",
        "                for score in scores\n",
        "            ], lag_ratio=0.2, rate_func=rush_into)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.scores = scores\n",
        "        self.proof_arrows = proof_arrows\n",
        "        self.proof_words = proof_words\n",
        "        self.problem_rects = problem_rects\n",
        "        self.test = test\n",
        "        self.time_labels = time_labels\n",
        "\n",
        "    def get_test(self):\n",
        "        group = Group(\n",
        "            ImageMobject(\"imo_2011_p1\"),\n",
        "            ImageMobject(\"imo_2011_p2\"),\n",
        "        )\n",
        "        group.set_height(6)\n",
        "        group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        for page in group:\n",
        "            rect = SurroundingRectangle(page, buff=0.01)\n",
        "            rect.set_stroke(WHITE, 1)\n",
        "            page.add(rect)\n",
        "            # page.pixel_array[:, :, :3] = 255 - page.pixel_array[:, :, :3]\n",
        "        return group\n",
        "\n",
        "    def get_problem_rects(self, page):\n",
        "        pw = page.get_width()\n",
        "        rects = VGroup(*[Rectangle() for x in range(3)])\n",
        "        rects.set_stroke(width=2)\n",
        "        rects.set_color_by_gradient([BLUE_E, BLUE_C, BLUE_D])\n",
        "\n",
        "        rects.set_width(pw * 0.75)\n",
        "        for factor, rect in zip([0.095, 0.16, 0.1], rects):\n",
        "            rect.set_height(factor * pw, stretch=True)\n",
        "        rects.arrange(DOWN, buff=0.08)\n",
        "        rects.move_to(page)\n",
        "        rects.shift(0.09 * pw * DOWN)\n",
        "        return rects\n",
        "\n",
        "\n",
        "class USProcessAlt(IntroduceIMO):\n",
        "    CONFIG = {\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_flag_and_label()\n",
        "        self.show_tests()\n",
        "        self.show_imo()\n",
        "\n",
        "    def add_flag_and_label(self):\n",
        "        flag = ImageMobject(\"flags/us\")\n",
        "        flag.set_height(1)\n",
        "        flag.to_corner(UL)\n",
        "        label = VGroup(*map(TexText, \"USA\"))\n",
        "        label.arrange(RIGHT, buff=0.05, aligned_edge=DOWN)\n",
        "        label.set_width(0.8 * flag.get_width())\n",
        "        label.next_to(flag, DOWN, buff=0.2 * flag.get_height())\n",
        "\n",
        "        self.add(flag, label)\n",
        "\n",
        "        self.flag = flag\n",
        "\n",
        "    def show_tests(self):\n",
        "        tests = VGroup(\n",
        "            self.get_test(\n",
        "                [\"American \", \"Mathematics \", \"Contest\"],\n",
        "                n_questions=25,\n",
        "                time_string=\"75 minutes\",\n",
        "                hours=1.25,\n",
        "                n_students=250000,\n",
        "            ),\n",
        "            self.get_test(\n",
        "                [\"American \", \"Invitational \", \"Math \", \"Exam\"],\n",
        "                n_questions=15,\n",
        "                time_string=\"3 hours\",\n",
        "                hours=3,\n",
        "                n_students=12000,\n",
        "            ),\n",
        "            self.get_test(\n",
        "                [\"U\", \"S\", \"A \", \"Math \", \"Olympiad\"],\n",
        "                n_questions=6,\n",
        "                time_string=\"$2 \\\\times 4.5$ hours\",\n",
        "                hours=4.5,\n",
        "                n_students=500,\n",
        "            ),\n",
        "            self.get_test(\n",
        "                [\"Mathematical \", \"Olympiad \", \"Program\"],\n",
        "                n_questions=None,\n",
        "                time_string=\"3 weeks\",\n",
        "                hours=None,\n",
        "                n_students=60\n",
        "            )\n",
        "        )\n",
        "        amc, aime, usamo, mop = tests\n",
        "        arrows = VGroup()\n",
        "\n",
        "        amc.to_corner(UR)\n",
        "        top_point = amc.get_top()\n",
        "        last_arrow = VectorizedPoint()\n",
        "        last_arrow.to_corner(DL)\n",
        "        next_anims = []\n",
        "\n",
        "        self.force_skipping()\n",
        "        for test in tests:\n",
        "            test.move_to(top_point, UP)\n",
        "            test.shift_onto_screen()\n",
        "            self.play(\n",
        "                Write(test.name),\n",
        "                *next_anims,\n",
        "                run_time=1,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.animate_name_abbreviation(test)\n",
        "            self.wait()\n",
        "\n",
        "            if isinstance(test.nq_label[0], Integer):\n",
        "                int_mob = test.nq_label[0]\n",
        "                n = int_mob.get_value()\n",
        "                int_mob.set_value(0)\n",
        "                self.play(\n",
        "                    ChangeDecimalToValue(int_mob, n),\n",
        "                    FadeIn(test.nq_label[1:])\n",
        "                )\n",
        "            else:\n",
        "                self.play(FadeIn(test.nq_label))\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(test.t_label)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            test.generate_target()\n",
        "            test.target.scale(0.575)\n",
        "            test.target.next_to(last_arrow, RIGHT, buff=SMALL_BUFF)\n",
        "            test.target.shift_onto_screen()\n",
        "\n",
        "            next_anims = [\n",
        "                MoveToTarget(test),\n",
        "                GrowArrow(last_arrow),\n",
        "            ]\n",
        "            last_arrow = Vector(0.5 * RIGHT)\n",
        "            last_arrow.set_color(WHITE)\n",
        "            last_arrow.next_to(test.target, RIGHT, SMALL_BUFF)\n",
        "            arrows.add(last_arrow)\n",
        "        self.play(*next_anims)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, tests,\n",
        "                lambda m: (m, LEFT),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                GrowArrow, arrows[:-1]\n",
        "            ),\n",
        "            lag_ratio=0.4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.tests = tests\n",
        "\n",
        "    def show_imo(self):\n",
        "        tests = self.tests\n",
        "        logo = ImageMobject(\"imo_logo\")\n",
        "        logo.set_height(1)\n",
        "        name = OldTexText(\"IMO\")\n",
        "        name.scale(2)\n",
        "        group = Group(logo, name)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_corner(UR)\n",
        "        group.shift(2 * LEFT)\n",
        "\n",
        "        students = VGroup(*[\n",
        "            PiCreature()\n",
        "            for x in range(6)\n",
        "        ])\n",
        "        students.arrange_in_grid(n_cols=3, buff=LARGE_BUFF)\n",
        "        students.set_height(2)\n",
        "        students.next_to(group, DOWN)\n",
        "        colors = it.cycle([RED, GREY_B, BLUE])\n",
        "        for student, color in zip(students, colors):\n",
        "            student.set_color(color)\n",
        "            student.save_state()\n",
        "            student.move_to(tests[-1])\n",
        "            student.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(group),\n",
        "            LaggedStartMap(\n",
        "                Restore, students,\n",
        "                run_time=3,\n",
        "                lag_ratio=0.3,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyMethod(student.change, \"hooray\")\n",
        "                for student in students\n",
        "            ])\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.play(Blink(random.choice(students)))\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def animate_name_abbreviation(self, test):\n",
        "        name = test.name\n",
        "        short_name = test.short_name\n",
        "        short_name.move_to(name, LEFT)\n",
        "        name.generate_target()\n",
        "        for p1, p2 in zip(name.target, short_name):\n",
        "            for letter in p1:\n",
        "                letter.move_to(p2[0])\n",
        "                letter.set_opacity(0)\n",
        "            p1[0].set_opacity(1)\n",
        "        self.add(test.rect, test.name, test.ns_label)\n",
        "        self.play(\n",
        "            FadeIn(test.rect),\n",
        "            MoveToTarget(name),\n",
        "            FadeIn(test.ns_label),\n",
        "        )\n",
        "\n",
        "        test.remove(name)\n",
        "        test.add(short_name)\n",
        "        self.remove(name)\n",
        "        self.add(short_name)\n",
        "\n",
        "    def get_test(self, name_parts, n_questions, time_string, hours, n_students):\n",
        "        T_COLOR = GREEN_B\n",
        "        Q_COLOR = YELLOW\n",
        "\n",
        "        name = OldTexText(*name_parts)\n",
        "        short_name = OldTexText(*[np[0] for np in name_parts])\n",
        "        if n_questions:\n",
        "            nq_label = VGroup(\n",
        "                Integer(n_questions),\n",
        "                OldTexText(\"questions\")\n",
        "            )\n",
        "            nq_label.arrange(RIGHT)\n",
        "        else:\n",
        "            nq_label = OldTexText(\"Lots of training\")\n",
        "        nq_label.set_color(Q_COLOR)\n",
        "\n",
        "        if time_string:\n",
        "            t_label = OldTexText(time_string)\n",
        "            t_label.set_color(T_COLOR)\n",
        "        else:\n",
        "            t_label = Integer(0).set_opacity(0)\n",
        "\n",
        "        clock = Clock()\n",
        "        clock.hour_hand.set_opacity(0)\n",
        "        clock.minute_hand.set_opacity(0)\n",
        "        clock.set_stroke(WHITE, 2)\n",
        "        if hours:\n",
        "            sector = Sector(\n",
        "                start_angle=TAU / 4,\n",
        "                angle=-TAU * (hours / 12),\n",
        "                outer_radius=clock.get_width() / 2,\n",
        "                arc_center=clock.get_center()\n",
        "            )\n",
        "            sector.set_fill(T_COLOR, 0.5)\n",
        "            sector.set_stroke(T_COLOR, 2)\n",
        "            clock.add(sector)\n",
        "            if hours == 4.5:\n",
        "                plus = OldTex(\"+\").scale(2)\n",
        "                plus.next_to(clock, RIGHT)\n",
        "                clock_copy = clock.copy()\n",
        "                clock_copy.next_to(plus, RIGHT)\n",
        "                clock.add(plus, clock_copy)\n",
        "        else:\n",
        "            clock.set_opacity(0)\n",
        "        clock.set_height(1)\n",
        "        clock.next_to(t_label, RIGHT, buff=MED_LARGE_BUFF)\n",
        "        t_label.add(clock)\n",
        "\n",
        "        ns_label = OldTexText(\"$\\\\sim${:,} students\".format(n_students))\n",
        "\n",
        "        result = VGroup(\n",
        "            name,\n",
        "            nq_label,\n",
        "            t_label,\n",
        "            ns_label,\n",
        "        )\n",
        "        result.arrange(\n",
        "            DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        rect = SurroundingRectangle(result, buff=MED_SMALL_BUFF)\n",
        "        rect.set_width(\n",
        "            result[1:].get_width() + MED_LARGE_BUFF,\n",
        "            about_edge=LEFT,\n",
        "            stretch=True,\n",
        "        )\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        result.add_to_back(rect)\n",
        "\n",
        "        result.name = name\n",
        "        result.short_name = short_name\n",
        "        result.nq_label = nq_label\n",
        "        result.t_label = t_label\n",
        "        result.ns_label = ns_label\n",
        "        result.rect = rect\n",
        "        result.clock = clock\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class Describe2011IMO(IntroduceIMO):\n",
        "    CONFIG = {\n",
        "        \"year\": 2011,\n",
        "        \"use_real_images\": True,\n",
        "        \"n_flag_rows\": 10,\n",
        "        \"student_data\": [\n",
        "            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n",
        "            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n",
        "            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n",
        "            [4, \"Jun Jie Joseph Kuan\", \"sg\", [7, 7, 7, 7, 7, 1]],\n",
        "            [4, \"David Yang\", \"us\", [7, 7, 7, 7, 7, 1]],\n",
        "            [6, \"Jie Jun Ang\", \"sg\", [7, 7, 7, 7, 7, 0]],\n",
        "            [6, \"Kensuke Yoshida\", \"jp\", [7, 6, 7, 7, 7, 1]],\n",
        "            [6, \"Raul Sarmiento\", \"pe\", [7, 7, 7, 7, 7, 0]],\n",
        "            [6, \"Nipun Pitimanaaree\", \"th\", [7, 7, 7, 7, 7, 0]],\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_flags_and_students()\n",
        "        self.comment_on_primality()\n",
        "        self.show_top_three_scorers()\n",
        "\n",
        "    def add_title(self):\n",
        "        year = OldTex(\"2011\")\n",
        "        logo = ImageMobject(\"imo_logo\")\n",
        "        imo = OldTexText(\"IMO\")\n",
        "        group = Group(year, logo, imo)\n",
        "        group.scale(1.25)\n",
        "        logo.set_height(1)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_corner(UR, buff=MED_SMALL_BUFF)\n",
        "        group.shift(LEFT)\n",
        "\n",
        "        self.add(group)\n",
        "        self.play(FadeIn(year, RIGHT))\n",
        "\n",
        "        self.title = group\n",
        "\n",
        "    def add_flags_and_students(self):\n",
        "        flags = self.get_flags()\n",
        "        flags.space_out_submobjects(0.8)\n",
        "        sf = 0.8\n",
        "        flags.stretch(sf, 0)\n",
        "        for flag in flags:\n",
        "            flag.stretch(1 / sf, 0)\n",
        "        flags.set_height(5)\n",
        "        flags.to_corner(DL)\n",
        "\n",
        "        student_groups = VGroup(*[\n",
        "            self.get_students(flag)\n",
        "            for flag in flags\n",
        "        ])\n",
        "        student_groups.arrange_in_grid(\n",
        "            n_rows=self.n_flag_rows,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        student_groups[-1].align_to(student_groups, LEFT)\n",
        "        student_groups.set_height(6)\n",
        "        student_groups.next_to(self.title, DOWN)\n",
        "        flags.align_to(student_groups, UP)\n",
        "\n",
        "        all_students = VGroup(*it.chain(*[\n",
        "            [\n",
        "                student\n",
        "                for student in group\n",
        "                if student.get_fill_opacity() > 0\n",
        "            ]\n",
        "            for group in student_groups\n",
        "        ]))\n",
        "\n",
        "        # Counters\n",
        "        student_counter = VGroup(\n",
        "            Integer(0),\n",
        "            OldTexText(\"Participants\"),\n",
        "        )\n",
        "        student_counter.set = all_students\n",
        "        student_counter.next_to(self.title, LEFT, MED_LARGE_BUFF)\n",
        "        student_counter.right_edge = student_counter.get_right()\n",
        "\n",
        "        def update_counter(counter):\n",
        "            counter[0].set_value(len(counter.set))\n",
        "            counter.arrange(RIGHT)\n",
        "            counter[0].align_to(counter[1][0][0], DOWN)\n",
        "            counter.move_to(counter.right_edge, RIGHT)\n",
        "\n",
        "        student_counter.add_updater(update_counter)\n",
        "\n",
        "        flag_counter = VGroup(\n",
        "            Integer(0),\n",
        "            OldTexText(\"Countries\")\n",
        "        )\n",
        "        flag_counter.set = flags\n",
        "        flag_counter.next_to(student_counter, LEFT, buff=0.75)\n",
        "        flag_counter.align_to(student_counter[0], DOWN)\n",
        "        flag_counter.right_edge = flag_counter.get_right()\n",
        "        flag_counter.add_updater(update_counter)\n",
        "\n",
        "        self.add(student_counter)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(all_students),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(flag_counter)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(flags),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.student_counter = student_counter\n",
        "        self.flag_counter = flag_counter\n",
        "        self.all_students = all_students\n",
        "        self.student_groups = student_groups\n",
        "        self.flags = flags\n",
        "\n",
        "    def comment_on_primality(self):\n",
        "        full_rect = FullScreenFadeRectangle(opacity=0.9)\n",
        "        numbers = VGroup(\n",
        "            self.title[0],\n",
        "            self.student_counter[0],\n",
        "            self.flag_counter[0],\n",
        "        )\n",
        "        lines = VGroup(*[\n",
        "            Line().match_width(number).next_to(number, DOWN, SMALL_BUFF)\n",
        "            for number in numbers\n",
        "        ])\n",
        "        lines.set_stroke(TEAL, 2)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DL)\n",
        "        randy.look_at(numbers)\n",
        "\n",
        "        words = VGroup(*[\n",
        "            OldTexText(\"Prime\").next_to(line, DOWN)\n",
        "            for line in reversed(lines)\n",
        "        ])\n",
        "        words.match_color(lines)\n",
        "\n",
        "        self.add(full_rect, numbers)\n",
        "        self.play(\n",
        "            FadeIn(full_rect),\n",
        "            randy.change, \"sassy\",\n",
        "            VFadeIn(randy),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines),\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change, \"thinking\",\n",
        "            LaggedStart(*[\n",
        "                FadeIn(word, UP)\n",
        "                for word in words\n",
        "            ], run_time=3, lag_ratio=0.5)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(words),\n",
        "        )\n",
        "        self.play(FadeOut(full_rect), FadeOut(lines))\n",
        "\n",
        "    def show_top_three_scorers(self):\n",
        "        student_groups = self.student_groups\n",
        "        all_students = self.all_students\n",
        "        flags = self.flags\n",
        "        student_counter = self.student_counter\n",
        "        flag_counter = self.flag_counter\n",
        "\n",
        "        student = student_groups[10][0]\n",
        "        flag = flags[10]\n",
        "\n",
        "        students_to_fade = VGroup(*filter(\n",
        "            lambda s: s is not student,\n",
        "            all_students\n",
        "        ))\n",
        "        flags_to_fade = Group(*filter(\n",
        "            lambda s: s is not flag,\n",
        "            flags\n",
        "        ))\n",
        "\n",
        "        grid = self.get_score_grid()\n",
        "        grid.shift(3 * DOWN)\n",
        "        title_row = grid.rows[0]\n",
        "        top_row = grid.rows[1]\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOutAndShiftDown, students_to_fade),\n",
        "            LaggedStartMap(FadeOutAndShiftDown, flags_to_fade),\n",
        "            ChangeDecimalToValue(student_counter[0], 1),\n",
        "            FadeOut(flag_counter),\n",
        "            run_time=2\n",
        "        )\n",
        "        student_counter[1][0][-1].fade(1)\n",
        "        self.play(\n",
        "            Write(top_row[0]),\n",
        "            ReplacementTransform(student, top_row[1][1]),\n",
        "            flag.replace, top_row[1][0],\n",
        "        )\n",
        "        self.remove(flag)\n",
        "        self.add(top_row[1])\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, title_row[2:]),\n",
        "            LaggedStartMap(FadeIn, top_row[2:]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                FadeIn(row, UP)\n",
        "                for row in grid.rows[2:4]\n",
        "            ]),\n",
        "            LaggedStart(*[\n",
        "                ShowCreation(line)\n",
        "                for line in grid.h_lines[:2]\n",
        "            ]),\n",
        "            lag_ratio=0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(\n",
        "                Group(title_row[3], grid.rows[3][3]),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        student_counter.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(self.title, UP),\n",
        "            FadeOut(student_counter, UP),\n",
        "            grid.rows[:4].shift, 3 * UP,\n",
        "            grid.h_lines[:3].shift, 3 * UP,\n",
        "        )\n",
        "        remaining_rows = grid.rows[4:]\n",
        "        remaining_lines = grid.h_lines[3:]\n",
        "        Group(remaining_rows, remaining_lines).shift(3 * UP)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, remaining_rows,\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, remaining_lines),\n",
        "            lag_ratio=0.3,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_score_grid(self):\n",
        "        data = self.student_data\n",
        "\n",
        "        ranks = VGroup(*[\n",
        "            Integer(row[0])\n",
        "            for row in data\n",
        "        ])\n",
        "\n",
        "        # Combine students with flags\n",
        "        students = VGroup(*[\n",
        "            OldTexText(row[1])\n",
        "            for row in data\n",
        "        ])\n",
        "        flags = Group(*[\n",
        "            ImageMobject(\"flags/{}.png\".format(row[2])).set_height(0.3)\n",
        "            for row in data\n",
        "        ])\n",
        "        students = Group(*[\n",
        "            Group(flag.next_to(student, LEFT, buff=0.2), student)\n",
        "            for flag, student in zip(flags, students)\n",
        "        ])\n",
        "\n",
        "        score_rows = VGroup(*[\n",
        "            VGroup(*map(Integer, row[3]))\n",
        "            for row in data\n",
        "        ])\n",
        "        colors = color_gradient([RED, YELLOW, GREEN], 8)\n",
        "        for score_row in score_rows:\n",
        "            for score in score_row:\n",
        "                score.set_color(colors[score.get_value()])\n",
        "\n",
        "        titles = VGroup(*[\n",
        "            VectorizedPoint(),\n",
        "            VectorizedPoint(),\n",
        "            *[\n",
        "                OldTexText(\"P{}\".format(i))\n",
        "                for i in range(1, 7)\n",
        "            ]\n",
        "        ])\n",
        "        titles.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        titles[2:].shift(students.get_width() * RIGHT)\n",
        "        rows = Group(titles, *[\n",
        "            Group(rank, student, *score_row)\n",
        "            for rank, flag, student, score_row in zip(\n",
        "                ranks, flags, students, score_rows\n",
        "            )\n",
        "        ])\n",
        "        rows.arrange(DOWN)\n",
        "        rows.to_edge(UP)\n",
        "        for row in rows:\n",
        "            for i, e1, e2 in zip(it.count(), titles, row):\n",
        "                if i < 2:\n",
        "                    e2.align_to(e1, LEFT)\n",
        "                else:\n",
        "                    e2.match_x(e1)\n",
        "        ranks.next_to(students, LEFT)\n",
        "\n",
        "        h_lines = VGroup()\n",
        "        for r1, r2 in zip(rows[1:], rows[2:]):\n",
        "            line = Line()\n",
        "            line.set_stroke(WHITE, 0.5)\n",
        "            line.match_width(r2)\n",
        "            line.move_to(midpoint(r1.get_bottom(), r2.get_top()))\n",
        "            line.align_to(r2, LEFT)\n",
        "            h_lines.add(line)\n",
        "\n",
        "        grid = Group(rows, h_lines)\n",
        "        grid.rows = rows\n",
        "        grid.h_lines = h_lines\n",
        "\n",
        "        return grid\n",
        "\n",
        "\n",
        "class AskWhatsOnTest(ShowTest, MovingCameraScene):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.introduce_test()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.ask_about_questions()\n",
        "\n",
        "    def ask_about_questions(self):\n",
        "        scores = self.scores\n",
        "        arrows = self.proof_arrows\n",
        "        proof_words = self.proof_words\n",
        "\n",
        "        question = OldTexText(\"What kind \\\\\\\\ of problems?\")\n",
        "        question.scale(1.5)\n",
        "        question.move_to(proof_words, LEFT)\n",
        "\n",
        "        research = OldTexText(\"Research-lite\")\n",
        "        research.scale(1.5)\n",
        "        research.move_to(question, LEFT)\n",
        "        research.shift(MED_SMALL_BUFF * RIGHT)\n",
        "        research.set_color(BLUE)\n",
        "\n",
        "        arrows.generate_target()\n",
        "        for arrow in arrows.target:\n",
        "            end = arrow.get_end()\n",
        "            start = arrow.get_start()\n",
        "            arrow.put_start_and_end_on(\n",
        "                interpolate(question.get_left(), start, 0.1),\n",
        "                end\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(scores),\n",
        "            FadeOut(proof_words),\n",
        "            MoveToTarget(arrows),\n",
        "            Write(question),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(research, DOWN),\n",
        "            question.shift, 2 * UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Experience\n",
        "        randy = Randolph(height=2)\n",
        "        randy.move_to(research.get_corner(UL), DL)\n",
        "        randy.shift(SMALL_BUFF * RIGHT)\n",
        "        clock = Clock()\n",
        "        clock.set_height(1)\n",
        "        clock.next_to(randy, UR)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question),\n",
        "            FadeIn(randy),\n",
        "            FadeInFromDown(clock),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change, \"pondering\",\n",
        "            ClockPassesTime(clock, run_time=5, hours_passed=5),\n",
        "        )\n",
        "        self.play(\n",
        "            ClockPassesTime(clock, run_time=2, hours_passed=2),\n",
        "            VFadeOut(clock),\n",
        "            Blink(randy),\n",
        "            VFadeOut(randy),\n",
        "            LaggedStartMap(\n",
        "                FadeOut,\n",
        "                VGroup(\n",
        "                    research,\n",
        "                    *arrows,\n",
        "                    *self.problem_rects,\n",
        "                    self.time_labels[0]\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Second part\n",
        "        big_rect = FullScreenFadeRectangle()\n",
        "        lil_rect = self.problem_rects[1].copy()\n",
        "        lil_rect.reverse_points()\n",
        "        big_rect.append_vectorized_mobject(lil_rect)\n",
        "        frame = self.camera_frame\n",
        "        frame.generate_target()\n",
        "        frame.target.scale(0.35)\n",
        "        frame.target.move_to(lil_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(self.test[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            MoveToTarget(frame, run_time=6),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReadQuestions(Scene):\n",
        "    def construct(self):\n",
        "        background = ImageMobject(\"AskWhatsOnTest_final_image\")\n",
        "        background.set_height(FRAME_HEIGHT)\n",
        "        self.add(background)\n",
        "\n",
        "        lines = SVGMobject(\"imo_2011_2_underline-01\")\n",
        "        lines.set_width(FRAME_WIDTH - 1)\n",
        "        lines.move_to(0.1 * DOWN)\n",
        "        lines.set_stroke(TEAL, 3)\n",
        "\n",
        "        clump_sizes = [1, 2, 3, 2, 1, 2]\n",
        "        partial_sums = list(np.cumsum(clump_sizes))\n",
        "        clumps = VGroup(*[\n",
        "            lines[i:j]\n",
        "            for i, j in zip(\n",
        "                [0] + partial_sums,\n",
        "                partial_sums,\n",
        "            )\n",
        "        ])\n",
        "\n",
        "        faders = []\n",
        "        for clump in clumps:\n",
        "            rects = VGroup()\n",
        "            for line in clump:\n",
        "                rect = Rectangle()\n",
        "                rect.set_stroke(width=0)\n",
        "                rect.set_fill(TEAL, 0.25)\n",
        "                rect.set_width(line.get_width() + SMALL_BUFF)\n",
        "                rect.set_height(0.35, stretch=True)\n",
        "                rect.move_to(line, DOWN)\n",
        "                rects.add(rect)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(clump, run_time=2),\n",
        "                FadeIn(rects),\n",
        "                *faders,\n",
        "            )\n",
        "            self.wait()\n",
        "            faders = [\n",
        "                FadeOut(clump),\n",
        "                FadeOut(rects),\n",
        "            ]\n",
        "        self.play(*faders)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Windmill scenes\n",
        "\n",
        "class WindmillScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"dot_config\": {\n",
        "            \"fill_color\": GREY_B,\n",
        "            \"radius\": 0.05,\n",
        "            \"background_stroke_width\": 2,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "        },\n",
        "        \"windmill_style\": {\n",
        "            \"stroke_color\": RED,\n",
        "            \"stroke_width\": 2,\n",
        "            \"background_stroke_width\": 3,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "        },\n",
        "        \"windmill_length\": 2 * FRAME_WIDTH,\n",
        "        \"windmill_rotation_speed\": 0.25,\n",
        "        # \"windmill_rotation_speed\": 0.5,\n",
        "        # \"hit_sound\": \"pen_click.wav\",\n",
        "        \"hit_sound\": \"pen_click.wav\",\n",
        "        \"leave_shadows\": False,\n",
        "    }\n",
        "\n",
        "    def get_random_point_set(self, n_points=11, width=6, height=6):\n",
        "        return np.array([\n",
        "            [\n",
        "                -width / 2 + np.random.random() * width,\n",
        "                -height / 2 + np.random.random() * height,\n",
        "                0\n",
        "            ]\n",
        "            for n in range(n_points)\n",
        "        ])\n",
        "\n",
        "    def get_dots(self, points):\n",
        "        return VGroup(*[\n",
        "            Dot(point, **self.dot_config)\n",
        "            for point in points\n",
        "        ])\n",
        "\n",
        "    def get_windmill(self, points, pivot=None, angle=TAU / 4):\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_length(self.windmill_length)\n",
        "        line.set_angle(angle)\n",
        "        line.set_style(**self.windmill_style)\n",
        "\n",
        "        line.point_set = points\n",
        "\n",
        "        if pivot is not None:\n",
        "            line.pivot = pivot\n",
        "        else:\n",
        "            line.pivot = points[0]\n",
        "\n",
        "        line.rot_speed = self.windmill_rotation_speed\n",
        "\n",
        "        line.add_updater(lambda l: l.move_to(l.pivot))\n",
        "        return line\n",
        "\n",
        "    def get_pivot_dot(self, windmill, color=YELLOW):\n",
        "        pivot_dot = Dot(color=YELLOW)\n",
        "        pivot_dot.add_updater(lambda d: d.move_to(windmill.pivot))\n",
        "        return pivot_dot\n",
        "\n",
        "    def start_leaving_shadows(self):\n",
        "        self.leave_shadows = True\n",
        "        self.add(self.get_windmill_shadows())\n",
        "\n",
        "    def get_windmill_shadows(self):\n",
        "        if not hasattr(self, \"windmill_shadows\"):\n",
        "            self.windmill_shadows = VGroup()\n",
        "        return self.windmill_shadows\n",
        "\n",
        "    def next_pivot_and_angle(self, windmill):\n",
        "        curr_angle = windmill.get_angle()\n",
        "        pivot = windmill.pivot\n",
        "        non_pivots = list(filter(\n",
        "            lambda p: not np.all(p == pivot),\n",
        "            windmill.point_set\n",
        "        ))\n",
        "\n",
        "        angles = np.array([\n",
        "            -(angle_of_vector(point - pivot) - curr_angle) % PI\n",
        "            for point in non_pivots\n",
        "        ])\n",
        "\n",
        "        # Edge case for 2 points\n",
        "        tiny_indices = angles < 1e-6\n",
        "        if np.all(tiny_indices):\n",
        "            return non_pivots[0], PI\n",
        "\n",
        "        angles[tiny_indices] = np.inf\n",
        "        index = np.argmin(angles)\n",
        "        return non_pivots[index], angles[index]\n",
        "\n",
        "    def rotate_to_next_pivot(self, windmill, max_time=None, added_anims=None):\n",
        "        \"\"\"\n",
        "        Returns animations to play following the contact, and total run time\n",
        "        \"\"\"\n",
        "        new_pivot, angle = self.next_pivot_and_angle(windmill)\n",
        "        change_pivot_at_end = True\n",
        "\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "\n",
        "        run_time = angle / windmill.rot_speed\n",
        "        if max_time is not None and run_time > max_time:\n",
        "            ratio = max_time / run_time\n",
        "            rate_func = (lambda t: ratio * t)\n",
        "            run_time = max_time\n",
        "            change_pivot_at_end = False\n",
        "        else:\n",
        "            rate_func = linear\n",
        "\n",
        "        for anim in added_anims:\n",
        "            if anim.run_time > run_time:\n",
        "                anim.run_time = run_time\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                windmill,\n",
        "                -angle,\n",
        "                rate_func=rate_func,\n",
        "                run_time=run_time,\n",
        "            ),\n",
        "            *added_anims,\n",
        "        )\n",
        "\n",
        "        if change_pivot_at_end:\n",
        "            self.handle_pivot_change(windmill, new_pivot)\n",
        "\n",
        "        # Return animations to play\n",
        "        return [self.get_hit_flash(new_pivot)], run_time\n",
        "\n",
        "    def handle_pivot_change(self, windmill, new_pivot):\n",
        "        windmill.pivot = new_pivot\n",
        "        self.add_sound(self.hit_sound)\n",
        "        if self.leave_shadows:\n",
        "            new_shadow = windmill.copy()\n",
        "            new_shadow.fade(0.5)\n",
        "            new_shadow.set_stroke(width=1)\n",
        "            new_shadow.clear_updaters()\n",
        "            shadows = self.get_windmill_shadows()\n",
        "            shadows.add(new_shadow)\n",
        "\n",
        "    def let_windmill_run(self, windmill, time):\n",
        "        # start_time = self.get_time()\n",
        "        # end_time = start_time + time\n",
        "        # curr_time = start_time\n",
        "        anims_from_last_hit = []\n",
        "        while time > 0:\n",
        "            anims_from_last_hit, last_run_time = self.rotate_to_next_pivot(\n",
        "                windmill,\n",
        "                max_time=time,\n",
        "                added_anims=anims_from_last_hit,\n",
        "            )\n",
        "            time -= last_run_time\n",
        "            # curr_time = self.get_time()\n",
        "\n",
        "    def add_dot_color_updater(self, dots, windmill, **kwargs):\n",
        "        for dot in dots:\n",
        "            dot.add_updater(lambda d: self.update_dot_color(\n",
        "                d, windmill, **kwargs\n",
        "            ))\n",
        "\n",
        "    def update_dot_color(self, dot, windmill, color1=BLUE, color2=GREY_BROWN):\n",
        "        perp = rotate_vector(windmill.get_vector(), TAU / 4)\n",
        "        dot_product = np.dot(perp, dot.get_center() - windmill.pivot)\n",
        "        if dot_product > 0:\n",
        "            dot.set_color(color1)\n",
        "        # elif dot_product < 0:\n",
        "        else:\n",
        "            dot.set_color(color2)\n",
        "        # else:\n",
        "        #     dot.set_color(WHITE)\n",
        "\n",
        "        dot.set_stroke(\n",
        "            # interpolate_color(dot.get_fill_color(), WHITE, 0.5),\n",
        "            WHITE,\n",
        "            width=2,\n",
        "            background=True\n",
        "        )\n",
        "\n",
        "    def get_hit_flash(self, point):\n",
        "        flash = Flash(\n",
        "            point,\n",
        "            line_length=0.1,\n",
        "            flash_radius=0.2,\n",
        "            run_time=0.5,\n",
        "            remover=True,\n",
        "        )\n",
        "        flash_mob = flash.mobject\n",
        "        for submob in flash_mob:\n",
        "            submob.reverse_points()\n",
        "        return Uncreate(\n",
        "            flash.mobject,\n",
        "            run_time=0.25,\n",
        "            lag_ratio=0,\n",
        "        )\n",
        "\n",
        "    def get_pivot_counters(self, windmill, counter_height=0.25, buff=0.2, color=WHITE):\n",
        "        points = windmill.point_set\n",
        "        counters = VGroup()\n",
        "        for point in points:\n",
        "            counter = Integer(0)\n",
        "            counter.set_color(color)\n",
        "            counter.set_height(counter_height)\n",
        "            counter.next_to(point, UP, buff=buff)\n",
        "            counter.point = point\n",
        "            counter.windmill = windmill\n",
        "            counter.is_pivot = False\n",
        "            counter.add_updater(self.update_counter)\n",
        "            counters.add(counter)\n",
        "        return counters\n",
        "\n",
        "    def update_counter(self, counter):\n",
        "        dist = get_norm(counter.point - counter.windmill.pivot)\n",
        "        counter.will_be_pivot = (dist < 1e-6)\n",
        "        if (not counter.is_pivot) and counter.will_be_pivot:\n",
        "            counter.increment_value()\n",
        "        counter.is_pivot = counter.will_be_pivot\n",
        "\n",
        "    def get_orientation_arrows(self, windmill, n_tips=20):\n",
        "        tips = VGroup(*[\n",
        "            ArrowTip(start_angle=0)\n",
        "            for x in range(n_tips)\n",
        "        ])\n",
        "        tips.stretch(0.75, 1)\n",
        "        tips.scale(0.5)\n",
        "\n",
        "        tips.rotate(windmill.get_angle())\n",
        "        tips.match_color(windmill)\n",
        "        tips.set_stroke(BLACK, 1, background=True)\n",
        "        for tip, a in zip(tips, np.linspace(0, 1, n_tips)):\n",
        "            tip.shift(\n",
        "                windmill.point_from_proportion(a) - tip.get_points()[0]\n",
        "            )\n",
        "        return tips\n",
        "\n",
        "    def get_left_right_colorings(self, windmill, opacity=0.3):\n",
        "        rects = VGroup(VMobject(), VMobject())\n",
        "        rects.const_opacity = opacity\n",
        "\n",
        "        def update_regions(rects):\n",
        "            p0, p1 = windmill.get_start_and_end()\n",
        "            v = p1 - p0\n",
        "            vl = rotate_vector(v, 90 * DEGREES)\n",
        "            vr = rotate_vector(v, -90 * DEGREES)\n",
        "            p2 = p1 + vl\n",
        "            p3 = p0 + vl\n",
        "            p4 = p1 + vr\n",
        "            p5 = p0 + vr\n",
        "            rects[0].set_points_as_corners([p0, p1, p2, p3])\n",
        "            rects[1].set_points_as_corners([p0, p1, p4, p5])\n",
        "            rects.set_stroke(width=0)\n",
        "            rects[0].set_fill(BLUE, rects.const_opacity)\n",
        "            rects[1].set_fill(GREY_BROWN, rects.const_opacity)\n",
        "            return rects\n",
        "\n",
        "        rects.add_updater(update_regions)\n",
        "        return rects\n",
        "\n",
        "\n",
        "class IntroduceWindmill(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"final_run_time\": 60,\n",
        "        \"windmill_rotation_speed\": 0.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_points()\n",
        "        self.exclude_colinear()\n",
        "        self.add_line()\n",
        "        self.switch_pivots()\n",
        "        self.continue_and_count()\n",
        "\n",
        "    def add_points(self):\n",
        "        points = self.get_random_point_set(8)\n",
        "        points[-1] = midpoint(points[0], points[1])\n",
        "        dots = self.get_dots(points)\n",
        "        dots.set_color(YELLOW)\n",
        "        dots.set_height(3)\n",
        "        braces = VGroup(\n",
        "            Brace(dots, LEFT),\n",
        "            Brace(dots, RIGHT),\n",
        "        )\n",
        "\n",
        "        group = VGroup(dots, braces)\n",
        "        group.set_height(4)\n",
        "        group.center().to_edge(DOWN)\n",
        "\n",
        "        S, eq = S_eq = OldTex(\"\\\\mathcal{S}\", \"=\")\n",
        "        S_eq.scale(2)\n",
        "        S_eq.next_to(braces, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(S_eq),\n",
        "            FadeIn(braces[0], RIGHT),\n",
        "            FadeIn(braces[1], LEFT),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            S.next_to, dots, LEFT,\n",
        "            {\"buff\": 2, \"aligned_edge\": UP},\n",
        "            FadeOut(braces),\n",
        "            FadeOut(eq),\n",
        "        )\n",
        "\n",
        "        self.S_label = S\n",
        "        self.dots = dots\n",
        "\n",
        "    def exclude_colinear(self):\n",
        "        dots = self.dots\n",
        "\n",
        "        line = Line(dots[0].get_center(), dots[1].get_center())\n",
        "        line.scale(1.5)\n",
        "        line.set_stroke(WHITE)\n",
        "\n",
        "        words = OldTexText(\"Not allowed!\")\n",
        "        words.scale(2)\n",
        "        words.set_color(RED)\n",
        "        words.next_to(line.get_center(), RIGHT)\n",
        "\n",
        "        self.add(line, dots)\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeIn(words, LEFT),\n",
        "            dots[-1].set_color, RED,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(line),\n",
        "            FadeOut(words),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(\n",
        "                dots[-1], 3 * RIGHT,\n",
        "                path_arc=-PI / 4,\n",
        "                rate_func=running_start,\n",
        "            )\n",
        "        )\n",
        "        dots.remove(dots[-1])\n",
        "        self.wait()\n",
        "\n",
        "    def add_line(self):\n",
        "        dots = self.dots\n",
        "        points = np.array(list(map(Mobject.get_center, dots)))\n",
        "        p0 = points[0]\n",
        "\n",
        "        windmill = self.get_windmill(points, p0, angle=60 * DEGREES)\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "\n",
        "        l_label = OldTex(\"\\\\ell\")\n",
        "        l_label.scale(1.5)\n",
        "        p_label = OldTex(\"P\")\n",
        "\n",
        "        l_label.next_to(\n",
        "            p0 + 2 * normalize(windmill.get_vector()),\n",
        "            RIGHT,\n",
        "        )\n",
        "        l_label.match_color(windmill)\n",
        "        p_label.next_to(p0, RIGHT)\n",
        "        p_label.match_color(pivot_dot)\n",
        "\n",
        "        arcs = VGroup(*[\n",
        "            Arc(angle=-45 * DEGREES, radius=1.5)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        arcs[1].rotate(PI, about_point=ORIGIN)\n",
        "        for arc in arcs:\n",
        "            arc.add_tip(tip_length=0.2)\n",
        "        arcs.rotate(windmill.get_angle())\n",
        "        arcs.shift(p0)\n",
        "\n",
        "        self.add(windmill, dots)\n",
        "        self.play(\n",
        "            GrowFromCenter(windmill),\n",
        "            FadeIn(l_label, DL),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(pivot_dot, p_label),\n",
        "            GrowFromCenter(pivot_dot),\n",
        "            dots.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(ShowCreation, arcs))\n",
        "        self.wait()\n",
        "\n",
        "        # Rotate to next pivot\n",
        "        next_pivot, angle = self.next_pivot_and_angle(windmill)\n",
        "        self.play(\n",
        "            *[\n",
        "                Rotate(\n",
        "                    mob, -0.99 * angle,\n",
        "                    about_point=p0,\n",
        "                    rate_func=linear,\n",
        "                )\n",
        "                for mob in [windmill, arcs, l_label]\n",
        "            ],\n",
        "            VFadeOut(l_label),\n",
        "        )\n",
        "        self.add_sound(self.hit_sound)\n",
        "        self.play(\n",
        "            self.get_hit_flash(next_pivot)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.pivot2 = next_pivot\n",
        "        self.pivot_dot = pivot_dot\n",
        "        self.windmill = windmill\n",
        "        self.p_label = p_label\n",
        "        self.arcs = arcs\n",
        "\n",
        "    def switch_pivots(self):\n",
        "        windmill = self.windmill\n",
        "        pivot2 = self.pivot2\n",
        "        p_label = self.p_label\n",
        "        arcs = self.arcs\n",
        "\n",
        "        q_label = OldTex(\"Q\")\n",
        "        q_label.set_color(YELLOW)\n",
        "        q_label.next_to(pivot2, DR, buff=SMALL_BUFF)\n",
        "\n",
        "        self.rotate_to_next_pivot(windmill)\n",
        "        self.play(\n",
        "            FadeIn(q_label, LEFT),\n",
        "            FadeOut(p_label),\n",
        "            FadeOut(arcs),\n",
        "        )\n",
        "        self.wait()\n",
        "        flashes, run_time = self.rotate_to_next_pivot(windmill)\n",
        "        self.remove(q_label)\n",
        "        self.add_sound(self.hit_sound)\n",
        "        self.play(*flashes)\n",
        "        self.wait()\n",
        "        self.let_windmill_run(windmill, 10)\n",
        "\n",
        "    def continue_and_count(self):\n",
        "        windmill = self.windmill\n",
        "        pivot_dot = self.pivot_dot\n",
        "\n",
        "        p_label = OldTex(\"P\")\n",
        "        p_label.match_color(pivot_dot)\n",
        "        p_label.next_to(pivot_dot, DR, buff=0)\n",
        "\n",
        "        l_label = OldTex(\"\\\\ell\")\n",
        "        l_label.scale(1.5)\n",
        "        l_label.match_color(windmill)\n",
        "        l_label.next_to(\n",
        "            windmill.get_center() + -3 * normalize(windmill.get_vector()),\n",
        "            DR,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(p_label, UL))\n",
        "        self.play(FadeIn(l_label, LEFT))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(\n",
        "            windmill.copy().fade(0.75),\n",
        "            pivot_dot.copy().fade(0.75),\n",
        "        )\n",
        "        pivot_counters = self.get_pivot_counters(windmill)\n",
        "        self.add(pivot_counters)\n",
        "        windmill.rot_speed *= 2\n",
        "\n",
        "        self.let_windmill_run(windmill, self.final_run_time)\n",
        "\n",
        "\n",
        "class ContrastToOtherOlympiadProblems(AskWhatsOnTest):\n",
        "    def construct(self):\n",
        "        self.zoom_to_other_questions()\n",
        "\n",
        "    def zoom_to_other_questions(self):\n",
        "        test = self.get_test()\n",
        "        rects = self.get_all_rects()\n",
        "\n",
        "        big_rects = VGroup()\n",
        "        for rect in rects:\n",
        "            big_rect = FullScreenFadeRectangle()\n",
        "            rect.reverse_points()\n",
        "            big_rect.append_vectorized_mobject(rect)\n",
        "            big_rects.add(big_rect)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        frame.generate_target()\n",
        "        frame.target.scale(0.35)\n",
        "        frame.target.move_to(rects[1])\n",
        "        big_rect = big_rects[1].copy()\n",
        "\n",
        "        self.add(test)\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            MoveToTarget(frame, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in [2, 0, 3, 5]:\n",
        "            self.play(\n",
        "                frame.move_to, rects[i],\n",
        "                Transform(big_rect, big_rects[i])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def get_all_rects(self, test):\n",
        "        rects = self.get_problem_rects(test[0])\n",
        "        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n",
        "        new_rects[0].stretch(0.85, 1)\n",
        "        new_rects[1].stretch(0.8, 1)\n",
        "        new_rects[2].stretch(0.8, 1)\n",
        "        new_rects.arrange(DOWN, buff=0.08)\n",
        "        new_rects.move_to(test[1])\n",
        "        new_rects.align_to(rects, UP)\n",
        "        rects.add(*new_rects)\n",
        "        return rects\n",
        "\n",
        "\n",
        "class WindmillExample30Points(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 30,\n",
        "        \"random_seed\": 0,\n",
        "        \"run_time\": 60,\n",
        "        \"counter_config\": {\n",
        "            \"counter_height\": 0.15,\n",
        "            \"buff\": 0.1,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        points = self.get_random_point_set(self.n_points)\n",
        "        points[:, 0] *= 1.5\n",
        "        sorted_points = sorted(list(points), key=lambda p: p[1])\n",
        "        sorted_points[4] += RIGHT\n",
        "\n",
        "        dots = self.get_dots(points)\n",
        "        windmill = self.get_windmill(points, sorted_points[5], angle=PI / 4)\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "        # self.add_dot_color_updater(dots, windmill)\n",
        "\n",
        "        self.add(windmill)\n",
        "        self.add(dots)\n",
        "        self.add(pivot_dot)\n",
        "        self.add(self.get_pivot_counters(\n",
        "            windmill, **self.counter_config\n",
        "        ))\n",
        "\n",
        "        self.let_windmill_run(windmill, self.run_time)\n",
        "\n",
        "\n",
        "class WindmillExample15Points(WindmillExample30Points):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 15,\n",
        "        \"run_time\": 60,\n",
        "        \"random_seed\": 2,\n",
        "        \"counter_config\": {\n",
        "            \"counter_height\": 0.25,\n",
        "            \"buff\": 0.1,\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class TheQuestion(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Will each point be hit infinitely many times?\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class SpiritOfIMO(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        problems = VGroup(*[\n",
        "            OldTexText(\"P{})\".format(i))\n",
        "            for i in range(1, 7)\n",
        "        ])\n",
        "        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n",
        "        problems.scale(1.5)\n",
        "        problems[3:].shift(1.5 * RIGHT)\n",
        "        problems.to_corner(UR, buff=LARGE_BUFF)\n",
        "        problems.shift(2 * LEFT)\n",
        "\n",
        "        light_bulbs = VGroup()\n",
        "        lights = VGroup()\n",
        "        for problem in problems:\n",
        "            light_bulb = Lightbulb()\n",
        "            light_bulb.base = light_bulb[:3]\n",
        "            light_bulb.light = light_bulb[3:]\n",
        "            light_bulb.set_height(1)\n",
        "            light_bulb.next_to(problem, RIGHT)\n",
        "            light_bulbs.add(light_bulb)\n",
        "\n",
        "            light = self.get_light(light_bulb.get_center())\n",
        "            lights.add(light)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, problems)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, light_bulbs,\n",
        "                run_time=1,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                LaggedStartMap, lights,\n",
        "                lambda l: (VFadeInThenOut, l),\n",
        "                run_time=3\n",
        "            ),\n",
        "            randy.change, \"thinking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.pi_creature_thinks(\n",
        "            \"Oh, I've\\\\\\\\seen this...\",\n",
        "            target_mode=\"surprised\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_light(self, point):\n",
        "        radii = np.arange(0, 5, 0.1)\n",
        "        result = VGroup(*[\n",
        "            Annulus(\n",
        "                inner_radius=r1,\n",
        "                outer_radius=r2,\n",
        "                arc_center=point,\n",
        "                fill_opacity=(1 / (r1 + 1)**2),\n",
        "                fill_color=YELLOW,\n",
        "            )\n",
        "            for r1, r2 in zip(radii[1:], radii[2:])\n",
        "        ])\n",
        "        return result\n",
        "\n",
        "\n",
        "# TODO\n",
        "class HowToPrepareForThis(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class HarderThanExpected(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Unusual aspect \\\\#2\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.match_width(title)\n",
        "        line.next_to(title, DOWN)\n",
        "\n",
        "        words = OldTexText(\"Harder than expected\")\n",
        "        words.set_color(RED)\n",
        "        words.scale(1.5)\n",
        "        words.next_to(line, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(title),\n",
        "            ShowCreation(line),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\"pondering\", \"confused\", \"sassy\")\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(words, UP),\n",
        "            self.change_students(*3 * [\"horrified\"]),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n",
        "    def construct(self):\n",
        "        test = self.get_test()\n",
        "        rects = self.get_all_rects(test)\n",
        "        for rect in rects:\n",
        "            rect.reverse_points()\n",
        "\n",
        "        big_rects = VGroup(*[\n",
        "            FullScreenFadeRectangle()\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n",
        "            br.append_vectorized_mobject(r1)\n",
        "            br.append_vectorized_mobject(r2)\n",
        "        big_rect = big_rects[0].copy()\n",
        "\n",
        "        p_labels = VGroup()\n",
        "        for i, rect in enumerate(rects):\n",
        "            p_label = OldTexText(\"P{}\".format(i + 1))\n",
        "            p_label.next_to(rect, LEFT)\n",
        "            p_labels.add(p_label)\n",
        "\n",
        "        arrow = Vector(3 * DOWN)\n",
        "        arrow.next_to(test[0], RIGHT)\n",
        "        arrow.match_y(rects)\n",
        "        harder_words = OldTexText(\"Get harder\")\n",
        "        harder_words.scale(2)\n",
        "        harder_words.next_to(arrow, RIGHT)\n",
        "        harder_words.set_color(RED)\n",
        "\n",
        "        p_words = VGroup(\n",
        "            OldTexText(\"Doable\", color=GREEN),\n",
        "            OldTexText(\"Challenging\", color=YELLOW),\n",
        "            OldTexText(\"Brutal\", color=RED),\n",
        "        )\n",
        "        p_words.add(*p_words.copy())\n",
        "        for rect, word, label in zip(rects, p_words, p_labels):\n",
        "            word.next_to(rect, UP)\n",
        "            label.match_color(word)\n",
        "\n",
        "        self.add(test[0])\n",
        "        self.play(\n",
        "            FadeIn(harder_words),\n",
        "            GrowArrow(arrow),\n",
        "            LaggedStart(*[FadeIn(p, UP) for p in p_labels[:3]]),\n",
        "            LaggedStartMap(ShowCreation, rects[:3]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(test[1]),\n",
        "            FadeIn(p_labels[3:]),\n",
        "            FadeIn(rects[3:]),\n",
        "            FadeOut(harder_words),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(big_rect, p_labels[0], p_labels[3])\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            FadeOut(rects),\n",
        "            FadeOut(p_labels[1:3]),\n",
        "            FadeOut(p_labels[4:]),\n",
        "            FadeInFromDown(p_words[0::3]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(big_rect, big_rects[1]),\n",
        "            FadeOut(p_labels[0::3]),\n",
        "            FadeIn(p_labels[1::3]),\n",
        "            FadeOut(p_words[0::3], DOWN),\n",
        "            FadeIn(p_words[1::3], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(big_rect, big_rects[2]),\n",
        "            FadeOut(p_labels[1::3]),\n",
        "            FadeIn(p_labels[2::3]),\n",
        "            FadeOut(p_words[1::3], DOWN),\n",
        "            FadeIn(p_words[2::3], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PerfectScoreData(Describe2011IMO):\n",
        "    CONFIG = {\n",
        "        \"n_students\": 563,\n",
        "        \"n_perfect_scores_per_problem\": [\n",
        "            345, 22, 51, 267, 170, 6,\n",
        "        ],\n",
        "        \"full_bar_width\": 7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_total_number_of_students()\n",
        "        self.add_subtitle()\n",
        "        self.show_data()\n",
        "        self.analyze_data()\n",
        "\n",
        "    def add_title(self):\n",
        "        self.force_skipping()\n",
        "        super().add_title()\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.title.center().to_edge(UP)\n",
        "\n",
        "    def show_total_number_of_students(self):\n",
        "        title = self.title\n",
        "\n",
        "        bar = self.get_bar(self.n_students, ORIGIN)\n",
        "        bar.next_to(title, DOWN, buff=0.3)\n",
        "        counter = self.get_bar_counter(bar)\n",
        "        counter_label = OldTexText(\"Students\")\n",
        "        counter_label.add_updater(\n",
        "            lambda m: m.next_to(counter, RIGHT)\n",
        "        )\n",
        "\n",
        "        self.add(counter, counter_label)\n",
        "        self.play(\n",
        "            self.get_bar_growth_anim(bar),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_subtitle(self):\n",
        "        title = self.title\n",
        "\n",
        "        subtitle = OldTexText(\n",
        "            \"Number of perfect scores on each problem:\"\n",
        "        )\n",
        "        subtitle.scale(1.25)\n",
        "        subtitle.set_color(GREEN)\n",
        "        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        problems = VGroup(*[\n",
        "            OldTexText(\"P{})\".format(i))\n",
        "            for i in range(1, 7)\n",
        "        ])\n",
        "        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n",
        "        problems[3:].shift(5 * RIGHT)\n",
        "        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n",
        "        problems.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(subtitle),\n",
        "            LaggedStartMap(FadeInFromDown, problems),\n",
        "        )\n",
        "\n",
        "        self.problems = problems\n",
        "\n",
        "    def show_data(self):\n",
        "        problems = self.problems\n",
        "        bars = VGroup(*[\n",
        "            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n",
        "            for n, p in zip(\n",
        "                self.n_perfect_scores_per_problem,\n",
        "                problems,\n",
        "            )\n",
        "        ])\n",
        "        counters = VGroup(*map(self.get_bar_counter, bars))\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(counters),\n",
        "            *[\n",
        "                self.get_bar_growth_anim(bar)\n",
        "                for bar in bars\n",
        "            ],\n",
        "        )\n",
        "        counters.set_fill(WHITE, 1)\n",
        "        self.wait()\n",
        "\n",
        "        self.problem_bars = bars\n",
        "        self.problem_counters = counters\n",
        "\n",
        "    def analyze_data(self):\n",
        "        problems = VGroup(*[\n",
        "            VGroup(p, pb, pc)\n",
        "            for p, pb, pc in zip(\n",
        "                self.problems,\n",
        "                self.problem_bars,\n",
        "                self.problem_counters,\n",
        "            )\n",
        "        ])\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(p, color=p[1].get_color())\n",
        "            for p in problems\n",
        "        ])\n",
        "\n",
        "        rect = rects[1].copy()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(rect, rects[4]))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(rect, rects[2]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(rect, rects[5]),\n",
        "            ReplacementTransform(rects[4], rects[5]),\n",
        "            ReplacementTransform(rects[2], rects[5]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_bar(self, number, left_side):\n",
        "        bar = Rectangle()\n",
        "        bar.set_stroke(width=0)\n",
        "        bar.set_fill(WHITE, 1)\n",
        "        bar.set_height(0.25)\n",
        "        bar.set_width(\n",
        "            self.full_bar_width * number / self.n_students,\n",
        "            stretch=True\n",
        "        )\n",
        "        bar.move_to(left_side, LEFT)\n",
        "\n",
        "        def update_bar_color(bar):\n",
        "            frac = bar.get_width() / self.full_bar_width\n",
        "            if 0 < frac <= 0.25:\n",
        "                alpha = 4 * frac\n",
        "                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n",
        "            elif 0.25 < frac <= 0.5:\n",
        "                alpha = 4 * (frac - 0.25)\n",
        "                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n",
        "            else:\n",
        "                alpha = 2 * (frac - 0.5)\n",
        "                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n",
        "        bar.add_updater(update_bar_color)\n",
        "        return bar\n",
        "\n",
        "    def get_bar_growth_anim(self, bar):\n",
        "        bar.save_state()\n",
        "        bar.stretch(0, 0, about_edge=LEFT)\n",
        "        return Restore(\n",
        "            bar,\n",
        "            suspend_mobject_updating=False,\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "    def get_bar_counter(self, bar):\n",
        "        counter = Integer()\n",
        "        counter.add_updater(\n",
        "            lambda m: m.set_value(\n",
        "                self.n_students * bar.get_width() / self.full_bar_width\n",
        "            )\n",
        "        )\n",
        "        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n",
        "        return counter\n",
        "\n",
        "\n",
        "class SixOnSix(Describe2011IMO):\n",
        "    CONFIG = {\n",
        "        \"student_data\": [\n",
        "            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n",
        "            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n",
        "            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n",
        "            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n",
        "            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n",
        "            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        grid = self.get_score_grid()\n",
        "        grid.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        for row in grid.rows:\n",
        "            row[0].set_opacity(0)\n",
        "        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n",
        "\n",
        "        sf = 1.25\n",
        "        title = OldTexText(\"Only 6 solved P6\")\n",
        "        title.scale(sf)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        subtitle = OldTexText(\"P2 evaded 5 of them\")\n",
        "        subtitle.set_color(YELLOW)\n",
        "        subtitle.scale(sf)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "\n",
        "        six_rect, two_rect = [\n",
        "            SurroundingRectangle(VGroup(\n",
        "                grid.rows[0][index],\n",
        "                grid.rows[-1][index],\n",
        "            ))\n",
        "            for index in [7, 3]\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            LaggedStart(*[FadeIn(row, UP) for row in grid.rows]),\n",
        "            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n",
        "        )\n",
        "        self.play(ShowCreation(six_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(six_rect, two_rect),\n",
        "            FadeIn(subtitle, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AlwaysStartSimple(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Always start\\\\\\\\simple\")\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class TryOutSimplestExamples(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"windmill_rotation_speed\": TAU / 8,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.two_points()\n",
        "        self.add_third_point()\n",
        "        self.add_fourth_point()\n",
        "        self.move_starting_line()\n",
        "\n",
        "    def two_points(self):\n",
        "        points = [1.5 * LEFT, 1.5 * RIGHT]\n",
        "        dots = self.dots = self.get_dots(points)\n",
        "        windmill = self.windmill = self.get_windmill(points, angle=TAU / 8)\n",
        "        pivot_dot = self.pivot_dot = self.get_pivot_dot(windmill)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(windmill),\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, dots,\n",
        "                scale_factor=10,\n",
        "                run_time=1,\n",
        "                lag_ratio=0.4,\n",
        "            ),\n",
        "            GrowFromCenter(pivot_dot),\n",
        "        )\n",
        "        self.let_windmill_run(windmill, 8)\n",
        "\n",
        "    def add_third_point(self):\n",
        "        windmill = self.windmill\n",
        "\n",
        "        new_point = 2 * DOWN\n",
        "        new_dot = self.get_dots([new_point])\n",
        "        windmill.point_set.append(new_point)\n",
        "\n",
        "        self.add(new_dot, self.pivot_dot)\n",
        "        self.play(FadeInFromLarge(new_dot, scale_factor=10))\n",
        "        self.let_windmill_run(windmill, 8)\n",
        "\n",
        "    def add_fourth_point(self):\n",
        "        windmill = self.windmill\n",
        "        dot = self.get_dots([ORIGIN])\n",
        "        dot.move_to(DOWN + 2 * RIGHT)\n",
        "        words = OldTexText(\"Never hit!\")\n",
        "        words.set_color(RED)\n",
        "        words.scale(0.75)\n",
        "        words.move_to(0.7 * DOWN, DOWN)\n",
        "\n",
        "        self.add(dot, self.pivot_dot)\n",
        "        self.play(\n",
        "            FadeInFromLarge(dot, scale_factor=10)\n",
        "        )\n",
        "        windmill.point_set.append(dot.get_center())\n",
        "        windmill.rot_speed = TAU / 4\n",
        "        self.let_windmill_run(windmill, 4)\n",
        "\n",
        "        # Shift point\n",
        "        self.play(\n",
        "            dot.next_to, words, DOWN,\n",
        "            FadeIn(words, RIGHT),\n",
        "        )\n",
        "        windmill.point_set[3] = dot.get_center()\n",
        "        self.let_windmill_run(windmill, 4)\n",
        "        self.wait()\n",
        "\n",
        "        self.dots.add(dot)\n",
        "        self.never_hit_words = words\n",
        "\n",
        "    def move_starting_line(self):\n",
        "        windmill = self.windmill\n",
        "        dots = self.dots\n",
        "\n",
        "        windmill.suspend_updating()\n",
        "        self.play(\n",
        "            windmill.move_to, dots[-1],\n",
        "            FadeOut(self.never_hit_words),\n",
        "        )\n",
        "        windmill.pivot = dots[-1].get_center()\n",
        "        windmill.resume_updating()\n",
        "\n",
        "        counters = self.get_pivot_counters(windmill)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                FadeIn(counter, DOWN)\n",
        "                for counter in counters\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        windmill.rot_speed = TAU / 8\n",
        "        self.let_windmill_run(windmill, 16)\n",
        "        highlight = windmill.copy()\n",
        "        highlight.set_stroke(YELLOW, 4)\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(highlight),\n",
        "        )\n",
        "        self.let_windmill_run(windmill, 8)\n",
        "\n",
        "\n",
        "class FearedCase(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 25,\n",
        "        \"windmill_rotation_speed\": TAU / 16,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        points = self.get_random_point_set(self.n_points)\n",
        "        sorted_points = sorted(list(points), key=lambda p: p[1])\n",
        "\n",
        "        dots = self.get_dots(points)\n",
        "        windmill = self.get_windmill(\n",
        "            points,\n",
        "            sorted_points[self.n_points // 2],\n",
        "            angle=0,\n",
        "        )\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "        # self.add_dot_color_updater(dots, windmill)\n",
        "        counters = self.get_pivot_counters(\n",
        "            windmill,\n",
        "            counter_height=0.15,\n",
        "            buff=0.1\n",
        "        )\n",
        "\n",
        "        self.add(windmill)\n",
        "        self.add(dots)\n",
        "        self.add(pivot_dot)\n",
        "        self.add(counters)\n",
        "\n",
        "        self.let_windmill_run(windmill, 32)\n",
        "        windmill.pivot = sorted_points[0]\n",
        "        self.let_windmill_run(windmill, 32)\n",
        "\n",
        "\n",
        "class WhereItStartsItEnds(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 11,\n",
        "        \"windmill_rotation_speed\": TAU / 8,\n",
        "        \"random_seed\": 1,\n",
        "        \"points_shift_val\": 2 * LEFT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_stays_in_middle()\n",
        "        self.ask_about_proof()\n",
        "\n",
        "    def show_stays_in_middle(self):\n",
        "        points = self.get_random_point_set(self.n_points)\n",
        "        points += self.points_shift_val\n",
        "        sorted_points = sorted(list(points), key=lambda p: p[1])\n",
        "        dots = self.get_dots(points)\n",
        "\n",
        "        windmill = self.get_windmill(\n",
        "            points,\n",
        "            sorted_points[self.n_points // 2],\n",
        "            angle=0\n",
        "        )\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "\n",
        "        sf = 1.25\n",
        "        start_words = OldTexText(\"Starts in the \", \"``middle''\")\n",
        "        start_words.scale(sf)\n",
        "        start_words.next_to(windmill, UP, MED_SMALL_BUFF)\n",
        "        start_words.to_edge(RIGHT)\n",
        "        end_words = OldTexText(\"Stays in the \", \"``middle''\")\n",
        "        end_words.scale(sf)\n",
        "        end_words.next_to(windmill, DOWN, MED_SMALL_BUFF)\n",
        "        end_words.to_edge(RIGHT)\n",
        "        start_words.match_x(end_words)\n",
        "\n",
        "        self.add(dots)\n",
        "        self.play(\n",
        "            ShowCreation(windmill),\n",
        "            GrowFromCenter(pivot_dot),\n",
        "            FadeIn(start_words, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.start_leaving_shadows()\n",
        "        self.add(windmill, dots, pivot_dot)\n",
        "        half_time = PI / windmill.rot_speed\n",
        "        self.let_windmill_run(windmill, time=half_time)\n",
        "        self.play(FadeIn(end_words, UP))\n",
        "        self.wait()\n",
        "        self.let_windmill_run(windmill, time=half_time)\n",
        "        self.wait()\n",
        "\n",
        "        self.start_words = start_words\n",
        "        self.end_words = end_words\n",
        "        self.windmill = windmill\n",
        "        self.dots = dots\n",
        "        self.pivot_dot = pivot_dot\n",
        "\n",
        "    def ask_about_proof(self):\n",
        "        sf = 1.25\n",
        "        middle_rects = self.get_middle_rects()\n",
        "        middle_words = OldTexText(\"Can you formalize this?\")\n",
        "        middle_words.scale(sf)\n",
        "        middle_words.next_to(middle_rects, DOWN, MED_LARGE_BUFF)\n",
        "        middle_words.to_edge(RIGHT)\n",
        "        middle_words.match_color(middle_rects)\n",
        "\n",
        "        proof_words = OldTexText(\"Can you prove this?\")\n",
        "        proof_words.next_to(\n",
        "            self.end_words.get_left(),\n",
        "            DL,\n",
        "            buff=2,\n",
        "        )\n",
        "        proof_words.shift(RIGHT)\n",
        "        proof_words.scale(sf)\n",
        "        proof_arrow = Arrow(\n",
        "            proof_words.get_top(),\n",
        "            self.end_words.get_corner(DL),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        proof_words2 = OldTexText(\"Then prove the result?\")\n",
        "        proof_words2.scale(sf)\n",
        "        proof_words2.next_to(middle_words, DOWN, MED_LARGE_BUFF)\n",
        "        proof_words2.to_edge(RIGHT)\n",
        "        VGroup(proof_words, proof_words2, proof_arrow).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(proof_words),\n",
        "            GrowArrow(proof_arrow),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(proof_arrow),\n",
        "            FadeOut(proof_words),\n",
        "            LaggedStartMap(ShowCreation, middle_rects),\n",
        "            Write(middle_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(proof_words2, UP))\n",
        "        self.wait()\n",
        "        self.let_windmill_run(self.windmill, time=10)\n",
        "\n",
        "    def get_middle_rects(self):\n",
        "        middle_rects = VGroup(*[\n",
        "            SurroundingRectangle(words[1])\n",
        "            for words in [\n",
        "                self.start_words,\n",
        "                self.end_words\n",
        "            ]\n",
        "        ])\n",
        "        middle_rects.set_color(TEAL)\n",
        "        return middle_rects\n",
        "\n",
        "\n",
        "class AltWhereItStartsItEnds(WhereItStartsItEnds):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 9,\n",
        "        \"random_seed\": 3,\n",
        "    }\n",
        "\n",
        "\n",
        "class FormalizeMiddle(WhereItStartsItEnds):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "        \"points_shift_val\": 3 * LEFT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_stays_in_middle()\n",
        "        self.problem_solving_tip()\n",
        "        self.define_colors()\n",
        "        self.mention_odd_case()\n",
        "        self.ask_about_numbers()\n",
        "\n",
        "    def problem_solving_tip(self):\n",
        "        mid_words = VGroup(\n",
        "            self.start_words,\n",
        "            self.end_words,\n",
        "        )\n",
        "        mid_words.save_state()\n",
        "\n",
        "        sf = 1.25\n",
        "        pst = OldTexText(\"Problem-solving tip:\")\n",
        "        pst.scale(sf)\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.match_width(pst)\n",
        "        underline.move_to(pst.get_bottom())\n",
        "        pst.add(underline)\n",
        "        pst.to_corner(UR)\n",
        "        # pst.set_color(YELLOW)\n",
        "\n",
        "        steps = VGroup(\n",
        "            OldTexText(\"Vague idea\"),\n",
        "            OldTexText(\"Put numbers to it\"),\n",
        "            OldTexText(\"Ask about those numbers\"),\n",
        "        )\n",
        "        steps.scale(sf)\n",
        "        steps.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        steps.next_to(pst, DOWN, buff=MED_LARGE_BUFF)\n",
        "        steps.shift_onto_screen()\n",
        "        pst.match_x(steps)\n",
        "\n",
        "        colors = color_gradient([BLUE, YELLOW], 3)\n",
        "        for step, color in zip(steps, colors):\n",
        "            step.set_color(color)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for s1, s2 in zip(steps, steps[1:]):\n",
        "            arrow = Arrow(s1.get_bottom(), s2.get_top(), buff=SMALL_BUFF)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        self.play(Write(pst), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mid_words.scale, 0.75,\n",
        "            mid_words.set_opacity, 0.25,\n",
        "            mid_words.to_corner, DL,\n",
        "            FadeInFromDown(steps[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        for arrow, step in zip(arrows, steps[1:]):\n",
        "            self.play(\n",
        "                FadeIn(step, UP),\n",
        "                GrowArrow(arrow),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        steps.generate_target()\n",
        "        steps.target.scale(0.75)\n",
        "        steps.target.arrange(DOWN, buff=0.2)\n",
        "        steps.target.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(pst),\n",
        "            MoveToTarget(steps),\n",
        "            Restore(mid_words),\n",
        "            FadeOut(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.tip_words = steps\n",
        "        self.mid_words = mid_words\n",
        "\n",
        "    def define_colors(self):\n",
        "        windmill = self.windmill\n",
        "        mid_words = self.mid_words\n",
        "        tip_words = self.tip_words\n",
        "        shadows = self.windmill_shadows\n",
        "        self.leave_shadows = False\n",
        "\n",
        "        full_time = TAU / windmill.rot_speed\n",
        "\n",
        "        self.play(FadeOut(shadows))\n",
        "        self.add(windmill, tip_words, mid_words, self.dots, self.pivot_dot)\n",
        "        self.let_windmill_run(windmill, time=full_time / 4)\n",
        "        windmill.rotate(PI)\n",
        "        self.wait()\n",
        "\n",
        "        # Show regions\n",
        "        rects = self.get_left_right_colorings(windmill)\n",
        "        rects.suspend_updating()\n",
        "        rects.save_state()\n",
        "        rects.stretch(0, 0, about_point=windmill.get_center())\n",
        "\n",
        "        counters = VGroup(Integer(0), Integer(0))\n",
        "        counters.scale(2)\n",
        "        counters[0].set_stroke(BLUE, 3, background=True)\n",
        "        counters[1].set_stroke(GREY_BROWN, 3, background=True)\n",
        "\n",
        "        new_dots = self.dots.copy()\n",
        "        new_dots.set_color(WHITE)\n",
        "        for dot in new_dots:\n",
        "            dot.scale(1.25)\n",
        "        new_dots.sort(lambda p: p[0])\n",
        "        k = self.n_points // 2\n",
        "        dot_sets = VGroup(new_dots[:k], new_dots[-k:])\n",
        "\n",
        "        label_sets = VGroup()\n",
        "        for dot_set, direction in zip(dot_sets, [LEFT, RIGHT]):\n",
        "            label_set = VGroup()\n",
        "            for i, dot in zip(it.count(1), dot_set):\n",
        "                label = Integer(i)\n",
        "                label.set_height(0.15)\n",
        "                label.next_to(dot, direction, SMALL_BUFF)\n",
        "                label_set.add(label)\n",
        "            label_sets.add(label_set)\n",
        "\n",
        "        for counter, dot_set in zip(counters, dot_sets):\n",
        "            counter.move_to(dot_set)\n",
        "            counter.to_edge(UP)\n",
        "\n",
        "        self.add(rects, *self.get_mobjects())\n",
        "        self.play(\n",
        "            Restore(rects),\n",
        "            FadeIn(counters),\n",
        "        )\n",
        "        for counter, dot_set, label_set in zip(counters, dot_sets, label_sets):\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(dot_set),\n",
        "                ShowIncreasingSubsets(label_set),\n",
        "                ChangingDecimal(counter, lambda a: len(dot_set)),\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(self.dots)\n",
        "        self.dots = new_dots\n",
        "\n",
        "        # Show orientation\n",
        "        tips = self.get_orientation_arrows(windmill)\n",
        "\n",
        "        self.play(ShowCreation(tips))\n",
        "        windmill.add(tips)\n",
        "        self.wait()\n",
        "\n",
        "        self.add_dot_color_updater(new_dots, windmill)\n",
        "\n",
        "        rects.suspend_updating()\n",
        "        for rect in rects:\n",
        "            self.play(rect.set_opacity, 1)\n",
        "            self.play(rect.set_opacity, rects.const_opacity)\n",
        "        rects.resume_updating()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            counters.space_out_submobjects, 0.8,\n",
        "            counters.next_to, mid_words, DOWN, LARGE_BUFF,\n",
        "            FadeOut(label_sets),\n",
        "        )\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.scale(2)\n",
        "        eq.move_to(counters)\n",
        "        self.play(FadeIn(eq))\n",
        "        self.wait()\n",
        "\n",
        "        self.counters = counters\n",
        "        self.colored_regions = rects\n",
        "        rects.resume_updating()\n",
        "\n",
        "    def mention_odd_case(self):\n",
        "        dots = self.dots\n",
        "        counters = self.counters\n",
        "\n",
        "        sf = 1.0\n",
        "        words = OldTexText(\n",
        "            \"Assume odd \\\\# points\"\n",
        "        )\n",
        "        words.scale(sf)\n",
        "        words.to_corner(UL)\n",
        "        example = VGroup(\n",
        "            OldTexText(\"Example:\"),\n",
        "            Integer(0)\n",
        "        )\n",
        "        example.arrange(RIGHT)\n",
        "        example.scale(sf)\n",
        "        example.next_to(words, DOWN)\n",
        "        example.align_to(words, LEFT)\n",
        "\n",
        "        k = self.n_points // 2\n",
        "        dot_rects = VGroup()\n",
        "        for i, dot in zip(it.count(1), dots):\n",
        "            dot_rect = SurroundingRectangle(dot)\n",
        "            dot_rect.match_color(dot)\n",
        "            dot_rects.add(dot_rect)\n",
        "\n",
        "        self.play(FadeIn(words, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(dots[k]),\n",
        "            self.pivot_dot.set_color, WHITE,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(example, UP))\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(dot_rects),\n",
        "            ChangingDecimal(\n",
        "                example[1],\n",
        "                lambda a: len(dot_rects)\n",
        "            ),\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(dot_rects)\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(dot_rects[:k]),\n",
        "            ShowCreationThenFadeOut(\n",
        "                SurroundingRectangle(counters[0], color=BLUE)\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(dot_rects[-k:]),\n",
        "            ShowCreationThenFadeOut(\n",
        "                SurroundingRectangle(counters[1], color=GREY_BROWN)\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(example),\n",
        "        )\n",
        "\n",
        "    def ask_about_numbers(self):\n",
        "        self.windmill.rot_speed *= 0.5\n",
        "        self.add(self.dots, self.pivot_dot)\n",
        "        self.let_windmill_run(self.windmill, 20)\n",
        "\n",
        "\n",
        "class SecondColoringExample(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"run_time\": 30,\n",
        "        \"n_points\": 9,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        points = self.get_random_point_set(self.n_points)\n",
        "        points += RIGHT\n",
        "        sorted_points = sorted(list(points), key=lambda p: p[0])\n",
        "\n",
        "        dots = self.get_dots(points)\n",
        "        windmill = self.get_windmill(\n",
        "            points,\n",
        "            pivot=sorted_points[self.n_points // 2],\n",
        "            angle=PI / 2\n",
        "        )\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "        pivot_dot.set_color(WHITE)\n",
        "        rects = self.get_left_right_colorings(windmill)\n",
        "        self.add_dot_color_updater(dots, windmill)\n",
        "\n",
        "        counts = VGroup(\n",
        "            OldTexText(\"\\\\# Blues = 4\"),\n",
        "            OldTexText(\"\\\\# Browns = 4\"),\n",
        "        )\n",
        "        counts.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "        counts.to_corner(UL)\n",
        "        counts[0].set_color(interpolate_color(BLUE, WHITE, 0.25))\n",
        "        counts[1].set_color(interpolate_color(GREY_BROWN, WHITE, 0.5))\n",
        "        counts[0].set_stroke(BLACK, 5, background=True)\n",
        "        counts[1].set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        const_words = OldTexText(\"Stay constant$\\\\dots$why?\")\n",
        "        const_words.next_to(counts, RIGHT, buff=1.5, aligned_edge=UP)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                const_words.get_left(),\n",
        "                count.get_right(),\n",
        "                buff=SMALL_BUFF,\n",
        "                max_tip_length_to_length_ratio=0.15,\n",
        "                max_stroke_width_to_length_ratio=3,\n",
        "            )\n",
        "            for count in counts\n",
        "        ])\n",
        "\n",
        "        self.add(rects, windmill, dots, pivot_dot)\n",
        "        self.add(counts, const_words, arrows)\n",
        "\n",
        "        self.let_windmill_run(windmill, time=self.run_time)\n",
        "\n",
        "\n",
        "class TalkThroughPivotChange(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"windmill_rotation_speed\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_windmill()\n",
        "        self.ask_about_pivot_change()\n",
        "        self.show_above_and_below()\n",
        "        self.change_pivot()\n",
        "\n",
        "    def setup_windmill(self):\n",
        "        points = self.points = np.array([\n",
        "            DR, UR, UL, DL, 0.5 * LEFT\n",
        "        ])\n",
        "        points *= 3\n",
        "        self.dots = self.get_dots(points)\n",
        "        self.windmill = self.get_windmill(points, points[-1])\n",
        "        self.pivot_dot = self.get_pivot_dot(self.windmill)\n",
        "        self.pivot_dot.set_color(WHITE)\n",
        "        self.add_dot_color_updater(self.dots, self.windmill)\n",
        "        self.rects = self.get_left_right_colorings(self.windmill)\n",
        "\n",
        "        self.add(\n",
        "            self.rects,\n",
        "            self.windmill,\n",
        "            self.dots,\n",
        "            self.pivot_dot,\n",
        "        )\n",
        "\n",
        "    def ask_about_pivot_change(self):\n",
        "        windmill = self.windmill\n",
        "\n",
        "        new_pivot, angle = self.next_pivot_and_angle(windmill)\n",
        "        words = OldTexText(\"Think about\\\\\\\\pivot change\")\n",
        "        words.next_to(new_pivot, UP, buff=2)\n",
        "        words.to_edge(LEFT)\n",
        "        arrow = Arrow(words.get_bottom(), new_pivot, buff=0.2)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                windmill, -0.9 * angle,\n",
        "                run_time=3,\n",
        "                rate_func=linear\n",
        "            ),\n",
        "            Write(words, run_time=1),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.question = words\n",
        "        self.question_arrow = arrow\n",
        "\n",
        "    def show_above_and_below(self):\n",
        "        windmill = self.windmill\n",
        "        vect = normalize(windmill.get_vector())\n",
        "        angle = windmill.get_angle()\n",
        "        tips = self.get_orientation_arrows(windmill)\n",
        "        top_half = Line(windmill.get_center(), windmill.get_end())\n",
        "        low_half = Line(windmill.get_center(), windmill.get_start())\n",
        "        top_half.set_stroke(YELLOW, 3)\n",
        "        low_half.set_stroke(PINK, 3)\n",
        "        halves = VGroup(top_half, low_half)\n",
        "\n",
        "        top_words = OldTexText(\"Above pivot\")\n",
        "        low_words = OldTexText(\"Below pivot\")\n",
        "        all_words = VGroup(top_words, low_words)\n",
        "        for words, half in zip(all_words, halves):\n",
        "            words.next_to(ORIGIN, DOWN)\n",
        "            words.rotate(angle, about_point=ORIGIN)\n",
        "            words.shift(half.point_from_proportion(0.15))\n",
        "            words.match_color(half)\n",
        "\n",
        "        self.play(ShowCreation(tips))\n",
        "        self.wait()\n",
        "        self.add(top_half, tips)\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(top_half),\n",
        "            FadeIn(top_words, -vect),\n",
        "        )\n",
        "        self.add(low_half, tips)\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(low_half),\n",
        "            FadeIn(low_words, vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        windmill.add(tips)\n",
        "        self.above_below_words = all_words\n",
        "\n",
        "    def change_pivot(self):\n",
        "        windmill = self.windmill\n",
        "        dots = self.dots\n",
        "        arrow = self.question_arrow\n",
        "\n",
        "        blue_rect = SurroundingRectangle(dots[3])\n",
        "        blue_rect.set_color(BLUE)\n",
        "        new_pivot_word = OldTexText(\"New pivot\")\n",
        "        new_pivot_word.next_to(blue_rect, LEFT)\n",
        "        old_pivot_word = OldTexText(\"Old pivot\")\n",
        "        old_pivot = windmill.pivot\n",
        "        old_pivot_word.next_to(\n",
        "            old_pivot, LEFT,\n",
        "            buff=SMALL_BUFF + MED_SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.above_below_words),\n",
        "            ReplacementTransform(\n",
        "                self.question,\n",
        "                new_pivot_word,\n",
        "            ),\n",
        "            ReplacementTransform(arrow, blue_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        anims, time = self.rotate_to_next_pivot(windmill)\n",
        "        self.play(\n",
        "            *anims,\n",
        "            Rotate(\n",
        "                windmill,\n",
        "                angle=-windmill.rot_speed,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(new_pivot_word, old_pivot_word),\n",
        "            blue_rect.move_to, old_pivot,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Hit new point\n",
        "        brown_rect = SurroundingRectangle(dots[1])\n",
        "        brown_rect.set_color(GREY_BROWN)\n",
        "\n",
        "        self.play(TransformFromCopy(blue_rect, brown_rect))\n",
        "        self.play(\n",
        "            blue_rect.move_to, windmill.pivot,\n",
        "            blue_rect.set_color, GREY_BROWN,\n",
        "            old_pivot_word.move_to, new_pivot_word,\n",
        "            FadeOut(new_pivot_word, DL)\n",
        "        )\n",
        "        self.let_windmill_run(windmill, 1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(old_pivot_word),\n",
        "            FadeOut(blue_rect),\n",
        "            FadeOut(brown_rect),\n",
        "        )\n",
        "        self.let_windmill_run(windmill, 20)\n",
        "\n",
        "\n",
        "class InsightNumber1(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Key insight 1: \",\n",
        "            \"\\\\# Points on either side is constant\"\n",
        "        )\n",
        "        words[0].set_color(YELLOW)\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        self.play(FadeInFromDown(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Rotate180Argument(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 21,\n",
        "        \"random_seed\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_windmill()\n",
        "        self.add_total_rotation_label()\n",
        "        self.rotate_180()\n",
        "        self.show_parallel_lines()\n",
        "        self.rotate_180()\n",
        "        self.rotate_180()\n",
        "\n",
        "    def setup_windmill(self):\n",
        "        n = self.n_points\n",
        "        points = self.get_random_point_set(n)\n",
        "        points[:, 0] *= 1.5\n",
        "        points += RIGHT\n",
        "        points = sorted(points, key=lambda p: p[0])\n",
        "        mid_point = points[n // 2]\n",
        "        points[n // 2 - 1] += 0.2 * LEFT\n",
        "        self.points = points\n",
        "\n",
        "        self.dots = self.get_dots(points)\n",
        "        self.windmill = self.get_windmill(points, mid_point)\n",
        "        self.pivot_dot = self.get_pivot_dot(self.windmill)\n",
        "        self.pivot_dot.set_color(WHITE)\n",
        "        self.add_dot_color_updater(self.dots, self.windmill)\n",
        "        self.rects = self.get_left_right_colorings(self.windmill)\n",
        "\n",
        "        p_label = OldTex(\"P_0\")\n",
        "        p_label.next_to(mid_point, RIGHT, SMALL_BUFF)\n",
        "        self.p_label = p_label\n",
        "\n",
        "        self.add(\n",
        "            self.rects,\n",
        "            self.windmill,\n",
        "            self.dots,\n",
        "            self.pivot_dot,\n",
        "            self.p_label,\n",
        "        )\n",
        "\n",
        "    def add_total_rotation_label(self):\n",
        "        windmill = self.windmill\n",
        "\n",
        "        words = OldTexText(\"Total rotation:\")\n",
        "        counter = Integer(0, unit=\"^\\\\circ\")\n",
        "        title = VGroup(words, counter)\n",
        "        title.arrange(RIGHT)\n",
        "        title.to_corner(UL)\n",
        "        rot_arrow = Vector(UP)\n",
        "        rot_arrow.set_color(RED)\n",
        "        rot_arrow.next_to(title, DOWN)\n",
        "        circle = Circle()\n",
        "        circle.replace(rot_arrow, dim_to_match=1)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "\n",
        "        rot_arrow.add_updater(\n",
        "            lambda m: m.set_angle(windmill.get_angle())\n",
        "        )\n",
        "        rot_arrow.add_updater(\n",
        "            lambda m: m.move_to(circle)\n",
        "        )\n",
        "\n",
        "        def update_count(c):\n",
        "            new_val = 90 - windmill.get_angle() * 360 / TAU\n",
        "            while abs(new_val - c.get_value()) > 90:\n",
        "                new_val += 360\n",
        "            c.set_value(new_val)\n",
        "\n",
        "        counter.add_updater(update_count)\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(title, circle),\n",
        "            buff=MED_LARGE_BUFF,\n",
        "        )\n",
        "        rect.set_fill(BLACK, 0.8)\n",
        "        rect.set_stroke(WHITE, 1)\n",
        "        title.shift(MED_SMALL_BUFF * LEFT)\n",
        "\n",
        "        self.rotation_label = VGroup(\n",
        "            rect, words, counter, circle, rot_arrow\n",
        "        )\n",
        "\n",
        "        self.add(self.rotation_label)\n",
        "\n",
        "    def rotate_180(self):\n",
        "        windmill = self.windmill\n",
        "        self.add(self.pivot_dot)\n",
        "        self.let_windmill_run(\n",
        "            windmill,\n",
        "            PI / windmill.rot_speed,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_parallel_lines(self):\n",
        "        points = self.get_points()\n",
        "        rotation_label = self.rotation_label\n",
        "        dots = self.dots\n",
        "        windmill = self.windmill\n",
        "\n",
        "        lines = VGroup()\n",
        "        for point in points:\n",
        "            line = Line(DOWN, UP)\n",
        "            line.set_height(2 * FRAME_HEIGHT)\n",
        "            line.set_stroke(RED, 1, opacity=0.5)\n",
        "            line.move_to(point)\n",
        "            lines.add(line)\n",
        "        lines.shuffle()\n",
        "\n",
        "        self.add(lines, dots, rotation_label)\n",
        "        self.play(\n",
        "            ShowCreation(lines, lag_ratio=0.5, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.rects.suspend_updating()\n",
        "        for rect in self.rects:\n",
        "            self.play(\n",
        "                rect.set_opacity, 0,\n",
        "                rate_func=there_and_back,\n",
        "                run_time=2\n",
        "            )\n",
        "        self.rects.resume_updating()\n",
        "        self.wait()\n",
        "\n",
        "        pivot_tracker = VectorizedPoint(windmill.pivot)\n",
        "        pivot_tracker.save_state()\n",
        "\n",
        "        def update_pivot(w):\n",
        "            w.pivot = pivot_tracker.get_center()\n",
        "        windmill.add_updater(update_pivot)\n",
        "\n",
        "        for x in range(4):\n",
        "            point = random.choice(points)\n",
        "            self.play(\n",
        "                pivot_tracker.move_to, point\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Restore(pivot_tracker))\n",
        "        self.play(FadeOut(lines))\n",
        "        windmill.remove_updater(update_pivot)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Rotate180ArgumentFast(Rotate180Argument):\n",
        "    CONFIG = {\n",
        "        \"windmill_rotation_speed\": 0.5,\n",
        "    }\n",
        "\n",
        "\n",
        "class EvenCase(Rotate180Argument):\n",
        "    CONFIG = {\n",
        "        \"n_points\": 10,\n",
        "        \"dot_config\": {\"radius\": 0.075},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.ask_about_even_number()\n",
        "        self.choose_halfway_point()\n",
        "\n",
        "        self.add_total_rotation_label()\n",
        "        self.rotate_180()\n",
        "        self.rotate_180()\n",
        "        self.show_parallel_lines()\n",
        "        self.rotate_180()\n",
        "        self.rotate_180()\n",
        "\n",
        "    def ask_about_even_number(self):\n",
        "        n = self.n_points\n",
        "        points = self.get_random_point_set(n)\n",
        "        points[:, 0] *= 2\n",
        "        points += DOWN\n",
        "        points = sorted(points, key=lambda p: p[0])\n",
        "        dots = self.get_dots(points)\n",
        "\n",
        "        windmill = self.get_windmill(points, points[3])\n",
        "        region_rects = self.rects = self.get_left_right_colorings(windmill)\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "        pivot_dot.set_color(WHITE)\n",
        "\n",
        "        dot_rects = VGroup(*map(SurroundingRectangle, dots))\n",
        "\n",
        "        question = OldTexText(\"What about an even number?\")\n",
        "        # question.to_corner(UL)\n",
        "        question.to_edge(UP)\n",
        "        counter_label = OldTexText(\"\\\\# Points\", \":\")\n",
        "        counter = Integer(0)\n",
        "        counter_group = VGroup(counter_label, counter)\n",
        "        counter_group.arrange(RIGHT)\n",
        "        counter.align_to(counter_label[1], DOWN)\n",
        "        counter_group.next_to(question, DOWN, MED_LARGE_BUFF)\n",
        "        counter_group.set_color(YELLOW)\n",
        "        # counter_group.align_to(question, LEFT)\n",
        "\n",
        "        self.add(question, counter_label)\n",
        "        self.add(windmill, dots, pivot_dot)\n",
        "\n",
        "        self.add_dot_color_updater(dots, windmill)\n",
        "        self.add(region_rects, question, counter_group, windmill, dots, pivot_dot)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(dot_rects),\n",
        "            ChangingDecimal(counter, lambda a: len(dot_rects)),\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.play(FadeOut(dot_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # region_rects.suspend_updating()\n",
        "        # self.play(\n",
        "        #     FadeIn(region_rects),\n",
        "        #     FadeOut(dot_rects),\n",
        "        # )\n",
        "        # region_rects.resume_updating()\n",
        "        # self.wait()\n",
        "\n",
        "        # Count by color\n",
        "        blue_rects = dot_rects[:3]\n",
        "        blue_rects.set_color(BLUE)\n",
        "        brown_rects = dot_rects[4:]\n",
        "        brown_rects.set_color(GREY_BROWN)\n",
        "        pivot_rect = dot_rects[3]\n",
        "        pivot_rect.set_color(GREY_BROWN)\n",
        "\n",
        "        blues_label = OldTexText(\"\\\\# Blues\", \":\")\n",
        "        blues_counter = Integer(len(blue_rects))\n",
        "        blues_group = VGroup(blues_label, blues_counter)\n",
        "        blues_group.set_color(BLUE)\n",
        "        browns_label = OldTexText(\"\\\\# Browns\", \":\")\n",
        "        browns_counter = Integer(len(brown_rects))\n",
        "        browns_group = VGroup(browns_label, browns_counter)\n",
        "        browns_group.set_color(interpolate_color(GREY_BROWN, WHITE, 0.5))\n",
        "        groups = VGroup(blues_group, browns_group)\n",
        "        for group in groups:\n",
        "            group.arrange(RIGHT)\n",
        "            group[-1].align_to(group[0][-1], DOWN)\n",
        "        groups.arrange(DOWN, aligned_edge=LEFT)\n",
        "        groups.next_to(counter_group, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(blues_group, UP),\n",
        "            ShowCreation(blue_rects),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(browns_group, UP),\n",
        "            ShowCreation(brown_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pivot counts as brown\n",
        "        pivot_words = OldTexText(\"Pivot counts as brown\")\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(pivot_dot, RIGHT, SMALL_BUFF)\n",
        "        pivot_words.next_to(arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pivot_words, LEFT),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(pivot_rect),\n",
        "            ChangeDecimalToValue(browns_counter, len(brown_rects) + 1),\n",
        "            FadeOut(pivot_dot),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dot_rects),\n",
        "            FadeOut(pivot_words),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        blues_counter.add_updater(\n",
        "            lambda c: c.set_value(len(list(filter(\n",
        "                lambda d: d.get_fill_color() == Color(BLUE),\n",
        "                dots\n",
        "            ))))\n",
        "        )\n",
        "        browns_counter.add_updater(\n",
        "            lambda c: c.set_value(len(list(filter(\n",
        "                lambda d: d.get_fill_color() == Color(GREY_BROWN),\n",
        "                dots\n",
        "            ))))\n",
        "        )\n",
        "\n",
        "        self.windmill = windmill\n",
        "        self.dots = dots\n",
        "        self.points = points\n",
        "        self.question = question\n",
        "        self.counter_group = VGroup(\n",
        "            counter_group,\n",
        "            blues_group,\n",
        "            browns_group,\n",
        "        )\n",
        "\n",
        "    def choose_halfway_point(self):\n",
        "        windmill = self.windmill\n",
        "        points = self.points\n",
        "        n = self.n_points\n",
        "\n",
        "        p_label = OldTex(\"P_0\")\n",
        "        p_label.next_to(points[n // 2], RIGHT, SMALL_BUFF)\n",
        "\n",
        "        pivot_tracker = VectorizedPoint(windmill.pivot)\n",
        "\n",
        "        def update_pivot(w):\n",
        "            w.pivot = pivot_tracker.get_center()\n",
        "\n",
        "        windmill.add_updater(update_pivot)\n",
        "\n",
        "        self.play(\n",
        "            pivot_tracker.move_to, points[n // 2],\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeIn(p_label, LEFT))\n",
        "        self.wait()\n",
        "        windmill.remove_updater(update_pivot)\n",
        "\n",
        "    def add_total_rotation_label(self):\n",
        "        super().add_total_rotation_label()\n",
        "        self.rotation_label.scale(0.8, about_edge=UL)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.question),\n",
        "            FadeIn(self.rotation_label),\n",
        "            self.counter_group.to_edge, UP,\n",
        "        )\n",
        "\n",
        "\n",
        "class TwoTakeaways(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Two takeaways\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        line = Line()\n",
        "        line.match_width(title)\n",
        "        line.next_to(title, DOWN, SMALL_BUFF)\n",
        "\n",
        "        items = VGroup(*[\n",
        "            OldTexText(\"1) Social\"),\n",
        "            OldTexText(\"2) Mathematical\"),\n",
        "        ])\n",
        "        items.scale(1.5)\n",
        "        items.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        items.next_to(line, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            GrowFromPoint(title, self.hold_up_spot),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.wait()\n",
        "        for item in items:\n",
        "            self.play(FadeIn(item, LEFT))\n",
        "            item.big = item.copy()\n",
        "            item.small = item.copy()\n",
        "            item.big.scale(1.5, about_edge=LEFT)\n",
        "            item.big.set_color(BLUE)\n",
        "            item.small.scale(0.75, about_edge=LEFT)\n",
        "            item.small.fade(0.5)\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait()\n",
        "        for i, j in [(0, 1), (1, 0)]:\n",
        "            self.play(\n",
        "                items[i].become, items[i].big,\n",
        "                items[j].become, items[j].small,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class EasyToFoolYourself(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.to_corner(DL)\n",
        "\n",
        "        bubble = ThoughtBubble()\n",
        "        for i, part in enumerate(bubble):\n",
        "            part.shift(2 * i * SMALL_BUFF * DOWN)\n",
        "        bubble.pin_to(morty)\n",
        "\n",
        "        fool_word = OldTexText(\"Fool\")\n",
        "        fool_word.scale(1.5)\n",
        "        fool_arrow = Vector(LEFT)\n",
        "        fool_arrow.next_to(morty, RIGHT, buff=0)\n",
        "        fool_word.next_to(fool_arrow, RIGHT)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "        self.play(\n",
        "            bubble[3].set_fill, GREEN_SCREEN, 0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"thinking\")\n",
        "        self.play(\n",
        "            FadeIn(fool_word, LEFT),\n",
        "            ShowCreation(fool_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.pi_creature_says(\n",
        "            \"Isn't it\\\\\\\\obvious?\",\n",
        "            target_mode=\"maybe\",\n",
        "            added_anims=[FadeOut(bubble)]\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        #\n",
        "        words = OldTexText(\"No it's not!\")\n",
        "        words.scale(1.5)\n",
        "        words.set_color(RED)\n",
        "        words.next_to(morty.bubble, RIGHT, LARGE_BUFF)\n",
        "        words.match_y(morty.bubble.content)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromLarge(words),\n",
        "            morty.change, \"guilty\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # for i, part in enumerate(bubble):\n",
        "        #     self.add(Integer(i).move_to(part))\n",
        "\n",
        "\n",
        "class FailureToEmpathize(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy, morty = self.pi_creatures\n",
        "\n",
        "        # What a mess...\n",
        "        big_bubble = ThoughtBubble(height=4, width=5)\n",
        "        big_bubble.scale(1.75)\n",
        "        big_bubble.flip(UR)\n",
        "        for part in big_bubble:\n",
        "            part.rotate(90 * DEGREES)\n",
        "        big_bubble[:3].rotate(-30 * DEGREES)\n",
        "        for i, part in enumerate(big_bubble[:3]):\n",
        "            part.rotate(30 * DEGREES)\n",
        "            part.shift((3 - i) * SMALL_BUFF * DOWN)\n",
        "        big_bubble[0].shift(MED_SMALL_BUFF * RIGHT)\n",
        "        big_bubble[:3].next_to(big_bubble[3], LEFT)\n",
        "        big_bubble[:3].shift(0.3 * DOWN)\n",
        "        big_bubble.set_fill(GREY_E)\n",
        "        big_bubble.to_corner(UR)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\sum_{k=1}^n (2k - 1) = n^2\"\n",
        "        )\n",
        "        self.pi_creature_thinks(\n",
        "            randy, equation,\n",
        "            target_mode=\"confused\",\n",
        "            look_at=equation,\n",
        "        )\n",
        "        randy_group = VGroup(\n",
        "            randy, randy.bubble,\n",
        "            randy.bubble.content\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            DrawBorderThenFill(big_bubble),\n",
        "            morty.change, \"confused\",\n",
        "            randy_group.scale, 0.5,\n",
        "            randy_group.move_to, big_bubble.get_bubble_center(),\n",
        "            randy_group.shift, 0.5 * DOWN + RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"maybe\")\n",
        "        self.wait(2)\n",
        "\n",
        "        # Zoom out\n",
        "        morty_group = VGroup(morty, big_bubble)\n",
        "        ap = 5 * RIGHT + 2.5 * UP\n",
        "        self.add(morty_group, randy_group)\n",
        "        self.play(\n",
        "            morty_group.scale, 2, {\"about_point\": ap},\n",
        "            morty_group.fade, 1,\n",
        "            randy_group.scale, 2, {\"about_point\": ap},\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph()\n",
        "        morty = Mortimer()\n",
        "        randy.flip().to_corner(DR)\n",
        "        morty.flip().to_corner(DL)\n",
        "\n",
        "        return (randy, morty)\n",
        "\n",
        "\n",
        "class DifficultyEstimateVsReality(Scene):\n",
        "    def construct(self):\n",
        "        axes = Axes(\n",
        "            x_min=-1,\n",
        "            x_max=10,\n",
        "            x_axis_config={\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            y_min=-1,\n",
        "            y_max=5,\n",
        "        )\n",
        "        axes.set_height(FRAME_HEIGHT - 1)\n",
        "        axes.center()\n",
        "        axes.x_axis.tick_marks.set_opacity(0)\n",
        "\n",
        "        y_label = OldTexText(\"Average score\")\n",
        "        y_label.scale(1.25)\n",
        "        y_label.rotate(90 * DEGREES)\n",
        "        y_label.next_to(axes.y_axis, LEFT, SMALL_BUFF)\n",
        "        y_label.shift(UP)\n",
        "\n",
        "        estimated = [1.8, 2.6, 3, 4, 5]\n",
        "        actual = [1.5, 0.5, 1, 1.2, 1.8]\n",
        "\n",
        "        colors = [GREEN, RED]\n",
        "        estimated_color, actual_color = colors\n",
        "\n",
        "        estimated_bars = VGroup()\n",
        "        actual_bars = VGroup()\n",
        "        bar_pairs = VGroup()\n",
        "\n",
        "        width = 0.25\n",
        "        for a, e in zip(actual, estimated):\n",
        "            bars = VGroup(\n",
        "                Rectangle(width=width, height=e),\n",
        "                Rectangle(width=width, height=a),\n",
        "            )\n",
        "            bars.set_stroke(width=1)\n",
        "            bars[0].set_fill(estimated_color, 0.75)\n",
        "            bars[1].set_fill(actual_color, 0.75)\n",
        "            bars.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "            bar_pairs.add(bars)\n",
        "            estimated_bars.add(bars[0])\n",
        "            actual_bars.add(bars[1])\n",
        "\n",
        "        bar_pairs.arrange(RIGHT, buff=1.5, aligned_edge=DOWN)\n",
        "        bar_pairs.move_to(axes.c2p(5, 0), DOWN)\n",
        "        for bp in bar_pairs:\n",
        "            for bar in bp:\n",
        "                bar.save_state()\n",
        "                bar.stretch(0, 1, about_edge=DOWN)\n",
        "\n",
        "        x_labels = VGroup(*[\n",
        "            OldTexText(\"Q{}\".format(i)).next_to(bp, DOWN)\n",
        "            for i, bp in zip(it.count(1), bar_pairs)\n",
        "        ])\n",
        "\n",
        "        data_labels = VGroup(\n",
        "            OldTexText(\"Estimated average\"),\n",
        "            OldTexText(\"Actual average\"),\n",
        "        )\n",
        "        data_labels.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        data_labels.to_edge(UP)\n",
        "        for color, label in zip(colors, data_labels):\n",
        "            square = Square()\n",
        "            square.set_height(0.5)\n",
        "            square.set_fill(color, 0.75)\n",
        "            square.set_stroke(WHITE, 1)\n",
        "            square.next_to(label, LEFT, SMALL_BUFF)\n",
        "            label.add(square)\n",
        "\n",
        "        self.play(Write(axes))\n",
        "        self.play(Write(y_label))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, x_labels,\n",
        "                lambda m: (m, UP),\n",
        "                run_time=2,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                Restore,\n",
        "                estimated_bars,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            FadeIn(data_labels[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Restore,\n",
        "                actual_bars,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            FadeIn(data_labels[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KeepInMindWhenTeaching(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"I don't know\\\\\\\\what you know!\",\n",
        "            target_mode=\"pleading\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                self.students[0], \"We know\",\n",
        "                target_mode=\"hooray\",\n",
        "            ),\n",
        "            self.students[1].change, \"happy\",\n",
        "            self.students[2].change, \"happy\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class VastSpaceOfConsiderations(Scene):\n",
        "    def construct(self):\n",
        "        considerations = VGroup(*[\n",
        "            OldTexText(phrase)\n",
        "            for phrase in [\n",
        "                \"Define ``outer'' points\",\n",
        "                \"Convex hulls\",\n",
        "                \"Linear equations\",\n",
        "                \"Sort points by when they're hit\",\n",
        "                \"Sort points by some kind of angle?\",\n",
        "                \"How does this permute the $n \\\\choose 2$ lines through pairs?\",\n",
        "                \"Some points are hit more than others, can we quantify this?\",\n",
        "            ]\n",
        "        ])\n",
        "        considerations.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        considerations.to_edge(LEFT)\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeIn(mob, UP)\n",
        "            for mob in considerations\n",
        "        ], run_time=3, lag_ratio=0.2))\n",
        "\n",
        "\n",
        "class WhatStaysConstantWrapper(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"background_color\": GREY_E\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_height(6)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        title1 = OldTexText(\"What stays constant?\")\n",
        "        title2 = OldTexText(\"Find an \", \"``invariant''\")\n",
        "        title2[1].set_color(YELLOW)\n",
        "        for title in [title1, title2]:\n",
        "            title.scale(2)\n",
        "            title.to_edge(UP)\n",
        "        rect.next_to(title1, DOWN)\n",
        "\n",
        "        self.add(rect)\n",
        "        self.play(FadeInFromDown(title1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(title1, UP),\n",
        "            FadeInFromDown(title2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CountHoles(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"Genus \", \"0\"),\n",
        "            OldTexText(\"Genus \", \"1\"),\n",
        "            OldTexText(\"Genus \", \"2\"),\n",
        "        )\n",
        "\n",
        "        labels.scale(2)\n",
        "        labels.arrange(RIGHT, buff=1.5)\n",
        "        labels.move_to(2 * DOWN)\n",
        "\n",
        "        equation = OldTex(\"y^2 = x^3 + ax + b\")\n",
        "        equation.scale(1.5)\n",
        "        equation.shift(UP)\n",
        "        equation.to_edge(LEFT)\n",
        "        # arrow = OldTex(\"\\\\approx\").scale(2)\n",
        "        arrow = Vector(2 * RIGHT)\n",
        "        arrow.next_to(equation, RIGHT)\n",
        "\n",
        "        equation_text = OldTexText(\"Some other problem\")\n",
        "        equation_text.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "        equation_text.match_width(equation)\n",
        "        equation_text.set_color(YELLOW)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, labels,\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            labels[1].shift, 4 * RIGHT,\n",
        "            FadeOut(labels[0::2]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(equation, RIGHT),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.play(FadeIn(equation_text, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LorenzTransform(Scene):\n",
        "    def construct(self):\n",
        "        grid = NumberPlane(\n",
        "            # faded_line_ratio=0,\n",
        "            # y_axis_config={\n",
        "            #     \"y_min\": -10,\n",
        "            #     \"y_max\": 10,\n",
        "            # }\n",
        "        )\n",
        "        grid.scale(2)\n",
        "        back_grid = grid.copy()\n",
        "        back_grid.set_stroke(GREY, 0.5)\n",
        "        # back_grid.set_opacity(0.5)\n",
        "\n",
        "        c_lines = VGroup(Line(DL, UR), Line(DR, UL))\n",
        "        c_lines.scale(FRAME_HEIGHT)\n",
        "        c_lines.set_stroke(YELLOW, 3)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"d\\\\tau^2 = dt^2 - dx^2\"\n",
        "        )\n",
        "        equation.scale(1.7)\n",
        "        equation.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        equation.shift(2.75 * DOWN)\n",
        "        equation.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.add(back_grid, grid, c_lines)\n",
        "        self.add(equation)\n",
        "        beta = 0.4\n",
        "        self.play(\n",
        "            grid.apply_matrix, np.array([\n",
        "                [1, beta],\n",
        "                [beta, 1],\n",
        "            ]) / (1 - beta**2),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OnceACleverDiscovery(Scene):\n",
        "    def construct(self):\n",
        "        energy = OldTexText(\"energy\")\n",
        "        rect = SurroundingRectangle(energy)\n",
        "        words = OldTexText(\"Once a clever discovery\")\n",
        "        vect = Vector(DR)\n",
        "        vect.next_to(rect.get_top(), UL, SMALL_BUFF)\n",
        "        words.next_to(vect.get_start(), UP)\n",
        "        words.set_color(YELLOW)\n",
        "        vect.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(vect),\n",
        "            ShowCreation(rect),\n",
        "        )\n",
        "        self.play(FadeInFromDown(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TerryTaoQuote(Scene):\n",
        "    def construct(self):\n",
        "        image = ImageMobject(\"TerryTao\")\n",
        "        image.set_height(4)\n",
        "        name = OldTexText(\"Terence Tao\")\n",
        "        name.scale(1.5)\n",
        "        name.next_to(image, DOWN, buff=0.2)\n",
        "        tao = Group(image, name)\n",
        "        tao.to_corner(DL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        tiny_tao = ImageMobject(\"TerryTaoIMO\")\n",
        "        tiny_tao.match_height(image)\n",
        "        tiny_tao.next_to(image, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        quote = self.get_quote()\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(image),\n",
        "            Write(name),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(tiny_tao, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(tiny_tao))\n",
        "\n",
        "        #\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                quote,\n",
        "                lag_ratio=0.05,\n",
        "                run_time=5,\n",
        "                rate_func=bezier([0, 0, 1, 1])\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        story_line = Line()\n",
        "        story_line.match_width(quote.story_part)\n",
        "        story_line.next_to(quote.story_part, DOWN, buff=0)\n",
        "        story_line.set_color(TEAL),\n",
        "        self.play(\n",
        "            quote.story_part.set_color, TEAL,\n",
        "            ShowCreation(story_line),\n",
        "            lag_ratio=0.2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_quote(self):\n",
        "        story_words = \"fables, stories, and anecdotes\"\n",
        "        quote = OldTexText(\n",
        "            \"\"\"\n",
        "            \\\\Large\n",
        "            ``Mathematical problems, or puzzles, are important to real mathematics\n",
        "            (like solving real-life problems), just as fables, stories, and anecdotes\n",
        "            are important to the young in understanding real life.''\\\\\\\\\n",
        "            \"\"\",\n",
        "            alignment=\"\",\n",
        "            arg_separator=\" \",\n",
        "            isolate=[story_words]\n",
        "        )\n",
        "        quote.story_part = quote.get_part_by_tex(story_words)\n",
        "        quote.set_width(FRAME_WIDTH - 2.5)\n",
        "        quote.to_edge(UP)\n",
        "\n",
        "        return quote\n",
        "\n",
        "\n",
        "class WindmillFairyTale(Scene):\n",
        "    def construct(self):\n",
        "        paths = SVGMobject(file_name=\"windmill_fairytale\")\n",
        "\n",
        "        paths.set_height(FRAME_HEIGHT - 1)\n",
        "        paths.set_stroke(width=0)\n",
        "        paths.set_fill([GREY_B, WHITE])\n",
        "\n",
        "        for path in paths:\n",
        "            path.reverse_points()\n",
        "\n",
        "        self.play(Write(paths[0], run_time=3))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeIn(paths[1], RIGHT),\n",
        "                FadeIn(paths[2], RIGHT),\n",
        "                lag_ratio=0.2,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "class SolveAProblemOneDay(SpiritOfIMO, PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        light_bulb = Lightbulb()\n",
        "        light_bulb.base = light_bulb[:3]\n",
        "        light_bulb.light = light_bulb[3:]\n",
        "        light_bulb.set_height(1)\n",
        "        light_bulb.next_to(randy, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        light = self.get_light(light_bulb.get_center())\n",
        "\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.pin_to(randy)\n",
        "\n",
        "        you = OldTexText(\"You\")\n",
        "        you.scale(1.5)\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(randy, RIGHT)\n",
        "        you.next_to(arrow)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(you, LEFT),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeInFromDown(light_bulb),\n",
        "            randy.change, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                VFadeInThenOut, light,\n",
        "                run_time=2\n",
        "            ),\n",
        "            randy.change, \"thinking\", light,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class QuixoteReference(Scene):\n",
        "    def construct(self):\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_fill([GREY_D, GREY])\n",
        "\n",
        "        windmill = SVGMobject(\"windmill\")\n",
        "        windmill.set_fill([GREY_BROWN, WHITE], 1)\n",
        "        windmill.set_stroke(width=0)\n",
        "        windmill.set_height(6)\n",
        "        windmill.to_edge(RIGHT)\n",
        "        # windmill.to_edge(DOWN, buff=0)\n",
        "\n",
        "        quixote = SVGMobject(\"quixote\")\n",
        "        quixote.flip()\n",
        "        quixote.set_height(4)\n",
        "        quixote.to_edge(LEFT)\n",
        "        quixote.set_stroke(BLACK, width=0)\n",
        "        quixote.set_fill(BLACK, 1)\n",
        "        quixote.align_to(windmill, DOWN)\n",
        "\n",
        "        self.add(rect)\n",
        "        # self.add(windmill)\n",
        "        self.play(LaggedStart(\n",
        "            DrawBorderThenFill(windmill),\n",
        "            DrawBorderThenFill(\n",
        "                quixote,\n",
        "                stroke_width=1,\n",
        "            ),\n",
        "            lag_ratio=0.4,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WindmillEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Kurt Dicus\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Davie Willimoto\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Hardik Meisheri\",\n",
        "            \"L. Z.\",\n",
        "            \"Matt Russell\",\n",
        "            \"Scott Gray\",\n",
        "            \"soekul\",\n",
        "            \"Tihan Seale\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Richard Barthel\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Arthur Zey\",\n",
        "            \"dave nicponski\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"kkm\",\n",
        "            \"Lambda AI Hardware\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Mark Heising\",\n",
        "            \"Nicholas Cahill\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Quantopian\",\n",
        "            \"Roy Larson\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Tauba Auerbach\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yu Jun\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"David Gow\",\n",
        "            \"J\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Aidan Shenkman\",\n",
        "            \"Alex Mijalis\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Andreas Benjamin Br\u00f6ssel\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Ankalagon\",\n",
        "            \"Antoine Bruguier\",\n",
        "            \"Antonio Juarez\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Austin Goodman\",\n",
        "            \"Awoo\",\n",
        "            \"Ayan Doss\",\n",
        "            \"AZsorcerer\",\n",
        "            \"Barry Fam\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Bradley Pirtle\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Charlie N\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Danger Dai\",\n",
        "            \"Daniel Pang\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"David B. Hill\",\n",
        "            \"David Clark\",\n",
        "            \"DeathByShrimp\",\n",
        "            \"Delton Ding\",\n",
        "            \"Dheeraj Vepakomma\",\n",
        "            \"eaglle\",\n",
        "            \"Empirasign\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Ero Carrera\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Fernando Via Canel\",\n",
        "            \"Gero Bone-Winkel\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"Isaac Jeffrey Lee\",\n",
        "            \"Ivan Sorokin\",\n",
        "            \"j eduardo perez\",\n",
        "            \"Jacob Harmon\",\n",
        "            \"Jacob Hartmann\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"John C. Vesey\",\n",
        "            \"John Griffith\",\n",
        "            \"John Haley\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Jordan A Purcell\",\n",
        "            \"Josh Kinnear\",\n",
        "            \"Joshua Claeys\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Kartik Cating-Subramanian\",\n",
        "            \"L0j1k\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Martin Price\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matthew Bouchard\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Michael Faust\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Mirik Gogri\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nero Li\",\n",
        "            \"Nikita Lesnikov\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Patrick Lucas\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"RedAgent14\",\n",
        "            \"rehmi post\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Roman Sergeychik\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Sebastian Garcia\",\n",
        "            \"Solara570\",\n",
        "            \"Steven Siddals\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Tal Einav\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Tom Fleming\",\n",
        "            \"Tyler VanValkenburg\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Vinicius Reis\",\n",
        "            \"Xuanji Li\",\n",
        "            \"Yavor Ivanov\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Zach Cardwell\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail(WindmillScene):\n",
        "    CONFIG = {\n",
        "        \"dot_config\": {\n",
        "            \"radius\": 0.15,\n",
        "            \"stroke_width\": 1,\n",
        "        },\n",
        "        \"random_seed\": 7,\n",
        "        \"animate\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        points = self.get_random_point_set(11)\n",
        "        points[:, 0] *= 1.7\n",
        "        points += 0.5 * LEFT\n",
        "\n",
        "        points[1] = ORIGIN\n",
        "        points[10] += LEFT\n",
        "        points[6] += 3 * RIGHT\n",
        "\n",
        "        windmill = self.get_windmill(\n",
        "            points, points[1],\n",
        "            angle=45 * DEGREES,\n",
        "        )\n",
        "        dots = self.get_dots(points)\n",
        "        # rects = self.get_left_right_colorings(windmill)\n",
        "        pivot_dot = self.get_pivot_dot(windmill)\n",
        "        pivot_dot.scale(2)\n",
        "        pivot_dot.set_color(WHITE)\n",
        "\n",
        "        new_pivot = points[5]\n",
        "        new_pivot2 = points[3]\n",
        "\n",
        "        flash = Flash(pivot_dot, flash_radius=0.5)\n",
        "\n",
        "        wa = windmill.get_angle()\n",
        "        arcs = VGroup(*[\n",
        "            Arc(\n",
        "                start_angle=wa + a,\n",
        "                angle=90 * DEGREES,\n",
        "                radius=1.5,\n",
        "                stroke_width=10,\n",
        "            ).add_tip(tip_length=0.7)\n",
        "            for a in [0, PI]\n",
        "        ])\n",
        "        arcs.move_to(windmill.pivot)\n",
        "        arcs.set_color([GREY_B, WHITE])\n",
        "\n",
        "        polygon1 = Polygon(\n",
        "            (FRAME_HEIGHT * UP + FRAME_WIDTH * LEFT) / 2,\n",
        "            (FRAME_HEIGHT * UP + FRAME_HEIGHT * RIGHT) / 2,\n",
        "            (FRAME_HEIGHT * DOWN + FRAME_HEIGHT * LEFT) / 2,\n",
        "            (FRAME_HEIGHT * DOWN + FRAME_WIDTH * LEFT) / 2,\n",
        "        )\n",
        "        polygon1.set_color([BLUE, GREY_E])\n",
        "        polygon1.set_fill(opacity=0.5)\n",
        "        polygon2 = Polygon(\n",
        "            (FRAME_HEIGHT * UP + FRAME_WIDTH * RIGHT) / 2,\n",
        "            (FRAME_HEIGHT * UP + FRAME_HEIGHT * RIGHT) / 2,\n",
        "            (FRAME_HEIGHT * DOWN + FRAME_HEIGHT * LEFT) / 2,\n",
        "            (FRAME_HEIGHT * DOWN + FRAME_WIDTH * RIGHT) / 2,\n",
        "        )\n",
        "        polygon2.set_sheen_direction(DR)\n",
        "        polygon2.set_color([GREY_BROWN, BLACK])\n",
        "        polygon2.set_fill(opacity=1)\n",
        "\n",
        "        self.add(polygon1, polygon2)\n",
        "        # self.add(rects[0])\n",
        "        self.add(windmill, dots, pivot_dot)\n",
        "        self.add(arcs)\n",
        "        self.add(flash.mobject)\n",
        "        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n",
        "\n",
        "        words = OldTexText(\"Next\\\\\\\\\", \"pivot\")\n",
        "        words2 = OldTexText(\"Next\\\\\\\\\", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n",
        "        words.scale(2)\n",
        "        words2.scale(2)\n",
        "        # words.next_to(windmill.pivot, RIGHT)\n",
        "        words.to_edge(UR)\n",
        "        words2.to_corner(DL)\n",
        "\n",
        "        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n",
        "        arrow.set_stroke(width=10)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n",
        "        arrow2.match_style(arrow)\n",
        "        arrow.rotate(\n",
        "            arrow2.get_angle() + PI - arrow.get_angle(),\n",
        "            about_point=new_pivot,\n",
        "        )\n",
        "\n",
        "        self.add(words, arrow)\n",
        "        self.add(words2, arrow2)\n",
        "\n",
        "        # for i, dot in enumerate(dots):\n",
        "        #     self.add(Integer(i).move_to(dot))\n",
        "\n",
        "        if self.animate:\n",
        "            sorted_dots = VGroup(*dots)\n",
        "            sorted_dots.sort(lambda p: np.dot(p, DR))\n",
        "\n",
        "            self.play(\n",
        "                polygon1.shift, FRAME_WIDTH * LEFT,\n",
        "                polygon2.shift, FRAME_WIDTH * RIGHT,\n",
        "                LaggedStart(*[\n",
        "                    ApplyMethod(mob.scale, 0)\n",
        "                    for mob in [sorted_dots[6], *flash.mobject, windmill, pivot_dot]\n",
        "                ]),\n",
        "                LaggedStart(*[\n",
        "                    ApplyMethod(dot.to_edge, LEFT, {\"buff\": -1})\n",
        "                    for dot in sorted_dots[:6]\n",
        "                ]),\n",
        "                LaggedStart(*[\n",
        "                    ApplyMethod(dot.to_edge, RIGHT, {\"buff\": -1})\n",
        "                    for dot in sorted_dots[7:]\n",
        "                ]),\n",
        "                LaggedStart(*[\n",
        "                    FadeOut(word, RIGHT)\n",
        "                    for word in words\n",
        "                ]),\n",
        "                LaggedStart(*[\n",
        "                    FadeOut(word, LEFT)\n",
        "                    for word in words2\n",
        "                ]),\n",
        "                LaggedStartMap(\n",
        "                    Uncreate,\n",
        "                    VGroup(arrow, arrow2, *arcs),\n",
        "                ),\n",
        "                run_time=3,\n",
        "            )\n",
        "\n",
        "\n",
        "class ThumbanailAnimated(Thumbnail):\n",
        "    CONFIG = {\n",
        "        \"animate\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail2(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n",
        "        # words.arrange(DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        words.set_height(FRAME_HEIGHT - 1.5)\n",
        "        words.to_edge(LEFT)\n",
        "\n",
        "        logo = ImageMobject(\"imo_logo\")\n",
        "        logo.set_height(4.5)\n",
        "        logo.to_corner(DR, buff=LARGE_BUFF)\n",
        "\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_fill([GREY, BLACK], 1)\n",
        "\n",
        "        self.clear()\n",
        "        self.add(rect)\n",
        "        self.add(words)\n",
        "        self.add(logo)\n"
    ]
}