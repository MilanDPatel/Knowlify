{
    "topic": "is demonstrating the concept of converting a MIDI file into a visual representation,",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "import mido\n",
        "from _2022.piano.wav_to_midi import DATA_DIR\n",
        "from _2022.piano.wav_to_midi import piano_midi_range\n",
        "from _2022.piano.wav_to_midi import midi_to_wav\n",
        "\n",
        "\n",
        "class AnimatedMidi(Scene):\n",
        "    midi_file = \"3-16-attempts/Help_Long_as_piano_5ms.mid\"\n",
        "    dist_per_sec = 4.0\n",
        "    bpm = 240\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"anti_alias_width\": 0,\n",
        "            \"samples\": 4,\n",
        "        }\n",
        "    }\n",
        "    hit_depth = 0.025\n",
        "    note_color = BLUE\n",
        "    hit_color = TEAL\n",
        "    note_to_key_width_ratio = 0.5\n",
        "    sound_file_time_offset = 0.3\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_piano()\n",
        "        self.add_note_rects()\n",
        "        self.add_piano_sound()\n",
        "        self.scroll()\n",
        "\n",
        "    def add_piano(self):\n",
        "        piano = Piano3D()\n",
        "        piano.set_width(9)\n",
        "        piano.move_to(5 * DOWN)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_phi(70 * DEGREES)\n",
        "\n",
        "        self.piano = piano\n",
        "        self.add(piano)\n",
        "\n",
        "    def add_note_rects(self):\n",
        "        mid_file = self.mid_file = os.path.join(DATA_DIR, self.midi_file)\n",
        "\n",
        "        # Pull out track\n",
        "        mid = mido.MidiFile(mid_file, clip=True)\n",
        "        track = mido.midifiles.MidiTrack()\n",
        "        track.extend([\n",
        "            msg\n",
        "            for msg in mido.merge_tracks(mid.tracks)\n",
        "            if msg.type not in ['pitchwheel', 'time_signature']\n",
        "        ])\n",
        "\n",
        "        # Relevant constants\n",
        "        offset = piano_midi_range[0]\n",
        "        tempo = 250000  # microseconds per quarter note\n",
        "        # (ms / beat) * (s / ms) * (beats / tick)\n",
        "        sec_per_tick = tempo * 1e-6 / mid.ticks_per_beat\n",
        "        dist_per_tick = self.dist_per_sec * sec_per_tick\n",
        "\n",
        "        pending_notes = {key: None for key in piano_midi_range}\n",
        "        notes_to_time_spans = {key: [] for key in piano_midi_range}\n",
        "\n",
        "        note_rects = VGroup()\n",
        "        time_in_ticks = 0\n",
        "        for msg in track:\n",
        "            time_in_ticks += msg.time\n",
        "            if msg.type == 'set_tempo':\n",
        "                sec_per_tick *= msg.tempo / tempo\n",
        "                dist_per_tick *= msg.tempo / tempo\n",
        "                tempo = msg.tempo\n",
        "            if msg.type == 'note_on' and msg.velocity > 0:\n",
        "                pending_notes[msg.note] = (time_in_ticks, msg.velocity)\n",
        "            elif msg.type == 'note_off':\n",
        "                if msg.note not in pending_notes or pending_notes[msg.note] is None:\n",
        "                    continue\n",
        "                if msg.note not in piano_midi_range:\n",
        "                    continue\n",
        "                print(pending_notes[msg.note])\n",
        "                start_time_in_ticks, velocity = pending_notes.pop(msg.note)\n",
        "                key = self.piano[msg.note - offset]\n",
        "                rect = Rectangle(\n",
        "                    width=self.note_to_key_width_ratio * key.get_width(),\n",
        "                    height=(time_in_ticks - start_time_in_ticks) * dist_per_tick\n",
        "                )\n",
        "                rect.next_to(key, UP, buff=start_time_in_ticks * dist_per_tick)\n",
        "                rect.set_stroke(width=0)\n",
        "                rect.set_fill(self.note_color, opacity=clip(0.25 + velocity / 100, 0, 1))\n",
        "                note_rects.add(rect)\n",
        "                notes_to_time_spans[msg.note].append((\n",
        "                    start_time_in_ticks * sec_per_tick,\n",
        "                    time_in_ticks * sec_per_tick\n",
        "                ))\n",
        "\n",
        "        self.note_rects = note_rects\n",
        "        self.notes_to_time_spans = notes_to_time_spans\n",
        "        self.add(note_rects)\n",
        "\n",
        "    def add_piano_sound(self):\n",
        "        self.add_sound(\n",
        "            midi_to_wav(self.mid_file),\n",
        "            self.sound_file_time_offset\n",
        "        )\n",
        "\n",
        "    def scroll(self):\n",
        "        piano = self.piano\n",
        "        note_rects = self.note_rects\n",
        "        notes_to_time_spans = self.notes_to_time_spans\n",
        "\n",
        "        for key in piano:\n",
        "            key.original_z = key.get_z()\n",
        "            key.original_color = key[0].get_fill_color()\n",
        "\n",
        "        piano.time = 0\n",
        "\n",
        "        def update_piano(piano, dt):\n",
        "            piano.time += dt\n",
        "            for note, key in zip(piano_midi_range, piano):\n",
        "                hit = False\n",
        "                for start, end in notes_to_time_spans[note]:\n",
        "                    if start - 1 / 60 < piano.time < end + 1 / 60:\n",
        "                        hit = True\n",
        "                if hit:\n",
        "                    key.set_z(key.original_z - self.hit_depth)\n",
        "                    key.set_fill(interpolate_color(\n",
        "                        key[0].get_fill_color(), self.hit_color, 0.5\n",
        "                    ))\n",
        "                else:\n",
        "                    key.set_z(key.original_z)\n",
        "                    key.set_fill(key.original_color)\n",
        "\n",
        "        piano.add_updater(update_piano)\n",
        "        note_rects_start = note_rects.get_center().copy()\n",
        "        note_rects.add_updater(lambda m: m.move_to(\n",
        "            note_rects_start + self.dist_per_sec * self.time * DOWN\n",
        "        ))\n",
        "        black_rect = Rectangle(width=piano.get_width(), height=5)\n",
        "        black_rect.set_fill(BLACK, 1)\n",
        "        black_rect.set_stroke(width=0)\n",
        "        black_rect.move_to(piano, UP)\n",
        "        self.add(note_rects, black_rect, piano)\n",
        "\n",
        "        self.wait(note_rects.get_height() / self.dist_per_sec + 3.0)\n",
        "\n",
        "\n",
        "class AnimatedMidiTrapped5m(AnimatedMidi):\n",
        "    midi_file = \"3-16-attempts/Help_Long_as_piano_5ms.mid\"\n",
        "\n",
        "\n",
        "class STFTAlgorithmOnTrapped(AnimatedMidi):\n",
        "    midi_file = \"3-16-attempts/Help_Long_STFT.mid\"\n",
        "\n",
        "\n",
        "class HelpLongOnlineConverter(AnimatedMidi):\n",
        "    midi_file = \"3-16-attempts/Help_Long_online.mid\"\n"
    ]
}