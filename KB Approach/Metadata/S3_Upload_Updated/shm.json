{
    "topic": "demonstrates the concept of a spring-mass system, where a mass is attached to a",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def get_coef_colors(n_coefs=3):\n",
        "    return [\n",
        "        interpolate_color_by_hsl(TEAL, RED, a)\n",
        "        for a in np.linspace(0, 1, n_coefs)\n",
        "    ]\n",
        "\n",
        "\n",
        "class SrpingMassSystem(VGroup):\n",
        "    def __init__(\n",
        "        self,\n",
        "        x0=0,\n",
        "        v0=0,\n",
        "        k=3,\n",
        "        mu=0.1,\n",
        "        equilibrium_length=7,\n",
        "        equilibrium_position=ORIGIN,\n",
        "        direction=RIGHT,\n",
        "        spring_stroke_color=GREY_B,\n",
        "        spring_stroke_width=2,\n",
        "        spring_radius=0.25,\n",
        "        n_spring_curls=8,\n",
        "        mass_width=1.0,\n",
        "        mass_color=BLUE_E,\n",
        "        mass_label=\"m\",\n",
        "    ):\n",
        "        super().__init__()\n",
        "        self.equilibrium_position = equilibrium_position\n",
        "        self.fixed_spring_point = equilibrium_position - (equilibrium_length - 0.5 * mass_width) * direction\n",
        "        self.direction = direction\n",
        "        self.rot_off_horizontal = angle_between_vectors(RIGHT, direction)\n",
        "        self.mass = self.get_mass(mass_width, mass_color, mass_label)\n",
        "        self.spring = self.get_spring(spring_stroke_color, spring_stroke_width, n_spring_curls, spring_radius)\n",
        "        self.add(self.spring, self.mass)\n",
        "\n",
        "        self.k = k\n",
        "        self.mu = mu\n",
        "        self.set_x(x0)\n",
        "        self.velocity = v0\n",
        "\n",
        "        self._is_running = True\n",
        "        self.add_updater(lambda m, dt: m.time_step(dt))\n",
        "\n",
        "    def get_spring(self, stroke_color, stroke_width, n_curls, radius):\n",
        "        spring = ParametricCurve(\n",
        "            lambda t: [t, -radius * math.sin(TAU * t), radius * math.cos(TAU * t)],\n",
        "            t_range=(0, n_curls, 1e-2),\n",
        "            stroke_color=stroke_color,\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "        spring.rotate(self.rot_off_horizontal)\n",
        "        return spring\n",
        "\n",
        "    def get_mass(self, mass_width, mass_color, mass_label):\n",
        "        mass = Square(mass_width)\n",
        "        mass.set_fill(mass_color, 1)\n",
        "        mass.set_stroke(WHITE, 1)\n",
        "        mass.set_shading(0.1, 0.1, 0.1)\n",
        "        label = Tex(mass_label)\n",
        "        label.set_max_width(0.5 * mass.get_width())\n",
        "        label.move_to(mass)\n",
        "        mass.add(label)\n",
        "        mass.label = label\n",
        "        return mass\n",
        "\n",
        "    def set_x(self, x):\n",
        "        self.mass.move_to(self.equilibrium_position + x * self.direction)\n",
        "        spring_width = SMALL_BUFF + get_norm(self.mass.get_left() - self.fixed_spring_point)\n",
        "        self.spring.rotate(-self.rot_off_horizontal)\n",
        "        self.spring.set_width(spring_width, stretch=True)\n",
        "        self.spring.rotate(self.rot_off_horizontal)\n",
        "        self.spring.move_to(self.fixed_spring_point, -self.direction)\n",
        "\n",
        "    def get_x(self):\n",
        "        return (self.mass.get_center() - self.equilibrium_position)[0]\n",
        "\n",
        "    def time_step(self, delta_t, dt_size=1e-2):\n",
        "        if not self._is_running:\n",
        "            return\n",
        "        if delta_t == 0:\n",
        "            return\n",
        "\n",
        "        state = [self.get_x(), self.velocity]\n",
        "        sub_steps = max(int(delta_t / dt_size), 1)\n",
        "        true_dt = delta_t / sub_steps\n",
        "        for _ in range(sub_steps):\n",
        "            # ODE\n",
        "            x, v = state\n",
        "            state += np.array([v, -self.k * x - self.mu * v]) * true_dt\n",
        "\n",
        "        self.set_x(state[0])\n",
        "        self.velocity = state[1]\n",
        "\n",
        "    def pause(self):\n",
        "        self._is_running = False\n",
        "\n",
        "    def unpause(self):\n",
        "        self._is_running = True\n",
        "\n",
        "    def set_k(self, k):\n",
        "        self.k = k\n",
        "        return self\n",
        "\n",
        "    def set_mu(self, mu):\n",
        "        self.mu = mu\n",
        "        return self\n",
        "\n",
        "    def set_velocity(self, velocity):\n",
        "        self.velocity = velocity\n",
        "        return self\n",
        "\n",
        "    def get_velocity_vector(self, scale_factor=0.5, thickness=3.0, v_offset=-0.25, color=GREEN):\n",
        "        \"\"\"Get a vector showing the mass's velocity\"\"\"\n",
        "        vector = Vector(RIGHT, fill_color=color)\n",
        "        v_shift = v_offset * UP\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            self.mass.get_center() + v_shift,\n",
        "            self.mass.get_center() + v_shift + scale_factor * self.velocity * RIGHT\n",
        "        ))\n",
        "        return vector\n",
        "\n",
        "    def get_force_vector(self, scale_factor=0.5, thickness=3.0, v_offset=-0.25, color=RED):\n",
        "        \"\"\"Get a vector showing the mass's velocity\"\"\"\n",
        "        vector = Vector(RIGHT, fill_color=color)\n",
        "        v_shift = v_offset * UP\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            self.mass.get_center() + v_shift,\n",
        "            self.mass.get_center() + v_shift + scale_factor * self.get_force() * RIGHT\n",
        "        ))\n",
        "        return vector\n",
        "\n",
        "    def get_force(self):\n",
        "        return -self.k * self.get_x() - self.mu * self.velocity\n",
        "\n",
        "\n",
        "class BasicSpringScene(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add spring, give some initial oscillation\n",
        "        spring = SrpingMassSystem(\n",
        "            x0=2,\n",
        "            mu=0.1,\n",
        "            k=3,\n",
        "            equilibrium_position=2 * LEFT,\n",
        "            equilibrium_length=5,\n",
        "        )\n",
        "        self.add(spring)\n",
        "\n",
        "        # Label on a number line\n",
        "        number_line = NumberLine(x_range=(-4, 4, 1))\n",
        "        number_line.next_to(spring.equilibrium_position, DOWN, buff=2.0)\n",
        "        number_line.add_numbers(font_size=24)\n",
        "\n",
        "        # Dashed line from mass to number line\n",
        "        dashed_line = DashedLine(\n",
        "            spring.mass.get_bottom(),\n",
        "            number_line.n2p(spring.get_x()),\n",
        "            stroke_color=GREY,\n",
        "            stroke_width=2\n",
        "        )\n",
        "        dashed_line.always.match_x(spring.mass)\n",
        "\n",
        "        # Arrow tip on number line\n",
        "        arrow_tip = ArrowTip(length=0.2, width=0.1)\n",
        "        arrow_tip.rotate(-90 * DEG)  # Point downward\n",
        "        arrow_tip.set_fill(TEAL)\n",
        "        arrow_tip.add_updater(lambda m: m.move_to(number_line.n2p(spring.get_x()), DOWN))\n",
        "\n",
        "        x_label = Tex(\"x = 0.00\", font_size=24)\n",
        "        x_number = x_label.make_number_changeable(\"0.00\")\n",
        "        x_number.add_updater(lambda m: m.set_value(spring.get_x()))\n",
        "        x_label.add_updater(lambda m: m.next_to(arrow_tip, UR, buff=0.1))\n",
        "\n",
        "        # Ambient playing, fade in labels\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            VFadeIn(number_line),\n",
        "            VFadeIn(dashed_line),\n",
        "            VFadeIn(arrow_tip),\n",
        "            VFadeIn(x_label),\n",
        "        )\n",
        "        self.wait(7)\n",
        "\n",
        "        # (For an insertion)\n",
        "        if False:\n",
        "            x_label_arrow = Vector(1.5 * DL, thickness=8)\n",
        "            x_label_arrow.set_fill(YELLOW)\n",
        "            x_label_arrow.always.move_to(arrow_tip, DL).shift(2 * RIGHT + 0.75 * UP)\n",
        "            self.play(\n",
        "                VFadeIn(x_label_arrow, time_span=(1, 2)),\n",
        "                x_label.animate.scale(2),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait(8)\n",
        "\n",
        "        # Show velocity\n",
        "        x_color, v_color, a_color = [interpolate_color_by_hsl(TEAL, RED, a) for a in np.linspace(0, 1, 3)]\n",
        "        v_vect = spring.get_velocity_vector(color=v_color, scale_factor=0.25)\n",
        "        a_vect = spring.get_force_vector(color=a_color, scale_factor=0.25)\n",
        "        a_vect.add_updater(lambda m: m.shift(v_vect.get_end() - m.get_start()))\n",
        "\n",
        "        self.play(VFadeIn(v_vect))\n",
        "        self.wait(5)\n",
        "        self.play(VFadeIn(a_vect))\n",
        "        self.wait(8)\n",
        "        self.wait_until(lambda: spring.velocity <= 0)\n",
        "\n",
        "        # Show the force law\n",
        "        self.remove(v_vect)\n",
        "        a_vect.remove_updater(a_vect.get_updaters()[-1])\n",
        "        spring.pause()\n",
        "\n",
        "        self.wait()\n",
        "        for x in range(2, 5):\n",
        "            self.play(spring.animate.set_x(x))\n",
        "            self.wait()\n",
        "\n",
        "        # Back and forth\n",
        "        t_tracker = ValueTracker(0)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                spring,\n",
        "                lambda m, a: m.set_x(4 * math.cos(2 * TAU * a)),\n",
        "                rate_func=linear,\n",
        "                run_time=8,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Ambient springing\n",
        "        spring.unpause()\n",
        "        spring.set_mu(0.25)\n",
        "        self.wait(15)\n",
        "\n",
        "        # Show the solution graph\n",
        "        frame = self.frame\n",
        "\n",
        "        time_tracker = ValueTracker(0)\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        axes = Axes(\n",
        "            x_range=(0, 20, 1),\n",
        "            y_range=(-2, 2, 1),\n",
        "            width=12,\n",
        "            height=3,\n",
        "            axis_config={\"stroke_color\": GREY}\n",
        "        )\n",
        "        axes.next_to(spring, UP, LARGE_BUFF)\n",
        "        axes.align_to(number_line, LEFT)\n",
        "\n",
        "        x_axis_label = Text(\"Time\", font_size=24).next_to(axes.x_axis, RIGHT, buff=0.1)\n",
        "        y_axis_label = Tex(\"x(t)\", font_size=24).next_to(axes.y_axis.get_top(), RIGHT, buff=0.1)\n",
        "        axes.add(x_axis_label)\n",
        "        axes.add(y_axis_label)\n",
        "\n",
        "        tracking_point = Point()\n",
        "        tracking_point.add_updater(lambda p: p.move_to(\n",
        "            axes.c2p(time_tracker.get_value(), spring.get_x())\n",
        "        ))\n",
        "\n",
        "        position_graph = TracedPath(\n",
        "            tracking_point.get_center,\n",
        "            stroke_color=BLUE,\n",
        "            stroke_width=3,\n",
        "        )\n",
        "\n",
        "        spring.pause()\n",
        "        spring.set_velocity(0)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2.88, 1.88, 0.0), 12.48),\n",
        "            FadeIn(axes),\n",
        "            VFadeOut(a_vect),\n",
        "            spring.animate.set_x(2),\n",
        "        )\n",
        "        self.add(tracking_point, position_graph, time_tracker)\n",
        "        spring.unpause()\n",
        "        self.wait(20)\n",
        "        position_graph.clear_updaters()\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class DampingForceDemo(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Create spring-mass system with invisible spring and damping only\n",
        "        spring_system = SrpingMassSystem(\n",
        "            x0=-4,\n",
        "            v0=2,\n",
        "            k=0,\n",
        "            mu=0.3,\n",
        "            equilibrium_position=ORIGIN,\n",
        "            equilibrium_length=6,\n",
        "            mass_width=0.8,\n",
        "            mass_color=BLUE_E,\n",
        "            mass_label=\"m\",\n",
        "        )\n",
        "        spring_system.spring.set_opacity(0)\n",
        "        self.add(spring_system)\n",
        "\n",
        "        # Create velocity vector\n",
        "        v_color = interpolate_color_by_hsl(TEAL, RED, 0.5)\n",
        "        velocity_vector = spring_system.get_velocity_vector(color=v_color, scale_factor=0.8)\n",
        "\n",
        "        velocity_label = Tex(R'\\vec{\\textbf{v}}', font_size=24)\n",
        "        velocity_label.set_color(v_color)\n",
        "        velocity_label.always.next_to(velocity_vector, RIGHT, buff=SMALL_BUFF)\n",
        "        velocity_label.add_updater(lambda m: m.set_max_width(0.5 * velocity_vector.get_width()))\n",
        "\n",
        "        # Create damping force vector\n",
        "        damping_vector = spring_system.get_velocity_vector(scale_factor=-0.5, color=RED, v_offset=-0.5)\n",
        "        damping_label = Tex(R\"-\\mu v\", fill_color=RED, font_size=24)\n",
        "        damping_label.always.next_to(damping_vector, DOWN, SMALL_BUFF)\n",
        "\n",
        "        # Add vectors and labels\n",
        "        self.add(velocity_vector, velocity_label)\n",
        "        self.add(damping_vector, damping_label)\n",
        "\n",
        "        # Let the system evolve\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class SolveDampedSpringEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show x and its derivatives\n",
        "        pos, vel, acc = funcs = VGroup(\n",
        "            Tex(R\"x(t)\"),\n",
        "            Tex(R\"x'(t)\"),\n",
        "            Tex(R\"x''(t)\"),\n",
        "        )\n",
        "        funcs.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        labels = VGroup(\n",
        "            Text(\"Position\").set_color(BLUE),\n",
        "            Text(\"Velocity\").set_color(RED),\n",
        "            Text(\"Acceleration\").set_color(YELLOW),\n",
        "        )\n",
        "        colors = get_coef_colors()\n",
        "        for line, label, color in zip(funcs, labels, colors):\n",
        "            label.set_color(color)\n",
        "            label.next_to(line, RIGHT, MED_LARGE_BUFF)\n",
        "            label.align_to(labels[0], LEFT)\n",
        "\n",
        "        VGroup(funcs, labels).to_corner(UR)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for l1, l2 in zip(funcs, funcs[1:]):\n",
        "            arrow = Line(l1.get_left(), l2.get_left(), path_arc=150 * DEG, buff=0.2)\n",
        "            arrow.add_tip(width=0.2, length=0.2)\n",
        "            arrow.set_color(GREY_B)\n",
        "            ddt = Tex(R\"\\frac{d}{dt}\", font_size=30)\n",
        "            ddt.set_color(GREY_B)\n",
        "            ddt.next_to(arrow, LEFT, SMALL_BUFF)\n",
        "            arrow.add(ddt)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        self.play(Write(funcs[0]), Write(labels[0]))\n",
        "        self.wait()\n",
        "        for func1, func2, label1, label2, arrow in zip(funcs, funcs[1:], labels, labels[1:], arrows):\n",
        "            self.play(LaggedStart(\n",
        "                GrowFromPoint(arrow, arrow.get_corner(UR), path_arc=30 * DEG),\n",
        "                TransformFromCopy(func1, func2, path_arc=30 * DEG),\n",
        "                FadeTransform(label1.copy(), label2),\n",
        "                lag_ratio=0.1\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        deriv_group = VGroup(funcs, labels, arrows)\n",
        "\n",
        "        # Show F=ma\n",
        "        t2c = {\n",
        "            \"x(t)\": colors[0],\n",
        "            \"x'(t)\": colors[1],\n",
        "            \"x''(t)\": colors[2],\n",
        "        }\n",
        "        equation1 = Tex(R\"{m} x''(t) = -k x(t) - \\mu x'(t)\", t2c=t2c)\n",
        "        equation1.to_corner(UL)\n",
        "\n",
        "        ma = equation1[\"{m} x''(t)\"][0]\n",
        "        kx = equation1[\"-k x(t)\"][0]\n",
        "        mu_v = equation1[R\"- \\mu x'(t)\"][0]\n",
        "        rhs = VGroup(kx, mu_v)\n",
        "\n",
        "        ma_brace, kx_brace, mu_v_brace = braces = VGroup(\n",
        "            Brace(part, DOWN, buff=SMALL_BUFF)\n",
        "            for part in [ma, kx, mu_v]\n",
        "        )\n",
        "        label_texs = [R\"\\textbf{F}\", R\"\\text{Spring force}\", R\"\\text{Damping}\"]\n",
        "        for brace, label_tex in zip(braces, label_texs):\n",
        "            brace.add(brace.get_tex(label_tex))\n",
        "\n",
        "        self.play(TransformFromCopy(acc, ma[1:], path_arc=-45 * DEG))\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromCenter(ma_brace),\n",
        "            Write(ma[0]),\n",
        "            run_time=1,\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            Write(equation1[\"= -k\"][0]),\n",
        "            FadeTransformPieces(ma_brace, kx_brace),\n",
        "            TransformFromCopy(pos, equation1[\"x(t)\"][0], path_arc=-45 * DEG),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransformPieces(kx_brace, mu_v_brace),\n",
        "            Write(equation1[R\"- \\mu\"][0]),\n",
        "            TransformFromCopy(vel, equation1[\"x'(t)\"][0], path_arc=-45 * DEG),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(mu_v_brace))\n",
        "\n",
        "        # Rearrange\n",
        "        equation2 = Tex(R\"{m} x''(t) + \\mu x'(t) + k x(t) = 0\", t2c=t2c)\n",
        "        equation2.move_to(equation1, UL)\n",
        "\n",
        "        self.play(TransformMatchingTex(equation1, equation2, path_arc=45 * DEG))\n",
        "        self.wait()\n",
        "\n",
        "        # Hypothesis of e^st\n",
        "        t2c = {\"s\": YELLOW, \"x(t)\": TEAL}\n",
        "        hyp_word, hyp_tex = hypothesis = VGroup(\n",
        "            Text(\"Hypothesis: \"),\n",
        "            Tex(\"x(t) = e^{st}\", t2c=t2c),\n",
        "        )\n",
        "        hypothesis.arrange(RIGHT)\n",
        "        hypothesis.to_corner(UR)\n",
        "        sub_hyp_word = TexText(R\"(For some $s$)\", t2c={\"$s$\": YELLOW}, font_size=36, fill_color=GREY_B)\n",
        "        sub_hyp_word.next_to(hyp_tex, DOWN)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(pos.copy(), hyp_tex[:4], path_arc=45 * DEG, remover=True),\n",
        "            FadeOut(deriv_group),\n",
        "            Write(hyp_word, run_time=1),\n",
        "            Write(hyp_tex[4:], time_span=(0.5, 1.5)),\n",
        "        ))\n",
        "        self.add(hypothesis)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sub_hyp_word, 0.25 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Plug it in\n",
        "        t2c[\"s\"] = YELLOW\n",
        "        equation3 = Tex(R\"{m} s^2 e^{st} + \\mu s e^{st} + k e^{st} = 0\", t2c=t2c)\n",
        "        equation3.next_to(equation2, DOWN, LARGE_BUFF)\n",
        "        pos_parts = VGroup(equation2[\"x(t)\"][0], equation3[\"e^{st}\"][-1])\n",
        "        vel_parts = VGroup(equation2[\"x'(t)\"][0], equation3[\"s e^{st}\"][0])\n",
        "        acc_parts = VGroup(equation2[\"x''(t)\"][0], equation3[\"s^2 e^{st}\"][0])\n",
        "        matched_parts = VGroup(pos_parts, vel_parts, acc_parts)\n",
        "\n",
        "        pos_rect, vel_rect, acc_rect = rects = VGroup(\n",
        "            SurroundingRectangle(group[0], buff=0.05).set_stroke(group[0][0].get_color(), 1)\n",
        "            for group in matched_parts\n",
        "        )\n",
        "\n",
        "        pos_arrow, vel_arrow, acc_arrow = arrows = VGroup(\n",
        "            Arrow(*pair, buff=0.1)\n",
        "            for pair in matched_parts\n",
        "        )\n",
        "\n",
        "        for rect, arrow, pair in zip(rects, arrows, matched_parts):\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                FadeTransform(pair[0].copy(), pair[1]),\n",
        "                rect.animate.surround(pair[1]),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(equation2[tex], equation3[tex])\n",
        "                for tex in [\"{m}\", \"+\", \"k\", R\"\\mu\", \"=\", \"0\"]),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrows, lag_ratio=0.1), FadeOut(rects, lag_ratio=0.1))\n",
        "\n",
        "        # Solve for s\n",
        "        key_syms = [\"s\", \"m\", R\"\\mu\", \"k\"]\n",
        "        equation4, equation5, equation6 = new_equations = VGroup(\n",
        "            Tex(R\"e^{st} \\left( ms^2 + \\mu s + k \\right) = 0\", t2c=t2c),\n",
        "            Tex(R\"ms^2 + \\mu s + k = 0\", t2c=t2c),\n",
        "            Tex(R\"{s} = {{-\\mu \\pm \\sqrt{\\mu^2 - 4mk}} \\over 2m}\", isolate=key_syms)\n",
        "        )\n",
        "        rhs = equation6[2:]\n",
        "        rhs.set_width(equation5.get_width() - equation6[:2].get_width(), about_edge=LEFT)\n",
        "        equation6.refresh_bounding_box()\n",
        "        equation6[\"{s}\"].set_color(YELLOW)\n",
        "        equation6.scale(1.25, about_edge=LEFT)\n",
        "\n",
        "        new_equations.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        new_equations.move_to(equation3, UL)\n",
        "        equation4 = new_equations[0]\n",
        "\n",
        "        exp_rect = SurroundingRectangle(equation4[R\"e^{st}\"])\n",
        "        exp_rect.set_stroke(YELLOW, 2)\n",
        "        ne_0 = VGroup(Tex(R\"\\ne\").rotate(90 * DEG), Integer(0))\n",
        "        ne_0.arrange(DOWN).next_to(exp_rect, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                equation3,\n",
        "                equation4,\n",
        "                matched_keys=[R\"e^{st}\"],\n",
        "                run_time=1.5,\n",
        "                path_arc=30 * DEG\n",
        "            )\n",
        "        )\n",
        "        self.wait(0.5)\n",
        "        self.play(ShowCreation(exp_rect))\n",
        "        self.wait()\n",
        "        self.play(Write(ne_0))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(ne_0))\n",
        "        self.play(\n",
        "            *(\n",
        "                TransformFromCopy(equation4[key], equation5[key])\n",
        "                for key in [R\"ms^2 + \\mu s + k\", \"= 0\"]\n",
        "            ),\n",
        "            FadeOut(exp_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show mirror image\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                equation5.copy(), equation2.copy(),\n",
        "                key_map={\n",
        "                    \"s^2\": \"x''(t)\",\n",
        "                    R\"\\mu s\": R\"\\mu x(t)\",\n",
        "                    R\"k\": R\"k x(t)\",\n",
        "                },\n",
        "                # match_animation=FadeTransform,\n",
        "                # mismatch_animation=FadeTransform,\n",
        "                remover=True,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                run_time=6\n",
        "            ),\n",
        "            equation4.animate.set_fill(opacity=0.25),\n",
        "        )\n",
        "        self.play(equation4.animate.set_fill(opacity=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Cover up mu terms\n",
        "        boxes = VGroup(\n",
        "            SurroundingRectangle(mob)\n",
        "            for mob in [\n",
        "                equation2[R\"+ \\mu x'(t)\"],\n",
        "                equation4[R\"+ \\mu s\"],\n",
        "                equation5[R\"+ \\mu s\"],\n",
        "            ]\n",
        "        )\n",
        "        boxes.set_fill(BLACK, 0)\n",
        "        boxes.set_stroke(colors[1], 2)\n",
        "\n",
        "        self.add(Point())\n",
        "        self.play(FadeIn(boxes, lag_ratio=0.1))\n",
        "        self.play(boxes.animate.set_fill(BLACK, 0.8).set_stroke(width=1, opacity=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Add simple answer\n",
        "        simple_answer = Tex(R\"s = \\pm i \\sqrt{k / m}\", t2c=t2c)\n",
        "        simple_answer.next_to(equation5, DOWN, LARGE_BUFF, aligned_edge=RIGHT)\n",
        "\n",
        "        omega_brace = Brace(simple_answer[R\"\\sqrt{k / m}\"], DOWN, SMALL_BUFF)\n",
        "        omega = omega_brace.get_tex(R\"\\omega\")\n",
        "        omega.set_color(PINK)\n",
        "\n",
        "        self.play(FadeIn(simple_answer))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(omega_brace), Write(omega))\n",
        "        self.wait()\n",
        "\n",
        "        simple_answer.add(omega_brace, omega)\n",
        "\n",
        "        # Reminder of what s represents\n",
        "        s_copy = simple_answer[0].copy()\n",
        "        s_rect = SurroundingRectangle(s_copy)\n",
        "\n",
        "        self.play(ShowCreation(s_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_rect.animate.surround(hyp_tex[\"e^{st}\"]).set_anim_args(path_arc=-60 * DEG),\n",
        "            FadeTransform(s_copy, hyp_tex[\"s\"], path_arc=-60 * DEG),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(s_rect))\n",
        "\n",
        "        # Move hypothesis\n",
        "        frame = self.frame\n",
        "        self.play(\n",
        "            frame.animate.scale(1.5, about_edge=LEFT),\n",
        "            hypothesis.animate.next_to(equation2, UP, LARGE_BUFF, aligned_edge=LEFT),\n",
        "            FadeOut(sub_hyp_word),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show quadratic formula\n",
        "        qf_arrow = Arrow(\n",
        "            equation5.get_right(),\n",
        "            equation6.get_corner(UR) + 0.5 * LEFT,\n",
        "            path_arc=-150 * DEG\n",
        "        )\n",
        "        qf_words = Text(\"Quadratic\\nFormula\", font_size=30, fill_color=GREY_B)\n",
        "        qf_words.next_to(qf_arrow.get_center(), UR)\n",
        "\n",
        "        naked_equation = equation6.copy()\n",
        "        for sym in key_syms:\n",
        "            naked_equation[sym].scale(0).set_fill(opacity=0).move_to(10 * LEFT)\n",
        "\n",
        "        qf_rect = SurroundingRectangle(equation6[2:])\n",
        "        qf_rect.set_stroke(YELLOW, 1.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(simple_answer, DOWN),\n",
        "            boxes.animate.set_fill(opacity=0).set_stroke(width=2, opacity=1)\n",
        "        )\n",
        "        self.play(FadeOut(boxes))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(equation5[\"s\"], equation6[\"s\"]),\n",
        "            Write(equation6[\"=\"]),\n",
        "            GrowFromPoint(qf_arrow, qf_arrow.get_corner(UL)),\n",
        "            FadeIn(qf_words, shift=0.5 * DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(equation5[sym], equation6[sym], time_span=(0.5, 1.5))\n",
        "                for sym in key_syms[1:]\n",
        "            ), lag_ratio=0.1),\n",
        "            Write(naked_equation),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(naked_equation)\n",
        "        self.add(equation6)\n",
        "        self.play(ShowCreation(qf_rect))\n",
        "        self.wait()\n",
        "\n",
        "    def old_material(self):\n",
        "        # Show implied exponentials\n",
        "        final_equation = new_equations[-1]\n",
        "        consolidated_lines = VGroup(\n",
        "            hypothesis,\n",
        "            equation2,\n",
        "            equation4,\n",
        "            final_equation,\n",
        "        )\n",
        "        consolidated_lines.target = consolidated_lines.generate_target()\n",
        "        consolidated_lines.target.scale(0.7)\n",
        "        consolidated_lines.target.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        consolidated_lines.target.to_corner(UL)\n",
        "\n",
        "        implies = Tex(R\"\\Longrightarrow\", font_size=60)\n",
        "        implies.next_to(consolidated_lines.target[0], RIGHT, buff=0.75)\n",
        "\n",
        "        t2c = {\"x(t)\": TEAL, R\"\\omega\": PINK}\n",
        "        imag_exps = VGroup(\n",
        "            Tex(R\"x(t) = e^{+i \\omega t}\", t2c=t2c),\n",
        "            Tex(R\"x(t) = e^{-i \\omega t}\", t2c=t2c),\n",
        "        )\n",
        "        imag_exps.arrange(RIGHT, buff=2.0)\n",
        "        imag_exps.next_to(implies, RIGHT, buff=0.75)\n",
        "\n",
        "        self.remove(final_equation)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(equation3, 0.5 * UP),\n",
        "            FadeOut(sub_hyp_word),\n",
        "            MoveToTarget(consolidated_lines),\n",
        "            Write(implies),\n",
        "        ))\n",
        "        for imag_exp, sgn in zip(imag_exps, \"+-\"):\n",
        "            self.play(\n",
        "                TransformFromCopy(hyp_tex[\"x(t) =\"][0], imag_exp[\"x(t) =\"][0]),\n",
        "                TransformFromCopy(hyp_tex[\"e\"][0], imag_exp[\"e\"][0]),\n",
        "                TransformFromCopy(hyp_tex[\"t\"][-1], imag_exp[\"t\"][-1]),\n",
        "                FadeTransform(final_equation[R\"\\pm i\"][0].copy(), imag_exp[Rf\"{sgn}i\"][0]),\n",
        "                FadeTransform(final_equation[R\"\\sqrt{k/m}\"][0].copy(), imag_exp[R\"\\omega\"][0]),\n",
        "            )\n",
        "\n",
        "        omega_brace = Brace(final_equation[R\"\\sqrt{k/m}\"], DOWN, SMALL_BUFF)\n",
        "        omega_label = omega_brace.get_tex(R\"\\omega\").set_color(PINK)\n",
        "        self.play(GrowFromCenter(omega_brace), Write(omega_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Combine two solutions\n",
        "        cos_equation = Tex(R\"e^{+i \\omega t} + e^{-i \\omega t} = 2\\cos(\\omega t)\", t2c={R\"\\omega\": PINK})\n",
        "        cos_equation.move_to(imag_exps)\n",
        "        omega_brace2 = omega_brace.copy()\n",
        "        omega_brace2.stretch(0.5, 0).match_width(cos_equation[R\"\\omega\"][-1])\n",
        "        omega_brace2.next_to(cos_equation[R\"\\omega\"][-1], DOWN, SMALL_BUFF)\n",
        "        omega_brace2_tex = omega_brace2.get_tex(R\"\\sqrt{k / m}\", buff=SMALL_BUFF, font_size=24)\n",
        "\n",
        "        self.remove(imag_exps)\n",
        "        self.play(\n",
        "            TransformFromCopy(imag_exps[0][R\"e^{+i \\omega t}\"], cos_equation[R\"e^{+i \\omega t}\"]),\n",
        "            TransformFromCopy(imag_exps[1][R\"e^{-i \\omega t}\"], cos_equation[R\"e^{-i \\omega t}\"]),\n",
        "            FadeOut(imag_exps[0][R\"x(t) =\"]),\n",
        "            FadeOut(imag_exps[1][R\"x(t) =\"]),\n",
        "            Write(cos_equation[\"+\"][1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(cos_equation[R\"= 2\\cos(\\omega t)\"]))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(omega_brace2), Write(omega_brace2_tex))\n",
        "\n",
        "        # Clear the board\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(implies),\n",
        "            FadeOut(cos_equation),\n",
        "            FadeOut(omega_brace2),\n",
        "            FadeOut(omega_brace2_tex),\n",
        "            FadeOut(consolidated_lines[2:]),\n",
        "            FadeOut(omega_brace),\n",
        "            FadeOut(omega_label),\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "\n",
        "        # Add damping term\n",
        "        t2c = {\"x''(t)\": colors[2], \"x'(t)\": colors[1], \"x(t)\": colors[0], \"{s}\": YELLOW}\n",
        "        new_lines = VGroup(\n",
        "            Tex(R\"m x''(t) + \\mu x'(t) + k x(t) = 0\", t2c=t2c),\n",
        "            Tex(R\"m ({s}^2 e^{{s}t}) + \\mu ({s} e^{{s}t}) + k (e^{{s}t}) = 0\", t2c=t2c),\n",
        "            Tex(R\"e^{{s}t}\\left(m {s}^2 + \\mu {s} + k \\right) = 0\", t2c=t2c),\n",
        "            Tex(R\"m {s}^2 + \\mu {s} + k = 0\", t2c=t2c),\n",
        "            Tex(R\"{s} = {{-\\mu \\pm \\sqrt{\\mu^2 - 4mk}} \\over 2m}\", t2c=t2c),\n",
        "        )\n",
        "        new_lines.scale(0.7)\n",
        "        new_lines.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "        new_lines.move_to(equation2, UL)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                equation2,\n",
        "                new_lines[0],\n",
        "                matched_keys=t2c.keys(),\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for line1, line2 in zip(new_lines, new_lines[1:]):\n",
        "            if line1 is new_lines[0]:\n",
        "                key_map = {\n",
        "                    \"x''(t)\": R\"({s}^2 e^{{s}t})\",\n",
        "                    \"x'(t)\": R\"({s} e^{{s}t})\",\n",
        "                    \"x(t)\": R\"(e^{{s}t})\",\n",
        "                }\n",
        "            else:\n",
        "                key_map = dict()\n",
        "            self.play(TransformMatchingTex(line1.copy(), line2, key_map=key_map, run_time=1, lag_ratio=0.01))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class DampedSpringSolutionsOnSPlane(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add the plane\n",
        "        plane = ComplexPlane((-3, 2), (-2, 2))\n",
        "        plane.set_height(5)\n",
        "        plane.background_lines.set_stroke(BLUE, 1)\n",
        "        plane.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        plane.move_to(DOWN)\n",
        "        plane.to_edge(RIGHT, buff=1.0)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Add the sliders\n",
        "        colors = [interpolate_color_by_hsl(RED, TEAL, a) for a in np.linspace(0, 1, 3)]\n",
        "        chars = [\"m\", R\"\\mu\", \"k\"]\n",
        "        m_slider, mu_slider, k_slider = sliders = VGroup(\n",
        "            self.get_slider(char, color)\n",
        "            for char, color in zip(chars, colors)\n",
        "        )\n",
        "        m_tracker, mu_tracker, k_tracker = trackers = Group(\n",
        "            slider.value_tracker for slider in sliders\n",
        "        )\n",
        "        sliders.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        sliders.next_to(plane, UP, aligned_edge=LEFT)\n",
        "\n",
        "        for tracker, value in zip(trackers, [1, 0, 3]):\n",
        "            tracker.set_value(value)\n",
        "\n",
        "        self.add(trackers)\n",
        "        self.add(sliders[0], sliders[2])\n",
        "\n",
        "        # Add the dots\n",
        "        def get_roots():\n",
        "            a, b, c = [t.get_value() for t in trackers]\n",
        "            m = -b / 2\n",
        "            p = c / a\n",
        "            disc = m**2 - p\n",
        "            radical = math.sqrt(disc) if disc >= 0 else 1j * math.sqrt(-disc)\n",
        "            return (m + radical, m - radical)\n",
        "\n",
        "        def update_dots(dots):\n",
        "            roots = get_roots()\n",
        "            for dot, root in zip(dots, roots):\n",
        "                dot.move_to(plane.n2p(root))\n",
        "\n",
        "        root_dots = GlowDot().replicate(2)\n",
        "        root_dots.add_updater(update_dots)\n",
        "\n",
        "        s_rhs_point = Point((-4.09, -1.0, 0.0))\n",
        "        rect_edge_point = (-3.33, -1.18, 0.0)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for line, dot in zip(lines, root_dots):\n",
        "                line.put_start_and_end_on(\n",
        "                    s_rhs_point.get_center(),\n",
        "                    dot.get_center(),\n",
        "                )\n",
        "\n",
        "        lines = Line().replicate(2)\n",
        "        lines.set_stroke(YELLOW, 2, 0.35)\n",
        "        lines.add_updater(update_lines)\n",
        "\n",
        "        self.add(root_dots)\n",
        "\n",
        "        # Play with k\n",
        "        self.play(ShowCreation(lines, lag_ratio=0, suspend_mobject_updating=True))\n",
        "        self.play(k_tracker.animate.set_value(1), run_time=2)\n",
        "        self.play(m_tracker.animate.set_value(4), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(k_tracker.animate.set_value(3), run_time=2)\n",
        "        self.play(m_tracker.animate.set_value(1), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Play with mu\n",
        "        self.play(\n",
        "            s_rhs_point.animate.move_to(rect_edge_point),\n",
        "            VFadeOut(lines),\n",
        "            VFadeIn(sliders[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(mu_tracker.animate.set_value(3), run_time=5)\n",
        "        self.wait()\n",
        "        self.play(mu_tracker.animate.set_value(0.5), run_time=3)\n",
        "        self.play(ShowCreation(lines, lag_ratio=0, suspend_mobject_updating=True))\n",
        "\n",
        "        # Background\n",
        "        self.add_background_image()\n",
        "\n",
        "        # Zoom out and show graph\n",
        "        frame = self.frame\n",
        "\n",
        "        axes = Axes((0, 10, 1), (-1, 1, 1), width=10, height=3.5)\n",
        "        axes.next_to(plane, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        def func(t):\n",
        "            roots = get_roots()\n",
        "            return 0.5 * (np.exp(roots[0] * t) + np.exp(roots[1] * t)).real\n",
        "\n",
        "        graph = axes.get_graph(func)\n",
        "        graph.set_stroke(TEAL, 3)\n",
        "        axes.bind_graph_to_func(graph, func)\n",
        "\n",
        "        graph_label = Tex(R\"\\text{Re}[e^{st}]\", t2c={\"s\": YELLOW}, font_size=72)\n",
        "        graph_label.next_to(axes.get_corner(UL), DL)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(12, about_point=4 * UP + 2 * LEFT),\n",
        "            FadeIn(axes, time_span=(1.5, 3)),\n",
        "            ShowCreation(graph, suspend_mobject_updating=True, time_span=(1.5, 3)),\n",
        "            Write(graph_label),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show exponential decay\n",
        "        exp_graph = axes.get_graph(lambda t: np.exp(get_roots()[0].real * t))\n",
        "        exp_graph.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(ShowCreation(exp_graph))\n",
        "        self.wait()\n",
        "\n",
        "        # More play\n",
        "        self.play(k_tracker.animate.set_value(1), run_time=2)\n",
        "        self.play(k_tracker.animate.set_value(4), run_time=2)\n",
        "        self.play(FadeOut(exp_graph))\n",
        "        self.wait()\n",
        "        self.play(mu_tracker.animate.set_value(2), run_time=3)\n",
        "        self.play(k_tracker.animate.set_value(2), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(mu_tracker.animate.set_value(3.5), run_time=3)\n",
        "        self.play(k_tracker.animate.set_value(5), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mu_tracker.animate.set_value(0.5),\n",
        "            m_tracker.animate.set_value(3),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Smooth all the way to end\n",
        "        self.play(mu_tracker.animate.set_value(4.2), run_time=12)\n",
        "\n",
        "    def add_background_image(self):\n",
        "        image = ImageMobject('/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/laplace/shm/images/LaplaceFormulaStill.png')\n",
        "        image.replace(self.frame)\n",
        "        image.set_z_index(-1)\n",
        "        self.background_image = image\n",
        "        self.add(image)\n",
        "\n",
        "    def get_slider(self, char_name, color=WHITE, x_range=(0, 5), height=1.5, font_size=36):\n",
        "        tracker = ValueTracker(0)\n",
        "        number_line = NumberLine(x_range, width=height, tick_size=0.05)\n",
        "        number_line.rotate(90 * DEG)\n",
        "\n",
        "        indicator = ArrowTip(width=0.1, length=0.2)\n",
        "        indicator.rotate(PI)\n",
        "        indicator.add_updater(lambda m: m.move_to(number_line.n2p(tracker.get_value()), LEFT))\n",
        "        indicator.set_color(color)\n",
        "\n",
        "        label = Tex(Rf\"{char_name} = 0.00\", font_size=font_size)\n",
        "        label[char_name].set_color(color)\n",
        "        label.rhs = label.make_number_changeable(\"0.00\")\n",
        "        label.always.next_to(indicator, RIGHT, SMALL_BUFF)\n",
        "        label.rhs.f_always.set_value(tracker.get_value)\n",
        "\n",
        "        slider = VGroup(number_line, indicator, label)\n",
        "        slider.value_tracker = tracker\n",
        "        return slider\n",
        "\n",
        "\n",
        "class RotatingExponentials(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Create time tracker\n",
        "        t_tracker = ValueTracker(0)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        get_t = t_tracker.get_value\n",
        "        omega = PI / 2\n",
        "\n",
        "        def get_x():\n",
        "            return math.cos(omega * get_t())\n",
        "\n",
        "        self.add(t_tracker)\n",
        "\n",
        "        # Create two complex planes side by side\n",
        "        left_plane, right_plane = planes = VGroup(\n",
        "            ComplexPlane(\n",
        "                (-2, 2), (-2, 2),\n",
        "                background_line_style=dict(stroke_color=BLUE, stroke_width=1),\n",
        "            )\n",
        "            for _ in range(2)\n",
        "        )\n",
        "        for plane in planes:\n",
        "            plane.axes.set_stroke(width=1)\n",
        "            plane.set_height(3.5)\n",
        "            plane.add_coordinate_labels(font_size=16)\n",
        "        planes.arrange(RIGHT, buff=1.0)\n",
        "        planes.to_edge(RIGHT)\n",
        "        planes.to_edge(UP, buff=1.5)\n",
        "\n",
        "        self.add(planes)\n",
        "\n",
        "        # Add titles\n",
        "        t2c = {R\"\\omega\": PINK}\n",
        "        left_title, right_title = titles = VGroup(\n",
        "            Tex(tex, t2c=t2c, font_size=48)\n",
        "            for tex in [\n",
        "                R\"e^{+i \\omega t}\",\n",
        "                R\"e^{-i \\omega t}\",\n",
        "            ]\n",
        "        )\n",
        "        for title, plane in zip(titles, planes):\n",
        "            title.next_to(plane, UP)\n",
        "\n",
        "        self.add(titles)\n",
        "\n",
        "        # Create rotating vectors\n",
        "        left_vector = self.get_rotating_vector(left_plane, 1j * omega, t_tracker, color=TEAL)\n",
        "        right_vector = self.get_rotating_vector(right_plane, -1j * omega, t_tracker, color=RED)\n",
        "        vectors = VGroup(left_vector, right_vector)\n",
        "\n",
        "        left_tail, right_tail = tails = VGroup(\n",
        "            TracingTail(vect.get_end, stroke_color=vect.get_color(), time_traced=2)\n",
        "            for vect in vectors\n",
        "        )\n",
        "\n",
        "        self.add(Point())\n",
        "        self.add(vectors, tails)\n",
        "\n",
        "        # Add time display\n",
        "        time_display = Tex(\"t = 0.00\", font_size=36).to_corner(UR)\n",
        "        time_label = time_display.make_number_changeable(\"0.00\")\n",
        "        time_label.add_updater(lambda m: m.set_value(t_tracker.get_value()))\n",
        "\n",
        "        # Animate rotation\n",
        "        self.wait(12)\n",
        "\n",
        "        # Add spring\n",
        "        spring = SrpingMassSystem(\n",
        "            equilibrium_position=planes[0].get_bottom() + DOWN,\n",
        "            equilibrium_length=3,\n",
        "            n_spring_curls=8,\n",
        "            mass_width=0.5,\n",
        "            spring_radius=0.2,\n",
        "        )\n",
        "        spring.pause()\n",
        "        unit_size = planes[0].x_axis.get_unit_size()\n",
        "        spring.add_updater(lambda m: m.set_x(unit_size * get_x()))\n",
        "\n",
        "        v_line = Line()\n",
        "        v_line.set_stroke(BLUE_A, 2)\n",
        "        v_line.f_always.put_start_and_end_on(spring.mass.get_top, left_vector.get_end)\n",
        "\n",
        "        self.play(VFadeIn(spring), VFadeIn(v_line))\n",
        "        self.wait(20)\n",
        "        self.play(\n",
        "            VFadeOut(spring),\n",
        "            VFadeOut(v_line),\n",
        "            VFadeOut(tails),\n",
        "        )\n",
        "\n",
        "        # Add them up\n",
        "        new_plane_center = planes.get_center()\n",
        "        shift_factor = ValueTracker(0)\n",
        "        right_vector.add_updater(lambda m: m.shift(shift_factor.get_value() * left_vector.get_vector()))\n",
        "\n",
        "        sum_expr = VGroup(titles[0], Tex(R\"+\"), titles[1])\n",
        "        sum_expr.target = sum_expr.generate_target()\n",
        "        sum_expr.target.arrange(RIGHT, buff=MED_SMALL_BUFF, aligned_edge=DOWN)\n",
        "        sum_expr.target.next_to(planes, UP, MED_SMALL_BUFF)\n",
        "        sum_expr[1].set_opacity(0).next_to(planes, UP)\n",
        "\n",
        "        result_dot = GlowDot()\n",
        "        result_dot.f_always.move_to(right_vector.get_end)\n",
        "\n",
        "        self.play(\n",
        "            planes[0].animate.move_to(new_plane_center),\n",
        "            planes[1].animate.move_to(new_plane_center).set_opacity(0),\n",
        "            MoveToTarget(sum_expr),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(shift_factor.animate.set_value(1))\n",
        "        self.play(FadeIn(result_dot))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Add another spring\n",
        "        spring = SrpingMassSystem(\n",
        "            equilibrium_position=planes[0].get_bottom() + DOWN,\n",
        "            equilibrium_length=5,\n",
        "            n_spring_curls=8,\n",
        "            mass_width=0.5,\n",
        "            spring_radius=0.2,\n",
        "        )\n",
        "        spring.pause()\n",
        "        unit_size = planes[0].x_axis.get_unit_size()\n",
        "        spring.add_updater(lambda m: m.set_x(2 * unit_size * get_x()))\n",
        "\n",
        "        v_line = Line()\n",
        "        v_line.set_stroke(BLUE_A, 2)\n",
        "        v_line.f_always.put_start_and_end_on(spring.mass.get_top, result_dot.get_center)\n",
        "\n",
        "        self.play(VFadeIn(spring), VFadeIn(v_line))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Right hand side\n",
        "        rhs = Tex(R\"= 2 \\cos(\\omega t)\", t2c={R\"\\omega\": PINK})\n",
        "        rhs.next_to(sum_expr, RIGHT, buff=MED_SMALL_BUFF).shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.play(Write(rhs))\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_rotating_vector(self, plane, s, t_tracker, color=TEAL, thickness=3):\n",
        "        \"\"\"Create a rotating vector for e^(st) on the given plane\"\"\"\n",
        "        def update_vector(vector):\n",
        "            t = t_tracker.get_value()\n",
        "            c = vector.coef_tracker.get_value()\n",
        "            z = c * np.exp(s * t)\n",
        "            vector.put_start_and_end_on(plane.n2p(0), plane.n2p(z))\n",
        "\n",
        "        vector = Arrow(LEFT, RIGHT, fill_color=color, thickness=thickness)\n",
        "        vector.coef_tracker = ComplexValueTracker(1)\n",
        "        vector.add_updater(update_vector)\n",
        "\n",
        "        return vector\n",
        "\n",
        "\n",
        "class SimpleSolutionSummary(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Summary of the \"strategy\" up top\n",
        "        t2c = {\"m\": RED, \"k\": TEAL, \"{s}\": YELLOW, R\"\\omega\": PINK}\n",
        "        kw = dict(t2c=t2c, font_size=36)\n",
        "        arrow = Vector(1.5 * RIGHT)\n",
        "        top_eq = VGroup(\n",
        "            Tex(R\"m x''(t) + k x(t) = 0\", **kw),\n",
        "            arrow,\n",
        "            Tex(R\"e^{{s}t}\\left(m{s}^2 + k\\right) = 0\", **kw),\n",
        "            Tex(R\"\\Longrightarrow\", **kw),\n",
        "            Tex(R\"{s} = \\pm i \\underbrace{\\sqrt{k / m}}_{\\omega}\", **kw),\n",
        "        )\n",
        "        top_eq.arrange(RIGHT)\n",
        "        top_eq[-1].align_to(top_eq[2], UP)\n",
        "        guess = Tex(R\"\\text{Guess } e^{{s}t}\", **kw)\n",
        "        guess.scale(0.75)\n",
        "        guess.next_to(arrow, UP, buff=0)\n",
        "        arrow.add(guess)\n",
        "\n",
        "        top_eq.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        top_eq.center().to_edge(UP)\n",
        "        self.add(top_eq)\n",
        "\n",
        "\n",
        "class ShowFamilyOfComplexSolutions(RotatingExponentials):\n",
        "    tex_to_color_map = {R\"\\omega\": PINK}\n",
        "    plane_config = dict(\n",
        "        background_line_style=dict(stroke_color=BLUE, stroke_width=1),\n",
        "        faded_line_style=dict(stroke_color=BLUE, stroke_width=0.5, stroke_opacity=0.25),\n",
        "    )\n",
        "    vect_colors = [TEAL, RED]\n",
        "    rotation_frequency = TAU / 4\n",
        "\n",
        "    def construct(self):\n",
        "        # Show the equation\n",
        "        frame = self.frame\n",
        "        frame.set_x(-10)\n",
        "\n",
        "        colors = get_coef_colors()\n",
        "        t2c = {\"x''(t)\": colors[2], \"x'(t)\": colors[1], \"x(t)\": colors[0]}\n",
        "        equation = Tex(R\"m x''(t) + k x(t) = 0\", t2c=t2c, font_size=42)\n",
        "        equation.next_to(frame.get_left(), RIGHT, buff=1.0)\n",
        "\n",
        "        arrow = Vector(3.0 * RIGHT, thickness=6, fill_color=GREY_B)\n",
        "        arrow.next_to(equation, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        strategy_words = VGroup(\n",
        "            Text(\"\u201cStrategy\u201d\"),\n",
        "            TexText(R\"Guess $e^{{s}t}$\", t2c={R\"{s}\": YELLOW}, font_size=36, fill_color=GREY_A)\n",
        "        )\n",
        "        strategy_words.arrange(DOWN)\n",
        "        strategy_words.next_to(arrow, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(strategy_words, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show two basis solutions on the left\n",
        "        t2c = self.tex_to_color_map\n",
        "        left_planes, left_plane_labels = self.get_left_planes(label_texs=[R\"e^{+i\\omega t}\", R\"e^{-i\\omega t}\"])\n",
        "        rot_vects, tails, t_tracker = self.get_rot_vects(left_planes)\n",
        "        left_planes_brace = Brace(left_planes, LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(rot_vects, tails)\n",
        "        self.add(t_tracker)\n",
        "        self.play(\n",
        "            GrowFromCenter(left_planes_brace),\n",
        "            FadeIn(left_planes),\n",
        "            FadeTransform(strategy_words[1][R\"e^{{s}t}\"].copy(), left_plane_labels[0]),\n",
        "            FadeTransform(strategy_words[1][R\"e^{{s}t}\"].copy(), left_plane_labels[1]),\n",
        "            VFadeIn(rot_vects),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show combination with tunable parameters\n",
        "        right_plane = self.get_right_plane()\n",
        "        right_plane.next_to(left_planes, RIGHT, buff=1.5)\n",
        "\n",
        "        scaled_solution = Tex(\n",
        "            R\"c_1 e^{+i\\omega t} + c_2 e^{-i\\omega t}\",\n",
        "            t2c={R\"\\omega\": PINK, \"c_1\": BLUE, \"c_2\": BLUE}\n",
        "        )\n",
        "        scaled_solution.next_to(right_plane, UP)\n",
        "\n",
        "        vect1, vect2 = right_rot_vects = self.get_rot_vect_sum(right_plane, t_tracker)\n",
        "        c1_eq, c2_eq = coef_eqs = VGroup(\n",
        "            VGroup(Tex(fR\"c_{n} = \"), DecimalNumber(1))\n",
        "            for n in [1, 2]\n",
        "        )\n",
        "        coef_eqs.scale(0.85)\n",
        "        for coef_eq in coef_eqs:\n",
        "            coef_eq.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            coef_eq[1].align_to(coef_eq[0][0], DOWN)\n",
        "            coef_eq[0][:2].set_fill(BLUE)\n",
        "        coef_eqs.arrange(DOWN, MED_LARGE_BUFF)\n",
        "        coef_eqs.to_corner(UR)\n",
        "        coef_eqs.shift(LEFT)\n",
        "\n",
        "        c1_eq[1].add_updater(lambda m: m.set_value(vect1.coef_tracker.get_value()))\n",
        "        c2_eq[1].add_updater(lambda m: m.set_value(vect2.coef_tracker.get_value()))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(right_plane),\n",
        "            FadeOut(left_planes_brace),\n",
        "            frame.animate.center(),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(left_plane_labels[0].copy(), scaled_solution[R\"e^{+i\\omega t}\"]),\n",
        "            FadeIn(scaled_solution[R\"c_1\"]),\n",
        "            TransformFromCopy(rot_vects[0], right_rot_vects[0], suspend_mobject_updating=True),\n",
        "            FadeTransform(left_plane_labels[1].copy(), scaled_solution[R\"e^{-i\\omega t}\"]),\n",
        "            FadeIn(scaled_solution[R\"+\"][1]),\n",
        "            FadeIn(scaled_solution[R\"c_2\"]),\n",
        "            TransformFromCopy(rot_vects[1], right_rot_vects[1], suspend_mobject_updating=True)\n",
        "        ))\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransformPieces(scaled_solution[R\"c_1\"].copy(), c1_eq),\n",
        "            FadeTransformPieces(scaled_solution[R\"c_2\"].copy(), c2_eq)\n",
        "        ))\n",
        "        self.play(LaggedStart(\n",
        "            vect1.coef_tracker.animate.set_value(2),\n",
        "            vect2.coef_tracker.animate.set_value(0.5),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "        comb_tail = TracingTail(vect2.get_end, stroke_color=YELLOW, time_traced=2)\n",
        "        glow_dot = GlowDot()\n",
        "        glow_dot.f_always.move_to(vect2.get_end)\n",
        "        self.add(comb_tail)\n",
        "        self.play(FadeIn(glow_dot))\n",
        "\n",
        "        self.wait(6)\n",
        "        self.play(LaggedStart(\n",
        "            vect1.coef_tracker.animate.set_value(complex(1.5, 1)),\n",
        "            vect2.coef_tracker.animate.set_value(complex(0.5, -1.25)),\n",
        "        ))\n",
        "        self.wait(7)\n",
        "\n",
        "        # Change the coefficients\n",
        "        t_tracker.suspend_updating()\n",
        "        self.play(\n",
        "            FadeOut(comb_tail, suspend_mobject_updating=True),\n",
        "            LaggedStart(\n",
        "                vect1.coef_tracker.animate.set_value(complex(0.31, -0.41)),\n",
        "                vect2.coef_tracker.animate.set_value(complex(2.71, -0.82)),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                vect1.coef_tracker.animate.set_value(complex(-1.03, 0.5)),\n",
        "                vect2.coef_tracker.animate.set_value(complex(1.5, 0.35)),\n",
        "            ),\n",
        "        )\n",
        "        self.add(comb_tail)\n",
        "        self.wait(2)\n",
        "        t_tracker.resume_updating()\n",
        "\n",
        "        # Zoom out\n",
        "        self.play(frame.animate.set_height(13.75, about_edge=RIGHT), run_time=2)\n",
        "        self.wait(4)\n",
        "        self.play(frame.animate.to_default_state(), run_time=2)\n",
        "\n",
        "        # Go to real valued\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                vect1.coef_tracker.animate.set_value(1),\n",
        "                vect2.coef_tracker.animate.set_value(1),\n",
        "            ),\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Show initial conditions\n",
        "        initial_conditions = VGroup(\n",
        "            Tex(R\"x_0 = 0.00\"),\n",
        "            Tex(R\"v_0 = 0.00\"),\n",
        "        )\n",
        "        x0_value = initial_conditions[0].make_number_changeable(\"0.00\")\n",
        "        v0_value = initial_conditions[1].make_number_changeable(\"0.00\")\n",
        "        x0_value.set_value(2)\n",
        "        initial_conditions.scale(0.85)\n",
        "        initial_conditions.arrange(DOWN)\n",
        "        initial_conditions.move_to(coef_eqs, LEFT)\n",
        "        initial_conditions.to_edge(UP)\n",
        "        implies = Tex(R\"\\Downarrow\", font_size=72)\n",
        "        implies.next_to(initial_conditions, DOWN)\n",
        "\n",
        "        t_tracker.suspend_updating()\n",
        "        t_tracker.set_value((t_tracker.get_value() + 2) % 4 - 2)\n",
        "        self.play(\n",
        "            FadeIn(initial_conditions),\n",
        "            Write(implies),\n",
        "            coef_eqs.animate.next_to(implies, DOWN).align_to(initial_conditions, LEFT),\n",
        "        )\n",
        "        self.remove(comb_tail)\n",
        "        self.play(\n",
        "            vect1.coef_tracker.animate.set_value(1),\n",
        "            vect2.coef_tracker.animate.set_value(1),\n",
        "            t_tracker.animate.set_value(0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(comb_tail)\n",
        "\n",
        "        # Highlight values, rise\n",
        "        t_tracker.resume_updating()\n",
        "\n",
        "        highlight_rect = SurroundingRectangle(initial_conditions[0])\n",
        "        highlight_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(highlight_rect))\n",
        "        self.wait()\n",
        "        self.play(highlight_rect.animate.surround(initial_conditions[1]))\n",
        "        self.wait(2)\n",
        "        self.play(highlight_rect.animate.surround(coef_eqs))\n",
        "        self.wait(4)\n",
        "\n",
        "        self.play(\n",
        "            vect1.coef_tracker.animate.set_value(1.5),\n",
        "            vect2.coef_tracker.animate.set_value(1.5),\n",
        "            ChangeDecimalToValue(x0_value, 3)\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "    def get_left_planes(self, label_texs: list[str]):\n",
        "        planes = VGroup(\n",
        "            ComplexPlane((-1, 1), (-1, 1), **self.plane_config)\n",
        "            for _ in range(2)\n",
        "        )\n",
        "        planes.arrange(DOWN, buff=1.0)\n",
        "        planes.set_height(6.5)\n",
        "        planes.to_corner(DL)\n",
        "        planes.set_z_index(-1)\n",
        "\n",
        "        labels = VGroup(Tex(tex, t2c=self.tex_to_color_map) for tex in label_texs)\n",
        "        for label, plane in zip(labels, planes):\n",
        "            label.next_to(plane, UP, SMALL_BUFF)\n",
        "\n",
        "        return planes, labels\n",
        "\n",
        "    def get_rot_vects(self, planes):\n",
        "        t_tracker = ValueTracker(0)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        rot_vects = VGroup(\n",
        "            self.get_rotating_vector(plane, u * 1j * self.rotation_frequency, t_tracker, color)\n",
        "            for plane, u, color in zip(planes, [+1, -1], self.vect_colors)\n",
        "        )\n",
        "        tails = VGroup(\n",
        "            TracingTail(vect.get_end, stroke_color=vect.get_color(), time_traced=2)\n",
        "            for vect in rot_vects\n",
        "        )\n",
        "\n",
        "        return Group(rot_vects, tails, t_tracker)\n",
        "\n",
        "    def get_rot_vect_sum(self, plane, t_tracker):\n",
        "        vect1, vect2 = vect_sum = VGroup(\n",
        "            self.get_rotating_vector(\n",
        "                plane,\n",
        "                u * 1j * self.rotation_frequency,\n",
        "                t_tracker,\n",
        "                color,\n",
        "            )\n",
        "            for u, color in zip([+1, -1], self.vect_colors)\n",
        "        )\n",
        "        vect2.add_updater(lambda m: m.put_start_on(vect1.get_end()))\n",
        "        return vect_sum\n",
        "\n",
        "    def get_right_plane(self, x_range=(-3, 3), height=5.5):\n",
        "        right_plane = ComplexPlane(x_range, x_range, **self.plane_config)\n",
        "        right_plane.set_height(height)\n",
        "        return right_plane\n",
        "\n",
        "    def add_scale_tracker(vector, initial_value=1):\n",
        "        \"\"\"\n",
        "        Assumes the vector has another updater constantly setting a location in the plane\n",
        "        \"\"\"\n",
        "        vector.c_tracker = ComplexValueTracker(initial_value)\n",
        "\n",
        "        def update_vector(vect):\n",
        "            c = vect.c_tracker.get_value()\n",
        "            vect.scale()\n",
        "            pass\n",
        "\n",
        "\n",
        "class GuessSine(InteractiveScene):\n",
        "    func_name = R\"\\sin\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        self.frame.set_height(9, about_edge=LEFT)\n",
        "        func_name = self.func_name\n",
        "        func_tex = Rf\"{func_name}(\\omega t)\"\n",
        "\n",
        "        t2c = {R\"\\omega\": PINK, \"x(t)\": TEAL, \"x''(t)\": RED}\n",
        "        equation = Tex(R\"m x''(t) + k x(t) = 0\", t2c=t2c)\n",
        "        equation.to_edge(LEFT)\n",
        "        guess_words = TexText(Rf\"Try $x(t) = {func_tex}$\", t2c=t2c, font_size=36)\n",
        "\n",
        "        arrow = Arrow(guess_words.get_left(), guess_words.get_right(), buff=-0.1, thickness=6)\n",
        "        arrow.next_to(equation, RIGHT)\n",
        "        guess_words.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.add(arrow)\n",
        "        self.add(guess_words)\n",
        "\n",
        "        # Sub\n",
        "        sub = Tex(fR\"-m \\omega^2 {func_tex}  + k {func_tex} = 0\", t2c=t2c)\n",
        "        sub.next_to(arrow, RIGHT)\n",
        "        simple_sub = Tex(Rf\"\\left(-m \\omega^2 + k\\right) {func_tex} = 0\", t2c=t2c)\n",
        "        simple_sub.next_to(arrow, RIGHT)\n",
        "        implies = Tex(R\"\\Rightarrow\", font_size=72)\n",
        "        implies.next_to(simple_sub, RIGHT)\n",
        "\n",
        "        t2c[R\"\\ding{51}\"] = GREEN\n",
        "        t2c[\"Valid\"] = GREEN\n",
        "        result = TexText(R\"\\ding{51} Valid if $\\omega = \\sqrt{k / m}$\", t2c=t2c, font_size=36)\n",
        "        result.next_to(simple_sub, DOWN)\n",
        "\n",
        "        simple_sub.shift(0.05 * UP)\n",
        "        blank_sub = sub.copy()\n",
        "        blank_sub[func_tex].set_opacity(0)\n",
        "        func_parts = sub[func_tex]\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformMatchingTex(equation.copy(), blank_sub, path_arc=30 * DEG, run_time=2),\n",
        "            FadeTransform(guess_words[func_tex][0].copy(), func_parts[0]),\n",
        "            FadeTransform(guess_words[func_tex][0].copy(), func_parts[1]),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(blank_sub, simple_sub),\n",
        "            Transform(func_parts[0], simple_sub[func_tex][0], path_arc=-30 * DEG),\n",
        "            Transform(func_parts[1], simple_sub[func_tex][0], path_arc=-30 * DEG),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(result, 0.5 * UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GuessCosine(GuessSine):\n",
        "    func_name = R\"\\cos\"\n",
        "\n",
        "\n",
        "class ShowFamilyOfRealSolutions(InteractiveScene):\n",
        "    t2c = {R\"\\omega\": PINK}\n",
        "    omega = PI\n",
        "    x_max = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # Add cosine and sine graphs up top\n",
        "        cos_graph, sin_graph = small_graphs = VGroup(\n",
        "            self.get_small_graph(math.cos, R\"\\cos(\\omega t)\", BLUE),\n",
        "            self.get_small_graph(math.sin, R\"\\sin(\\omega t)\", RED),\n",
        "        )\n",
        "        small_graphs.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        small_graphs.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(small_graphs)\n",
        "\n",
        "        # Add master graph\n",
        "        coef_trackers = ValueTracker(1).replicate(2)\n",
        "\n",
        "        def func(t):\n",
        "            c1 = coef_trackers[0].get_value()\n",
        "            c2 = coef_trackers[1].get_value()\n",
        "            return c1 * np.cos(self.omega * t) + c2 * np.sin(self.omega * t)\n",
        "\n",
        "        axes = Axes((0, self.x_max), (-3, 3), width=self.x_max, height=4)\n",
        "        axes.to_edge(DOWN)\n",
        "        graph_label = Tex(R\"+1.00 \\cos(\\omega t) +1.00 \\sin(\\omega t)\", t2c=self.t2c)\n",
        "        graph_label.next_to(axes.y_axis.get_top(), UR)\n",
        "        coef_labels = graph_label.make_number_changeable(\"+1.00\", replace_all=True, edge_to_fix=RIGHT, include_sign=True)\n",
        "        coef_labels.set_color(YELLOW)\n",
        "        coef_labels[0].add_updater(lambda m: m.set_value(coef_trackers[0].get_value()))\n",
        "        coef_labels[1].add_updater(lambda m: m.set_value(coef_trackers[1].get_value()))\n",
        "\n",
        "        graph = axes.get_graph(func)\n",
        "        graph.set_stroke(TEAL, 5)\n",
        "        axes.bind_graph_to_func(graph, func)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph_label)\n",
        "        self.add(graph)\n",
        "\n",
        "        # Tweak the parameters\n",
        "        for c1, c2 in [(-0.5, 2), (1.5, 0), (0.25, -2)]:\n",
        "            self.play(LaggedStart(\n",
        "                coef_trackers[0].animate.set_value(c1),\n",
        "                coef_trackers[1].animate.set_value(c2),\n",
        "                lag_ratio=0.5\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        # Tweak with spring\n",
        "        for c1, c2 in [(1.6, 1.8), (-2.7, 0.18), (0.5, -2)]:\n",
        "            self.play(LaggedStart(\n",
        "                coef_trackers[0].animate.set_value(c1),\n",
        "                coef_trackers[1].animate.set_value(c2),\n",
        "                lag_ratio=0.5\n",
        "            ))\n",
        "            self.show_spring(axes, graph, func)\n",
        "\n",
        "    def get_small_graph(self, func, func_name, color):\n",
        "        axes = Axes((0, 6), (-2, 2), height=2, width=6)\n",
        "        graph = axes.get_graph(lambda t: func(self.omega * t))\n",
        "        graph.set_stroke(color, 3)\n",
        "        label = Tex(func_name, t2c=self.t2c, font_size=36)\n",
        "        label.move_to(axes, UP)\n",
        "\n",
        "        return VGroup(axes, graph, label)\n",
        "\n",
        "    def show_spring(self, axes, graph, func):\n",
        "        graph_copy = graph.copy()\n",
        "        graph_copy.clear_updaters()\n",
        "\n",
        "        spring = SrpingMassSystem(\n",
        "            equilibrium_length=4,\n",
        "            equilibrium_position=axes.get_right() + RIGHT,\n",
        "            direction=UP,\n",
        "            mass_width=0.75,\n",
        "            spring_radius=0.2,\n",
        "        )\n",
        "        spring.add_updater(\n",
        "            lambda m: m.set_x(axes.y_axis.get_unit_size() * axes.y_axis.p2n(graph_copy.get_end()))\n",
        "        )\n",
        "\n",
        "        h_line = Line()\n",
        "        h_line.set_stroke(WHITE, 1)\n",
        "        h_line.f_always.put_start_and_end_on(\n",
        "            spring.mass.get_left,\n",
        "            graph_copy.get_end,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            graph.animate.set_stroke(opacity=0.2),\n",
        "            ShowCreation(graph_copy, rate_func=linear, run_time=self.x_max),\n",
        "            VFadeIn(spring, run_time=1),\n",
        "            VFadeIn(h_line, run_time=1),\n",
        "        )\n",
        "        self.play(FadeOut(spring), FadeOut(h_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(graph_copy, spring, h_line)\n",
        "        graph.set_stroke(opacity=1)\n",
        "\n",
        "\n",
        "class SetOfInitialConditions(InteractiveScene):\n",
        "    graph_time = 8\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up all boxes\n",
        "        frame = self.frame\n",
        "        box = Rectangle(width=3.5, height=2.0)\n",
        "        box.set_stroke(WHITE, 1)\n",
        "        v_line = DashedLine(box.get_top(), box.get_bottom())\n",
        "        v_line.set_stroke(GREY_C, 1, 0.5)\n",
        "        v_line.scale(0.9)\n",
        "        box.add(v_line)\n",
        "\n",
        "        n_rows = 5\n",
        "        n_cols = 5\n",
        "        box_row = box.get_grid(1, n_cols, buff=0)\n",
        "        box_grid = box_row.get_grid(n_rows, 1, buff=0)\n",
        "        for row, v0 in zip(box_grid, np.linspace(1, -1, n_rows)):\n",
        "            for box, x0 in zip(row, np.linspace(-1, 1, n_cols)):\n",
        "                box.spring = self.get_spring_in_a_box(box, x0=x0, v0=v0)\n",
        "\n",
        "        # Show the first example\n",
        "        mid_row = box_grid[n_rows // 2]\n",
        "        x0_labels = VGroup(\n",
        "            Tex(Rf\"x_0 = {x0}\", font_size=48).next_to(box, UP, SMALL_BUFF)\n",
        "            for x0, box in zip(range(-2, 3), mid_row)\n",
        "        )\n",
        "        mid_row_springs = VGroup(box.spring for box in mid_row)\n",
        "\n",
        "        mid_row_solutions = VGroup(\n",
        "            self.get_solution_graph(box, x0=x0)\n",
        "            for box, x0 in zip(mid_row, range(-2, 3))\n",
        "        )\n",
        "        last_solution = mid_row_solutions[-1]\n",
        "\n",
        "        last_box = mid_row[-1]\n",
        "        last_spring = last_box.spring\n",
        "        top_line = Line(last_box.get_center(), last_spring.mass.get_center())\n",
        "        top_line.set_y(last_spring.mass.get_y(UP))\n",
        "        brace = LineBrace(Line(ORIGIN, 1.5 * RIGHT))\n",
        "        brace.match_width(top_line)\n",
        "        brace.next_to(top_line, UP, SMALL_BUFF)\n",
        "        brace.stretch(0.5, 1, about_edge=DOWN)\n",
        "        last_x = last_spring.get_x()\n",
        "        last_spring.set_x(0)\n",
        "\n",
        "        self.add(last_box, last_spring)\n",
        "        frame.move_to(mid_row[-1]).set_height(5)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromPoint(brace, brace.get_left()),\n",
        "            last_spring.animate.set_x(last_x),\n",
        "            Write(x0_labels[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        last_spring.unpause()\n",
        "        last_spring.v_vect.set_opacity(0)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (6.7, -0.61, 0.0), 6.16).set_anim_args(run_time=2),\n",
        "            FadeIn(last_solution[0]),\n",
        "            ShowCreation(last_solution[1], rate_func=linear, run_time=self.graph_time)\n",
        "        )\n",
        "        last_spring.pause()\n",
        "\n",
        "        # Show the full middle row\n",
        "        self.play(\n",
        "            frame.animate.center().set_width(box_grid.get_width() + 2).set_anim_args(time_span=(0, 1.5)),\n",
        "            last_spring.animate.set_x(1).set_anim_args(time_span=(0, 1)),\n",
        "            LaggedStartMap(FadeIn, VGroup(*reversed(mid_row[:-1])), lag_ratio=0.75),\n",
        "            LaggedStartMap(FadeIn, VGroup(*reversed(mid_row_springs[:-1])), lag_ratio=0.75),\n",
        "            LaggedStartMap(FadeIn, VGroup(*reversed(x0_labels[:-1])), lag_ratio=0.75),\n",
        "            LaggedStartMap(FadeIn, VGroup(*reversed(mid_row_solutions[:-1])), lag_ratio=0.75),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        graphs = VGroup(solution[1] for solution in mid_row_solutions)\n",
        "        faint_graphs = graphs.copy().set_stroke(width=1, opacity=0.25)\n",
        "        for spring in mid_row_springs:\n",
        "            spring.unpause()\n",
        "            spring.v_vect.set_opacity(0)\n",
        "            spring.x0 = spring.get_x()\n",
        "        self.add(faint_graphs)\n",
        "        self.play(\n",
        "            ShowCreation(graphs, lag_ratio=0, run_time=self.graph_time, rate_func=linear),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(faint_graphs)\n",
        "        for spring in mid_row_springs:\n",
        "            spring.pause()\n",
        "            spring.v_vect.set_opacity(0)\n",
        "            spring.set_velocity(0)\n",
        "        self.play(\n",
        "            FadeOut(mid_row_solutions),\n",
        "            *(spring.animate.set_x(spring.x0) for spring in mid_row_springs)\n",
        "        )\n",
        "\n",
        "        # Show initial velocities\n",
        "        v0_labels = VGroup(\n",
        "            Tex(Rf\"v_0 = {v0}\", font_size=48).next_to(row, LEFT).set_fill(TEAL)\n",
        "            for v0, row in zip(range(2, -3, -1), box_grid)\n",
        "        )\n",
        "        other_indices = [0, 1, 3, 4]\n",
        "        row_springs = VGroup(VGroup(box.spring for box in row) for row in box_grid)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_width(box_grid.get_width() + 3, about_edge=DR),\n",
        "            Write(v0_labels[2])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, VGroup(box_grid[i] for i in other_indices), lag_ratio=0.5, run_time=3),\n",
        "            LaggedStartMap(FadeIn, VGroup(v0_labels[i] for i in other_indices), lag_ratio=0.5, run_time=3),\n",
        "            LaggedStartMap(FadeIn, VGroup(row_springs[i] for i in other_indices), lag_ratio=0.5, run_time=3),\n",
        "            x0_labels.animate.next_to(box_grid, UP, SMALL_BUFF).set_anim_args(run_time=1),\n",
        "            FadeOut(brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Let it play\n",
        "        for row in box_grid:\n",
        "            for box in row:\n",
        "                box.spring.unpause()\n",
        "\n",
        "        self.wait(20)\n",
        "\n",
        "        # Add graphs\n",
        "        all_solutions = VGroup(\n",
        "            self.get_solution_graph(box, x0=x0, v0=v0, graph_color=YELLOW).move_to(box).scale(0.8)\n",
        "            for row, v0 in zip(box_grid, range(2, -3, -1))\n",
        "            for box, x0 in zip(row, range(-2, 3))\n",
        "        )\n",
        "        all_axes = VGroup(s[0] for s in all_solutions)\n",
        "        all_graphs = VGroup(s[1] for s in all_solutions)\n",
        "\n",
        "        self.remove(*(box.spring for row in box_grid for box in row))\n",
        "        self.add(all_axes)\n",
        "        self.play(ShowCreation(all_graphs, lag_ratio=1e-1, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight one\n",
        "        highlight = all_solutions[14].copy()\n",
        "        self.add(highlight)\n",
        "        self.play(all_solutions.animate.fade(0.75))\n",
        "        self.wait()\n",
        "\n",
        "    def get_spring_in_a_box(self, box, x0=0, v0=0, k=9, mu=0.5):\n",
        "        box_width = box.get_width()\n",
        "        spring = SrpingMassSystem(\n",
        "            x0=x0,\n",
        "            v0=v0,\n",
        "            k=k,\n",
        "            mu=mu,\n",
        "            mass_width=0.1 * box_width,\n",
        "            equilibrium_length=0.5 * box_width,\n",
        "            equilibrium_position=box.get_center(),\n",
        "            spring_radius=0.035 * box_width,\n",
        "        )\n",
        "        v_vect = spring.get_velocity_vector(v_offset=-box_width * 0.1, scale_factor=0.5)\n",
        "        spring.add(v_vect)\n",
        "        spring.v_vect = v_vect\n",
        "        spring.pause()\n",
        "        return spring\n",
        "\n",
        "    def get_solution_graph(self, box, x0=2, v0=0, k=9, mu=0.5, width_factor=0.8, graph_color=TEAL):\n",
        "        axes = Axes(\n",
        "            x_range=(0, self.graph_time, 1),\n",
        "            y_range=(-2, 2),\n",
        "            width=width_factor * box.get_width(),\n",
        "            height=box.get_height(),\n",
        "        )\n",
        "        axes.set_stroke(GREY, 1)\n",
        "        axes.next_to(box, DOWN)\n",
        "\n",
        "        s = 0.5 * (-mu + 1j * math.sqrt(4 * k - mu**2))\n",
        "        z0 = complex(\n",
        "            x0,\n",
        "            (s.real * x0 - v0) / s.imag\n",
        "        )\n",
        "\n",
        "        graph = axes.get_graph(\n",
        "            lambda t: (z0 * np.exp(s * t)).real,\n",
        "        )\n",
        "        graph.set_stroke(graph_color, 2)\n",
        "        return VGroup(axes, graph)\n"
    ]
}