{
    "topic": "demonstrates the concept of weighted coins and how they can be used to calculate",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2020.beta.helpers import *\n",
        "from _2020.beta.beta1 import *\n",
        "from _2020.beta.beta2 import ShowLimitToPdf\n",
        "\n",
        "import scipy.stats\n",
        "\n",
        "OUTPUT_DIRECTORY = \"bayes/beta3\"\n",
        "\n",
        "\n",
        "class RemindOfWeightedCoin(Scene):\n",
        "    def construct(self):\n",
        "        # Largely copied from beta2\n",
        "\n",
        "        # Prob label\n",
        "        p_label = get_prob_coin_label()\n",
        "        p_label.set_height(0.7)\n",
        "        p_label.to_edge(UP)\n",
        "\n",
        "        rhs = p_label[-1]\n",
        "        q_box = get_q_box(rhs)\n",
        "        p_label.add(q_box)\n",
        "\n",
        "        self.add(p_label)\n",
        "\n",
        "        # Coin grid\n",
        "        def get_random_coin_grid(p):\n",
        "            bools = np.random.random(100) < p\n",
        "            grid = get_coin_grid(bools)\n",
        "            return grid\n",
        "\n",
        "        grid = get_random_coin_grid(0.5)\n",
        "        grid.next_to(p_label, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, grid,\n",
        "            lag_ratio=2 / len(grid),\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Label as h\n",
        "        brace = Brace(q_box, DOWN, buff=SMALL_BUFF)\n",
        "        h_label = OldTex(\"h\")\n",
        "        h_label.next_to(brace, DOWN)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(h_label, RIGHT)\n",
        "        h_decimal = DecimalNumber(0.5)\n",
        "        h_decimal.next_to(eq, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(h_label, UP),\n",
        "            grid.scale, 0.8, {\"about_edge\": DOWN},\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Alternate weightings\n",
        "        tail_grid = get_random_coin_grid(0)\n",
        "        head_grid = get_random_coin_grid(1)\n",
        "        grid70 = get_random_coin_grid(0.7)\n",
        "        alt_grids = [tail_grid, head_grid, grid70]\n",
        "        for ag in alt_grids:\n",
        "            ag.replace(grid)\n",
        "\n",
        "        for coins in [grid, *alt_grids]:\n",
        "            for coin in coins:\n",
        "                coin.generate_target()\n",
        "                coin.target.rotate(90 * DEGREES, axis=UP)\n",
        "                coin.target.set_opacity(0)\n",
        "\n",
        "        def get_grid_swap_anims(g1, g2):\n",
        "            return [\n",
        "                LaggedStartMap(MoveToTarget, g1, lag_ratio=0.02, run_time=1.5, remover=True),\n",
        "                LaggedStartMap(MoveToTarget, g2, lag_ratio=0.02, run_time=1.5, rate_func=reverse_smooth),\n",
        "            ]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(eq),\n",
        "            UpdateFromAlphaFunc(h_decimal, lambda m, a: m.set_opacity(a)),\n",
        "            ChangeDecimalToValue(h_decimal, 0, run_time=2),\n",
        "            *get_grid_swap_anims(grid, tail_grid)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(h_decimal, 1, run_time=1.5),\n",
        "            *get_grid_swap_anims(tail_grid, head_grid)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(h_decimal, 0.7, run_time=1.5),\n",
        "            *get_grid_swap_anims(head_grid, grid70)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Graph\n",
        "        axes = scaled_pdf_axes()\n",
        "        axes.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        axes.y_axis.numbers.set_opacity(0)\n",
        "        axes.y_axis_label.set_opacity(0)\n",
        "\n",
        "        h_lines = VGroup()\n",
        "        for y in range(15):\n",
        "            h_line = Line(axes.c2p(0, y), axes.c2p(1, y))\n",
        "            h_lines.add(h_line)\n",
        "        h_lines.set_stroke(WHITE, 0.5, opacity=0.5)\n",
        "        axes.add(h_lines)\n",
        "\n",
        "        x_axis_label = p_label[:4].copy()\n",
        "        x_axis_label.set_height(0.4)\n",
        "        x_axis_label.next_to(axes.c2p(1, 0), UR, buff=SMALL_BUFF)\n",
        "        axes.x_axis.add(x_axis_label)\n",
        "\n",
        "        n_heads_tracker = ValueTracker(3)\n",
        "        n_tails_tracker = ValueTracker(3)\n",
        "\n",
        "        def get_graph(axes=axes, nht=n_heads_tracker, ntt=n_tails_tracker):\n",
        "            dist = scipy.stats.beta(nht.get_value() + 1, ntt.get_value() + 1)\n",
        "            graph = axes.get_graph(dist.pdf, step_size=0.05)\n",
        "            graph.set_stroke(BLUE, 3)\n",
        "            graph.set_fill(BLUE_E, 1)\n",
        "            return graph\n",
        "\n",
        "        graph = always_redraw(get_graph)\n",
        "\n",
        "        area_label = OldTexText(\"Area = 1\")\n",
        "        area_label.set_height(0.5)\n",
        "        area_label.move_to(axes.c2p(0.5, 1))\n",
        "\n",
        "        # pdf label\n",
        "        pdf_label = OldTexText(\"probability \", \"density \", \"function\")\n",
        "        pdf_label.next_to(axes.input_to_graph_point(0.5, graph), UP)\n",
        "        pdf_target_template = OldTexText(\"p\", \"d\", \"f\")\n",
        "        pdf_target_template.next_to(axes.input_to_graph_point(0.7, graph), UR)\n",
        "        pdf_label.generate_target()\n",
        "        for part, letter2 in zip(pdf_label.target, pdf_target_template):\n",
        "            for letter1 in part:\n",
        "                letter1.move_to(letter2)\n",
        "            part[1:].set_opacity(0)\n",
        "\n",
        "        # Add plot\n",
        "        self.add(axes, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeOut(eq),\n",
        "            FadeOut(h_decimal),\n",
        "            LaggedStartMap(MoveToTarget, grid70, run_time=1, remover=True),\n",
        "            FadeIn(axes),\n",
        "        )\n",
        "        self.play(\n",
        "            DrawBorderThenFill(graph),\n",
        "            FadeIn(area_label, rate_func=squish_rate_func(smooth, 0.5, 1), run_time=2),\n",
        "            Write(pdf_label, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Region\n",
        "        lh_tracker = ValueTracker(0.7)\n",
        "        rh_tracker = ValueTracker(0.7)\n",
        "\n",
        "        def get_region(axes=axes, graph=graph, lh_tracker=lh_tracker, rh_tracker=rh_tracker):\n",
        "            lh = lh_tracker.get_value()\n",
        "            rh = rh_tracker.get_value()\n",
        "            region = get_region_under_curve(axes, graph, lh, rh)\n",
        "            region.set_fill(GREY, 0.85)\n",
        "            region.set_stroke(YELLOW, 1)\n",
        "            return region\n",
        "\n",
        "        region = always_redraw(get_region)\n",
        "\n",
        "        region_area_label = DecimalNumber(num_decimal_places=3)\n",
        "        region_area_label.next_to(axes.c2p(0.7, 0), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        def update_ra_label(label, nht=n_heads_tracker, ntt=n_tails_tracker, lht=lh_tracker, rht=rh_tracker):\n",
        "            dist = scipy.stats.beta(nht.get_value() + 1, ntt.get_value() + 1)\n",
        "            area = dist.cdf(rht.get_value()) - dist.cdf(lht.get_value())\n",
        "            label.set_value(area)\n",
        "\n",
        "        region_area_label.add_updater(update_ra_label)\n",
        "\n",
        "        range_label = VGroup(\n",
        "            OldTex(\"0.6 \\\\le\"),\n",
        "            p_label[:4].copy(),\n",
        "            OldTex(\"\\\\le 0.8\"),\n",
        "        )\n",
        "        for mob in range_label:\n",
        "            mob.set_height(0.4)\n",
        "        range_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        pp_label = VGroup(\n",
        "            OldTex(\"P(\"),\n",
        "            range_label,\n",
        "            OldTex(\")\"),\n",
        "        )\n",
        "        for mob in pp_label[::2]:\n",
        "            mob.set_height(0.7)\n",
        "            mob.set_color(YELLOW)\n",
        "        pp_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        pp_label.move_to(axes.c2p(0.3, 3))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pp_label[::2]),\n",
        "            MoveToTarget(pdf_label),\n",
        "            FadeOut(area_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(p_label[:4], range_label[1]))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(axes.x_axis.numbers[2], range_label[0]))\n",
        "        self.play(TransformFromCopy(axes.x_axis.numbers[3], range_label[2]))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(region)\n",
        "        self.play(\n",
        "            lh_tracker.set_value, 0.6,\n",
        "            rh_tracker.set_value, 0.8,\n",
        "            UpdateFromAlphaFunc(\n",
        "                region_area_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "                rate_func=squish_rate_func(smooth, 0.25, 1)\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 7/10 heads\n",
        "        bools = [True] * 7 + [False] * 3\n",
        "        random.shuffle(bools)\n",
        "        coins = VGroup(*[\n",
        "            get_coin(\"H\" if heads else \"T\")\n",
        "            for heads in bools\n",
        "        ])\n",
        "        coins.arrange(RIGHT)\n",
        "        coins.set_height(0.7)\n",
        "        coins.next_to(h_label, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        heads = [c for c in coins if c.symbol == \"H\"]\n",
        "        numbers = VGroup(*[\n",
        "            Integer(i + 1).set_height(0.2).next_to(coin, DOWN, SMALL_BUFF)\n",
        "            for i, coin in enumerate(heads)\n",
        "        ])\n",
        "\n",
        "        for coin in coins:\n",
        "            coin.save_state()\n",
        "            coin.rotate(90 * DEGREES, UP)\n",
        "            coin.set_opacity(0)\n",
        "\n",
        "        pp_label.generate_target()\n",
        "        pp_label.target.set_height(0.5)\n",
        "        pp_label.target.next_to(axes.c2p(0, 2), RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, coins),\n",
        "            MoveToTarget(pp_label),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(ShowIncreasingSubsets(numbers))\n",
        "        self.wait()\n",
        "\n",
        "        # Move plot\n",
        "        self.play(\n",
        "            n_heads_tracker.set_value, 7,\n",
        "            n_tails_tracker.set_value, 3,\n",
        "            FadeOut(pdf_label, rate_func=squish_rate_func(smooth, 0, 0.5)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # How does the answer change with more data\n",
        "        new_bools = [True] * 63 + [False] * 27\n",
        "        random.shuffle(new_bools)\n",
        "        bools = [c.symbol == \"H\" for c in coins] + new_bools\n",
        "        grid = get_coin_grid(bools)\n",
        "        grid.set_height(3.5)\n",
        "        grid.next_to(axes.c2p(0, 3), RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(numbers),\n",
        "            ReplacementTransform(coins, grid[:10]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(grid[10:], lag_ratio=0.1, rate_func=linear),\n",
        "            pp_label.next_to, grid, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(graph, region, region_area_label, p_label, q_box, brace, h_label)\n",
        "        self.play(\n",
        "            n_heads_tracker.set_value, 70,\n",
        "            n_tails_tracker.set_value, 30,\n",
        "        )\n",
        "        self.wait()\n",
        "        origin = axes.c2p(0, 0)\n",
        "        self.play(\n",
        "            axes.y_axis.stretch, 0.5, 1, {\"about_point\": origin},\n",
        "            h_lines.stretch, 0.5, 1, {\"about_point\": origin},\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shift the shape around\n",
        "        pairs = [\n",
        "            (70 * 3, 30 * 3),\n",
        "            (35, 15),\n",
        "            (35 + 20, 15 + 20),\n",
        "            (7, 3),\n",
        "            (70, 30),\n",
        "        ]\n",
        "        for nh, nt in pairs:\n",
        "            self.play(\n",
        "                n_heads_tracker.set_value, nh,\n",
        "                n_tails_tracker.set_value, nt,\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # End\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class LastTimeWrapper(Scene):\n",
        "    def construct(self):\n",
        "        fs_rect = FullScreenFadeRectangle(fill_opacity=1, fill_color=GREY_E)\n",
        "        self.add(fs_rect)\n",
        "\n",
        "        title = OldTexText(\"Last Time\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_height(6)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(rect),\n",
        "            FadeInFromDown(title),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ComplainAboutSimplisticModel(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class BayesianFrequentistDivide(Scene):\n",
        "    def construct(self):\n",
        "        # Setup Bayesian vs. Frequentist divide\n",
        "        b_label = OldTexText(\"Bayesian\")\n",
        "        f_label = OldTexText(\"Frequentist\")\n",
        "        labels = VGroup(b_label, f_label)\n",
        "        for label, vect in zip(labels, [LEFT, RIGHT]):\n",
        "            label.set_height(0.7)\n",
        "            label.move_to(vect * FRAME_WIDTH / 4)\n",
        "            label.to_edge(UP, buff=0.35)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(labels, DOWN)\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_height(FRAME_HEIGHT)\n",
        "        v_line.center()\n",
        "\n",
        "        for label in labels:\n",
        "            label.save_state()\n",
        "            label.set_y(0)\n",
        "            self.play(\n",
        "                FadeIn(label, -normalize(label.get_center())),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(VGroup(v_line, h_line)),\n",
        "            *map(Restore, labels),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Overlay ShowBayesianUpdating in editing\n",
        "        # Frequentist list (ignore?)\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"$p$-value\": YELLOW,\n",
        "                \"$H_0$\": PINK,\n",
        "                \"$\\\\alpha$\": BLUE,\n",
        "            },\n",
        "            \"alignment\": \"\",\n",
        "        }\n",
        "        freq_list = VGroup(\n",
        "            OldTexText(\"1. State a null hypothesis $H_0$\", **kw),\n",
        "            OldTexText(\"2. Choose a test statistic,\\\\\\\\\", \"$\\\\qquad$ compute its value\", **kw),\n",
        "            OldTexText(\"3. Calculate a $p$-value\", **kw),\n",
        "            OldTexText(\"4. Choose a significance value $\\\\alpha$\", **kw),\n",
        "            OldTexText(\"5. Reject $H_0$ if $p$-value\\\\\\\\\", \"$\\\\qquad$ is less than $\\\\alpha$\", **kw),\n",
        "        )\n",
        "\n",
        "        freq_list.set_width(0.5 * FRAME_WIDTH - 1)\n",
        "        freq_list.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        freq_list.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        freq_list.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        # Frequentist icon\n",
        "        axes = get_beta_dist_axes(y_max=5, y_unit=1)\n",
        "        axes.set_width(0.5 * FRAME_WIDTH - 1)\n",
        "        axes.move_to(FRAME_WIDTH * RIGHT / 4 + DOWN)\n",
        "\n",
        "        dist = scipy.stats.norm(0.5, 0.1)\n",
        "        graph = axes.get_graph(dist.pdf)\n",
        "        graphs = VGroup()\n",
        "        for x_min, x_max in [(0, 0.3), (0.3, 0.7), (0.7, 1.0)]:\n",
        "            graph = axes.get_graph(dist.pdf, x_min=x_min, x_max=x_max)\n",
        "            graph.add_line_to(axes.c2p(x_max, 0))\n",
        "            graph.add_line_to(axes.c2p(x_min, 0))\n",
        "            graph.add_line_to(graph.get_start())\n",
        "            graphs.add(graph)\n",
        "\n",
        "        graphs.set_stroke(width=0)\n",
        "        graphs.set_fill(RED, 1)\n",
        "        graphs[1].set_fill(GREY_D, 1)\n",
        "\n",
        "        H_words = VGroup(*[TexText(\"Reject\\\\\\\\$H_0$\") for x in range(2)])\n",
        "        for H_word, graph, vect in zip(H_words, graphs[::2], [RIGHT, LEFT]):\n",
        "            H_word.next_to(graph, UP, MED_LARGE_BUFF)\n",
        "            arrow = Arrow(\n",
        "                H_word.get_bottom(),\n",
        "                graph.get_center() + 0.75 * vect,\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            H_word.add(arrow)\n",
        "\n",
        "        H_words.set_color(RED)\n",
        "        self.add(H_words)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graphs)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "        # Transition to 2x2\n",
        "        # Go back to prior\n",
        "        # Label uniform prior\n",
        "        # Talk about real coin prior\n",
        "        # Update ad infinitum\n",
        "\n",
        "\n",
        "class ArgumentBetweenBayesianAndFrequentist(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "# From version 1\n",
        "class ShowBayesianUpdating(Scene):\n",
        "    CONFIG = {\n",
        "        \"true_p\": 0.72,\n",
        "        \"random_seed\": 4,\n",
        "        \"initial_axis_scale_factor\": 3.5\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = scaled_pdf_axes(self.initial_axis_scale_factor)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Graph\n",
        "        n_heads = 0\n",
        "        n_tails = 0\n",
        "        graph = get_beta_graph(axes, n_heads, n_tails)\n",
        "        self.add(graph)\n",
        "\n",
        "        # Get coins\n",
        "        true_p = self.true_p\n",
        "        bool_values = np.random.random(100) < true_p\n",
        "        bool_values[1] = True\n",
        "        coins = self.get_coins(bool_values)\n",
        "        coins.next_to(axes.y_axis, RIGHT, MED_LARGE_BUFF)\n",
        "        coins.to_edge(UP, LARGE_BUFF)\n",
        "\n",
        "        # Probability label\n",
        "        p_label, prob, prob_box = self.get_probability_label()\n",
        "        self.add(p_label)\n",
        "        self.add(prob_box)\n",
        "\n",
        "        # Slow animations\n",
        "        def head_likelihood(x):\n",
        "            return x\n",
        "\n",
        "        def tail_likelihood(x):\n",
        "            return 1 - x\n",
        "\n",
        "        n_previews = 10\n",
        "        n_slow_previews = 5\n",
        "        for x in range(n_previews):\n",
        "            coin = coins[x]\n",
        "            is_heads = bool_values[x]\n",
        "\n",
        "            new_data_label = OldTexText(\"New data\")\n",
        "            new_data_label.set_height(0.3)\n",
        "            arrow = Vector(0.5 * UP)\n",
        "            arrow.next_to(coin, DOWN, SMALL_BUFF)\n",
        "            new_data_label.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "            new_data_label.shift(MED_SMALL_BUFF * RIGHT)\n",
        "\n",
        "            if is_heads:\n",
        "                line = axes.get_graph(lambda x: x)\n",
        "                label = OldTex(\"\\\\text{Scale by } x\")\n",
        "                likelihood = head_likelihood\n",
        "                n_heads += 1\n",
        "            else:\n",
        "                line = axes.get_graph(lambda x: 1 - x)\n",
        "                label = OldTex(\"\\\\text{Scale by } (1 - x)\")\n",
        "                likelihood = tail_likelihood\n",
        "                n_tails += 1\n",
        "            label.next_to(graph, UP)\n",
        "            label.set_stroke(BLACK, 3, background=True)\n",
        "            line.set_stroke(YELLOW, 3)\n",
        "\n",
        "            graph_copy = graph.copy()\n",
        "            scaled_graph = graph.copy()\n",
        "            scaled_graph.apply_function(\n",
        "                lambda p: axes.c2p(\n",
        "                    axes.x_axis.p2n(p),\n",
        "                    axes.y_axis.p2n(p) * likelihood(axes.x_axis.p2n(p))\n",
        "                )\n",
        "            )\n",
        "            scaled_graph.set_color(GREEN)\n",
        "\n",
        "            renorm_label = OldTexText(\"Renormalize\")\n",
        "            renorm_label.move_to(label)\n",
        "\n",
        "            new_graph = get_beta_graph(axes, n_heads, n_tails)\n",
        "\n",
        "            renormalized_graph = scaled_graph.copy()\n",
        "            renormalized_graph.match_style(graph)\n",
        "            renormalized_graph.match_height(new_graph, stretch=True, about_edge=DOWN)\n",
        "\n",
        "            if x < n_slow_previews:\n",
        "                self.play(\n",
        "                    FadeInFromDown(coin),\n",
        "                    FadeIn(new_data_label),\n",
        "                    GrowArrow(arrow),\n",
        "                )\n",
        "                self.play(\n",
        "                    FadeOut(new_data_label),\n",
        "                    FadeOut(arrow),\n",
        "                    ShowCreation(line),\n",
        "                    FadeIn(label),\n",
        "                )\n",
        "                self.add(graph_copy, line, label)\n",
        "                self.play(Transform(graph_copy, scaled_graph))\n",
        "                self.play(\n",
        "                    FadeOut(line),\n",
        "                    FadeOut(label),\n",
        "                    FadeIn(renorm_label),\n",
        "                )\n",
        "                self.play(\n",
        "                    Transform(graph_copy, renormalized_graph),\n",
        "                    FadeOut(graph),\n",
        "                )\n",
        "                self.play(FadeOut(renorm_label))\n",
        "            else:\n",
        "                self.add(coin)\n",
        "                graph_copy.become(scaled_graph)\n",
        "                self.add(graph_copy)\n",
        "                self.play(\n",
        "                    Transform(graph_copy, renormalized_graph),\n",
        "                    FadeOut(graph),\n",
        "                )\n",
        "            graph = new_graph\n",
        "            self.remove(graph_copy)\n",
        "            self.add(new_graph)\n",
        "\n",
        "        # Rescale y axis\n",
        "        axes.save_state()\n",
        "        sf = self.initial_axis_scale_factor\n",
        "        axes.y_axis.stretch(1 / sf, 1, about_point=axes.c2p(0, 0))\n",
        "        for number in axes.y_axis.numbers:\n",
        "            number.stretch(sf, 1)\n",
        "        axes.y_axis.numbers[:4].set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            Restore(axes, rate_func=lambda t: smooth(1 - t)),\n",
        "            graph.stretch, 1 / sf, 1, {\"about_edge\": DOWN},\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Fast animations\n",
        "        for x in range(n_previews, len(coins)):\n",
        "            coin = coins[x]\n",
        "            is_heads = bool_values[x]\n",
        "\n",
        "            if is_heads:\n",
        "                n_heads += 1\n",
        "            else:\n",
        "                n_tails += 1\n",
        "            new_graph = get_beta_graph(axes, n_heads, n_tails)\n",
        "\n",
        "            self.add(coins[:x + 1])\n",
        "            self.add(new_graph)\n",
        "            self.remove(graph)\n",
        "            self.wait(0.25)\n",
        "            # self.play(\n",
        "            #     FadeIn(new_graph),\n",
        "            #     run_time=0.25,\n",
        "            # )\n",
        "            # self.play(\n",
        "            #     FadeOut(graph),\n",
        "            #     run_time=0.25,\n",
        "            # )\n",
        "            graph = new_graph\n",
        "\n",
        "        # Show confidence interval\n",
        "        dist = scipy.stats.beta(n_heads + 1, n_tails + 1)\n",
        "        v_lines = VGroup()\n",
        "        labels = VGroup()\n",
        "        x_bounds = dist.interval(0.95)\n",
        "        for x in x_bounds:\n",
        "            line = DashedLine(\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x, 12),\n",
        "            )\n",
        "            line.set_color(YELLOW)\n",
        "            v_lines.add(line)\n",
        "            label = DecimalNumber(x)\n",
        "            label.set_height(0.25)\n",
        "            label.next_to(line, UP)\n",
        "            label.match_color(line)\n",
        "            labels.add(label)\n",
        "\n",
        "        true_graph = axes.get_graph(dist.pdf)\n",
        "        region = get_region_under_curve(axes, true_graph, *x_bounds)\n",
        "        region.set_fill(GREY_BROWN, 0.85)\n",
        "        region.set_stroke(YELLOW, 1)\n",
        "\n",
        "        label95 = OldTex(\"95\\\\%\")\n",
        "        fix_percent(label95.family_members_with_points()[-1])\n",
        "        label95.move_to(region, DOWN)\n",
        "        label95.shift(0.5 * UP)\n",
        "\n",
        "        self.play(*map(ShowCreation, v_lines))\n",
        "        self.play(\n",
        "            FadeIn(region),\n",
        "            Write(label95)\n",
        "        )\n",
        "        self.wait()\n",
        "        for label in labels:\n",
        "            self.play(FadeInFromDown(label))\n",
        "        self.wait()\n",
        "\n",
        "        # Show true value\n",
        "        self.wait()\n",
        "        self.play(FadeOut(prob_box))\n",
        "        self.play(ShowCreationThenFadeAround(prob))\n",
        "        self.wait()\n",
        "\n",
        "        # Much more data\n",
        "        many_bools = np.hstack([\n",
        "            bool_values,\n",
        "            (np.random.random(1000) < true_p)\n",
        "        ])\n",
        "        N_tracker = ValueTracker(100)\n",
        "        graph.N_tracker = N_tracker\n",
        "        graph.bools = many_bools\n",
        "        graph.axes = axes\n",
        "        graph.v_lines = v_lines\n",
        "        graph.labels = labels\n",
        "        graph.region = region\n",
        "        graph.label95 = label95\n",
        "\n",
        "        label95.width_ratio = label95.get_width() / region.get_width()\n",
        "\n",
        "        def update_graph(graph):\n",
        "            N = int(graph.N_tracker.get_value())\n",
        "            nh = sum(graph.bools[:N])\n",
        "            nt = len(graph.bools[:N]) - nh\n",
        "            new_graph = get_beta_graph(graph.axes, nh, nt, step_size=0.05)\n",
        "            graph.become(new_graph)\n",
        "\n",
        "            dist = scipy.stats.beta(nh + 1, nt + 1)\n",
        "            x_bounds = dist.interval(0.95)\n",
        "            for x, line, label in zip(x_bounds, graph.v_lines, graph.labels):\n",
        "                line.set_x(graph.axes.c2p(x, 0)[0])\n",
        "                label.set_x(graph.axes.c2p(x, 0)[0])\n",
        "                label.set_value(x)\n",
        "\n",
        "            graph.labels[0].shift(MED_SMALL_BUFF * LEFT)\n",
        "            graph.labels[1].shift(MED_SMALL_BUFF * RIGHT)\n",
        "\n",
        "            new_simple_graph = graph.axes.get_graph(dist.pdf)\n",
        "            new_region = get_region_under_curve(graph.axes, new_simple_graph, *x_bounds)\n",
        "            new_region.match_style(graph.region)\n",
        "            graph.region.become(new_region)\n",
        "\n",
        "            graph.label95.set_width(graph.label95.width_ratio * graph.region.get_width())\n",
        "            graph.label95.match_x(graph.region)\n",
        "\n",
        "        self.add(graph, region, label95, p_label)\n",
        "        self.play(\n",
        "            N_tracker.set_value, 1000,\n",
        "            UpdateFromFunc(graph, update_graph),\n",
        "            Animation(v_lines),\n",
        "            Animation(labels),\n",
        "            Animation(graph.region),\n",
        "            Animation(graph.label95),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "\n",
        "    def get_coins(self, bool_values):\n",
        "        coins = VGroup(*[\n",
        "            get_coin(\"H\" if heads else \"T\")\n",
        "            for heads in bool_values\n",
        "        ])\n",
        "        coins.arrange_in_grid(n_rows=10, buff=MED_LARGE_BUFF)\n",
        "        coins.set_height(5)\n",
        "        return coins\n",
        "\n",
        "    def get_probability_label(self):\n",
        "        head = get_coin(\"H\")\n",
        "        p_label = OldTex(\n",
        "            \"P(00) = \",\n",
        "            tex_to_color_map={\"00\": WHITE}\n",
        "        )\n",
        "        template = p_label.get_part_by_tex(\"00\")\n",
        "        head.replace(template)\n",
        "        p_label.replace_submobject(\n",
        "            p_label.index_of_part(template),\n",
        "            head,\n",
        "        )\n",
        "        prob = DecimalNumber(self.true_p)\n",
        "        prob.next_to(p_label, RIGHT)\n",
        "        p_label.add(prob)\n",
        "        p_label.set_height(0.75)\n",
        "        p_label.to_corner(UR)\n",
        "\n",
        "        prob_box = SurroundingRectangle(prob, buff=SMALL_BUFF)\n",
        "        prob_box.set_fill(GREY_D, 1)\n",
        "        prob_box.set_stroke(WHITE, 2)\n",
        "\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.move_to(prob_box)\n",
        "        prob_box.add(q_marks)\n",
        "\n",
        "        return p_label, prob, prob_box\n",
        "\n",
        "\n",
        "class HighlightReviewPartsReversed(HighlightReviewParts):\n",
        "    CONFIG = {\n",
        "        \"reverse_order\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class Grey(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenFadeRectangle(fill_color=GREY_D, fill_opacity=1))\n",
        "\n",
        "\n",
        "class ShowBayesRule(Scene):\n",
        "    def construct(self):\n",
        "        hyp = \"\\\\text{Hypothesis}\"\n",
        "        data = \"\\\\text{Data}\"\n",
        "        bayes = OldTex(\n",
        "            f\"P({hyp} \\\\,|\\\\, {data})\", \"=\", \"{\",\n",
        "            f\"P({data} \\\\,|\\\\, {hyp})\", f\"P({hyp})\",\n",
        "            \"\\\\over\", f\"P({data})\",\n",
        "            tex_to_color_map={\n",
        "                hyp: YELLOW,\n",
        "                data: GREEN,\n",
        "            }\n",
        "        )\n",
        "\n",
        "        title = OldTexText(\"Bayes' rule\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(*bayes[:5])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *[\n",
        "                TransformFromCopy(bayes[i], bayes[j], path_arc=30 * DEGREES)\n",
        "                for i, j in [\n",
        "                    (0, 7),\n",
        "                    (1, 10),\n",
        "                    (2, 9),\n",
        "                    (3, 8),\n",
        "                    (4, 11),\n",
        "                ]\n",
        "            ],\n",
        "            FadeIn(bayes[5]),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *[\n",
        "                TransformFromCopy(bayes[i], bayes[j], path_arc=30 * DEGREES)\n",
        "                for i, j in [\n",
        "                    (0, 12),\n",
        "                    (1, 13),\n",
        "                    (4, 14),\n",
        "                    (0, 16),\n",
        "                    (3, 17),\n",
        "                    (4, 18),\n",
        "                ]\n",
        "            ],\n",
        "            FadeIn(bayes[15]),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.add(bayes)\n",
        "        self.wait()\n",
        "\n",
        "        hyp_word = bayes.get_part_by_tex(hyp)\n",
        "        example_hyp = OldTexText(\n",
        "            \"For example,\\\\\\\\\",\n",
        "            \"$0.9 < s < 0.99$\",\n",
        "        )\n",
        "        example_hyp[1].set_color(YELLOW)\n",
        "        example_hyp.next_to(hyp_word, DOWN, buff=1.5)\n",
        "\n",
        "        data_word = bayes.get_part_by_tex(data)\n",
        "        example_data = OldTex(\n",
        "            \"48\\\\,\", CMARK_TEX,\n",
        "            \"\\\\,2\\\\,\", XMARK_TEX,\n",
        "        )\n",
        "        example_data.set_color_by_tex(CMARK_TEX, GREEN)\n",
        "        example_data.set_color_by_tex(XMARK_TEX, RED)\n",
        "        example_data.scale(1.5)\n",
        "        example_data.next_to(example_hyp, RIGHT, buff=1.5)\n",
        "\n",
        "        hyp_arrow = Arrow(\n",
        "            hyp_word.get_bottom(),\n",
        "            example_hyp.get_top(),\n",
        "        )\n",
        "        data_arrow = Arrow(\n",
        "            data_word.get_bottom(),\n",
        "            example_data.get_top(),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(hyp_arrow),\n",
        "            FadeInFromPoint(example_hyp, hyp_word.get_center()),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(data_arrow),\n",
        "            FadeInFromPoint(example_data, data_word.get_center()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VisualizeBayesRule(Scene):\n",
        "    def construct(self):\n",
        "        self.show_continuum()\n",
        "        self.show_arrows()\n",
        "        self.show_discrete_probabilities()\n",
        "        self.show_bayes_formula()\n",
        "        self.parallel_universes()\n",
        "        self.update_from_data()\n",
        "\n",
        "    def show_continuum(self):\n",
        "        axes = get_beta_dist_axes(y_max=1, y_unit=0.1)\n",
        "        axes.y_axis.add_numbers(\n",
        "            *np.arange(0.2, 1.2, 0.2),\n",
        "            num_decimal_places=1,\n",
        "        )\n",
        "\n",
        "        p_label = OldTex(\n",
        "            \"P(s \\\\,|\\\\, \\\\text{data})\",\n",
        "            tex_to_color_map={\n",
        "                \"s\": YELLOW,\n",
        "                \"\\\\text{data}\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        p_label.scale(1.5)\n",
        "        p_label.to_edge(UP, LARGE_BUFF)\n",
        "\n",
        "        s_part = p_label.get_part_by_tex(\"s\").copy()\n",
        "        x_line = Line(axes.c2p(0, 0), axes.c2p(1, 0))\n",
        "        x_line.set_stroke(YELLOW, 3)\n",
        "\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(s_part, DOWN, SMALL_BUFF)\n",
        "        value = DecimalNumber(0, num_decimal_places=4)\n",
        "        value.set_color(YELLOW)\n",
        "        value.next_to(arrow, DOWN)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(p_label)\n",
        "        self.play(\n",
        "            s_part.next_to, x_line.get_start(), UR, SMALL_BUFF,\n",
        "            GrowArrow(arrow),\n",
        "            FadeInFromPoint(value, s_part.get_center()),\n",
        "        )\n",
        "\n",
        "        s_part.tracked = x_line\n",
        "        value.tracked = x_line\n",
        "        value.x_axis = axes.x_axis\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            UpdateFromFunc(\n",
        "                s_part,\n",
        "                lambda m: m.next_to(m.tracked.get_end(), UR, SMALL_BUFF)\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                value,\n",
        "                lambda m: m.set_value(\n",
        "                    m.x_axis.p2n(m.tracked.get_end())\n",
        "                )\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(value),\n",
        "        )\n",
        "\n",
        "        self.p_label = p_label\n",
        "        self.s_part = s_part\n",
        "        self.value = value\n",
        "        self.x_line = x_line\n",
        "        self.axes = axes\n",
        "\n",
        "    def show_arrows(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        arrows = VGroup()\n",
        "        arrow_template = Vector(DOWN)\n",
        "\n",
        "        def get_arrow(s, denom):\n",
        "            arrow = arrow_template.copy()\n",
        "            arrow.set_height(4 / denom)\n",
        "            arrow.move_to(axes.c2p(s, 0), DOWN)\n",
        "            arrow.set_color(interpolate_color(\n",
        "                GREY_A, GREY_C, random.random()\n",
        "            ))\n",
        "            return arrow\n",
        "\n",
        "        for k in range(2, 50):\n",
        "            for n in range(1, k):\n",
        "                if np.gcd(n, k) != 1:\n",
        "                    continue\n",
        "                s = n / k\n",
        "                arrows.add(get_arrow(s, k))\n",
        "        for k in range(50, 1000):\n",
        "            arrows.add(get_arrow(1 / k, k))\n",
        "            arrows.add(get_arrow(1 - 1 / k, k))\n",
        "\n",
        "        kw = {\n",
        "            \"lag_ratio\": 0.5,\n",
        "            \"run_time\": 5,\n",
        "            \"rate_func\": lambda t: t**4,\n",
        "        }\n",
        "        arrows.save_state()\n",
        "        for arrow in arrows:\n",
        "            arrow.stretch(0, 0)\n",
        "            arrow.set_stroke(width=0)\n",
        "            arrow.set_opacity(0)\n",
        "        self.play(Restore(arrows, **kw))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, arrows,\n",
        "            lambda m: (m.scale, 0, {\"about_edge\": DOWN}),\n",
        "            **kw\n",
        "        ))\n",
        "        self.remove(arrows)\n",
        "        self.wait()\n",
        "\n",
        "    def show_discrete_probabilities(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        x_lines = VGroup()\n",
        "        dx = 0.01\n",
        "        for x in np.arange(0, 1, dx):\n",
        "            line = Line(\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x + dx, 0),\n",
        "            )\n",
        "            line.set_stroke(BLUE, 3)\n",
        "            line.generate_target()\n",
        "            line.target.rotate(\n",
        "                90 * DEGREES,\n",
        "                about_point=line.get_start()\n",
        "            )\n",
        "            x_lines.add(line)\n",
        "\n",
        "        self.add(x_lines)\n",
        "        self.play(\n",
        "            FadeOut(self.x_line),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, x_lines,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        label = Integer(0)\n",
        "        label.set_height(0.5)\n",
        "        label.next_to(self.p_label[1], DOWN, LARGE_BUFF)\n",
        "        unit = OldTex(\"\\\\%\")\n",
        "        unit.match_height(label)\n",
        "        fix_percent(unit.family_members_with_points()[0])\n",
        "        always(unit.next_to, label, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        arrow = Arrow()\n",
        "        arrow.max_stroke_width_to_length_ratio = 1\n",
        "        arrow.axes = axes\n",
        "        arrow.label = label\n",
        "        arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            m.label.get_bottom() + MED_SMALL_BUFF * DOWN,\n",
        "            m.axes.c2p(0.01 * m.label.get_value(), 0.03),\n",
        "        ))\n",
        "\n",
        "        self.add(label, unit, arrow)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(label, 99),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [label, unit, arrow]))\n",
        "\n",
        "        # Show prior label\n",
        "        p_label = self.p_label\n",
        "        given_data = p_label[2:4]\n",
        "        prior_label = OldTex(\"P(s)\", tex_to_color_map={\"s\": YELLOW})\n",
        "        prior_label.match_height(p_label)\n",
        "        prior_label.move_to(p_label, DOWN, LARGE_BUFF)\n",
        "\n",
        "        p_label.save_state()\n",
        "        self.play(\n",
        "            given_data.scale, 0.5,\n",
        "            given_data.set_opacity, 0.5,\n",
        "            given_data.to_corner, UR,\n",
        "            Transform(p_label[:2], prior_label[:2]),\n",
        "            Transform(p_label[-1], prior_label[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in on the y-values\n",
        "        new_ticks = VGroup()\n",
        "        new_labels = VGroup()\n",
        "        dy = 0.01\n",
        "        for y in np.arange(dy, 5 * dy, dy):\n",
        "            height = get_norm(axes.c2p(0, dy) - axes.c2p(0, 0))\n",
        "            tick = axes.y_axis.get_tick(y, SMALL_BUFF)\n",
        "            label = DecimalNumber(y)\n",
        "            label.match_height(axes.y_axis.numbers[0])\n",
        "            always(label.next_to, tick, LEFT, SMALL_BUFF)\n",
        "\n",
        "            new_ticks.add(tick)\n",
        "            new_labels.add(label)\n",
        "\n",
        "        for num in axes.y_axis.numbers:\n",
        "            height = num.get_height()\n",
        "            always(num.set_height, height, stretch=True)\n",
        "\n",
        "        bars = VGroup()\n",
        "        dx = 0.01\n",
        "        origin = axes.c2p(0, 0)\n",
        "        for x in np.arange(0, 1, dx):\n",
        "            rect = Rectangle(\n",
        "                width=get_norm(axes.c2p(dx, 0) - origin),\n",
        "                height=get_norm(axes.c2p(0, dy) - origin),\n",
        "            )\n",
        "            rect.x = x\n",
        "            rect.set_stroke(BLUE, 1)\n",
        "            rect.set_fill(BLUE, 0.5)\n",
        "            rect.move_to(axes.c2p(x, 0), DL)\n",
        "            bars.add(rect)\n",
        "\n",
        "        stretch_group = VGroup(\n",
        "            axes.y_axis,\n",
        "            bars,\n",
        "            new_ticks,\n",
        "            x_lines,\n",
        "        )\n",
        "        x_lines.set_height(\n",
        "            bars.get_height(),\n",
        "            about_edge=DOWN,\n",
        "            stretch=True,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            stretch_group.stretch, 25, 1, {\"about_point\": axes.c2p(0, 0)},\n",
        "            VFadeIn(bars),\n",
        "            VFadeIn(new_ticks),\n",
        "            VFadeIn(new_labels),\n",
        "            VFadeOut(x_lines),\n",
        "            run_time=4,\n",
        "        )\n",
        "\n",
        "        highlighted_bars = bars.copy()\n",
        "        highlighted_bars.set_color(YELLOW)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, highlighted_bars,\n",
        "                lag_ratio=0.5,\n",
        "                rate_func=there_and_back,\n",
        "            ),\n",
        "            ShowCreationThenFadeAround(new_labels[0]),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(highlighted_bars)\n",
        "\n",
        "        # Nmae as prior\n",
        "        prior_name = OldTexText(\"Prior\", \" distribution\")\n",
        "        prior_name.set_height(0.6)\n",
        "        prior_name.next_to(prior_label, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeInFromDown(prior_name))\n",
        "        self.wait()\n",
        "\n",
        "        # Show alternate distribution\n",
        "        bars.save_state()\n",
        "        for a, b in [(5, 2), (1, 6)]:\n",
        "            dist = scipy.stats.beta(a, b)\n",
        "            for bar, saved in zip(bars, bars.saved_state):\n",
        "                bar.target = saved.copy()\n",
        "                height = get_norm(axes.c2p(0.1 * dist.pdf(bar.x)) - axes.c2p(0, 0))\n",
        "                bar.target.set_height(height, about_edge=DOWN, stretch=True)\n",
        "\n",
        "            self.play(LaggedStartMap(MoveToTarget, bars, lag_ratio=0.00))\n",
        "            self.wait()\n",
        "        self.play(Restore(bars))\n",
        "        self.wait()\n",
        "\n",
        "        uniform_name = OldTexText(\"Uniform\")\n",
        "        uniform_name.match_height(prior_name)\n",
        "        uniform_name.move_to(prior_name, DL)\n",
        "        uniform_name.shift(RIGHT)\n",
        "        uniform_name.set_y(bars.get_top()[1] + MED_SMALL_BUFF, DOWN)\n",
        "        self.play(\n",
        "            prior_name[0].next_to, uniform_name, RIGHT, MED_SMALL_BUFF, DOWN,\n",
        "            FadeOut(prior_name[1], RIGHT),\n",
        "            FadeIn(uniform_name, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.bars = bars\n",
        "        self.uniform_label = VGroup(uniform_name, prior_name[0])\n",
        "\n",
        "    def show_bayes_formula(self):\n",
        "        uniform_label = self.uniform_label\n",
        "        p_label = self.p_label\n",
        "        bars = self.bars\n",
        "\n",
        "        prior_label = VGroup(\n",
        "            p_label[0].deepcopy(),\n",
        "            p_label[1].deepcopy(),\n",
        "            p_label[4].deepcopy(),\n",
        "        )\n",
        "        eq = OldTex(\"=\")\n",
        "        likelihood_label = OldTex(\n",
        "            \"P(\", \"\\\\text{data}\", \"|\", \"s\", \")\",\n",
        "        )\n",
        "        likelihood_label.set_color_by_tex(\"data\", GREEN)\n",
        "        likelihood_label.set_color_by_tex(\"s\", YELLOW)\n",
        "        over = Line(LEFT, RIGHT)\n",
        "        p_data_label = OldTexText(\"P(\", \"\\\\text{data}\", \")\")\n",
        "        p_data_label.set_color_by_tex(\"data\", GREEN)\n",
        "\n",
        "        for mob in [eq, likelihood_label, over, p_data_label]:\n",
        "            mob.scale(1.5)\n",
        "            mob.set_opacity(0.1)\n",
        "\n",
        "        eq.move_to(prior_label, LEFT)\n",
        "        over.set_width(\n",
        "            prior_label.get_width() +\n",
        "            likelihood_label.get_width() +\n",
        "            MED_SMALL_BUFF\n",
        "        )\n",
        "        over.next_to(eq, RIGHT, MED_SMALL_BUFF)\n",
        "        p_data_label.next_to(over, DOWN, MED_SMALL_BUFF)\n",
        "        likelihood_label.next_to(over, UP, MED_SMALL_BUFF, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            p_label.restore,\n",
        "            p_label.next_to, eq, LEFT, MED_SMALL_BUFF,\n",
        "            prior_label.next_to, over, UP, MED_SMALL_BUFF, LEFT,\n",
        "            FadeIn(eq),\n",
        "            FadeIn(likelihood_label),\n",
        "            FadeIn(over),\n",
        "            FadeIn(p_data_label),\n",
        "            FadeOut(uniform_label),\n",
        "        )\n",
        "\n",
        "        # Show new distribution\n",
        "        post_bars = bars.copy()\n",
        "        total_prob = 0\n",
        "        for bar, p in zip(post_bars, np.arange(0, 1, 0.01)):\n",
        "            prob = scipy.stats.binom(50, p).pmf(48)\n",
        "            bar.stretch(prob, 1, about_edge=DOWN)\n",
        "            total_prob += 0.01 * prob\n",
        "        post_bars.stretch(1 / total_prob, 1, about_edge=DOWN)\n",
        "        post_bars.stretch(0.25, 1, about_edge=DOWN)  # Lie to fit on screen...\n",
        "        post_bars.set_color(MAROON_D)\n",
        "        post_bars.set_fill(opacity=0.8)\n",
        "\n",
        "        brace = Brace(p_label, DOWN)\n",
        "        post_word = brace.get_text(\"Posterior\")\n",
        "        post_word.scale(1.25, about_edge=UP)\n",
        "        post_word.set_color(MAROON_D)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                bars.copy().set_opacity(0),\n",
        "                post_bars,\n",
        "            ),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(post_word, 0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            eq.set_opacity, 1,\n",
        "            likelihood_label.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        data = get_check_count_label(48, 2)\n",
        "        data.scale(1.5)\n",
        "        data.next_to(likelihood_label, DOWN, buff=2, aligned_edge=LEFT)\n",
        "        data_arrow = Arrow(\n",
        "            likelihood_label[1].get_bottom(),\n",
        "            data.get_top()\n",
        "        )\n",
        "        data_arrow.set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(data_arrow),\n",
        "            GrowFromPoint(data, data_arrow.get_start()),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(data_arrow))\n",
        "        self.play(\n",
        "            over.set_opacity, 1,\n",
        "            p_data_label.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            FadeOut(post_word),\n",
        "            FadeOut(post_bars),\n",
        "            FadeOut(data),\n",
        "            p_label.set_opacity, 0.1,\n",
        "            eq.set_opacity, 0.1,\n",
        "            likelihood_label.set_opacity, 0.1,\n",
        "            over.set_opacity, 0.1,\n",
        "            p_data_label.set_opacity, 0.1,\n",
        "        )\n",
        "\n",
        "        self.bayes = VGroup(\n",
        "            p_label, eq,\n",
        "            prior_label, likelihood_label,\n",
        "            over, p_data_label\n",
        "        )\n",
        "        self.data = data\n",
        "\n",
        "    def parallel_universes(self):\n",
        "        bars = self.bars\n",
        "\n",
        "        cols = VGroup()\n",
        "        squares = VGroup()\n",
        "        sample_colors = color_gradient(\n",
        "            [GREEN_C, GREEN_D, GREEN_E],\n",
        "            100\n",
        "        )\n",
        "        for bar in bars:\n",
        "            n_rows = 12\n",
        "            col = VGroup()\n",
        "            for x in range(n_rows):\n",
        "                square = Rectangle(\n",
        "                    width=bar.get_width(),\n",
        "                    height=bar.get_height() / n_rows,\n",
        "                )\n",
        "                square.set_stroke(width=0)\n",
        "                square.set_fill(opacity=1)\n",
        "                square.set_color(random.choice(sample_colors))\n",
        "                col.add(square)\n",
        "                squares.add(square)\n",
        "            col.arrange(DOWN, buff=0)\n",
        "            col.move_to(bar)\n",
        "            cols.add(col)\n",
        "        squares.shuffle()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                VFadeInThenOut, squares,\n",
        "                lag_ratio=0.005,\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "        self.remove(squares)\n",
        "        squares.set_opacity(1)\n",
        "        self.wait()\n",
        "\n",
        "        example_col = cols[95]\n",
        "\n",
        "        self.play(\n",
        "            bars.set_opacity, 0.25,\n",
        "            FadeIn(example_col, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dist = scipy.stats.binom(50, 0.95)\n",
        "        for x in range(12):\n",
        "            square = random.choice(example_col).copy()\n",
        "            square.set_fill(opacity=0)\n",
        "            square.set_stroke(YELLOW, 2)\n",
        "            self.add(square)\n",
        "            nc = dist.ppf(random.random())\n",
        "            data = get_check_count_label(nc, 50 - nc)\n",
        "            data.next_to(example_col, UP)\n",
        "\n",
        "            self.add(square, data)\n",
        "            self.wait(0.5)\n",
        "            self.remove(square, data)\n",
        "        self.wait()\n",
        "\n",
        "        self.data.set_opacity(1)\n",
        "        self.play(\n",
        "            FadeIn(self.data),\n",
        "            FadeOut(example_col),\n",
        "            self.bayes[3].set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def update_from_data(self):\n",
        "        bars = self.bars\n",
        "        data = self.data\n",
        "        bayes = self.bayes\n",
        "\n",
        "        new_bars = bars.copy()\n",
        "        new_bars.set_stroke(opacity=1)\n",
        "        new_bars.set_fill(opacity=0.8)\n",
        "        for bar, p in zip(new_bars, np.arange(0, 1, 0.01)):\n",
        "            dist = scipy.stats.binom(50, p)\n",
        "            scalar = dist.pmf(48)\n",
        "            bar.stretch(scalar, 1, about_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                bars.copy().set_opacity(0),\n",
        "                new_bars\n",
        "            ),\n",
        "            bars.set_fill, {\"opacity\": 0.1},\n",
        "            bars.set_stroke, {\"opacity\": 0.1},\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show example bar\n",
        "        bar95 = VGroup(\n",
        "            bars[95].copy(),\n",
        "            new_bars[95].copy()\n",
        "        )\n",
        "        bar95.save_state()\n",
        "        bar95.generate_target()\n",
        "        bar95.target.scale(2)\n",
        "        bar95.target.next_to(bar95, UP, LARGE_BUFF)\n",
        "        bar95.target.set_stroke(BLUE, 3)\n",
        "\n",
        "        ex_label = OldTex(\"s\", \"=\", \"0.95\")\n",
        "        ex_label.set_color(YELLOW)\n",
        "        ex_label.next_to(bar95.target, DOWN, submobject_to_align=ex_label[-1])\n",
        "\n",
        "        highlight = SurroundingRectangle(bar95, buff=0)\n",
        "        highlight.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(FadeIn(highlight))\n",
        "        self.play(\n",
        "            MoveToTarget(bar95),\n",
        "            FadeInFromDown(ex_label),\n",
        "            data.shift, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        side_brace = Brace(bar95[1], RIGHT, buff=SMALL_BUFF)\n",
        "        side_label = side_brace.get_text(\"0.26\", buff=SMALL_BUFF)\n",
        "        self.play(\n",
        "            GrowFromCenter(side_brace),\n",
        "            FadeIn(side_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(side_brace),\n",
        "            FadeOut(side_label),\n",
        "            FadeOut(ex_label),\n",
        "        )\n",
        "        self.play(\n",
        "            bar95.restore,\n",
        "            bar95.set_opacity, 0,\n",
        "        )\n",
        "\n",
        "        for bar in bars[94:80:-1]:\n",
        "            highlight.move_to(bar)\n",
        "            self.wait(0.5)\n",
        "        self.play(FadeOut(highlight))\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize formula terms\n",
        "        tops = VGroup()\n",
        "        for bar, new_bar in zip(bars, new_bars):\n",
        "            top = Line(bar.get_corner(UL), bar.get_corner(UR))\n",
        "            top.set_stroke(YELLOW, 2)\n",
        "            top.generate_target()\n",
        "            top.target.move_to(new_bar, UP)\n",
        "            tops.add(top)\n",
        "\n",
        "        rect = SurroundingRectangle(bayes[2])\n",
        "        rect.set_stroke(YELLOW, 1)\n",
        "        rect.target = SurroundingRectangle(bayes[3])\n",
        "        rect.target.match_style(rect)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            ShowCreation(tops),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, tops,\n",
        "                run_time=2,\n",
        "                lag_ratio=0.02,\n",
        "            ),\n",
        "            MoveToTarget(rect),\n",
        "        )\n",
        "        self.play(FadeOut(tops))\n",
        "        self.wait()\n",
        "\n",
        "        # Show alternate priors\n",
        "        axes = self.axes\n",
        "        bar_groups = VGroup()\n",
        "        for bar, new_bar in zip(bars, new_bars):\n",
        "            bar_groups.add(VGroup(bar, new_bar))\n",
        "\n",
        "        bar_groups.save_state()\n",
        "        for a, b in [(5, 2), (7, 1)]:\n",
        "            dist = scipy.stats.beta(a, b)\n",
        "            for bar, saved in zip(bar_groups, bar_groups.saved_state):\n",
        "                bar.target = saved.copy()\n",
        "                height = get_norm(axes.c2p(0.1 * dist.pdf(bar[0].x)) - axes.c2p(0, 0))\n",
        "                height = max(height, 1e-6)\n",
        "                bar.target.set_height(height, about_edge=DOWN, stretch=True)\n",
        "\n",
        "            self.play(LaggedStartMap(MoveToTarget, bar_groups, lag_ratio=0))\n",
        "            self.wait()\n",
        "        self.play(Restore(bar_groups))\n",
        "        self.wait()\n",
        "\n",
        "        # Rescale\n",
        "        ex_p_label = OldTex(\n",
        "            \"P(s = 0.95 | 00000000) = \",\n",
        "            tex_to_color_map={\n",
        "                \"s = 0.95\": YELLOW,\n",
        "                \"00000000\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        ex_p_label.scale(1.5)\n",
        "        ex_p_label.next_to(bars, UP, LARGE_BUFF)\n",
        "        ex_p_label.align_to(bayes, LEFT)\n",
        "        template = ex_p_label.get_part_by_tex(\"00000000\")\n",
        "        template.set_opacity(0)\n",
        "\n",
        "        highlight = SurroundingRectangle(new_bars[95], buff=0)\n",
        "        highlight.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.remove(data)\n",
        "        self.play(\n",
        "            FadeIn(ex_p_label),\n",
        "            VFadeOut(data[0]),\n",
        "            data[1:].move_to, template,\n",
        "            FadeIn(highlight)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        numer = new_bars[95].copy()\n",
        "        numer.set_stroke(YELLOW, 1)\n",
        "        denom = new_bars[80:].copy()\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(3)\n",
        "        h_line.set_stroke(width=2)\n",
        "        h_line.next_to(ex_p_label, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            numer.next_to, h_line, UP,\n",
        "            denom.next_to, h_line, DOWN,\n",
        "            ShowCreation(h_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            denom.space_out_submobjects,\n",
        "            rate_func=there_and_back\n",
        "        )\n",
        "        self.play(\n",
        "            bayes[4].set_opacity, 1,\n",
        "            bayes[5].set_opacity, 1,\n",
        "            FadeOut(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Rescale\n",
        "        self.play(\n",
        "            FadeOut(highlight),\n",
        "            FadeOut(ex_p_label),\n",
        "            FadeOut(data),\n",
        "            FadeOut(h_line),\n",
        "            FadeOut(numer),\n",
        "            FadeOut(denom),\n",
        "            bayes.set_opacity, 1,\n",
        "        )\n",
        "\n",
        "        new_bars.unlock_shader_data()\n",
        "        self.remove(new_bars, *new_bars)\n",
        "        self.play(\n",
        "            new_bars.set_height, 5, {\"about_edge\": DOWN, \"stretch\": True},\n",
        "            new_bars.set_color, MAROON_D,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UniverseOf95Percent(WhatsTheModel):\n",
        "    CONFIG = {\"s\": 0.95}\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_buyer_and_seller()\n",
        "        for m, v in [(self.seller, RIGHT), (self.buyer, LEFT)]:\n",
        "            m.shift(v)\n",
        "            m.label.shift(v)\n",
        "\n",
        "        pis = VGroup(self.seller, self.buyer)\n",
        "        label = get_prob_positive_experience_label(True, True)\n",
        "        label[-1].set_value(self.s)\n",
        "        label.set_height(1)\n",
        "        label.next_to(pis, UP, LARGE_BUFF)\n",
        "        self.add(label)\n",
        "\n",
        "        for x in range(4):\n",
        "            self.play(*self.experience_animations(\n",
        "                self.seller, self.buyer, arc=30 * DEGREES, p=self.s\n",
        "            ))\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class UniverseOf50Percent(UniverseOf95Percent):\n",
        "    CONFIG = {\"s\": 0.5}\n",
        "\n",
        "\n",
        "class OpenAndCloseAsideOnPdfs(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"$\\\\langle$\", \"Aside on\", \" pdfs\", \"$\\\\rangle$\"),\n",
        "            OldTexText(\"$\\\\langle$/\", \"Aside on\", \" pdfs\", \"$\\\\rangle$\"),\n",
        "        )\n",
        "        labels.set_width(FRAME_WIDTH / 2)\n",
        "        for label in labels:\n",
        "            label.set_color_by_tex(\"pdfs\", YELLOW)\n",
        "\n",
        "        self.play(FadeInFromDown(labels[0]))\n",
        "        self.wait()\n",
        "        self.play(Transform(*labels))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BayesRuleWithPdf(ShowLimitToPdf):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = self.get_axes()\n",
        "        sf = 1.5\n",
        "        axes.y_axis.stretch(sf, 1, about_point=axes.c2p(0, 0))\n",
        "        for number in axes.y_axis.numbers:\n",
        "            number.stretch(1 / sf, 1)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Formula\n",
        "        bayes = self.get_formula()\n",
        "\n",
        "        post = bayes[:5]\n",
        "        eq = bayes[5]\n",
        "        prior = bayes[6:9]\n",
        "        likelihood = bayes[9:14]\n",
        "        over = bayes[14]\n",
        "        p_data = bayes[15:]\n",
        "\n",
        "        self.play(FadeInFromDown(bayes))\n",
        "        self.wait()\n",
        "\n",
        "        # Prior\n",
        "        prior_graph = get_beta_graph(axes, 0, 0)\n",
        "        prior_graph_top = Line(\n",
        "            prior_graph.get_corner(UL),\n",
        "            prior_graph.get_corner(UR),\n",
        "        )\n",
        "        prior_graph_top.set_stroke(YELLOW, 3)\n",
        "\n",
        "        bayes.save_state()\n",
        "        bayes.set_opacity(0.2)\n",
        "        prior.set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            Restore(bayes, rate_func=reverse_smooth),\n",
        "            FadeIn(prior_graph),\n",
        "            ShowCreation(prior_graph_top),\n",
        "        )\n",
        "        self.play(FadeOut(prior_graph_top))\n",
        "        self.wait()\n",
        "\n",
        "        # Scale Down\n",
        "        nh = 1\n",
        "        nt = 2\n",
        "\n",
        "        scaled_graph = axes.get_graph(\n",
        "            lambda x: scipy.stats.binom(3, x).pmf(1) + 1e-6\n",
        "        )\n",
        "        scaled_graph.set_stroke(GREEN)\n",
        "        scaled_region = get_region_under_curve(axes, scaled_graph, 0, 1)\n",
        "\n",
        "        def to_uniform(p, axes=axes):\n",
        "            return axes.c2p(\n",
        "                axes.x_axis.p2n(p),\n",
        "                int(axes.y_axis.p2n(p) != 0),\n",
        "            )\n",
        "\n",
        "        scaled_region.set_fill(opacity=0.75)\n",
        "        scaled_region.save_state()\n",
        "        scaled_region.apply_function(to_uniform)\n",
        "\n",
        "        self.play(\n",
        "            Restore(scaled_region),\n",
        "            UpdateFromAlphaFunc(\n",
        "                scaled_region,\n",
        "                lambda m, a: m.set_opacity(a * 0.75),\n",
        "            ),\n",
        "            likelihood.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Rescale\n",
        "        new_graph = get_beta_graph(axes, nh, nt)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                scaled_region.set_height, new_graph.get_height(),\n",
        "                {\"about_edge\": DOWN, \"stretch\": True},\n",
        "                run_time=2,\n",
        "            ),\n",
        "            over.set_opacity, 1,\n",
        "            p_data.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            post.set_opacity, 1,\n",
        "            eq.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Use lower case\n",
        "        new_bayes = self.get_formula(lowercase=True)\n",
        "        new_bayes.replace(bayes, dim_to_match=0)\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(new_bayes[0][0]),\n",
        "            SurroundingRectangle(new_bayes[6][0]),\n",
        "        )\n",
        "        rects.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.remove(bayes)\n",
        "        bayes = self.get_formula()\n",
        "        self.add(bayes)\n",
        "        self.play(Transform(bayes, new_bayes))\n",
        "        self.play(ShowCreationThenFadeOut(rects))\n",
        "\n",
        "    def get_formula(self, lowercase=False):\n",
        "        p_sym = \"p\" if lowercase else \"P\"\n",
        "        bayes = OldTex(\n",
        "            p_sym + \"({s} \\\\,|\\\\, \\\\text{data})\", \"=\",\n",
        "            \"{\" + p_sym + \"({s})\",\n",
        "            \"P(\\\\text{data} \\\\,|\\\\, {s})\",\n",
        "            \"\\\\over\",\n",
        "            \"P(\\\\text{data})\",\n",
        "            tex_to_color_map={\n",
        "                \"{s}\": YELLOW,\n",
        "                \"\\\\text{data}\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        bayes.set_height(1.5)\n",
        "        bayes.to_edge(UP)\n",
        "        return bayes\n",
        "\n",
        "\n",
        "class TalkThroughCoinExample(ShowBayesianUpdating):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        axes = self.get_axes()\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label.next_to(axes.x_axis.get_end(), UR, MED_SMALL_BUFF)\n",
        "        axes.add(x_label)\n",
        "\n",
        "        p_label, prob, prob_box = self.get_probability_label()\n",
        "        prob_box_x = x_label.copy().move_to(prob_box)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(p_label)\n",
        "        self.add(prob_box)\n",
        "\n",
        "        self.wait()\n",
        "        q_marks = prob_box[1]\n",
        "        prob_box.remove(q_marks)\n",
        "        self.play(\n",
        "            FadeOut(q_marks),\n",
        "            TransformFromCopy(x_label, prob_box_x)\n",
        "        )\n",
        "        prob_box.add(prob_box_x)\n",
        "\n",
        "        # Setup coins\n",
        "        bool_values = (np.random.random(100) < self.true_p)\n",
        "        bool_values[:5] = [True, False, True, True, False]\n",
        "        coins = self.get_coins(bool_values)\n",
        "        coins.next_to(axes.y_axis, RIGHT, MED_LARGE_BUFF)\n",
        "        coins.to_edge(UP)\n",
        "\n",
        "        # Random coin\n",
        "        rows = VGroup()\n",
        "        for x in range(5):\n",
        "            row = self.get_coins(np.random.random(10) < self.true_p)\n",
        "            row.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "            row.set_width(6)\n",
        "            row.move_to(UP)\n",
        "            rows.add(row)\n",
        "\n",
        "        last_row = VMobject()\n",
        "        for row in rows:\n",
        "            self.play(\n",
        "                FadeOut(last_row, DOWN),\n",
        "                FadeIn(row, lag_ratio=0.1)\n",
        "            )\n",
        "            last_row = row\n",
        "        self.play(FadeOut(last_row, DOWN))\n",
        "\n",
        "        # Uniform pdf\n",
        "        region = get_beta_graph(axes, 0, 0)\n",
        "        graph = Line(\n",
        "            region.get_corner(UL),\n",
        "            region.get_corner(UR),\n",
        "        )\n",
        "        func_label = OldTex(\"f(x) =\", \"1\")\n",
        "        func_label.next_to(graph, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(func_label, lag_ratio=0.1),\n",
        "            ShowCreation(graph),\n",
        "        )\n",
        "        self.add(region, graph)\n",
        "        self.play(FadeIn(region))\n",
        "        self.wait()\n",
        "\n",
        "        # First flip\n",
        "        coin = coins[0]\n",
        "        arrow = Vector(0.5 * UP)\n",
        "        arrow.next_to(coin, DOWN, SMALL_BUFF)\n",
        "        data_label = OldTexText(\"New data\")\n",
        "        data_label.set_height(0.25)\n",
        "        data_label.next_to(arrow, DOWN)\n",
        "        data_label.shift(0.5 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(coin, DOWN),\n",
        "            GrowArrow(arrow),\n",
        "            Write(data_label, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show Bayes rule\n",
        "        bayes = OldTex(\n",
        "            \"p({x} | \\\\text{data})\", \"=\",\n",
        "            \"p({x})\",\n",
        "            \"{P(\\\\text{data} | {x})\",\n",
        "            \"\\\\over\",\n",
        "            \"P(\\\\text{data})\",\n",
        "            tex_to_color_map={\n",
        "                \"{x}\": WHITE,\n",
        "                \"\\\\text{data}\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        bayes.next_to(func_label, UP, LARGE_BUFF, LEFT)\n",
        "\n",
        "        likelihood = bayes[9:14]\n",
        "        p_data = bayes[15:]\n",
        "        likelihood_rect = SurroundingRectangle(likelihood, buff=0.05)\n",
        "        likelihood_rect.save_state()\n",
        "        p_data_rect = SurroundingRectangle(p_data, buff=0.05)\n",
        "\n",
        "        likelihood_x_label = OldTex(\"x\")\n",
        "        likelihood_x_label.next_to(likelihood_rect, UP)\n",
        "\n",
        "        self.play(FadeInFromDown(bayes))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(likelihood_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(TransformFromCopy(likelihood[-2], likelihood_x_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Scale by x\n",
        "        times_x = OldTex(\"\\\\cdot \\\\, x\")\n",
        "        times_x.next_to(func_label, RIGHT, buff=0.2)\n",
        "\n",
        "        new_graph = axes.get_graph(lambda x: x)\n",
        "        sub_region = get_region_under_curve(axes, new_graph, 0, 1)\n",
        "\n",
        "        self.play(\n",
        "            Write(times_x),\n",
        "            Transform(graph, new_graph),\n",
        "        )\n",
        "        self.play(\n",
        "            region.set_opacity, 0.5,\n",
        "            FadeIn(sub_region),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show example scalings\n",
        "        low_x = 0.1\n",
        "        high_x = 0.9\n",
        "        lines = VGroup()\n",
        "        for x in [low_x, high_x]:\n",
        "            lines.add(Line(axes.c2p(x, 0), axes.c2p(x, 1)))\n",
        "\n",
        "        lines.set_stroke(YELLOW, 3)\n",
        "\n",
        "        for x, line in zip([low_x, high_x], lines):\n",
        "            self.play(FadeIn(line))\n",
        "            self.play(line.scale, x, {\"about_edge\": DOWN})\n",
        "        self.wait()\n",
        "        self.play(FadeOut(lines))\n",
        "\n",
        "        # Renormalize\n",
        "        self.play(\n",
        "            FadeOut(likelihood_x_label),\n",
        "            ReplacementTransform(likelihood_rect, p_data_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        one = func_label[1]\n",
        "        two = OldTex(\"2\")\n",
        "        two.move_to(one, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(region),\n",
        "            sub_region.stretch, 2, 1, {\"about_edge\": DOWN},\n",
        "            sub_region.set_color, BLUE,\n",
        "            graph.stretch, 2, 1, {\"about_edge\": DOWN},\n",
        "            FadeInFromDown(two),\n",
        "            FadeOut(one, UP),\n",
        "        )\n",
        "        region = sub_region\n",
        "        func_label = VGroup(func_label[0], two, times_x)\n",
        "        self.add(func_label)\n",
        "\n",
        "        self.play(func_label.shift, 0.5 * UP)\n",
        "        self.wait()\n",
        "\n",
        "        const = OldTex(\"C\")\n",
        "        const.scale(0.9)\n",
        "        const.move_to(two, DR)\n",
        "        const.shift(0.07 * RIGHT)\n",
        "        self.play(\n",
        "            FadeOut(two, UP),\n",
        "            FadeIn(const, DOWN)\n",
        "        )\n",
        "        self.remove(func_label)\n",
        "        func_label = VGroup(func_label[0], const, times_x)\n",
        "        self.add(func_label)\n",
        "        self.play(FadeOut(p_data_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Show tails\n",
        "        coin = coins[1]\n",
        "        self.play(\n",
        "            arrow.next_to, coin, DOWN, SMALL_BUFF,\n",
        "            MaintainPositionRelativeTo(data_label, arrow),\n",
        "            FadeInFromDown(coin),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        to_prior_arrow = Arrow(\n",
        "            func_label[0][3],\n",
        "            bayes[6],\n",
        "            max_tip_length_to_length_ratio=0.15,\n",
        "            stroke_width=3,\n",
        "        )\n",
        "        to_prior_arrow.set_color(RED)\n",
        "\n",
        "        self.play(Indicate(func_label, scale_factor=1.2, color=RED))\n",
        "        self.play(ShowCreation(to_prior_arrow))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(to_prior_arrow))\n",
        "\n",
        "        # Scale by (1 - x)\n",
        "        eq_1mx = OldTex(\"(1 - x)\")\n",
        "        dot = OldTex(\"\\\\cdot\")\n",
        "        rhs_part = VGroup(dot, eq_1mx)\n",
        "        rhs_part.arrange(RIGHT, buff=0.2)\n",
        "        rhs_part.move_to(func_label, RIGHT)\n",
        "\n",
        "        l_1mx = eq_1mx.copy()\n",
        "        likelihood_rect.restore()\n",
        "        l_1mx.next_to(likelihood_rect, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(likelihood_rect),\n",
        "            FadeIn(l_1mx, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeOut(Underline(p_label)))\n",
        "        self.play(Indicate(coins[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(l_1mx, eq_1mx),\n",
        "            FadeIn(dot, RIGHT),\n",
        "            func_label.next_to, dot, LEFT, 0.2,\n",
        "        )\n",
        "\n",
        "        scaled_graph = axes.get_graph(lambda x: 2 * x * (1 - x))\n",
        "        scaled_region = get_region_under_curve(axes, scaled_graph, 0, 1)\n",
        "\n",
        "        self.play(Transform(graph, scaled_graph))\n",
        "        self.play(FadeIn(scaled_region))\n",
        "        self.wait()\n",
        "\n",
        "        # Renormalize\n",
        "        self.remove(likelihood_rect)\n",
        "        self.play(\n",
        "            TransformFromCopy(likelihood_rect, p_data_rect),\n",
        "            FadeOut(l_1mx)\n",
        "        )\n",
        "        new_graph = get_beta_graph(axes, 1, 1)\n",
        "        group = VGroup(graph, scaled_region)\n",
        "        self.play(\n",
        "            group.set_height,\n",
        "            new_graph.get_height(), {\"about_edge\": DOWN, \"stretch\": True},\n",
        "            group.set_color, BLUE,\n",
        "            FadeOut(region),\n",
        "        )\n",
        "        region = scaled_region\n",
        "        self.play(FadeOut(p_data_rect))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(const))\n",
        "\n",
        "        # Repeat\n",
        "        exp1 = Integer(1)\n",
        "        exp1.set_height(0.2)\n",
        "        exp1.move_to(func_label[2].get_corner(UR), DL)\n",
        "        exp1.shift(0.02 * DOWN + 0.07 * RIGHT)\n",
        "\n",
        "        exp2 = exp1.copy()\n",
        "        exp2.move_to(eq_1mx.get_corner(UR), DL)\n",
        "        exp2.shift(0.1 * RIGHT)\n",
        "        exp2.align_to(exp1, DOWN)\n",
        "\n",
        "        shift_vect = UP + 0.5 * LEFT\n",
        "        VGroup(exp1, exp2).shift(shift_vect)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(exp1, DOWN),\n",
        "            FadeIn(exp2, DOWN),\n",
        "            VGroup(func_label, dot, eq_1mx).shift, shift_vect,\n",
        "            bayes.scale, 0.5,\n",
        "            bayes.next_to, p_label, DOWN, LARGE_BUFF, {\"aligned_edge\": RIGHT},\n",
        "        )\n",
        "        nh = 1\n",
        "        nt = 1\n",
        "        for coin, is_heads in zip(coins[2:10], bool_values[2:10]):\n",
        "            self.play(\n",
        "                arrow.next_to, coin, DOWN, SMALL_BUFF,\n",
        "                MaintainPositionRelativeTo(data_label, arrow),\n",
        "                FadeIn(coin, DOWN),\n",
        "            )\n",
        "            if is_heads:\n",
        "                nh += 1\n",
        "                old_exp = exp1\n",
        "            else:\n",
        "                nt += 1\n",
        "                old_exp = exp2\n",
        "\n",
        "            new_exp = old_exp.copy()\n",
        "            new_exp.increment_value(1)\n",
        "\n",
        "            dist = scipy.stats.beta(nh + 1, nt + 1)\n",
        "            new_graph = axes.get_graph(dist.pdf)\n",
        "            new_region = get_region_under_curve(axes, new_graph, 0, 1)\n",
        "            new_region.match_style(region)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(graph),\n",
        "                FadeOut(region),\n",
        "                FadeIn(new_graph),\n",
        "                FadeIn(new_region),\n",
        "                FadeOut(old_exp, MED_SMALL_BUFF * UP),\n",
        "                FadeIn(new_exp, MED_SMALL_BUFF * DOWN),\n",
        "            )\n",
        "            graph = new_graph\n",
        "            region = new_region\n",
        "            self.remove(new_exp)\n",
        "            self.add(old_exp)\n",
        "            old_exp.increment_value()\n",
        "            self.wait()\n",
        "\n",
        "            if coin is coins[4]:\n",
        "                area_label = OldTexText(\"Area = 1\")\n",
        "                area_label.move_to(axes.c2p(0.6, 0.8))\n",
        "                self.play(GrowFromPoint(\n",
        "                    area_label, const.get_center()\n",
        "                ))\n",
        "\n",
        "\n",
        "class PDefectEqualsQmark(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTex(\n",
        "            \"P(\\\\text{Defect}) = ???\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Defect}\": RED,\n",
        "            }\n",
        "        )\n",
        "        self.play(FadeIn(label, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UpdateOnceWithBinomial(TalkThroughCoinExample):\n",
        "    def construct(self):\n",
        "        # Fair bit of copy-pasting from above.  If there's\n",
        "        # time, refactor this properly\n",
        "        # Setup\n",
        "        axes = self.get_axes()\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label.next_to(axes.x_axis.get_end(), UR, MED_SMALL_BUFF)\n",
        "        axes.add(x_label)\n",
        "\n",
        "        p_label, prob, prob_box = self.get_probability_label()\n",
        "        prob_box_x = x_label.copy().move_to(prob_box)\n",
        "\n",
        "        q_marks = prob_box[1]\n",
        "        prob_box.remove(q_marks)\n",
        "        prob_box.add(prob_box_x)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(p_label)\n",
        "        self.add(prob_box)\n",
        "\n",
        "        # Coins\n",
        "        bool_values = (np.random.random(100) < self.true_p)\n",
        "        bool_values[:5] = [True, False, True, True, False]\n",
        "        coins = self.get_coins(bool_values)\n",
        "        coins.next_to(axes.y_axis, RIGHT, MED_LARGE_BUFF)\n",
        "        coins.to_edge(UP)\n",
        "        self.add(coins[:10])\n",
        "\n",
        "        # Uniform pdf\n",
        "        region = get_beta_graph(axes, 0, 0)\n",
        "        graph = axes.get_graph(\n",
        "            lambda x: 1,\n",
        "            min_samples=30,\n",
        "        )\n",
        "        self.add(region, graph)\n",
        "\n",
        "        # Show Bayes rule\n",
        "        bayes = OldTex(\n",
        "            \"p({x} | \\\\text{data})\", \"=\",\n",
        "            \"p({x})\",\n",
        "            \"{P(\\\\text{data} | {x})\",\n",
        "            \"\\\\over\",\n",
        "            \"P(\\\\text{data})\",\n",
        "            tex_to_color_map={\n",
        "                \"{x}\": WHITE,\n",
        "                \"\\\\text{data}\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        bayes.move_to(axes.c2p(0, 2.5))\n",
        "        bayes.align_to(coins, LEFT)\n",
        "\n",
        "        likelihood = bayes[9:14]\n",
        "        # likelihood_rect = SurroundingRectangle(likelihood, buff=0.05)\n",
        "\n",
        "        self.add(bayes)\n",
        "\n",
        "        # All data at once\n",
        "        brace = Brace(coins[:10], DOWN)\n",
        "        all_data_label = brace.get_text(\"One update from all data\")\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(all_data_label, 0.2 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Binomial formula\n",
        "        nh = sum(bool_values[:10])\n",
        "        nt = sum(~bool_values[:10])\n",
        "\n",
        "        likelihood_brace = Brace(likelihood, UP)\n",
        "        t2c = {\n",
        "            str(nh): BLUE,\n",
        "            str(nt): RED,\n",
        "        }\n",
        "        binom_formula = OldTex(\n",
        "            \"{10 \\\\choose \", str(nh), \"}\",\n",
        "            \"x^{\", str(nh), \"}\",\n",
        "            \"(1-x)^{\" + str(nt) + \"}\",\n",
        "            tex_to_color_map=t2c,\n",
        "        )\n",
        "        binom_formula[0][-1].set_color(BLUE)\n",
        "        binom_formula[1].set_color(WHITE)\n",
        "        binom_formula.set_width(likelihood_brace.get_width() + 0.5)\n",
        "        binom_formula.next_to(likelihood_brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(brace, likelihood_brace),\n",
        "            FadeOut(all_data_label),\n",
        "            FadeIn(binom_formula)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # New plot\n",
        "        rhs = OldTex(\n",
        "            \"C \\\\cdot\",\n",
        "            \"x^{\", str(nh), \"}\",\n",
        "            \"(1-x)^{\", str(nt), \"}\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        rhs.next_to(bayes[:5], DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.rotate(90 * DEGREES)\n",
        "        eq.next_to(bayes[:5], DOWN, buff=0.35)\n",
        "\n",
        "        dist = scipy.stats.beta(nh + 1, nt + 1)\n",
        "        new_graph = axes.get_graph(dist.pdf)\n",
        "        new_graph.shift(1e-6 * UP)\n",
        "        new_graph.set_stroke(WHITE, 1, opacity=0.5)\n",
        "        new_region = get_region_under_curve(axes, new_graph, 0, 1)\n",
        "        new_region.match_style(region)\n",
        "        new_region.set_opacity(0.75)\n",
        "\n",
        "        self.add(new_region, new_graph, bayes)\n",
        "        self.play(\n",
        "            FadeOut(graph),\n",
        "            FadeOut(region),\n",
        "            FadeIn(new_graph),\n",
        "            FadeIn(new_region),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(eq),\n",
        "            FadeIn(rhs, UP)\n",
        "        )\n",
        "        self.wait()\n"
    ]
}