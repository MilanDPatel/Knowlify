{
    "topic": "The mathematical concept being demonstrated is the Sudoku puzzle, which involves filling in a 9",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.blocks_and_grover.qc_supplements import *\n",
        "\n",
        "\n",
        "default_sudoku_values = [  # TODO\n",
        "    [7, 4, 3, 6, 5, 1, 9, 8, 2],\n",
        "    [1, 8, 9, 2, 3, 4, 7, 6, 5],\n",
        "    [6, 2, 5, 9, 8, 7, 4, 3, 1],\n",
        "    [3, 2, 5, 8, 6, 9, 4, 1, 7],\n",
        "    [9, 7, 6, 3, 4, 1, 5, 2, 8],\n",
        "    [1, 4, 8, 7, 5, 2, 3, 6, 9],\n",
        "    [2, 3, 8, 5, 7, 6, 1, 9, 4],\n",
        "    [4, 1, 7, 8, 9, 3, 6, 5, 2],\n",
        "    [5, 9, 6, 2, 1, 4, 8, 7, 3],\n",
        "]\n",
        "\n",
        "default_sudoku_locked_cells = [\n",
        "    [3, 7, 8],\n",
        "    [1, 6, 7, 8],\n",
        "    [3, 5],\n",
        "    [1, 3, 6, 8],\n",
        "    [5],\n",
        "    [1, 3, 4, 8],\n",
        "    [5, 6],\n",
        "    [5],\n",
        "    [4, 9],\n",
        "]\n",
        "\n",
        "\n",
        "class Sudoku(VGroup):\n",
        "    def __init__(\n",
        "        self,\n",
        "        values=default_sudoku_values,\n",
        "        locked_cells=default_sudoku_locked_cells,\n",
        "        height=4,\n",
        "        big_square_stroke_width=3,\n",
        "        little_square_stroke_width=0.5,\n",
        "        locked_number_color=BLUE_B,\n",
        "        num_to_square_height_ratio=0.5\n",
        "    ):\n",
        "        self.big_grid = self.get_square_grid(height, big_square_stroke_width)\n",
        "        self.little_grids = VGroup(\n",
        "            self.get_square_grid(height / 3, little_square_stroke_width).move_to(square)\n",
        "            for square in self.big_grid\n",
        "        )\n",
        "        self.numbers = VGroup(\n",
        "            VGroup(\n",
        "                Integer(num).replace(square, 1).scale(num_to_square_height_ratio)\n",
        "                for square, num in zip(grid, arr)\n",
        "            )\n",
        "            for grid, arr in zip(self.little_grids, values)\n",
        "        )\n",
        "        self.locked_cells = locked_cells\n",
        "        self.locked_numbers = VGroup()\n",
        "        self.unlocked_numbers = VGroup()\n",
        "\n",
        "        for coords, group in zip(locked_cells, self.numbers):\n",
        "            for x, num in enumerate(group):\n",
        "                if x in coords:\n",
        "                    self.locked_numbers.add(num)\n",
        "                else:\n",
        "                    self.unlocked_numbers.add(num)\n",
        "        self.locked_numbers.set_fill(locked_number_color, border_width=2)\n",
        "\n",
        "        super().__init__(self.big_grid, self.little_grids, self.numbers)\n",
        "\n",
        "    def get_rows(self):\n",
        "        grids = self.numbers\n",
        "        slices = [slice(0, 3), slice(3, 6), slice(6, 9)]\n",
        "        rows = VGroup()\n",
        "        for slc1 in slices:\n",
        "            for slc2 in slices:\n",
        "                row = VGroup()\n",
        "                for grid in grids[slc1]:\n",
        "                    for num in grid[slc2]:\n",
        "                        row.add(num)\n",
        "                rows.add(row)\n",
        "        return rows\n",
        "\n",
        "    def get_columns(self):\n",
        "        grids = self.numbers\n",
        "        slices = [slice(0, 9, 3), slice(1, 9, 3), slice(2, 9, 3)]\n",
        "        cols = VGroup()\n",
        "        for slc1 in slices:\n",
        "            for slc2 in slices:\n",
        "                col = VGroup()\n",
        "                for grid in grids[slc1]:\n",
        "                    for num in grid[slc2]:\n",
        "                        col.add(num)\n",
        "                cols.add(col)\n",
        "        return cols\n",
        "\n",
        "    def get_number_squares(self):\n",
        "        return self.numbers\n",
        "\n",
        "    def get_square_grid(\n",
        "        self,\n",
        "        height,\n",
        "        stroke_width,\n",
        "        stroke_color=WHITE,\n",
        "        fill_color=GREY_E,\n",
        "    ):\n",
        "        square = Square()\n",
        "        square.set_fill(fill_color, 1)\n",
        "        square.set_stroke(stroke_color, stroke_width)\n",
        "        grid = square.get_grid(3, 3, buff=0)\n",
        "        grid.set_height(height)\n",
        "        return grid\n",
        "\n",
        "\n",
        "class Intro(InteractiveScene):\n",
        "    random_seed = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        background = FullScreenRectangle().set_fill(GREY_E)\n",
        "        background.set_fill(GREY_E, 0.5)\n",
        "        self.add(background)\n",
        "\n",
        "        icon = get_quantum_computer_symbol(height=3)\n",
        "        icon.center()\n",
        "        self.play(Write(icon, run_time=3, lag_ratio=1e-2, stroke_color=TEAL))\n",
        "        self.wait()\n",
        "        self.play(icon.animate.to_edge(LEFT))\n",
        "        self.wait()\n",
        "\n",
        "        # Comments\n",
        "        folder = Path('/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/blocks_and_grover/Comments')\n",
        "        comments = Group(\n",
        "            Group(ImageMobject(folder / name))\n",
        "            for name in os.listdir(folder)\n",
        "        )\n",
        "        for comment in comments:\n",
        "            comment.add_to_back(SurroundingRectangle(comment, buff=0).set_stroke(WHITE, 1))\n",
        "            comment.set_width(4)\n",
        "            comment.move_to(4 * LEFT)\n",
        "            comment.shift(np.random.uniform(-1, 1) * RIGHT + np.random.uniform(-3, 3) * UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(icon, time_span=(0, 2)),\n",
        "            LaggedStartMap(FadeIn, comments, lag_ratio=0.6, shift=0.25 * UP, run_time=8)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HowDoYouKnowWhichAxis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.play(\n",
        "            morty.change(\"guilty\"),\n",
        "            stds[2].says(\"Doesn't this assumes\\nknowing the key value?\", mode=\"angry\", bubble_direction=LEFT),\n",
        "            stds[0].change(\"confused\", look_at=self.screen),\n",
        "            stds[1].change(\"pleading\", look_at=self.screen),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(5)\n",
        "        self.play(self.change_students(\"erm\", \"confused\", \"sassy\"))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class SudokuChecker(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Introduce, and add solution\n",
        "        sudoku = Sudoku(height=6)\n",
        "        sudoku.unlocked_numbers.set_opacity(0)\n",
        "\n",
        "        self.play(Write(sudoku, run_time=3, lag_ratio=1e-2))\n",
        "        sudoku.unlocked_numbers.shuffle()\n",
        "        self.play(sudoku.unlocked_numbers.animate.set_opacity(1).set_anim_args(lag_ratio=0.1), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        # Check rows, columns, squares\n",
        "        row_rects, col_rects, square_rects = rect_groups = VGroup(\n",
        "            VGroup(\n",
        "                VGroup(SurroundingRectangle(num) for num in sg)\n",
        "                for sg in group\n",
        "            )\n",
        "            for group in [sudoku.get_rows(), sudoku.get_columns(), sudoku.get_number_squares()]\n",
        "        )\n",
        "        rect_groups.set_stroke(YELLOW, 3)\n",
        "\n",
        "        for group in rect_groups:\n",
        "            self.play(\n",
        "                LaggedStart(*(\n",
        "                    VFadeInThenOut(sg, lag_ratio=0.025)\n",
        "                    for sg in group\n",
        "                ), lag_ratio=0.5, run_time=5)\n",
        "            )\n",
        "\n",
        "        # Replace with question marks\n",
        "        unlocked_numbers = sudoku.unlocked_numbers\n",
        "        q_marks = VGroup(\n",
        "            Text(\"?\").replace(num, 1)\n",
        "            for num in sudoku.unlocked_numbers\n",
        "        )\n",
        "        q_marks.set_color(RED)\n",
        "        unlocked_numbers.save_state()\n",
        "        self.play(\n",
        "            Transform(unlocked_numbers, q_marks, lag_ratio=1e-2, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(unlocked_numbers))\n",
        "\n",
        "        # Show randomization\n",
        "        def randomize_numbers(numbers):\n",
        "            for number in numbers:\n",
        "                number.set_value(random.uniform(1, 9))\n",
        "\n",
        "        self.play(UpdateFromFunc(sudoku.unlocked_numbers, randomize_numbers, run_time=10))\n",
        "\n",
        "\n",
        "class SudokuCheckingCode(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Thanks Claude!\n",
        "        code = Code(\"\"\"\n",
        "            def is_valid_sudoku(board):\n",
        "                \\\"\\\"\\\"\n",
        "                Check if a completed Sudoku board is valid.\n",
        "\n",
        "                Args:\n",
        "                    board: A 9x9 list of lists where each\n",
        "                    cell contains an integer from 1 to 9\n",
        "\n",
        "                Returns:\n",
        "                    bool: True if the solution is valid, False otherwise\n",
        "                \\\"\\\"\\\"\n",
        "                # Check rows\n",
        "                for row in board:\n",
        "                    if set(row) != set(range(1, 10)):\n",
        "                        return False\n",
        "\n",
        "                # Check columns\n",
        "                for col in range(9):\n",
        "                    column = [board[row][col] for row in range(9)]\n",
        "                    if set(column) != set(range(1, 10)):\n",
        "                        return False\n",
        "\n",
        "                # Check 3x3 sub-boxes\n",
        "                for box_row in range(0, 9, 3):\n",
        "                    for box_col in range(0, 9, 3):\n",
        "                        # Get all numbers in the current 3x3 box\n",
        "                        box = []\n",
        "                        for i in range(3):\n",
        "                            for j in range(3):\n",
        "                                box.append(board[box_row + i][box_col + j])\n",
        "                        if set(box) != set(range(1, 10)):\n",
        "                            return False\n",
        "\n",
        "                # If all checks pass, the solution is valid\n",
        "                return True\n",
        "        \"\"\", alignment=\"LEFT\")\n",
        "        code.set_height(7)\n",
        "        self.play(ShowIncreasingSubsets(code, run_time=8, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ArrowToQC(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        icon = get_quantum_computer_symbol(height=2.5)\n",
        "        icon.center().to_edge(DOWN)\n",
        "        arrow = Vector(1.5 * DOWN, thickness=6)\n",
        "        arrow.next_to(icon, UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(icon, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CompiledSudokuVerifier(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        sudoku = Sudoku(height=5)\n",
        "        sudoku.to_edge(LEFT)\n",
        "\n",
        "        machine = get_blackbox_machine(height=3, label_tex=R\"\\text{Verifier}\")\n",
        "        machine.next_to(sudoku, RIGHT, LARGE_BUFF)\n",
        "        machine[-1].scale(0.65).set_color(YELLOW)\n",
        "\n",
        "        self.add(sudoku)\n",
        "        self.add(machine)\n",
        "\n",
        "        # Pile logic gates into the machine\n",
        "        gates = VGroup(\n",
        "            SVGMobject(\"and_gate\"),\n",
        "            SVGMobject(\"or_gate\"),\n",
        "            SVGMobject(\"not_gate\"),\n",
        "        )\n",
        "        names = VGroup(Text(text) for text in [\"AND\", \"OR\", \"NOT\"])\n",
        "        names.scale(0.5)\n",
        "        names.set_fill(GREY_C)\n",
        "\n",
        "        gates.set_height(0.65)\n",
        "        gates.set_fill(GREY_B)\n",
        "        gates.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        gates.next_to(machine, UP, MED_LARGE_BUFF)\n",
        "        for name, gate in zip(names, gates):\n",
        "            name.next_to(gate, UP)\n",
        "\n",
        "        pile_of_gates = VGroup(*it.chain(*(g.replicate(200) for g in gates)))\n",
        "        pile_of_gates.shuffle()\n",
        "        pile_of_gates.set_fill(opacity=0.25)\n",
        "        pile_of_gates.generate_target()\n",
        "        for gate in pile_of_gates.target:\n",
        "            gate.scale(0.25)\n",
        "            shift = np.random.uniform(-1.5, 1.5, 3)\n",
        "            shift[2] = 0\n",
        "            gate.move_to(machine.get_center() + shift)\n",
        "            gate.set_fill(opacity=0.1)\n",
        "\n",
        "        self.add(gates, names)\n",
        "        self.play(\n",
        "            MoveToTarget(pile_of_gates, lag_ratio=3.0 / len(pile_of_gates), run_time=8)\n",
        "        )\n",
        "\n",
        "        # Turn sudoku into binary\n",
        "        all_numbers = VGroup(num for grid in sudoku.numbers for num in grid)\n",
        "        bit_groups = VGroup(\n",
        "            BitString(num.get_value()).replace(num, 1).scale(0.35)\n",
        "            for num in all_numbers\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(all_numbers, bit_groups, lag_ratio=1e-3),\n",
        "            sudoku.big_grid.animate.set_fill(opacity=0.1).set_stroke(opacity=0.25),\n",
        "            sudoku.little_grids.animate.set_fill(opacity=0.1).set_stroke(opacity=0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        target_bits = bit_groups.copy()\n",
        "        target_bits.arrange(DOWN, buff=0.025)\n",
        "        target_bits.set_height(machine.get_height() * 0.5)\n",
        "        target_bits.move_to(machine, LEFT)\n",
        "        target_bits.set_opacity(0.1)\n",
        "        self.play(TransformFromCopy(bit_groups, target_bits, lag_ratio=1e-3, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show outputs\n",
        "        outputs = VGroup(Integer(1), Integer(0))\n",
        "        outputs.set_height(0.75)\n",
        "        outputs.next_to(machine, RIGHT, LARGE_BUFF)\n",
        "        marks = VGroup(Checkmark().set_color(GREEN), Exmark().set_color(RED))\n",
        "        for mark, output in zip(marks, outputs):\n",
        "            mark.match_height(output)\n",
        "            mark.next_to(output, RIGHT)\n",
        "            self.play(FadeIn(output, RIGHT))\n",
        "            self.play(Write(mark))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(mark), FadeOut(output))\n",
        "\n",
        "\n",
        "class StateVectorsAsABasis(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        frame = self.frame\n",
        "        x_range = y_range = z_range = (-2, 2, 1)\n",
        "        axes = ThreeDAxes(x_range, y_range, z_range)\n",
        "        axes.set_height(4)\n",
        "\n",
        "        basis_vectors = VGroup(\n",
        "            Vector(2 * vect, thickness=4)\n",
        "            for vect in np.identity(3)\n",
        "        )\n",
        "        basis_vectors.set_submobject_colors_by_gradient(BLUE_D, BLUE_B)\n",
        "        for vect in basis_vectors:\n",
        "            vect.rotate(90 * DEG, axis=vect.get_vector())\n",
        "\n",
        "        frame.reorient(-23, 81, 0, (-1.0, 0, 0.5), 4)\n",
        "        frame.add_ambient_rotation()\n",
        "        self.add(axes)\n",
        "\n",
        "        # Bit strings\n",
        "        two_qubits = VGroup(\n",
        "            KetGroup(BitString(n, length=2))\n",
        "            for n in range(4)\n",
        "        )\n",
        "        four_qubits = VGroup(\n",
        "            KetGroup(BitString(n, length=4))\n",
        "            for n in range(16)\n",
        "        )\n",
        "        for group in [two_qubits, four_qubits]:\n",
        "            group.fix_in_frame()\n",
        "            group.arrange(DOWN)\n",
        "            group.set_max_height(7)\n",
        "            group.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        two_qubits.scale(1.5, about_edge=LEFT).space_out_submobjects(1.25)\n",
        "\n",
        "        basis_labels = VGroup(\n",
        "            two_qubits[0].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[0].get_end(), OUT, SMALL_BUFF),\n",
        "            two_qubits[1].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[1].get_end(), OUT, SMALL_BUFF),\n",
        "            two_qubits[2].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[2].get_end(), RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        basis_labels.unfix_from_frame()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, two_qubits, shift=0.5 * UP, lag_ratio=0.5))\n",
        "\n",
        "        for src, trg, vect in zip(two_qubits, basis_labels, basis_vectors):\n",
        "            self.play(\n",
        "                TransformFromCopy(src, trg),\n",
        "                GrowArrow(vect)\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Name basis vectors\n",
        "        basis_name = TexText(R\"``Basis vectors''\")\n",
        "        basis_name.fix_in_frame()\n",
        "        basis_name.set_color(BLUE)\n",
        "        basis_name.to_corner(UR, buff=MED_SMALL_BUFF)\n",
        "        self.play(Write(basis_name))\n",
        "        self.wait(10)\n",
        "        self.play(FadeOut(basis_name))\n",
        "\n",
        "        # Replace with larger vectors\n",
        "        new_basis_labels = VGroup(\n",
        "            four_qubits[0].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[0].get_end(), OUT, SMALL_BUFF),\n",
        "            four_qubits[1].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[1].get_end(), OUT, SMALL_BUFF),\n",
        "            four_qubits[2].copy().scale(0.3).rotate(90 * DEG, RIGHT).next_to(basis_vectors[2].get_end(), RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        new_basis_labels.unfix_from_frame()\n",
        "        self.play(\n",
        "            FadeOut(two_qubits),\n",
        "            FadeOut(basis_labels),\n",
        "            LaggedStartMap(FadeIn, four_qubits, lag_ratio=0.25)\n",
        "        )\n",
        "\n",
        "        for src, trg in zip(four_qubits, new_basis_labels):\n",
        "            self.play(TransformFromCopy(src, trg))\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class OperationsOnQC(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Bad output\n",
        "        icon = get_quantum_computer_symbol(height=3)\n",
        "        icon.center()\n",
        "        in_ket = KetGroup(BitString(12).scale(2))\n",
        "        in_ket.next_to(icon, LEFT)\n",
        "        arrows = Vector(RIGHT, thickness=4).replicate(2)\n",
        "        arrows[0].next_to(icon, LEFT)\n",
        "        arrows[1].next_to(icon, RIGHT)\n",
        "        in_ket.next_to(arrows, LEFT)\n",
        "\n",
        "        bad_output = VGroup(Text(\"True\"), Text(\"or\"), Text(\"False\"))\n",
        "        bad_output.scale(1.5)\n",
        "        bad_output.arrange(DOWN)\n",
        "        bad_output.next_to(arrows, RIGHT)\n",
        "        big_cross = Cross(bad_output)\n",
        "        big_cross.scale(1.25)\n",
        "        big_cross.set_stroke(RED, [0, 12, 12, 12, 0])\n",
        "\n",
        "        self.add(icon, arrows, in_ket)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(in_ket.copy(), shift=2 * RIGHT, scale=0.5),\n",
        "            FadeIn(bad_output, shift=2 * RIGHT, scale=2),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(ShowCreation(big_cross))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(in_ket), FadeOut(bad_output), FadeOut(big_cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwoByTwoGrid(InteractiveScene):\n",
        "    random_seed = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        rects = ScreenRectangle().set_height(FRAME_HEIGHT / 2).get_grid(2, 2, buff=0)\n",
        "        h_line = Line(LEFT, RIGHT).replace(rects, 0)\n",
        "        v_line = Line(UP, DOWN).replace(rects, 1)\n",
        "        lines = VGroup(h_line, v_line)\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.add(lines)\n",
        "\n",
        "        # Add classical verifiers\n",
        "        verifiers = get_blackbox_machine(label_tex=\"\").replicate(4)\n",
        "        for n, verifier, rect in zip(it.count(), verifiers, rects):\n",
        "            verifier.set_height(1.0)\n",
        "            verifier.move_to(rect)\n",
        "            if n < 2:\n",
        "                label = Text(\"Verifier\", font_size=24)\n",
        "                label.set_color(YELLOW)\n",
        "            else:\n",
        "                verifier.rotate(90 * DEG)\n",
        "                label = get_quantum_computer_symbol(height=0.75)\n",
        "\n",
        "            label.move_to(verifier)\n",
        "            verifier.add(label)\n",
        "\n",
        "        verifiers[:2].shift(0.75 * RIGHT)\n",
        "\n",
        "        good_sudoku, bad_sudoku = sudokus = VGroup(\n",
        "            Sudoku(big_square_stroke_width=2, little_square_stroke_width=0.25)\n",
        "            for x in range(2)\n",
        "        )\n",
        "        sudokus.set_height(2.5)\n",
        "\n",
        "        for number in bad_sudoku.unlocked_numbers:\n",
        "            number.set_value(random.randint(1, 9))\n",
        "\n",
        "        classical_outputs = VGroup(Integer(1), Integer(0))\n",
        "        marks = VGroup(Checkmark().set_color(GREEN), Exmark().set_color(RED))\n",
        "\n",
        "        for sudoku, verifier, output, mark in zip(sudokus, verifiers, classical_outputs, marks):\n",
        "            sudoku.next_to(verifier, LEFT, MED_LARGE_BUFF)\n",
        "            output.next_to(verifier, RIGHT, MED_LARGE_BUFF)\n",
        "            mark.match_height(output)\n",
        "            mark.next_to(output, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(verifiers[:2])\n",
        "        self.add(sudokus)\n",
        "\n",
        "        for sudoku, verifier, output, mark in zip(sudokus, verifiers, classical_outputs, marks):\n",
        "            self.play(LaggedStart(\n",
        "                FadeOutToPoint(sudoku.numbers.copy(), verifier.get_center(), lag_ratio=1e-3),\n",
        "                FadeInFromPoint(output, verifier.get_center()),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            ))\n",
        "            self.play(Write(mark))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # Map to quantum verifiers\n",
        "        self.play(TransformFromCopy(verifiers[:2], verifiers[2:], run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Translate True behavior\n",
        "        good_input = self.turn_into_bits(good_sudoku)\n",
        "        good_ket = KetGroup(good_input.copy(), height_scale_factor=1.5)\n",
        "        good_ket.next_to(verifiers[2], UP)\n",
        "        good_ket_out = good_ket.copy()\n",
        "        neg = Tex(\"-\", font_size=24)\n",
        "        neg.set_fill(GREEN, border_width=3)\n",
        "        neg.next_to(good_ket_out, LEFT, SMALL_BUFF)\n",
        "        good_ket_out.add_to_back(neg)\n",
        "        good_ket_out.next_to(verifiers[2], DOWN, buff=0.2)\n",
        "\n",
        "        mult_neg_1_words = TexText(R\"Multiply\\\\by $-1$\", font_size=36)\n",
        "        mult_neg_1_words.set_fill(TEAL_A)\n",
        "        mult_neg_1_words.next_to(verifiers[2], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeTransform(good_input.copy(), good_ket))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOutToPoint(good_ket.copy(), verifiers[2].get_center(), lag_ratio=0.01),\n",
        "                FadeInFromPoint(good_ket_out, verifiers[2].get_center(), lag_ratio=0.01),\n",
        "                lag_ratio=0.5\n",
        "            ),\n",
        "            FadeIn(mult_neg_1_words, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Translate False behavior (a lot of coying, but I'm in a rush)\n",
        "        bad_input = self.turn_into_bits(bad_sudoku)\n",
        "        bad_ket = KetGroup(bad_input.copy(), height_scale_factor=1.5)\n",
        "        bad_ket.next_to(verifiers[3], UP)\n",
        "        bad_ket_out = bad_ket.copy()\n",
        "        bad_ket_out.next_to(verifiers[3], DOWN)\n",
        "\n",
        "        mult_pos_1_words = TexText(R\"Multiply\\\\by $+1$\", font_size=36)\n",
        "        mult_pos_1_words.set_fill(TEAL_A)\n",
        "        mult_pos_1_words.next_to(verifiers[3], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeTransform(bad_input.copy(), bad_ket))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOutToPoint(bad_ket.copy(), verifiers[3].get_center(), lag_ratio=0.01),\n",
        "                FadeInFromPoint(bad_ket_out, verifiers[3].get_center(), lag_ratio=0.01),\n",
        "                lag_ratio=0.5\n",
        "            ),\n",
        "            FadeIn(mult_pos_1_words, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show logic gates\n",
        "        gate_groups = VGroup(\n",
        "            SVGMobject(\"and_gate\").replicate(2),\n",
        "            SVGMobject(\"not_gate\").replicate(2),\n",
        "            SVGMobject(\"or_gate\").replicate(2),\n",
        "        )\n",
        "        for group in gate_groups:\n",
        "            group.set_fill(BLUE)\n",
        "            group.target = group.generate_target()\n",
        "            for mob, box in zip(group, verifiers):\n",
        "                mob.match_height(box)\n",
        "                mob.scale(0.8)\n",
        "                mob.next_to(box, UP)\n",
        "            for mob, box in zip(group.target, verifiers[2:]):\n",
        "                mob.match_width(box)\n",
        "                mob.scale(0.7)\n",
        "                mob.move_to(box)\n",
        "                mob.set_fill(TEAL, 0.5)\n",
        "\n",
        "        for group in gate_groups:\n",
        "            self.play(LaggedStartMap(FadeIn, group, shift=UP, lag_ratio=0.5))\n",
        "            self.wait()\n",
        "            self.play(TransformFromCopy(group, group.target))\n",
        "            self.play(FadeOut(group.target))\n",
        "            self.play(FadeOut(group))\n",
        "\n",
        "    def turn_into_bits(self, sudoku):\n",
        "        # Test\n",
        "        bits = VGroup(\n",
        "            BitString(num.get_value()).replace(num, 1).scale(0.35)\n",
        "            for grid in sudoku.numbers for num in grid\n",
        "        )\n",
        "        sudoku.save_state()\n",
        "\n",
        "        in_group = VGroup(\n",
        "            bits[0].copy().set_width(0.25),\n",
        "            Tex(R\"\\cdots\", font_size=20),\n",
        "            bits[-1].copy().set_width(0.25),\n",
        "        )\n",
        "        for piece in in_group:\n",
        "            piece.space_out_submobjects(0.85)\n",
        "        in_group[1].scale(0.7)\n",
        "        in_group.arrange(RIGHT, buff=0.025)\n",
        "        in_group.replace(sudoku, 0)\n",
        "        in_group.set_fill(GREY_A)\n",
        "\n",
        "        sudoku.saved_state.scale(0.5)\n",
        "        sudoku.saved_state.fade(0.5)\n",
        "        sudoku.saved_state.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            sudoku.animate.fade(0.9),\n",
        "            FadeIn(bits, lag_ratio=1e-3)\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            ReplacementTransform(bits[0], in_group[0]),\n",
        "            *(ReplacementTransform(bs, in_group[1]) for bs in bits[1:-1]),\n",
        "            ReplacementTransform(bits[-1], in_group[-1]),\n",
        "            Restore(sudoku),\n",
        "            lag_ratio=1e-2,\n",
        "        ))\n",
        "        return in_group\n",
        "\n",
        "\n",
        "class AskWhyThatsTrue(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.play(\n",
        "            stds[1].says(\"How does that work?\", mode=\"maybe\"),\n",
        "            stds[0].change('erm', look_at=self.screen),\n",
        "            stds[2].change(\"confused\", look_at=self.screen),\n",
        "            morty.change('hesitant'),\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Mapping\n",
        "        mapping = VGroup(\n",
        "            VGroup(Text(\"True\").set_color(GREEN), Vector(DOWN), Tex(R\"\\times -1\")).arrange(DOWN),\n",
        "            VGroup(Text(\"False\").set_color(RED), Vector(DOWN), Tex(R\"\\times +1\")).arrange(DOWN),\n",
        "        )\n",
        "        for part in mapping:\n",
        "            tex = part[2]\n",
        "            tex[1].scale(0.75, about_point=tex[2].get_left())\n",
        "            tex[0].scale(1.5)\n",
        "        mapping.arrange(RIGHT, buff=2.0)\n",
        "        mapping.move_to(self.hold_up_spot, DOWN).shift(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            FadeIn(mapping, UP),\n",
        "            stds[1].debubble(mode=\"pondering\"),\n",
        "            stds[0].change(\"sassy\", mapping),\n",
        "            stds[2].change(\"hesitant\", mapping),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change(\"hesitant\"))\n",
        "        self.wait(3)\n",
        "        self.play(morty.change(\"pondering\", mapping))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ListOfConfusions(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        items = BulletedList(\n",
        "            \"Insufficient detail\",\n",
        "            \"Bad framing\",\n",
        "            \"Glossing over linearity\",\n",
        "            buff=1.0\n",
        "        )\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(item[1:])\n",
        "            for item in items\n",
        "        )\n",
        "        rects.set_stroke(width=0)\n",
        "        rects.set_fill(GREY_D, 1)\n",
        "\n",
        "        self.add(items)\n",
        "        self.add(rects[1:])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            items[0].animate.fade(0.5),\n",
        "            rects[1].animate.stretch(0, 0, about_edge=RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            items[1].animate.fade(0.5),\n",
        "            rects[2].animate.stretch(0, 0, about_edge=RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SolveSHAWord(InteractiveScene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            TexText(R\"Solve for ${x}$\"),\n",
        "            Tex(R\"\\text{SHA256}({x}) = 0\"),\n",
        "        )\n",
        "        words.set_color(GREY_B)\n",
        "        for word in words:\n",
        "            word[\"{x}\"].set_color(YELLOW)\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThatsOnMe(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.play(\n",
        "            morty.says(\"That's on me\", mode=\"guilty\"),\n",
        "            self.change_students(\"pondering\", \"well\", \"hesitant\", look_at=self.screen),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShowSuperposition(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        frame = self.frame\n",
        "        x_range = y_range = z_range = (-2, 2, 1)\n",
        "        axes = ThreeDAxes(x_range, y_range, z_range)\n",
        "        unit_size = 3\n",
        "        axes.set_height(2 * unit_size)\n",
        "\n",
        "        basis_vectors = VGroup(\n",
        "            Vector(unit_size * vect, thickness=5)\n",
        "            for vect in np.identity(3)\n",
        "        )\n",
        "        basis_vectors.set_submobject_colors_by_gradient(BLUE_D, BLUE_B)\n",
        "        for n, vect in enumerate(basis_vectors):\n",
        "            if n < 2:\n",
        "                vect.always.set_perpendicular_to_camera(frame)\n",
        "            else:\n",
        "                vect.rotate(90 * DEG, OUT)\n",
        "\n",
        "        frame.reorient(-33, 74, 0)\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(0.5 * DEG)\n",
        "        self.add(axes)\n",
        "        self.add(basis_vectors)\n",
        "\n",
        "        # Label bases\n",
        "        basis_labels = VGroup(\n",
        "            KetGroup(BitString(n, length=2)).set_height(0.35)\n",
        "            for n in range(3)\n",
        "        )\n",
        "        basis_labels.rotate(90 * DEG, RIGHT)\n",
        "        for label, vect, direction in zip(basis_labels, basis_vectors, [RIGHT, UP + OUT, RIGHT]):\n",
        "            label.next_to(vect.get_end(), direction, MED_SMALL_BUFF)\n",
        "            label.set_fill(vect.get_color(), 1)\n",
        "\n",
        "        self.add(basis_labels, basis_vectors)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show a general vector\n",
        "        vect_coords = normalize([np.sqrt(2) / 2, 0.5, 0.5])\n",
        "        vector = Vector(unit_size * vect_coords, thickness=5, fill_color=TEAL)\n",
        "        vector.set_perpendicular_to_camera(frame)\n",
        "        dec_kw = dict(include_sign=True, font_size=36)\n",
        "        vect_label = VGroup(\n",
        "            DecimalNumber(vect_coords[0], **dec_kw),\n",
        "            KetGroup(BitString(0, 2)),\n",
        "            DecimalNumber(vect_coords[1], **dec_kw),\n",
        "            KetGroup(BitString(1, 2)),\n",
        "            DecimalNumber(vect_coords[2], **dec_kw),\n",
        "            KetGroup(BitString(2, 2)),\n",
        "            DecimalNumber(0, **dec_kw),\n",
        "            KetGroup(BitString(3, 2)),\n",
        "        )\n",
        "        vect_label[1::2].set_submobject_colors_by_gradient(BLUE, BLUE_E)\n",
        "        vect_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        vect_label.rotate(90 * DEG, RIGHT)\n",
        "        vect_label.next_to(vector.get_end(), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(vector),\n",
        "            frame.animate.set_x(1),\n",
        "        )\n",
        "        self.play(FadeIn(vect_label))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show column vector\n",
        "        col = DecimalMatrix(np.array([*vect_coords, 0]).reshape(-1, 1), decimal_config=dec_kw)\n",
        "        col.scale(0.75)\n",
        "        col.rotate(90 * DEG, RIGHT)\n",
        "        col.next_to(vector.get_end(), RIGHT)\n",
        "        eq = Tex(\"=\")\n",
        "        eq.rotate(90 * DEG, RIGHT)\n",
        "        eq.next_to(col, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(col.get_brackets()),\n",
        "            TransformFromCopy(vect_label[0::2], col.get_entries(), run_time=2),\n",
        "            FadeIn(eq),\n",
        "            vect_label.animate.next_to(eq, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        # Surrounding rectangles\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(mob.copy().rotate(90 * DEG, LEFT)).rotate(90 * DEG, RIGHT)\n",
        "            for mob in [col, vect_label]\n",
        "        )\n",
        "        rects.set_stroke(YELLOW, 2)\n",
        "        self.play(ShowCreation(rects[0]))\n",
        "        self.wait(5)\n",
        "        self.play(Transform(*rects))\n",
        "        self.wait(7)\n",
        "\n",
        "        # Write superposition\n",
        "        word = TexText(\"``Superposition''\", font_size=72)\n",
        "        word.rotate(90 * DEG, RIGHT)\n",
        "        word.set_color(YELLOW)\n",
        "        word.next_to(rects[0], OUT)\n",
        "\n",
        "        self.play(Write(word), frame.animate.set_x(2), run_time=3)\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class NorthEastTraveler(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add compass\n",
        "        compass = self.get_compass()\n",
        "        compass.move_to(5 * RIGHT + 2.5 * UP)\n",
        "        self.add(compass)\n",
        "\n",
        "        # Show travler\n",
        "        randy = Randolph(height=1, mode=\"tease\")\n",
        "        vel_vect = Vector(2 * RIGHT, thickness=4, color=YELLOW)\n",
        "        vel_vect.move_to(randy.get_bottom(), LEFT)\n",
        "        travler = VGroup(randy, vel_vect)\n",
        "        travler.rotate(45 * DEG) \n",
        "        travler.move_to(4 * LEFT + 2 * DOWN)\n",
        "\n",
        "        self.add(travler)\n",
        "        self.play(travler.animate.shift(3 * UR), run_time=5, rate_func=linear)\n",
        "\n",
        "        # Show components\n",
        "        components = VGroup(\n",
        "            Vector(math.sqrt(2) * UP).shift(math.sqrt(2) * RIGHT).set_fill(GREEN),\n",
        "            Vector(math.sqrt(2) * RIGHT).set_fill(RED)\n",
        "        )\n",
        "        components.shift(vel_vect.get_start() - components[1].get_start())\n",
        "        labels = VGroup(\n",
        "            Text(\"North\").next_to(components[0], RIGHT, buff=-0.05),\n",
        "            Text(\"East\").next_to(components[1], DOWN, SMALL_BUFF),\n",
        "        )\n",
        "\n",
        "        for component, label in zip(components, labels):\n",
        "            label.scale(0.75)\n",
        "            label.match_color(component)\n",
        "            self.play(\n",
        "                GrowArrow(component),\n",
        "                FadeIn(label)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum\n",
        "        sum_expr = VGroup(labels[0].copy(), Tex(R\"+\", font_size=24), labels[1].copy())\n",
        "        sum_expr.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        sum_expr.next_to(vel_vect.get_end(), UP)\n",
        "        self.play(\n",
        "            TransformFromCopy(labels, sum_expr[0::2]),\n",
        "            Write(sum_expr[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Do a 90 degree rotation\n",
        "        north_group = VGroup(components[0], labels[0])\n",
        "        east_group = VGroup(components[1], labels[1])\n",
        "        self.play(\n",
        "            FadeOut(sum_expr),\n",
        "            north_group.animate.shift(DR).fade(0.5),\n",
        "            east_group.animate.shift(DR).fade(0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(travler.copy().fade(0.75))\n",
        "        t_rot_marks = self.show_90_degree_rotation(travler, 45 * DEG, about_point=vel_vect.get_start())\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            north_group.animate.set_fill(opacity=1).shift(UR),\n",
        "            FadeOut(t_rot_marks)\n",
        "        )\n",
        "        n_rot_marks = self.show_90_degree_rotation(components[0], 90 * DEG, about_point=components[0].get_start())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            east_group.animate.set_fill(opacity=1).shift(DR + DOWN)\n",
        "        )\n",
        "        e_rot_marks = self.show_90_degree_rotation(components[1], 0, about_point=components[1].get_start())\n",
        "\n",
        "        self.add(components.copy().set_opacity(0.5))\n",
        "        self.play(components[1].animate.shift(vel_vect.get_start() - components[1].get_start()))\n",
        "        self.play(components[0].animate.shift(components[1].get_end() - components[0].get_start()))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            Rotate(mob, -90 * DEG, about_point=vel_vect.get_start(), run_time=6, rate_func=there_and_back_with_pause)\n",
        "            for mob in [travler, *components]\n",
        "        ), lag_ratio=0.05))\n",
        "\n",
        "    def get_compass(self):\n",
        "        spike = Triangle()\n",
        "        spike.set_shape(0.25, 1)\n",
        "        spike.move_to(ORIGIN, DOWN)\n",
        "        spikes = VGroup(\n",
        "            spike.copy().rotate(x * TAU / 4, about_point=ORIGIN)\n",
        "            for x in range(4)\n",
        "        )\n",
        "        lil_spikes = spikes.copy().rotate(45 * DEG).scale(0.75)\n",
        "        dot = Circle(radius=0.25)\n",
        "        compass = VGroup(spikes, lil_spikes, dot)\n",
        "        compass.set_stroke(width=0)\n",
        "        compass.set_fill(GREY_D, 1)\n",
        "        compass.set_shading(0.5, 0.5, 1)\n",
        "\n",
        "        labels = VGroup(map(Text, \"NWSE\"))\n",
        "        labels.scale(0.5)\n",
        "        for label, spike, vect in zip(labels, spikes, compass_directions(4, start_vect=UP)):\n",
        "            label.next_to(spike, np.round(vect), SMALL_BUFF)\n",
        "        compass.add(labels)\n",
        "\n",
        "        return compass\n",
        "\n",
        "    def show_90_degree_rotation(self, mobject, start_angle, about_point, radius=1.5):\n",
        "        arc = Arc(start_angle, 90 * DEG, arc_center=about_point, radius=radius)\n",
        "        arc.add_tip(width=0.2, length=0.2)\n",
        "        arc.set_color(YELLOW)\n",
        "        label = Tex(R\"90^\\circ\")\n",
        "        midpoint = arc.pfp(0.5)\n",
        "        label.next_to(midpoint, normalize(midpoint - about_point))\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(arc),\n",
        "            FadeIn(label),\n",
        "            Rotate(mobject, 90 * DEG, about_point=about_point),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "        return VGroup(arc, label)\n",
        "\n",
        "\n",
        "class SimpleTwobitKet(InteractiveScene):\n",
        "    def construct(self):\n",
        "        group = KetGroup(BitString(2, 2))\n",
        "        group.scale(2)\n",
        "        self.add(group)\n",
        "\n",
        "\n",
        "class ShowLinearityExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add machine\n",
        "        machine = get_blackbox_machine()\n",
        "        machine[-1].set_color(TEAL)\n",
        "        icon = get_quantum_computer_symbol(height=1)\n",
        "        icon.next_to(machine, DOWN)\n",
        "\n",
        "        self.add(machine, icon)\n",
        "        self.wait()\n",
        "\n",
        "        # Show a weighted sum\n",
        "        kets = VGroup(\n",
        "            KetGroup(BitString(n, 2))\n",
        "            for n in range(4)\n",
        "        )\n",
        "        kets.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "        kets.set_submobject_colors_by_gradient(BLUE, BLUE_E)\n",
        "        kets.next_to(machine, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        components = VGroup(\n",
        "            DecimalNumber(n, include_sign=True, font_size=42)\n",
        "            for n in normalize([1, -2, 3, -4])\n",
        "        )\n",
        "        for component, ket in zip(components, kets):\n",
        "            component.next_to(ket, LEFT, SMALL_BUFF)\n",
        "\n",
        "        in_group = VGroup(components, kets)\n",
        "        self.play(FadeIn(in_group, RIGHT))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOutToPoint(in_group.copy(), machine.get_left() + RIGHT, lag_ratio=0.01, run_time=2)\n",
        "        )\n",
        "\n",
        "        # Show output\n",
        "        out_kets = VGroup()\n",
        "        for ket in kets:\n",
        "            f_group = Tex(R\"f()\", font_size=60)\n",
        "            f_group.set_color(TEAL)\n",
        "            f_group[:2].next_to(ket, LEFT, SMALL_BUFF)\n",
        "            f_group[2].next_to(ket, RIGHT, SMALL_BUFF)\n",
        "            out_ket = VGroup(f_group, ket.copy())\n",
        "            out_kets.add(out_ket)\n",
        "\n",
        "        out_components = components.copy()\n",
        "        out_kets.next_to(machine, RIGHT, buff=1.5)\n",
        "        for out_ket, component in zip(out_kets, out_components):\n",
        "            component.next_to(out_ket, LEFT, SMALL_BUFF)\n",
        "\n",
        "        out_group = VGroup(out_components, out_kets)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromPoint(out_group, machine.get_right() + LEFT, lag_ratio=0.01, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight components\n",
        "        in_rects = VGroup(map(SurroundingRectangle, components))\n",
        "        out_rects = VGroup(map(SurroundingRectangle, out_components))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(VFadeInThenOut, in_rects, lag_ratio=0.5),\n",
        "            LaggedStartMap(VFadeInThenOut, out_rects, lag_ratio=0.5),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ZGateExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        z_gates = VGroup(get_blackbox_machine(label_tex=\"Z\") for n in range(3))\n",
        "        z_gates.scale(0.35)\n",
        "        z_gates.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        z_gates.move_to(4 * LEFT + UP)\n",
        "        for gate in z_gates:\n",
        "            gate[-1].set_color(TEAL)\n",
        "            gate[-1].scale(1.5)\n",
        "\n",
        "        zero, one = kets = VGroup(\n",
        "            KetGroup(Integer(0)),\n",
        "            KetGroup(Integer(1)),\n",
        "        )\n",
        "        gen_input = VGroup(Tex(R\"x\"), zero.copy(), Tex(R\"+\"), Tex(R\"y\"), one.copy())\n",
        "        gen_input.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        inputs = VGroup(zero, one, gen_input)\n",
        "        for in_group, gate in zip(inputs, z_gates):\n",
        "            in_group.next_to(gate, LEFT)\n",
        "\n",
        "        # Act on zero, then one\n",
        "        outputs = VGroup(\n",
        "            zero.copy().next_to(z_gates[0], RIGHT),\n",
        "            VGroup(Tex(\"-\"), one.copy()).arrange(RIGHT, buff=SMALL_BUFF).next_to(z_gates[1], RIGHT)\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(z_gates[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(zero, RIGHT))\n",
        "        self.play(LaggedStart(\n",
        "            FadeOutToPoint(zero.copy(), z_gates[0].get_center(), lag_ratio=0.05),\n",
        "            FadeInFromPoint(outputs[0], z_gates[0].get_center(), lag_ratio=0.05),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(*z_gates[:2]),\n",
        "            TransformFromCopy(*kets),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            FadeOutToPoint(one.copy(), z_gates[1].get_center(), lag_ratio=0.05),\n",
        "            FadeInFromPoint(outputs[1], z_gates[1].get_center(), lag_ratio=0.05),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # General input\n",
        "        self.play(\n",
        "            TransformFromCopy(*z_gates[1:3]),\n",
        "            TransformFromCopy(kets, gen_input[1::3]),\n",
        "            *(FadeIn(gen_input[i]) for i in [0, 2, 3])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rhss = VGroup(\n",
        "            Tex(R\"xZ|0\\rangle + y Z|1\\rangle \", t2c={\"Z\": TEAL}),\n",
        "            Tex(R\"x |0\\rangle - y |1\\rangle\"),\n",
        "        )\n",
        "        rhss[0].next_to(z_gates[2], RIGHT)\n",
        "        rhss[1].next_to(rhss[0], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOutToPoint(gen_input.copy(), z_gates[2].get_center(), lag_ratio=0.01),\n",
        "            FadeInFromPoint(rhss[0], z_gates[2].get_center(), lag_ratio=0.01),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rhss[1], DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PassSuperpositionIntoVerifier(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up machine\n",
        "        frame = self.frame\n",
        "        frame.shift(1.5 * LEFT)\n",
        "        machine = get_blackbox_machine(label_tex=\"V\")\n",
        "        machine[-1].set_color(TEAL)\n",
        "        self.add(machine)\n",
        "\n",
        "        # Bit string to general input\n",
        "        bit_ket = KetGroup(Tex(\"0111...0011\"))\n",
        "        bit_ket.next_to(machine, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        basis_kets = VGroup(\n",
        "            KetGroup(Tex(R\"b_0\")),\n",
        "            KetGroup(Tex(R\"b_1\")),\n",
        "            Tex(R\"\\vdots\"),\n",
        "            KetGroup(Tex(R\"b_k\")),\n",
        "            Tex(R\"\\vdots\"),\n",
        "            KetGroup(Tex(R\"b_{n-2}\")),\n",
        "            KetGroup(Tex(R\"b_{n-1}\")),\n",
        "        )\n",
        "        basis_kets.set_submobject_colors_by_gradient(BLUE, BLUE_E)\n",
        "        basis_kets.arrange(DOWN)\n",
        "        basis_kets.next_to(machine, LEFT, MED_LARGE_BUFF)\n",
        "        components = VGroup(\n",
        "            Tex(R\"x_0\"), Tex(R\"+x_1\"), VectorizedPoint(), Tex(\"+x_k\"), VectorizedPoint(), Tex(\"+x_{n-2}\"), Tex(R\"+x_{n-1}\")\n",
        "        )\n",
        "        for comp, ket in zip(components, basis_kets):\n",
        "            comp.next_to(ket, LEFT, SMALL_BUFF)\n",
        "\n",
        "        basis_label = Text(\"Basis\")\n",
        "        basis_label.next_to(bit_ket, LEFT)\n",
        "        brace = Brace(components, LEFT)\n",
        "        superposition_word = brace.get_text(\"Superposition\")\n",
        "\n",
        "        self.add(bit_ket)\n",
        "        self.play(FadeIn(basis_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(bit_ket, basis_kets[3]),\n",
        "            basis_label.animate.next_to(basis_kets[3], LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(basis_label, superposition_word),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(basis_kets, lag_ratio=0.1, run_time=2),\n",
        "            FadeIn(components, lag_ratio=0.1, run_time=2),\n",
        "        )\n",
        "        self.remove(bit_ket)\n",
        "        self.wait()\n",
        "\n",
        "        # Show the output\n",
        "        out_kets = basis_kets.copy()\n",
        "        out_Vs = VGroup(\n",
        "            Tex(R\"V\").set_color(TEAL).next_to(ket, LEFT, SMALL_BUFF)\n",
        "            for ket in out_kets\n",
        "        )\n",
        "        VGroup(out_Vs[2], out_Vs[4]).set_opacity(0)\n",
        "        out_comps = components.copy()\n",
        "        out_comps.shift(out_Vs[0].get_width() * LEFT)\n",
        "        out_group = VGroup(out_comps, out_Vs, out_kets)\n",
        "        out_group.next_to(machine, RIGHT)\n",
        "\n",
        "        in_group = VGroup(components, basis_kets)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOutToPoint(in_group.copy(), machine.get_left() + RIGHT, lag_ratio=0.01),\n",
        "                FadeInFromPoint(out_group, machine.get_right() + LEFT, lag_ratio=0.01),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            ),\n",
        "            frame.animate.center(),\n",
        "            FadeOut(brace),\n",
        "            FadeOut(superposition_word),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show unchanged parts\n",
        "        last_annotation = VGroup()\n",
        "        for n in [0, 1, -2, -1]:\n",
        "            comp = out_comps[n]\n",
        "            V = out_Vs[n]\n",
        "            ket = out_kets[n]\n",
        "\n",
        "            rect = SurroundingRectangle(VGroup(comp, V, ket))\n",
        "            rect.set_stroke(YELLOW)\n",
        "            label = Text(\"Unchanged\", font_size=36)\n",
        "            label.set_color(YELLOW)\n",
        "            label.next_to(rect, RIGHT)\n",
        "            annotation = VGroup(rect, label)\n",
        "            self.play(LaggedStart(\n",
        "                FadeOut(last_annotation),\n",
        "                FadeIn(annotation),\n",
        "                FadeOut(V),\n",
        "                comp.animate.shift(V.get_width() * RIGHT),\n",
        "            ))\n",
        "            last_annotation = annotation\n",
        "        self.play(FadeOut(annotation))\n",
        "\n",
        "        # Show key solution\n",
        "        sol_index = 3\n",
        "        solution_label = Text(\"Sudoku\\nSolution\")\n",
        "        solution_label.next_to(components[sol_index], LEFT, LARGE_BUFF)\n",
        "        solution_arrow = Arrow(solution_label, components[sol_index])\n",
        "\n",
        "        out_rect = SurroundingRectangle(\n",
        "            VGroup(out_comps[sol_index], out_Vs[sol_index], out_kets[sol_index])\n",
        "        )\n",
        "        out_rect.set_stroke(YELLOW)\n",
        "        flip_word = Text(\"Flip!\")\n",
        "        flip_word.set_color(YELLOW)\n",
        "        flip_word.next_to(out_rect, RIGHT)\n",
        "        new_out_comp = Tex(R\"-x_k\")\n",
        "        new_out_comp.next_to(out_kets[sol_index], LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(out_rect),\n",
        "            FadeIn(flip_word),\n",
        "            Transform(out_comps[sol_index], new_out_comp),\n",
        "            FadeOut(out_Vs[sol_index], scale=0.25),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(solution_label),\n",
        "            GrowArrow(solution_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Parallelization\n",
        "        lines = VGroup(\n",
        "            Line(basis_kets[n].get_right(), out_comps[n].get_left(), buff=SMALL_BUFF)\n",
        "            for n in range(7)\n",
        "        )\n",
        "\n",
        "        new_machines = VGroup(machine.copy().scale(0.25).move_to(line) for line in lines)\n",
        "\n",
        "        pre_machine = VGroup(machine.copy())\n",
        "        self.remove(machine)\n",
        "        self.add(lines, Point(), pre_machine)\n",
        "        self.play(\n",
        "            Transform(pre_machine, new_machines),\n",
        "            LaggedStartMap(ShowCreation, lines)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(pre_machine),\n",
        "            FadeIn(machine),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Column vector\n",
        "        in_col = TexMatrix(np.array([\"x_0\", \"x_1\", R\"\\vdots\", \"x_k\", R\"\\vdots\", R\"x_{n-2}\", R\"x_{n-1}\"]).reshape(-1, 1))\n",
        "        out_col = TexMatrix(np.array([\"x_0\", \"x_1\", R\"\\vdots\", \"-x_k\", R\"\\vdots\", R\"x_{n-2}\", R\"x_{n-1}\"]).reshape(-1, 1))\n",
        "\n",
        "        for col, vect in zip([in_col, out_col], [LEFT, RIGHT]):\n",
        "            col.match_height(basis_kets)\n",
        "            col.next_to(machine, vect)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(solution_label),\n",
        "            FadeOut(solution_arrow),\n",
        "            FadeOut(basis_kets),\n",
        "            FadeOut(out_kets),\n",
        "            out_rect.animate.surround(out_col.get_entries()[3]).set_stroke(width=1),\n",
        "            FadeOut(flip_word),\n",
        "            ReplacementTransform(components, in_col.get_entries()),\n",
        "            ReplacementTransform(out_comps, out_col.get_entries()),\n",
        "            Write(in_col.get_brackets()),\n",
        "            Write(out_col.get_brackets()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OverOrUnderExplain(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"shruggie\"),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"pondering\", look_at=self.screen),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(\n",
        "            stds[2].change(\"erm\", look_at=morty.eyes),\n",
        "            morty.change(\"hesitant\", look_at=self.students),\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            self.change_students(\"hesitant\", \"well\", \"confused\", look_at=3 * UR)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class IsThisUseful(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"hesitant\", self.screen),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"pondering\", look_at=self.screen)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            stds[1].says(\"Is this...useful?\", mode=\"confused\"),\n",
        "            stds[0].change(\"hesitant\", look_at=stds[1].eyes),\n",
        "            stds[2].change(\"well\", look_at=stds[1].eyes),\n",
        "            morty.change(\"guilty\", look_at=stds[1].eyes),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SudokuBruteForce(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        words = Text(\"Comically inefficient\\nbrute force approach:\")\n",
        "        steps = TexText(\"$9^{60}$ Steps\", isolate=[\"60\"])\n",
        "        steps.scale(1.5)\n",
        "        group = VGroup(words, steps)\n",
        "        group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        brace = Brace(steps[:3], DOWN)\n",
        "        number = Tex(\"{:,d}\".format(9**60).replace(\",\", \"{,}\"))\n",
        "        number.scale(0.75)\n",
        "        number.set_color(RED)\n",
        "        number.next_to(brace, DOWN).shift_onto_screen()\n",
        "\n",
        "        self.add(group)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(number, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show Grover\n",
        "        grover_words = TexText(\"Using Grover's Algorithm:\")\n",
        "        grover_words.move_to(words, RIGHT)\n",
        "        grover_steps = TexText(R\"$\\displaystyle \\left\\lceil\\frac{\\pi}{4} 9^{30}\\right\\rceil$ Steps\", isolate=[\"30\"])\n",
        "        grover_steps.move_to(steps, LEFT)\n",
        "        new_brace = Brace(grover_steps[:8], DOWN)\n",
        "        new_number = Tex(\"{:,d}\".format(int(np.ceil(9**30 * PI / 4))).replace(\",\", \"{,}\"))\n",
        "        new_number.scale(0.75)\n",
        "        new_number.set_color(RED)\n",
        "        new_number.next_to(new_brace, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransformPieces(words, grover_words),\n",
        "            FadeTransform(steps, grover_steps),\n",
        "            Transform(brace, new_brace),\n",
        "            FadeTransformPieces(number, new_number),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShaInversionCounts(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        classical = VGroup(\n",
        "            get_classical_computer_symbol(height=1),\n",
        "            TexText(\"$2^{256}$ Steps\"),\n",
        "        )\n",
        "        quantum = VGroup(\n",
        "            get_quantum_computer_symbol(height=1),\n",
        "            TexText(R\"$\\displaystyle \\left\\lceil \\frac{\\pi}{4} 2^{128} \\right\\rceil$ Steps\"),\n",
        "        )\n",
        "        group = VGroup(classical, quantum)\n",
        "        for elem in group:\n",
        "            elem.arrange(RIGHT)\n",
        "        group.arrange(DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        group.to_corner(UR)\n",
        "\n",
        "        self.play(FadeIn(classical, UP))\n",
        "        self.wait()\n",
        "        self.play(FadeTransformPieces(classical.copy(), quantum, lag_ratio=1e-4))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SkepticalPiCreature(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        randy = Randolph().to_edge(DOWN).shift(3 * LEFT)\n",
        "        randy.body.set_color(MAROON_E)\n",
        "        morty = Mortimer().to_edge(DOWN).shift(3 * RIGHT)\n",
        "        morty.make_eye_contact(randy)\n",
        "        for pi in [randy, morty]:\n",
        "            pi.change_mode(\"tease\")\n",
        "            pi.body.insert_n_curves(100)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            randy.says(\"Quantum Computing will\\nchange everything!\", mode=\"surprised\"),\n",
        "            morty.change(\"hesitant\")\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.add(Point())\n",
        "        self.play(\n",
        "            morty.says(\"...will it?\", mode=\"sassy\"),\n",
        "            randy.change(\"guilty\"),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FactoringNumbers(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show factoring number\n",
        "        factor_values = [314159265359, 1618033988749]\n",
        "        icon = get_quantum_computer_symbol(height=2).move_to(RIGHT)\n",
        "        factors = VGroup(Integer(value) for value in factor_values)\n",
        "        factors.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        product_value = int(factor_values[0] * factor_values[1])\n",
        "        product = Tex(\"{:,d}\".format(product_value).replace(\",\", \"{,}\"))\n",
        "        product.next_to(icon, LEFT)\n",
        "\n",
        "        product.set_color(TEAL)\n",
        "        factors.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "\n",
        "        times = Tex(R\"\\times\")\n",
        "        times.move_to(factors)\n",
        "\n",
        "        factor_group = VGroup(factors[0], times, factors[1])\n",
        "        factor_group.arrange(DOWN, SMALL_BUFF)\n",
        "        factor_group.next_to(icon, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(icon)\n",
        "        self.play(FadeIn(product, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeOutToPoint(product.copy(), icon.get_center(), lag_ratio=0.02, path_arc=45 * DEG),\n",
        "            FadeInFromPoint(factor_group, icon.get_center(), lag_ratio=0.02, path_arc=45 * DEG),\n",
        "            lag_ratio=0.3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FourBitAdder(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        circuit = SVGMobject(\"Four_bit_adder_with_carry_lookahead\")\n",
        "        circuit.set_height(7.0)\n",
        "        circuit.set_stroke(WHITE, 1)\n",
        "        circuit.set_fill(BLACK, 0)\n",
        "        circuit.sort(lambda p: np.dot(p, DR))\n",
        "\n",
        "        self.play(Write(circuit, lag_ratio=1e-2, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PatronScroll(PatreonEndScreen):\n",
        "    pass\n"
    ]
}