{
    "topic": "The mathematical concept being demonstrated is the construction of a Pascal's triangle using a recursive function.",
    "code": [
        "\n",
        "from manim_imports_ext import *\n",
        "from once_useful_constructs.combinatorics import *\n",
        "\n",
        "nb_levels = 5\n",
        "\n",
        "dev_x_step = 2\n",
        "dev_y_step = 5\n",
        "\n",
        "GRADE_COLOR_1 = RED\n",
        "GRADE_COLOR_2 = BLUE\n",
        "\n",
        "\n",
        "\n",
        "def graded_square(n,k):\n",
        "    return Square(\n",
        "        side_length = 1, \n",
        "        fill_color = graded_color(n,k), \n",
        "        fill_opacity = 1, \n",
        "        stroke_width = 1\n",
        "    )\n",
        "\n",
        "def graded_binomial(n,k):\n",
        "    return Integer(\n",
        "        choose(n,k), \n",
        "        color = graded_color(n,k)\n",
        "    )\n",
        "\n",
        "def split_square(n,k):\n",
        "    width = 1\n",
        "    height = 1\n",
        "\n",
        "    proportion = float(choose(n,k)) / 2**n\n",
        "    \n",
        "    lower_height = proportion * height\n",
        "    upper_height = (1 - proportion) * height\n",
        "    lower_rect = Rectangle(\n",
        "        width = width,\n",
        "        height = lower_height,\n",
        "        fill_color = RED,\n",
        "        fill_opacity = 1.0,\n",
        "        stroke_color = WHITE,\n",
        "        stroke_width = 3\n",
        "    )\n",
        "    upper_rect = Rectangle(\n",
        "        width = width,\n",
        "        height = upper_height,\n",
        "        fill_color = BLUE,\n",
        "        fill_opacity = 1.0,\n",
        "        stroke_color = WHITE,\n",
        "        stroke_width = 3\n",
        "    )\n",
        "    upper_rect.next_to(lower_rect,UP,buff = 0)\n",
        "    square = VGroup(lower_rect, upper_rect).move_to(ORIGIN)\n",
        "    return square\n",
        "\n",
        "\n",
        "class BuildNewPascalRow(Transform):\n",
        "\n",
        "    def __init__(self,mobject, duplicate_row = None, **kwargs):\n",
        "        if mobject.__class__ != GeneralizedPascalsTriangle and mobject.__class__ != PascalsTriangle:\n",
        "            raise(\"Transform BuildNewPascalRow only works on members of (Generalized)PascalsTriangle!\")\n",
        "\n",
        "        n = mobject.nrows - 1\n",
        "        lowest_row_copy1 = mobject.get_lowest_row()\n",
        "        lowest_row_copy2 = duplicate_row\n",
        "\n",
        "        start_mob = VGroup(lowest_row_copy1, lowest_row_copy2)\n",
        "\n",
        "        new_pt = mobject.copy()\n",
        "        new_pt.nrows += 1\n",
        "        new_pt.init_points()\n",
        "        # align with original (copy got centered on screen)\n",
        "        c1 = new_pt.coords_to_mobs[0][0].get_center()\n",
        "        c2 = mobject.coords_to_mobs[0][0].get_center()\n",
        "        print(c1, c2)\n",
        "        v = c2 - c1\n",
        "        new_pt.shift(v)\n",
        "\n",
        "        new_row_left_copy = VGroup(*[\n",
        "            new_pt.coords_to_mobs[n+1][k]\n",
        "            for k in range(0,n+1)\n",
        "        ])\n",
        "\n",
        "        new_row_right_copy = VGroup(*[\n",
        "            new_pt.coords_to_mobs[n+1][k]\n",
        "            for k in range(1,n+2)\n",
        "        ]).copy()\n",
        "\n",
        "        target_mob = VGroup(new_row_left_copy, new_row_right_copy)\n",
        "\n",
        "        Transform.__init__(self, start_mob, target_mob, **kwargs)\n",
        "\n",
        "        \n",
        "\n",
        "\n",
        "\n",
        "class SimplePascal(Scene):\n",
        "\n",
        "    def build_new_pascal_row(self,old_pt):\n",
        "\n",
        "        lowest_row_copy = old_pt.get_lowest_row().copy()\n",
        "        self.add(lowest_row_copy)\n",
        "\n",
        "        n = old_pt.nrows - 1\n",
        "        lowest_row_copy1 = old_pt.get_lowest_row()\n",
        "        lowest_row_copy2 = lowest_row_copy1.copy()\n",
        "\n",
        "\n",
        "        start_mob = VGroup(lowest_row_copy1, lowest_row_copy2)\n",
        "        self.add(start_mob)\n",
        "\n",
        "        new_pt = old_pt.copy()\n",
        "        cell_height = old_pt.height / old_pt.nrows\n",
        "        cell_width = old_pt.width / old_pt.nrows\n",
        "        new_pt.nrows += 1\n",
        "        new_pt.height = new_pt.nrows * cell_height\n",
        "        new_pt.width = new_pt.nrows * cell_width\n",
        "\n",
        "        new_pt.init_points()\n",
        "        # align with original (copy got centered on screen)\n",
        "        c1 = new_pt.coords_to_mobs[0][0].get_center()\n",
        "        c2 = old_pt.coords_to_mobs[0][0].get_center()\n",
        "        v = c2 - c1\n",
        "        new_pt.shift(v)\n",
        "\n",
        "        new_row_left_copy = VGroup(*[\n",
        "            new_pt.coords_to_mobs[n+1][k]\n",
        "            for k in range(0,n+1)\n",
        "        ])\n",
        "\n",
        "        new_row_right_copy = VGroup(*[\n",
        "            new_pt.coords_to_mobs[n+1][k]\n",
        "            for k in range(1,n+2)\n",
        "        ]).copy()\n",
        "\n",
        "        target_mob = VGroup(new_row_left_copy, new_row_right_copy)\n",
        "        self.play(Transform(start_mob, target_mob))\n",
        "\n",
        "        return new_pt\n",
        "\n",
        "\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        cell_height = 1\n",
        "        cell_width = 1\n",
        "        nrows = 1\n",
        "        pt = GeneralizedPascalsTriangle(\n",
        "            nrows = nrows, \n",
        "            height = nrows * cell_height, \n",
        "            width = nrows * cell_width, \n",
        "            submob_class = graded_square,\n",
        "            portion_to_fill = 0.9\n",
        "        )\n",
        "        pt.shift(3 * UP)\n",
        "        self.add(pt)\n",
        "        lowest_row_copy = pt.get_lowest_row().copy()\n",
        "        self.add(lowest_row_copy)\n",
        "        #self.play(BuildNewPascalRow(pt, duplicate_row = lowest_row_copy))\n",
        "        for i in range(7):\n",
        "            pt = self.build_new_pascal_row(pt)\n",
        "        \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class PascalNetScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        unit_width = 0.25\n",
        "        top_height = 4.0\n",
        "        level_height = 2.0 * top_height / nb_levels\n",
        "\n",
        "        start_points = np.array([top_height * UP])\n",
        "\n",
        "        dev_start = start_points[0]\n",
        "\n",
        "        j = 0\n",
        "\n",
        "        for n in range(nb_levels):\n",
        "\n",
        "            half_width = 0.5 * (n + 0.5) * unit_width\n",
        "\n",
        "            stop_points_left = start_points.copy()\n",
        "            stop_points_left[:,0] -= 0.5 * unit_width\n",
        "            stop_points_left[:,1] -= level_height\n",
        "\n",
        "            stop_points_right = start_points.copy()\n",
        "            stop_points_right[:,0] += 0.5 * unit_width\n",
        "            stop_points_right[:,1] -= level_height\n",
        "            \n",
        "            for (p,q) in zip(start_points,stop_points_left):\n",
        "                alpha = np.abs((p[0]+q[0])/2) / half_width\n",
        "                color = rainbow_color(alpha)\n",
        "                line = Line(p,q, stroke_color = color)\n",
        "                self.add(line)\n",
        "\n",
        "            for (i,(p,q)) in enumerate(zip(start_points,stop_points_right)):\n",
        "                alpha = np.abs((p[0]+q[0])/2) / half_width\n",
        "                color = rainbow_color(alpha)\n",
        "                line = Line(p,q, stroke_color = color)\n",
        "                self.add(line)\n",
        "\n",
        "            if (n + 1) % dev_y_step == 0 and n != 1:\n",
        "                j += dev_x_step\n",
        "                dev_stop = stop_points_left[j]\n",
        "                line = Line(dev_start,dev_stop,stroke_color = WHITE)\n",
        "                self.add(line)\n",
        "                dot = Dot(dev_stop, fill_color = WHITE)\n",
        "                self.add_foreground_mobject(dot)\n",
        "                dev_start = dev_stop\n",
        "\n",
        "            start_points = np.append(stop_points_left,[stop_points_right[-1]], axis = 0)\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class RescaledPascalNetScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        half_width = 3.0\n",
        "        top_height = 4.0\n",
        "        level_height = 2.0 * top_height / nb_levels\n",
        "\n",
        "        start_points = np.array([top_height * UP])\n",
        "        left_edge = top_height * UP + half_width * LEFT\n",
        "        right_edge = top_height * UP + half_width * RIGHT\n",
        "\n",
        "        dev_start = start_points[0]\n",
        "\n",
        "        j = 0\n",
        "\n",
        "        for n in range(nb_levels):\n",
        "\n",
        "            if n == 0:\n",
        "                start_points_left_shift = np.array([left_edge])\n",
        "            else:\n",
        "                start_points_left_shift = start_points[:-1]\n",
        "                start_points_left_shift = np.insert(start_points_left_shift,0,left_edge, axis = 0)\n",
        "            stop_points_left = 0.5 * (start_points + start_points_left_shift)\n",
        "            stop_points_left += level_height * DOWN\n",
        "\n",
        "            \n",
        "            if n == 0:\n",
        "                start_points_right_shift = np.array([right_edge])\n",
        "            else:\n",
        "                start_points_right_shift = start_points[1:]\n",
        "                start_points_right_shift = np.append(start_points_right_shift,np.array([right_edge]), axis = 0)\n",
        "            stop_points_right = 0.5 * (start_points + start_points_right_shift)\n",
        "            stop_points_right += level_height * DOWN\n",
        "\n",
        "            \n",
        "            for (i,(p,q)) in enumerate(zip(start_points,stop_points_left)):\n",
        "                \n",
        "                color = GREY_B \n",
        "\n",
        "                if n % 2 == 0 and i <= n/2:\n",
        "                    m = n/2 + 0.25\n",
        "                    jj = i\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 0 and i > n/2:\n",
        "                    m = n/2 + 0.25\n",
        "                    jj = n - i + 0.5\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 1 and i <= n/2:\n",
        "                    m = n/2 + 0.75\n",
        "                    jj = i\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 1 and i > n/2:\n",
        "                    m = n/2 + 0.75\n",
        "                    jj = n - i + 0.5\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                line = Line(p,q, stroke_color = color)\n",
        "                self.add(line)\n",
        "\n",
        "            for (i,(p,q)) in enumerate(zip(start_points,stop_points_right)):\n",
        "                \n",
        "                color = GREY_B\n",
        "\n",
        "                if n % 2 == 0 and i < n/2:\n",
        "                    m = n/2 + 0.25\n",
        "                    jj = i + 0.5\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 0 and i >= n/2:\n",
        "                    m = n/2 + 0.25\n",
        "                    jj = n - i\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 1 and i <= n/2:\n",
        "                    m = n/2 + 0.75\n",
        "                    jj = i + 0.5\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "                elif n % 2 == 1 and i > n/2:\n",
        "                    m = n/2 + 0.75\n",
        "                    jj = n - i\n",
        "                    alpha = 1 - float(jj)/m\n",
        "                    color = rainbow_color(alpha)\n",
        "\n",
        "\n",
        "                line = Line(p,q, stroke_color = color)\n",
        "                self.add(line)\n",
        "\n",
        "            if (n + 1) % dev_y_step == 0 and n != 1:\n",
        "                j += dev_x_step\n",
        "                dev_stop = stop_points_left[j]\n",
        "                line = Line(dev_start,dev_stop,stroke_color = WHITE)\n",
        "                self.add(line)\n",
        "                dot = Dot(dev_stop, fill_color = WHITE)\n",
        "                self.add_foreground_mobject(dot)\n",
        "                dev_start = dev_stop\n",
        "\n",
        "\n",
        "\n",
        "            start_points = np.append(stop_points_left,[stop_points_right[-1]], axis = 0)\n",
        "            \n",
        "            left_edge += level_height * DOWN\n",
        "            right_edge += level_height * DOWN\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}