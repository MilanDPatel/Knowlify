{
    "topic": "The mathematical concept being demonstrated in this code is the construction of a lattice point on a complex plane,",
    "code": [
        "from manim_imports_ext import *\n",
        "from functools import reduce\n",
        "\n",
        "# revert_to_original_skipping_status\n",
        "\n",
        "def chi_func(n):\n",
        "    if n%2 == 0:\n",
        "        return 0\n",
        "    if n%4 == 1:\n",
        "        return 1\n",
        "    else:\n",
        "        return -1\n",
        "\n",
        "class LatticePointScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 6,\n",
        "        \"x_radius\" : None,\n",
        "        \"plane_center\" : ORIGIN,\n",
        "        \"max_lattice_point_radius\" : 6,\n",
        "        \"dot_radius\" : 0.075,\n",
        "        \"secondary_line_ratio\" : 0,\n",
        "        \"plane_color\" : BLUE_E,\n",
        "        \"dot_color\" : YELLOW,\n",
        "        \"dot_drawing_stroke_color\" : PINK,\n",
        "        \"circle_color\" : MAROON_D,\n",
        "        \"radial_line_color\" : RED,\n",
        "    }\n",
        "    def setup(self):\n",
        "        if self.x_radius is None:\n",
        "            self.x_radius = self.y_radius*FRAME_X_RADIUS/FRAME_Y_RADIUS\n",
        "        plane = ComplexPlane(\n",
        "            y_radius = self.y_radius,\n",
        "            x_radius = self.x_radius,\n",
        "            secondary_line_ratio = self.secondary_line_ratio,\n",
        "            radius = self.plane_color\n",
        "        )\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        plane.shift(self.plane_center)\n",
        "        self.add(plane)\n",
        "        self.plane = plane\n",
        "\n",
        "        self.setup_lattice_points()\n",
        "\n",
        "    def setup_lattice_points(self):\n",
        "        M = self.max_lattice_point_radius\n",
        "        int_range = list(range(-M, M+1))\n",
        "        self.lattice_points = VGroup()\n",
        "        for x, y in it.product(*[int_range]*2):\n",
        "            r_squared = x**2 + y**2\n",
        "            if r_squared > M**2:\n",
        "                continue\n",
        "            dot = Dot(\n",
        "                self.plane.coords_to_point(x, y),\n",
        "                color = self.dot_color,\n",
        "                radius = self.dot_radius,\n",
        "            )\n",
        "            dot.r_squared = r_squared\n",
        "            self.lattice_points.add(dot)\n",
        "        self.lattice_points.sort(\n",
        "            lambda p : get_norm(p - self.plane_center)\n",
        "        )\n",
        "\n",
        "    def get_circle(self, radius = None, color = None):\n",
        "        if radius is None:\n",
        "            radius = self.max_lattice_point_radius\n",
        "        if color is None:\n",
        "            color = self.circle_color\n",
        "        radius *= self.plane.get_space_unit_to_y_unit()\n",
        "        circle = Circle(\n",
        "            color = color,\n",
        "            radius = radius,\n",
        "        )\n",
        "        circle.move_to(self.plane.get_center())\n",
        "        return circle\n",
        "\n",
        "    def get_radial_line_with_label(self, radius = None, color = None):\n",
        "        if radius is None:\n",
        "            radius = self.max_lattice_point_radius\n",
        "        if color is None:\n",
        "            color = self.radial_line_color\n",
        "        radial_line = Line(\n",
        "            self.plane_center,\n",
        "            self.plane.coords_to_point(radius, 0),\n",
        "            color = color\n",
        "        )\n",
        "        r_squared = int(np.round(radius**2))\n",
        "        root_label = OldTex(\"\\\\sqrt{%d}\"%r_squared)\n",
        "        root_label.add_background_rectangle()\n",
        "        root_label.next_to(radial_line, UP, SMALL_BUFF)\n",
        "\n",
        "        return radial_line, root_label\n",
        "\n",
        "    def get_lattice_points_on_r_squared_circle(self, r_squared):\n",
        "        points = VGroup(*[dot for dot in self.lattice_points if dot.r_squared == r_squared])\n",
        "        points.sort(\n",
        "            lambda p : angle_of_vector(p-self.plane_center)%(2*np.pi)\n",
        "        )\n",
        "        return points\n",
        "\n",
        "    def draw_lattice_points(self, points = None, run_time = 4):\n",
        "        if points is None:\n",
        "            points = self.lattice_points\n",
        "        self.play(*[\n",
        "            DrawBorderThenFill(\n",
        "                dot,\n",
        "                stroke_width = 4,\n",
        "                stroke_color = self.dot_drawing_stroke_color,\n",
        "                run_time = run_time,\n",
        "                rate_func = squish_rate_func(\n",
        "                    double_smooth, a, a + 0.25\n",
        "                ),\n",
        "            )\n",
        "            for dot, a in zip(\n",
        "                points, \n",
        "                np.linspace(0, 0.75, len(points))\n",
        "            )\n",
        "        ])\n",
        "\n",
        "    def add_axis_labels(self, spacing = 2):\n",
        "        x_max = int(self.plane.point_to_coords(FRAME_X_RADIUS*RIGHT)[0])\n",
        "        y_max = int(self.plane.point_to_coords(FRAME_Y_RADIUS*UP)[1])\n",
        "        x_range = list(range(spacing, x_max, spacing))\n",
        "        y_range = list(range(spacing, y_max, spacing))\n",
        "        for r in x_range, y_range:\n",
        "            r += [-n for n in r]\n",
        "        tick = Line(ORIGIN, MED_SMALL_BUFF*UP)\n",
        "        x_ticks = VGroup(*[\n",
        "            tick.copy().move_to(self.plane.coords_to_point(x, 0))\n",
        "            for x in x_range\n",
        "        ])\n",
        "        tick.rotate(-np.pi/2)\n",
        "        y_ticks = VGroup(*[\n",
        "            tick.copy().move_to(self.plane.coords_to_point(0, y))\n",
        "            for y in y_range\n",
        "        ])\n",
        "        x_labels = VGroup(*[\n",
        "            OldTex(str(x))\n",
        "            for x in x_range\n",
        "        ])\n",
        "        y_labels = VGroup(*[\n",
        "            OldTex(str(y) + \"i\")\n",
        "            for y in y_range\n",
        "        ])\n",
        "\n",
        "        for labels, ticks in (x_labels, x_ticks), (y_labels, y_ticks):\n",
        "            labels.scale(0.6)\n",
        "            for tex_mob, tick in zip(labels, ticks):\n",
        "                tex_mob.add_background_rectangle()\n",
        "                tex_mob.next_to(\n",
        "                    tick,\n",
        "                    tick.get_start() - tick.get_end(),\n",
        "                    SMALL_BUFF\n",
        "                )\n",
        "        self.add(x_ticks, y_ticks, x_labels, y_labels)\n",
        "        digest_locals(self, [\n",
        "            \"x_ticks\", \"y_ticks\",\n",
        "            \"x_labels\", \"y_labels\",\n",
        "        ])\n",
        "\n",
        "    def point_to_int_coords(self, point):\n",
        "        x, y = self.plane.point_to_coords(point)[:2]\n",
        "        return (int(np.round(x)), int(np.round(y)))\n",
        "\n",
        "    def dot_to_int_coords(self, dot):\n",
        "        return self.point_to_int_coords(dot.get_center())\n",
        "\n",
        "\n",
        "######\n",
        "\n",
        "class Introduction(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.introduce_three_objects()\n",
        "        self.show_screen()\n",
        "\n",
        "    def introduce_three_objects(self):\n",
        "        primes = self.get_primes()\n",
        "        primes.to_corner(UP+RIGHT)\n",
        "        primes.shift(DOWN)\n",
        "        plane = self.get_complex_numbers()\n",
        "        plane.shift(2*LEFT)\n",
        "        pi_group = self.get_pi_group()\n",
        "        pi_group.next_to(primes, DOWN, buff = MED_LARGE_BUFF)\n",
        "        pi_group.shift_onto_screen()\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        video = VideoIcon()\n",
        "        video.set_color(TEAL)\n",
        "        video.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            DrawBorderThenFill(video)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(primes, run_time = 2),\n",
        "            morty.change_mode, \"happy\",\n",
        "            video.set_height, FRAME_WIDTH,\n",
        "            video.center,\n",
        "            video.set_fill, None, 0\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(plane, run_time = 2),\n",
        "            morty.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(morty)\n",
        "        morty = morty.copy()\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                morty.body,\n",
        "                pi_group.get_part_by_tex(\"pi\"),\n",
        "                run_time = 1\n",
        "            ),\n",
        "            FadeOut(VGroup(morty.eyes, morty.mouth)),\n",
        "            Write(VGroup(*pi_group[1:]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            plane.set_width, pi_group.get_width(),\n",
        "            plane.next_to, pi_group, DOWN, MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "    def show_screen(self):\n",
        "        screen = ScreenRectangle(height = 4.3)\n",
        "        screen.to_edge(LEFT)\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"From zeta video\"),\n",
        "            OldTexText(\"Coming up\")\n",
        "        )\n",
        "        for title in titles:\n",
        "            title.next_to(screen, UP)\n",
        "            title.set_color(YELLOW)\n",
        "        self.play(\n",
        "            ShowCreation(screen),\n",
        "            FadeIn(titles[0])\n",
        "        )\n",
        "        self.show_frame()\n",
        "        self.wait(2)\n",
        "        self.play(Transform(*titles))\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_primes(self):\n",
        "        return OldTex(\"2, 3, 5, 7, 11, 13, \\\\dots\")\n",
        "\n",
        "    def get_complex_numbers(self):\n",
        "        plane = ComplexPlane(\n",
        "            x_radius = 3,\n",
        "            y_radius = 2.5,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        point = plane.number_to_point(complex(1, 2))\n",
        "        dot = Dot(point, radius = YELLOW)\n",
        "        label = OldTex(\"1 + 2i\")\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, UP+RIGHT, buff = SMALL_BUFF)\n",
        "        label.set_color(YELLOW)\n",
        "        plane.label = label\n",
        "        plane.add(dot, label)\n",
        "        return plane\n",
        "\n",
        "    def get_pi_group(self):\n",
        "        result = OldTex(\"\\\\pi\", \"=\", \"%.8f\\\\dots\"%np.pi)\n",
        "        pi = result.get_part_by_tex(\"pi\")\n",
        "        pi.scale(2, about_point = pi.get_right())\n",
        "        pi.set_color(MAROON_B)\n",
        "        return result\n",
        "\n",
        "class ShowSum(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"num_terms_to_add\" : 40,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.say_words()\n",
        "        self.show_sum()\n",
        "\n",
        "    def say_words(self):\n",
        "        self.teacher_says(\"This won't be easy\")\n",
        "        self.play_student_changes(\n",
        "            \"hooray\", \"sassy\", \"angry\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_sum(self):\n",
        "        line = UnitInterval()\n",
        "        line.add_numbers(0, 1)\n",
        "        # line.shift(UP)\n",
        "        sum_point = line.number_to_point(np.pi/4)\n",
        "\n",
        "        numbers = [0] + [\n",
        "            ((-1)**n)/(2.0*n + 1) \n",
        "            for n in range(self.num_terms_to_add)\n",
        "        ]\n",
        "        partial_sums = np.cumsum(numbers)\n",
        "        points = list(map(line.number_to_point, partial_sums))\n",
        "        arrows = [\n",
        "            Arrow(\n",
        "                p1, p2, \n",
        "                tip_length = 0.2*min(1, get_norm(p1-p2)),\n",
        "                buff = 0\n",
        "            )\n",
        "            for p1, p2 in zip(points, points[1:])\n",
        "        ]\n",
        "        dot = Dot(points[0])\n",
        "\n",
        "        sum_mob = OldTex(\n",
        "            \"1\", \"-\\\\frac{1}{3}\", \n",
        "            \"+\\\\frac{1}{5}\", \"-\\\\frac{1}{7}\",\n",
        "            \"+\\\\frac{1}{9}\", \"-\\\\frac{1}{11}\",\n",
        "            \"+\\\\cdots\"\n",
        "        )\n",
        "        sum_mob.to_corner(UP+RIGHT)\n",
        "        lhs = OldTex(\n",
        "            \"\\\\frac{\\\\pi}{4}\", \"=\", \n",
        "        )\n",
        "        lhs.next_to(sum_mob, LEFT)\n",
        "        lhs.set_color_by_tex(\"pi\", YELLOW)\n",
        "        sum_arrow = Arrow(\n",
        "            lhs.get_part_by_tex(\"pi\").get_bottom(),\n",
        "            sum_point\n",
        "        )\n",
        "        fading_terms = [\n",
        "            OldTex(sign + \"\\\\frac{1}{%d}\"%(2*n + 1))\n",
        "            for n, sign in zip(\n",
        "                list(range(self.num_terms_to_add)),\n",
        "                it.cycle(\"+-\")\n",
        "            )\n",
        "        ]\n",
        "        for fading_term, arrow in zip(fading_terms, arrows):\n",
        "            fading_term.next_to(arrow, UP)\n",
        "\n",
        "        terms = it.chain(sum_mob, it.repeat(None))\n",
        "        last_arrows = it.chain([None], arrows)\n",
        "        last_fading_terms = it.chain([None], fading_terms)\n",
        "\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = line,\n",
        "            added_anims = [\n",
        "                FadeIn(VGroup(line, dot)),\n",
        "                FadeIn(lhs),\n",
        "                RemovePiCreatureBubble(\n",
        "                    self.teacher,\n",
        "                    target_mode = \"raise_right_hand\"\n",
        "                )\n",
        "            ]\n",
        "            \n",
        "        )\n",
        "        run_time = 1\n",
        "        for term, arrow, last_arrow, fading_term, last_fading_term in zip(\n",
        "            terms, arrows, last_arrows, fading_terms, last_fading_terms\n",
        "            ):\n",
        "            anims = []\n",
        "            if term:\n",
        "                anims.append(Write(term))\n",
        "            if last_arrow:\n",
        "                anims.append(FadeOut(last_arrow))\n",
        "            if last_fading_term:\n",
        "                anims.append(FadeOut(last_fading_term))\n",
        "            dot_movement = ApplyMethod(dot.move_to, arrow.get_end())\n",
        "            anims.append(ShowCreation(arrow))\n",
        "            anims.append(dot_movement)\n",
        "            anims.append(FadeIn(fading_term))\n",
        "            self.play(*anims, run_time = run_time)\n",
        "            if term:\n",
        "                self.wait()\n",
        "            else:\n",
        "                run_time *= 0.8\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(fading_term),\n",
        "            dot.move_to, sum_point\n",
        "        )\n",
        "        self.play(ShowCreation(sum_arrow))\n",
        "        self.wait()\n",
        "        self.play_student_changes(\"erm\", \"confused\", \"maybe\")\n",
        "        self.play(self.teacher.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class FermatsDreamExcerptWrapper(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"From ``Fermat's dream'' by Kato, Kurokawa and Saito\"\n",
        "        )\n",
        "        words.scale(0.8)\n",
        "        words.to_edge(UP)\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "\n",
        "class ShowCalculus(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        frac_sum = OldTex(\n",
        "            \"1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\",\n",
        "        )\n",
        "        int1 = OldTex(\n",
        "            \"= \\\\int_0^1 (1 - x^2 + x^4 - \\\\dots )\\\\,dx\"\n",
        "        )\n",
        "        int2 = OldTex(\n",
        "            \"= \\\\int_0^1 \\\\frac{1}{1+x^2}\\\\,dx\"\n",
        "        )\n",
        "        arctan = OldTex(\"= \\\\tan^{-1}(1)\")\n",
        "        pi_fourths = OldTex(\"= \\\\frac{\\\\pi}{4}\")\n",
        "\n",
        "        frac_sum.to_corner(UP+LEFT)\n",
        "        frac_sum.shift(RIGHT)\n",
        "        rhs_group = VGroup(int1, int2, arctan, pi_fourths)\n",
        "        rhs_group.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rhs_group.shift(\n",
        "            frac_sum.get_right() + MED_SMALL_BUFF*RIGHT \\\n",
        "            -int1[0].get_left()\n",
        "        )\n",
        "        \n",
        "        self.add(frac_sum)\n",
        "        modes = it.chain([\"plain\"], it.cycle([\"confused\"]))\n",
        "        for rhs, mode in zip(rhs_group, modes):\n",
        "            self.play(\n",
        "                FadeIn(rhs),\n",
        "                self.pi_creature.change, mode\n",
        "            )\n",
        "            self.wait()\n",
        "        self.change_mode(\"maybe\")\n",
        "        self.wait()\n",
        "        self.look_at(rhs_group[-1])\n",
        "        self.wait()\n",
        "        self.pi_creature_says(\n",
        "            \"Where's the \\\\\\\\ circle?\",\n",
        "            bubble_config = {\"width\" : 4, \"height\" : 3},\n",
        "            target_mode = \"maybe\"\n",
        "        )\n",
        "        self.look_at(rhs_group[0])\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n",
        "\n",
        "class CertainRegularityInPrimes(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 8,\n",
        "        \"x_radius\" : 20,\n",
        "        \"max_lattice_point_radius\" : 8,\n",
        "        \"plane_center\" : 2.5*RIGHT,\n",
        "        \"primes\" : [5, 13, 17, 29, 37, 41, 53],\n",
        "        \"include_pi_formula\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        if self.include_pi_formula:\n",
        "            self.add_pi_formula()\n",
        "        self.walk_through_primes()\n",
        "\n",
        "    def add_pi_formula(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{\\\\pi}{4}\", \"=\",\n",
        "            \"1\", \"-\", \"\\\\frac{1}{3}\",\n",
        "            \"+\", \"\\\\frac{1}{5}\", \"-\", \"\\\\frac{1}{7}\",\n",
        "            \"+\\\\cdots\"\n",
        "        )\n",
        "        formula.set_color_by_tex(\"pi\", YELLOW)\n",
        "        formula.add_background_rectangle()\n",
        "        formula.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        self.add_foreground_mobject(formula)\n",
        "\n",
        "    def walk_through_primes(self):\n",
        "        primes = self.primes\n",
        "        lines_and_labels = [\n",
        "            self.get_radial_line_with_label(np.sqrt(p))\n",
        "            for p in primes\n",
        "        ]\n",
        "        lines, labels = list(zip(*lines_and_labels))\n",
        "        circles = [\n",
        "            self.get_circle(np.sqrt(p))\n",
        "            for p in primes\n",
        "        ]\n",
        "        dots_list = [\n",
        "            self.get_lattice_points_on_r_squared_circle(p)\n",
        "            for p in primes\n",
        "        ]\n",
        "        groups = [\n",
        "            VGroup(*mobs)\n",
        "            for mobs in zip(lines, labels, circles, dots_list)\n",
        "        ]\n",
        "\n",
        "        curr_group = groups[0]\n",
        "        self.play(Write(curr_group, run_time = 2))\n",
        "        self.wait()\n",
        "        for group in groups[1:]:\n",
        "            self.play(Transform(curr_group, group))\n",
        "            self.wait(2)\n",
        "\n",
        "class Outline(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.generate_list()\n",
        "        self.wonder_at_pi()\n",
        "        self.count_lattice_points()\n",
        "        self.write_steps_2_and_3()\n",
        "        self.show_chi()\n",
        "        self.show_complicated_formula()\n",
        "        self.show_last_step()\n",
        "\n",
        "    def generate_list(self):\n",
        "        steps = VGroup(\n",
        "            OldTexText(\"1. Count lattice points\"),\n",
        "            OldTex(\"2. \\\\text{ Things like }17 = \", \"4\", \"^2 + \", \"1\", \"^2\"),\n",
        "            OldTex(\"3. \\\\text{ Things like }17 = (\", \"4\", \" + \", \"i\", \")(\", \"4\", \" - \", \"i\", \")\"),\n",
        "            OldTexText(\"4. Introduce $\\\\chi$\"),\n",
        "            OldTexText(\"5. Shift perspective\"),\n",
        "        )\n",
        "        for step in steps[1:3]:\n",
        "            step.set_color_by_tex(\"1\", RED, substring = False)\n",
        "            step.set_color_by_tex(\"i\", RED, substring = False)\n",
        "            step.set_color_by_tex(\"4\", GREEN, substring = False)\n",
        "        steps.arrange(\n",
        "            DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        steps.to_corner(UP+LEFT)\n",
        "\n",
        "        self.steps = steps\n",
        "\n",
        "    def wonder_at_pi(self):\n",
        "        question = OldTex(\"\\\\pi\", \"=???\")\n",
        "        pi = question.get_part_by_tex(\"pi\")\n",
        "        pi.scale(2, about_point = pi.get_right())\n",
        "        pi.set_color(YELLOW)\n",
        "        question.next_to(self.pi_creature.body, LEFT, aligned_edge = UP)\n",
        "        self.think(\n",
        "            \"Who am I really?\",\n",
        "            look_at = question,\n",
        "            added_anims = [\n",
        "                FadeIn(question)\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.pi_creature),\n",
        "            question.to_corner, UP+RIGHT\n",
        "        )\n",
        "\n",
        "        self.question = question\n",
        "        self.pi = question.get_part_by_tex(\"pi\")\n",
        "\n",
        "    def count_lattice_points(self):\n",
        "        step = self.steps[0]\n",
        "        plane = NumberPlane(\n",
        "            x_radius = 10, y_radius = 10,\n",
        "            secondary_line_ratio = 0,\n",
        "            color = BLUE_E,\n",
        "        )\n",
        "        plane.set_height(6)\n",
        "        plane.next_to(step, DOWN)\n",
        "        plane.to_edge(LEFT)\n",
        "        circle = Circle(\n",
        "            color = YELLOW,\n",
        "            radius = get_norm(\n",
        "                plane.coords_to_point(10, 0) - \\\n",
        "                plane.coords_to_point(0, 0)\n",
        "            )\n",
        "        )\n",
        "        plane_center = plane.coords_to_point(0, 0)\n",
        "        circle.move_to(plane_center)\n",
        "        lattice_points = VGroup(*[\n",
        "            Dot(\n",
        "                plane.coords_to_point(a, b), \n",
        "                radius = 0.05,\n",
        "                color = PINK,\n",
        "            )\n",
        "            for a in range(-10, 11)\n",
        "            for b in range(-10, 11)\n",
        "            if a**2 + b**2 <= 10**2\n",
        "        ])\n",
        "        lattice_points.sort(\n",
        "            lambda p : get_norm(p - plane_center)\n",
        "        )\n",
        "        lattice_group = VGroup(plane, circle, lattice_points)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(Write(plane, run_time = 2), Animation(circle))\n",
        "        self.play(\n",
        "            *[\n",
        "                DrawBorderThenFill(\n",
        "                    dot,\n",
        "                    stroke_width = 4,\n",
        "                    stroke_color = YELLOW,\n",
        "                    run_time = 4,\n",
        "                    rate_func = squish_rate_func(\n",
        "                        double_smooth, a, a + 0.25\n",
        "                    )\n",
        "                )\n",
        "                for dot, a in zip(\n",
        "                    lattice_points, \n",
        "                    np.linspace(0, 0.75, len(lattice_points))\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(step)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lattice_group.set_height, 2.5,\n",
        "            lattice_group.next_to, self.question, DOWN,\n",
        "            lattice_group.to_edge, RIGHT\n",
        "        )\n",
        "\n",
        "    def write_steps_2_and_3(self):\n",
        "        for step in self.steps[1:3]:\n",
        "            self.play(FadeIn(step))\n",
        "            self.wait(2)\n",
        "        self.wait()\n",
        "\n",
        "    def show_chi(self):\n",
        "        input_range = list(range(1, 7))\n",
        "        chis = VGroup(*[\n",
        "            OldTex(\"\\\\chi(%d)\"%n)\n",
        "            for n in input_range\n",
        "        ])\n",
        "        chis.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        chis.set_stroke(WHITE, width = 1)\n",
        "        numerators = VGroup()\n",
        "        arrows = VGroup()\n",
        "        for chi, n in zip(chis, input_range):\n",
        "            arrow = OldTex(\"\\\\Downarrow\")\n",
        "            arrow.next_to(chi, DOWN, SMALL_BUFF)\n",
        "            arrows.add(arrow)\n",
        "            value = OldTex(str(chi_func(n)))\n",
        "            value.set_color_by_tex(\"1\", BLUE)\n",
        "            value.set_color_by_tex(\"-1\", GREEN)\n",
        "            value.next_to(arrow, DOWN)\n",
        "            numerators.add(value)\n",
        "        group = VGroup(chis, arrows, numerators)\n",
        "        group.set_width(1.3*FRAME_X_RADIUS)\n",
        "        group.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(FadeIn(self.steps[3]))\n",
        "        self.play(*[\n",
        "            FadeIn(\n",
        "                mob, \n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "            for mob in [chis, arrows, numerators]\n",
        "        ])\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "\n",
        "        self.chis = chis\n",
        "        self.arrows = arrows\n",
        "        self.numerators = numerators\n",
        "\n",
        "    def show_complicated_formula(self):\n",
        "        rhs = OldTex(\n",
        "            \" = \\\\lim_{N \\\\to \\\\infty}\",\n",
        "            \" \\\\frac{4}{N}\",\n",
        "            \"\\\\sum_{n = 1}^N\",\n",
        "            \"\\\\sum_{d | n} \\\\chi(d)\",\n",
        "        )\n",
        "        pi = self.pi \n",
        "        self.add(pi.copy())\n",
        "        pi.generate_target()\n",
        "        pi.target.next_to(self.steps[3], RIGHT, MED_LARGE_BUFF)\n",
        "        pi.target.shift(MED_LARGE_BUFF*DOWN)\n",
        "        rhs.next_to(pi.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(pi),\n",
        "            Write(rhs)\n",
        "        )\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait(2)\n",
        "\n",
        "        self.complicated_formula = rhs\n",
        "\n",
        "    def show_last_step(self):\n",
        "        expression = OldTex(\n",
        "            \"=\", \"\\\\frac{\\\\quad}{1}\",\n",
        "            *it.chain(*[\n",
        "                [\"+\", \"\\\\frac{\\\\quad}{%d}\"%d]\n",
        "                for d in range(2, len(self.numerators)+1)\n",
        "            ] + [[\"+ \\\\cdots\"]])\n",
        "        )\n",
        "        over_four = OldTex(\"\\\\quad \\\\over 4\")\n",
        "        over_four.to_corner(DOWN+LEFT)\n",
        "        over_four.shift(UP)\n",
        "        pi = self.pi\n",
        "        pi.generate_target()\n",
        "        pi.target.scale(0.75)\n",
        "        pi.target.next_to(over_four, UP)\n",
        "        expression.next_to(over_four, RIGHT, align_using_submobjects = True)\n",
        "        self.numerators.generate_target()\n",
        "        for num, denom in zip(self.numerators.target, expression[1::2]):\n",
        "            num.scale(1.2)\n",
        "            num.next_to(denom, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(self.numerators),\n",
        "            MoveToTarget(pi),\n",
        "            Write(over_four),\n",
        "            FadeOut(self.chis),\n",
        "            FadeOut(self.arrows),\n",
        "            FadeOut(self.complicated_formula),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(expression),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    ########\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph(color = BLUE_C).flip().to_corner(DOWN+RIGHT)\n",
        "\n",
        "class CountLatticePoints(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 11,\n",
        "        \"max_lattice_point_radius\" : 10,\n",
        "        \"dot_radius\" : 0.05,\n",
        "        \"example_coords\" : (7, 5),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_lattice_point()\n",
        "        self.draw_lattice_points_in_circle()\n",
        "        self.turn_points_int_units_of_area()\n",
        "        self.write_pi_R_squared()\n",
        "        self.allude_to_alternate_counting_method()\n",
        "\n",
        "\n",
        "    def introduce_lattice_point(self):\n",
        "        x, y = self.example_coords\n",
        "        example_dot = Dot(\n",
        "            self.plane.coords_to_point(x, y),\n",
        "            color = self.dot_color,\n",
        "            radius = 1.5*self.dot_radius,\n",
        "        )\n",
        "        label = OldTex(str(self.example_coords))\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(example_dot, UP+RIGHT, buff = 0)\n",
        "        h_line = Line(\n",
        "            ORIGIN, self.plane.coords_to_point(x, 0),\n",
        "            color = GREEN\n",
        "        )\n",
        "        v_line = Line(\n",
        "            h_line.get_end(), self.plane.coords_to_point(x, y),\n",
        "            color = RED\n",
        "        )\n",
        "        lines = VGroup(h_line, v_line)\n",
        "\n",
        "        dots = self.lattice_points.copy()\n",
        "        random.shuffle(dots.submobjects)\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                dot.set_fill, None, 0,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(\n",
        "                    lambda t : 1 - there_and_back(t),\n",
        "                    a, a + 0.5\n",
        "                ),\n",
        "                remover = True\n",
        "            )\n",
        "            for dot, a in zip(dots, np.linspace(0, 0.5, len(dots)))\n",
        "        ])\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            ShowCreation(lines),\n",
        "            DrawBorderThenFill(example_dot),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [label, lines, example_dot])))\n",
        "\n",
        "    def draw_lattice_points_in_circle(self):\n",
        "        circle = self.get_circle()\n",
        "        radius = Line(ORIGIN, circle.get_right())\n",
        "        radius.set_color(RED)\n",
        "        brace = Brace(radius, DOWN, buff = SMALL_BUFF)\n",
        "        radius_label = brace.get_text(\n",
        "            str(self.max_lattice_point_radius),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        radius_label.add_background_rectangle()\n",
        "        brace.add(radius_label)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotating(radius, about_point = ORIGIN),\n",
        "            run_time = 2,\n",
        "            rate_func = smooth,\n",
        "        )\n",
        "        self.play(FadeIn(brace))\n",
        "        self.add_foreground_mobject(brace)\n",
        "        self.draw_lattice_points()\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, radius])))\n",
        "\n",
        "        self.circle = circle\n",
        "\n",
        "    def turn_points_int_units_of_area(self):\n",
        "        square = Square(fill_opacity = 0.9)\n",
        "        unit_line = Line(\n",
        "            self.plane.coords_to_point(0, 0),\n",
        "            self.plane.coords_to_point(1, 0),\n",
        "        )\n",
        "        square.set_width(unit_line.get_width())\n",
        "        squares = VGroup(*[\n",
        "            square.copy().move_to(point)\n",
        "            for point in self.lattice_points\n",
        "        ])\n",
        "        squares.set_color_by_gradient(BLUE_E, GREEN_E)\n",
        "        squares.set_stroke(WHITE, 1)\n",
        "        point_copies = self.lattice_points.copy()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                point_copies, squares,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            Animation(self.lattice_points)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(squares), Animation(self.lattice_points))\n",
        "\n",
        "    def write_pi_R_squared(self):\n",
        "        equations = VGroup(*[\n",
        "            VGroup(\n",
        "                OldTexText(\n",
        "                    \"\\\\# Lattice points\\\\\\\\\",\n",
        "                    \"within radius \", R,\n",
        "                    alignment = \"\"\n",
        "                ),\n",
        "                OldTex(\n",
        "                    \"\\\\approx \\\\pi\", \"(\", R, \")^2\"\n",
        "                )\n",
        "            ).arrange(RIGHT)\n",
        "            for R in (\"10\", \"1{,}000{,}000\", \"R\")\n",
        "        ])\n",
        "        radius_10_eq, radius_million_eq, radius_R_eq = equations\n",
        "        for eq in equations:\n",
        "            for tex_mob in eq:\n",
        "                tex_mob.set_color_by_tex(\"0\", BLUE)\n",
        "        radius_10_eq.to_corner(UP+LEFT)\n",
        "        radius_million_eq.next_to(radius_10_eq, DOWN, LARGE_BUFF)\n",
        "        radius_million_eq.to_edge(LEFT)\n",
        "        brace = Brace(radius_million_eq, DOWN)\n",
        "        brace.add(brace.get_text(\"More accurate\"))\n",
        "        brace.set_color(YELLOW)\n",
        "\n",
        "        background = FullScreenFadeRectangle(opacity = 0.9)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(background),\n",
        "            Write(radius_10_eq)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            radius_10_eq.copy(),\n",
        "            radius_million_eq\n",
        "        ))\n",
        "        self.play(FadeIn(brace))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.radius_10_eq = radius_10_eq\n",
        "        self.million_group = VGroup(radius_million_eq, brace)\n",
        "        self.radius_R_eq = radius_R_eq\n",
        "\n",
        "    def allude_to_alternate_counting_method(self):\n",
        "        alt_count = OldTexText(\n",
        "            \"(...something else...)\", \"$R^2$\", \"=\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        alt_count.to_corner(UP+LEFT)\n",
        "        alt_count.set_color_by_tex(\"something\", MAROON_B)\n",
        "        self.radius_R_eq.next_to(alt_count, RIGHT)\n",
        "\n",
        "        final_group = VGroup(\n",
        "            alt_count.get_part_by_tex(\"something\"),\n",
        "            self.radius_R_eq[1].get_part_by_tex(\"pi\"),\n",
        "        ).copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.million_group),\n",
        "            Write(alt_count),\n",
        "            ReplacementTransform(\n",
        "                self.radius_10_eq,\n",
        "                self.radius_R_eq\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            final_group.arrange, RIGHT,\n",
        "            final_group.next_to, ORIGIN, UP\n",
        "        )\n",
        "        rect = BackgroundRectangle(final_group)\n",
        "        self.play(FadeIn(rect), Animation(final_group))\n",
        "        self.wait(2)\n",
        "\n",
        "class SoYouPlay(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"So you play!\",\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"thinking\", \"hesitant\")\n",
        "        self.wait()\n",
        "        self.look_at(Dot().to_corner(UP+LEFT))\n",
        "        self.wait(3)\n",
        "\n",
        "class CountThroughRings(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"example_coords\" : (3, 2),\n",
        "        \"num_rings_to_show_explicitly\" : 7,\n",
        "        \"x_radius\" : 15,\n",
        "\n",
        "        \"plane_center\" : 2*RIGHT,\n",
        "        \"max_lattice_point_radius\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_lattice_points()\n",
        "        self.preview_rings()\n",
        "        self.isolate_single_ring()\n",
        "        self.show_specific_lattice_point_distance()\n",
        "        self.count_through_rings()\n",
        "\n",
        "    def add_lattice_points(self):\n",
        "        big_circle = self.get_circle()\n",
        "        self.add(big_circle)\n",
        "        self.add(self.lattice_points)\n",
        "        self.big_circle = big_circle\n",
        "\n",
        "    def preview_rings(self):\n",
        "        radii = list(set([\n",
        "            np.sqrt(p.r_squared) for p in self.lattice_points\n",
        "        ]))\n",
        "        radii.sort()\n",
        "        circles = VGroup(*[\n",
        "            self.get_circle(radius = r)\n",
        "            for r in radii\n",
        "        ])\n",
        "        circles.set_stroke(width = 2)\n",
        "    \n",
        "        self.add_foreground_mobject(self.lattice_points)\n",
        "        self.play(FadeIn(circles))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            circles,\n",
        "            arg_creator = lambda m : (m.set_stroke, PINK, 4),\n",
        "            rate_func = there_and_back,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.remove_foreground_mobject(self.lattice_points)\n",
        "\n",
        "        digest_locals(self, [\"circles\", \"radii\"])\n",
        "\n",
        "    def isolate_single_ring(self):\n",
        "        x, y = self.example_coords\n",
        "        example_circle = self.circles[\n",
        "            self.radii.index(np.sqrt(x**2 + y**2))\n",
        "        ]\n",
        "        self.circles.remove(example_circle)\n",
        "        points_on_example_circle = self.get_lattice_points_on_r_squared_circle(\n",
        "            x**2 + y**2\n",
        "        ).copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.circles),\n",
        "            self.lattice_points.set_fill, GREY, 0.5,\n",
        "            Animation(points_on_example_circle)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        digest_locals(self, [\"points_on_example_circle\", \"example_circle\"])\n",
        "\n",
        "    def show_specific_lattice_point_distance(self):\n",
        "        x, y = self.example_coords\n",
        "        dot = Dot(\n",
        "            self.plane.coords_to_point(x, y),\n",
        "            color = self.dot_color,\n",
        "            radius = self.dot_radius\n",
        "        )\n",
        "        label = OldTex(\"(a, b)\")\n",
        "        num_label = OldTex(str(self.example_coords))\n",
        "        for mob in label, num_label:\n",
        "            mob.add_background_rectangle()\n",
        "            mob.next_to(dot, UP + RIGHT, SMALL_BUFF)\n",
        "        a, b = label[1][1].copy(), label[1][3].copy()\n",
        "\n",
        "        x_spot = self.plane.coords_to_point(x, 0)\n",
        "        radial_line = Line(self.plane_center, dot)\n",
        "        h_line = Line(self.plane_center, x_spot)\n",
        "        h_line.set_color(GREEN)\n",
        "        v_line = Line(x_spot, dot)\n",
        "        v_line.set_color(RED)\n",
        "\n",
        "        distance = OldTex(\"\\\\sqrt{a^2 + b^2}\")\n",
        "        distance_num = OldTex(\"\\\\sqrt{%d}\"%(x**2 + y**2))\n",
        "        for mob in distance, distance_num:\n",
        "            mob.scale(0.75)\n",
        "            mob.add_background_rectangle()\n",
        "            mob.next_to(radial_line.get_center(), UP, SMALL_BUFF)\n",
        "            mob.rotate(\n",
        "                radial_line.get_angle(),\n",
        "                about_point = mob.get_bottom()\n",
        "            )\n",
        "\n",
        "        self.play(Write(label))\n",
        "        self.play(\n",
        "            ApplyMethod(a.next_to, h_line, DOWN, SMALL_BUFF),\n",
        "            ApplyMethod(b.next_to, v_line, RIGHT, SMALL_BUFF),\n",
        "            ShowCreation(h_line),\n",
        "            ShowCreation(v_line),\n",
        "        )\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(Write(distance))\n",
        "        self.wait(2)\n",
        "\n",
        "        a_num, b_num = [\n",
        "            OldTex(str(coord))[0]\n",
        "            for coord in self.example_coords\n",
        "        ]\n",
        "        a_num.move_to(a, UP)\n",
        "        b_num.move_to(b, LEFT)\n",
        "        self.play(\n",
        "            Transform(label, num_label),\n",
        "            Transform(a, a_num),\n",
        "            Transform(b, b_num),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(distance, distance_num))\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.example_circle, self.points_on_example_circle,\n",
        "            distance, a, b,\n",
        "            radial_line, h_line, v_line,\n",
        "            label\n",
        "        ])))\n",
        "\n",
        "    def count_through_rings(self):\n",
        "        counts = [\n",
        "            len(self.get_lattice_points_on_r_squared_circle(N))\n",
        "            for N in range(self.max_lattice_point_radius**2 + 1)\n",
        "        ]\n",
        "        left_list = VGroup(*[\n",
        "            OldTex(\n",
        "                \"\\\\sqrt{%d} \\\\Rightarrow\"%n, str(count)\n",
        "            )\n",
        "            for n, count in zip(\n",
        "                list(range(self.num_rings_to_show_explicitly)),\n",
        "                counts\n",
        "            )\n",
        "        ])\n",
        "        left_counts = VGroup()\n",
        "        left_roots = VGroup()\n",
        "        for mob in left_list:\n",
        "            mob[1].set_color(YELLOW)\n",
        "            left_counts.add(VGroup(mob[1]))\n",
        "            mob.add_background_rectangle()\n",
        "            left_roots.add(VGroup(mob[0], mob[1][0]))\n",
        "\n",
        "        left_list.arrange(\n",
        "            DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        left_list.to_corner(UP + LEFT)\n",
        "\n",
        "        top_list = VGroup(*[\n",
        "            OldTex(\"%d, \"%count)\n",
        "            for count in counts\n",
        "        ])\n",
        "        top_list.set_color(YELLOW)\n",
        "        top_list.arrange(RIGHT, aligned_edge = DOWN)\n",
        "        top_list.set_width(FRAME_WIDTH - MED_LARGE_BUFF)\n",
        "        top_list.to_edge(UP, buff = SMALL_BUFF)\n",
        "        top_rect = BackgroundRectangle(top_list)\n",
        "\n",
        "        for r_squared, count_mob, root in zip(it.count(), left_counts, left_roots):\n",
        "            self.show_ring_count(\n",
        "                r_squared,\n",
        "                count_mob,\n",
        "                added_anims = [FadeIn(root)]\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(left_roots),\n",
        "            FadeIn(top_rect),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    lc, VGroup(tc),\n",
        "                    path_arc = np.pi/2\n",
        "                )\n",
        "                for lc, tc in zip(left_counts, top_list)\n",
        "            ]\n",
        "        )\n",
        "        for r_squared in range(len(left_counts), self.max_lattice_point_radius**2 + 1):\n",
        "            self.show_ring_count(\n",
        "                r_squared, top_list[r_squared],\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    def show_ring_count(\n",
        "        self, radius_squared, target,\n",
        "        added_anims = None,        \n",
        "        run_time = 1\n",
        "        ):\n",
        "        added_anims = added_anims or []\n",
        "        radius = np.sqrt(radius_squared)\n",
        "        points = self.get_lattice_points_on_r_squared_circle(radius_squared)\n",
        "        points.save_state()\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line = Line(\n",
        "            self.plane_center, self.plane.coords_to_point(radius, 0),\n",
        "            color = RED\n",
        "        )\n",
        "        root = OldTex(\"\\\\sqrt{%d}\"%radius_squared)\n",
        "        root.add_background_rectangle()\n",
        "        root.set_width(\n",
        "            min(0.7*radial_line.get_width(), root.get_width())\n",
        "        )\n",
        "        root.next_to(radial_line, DOWN, SMALL_BUFF)\n",
        "        if not hasattr(self, \"little_circle\"):\n",
        "            self.little_circle = circle\n",
        "        if not hasattr(self, \"radial_line\"):\n",
        "            self.radial_line = radial_line\n",
        "        if not hasattr(self, \"root\"):\n",
        "            self.root = root\n",
        "        if hasattr(self, \"last_points\"):\n",
        "            added_anims += [self.last_points.restore]\n",
        "        self.last_points = points\n",
        "\n",
        "        if radius_squared == 0:\n",
        "            points.set_fill(YELLOW, 1)\n",
        "            self.play(\n",
        "                DrawBorderThenFill(points, stroke_color = PINK),\n",
        "                *added_anims,\n",
        "                run_time = run_time\n",
        "            )\n",
        "            self.play(ReplacementTransform(\n",
        "                points.copy(), target\n",
        "            ))\n",
        "            return\n",
        "        points.set_fill(YELLOW, 1)\n",
        "        self.play(\n",
        "            Transform(self.little_circle, circle),\n",
        "            Transform(self.radial_line, radial_line),\n",
        "            Transform(self.root, root),\n",
        "            DrawBorderThenFill(\n",
        "                points, \n",
        "                stroke_width = 4,\n",
        "                stroke_color = PINK,\n",
        "            ),\n",
        "            *added_anims,\n",
        "            run_time = run_time\n",
        "        )\n",
        "        self.wait(run_time)\n",
        "        if len(points) > 0:\n",
        "            mover = points.copy()  \n",
        "        else:\n",
        "            mover = VectorizedPoint(self.plane_center)\n",
        "        self.play(ReplacementTransform(mover, target, run_time = run_time))\n",
        "\n",
        "class LookAtExampleRing(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"dot_radius\" : 0.1,\n",
        "        \"plane_center\" : 2*LEFT,\n",
        "        \"x_radius\" : 17,\n",
        "        \"y_radius\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.analyze_25()\n",
        "        self.analyze_11()\n",
        "\n",
        "    def analyze_25(self):\n",
        "        x_color = GREEN\n",
        "        y_color = RED\n",
        "        circle = self.get_circle(radius = 5)\n",
        "        points = self.get_lattice_points_on_r_squared_circle(25)\n",
        "        radius, root_label = self.get_radial_line_with_label(5)\n",
        "        coords_list = [(5, 0), (4, 3), (3, 4), (0, 5), (-3, 4), (-4, 3)]\n",
        "        labels = [\n",
        "            OldTex(\"(\", str(x), \",\", str(y), \")\")\n",
        "            for x, y in coords_list\n",
        "        ]\n",
        "        for label in labels:\n",
        "            label.x = label[1]\n",
        "            label.y = label[3]\n",
        "            label.x.set_color(x_color)\n",
        "            label.y.set_color(y_color)\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "        for label, point in zip(labels, points):\n",
        "            x_coord = (point.get_center() - self.plane_center)[0]\n",
        "            vect = UP+RIGHT if x_coord >= 0 else UP+LEFT\n",
        "            label.next_to(point, vect, SMALL_BUFF)\n",
        "            label.point = point\n",
        "\n",
        "        def special_str(n):\n",
        "            return \"(%d)\"%n if n < 0 else str(n)\n",
        "\n",
        "        sums_of_squares = [\n",
        "            OldTex(\n",
        "                special_str(x), \"^2\", \"+\", \n",
        "                special_str(y), \"^2\", \"= 25\"\n",
        "            )\n",
        "            for x, y in coords_list\n",
        "        ]\n",
        "        for tex_mob in sums_of_squares:\n",
        "            tex_mob.x = tex_mob[0]\n",
        "            tex_mob.y = tex_mob[3]\n",
        "            tex_mob.x.set_color(x_color)\n",
        "            tex_mob.y.set_color(y_color)\n",
        "            tex_mob.add_background_rectangle()\n",
        "            tex_mob.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(radius),\n",
        "            Write(root_label)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotating(\n",
        "                radius, \n",
        "                about_point = self.plane_center,\n",
        "                rate_func = smooth, \n",
        "            ),\n",
        "            FadeIn(points, lag_ratio = 0.5),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        curr_label = labels[0]\n",
        "        curr_sum_of_squares = sums_of_squares[0]\n",
        "        self.play(\n",
        "            Write(curr_label),\n",
        "            curr_label.point.set_color, PINK\n",
        "        )\n",
        "        x, y = curr_label.x.copy(), curr_label.y.copy()\n",
        "        self.play(\n",
        "            Transform(x, curr_sum_of_squares.x),\n",
        "            Transform(y, curr_sum_of_squares.y),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(curr_sum_of_squares),\n",
        "            Animation(VGroup(x, y))\n",
        "        )\n",
        "        self.remove(x, y)\n",
        "        self.wait()\n",
        "\n",
        "        for label, sum_of_squares in zip(labels, sums_of_squares)[1:]:\n",
        "            self.play(\n",
        "                ReplacementTransform(curr_label, label),\n",
        "                label.point.set_color, PINK,\n",
        "                curr_label.point.set_color, self.dot_color\n",
        "            )\n",
        "            curr_label = label\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    curr_sum_of_squares, sum_of_squares\n",
        "                )\n",
        "            )\n",
        "            curr_sum_of_squares = sum_of_squares\n",
        "            self.wait()\n",
        "\n",
        "        points.save_state()\n",
        "        points.generate_target()\n",
        "        for i, point in enumerate(points.target):\n",
        "            point.move_to(\n",
        "                self.plane.coords_to_point(i%3, i//3)\n",
        "            )\n",
        "        points.target.next_to(circle, RIGHT)\n",
        "\n",
        "        self.play(MoveToTarget(\n",
        "            points, \n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(points.restore, run_time = 2)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            curr_label, curr_sum_of_squares, \n",
        "            circle, points,\n",
        "            radius, root_label\n",
        "        ])))\n",
        "\n",
        "    def analyze_11(self):\n",
        "        R = np.sqrt(11)\n",
        "        circle = self.get_circle(radius = R)\n",
        "        radius, root_label = self.get_radial_line_with_label(R)\n",
        "        equation = OldTex(\"11 \\\\ne \", \"a\", \"^2\", \"+\", \"b\", \"^2\")\n",
        "        equation.set_color_by_tex(\"a\", GREEN)\n",
        "        equation.set_color_by_tex(\"b\", RED)\n",
        "        equation.add_background_rectangle()\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(root_label),\n",
        "            ShowCreation(radius),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotating(\n",
        "                radius, \n",
        "                about_point = self.plane_center,\n",
        "                rate_func = smooth, \n",
        "            ),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(equation))\n",
        "        self.wait(3)\n",
        "\n",
        "class Given2DThinkComplex(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        tex = OldTexText(\"2D $\\\\Leftrightarrow$ Complex numbers\")\n",
        "        plane = ComplexPlane(\n",
        "            x_radius = 0.6*FRAME_X_RADIUS,\n",
        "            y_radius = 0.6*FRAME_Y_RADIUS,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        plane.set_height(FRAME_Y_RADIUS)\n",
        "        plane.to_corner(UP+LEFT)\n",
        "\n",
        "        self.teacher_says(tex)\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(plane),\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode = \"raise_right_hand\"\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"thinking\"]*3,\n",
        "            look_at = plane\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceComplexConjugate(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 20,\n",
        "        \"x_radius\" : 30,\n",
        "        \"plane_scale_factor\" : 1.7,\n",
        "        \"plane_center\" : 2*LEFT,\n",
        "        \"example_coords\" : (3, 4),\n",
        "        \"x_color\" : GREEN,\n",
        "        \"y_color\" : RED,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.resize_plane()\n",
        "        self.write_points_with_complex_coords()\n",
        "        self.introduce_complex_conjugate()\n",
        "        self.show_confusion()\n",
        "        self.expand_algebraically()\n",
        "        self.discuss_geometry()\n",
        "        self.show_geometrically()\n",
        "\n",
        "    def resize_plane(self):\n",
        "        self.plane.scale(\n",
        "            self.plane_scale_factor,\n",
        "            about_point = self.plane_center\n",
        "        )\n",
        "        self.plane.set_stroke(width = 1)\n",
        "        self.plane.axes.set_stroke(width = 3)\n",
        "\n",
        "    def write_points_with_complex_coords(self):\n",
        "        x, y = self.example_coords\n",
        "        x_color = self.x_color\n",
        "        y_color = self.y_color\n",
        "\n",
        "        point = self.plane.coords_to_point(x, y)\n",
        "        dot = Dot(point, color = self.dot_color)\n",
        "        x_point = self.plane.coords_to_point(x, 0)\n",
        "        h_arrow = Arrow(self.plane_center, x_point, buff = 0)\n",
        "        v_arrow = Arrow(x_point, point, buff = 0)\n",
        "        h_arrow.set_color(x_color)\n",
        "        v_arrow.set_color(y_color)\n",
        "        x_coord = OldTex(str(x))\n",
        "        x_coord.next_to(h_arrow, DOWN, SMALL_BUFF)\n",
        "        x_coord.set_color(x_color)\n",
        "        x_coord.add_background_rectangle()\n",
        "        y_coord = OldTex(str(y))\n",
        "        imag_y_coord = OldTex(str(y) + \"i\")\n",
        "        for coord in y_coord, imag_y_coord:\n",
        "            coord.next_to(v_arrow, RIGHT, SMALL_BUFF)\n",
        "            coord.set_color(y_color)\n",
        "            coord.add_background_rectangle()\n",
        "\n",
        "        tuple_label = OldTex(str((x, y)))\n",
        "        tuple_label[1].set_color(x_color)\n",
        "        tuple_label[3].set_color(y_color)\n",
        "        complex_label = OldTex(\"%d+%di\"%(x, y))\n",
        "        complex_label[0].set_color(x_color)\n",
        "        complex_label[2].set_color(y_color)\n",
        "        for label in tuple_label, complex_label:\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(dot, UP+RIGHT, buff = 0)\n",
        "\n",
        "        y_range = list(range(-9, 10, 3))\n",
        "        ticks = VGroup(*[\n",
        "            Line(\n",
        "                ORIGIN, MED_SMALL_BUFF*RIGHT\n",
        "            ).move_to(self.plane.coords_to_point(0, y))\n",
        "            for y in y_range\n",
        "        ])\n",
        "        imag_coords = VGroup()\n",
        "        for y, tick in zip(y_range, ticks):\n",
        "            if y == 0:\n",
        "                continue\n",
        "            if y == 1:\n",
        "                tex = \"i\"\n",
        "            elif y == -1:\n",
        "                tex = \"-i\"\n",
        "            else:\n",
        "                tex = \"%di\"%y\n",
        "            imag_coord = OldTex(tex)\n",
        "            imag_coord.scale(0.75)\n",
        "            imag_coord.add_background_rectangle()\n",
        "            imag_coord.next_to(tick, LEFT, SMALL_BUFF)\n",
        "            imag_coords.add(imag_coord)\n",
        "\n",
        "        self.add(dot)\n",
        "        self.play(\n",
        "            ShowCreation(h_arrow),\n",
        "            Write(x_coord)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(v_arrow),\n",
        "            Write(y_coord)\n",
        "        )\n",
        "        self.play(FadeIn(tuple_label))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [tuple_label, y_coord])))\n",
        "        self.play(*list(map(FadeIn, [complex_label, imag_y_coord])))\n",
        "        self.play(*list(map(Write, [imag_coords, ticks])))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            v_arrow, h_arrow, \n",
        "            x_coord, imag_y_coord,\n",
        "        ])))\n",
        "\n",
        "        self.complex_label = complex_label\n",
        "        self.example_dot = dot\n",
        "\n",
        "    def introduce_complex_conjugate(self):\n",
        "        x, y = self.example_coords\n",
        "        equation = VGroup(\n",
        "            OldTex(\"25 = \", str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"),\n",
        "            OldTex(\"(\", str(x), \"+\", str(y), \"i\", \")\"),\n",
        "            OldTex(\"(\", str(x), \"-\", str(y), \"i\", \")\"),\n",
        "        )\n",
        "        equation.arrange(\n",
        "            RIGHT, buff = SMALL_BUFF,\n",
        "        )\n",
        "        VGroup(*equation[-2:]).shift(0.5*SMALL_BUFF*DOWN)\n",
        "        equation.scale(0.9)\n",
        "        equation.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n",
        "        equation.shift(MED_LARGE_BUFF*DOWN)\n",
        "        for tex_mob in equation:\n",
        "            tex_mob.set_color_by_tex(str(x), self.x_color)\n",
        "            tex_mob.set_color_by_tex(str(y), self.y_color)\n",
        "            tex_mob.add_background_rectangle()\n",
        "\n",
        "        dot = Dot(\n",
        "            self.plane.coords_to_point(x, -y),\n",
        "            color = self.dot_color\n",
        "        )\n",
        "        label = OldTex(\"%d-%di\"%(x, y))\n",
        "        label[0].set_color(self.x_color)\n",
        "        label[2].set_color(self.y_color)\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, DOWN+RIGHT, buff = 0)\n",
        "\n",
        "        brace = Brace(equation[-1], DOWN)\n",
        "        conjugate_words = OldTexText(\"Complex \\\\\\\\ conjugate\")\n",
        "        conjugate_words.scale(0.8)\n",
        "        conjugate_words.add_background_rectangle()\n",
        "        conjugate_words.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            equation,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(conjugate_words, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(m1.copy(), m2)\n",
        "            for m1, m2 in [\n",
        "                (self.example_dot, dot),\n",
        "                (self.complex_label, label),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        self.conjugate_label = VGroup(brace, conjugate_words)\n",
        "        self.equation = equation\n",
        "        self.conjugate_dot = dot\n",
        "\n",
        "    def show_confusion(self):\n",
        "        randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n",
        "        morty = Mortimer().to_edge(DOWN)\n",
        "        randy.make_eye_contact(morty)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [randy, morty])))\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Wait \\\\dots why?\",\n",
        "            target_mode = \"confused\",\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                randy, target_mode = \"erm\",\n",
        "            ),\n",
        "            PiCreatureSays(\n",
        "                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n",
        "                target_mode = \"hooray\",\n",
        "                bubble_config = {\"width\" : 5, \"height\" : 3}\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            morty.look_at, self.equation,\n",
        "            randy.look_at, self.equation,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.play(RemovePiCreatureBubble(morty))\n",
        "        self.play(*list(map(FadeOut, [randy, morty])))\n",
        "\n",
        "    def expand_algebraically(self):\n",
        "        x, y = self.example_coords\n",
        "        expansion = VGroup(\n",
        "            OldTex(str(x), \"^2\"),\n",
        "            OldTex(\"-\", \"(\", str(y), \"i\", \")^2\")\n",
        "        )\n",
        "        expansion.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        expansion.next_to(\n",
        "            VGroup(*self.equation[-2:]), \n",
        "            DOWN, LARGE_BUFF\n",
        "        )\n",
        "        alt_y_term = OldTex(\"+\", str(y), \"^2\")\n",
        "        alt_y_term.move_to(expansion[1], LEFT)\n",
        "        for tex_mob in list(expansion) + [alt_y_term]:\n",
        "            tex_mob.set_color_by_tex(str(x), self.x_color)\n",
        "            tex_mob.set_color_by_tex(str(y), self.y_color)\n",
        "            tex_mob.rect = BackgroundRectangle(tex_mob)\n",
        "\n",
        "        x1 = self.equation[-2][1][1]\n",
        "        x2 = self.equation[-1][1][1]\n",
        "        y1 = VGroup(*self.equation[-2][1][3:5])\n",
        "        y2 = VGroup(*self.equation[-1][1][2:5])\n",
        "        vect = MED_LARGE_BUFF*UP\n",
        "\n",
        "        self.play(FadeOut(self.conjugate_label))\n",
        "        group = VGroup(x1, x2)\n",
        "        self.play(group.shift, -vect)\n",
        "        self.play(\n",
        "            FadeIn(expansion[0].rect),\n",
        "            ReplacementTransform(group.copy(), expansion[0]),\n",
        "        )\n",
        "        self.play(group.shift, vect)\n",
        "        group = VGroup(x1, y2)\n",
        "        self.play(group.shift, -vect)\n",
        "        self.wait()\n",
        "        self.play(group.shift, vect)\n",
        "        group = VGroup(x2, y1)\n",
        "        self.play(group.shift, -vect)\n",
        "        self.wait()\n",
        "        self.play(group.shift, vect)\n",
        "        group = VGroup(*it.chain(y1, y2))\n",
        "        self.play(group.shift, -vect)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(expansion[1].rect),\n",
        "            ReplacementTransform(group.copy(), expansion[1]),\n",
        "        )\n",
        "        self.play(group.shift, vect)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Transform(expansion[1].rect, alt_y_term.rect),\n",
        "            Transform(expansion[1], alt_y_term),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            expansion[0].rect,\n",
        "            expansion[1].rect,\n",
        "            expansion\n",
        "        ])))\n",
        "\n",
        "    def discuss_geometry(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.scale(0.8)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.set_height(randy.get_height())\n",
        "        morty.next_to(randy, RIGHT)\n",
        "        randy.make_eye_contact(morty)\n",
        "        screen = ScreenRectangle(height = 3.5)\n",
        "        screen.to_corner(DOWN+RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [randy, morty])))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"More geometry!\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 2,\n",
        "            bubble_config = {\"height\" : 2, \"width\" : 4}\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                morty, target_mode = \"plain\",\n",
        "            ),\n",
        "            PiCreatureSays(\n",
        "                randy, \"???\",\n",
        "                target_mode = \"maybe\",\n",
        "                bubble_config = {\"width\" : 3, \"height\" : 2}\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(screen),\n",
        "            morty.look_at, screen,\n",
        "            randy.look_at, screen,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(RemovePiCreatureBubble(randy, target_mode = \"pondering\"))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [randy, morty, screen])))\n",
        "\n",
        "    def show_geometrically(self):\n",
        "        dots = [self.example_dot, self.conjugate_dot]\n",
        "        top_dot, low_dot = dots\n",
        "        for dot in dots:\n",
        "            dot.line = Line(\n",
        "                self.plane_center, dot.get_center(), \n",
        "                color = BLUE\n",
        "            )\n",
        "            dot.angle = dot.line.get_angle()\n",
        "            dot.arc = Arc(\n",
        "                dot.angle,\n",
        "                radius = 0.75, \n",
        "                color = YELLOW\n",
        "            )\n",
        "            dot.arc.shift(self.plane_center)\n",
        "            dot.arc.add_tip(tip_length = 0.2)\n",
        "            dot.rotate_word = OldTexText(\"Rotate\")\n",
        "            dot.rotate_word.scale(0.5)\n",
        "            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n",
        "            dot.magnitude_word = OldTexText(\"Length 5\")\n",
        "            dot.magnitude_word.scale(0.6)\n",
        "            dot.magnitude_word.next_to(\n",
        "                ORIGIN,\n",
        "                np.sign(dot.get_center()[1])*UP,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            dot.magnitude_word.add_background_rectangle()\n",
        "            dot.magnitude_word.rotate(dot.angle)\n",
        "            dot.magnitude_word.shift(dot.line.get_center())\n",
        "        twenty_five_label = OldTex(\"25\")\n",
        "        twenty_five_label.add_background_rectangle()\n",
        "        twenty_five_label.next_to(\n",
        "            self.plane.coords_to_point(25, 0),\n",
        "            DOWN\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(top_dot.line))\n",
        "        mover = VGroup(\n",
        "            top_dot.line.copy().set_color(PINK), \n",
        "            top_dot.copy()\n",
        "        )\n",
        "        self.play(FadeIn(\n",
        "            top_dot.magnitude_word,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(top_dot.arc))\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(low_dot.line))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                top_dot.arc,\n",
        "                low_dot.arc\n",
        "            ),\n",
        "            FadeIn(low_dot.rotate_word)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                mover, low_dot.angle, \n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(low_dot.arc),\n",
        "            FadeOut(low_dot.rotate_word),\n",
        "            FadeIn(low_dot.magnitude_word),\n",
        "        )\n",
        "        self.play(\n",
        "            mover[0].scale_about_point, 5, self.plane_center,\n",
        "            mover[1].move_to, self.plane.coords_to_point(25, 0),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(twenty_five_label))\n",
        "        self.wait(3)\n",
        "\n",
        "class NameGaussianIntegers(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"max_lattice_point_radius\" : 15,\n",
        "        \"dot_radius\" : 0.05,\n",
        "        \"plane_center\" : 2*LEFT,\n",
        "        \"x_radius\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_axis_labels()\n",
        "        self.add_a_plus_bi()\n",
        "        self.draw_lattice_points()\n",
        "        self.add_name()\n",
        "        self.restrict_to_one_circle()\n",
        "        self.show_question_algebraically()\n",
        "\n",
        "    def add_a_plus_bi(self):\n",
        "        label = OldTex(\n",
        "            \"a\", \"+\", \"b\", \"i\"\n",
        "        )\n",
        "        a = label.get_part_by_tex(\"a\")\n",
        "        b = label.get_part_by_tex(\"b\")\n",
        "        a.set_color(GREEN)\n",
        "        b.set_color(RED)\n",
        "        label.add_background_rectangle()\n",
        "        label.to_corner(UP+RIGHT)\n",
        "        integers = OldTexText(\"Integers\")\n",
        "        integers.next_to(label, DOWN, LARGE_BUFF)\n",
        "        integers.add_background_rectangle()\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(integers.get_top(), mob, tip_length = 0.15)\n",
        "            for mob in (a, b)\n",
        "        ])\n",
        "        self.add_foreground_mobjects(label, integers, arrows)\n",
        "\n",
        "        self.a_plus_bi = label\n",
        "        self.integers_label = VGroup(integers, arrows)\n",
        "\n",
        "    def add_name(self):\n",
        "        gauss_name = OldTexText(\n",
        "            \"Carl Friedrich Gauss\"\n",
        "        )\n",
        "        gauss_name.add_background_rectangle()\n",
        "        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n",
        "        gauss_name.to_edge(LEFT)\n",
        "\n",
        "        gaussian_integers = OldTexText(\"``Gaussian integers'': \")\n",
        "        gaussian_integers.scale(0.9)\n",
        "        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n",
        "        gaussian_integers.add_background_rectangle()\n",
        "\n",
        "        self.play(FadeIn(gaussian_integers))\n",
        "        self.add_foreground_mobject(gaussian_integers)\n",
        "        self.play(FadeIn(\n",
        "            gauss_name,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(gauss_name))\n",
        "\n",
        "        self.gaussian_integers = gaussian_integers\n",
        "\n",
        "    def restrict_to_one_circle(self):\n",
        "        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n",
        "        for dot in dots:\n",
        "            dot.scale(2)\n",
        "        circle = self.get_circle(5)\n",
        "        radius, root_label = self.get_radial_line_with_label(5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.lattice_points),\n",
        "            ShowCreation(circle),\n",
        "            Rotating(\n",
        "                radius, \n",
        "                run_time = 1, rate_func = smooth,\n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            *list(map(GrowFromCenter, dots))\n",
        "        )\n",
        "        self.play(Write(root_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.circle_dots = dots\n",
        "\n",
        "    def show_question_algebraically(self):\n",
        "        for i, dot in enumerate(self.circle_dots):\n",
        "            x, y = self.dot_to_int_coords(dot)\n",
        "            x_str = str(x)\n",
        "            y_str = str(y) if y >= 0 else \"(%d)\"%y\n",
        "            label = OldTex(x_str, \"+\", y_str, \"i\")\n",
        "            label.scale(0.8)\n",
        "            label.next_to(\n",
        "                dot, \n",
        "                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n",
        "                buff = 0,\n",
        "            )\n",
        "            label.add_background_rectangle()\n",
        "            dot.label = label\n",
        "\n",
        "            equation = OldTex(\n",
        "                \"25 = \"\n",
        "                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n",
        "                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n",
        "            )\n",
        "            equation.scale(0.9)\n",
        "            equation.add_background_rectangle()\n",
        "            equation.to_corner(UP + RIGHT)\n",
        "            dot.equation = equation\n",
        "\n",
        "            for mob in label, equation:\n",
        "                mob.set_color_by_tex(x_str, GREEN, substring = False)\n",
        "                mob.set_color_by_tex(y_str, RED, substring = False)\n",
        "\n",
        "            dot.line_pair = VGroup(*[\n",
        "                Line(\n",
        "                    self.plane_center,\n",
        "                    self.plane.coords_to_point(x, u*y),\n",
        "                    color = PINK,\n",
        "                )\n",
        "                for u in (1, -1)\n",
        "            ])\n",
        "            dot.conjugate_dot = self.circle_dots[-i]\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.a_plus_bi, self.integers_label,\n",
        "            self.gaussian_integers,\n",
        "        ])))\n",
        "\n",
        "        last_dot = None\n",
        "        for dot in self.circle_dots:\n",
        "            anims = [\n",
        "                dot.set_color, PINK,\n",
        "                dot.conjugate_dot.set_color, PINK,\n",
        "            ]\n",
        "            if last_dot is None:\n",
        "                anims += [\n",
        "                    FadeIn(dot.equation),\n",
        "                    FadeIn(dot.label),\n",
        "                ]\n",
        "                anims += list(map(ShowCreation, dot.line_pair))\n",
        "            else:\n",
        "                anims += [\n",
        "                    last_dot.set_color, self.dot_color,\n",
        "                    last_dot.conjugate_dot.set_color, self.dot_color,\n",
        "                    ReplacementTransform(last_dot.equation, dot.equation),\n",
        "                    ReplacementTransform(last_dot.label, dot.label),\n",
        "                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n",
        "                ]\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            last_dot = dot\n",
        "\n",
        "class FactorOrdinaryNumber(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n",
        "        )\n",
        "        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n",
        "        number = equation[0]\n",
        "        alt_rhs_list = list(it.starmap(Tex, [\n",
        "            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n",
        "            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n",
        "            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n",
        "            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n",
        "            (\"=\", \"2 \\\\cdot (-3) \\\\cdot (3) \\\\cdot (-5) \\\\cdot 5^2\"),\n",
        "        ]))\n",
        "        for alt_rhs in alt_rhs_list:\n",
        "            if \"\\\\ne\" in alt_rhs.get_tex():\n",
        "                alt_rhs.set_color(RED)\n",
        "            else:\n",
        "                alt_rhs.set_color(GREEN)\n",
        "            alt_rhs.move_to(equation.get_right())\n",
        "        number.save_state()\n",
        "        number.next_to(self.teacher, UP+LEFT)\n",
        "        title = OldTexText(\"Almost\", \"Unique factorization\")\n",
        "        title.set_color_by_tex(\"Almost\", YELLOW)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            Write(number)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            number.restore,\n",
        "            Write(VGroup(*equation[1:])),\n",
        "            Write(title[1])\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = equation,\n",
        "            added_anims = [self.teacher.change_mode, \"happy\"]\n",
        "        )\n",
        "        self.wait()\n",
        "        last_alt_rhs = None\n",
        "        for alt_rhs in alt_rhs_list:\n",
        "            equation.generate_target()\n",
        "            equation.target.next_to(alt_rhs, LEFT)\n",
        "            anims = [MoveToTarget(equation)]\n",
        "            if last_alt_rhs:\n",
        "                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n",
        "            else:\n",
        "                anims += [FadeIn(alt_rhs)]\n",
        "            self.play(*anims)\n",
        "            if alt_rhs is alt_rhs_list[-2]:\n",
        "                self.play_student_changes(\n",
        "                    *[\"sassy\"]*3,\n",
        "                    look_at = alt_rhs,\n",
        "                    added_anims = [Write(title[0])]\n",
        "                )\n",
        "            self.wait(2)\n",
        "            last_alt_rhs = alt_rhs\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(VGroup(equation, alt_rhs)),\n",
        "            PiCreatureSays(\n",
        "                self.teacher,\n",
        "                \"It's similar for \\\\\\\\ Gaussian integers\",\n",
        "                bubble_config = {\"height\" : 3.5}\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceGaussianPrimes(LatticePointScene, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"plane_center\" : LEFT,\n",
        "        \"x_radius\" : 13,\n",
        "    }\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.7)\n",
        "        morty.next_to(ORIGIN, UP, buff = 0)\n",
        "        morty.to_edge(LEFT)\n",
        "        return morty\n",
        "\n",
        "    def setup(self):\n",
        "        LatticePointScene.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.remove(self.pi_creature)\n",
        "\n",
        "    def construct(self):\n",
        "        self.plane.set_stroke(width = 2)\n",
        "        morty = self.pi_creature\n",
        "        dots = [\n",
        "            Dot(self.plane.coords_to_point(*coords))\n",
        "            for coords in [\n",
        "                (5, 0), \n",
        "                (2, 1), (2, -1), \n",
        "                (-1, 2), (-1, -2),\n",
        "                (-2, -1), (-2, 1),\n",
        "            ]\n",
        "        ]\n",
        "        five_dot = dots[0]\n",
        "        five_dot.set_color(YELLOW)\n",
        "        p_dots = VGroup(*dots[1:])\n",
        "        p1_dot, p2_dot, p3_dot, p4_dot, p5_dot, p6_dot = p_dots\n",
        "        VGroup(p1_dot, p3_dot, p5_dot).set_color(PINK)\n",
        "        VGroup(p2_dot, p4_dot, p6_dot).set_color(RED)\n",
        "\n",
        "        labels = [\n",
        "            OldTex(tex).add_background_rectangle()\n",
        "            for tex in (\"5\", \"2+i\", \"2-i\", \"-1+2i\", \"-1-2i\", \"-2-i\", \"-2+i\")\n",
        "        ]\n",
        "        five_label, p1_label, p2_label, p3_label, p4_label, p5_label, p6_label = labels\n",
        "        vects = [\n",
        "            DOWN, \n",
        "            UP+RIGHT, DOWN+RIGHT, \n",
        "            UP+LEFT, DOWN+LEFT,\n",
        "            DOWN+LEFT, UP+LEFT,\n",
        "        ]\n",
        "        for dot, label, vect in zip(dots, labels, vects):\n",
        "            label.next_to(dot, vect, SMALL_BUFF)\n",
        "\n",
        "        arc_angle = 0.8*np.pi\n",
        "        times_i_arc = Arrow(\n",
        "            p1_dot.get_top(), p3_dot.get_top(), \n",
        "            path_arc = arc_angle\n",
        "        )\n",
        "        times_neg_i_arc = Arrow(\n",
        "            p2_dot.get_bottom(), p4_dot.get_bottom(), \n",
        "            path_arc = -arc_angle\n",
        "        )\n",
        "        times_i = OldTex(\"\\\\times i\")\n",
        "        times_i.add_background_rectangle()\n",
        "        times_i.next_to(\n",
        "            times_i_arc.point_from_proportion(0.5),\n",
        "            UP\n",
        "        )\n",
        "        times_neg_i = OldTex(\"\\\\times (-i)\")\n",
        "        times_neg_i.add_background_rectangle()\n",
        "        times_neg_i.next_to(\n",
        "            times_neg_i_arc.point_from_proportion(0.5),\n",
        "            DOWN\n",
        "        )\n",
        "        VGroup(\n",
        "            times_i, times_neg_i, times_i_arc, times_neg_i_arc\n",
        "        ).set_color(MAROON_B)\n",
        "\n",
        "        gaussian_prime = OldTexText(\"$\\\\Rightarrow$ ``Gaussian prime''\")\n",
        "        gaussian_prime.add_background_rectangle()\n",
        "        gaussian_prime.scale(0.9)\n",
        "        gaussian_prime.next_to(p1_label, RIGHT)\n",
        "\n",
        "        factorization = OldTex(\n",
        "            \"5\", \"= (2+i)(2-i)\"\n",
        "        )\n",
        "        factorization.to_corner(UP+RIGHT)\n",
        "        factorization.shift(1.5*LEFT)\n",
        "        factorization.add_background_rectangle()\n",
        "        neg_alt_factorization = OldTex(\"=(-2-i)(-2+i)\")\n",
        "        i_alt_factorization = OldTex(\"=(-1+2i)(-1-2i)\")\n",
        "        for alt_factorization in neg_alt_factorization, i_alt_factorization:\n",
        "            alt_factorization.next_to(\n",
        "                factorization.get_part_by_tex(\"=\"), DOWN,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "            alt_factorization.add_background_rectangle()\n",
        "\n",
        "        for dot in dots:\n",
        "            dot.add(Line(\n",
        "                self.plane_center,\n",
        "                dot.get_center(),\n",
        "                color = dot.get_color()\n",
        "            ))\n",
        "\n",
        "        self.add(factorization)\n",
        "        self.play(\n",
        "            DrawBorderThenFill(five_dot), \n",
        "            FadeIn(five_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(five_dot).copy(),\n",
        "                VGroup(p1_dot, p2_dot)\n",
        "            )\n",
        "        )\n",
        "        self.play(*list(map(Write, [p1_label, p2_label])))\n",
        "        self.wait()\n",
        "        self.play(Write(gaussian_prime))\n",
        "        self.wait()\n",
        "\n",
        "        #Show morty\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"\\\\emph{Almost} unique\",\n",
        "            bubble_config = {\"height\" : 2, \"width\" : 5},\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(morty, target_mode = \"pondering\"))\n",
        "\n",
        "        #Show neg_alternate expression \n",
        "        movers = [p1_dot, p2_dot, p1_label, p2_label]\n",
        "        for mover in movers:\n",
        "            mover.save_state()\n",
        "        self.play(\n",
        "            Transform(p1_dot, p5_dot),\n",
        "            Transform(p1_label, p5_label),\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(p2_dot, p6_dot),\n",
        "            Transform(p2_label, p6_label),\n",
        "        )\n",
        "        self.play(Write(neg_alt_factorization))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(neg_alt_factorization),\n",
        "            *[m.restore for m in movers]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ##Show i_alternate expression\n",
        "        self.play(\n",
        "            ShowCreation(times_i_arc),\n",
        "            FadeIn(times_i),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    mob1.copy(), mob2,\n",
        "                    path_arc = np.pi/2\n",
        "                )\n",
        "                for mob1, mob2 in [\n",
        "                    (p1_dot, p3_dot),\n",
        "                    (p1_label, p3_label),\n",
        "                ]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(times_neg_i_arc),\n",
        "            FadeIn(times_neg_i),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    mob1.copy(), mob2,\n",
        "                    path_arc = -np.pi/2\n",
        "                )\n",
        "                for mob1, mob2 in [\n",
        "                    (p2_dot, p4_dot),\n",
        "                    (p2_label, p4_label),\n",
        "                ]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(i_alt_factorization))\n",
        "        self.change_mode(\"hesitant\")\n",
        "        self.wait(3)\n",
        "\n",
        "class FromIntegerFactorsToGaussianFactors(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        expression = OldTex(\n",
        "            \"30\", \"=\", \"2\", \"\\\\cdot\", \"3\", \"\\\\cdot\", \"5\"\n",
        "        )\n",
        "        expression.shift(2*UP)\n",
        "        two = expression.get_part_by_tex(\"2\")\n",
        "        five = expression.get_part_by_tex(\"5\")\n",
        "        two.set_color(BLUE)\n",
        "        five.set_color(GREEN)\n",
        "        two.factors = OldTex(\"(1+i)\", \"(1-i)\")\n",
        "        five.factors = OldTex(\"(2+i)\", \"(2-i)\")\n",
        "        for mob, vect in (two, DOWN), (five, UP):\n",
        "            mob.factors.next_to(mob, vect, LARGE_BUFF)\n",
        "            mob.factors.set_color(mob.get_color())\n",
        "            mob.arrows = VGroup(*[\n",
        "                Arrow(\n",
        "                    mob.get_edge_center(vect),\n",
        "                    factor.get_edge_center(-vect),\n",
        "                    color = mob.get_color(),\n",
        "                    tip_length = 0.15\n",
        "                )\n",
        "                for factor in mob.factors\n",
        "            ])\n",
        "\n",
        "        self.add(expression)\n",
        "        for mob in two, five:\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    mob.copy(),\n",
        "                    mob.factors\n",
        "                ),\n",
        "                *list(map(ShowCreation, mob.arrows))\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"pondering\", expression)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.wait(5)\n",
        "        group = VGroup(\n",
        "            expression, \n",
        "            two.arrows, two.factors,\n",
        "            five.arrows, five.factors,\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"Now for a \\\\\\\\ surprising fact...\",\n",
        "            added_anims = [FadeOut(group)]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class FactorizationPattern(Scene):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_number_line()\n",
        "        self.show_one_mod_four_primes()\n",
        "        self.show_three_mod_four_primes()\n",
        "        self.ask_why_this_is_true()\n",
        "        self.show_two()\n",
        "\n",
        "    def add_number_line(self):\n",
        "        line = NumberLine(\n",
        "            x_min = 0,\n",
        "            x_max = 36,\n",
        "            unit_size = 0.4,\n",
        "            numbers_to_show = list(range(0, 33, 4)),\n",
        "            big_tick_numbers = list(range(0, 33, 4)),\n",
        "        )\n",
        "        line.shift(2*DOWN)\n",
        "        line.to_edge(LEFT)\n",
        "        line.add_numbers()\n",
        "\n",
        "        self.add(line)\n",
        "        self.number_line = line\n",
        "\n",
        "    def show_one_mod_four_primes(self):\n",
        "        primes = [5, 13, 17, 29]\n",
        "        dots = VGroup(*[\n",
        "            Dot(self.number_line.number_to_point(prime))\n",
        "            for prime in primes\n",
        "        ])\n",
        "        dots.set_color(GREEN)\n",
        "        prime_mobs = VGroup(*list(map(Tex, list(map(str, primes)))))\n",
        "        arrows = VGroup()\n",
        "        for prime_mob, dot in zip(prime_mobs, dots):\n",
        "            prime_mob.next_to(dot, UP, LARGE_BUFF)\n",
        "            prime_mob.set_color(dot.get_color())\n",
        "            arrow = Arrow(prime_mob, dot, buff = SMALL_BUFF)\n",
        "            arrow.set_color(dot.get_color())\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        factorizations = VGroup(*[\n",
        "            OldTex(\"=(%d+%si)(%d-%si)\"%(x, y_str, x, y_str))\n",
        "            for x, y in [(2, 1), (3, 2), (4, 1), (5, 2)]\n",
        "            for y_str in [str(y) if y is not 1 else \"\"]\n",
        "        ])\n",
        "        factorizations.arrange(DOWN, aligned_edge = LEFT)\n",
        "        factorizations.to_corner(UP+LEFT)\n",
        "        factorizations.shift(RIGHT)\n",
        "        movers = VGroup()\n",
        "        for p_mob, factorization in zip(prime_mobs, factorizations):\n",
        "            mover = p_mob.copy()\n",
        "            mover.generate_target()\n",
        "            mover.target.next_to(factorization, LEFT)\n",
        "            movers.add(mover)\n",
        "        v_dots = OldTex(\"\\\\vdots\")\n",
        "        v_dots.next_to(factorizations[-1][0], DOWN)\n",
        "        factorization.add(v_dots)\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, prime_mobs)),\n",
        "            list(map(ShowCreation, arrows)),\n",
        "            list(map(DrawBorderThenFill, dots)),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            MoveToTarget(\n",
        "                mover,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi/2,\n",
        "            )\n",
        "            for mover in movers\n",
        "        ])\n",
        "        self.play(FadeIn(\n",
        "            factorizations, \n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(4)\n",
        "        self.play(*list(map(FadeOut, [movers, factorizations])))\n",
        "\n",
        "    def show_three_mod_four_primes(self):\n",
        "        primes = [3, 7, 11, 19, 23, 31]\n",
        "        dots = VGroup(*[\n",
        "            Dot(self.number_line.number_to_point(prime))\n",
        "            for prime in primes\n",
        "        ])\n",
        "        dots.set_color(RED)\n",
        "        prime_mobs = VGroup(*list(map(Tex, list(map(str, primes)))))\n",
        "        arrows = VGroup()\n",
        "        for prime_mob, dot in zip(prime_mobs, dots):\n",
        "            prime_mob.next_to(dot, UP, LARGE_BUFF)\n",
        "            prime_mob.set_color(dot.get_color())\n",
        "            arrow = Arrow(prime_mob, dot, buff = SMALL_BUFF)\n",
        "            arrow.set_color(dot.get_color())\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        words = OldTexText(\"Already Gaussian primes\")\n",
        "        words.to_corner(UP+LEFT)\n",
        "        word_arrows = VGroup(*[\n",
        "            Line(\n",
        "                words.get_bottom(), p_mob.get_top(),\n",
        "                color = p_mob.get_color(),\n",
        "                buff = MED_SMALL_BUFF\n",
        "            )\n",
        "            for p_mob in prime_mobs\n",
        "        ])\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, prime_mobs)),\n",
        "            list(map(ShowCreation, arrows)),\n",
        "            list(map(DrawBorderThenFill, dots)),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            *list(map(ShowCreation, word_arrows))\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(*list(map(FadeOut, [words, word_arrows])))\n",
        "\n",
        "    def ask_why_this_is_true(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.scale(0.7)\n",
        "        randy.to_edge(LEFT)\n",
        "        randy.shift(0.8*UP)\n",
        "\n",
        "        links_text = OldTexText(\"(See links in description)\")\n",
        "        links_text.scale(0.7)\n",
        "        links_text.to_corner(UP+RIGHT)\n",
        "        links_text.shift(DOWN)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"Wait...why?\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            bubble_config = {\"height\" : 2, \"width\" : 3},\n",
        "            target_mode = \"confused\",\n",
        "            look_at = self.number_line,\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(links_text))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            randy, randy.bubble, randy.bubble.content,\n",
        "            links_text\n",
        "        ])))\n",
        "\n",
        "    def show_two(self):\n",
        "        two_dot = Dot(self.number_line.number_to_point(2))\n",
        "        two = OldTex(\"2\")\n",
        "        two.next_to(two_dot, UP, LARGE_BUFF)\n",
        "        arrow = Arrow(two, two_dot, buff = SMALL_BUFF)\n",
        "        VGroup(two_dot, two, arrow).set_color(YELLOW)\n",
        "\n",
        "        mover = two.copy()\n",
        "        mover.generate_target()\n",
        "        mover.target.to_corner(UP+LEFT)\n",
        "        factorization = OldTex(\"=\", \"(1+i)\", \"(1-i)\")\n",
        "        factorization.next_to(mover.target, RIGHT)\n",
        "        factors = VGroup(*factorization[1:])\n",
        "\n",
        "        time_i_arrow = Arrow(\n",
        "            factors[1].get_bottom(),\n",
        "            factors[0].get_bottom(),\n",
        "            path_arc = -np.pi\n",
        "        )\n",
        "        times_i = OldTex(\"\\\\times i\")\n",
        "        # times_i.scale(1.5)\n",
        "        times_i.next_to(time_i_arrow, DOWN)\n",
        "        times_i.set_color(time_i_arrow.get_color())\n",
        "        words = OldTexText(\"You'll see why this matters...\")\n",
        "        words.next_to(times_i, DOWN)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            Write(two),\n",
        "            ShowCreation(arrow),\n",
        "            DrawBorderThenFill(two_dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(mover),\n",
        "            Write(factorization)\n",
        "        )\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(time_i_arrow))\n",
        "        self.play(Write(times_i))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class RingsWithOneModFourPrimes(CertainRegularityInPrimes):\n",
        "    CONFIG = {\n",
        "        \"plane_center\" : ORIGIN,\n",
        "        \"primes\" : [5, 13, 17, 29, 37, 41, 53],\n",
        "        \"include_pi_formula\" : False,\n",
        "    }\n",
        "\n",
        "class RingsWithThreeModFourPrimes(CertainRegularityInPrimes):\n",
        "    CONFIG = {\n",
        "        \"plane_center\" : ORIGIN,\n",
        "        \"primes\" : [3, 7, 11, 19, 23, 31, 43],\n",
        "        \"include_pi_formula\" : False,\n",
        "    }\n",
        "\n",
        "class FactorTwo(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        two_dot = Dot(self.plane.coords_to_point(2, 0))\n",
        "        two_dot.set_color(YELLOW)\n",
        "        factor_dots = VGroup(*[\n",
        "            Dot(self.plane.coords_to_point(1, u))\n",
        "            for u in (1, -1)\n",
        "        ])\n",
        "        two_label = OldTex(\"2\").next_to(two_dot, DOWN)\n",
        "        two_label.set_color(YELLOW)\n",
        "        two_label.add_background_rectangle()\n",
        "        factor_labels = VGroup(*[\n",
        "            OldTex(tex).add_background_rectangle().next_to(dot, vect)\n",
        "            for tex, dot, vect in zip(\n",
        "                [\"1+i\", \"1-i\"], factor_dots, [UP, DOWN]\n",
        "            )\n",
        "        ])\n",
        "        VGroup(factor_labels, factor_dots).set_color(MAROON_B)\n",
        "\n",
        "        for dot in it.chain(factor_dots, [two_dot]):\n",
        "            line = Line(self.plane_center, dot.get_center())\n",
        "            line.set_color(dot.get_color())\n",
        "            dot.add(line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(two_dot),\n",
        "            Write(two_label),\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(mob1.copy()), mob2\n",
        "            )\n",
        "            for mob1, mob2 in [\n",
        "                (two_label, factor_labels),\n",
        "                (two_dot, factor_dots),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        dot_copy = factor_dots[1].copy()\n",
        "        dot_copy.set_color(RED)\n",
        "        for angle in np.pi/2, -np.pi/2:\n",
        "            self.play(Rotate(dot_copy, angle, run_time = 2))\n",
        "            self.wait(2)\n",
        "\n",
        "class CountThroughRingsCopy(CountThroughRings):\n",
        "    pass\n",
        "\n",
        "class NameGaussianIntegersCopy(NameGaussianIntegers):\n",
        "    pass\n",
        "\n",
        "class IntroduceRecipe(Scene):\n",
        "    CONFIG = {\n",
        "        \"N_string\" : \"25\",\n",
        "        \"integer_factors\" : [5, 5],\n",
        "        \"gaussian_factors\" : [\n",
        "            complex(2, 1), complex(2, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "        ],\n",
        "        \"x_color\" : GREEN,\n",
        "        \"y_color\" : RED,\n",
        "        \"N_color\" : WHITE,\n",
        "        \"i_positive_color\" : BLUE,\n",
        "        \"i_negative_color\" : YELLOW,\n",
        "        \"i_zero_color\" : MAROON_B,\n",
        "        \"T_chart_width\" : 8,\n",
        "        \"T_chart_height\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.mention_conjugate_rule()\n",
        "        self.take_product_of_columns()\n",
        "        self.mark_left_product_as_result()\n",
        "        self.swap_factors()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\n",
        "            \"\\\\text{Recipe for }\",\n",
        "            \"a\", \"+\", \"b\", \"i\",\n",
        "            \"\\\\text{ satisfying }\",\n",
        "            \"(\", \"a\", \"+\", \"b\", \"i\", \")\",\n",
        "            \"(\", \"a\", \"-\", \"b\", \"i\", \")\",\n",
        "            \"=\", self.N_string\n",
        "        )\n",
        "        strings = (\"a\", \"b\", self.N_string)\n",
        "        colors = (self.x_color, self.y_color, self.N_color)\n",
        "        for tex, color in zip(strings, colors):\n",
        "            title.set_color_by_tex(tex, color, substring = False)\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "        N_mob = title.get_part_by_tex(self.N_string)\n",
        "        digest_locals(self, [\"title\", \"h_line\", \"N_mob\"])\n",
        "\n",
        "    def show_ordinary_factorization(self):\n",
        "        N_mob = self.N_mob.copy()\n",
        "        N_mob.generate_target()\n",
        "        N_mob.target.next_to(self.h_line, DOWN)\n",
        "        N_mob.target.to_edge(LEFT)\n",
        "\n",
        "        factors = self.integer_factors\n",
        "        symbols = [\"=\"] + [\"\\\\cdot\"]*(len(factors)-1)\n",
        "        factorization = OldTex(*it.chain(*list(zip(\n",
        "            symbols, list(map(str, factors))\n",
        "        ))))\n",
        "        factorization.next_to(N_mob.target, RIGHT)\n",
        "\n",
        "        self.play(MoveToTarget(\n",
        "            N_mob,\n",
        "            run_time = 2,\n",
        "            path_arc = -np.pi/6\n",
        "        ))\n",
        "        self.play(Write(factorization))\n",
        "        self.wait()\n",
        "\n",
        "        self.factored_N_mob = N_mob\n",
        "        self.integer_factorization = factorization\n",
        "\n",
        "    def subfactor_ordinary_factorization(self):\n",
        "        factors = self.gaussian_factors\n",
        "        factorization = OldTex(\n",
        "            \"=\", *list(map(self.complex_number_to_tex, factors))\n",
        "        )\n",
        "        max_width = FRAME_WIDTH - 2\n",
        "        if factorization.get_width() > max_width:\n",
        "            factorization.set_width(max_width)\n",
        "        factorization.next_to(\n",
        "            self.integer_factorization, DOWN,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        for factor, mob in zip(factors, factorization[1:]):\n",
        "            mob.underlying_number = factor\n",
        "            y = complex(factor).imag\n",
        "            if y == 0:\n",
        "                mob.set_color(self.i_zero_color)\n",
        "            elif y > 0:\n",
        "                mob.set_color(self.i_positive_color)\n",
        "            elif y < 0:\n",
        "                mob.set_color(self.i_negative_color)\n",
        "        movers = VGroup()\n",
        "        mover = self.integer_factorization[0].copy()\n",
        "        mover.target = factorization[0]\n",
        "        movers.add(mover)\n",
        "        index = 0\n",
        "        for prime_mob in self.integer_factorization[1::2]:\n",
        "            gauss_prime = factors[index]\n",
        "            gauss_prime_mob = factorization[index+1]\n",
        "            mover = prime_mob.copy()\n",
        "            mover.target = gauss_prime_mob\n",
        "            movers.add(mover)\n",
        "            if abs(complex(gauss_prime).imag) > 0:\n",
        "                index += 1\n",
        "                mover = prime_mob.copy()\n",
        "                mover.target = factorization[index+1]\n",
        "                movers.add(mover)\n",
        "            index += 1\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget,\n",
        "            movers,\n",
        "            replace_mobject_with_target_in_scene = True\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.gaussian_factorization = factorization\n",
        "\n",
        "    def organize_factors_into_columns(self):\n",
        "        T_chart = self.get_T_chart()\n",
        "        factors = self.gaussian_factorization.copy()[1:]\n",
        "        left_factors, right_factors = self.get_left_and_right_factors()\n",
        "        for group in left_factors, right_factors:\n",
        "            group.generate_target()\n",
        "            group.target.arrange(DOWN)\n",
        "        left_factors.target.next_to(T_chart.left_h_line, DOWN)\n",
        "        right_factors.target.next_to(T_chart.right_h_line, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(T_chart))\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(left_factors))\n",
        "        self.play(MoveToTarget(right_factors))\n",
        "        self.wait()\n",
        "\n",
        "        digest_locals(self, [\"left_factors\", \"right_factors\"])\n",
        "\n",
        "    def mention_conjugate_rule(self):\n",
        "        left_factors = self.left_factors\n",
        "        right_factors = self.right_factors\n",
        "        double_arrows = VGroup()\n",
        "        for lf, rf in zip(left_factors.target, right_factors.target):\n",
        "            arrow = DoubleArrow(\n",
        "                lf, rf, \n",
        "                buff = SMALL_BUFF,\n",
        "                tip_length = SMALL_BUFF,\n",
        "                color = GREEN\n",
        "            )\n",
        "            word = OldTexText(\"Conjugates\")\n",
        "            word.scale(0.75)\n",
        "            word.add_background_rectangle()\n",
        "            word.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "            arrow.add(word)\n",
        "            double_arrows.add(arrow)\n",
        "        main_arrow = double_arrows[0]\n",
        "\n",
        "        self.play(Write(main_arrow, run_time = 1))\n",
        "        self.wait()\n",
        "        for new_arrow in double_arrows[1:]:\n",
        "            self.play(Transform(main_arrow, new_arrow))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(FadeOut(main_arrow))\n",
        "\n",
        "    def take_product_of_columns(self):\n",
        "        arrows = self.get_product_multiplication_lines()\n",
        "        products = self.get_product_mobjects()\n",
        "        factor_groups = [self.left_factors, self.right_factors]\n",
        "\n",
        "        for arrow, product, group in zip(arrows, products, factor_groups):\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.play(ReplacementTransform(\n",
        "                group.copy(), VGroup(product)\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.wait(3)\n",
        "\n",
        "    def mark_left_product_as_result(self):\n",
        "        rect = self.get_result_surrounding_rect()\n",
        "        words = OldTexText(\"Output\", \" of recipe\")\n",
        "        words.next_to(rect, DOWN, buff = MED_LARGE_BUFF)\n",
        "        words.to_edge(LEFT)\n",
        "        arrow = Arrow(words.get_top(), rect.get_left())\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [words, arrow])))\n",
        "\n",
        "        self.output_label_group = VGroup(words, arrow)\n",
        "\n",
        "    def swap_factors(self):\n",
        "        for i in range(len(self.left_factors)):\n",
        "            self.swap_factors_at_index(i)\n",
        "            self.wait()\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_left_and_right_factors(self):\n",
        "        factors = self.gaussian_factorization.copy()[1:]\n",
        "        return VGroup(*factors[::2]), VGroup(*factors[1::2])\n",
        "\n",
        "    def get_T_chart(self):\n",
        "        T_chart = VGroup()\n",
        "        h_lines = VGroup(*[\n",
        "            Line(ORIGIN, self.T_chart_width*RIGHT/2.0) \n",
        "            for x in range(2)\n",
        "        ])\n",
        "        h_lines.arrange(RIGHT, buff = 0)\n",
        "        h_lines.shift(UP)\n",
        "        v_line = Line(self.T_chart_height*UP, ORIGIN)\n",
        "        v_line.move_to(h_lines.get_center(), UP)\n",
        "\n",
        "        T_chart.left_h_line, T_chart.right_h_line = h_lines\n",
        "        T_chart.v_line = v_line\n",
        "        T_chart.digest_mobject_attrs()\n",
        "\n",
        "        return T_chart\n",
        "\n",
        "    def complex_number_to_tex(self, z):\n",
        "        z = complex(z)\n",
        "        x, y = z.real, z.imag\n",
        "        if y == 0:\n",
        "            return \"(%d)\"%x\n",
        "        y_sign_tex = \"+\" if y >= 0 else \"-\"\n",
        "        if abs(y) == 1:\n",
        "            y_str = y_sign_tex + \"i\"\n",
        "        else:\n",
        "            y_str = y_sign_tex + \"%di\"%abs(y)\n",
        "        return \"(%d%s)\"%(x, y_str)\n",
        "\n",
        "    def get_product_multiplication_lines(self):\n",
        "        lines = VGroup()\n",
        "        for factors in self.left_factors, self.right_factors:\n",
        "            line = Line(ORIGIN, 3*RIGHT)\n",
        "            line.next_to(factors, DOWN, SMALL_BUFF)\n",
        "            times = OldTex(\"\\\\times\")\n",
        "            times.next_to(line.get_left(), UP+RIGHT, SMALL_BUFF)\n",
        "            line.add(times)\n",
        "            lines.add(line)\n",
        "        self.multiplication_lines = lines\n",
        "        return lines\n",
        "\n",
        "    def get_product_mobjects(self):\n",
        "        factor_groups = [self.left_factors, self.right_factors]\n",
        "        product_mobjects = VGroup()\n",
        "        for factors, line in zip(factor_groups, self.multiplication_lines):\n",
        "            product = reduce(op.mul, [\n",
        "                factor.underlying_number\n",
        "                for factor in factors\n",
        "            ])\n",
        "            color = average_color(*[\n",
        "                factor.get_color()\n",
        "                for factor in factors\n",
        "            ])\n",
        "            product_mob = OldTex(\n",
        "                self.complex_number_to_tex(product)\n",
        "            )\n",
        "            product_mob.set_color(color)\n",
        "            product_mob.next_to(line, DOWN)\n",
        "            product_mobjects.add(product_mob)\n",
        "        self.product_mobjects = product_mobjects\n",
        "        return product_mobjects\n",
        "\n",
        "    def swap_factors_at_index(self, index):\n",
        "        factor_groups = self.left_factors, self.right_factors\n",
        "        factors_to_swap = [group[index] for group in factor_groups]\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                factors_to_swap[i].move_to, factors_to_swap[1-i],\n",
        "                path_arc = np.pi/2,\n",
        "            )\n",
        "            for i in range(2)\n",
        "        ])\n",
        "        for i, group in enumerate(factor_groups):\n",
        "            group.submobjects[index] = factors_to_swap[1-i]\n",
        "        self.play(FadeOut(self.product_mobjects))\n",
        "        self.get_product_mobjects()\n",
        "        rect = self.result_surrounding_rect\n",
        "        new_rect = self.get_result_surrounding_rect()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(group.copy(), VGroup(product))\n",
        "            for group, product in zip(\n",
        "                factor_groups, self.product_mobjects,\n",
        "            )\n",
        "        ]+[\n",
        "            ReplacementTransform(rect, new_rect)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def get_result_surrounding_rect(self, product = None):\n",
        "        if product is None:\n",
        "            product = self.product_mobjects[0]\n",
        "        rect = SurroundingRectangle(product)\n",
        "        self.result_surrounding_rect = rect\n",
        "        return rect\n",
        "\n",
        "    def write_last_step(self):\n",
        "        output_words, arrow = self.output_label_group\n",
        "        final_step = OldTexText(\n",
        "            \"Multiply by $1$, $i$, $-1$ or $-i$\"\n",
        "        )\n",
        "        final_step.scale(0.9)\n",
        "        final_step.next_to(arrow.get_start(), DOWN, SMALL_BUFF)\n",
        "        final_step.shift_onto_screen()\n",
        "        \n",
        "        anims = [Write(final_step)]\n",
        "        if arrow not in self.get_mobjects():\n",
        "            # arrow = Arrow(\n",
        "            #     final_step.get_top(),\n",
        "            #     self.result_surrounding_rect.get_left()\n",
        "            # )\n",
        "            anims += [ShowCreation(arrow)]\n",
        "        self.play(*anims)\n",
        "        self.wait(2)\n",
        "\n",
        "class StateThreeChoices(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"$5^2$ gives 3 choices.\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class ThreeOutputsAsLatticePoints(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"coords_list\" : [(3, 4), (5, 0), (3, -4)],\n",
        "        \"dot_radius\" : 0.1,\n",
        "        \"colors\" : [YELLOW, GREEN, PINK, MAROON_B],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_circle()\n",
        "        self.add_dots_and_labels()\n",
        "\n",
        "    def add_circle(self):\n",
        "        radius = np.sqrt(self.radius_squared)\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line, root_label = self.get_radial_line_with_label(radius)\n",
        "        self.add(radial_line, root_label, circle)\n",
        "        self.add_foreground_mobject(root_label)\n",
        "\n",
        "    def add_dots_and_labels(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                self.plane.coords_to_point(*coords),\n",
        "                radius = self.dot_radius, \n",
        "                color = self.colors[0],\n",
        "            )\n",
        "            for coords in self.coords_list\n",
        "        ])\n",
        "        labels = VGroup()\n",
        "        for x, y in self.coords_list:\n",
        "            if y == 0:\n",
        "                y_str = \"\"\n",
        "                vect = DOWN+RIGHT\n",
        "            elif y > 1:\n",
        "                y_str = \"+%di\"%y\n",
        "                vect = UP+RIGHT\n",
        "            else:\n",
        "                y_str = \"%di\"%y\n",
        "                vect = DOWN+RIGHT\n",
        "            label = OldTex(\"%d%s\"%(x, y_str))\n",
        "            label.add_background_rectangle()\n",
        "            point = self.plane.coords_to_point(x, y)\n",
        "            label.next_to(point, vect)\n",
        "            labels.add(label)\n",
        "\n",
        "        for dot, label in zip(dots, labels):\n",
        "            self.play(\n",
        "                FadeIn(label),\n",
        "                DrawBorderThenFill(\n",
        "                    dot, \n",
        "                    stroke_color = PINK,\n",
        "                    stroke_width = 4\n",
        "                )\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.original_dots = dots\n",
        "\n",
        "class LooksLikeYoureMissingSome(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Looks like you're \\\\\\\\ missing a few\",\n",
        "            target_mode = \"sassy\",\n",
        "            index = 0,\n",
        "        )\n",
        "        self.play(self.teacher.change, \"guilty\")\n",
        "        self.wait(3)\n",
        "\n",
        "class ShowAlternateFactorizationOfTwentyFive(IntroduceRecipe):\n",
        "    CONFIG = {\n",
        "        \"gaussian_factors\" : [\n",
        "            complex(-1, 2), complex(-1, -2),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.take_product_of_columns()\n",
        "        self.mark_left_product_as_result()\n",
        "        self.swap_factors()\n",
        "\n",
        "class WriteAlternateLastStep(IntroduceRecipe):\n",
        "    def construct(self):\n",
        "        self.force_skipping()        \n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.take_product_of_columns()\n",
        "        self.mark_left_product_as_result()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.cross_out_output_words()\n",
        "        self.write_last_step()\n",
        "\n",
        "    def cross_out_output_words(self):\n",
        "        output_words, arrow = self.output_label_group\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.replace(output_words, stretch = True)\n",
        "        cross.set_color(RED)\n",
        "        \n",
        "        self.add(output_words, arrow)\n",
        "        self.play(Write(cross))\n",
        "        output_words.add(cross)\n",
        "        self.play(output_words.to_edge, DOWN)\n",
        "\n",
        "class ThreeOutputsAsLatticePointsContinued(ThreeOutputsAsLatticePoints):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        ThreeOutputsAsLatticePoints.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.show_multiplication_by_units()\n",
        "\n",
        "    def show_multiplication_by_units(self):\n",
        "        original_dots = self.original_dots\n",
        "        lines = VGroup()\n",
        "        for dot in original_dots:\n",
        "            line = Line(self.plane_center, dot.get_center())\n",
        "            line.set_stroke(dot.get_color(), 6)\n",
        "            lines.add(line)\n",
        "            dot.add(line)\n",
        "        words_group = VGroup(*[\n",
        "            OldTexText(\"Multiply by $%s$\"%s)\n",
        "            for s in (\"1\", \"i\", \"-1\", \"-i\")\n",
        "        ])\n",
        "        for words, color in zip(words_group, self.colors):\n",
        "            words.add_background_rectangle()\n",
        "            words.set_color(color)\n",
        "        words_group.arrange(DOWN, aligned_edge = LEFT)\n",
        "        words_group.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        angles = [np.pi/2, np.pi, -np.pi/2]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words_group[0]),\n",
        "            *list(map(ShowCreation, lines))\n",
        "        )\n",
        "        for words, angle, color in zip(words_group[1:], angles, self.colors[1:]):\n",
        "            self.play(FadeIn(words))\n",
        "            dots_copy = original_dots.copy()\n",
        "            self.play(\n",
        "                dots_copy.rotate, angle,\n",
        "                dots_copy.set_color, color,\n",
        "                path_arc = angle\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "class RecipeFor125(IntroduceRecipe):\n",
        "    CONFIG = {\n",
        "        \"N_string\" : \"125\",\n",
        "        \"integer_factors\" : [5, 5, 5],\n",
        "        \"gaussian_factors\" : [\n",
        "            complex(2, -1), complex(2, 1), \n",
        "            complex(2, -1), complex(2, 1), \n",
        "            complex(2, -1), complex(2, 1),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        \n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.organize_factors_into_columns()\n",
        "        # self.take_product_of_columns()\n",
        "        # self.mark_left_product_as_result()\n",
        "        # self.swap_factors()\n",
        "        # self.write_last_step()\n",
        "\n",
        "class StateFourChoices(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"$5^3$ gives 4 choices.\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class Show125Circle(ThreeOutputsAsLatticePointsContinued):\n",
        "    CONFIG = {\n",
        "        \"radius_squared\" : 125,\n",
        "        \"coords_list\" : [(2, 11), (10, 5), (10, -5), (2, -11)],\n",
        "        \"y_radius\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_circle()\n",
        "        self.add_dots_and_labels()\n",
        "        self.show_multiplication_by_units()\n",
        "        self.ask_about_two()\n",
        "\n",
        "    def draw_circle(self):\n",
        "        self.plane.scale(2)\n",
        "        radius = np.sqrt(self.radius_squared)\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line, root_label = self.get_radial_line_with_label(radius)\n",
        "\n",
        "        self.play(\n",
        "            Write(root_label),\n",
        "            ShowCreation(radial_line)\n",
        "        )\n",
        "        self.add_foreground_mobject(root_label)\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                radial_line, \n",
        "                rate_func = smooth, \n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            ShowCreation(circle),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        group = VGroup(\n",
        "            self.plane, radial_line, circle, root_label\n",
        "        )\n",
        "        self.play(group.scale, 0.5)\n",
        "\n",
        "class RecipeFor375(IntroduceRecipe):\n",
        "    CONFIG = {\n",
        "        \"N_string\" : \"375\",\n",
        "        \"integer_factors\" : [3, 5, 5, 5],\n",
        "        \"gaussian_factors\" : [\n",
        "            3, \n",
        "            complex(2, 1), complex(2, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.express_trouble_with_three()\n",
        "        self.take_product_of_columns()\n",
        "\n",
        "    def express_trouble_with_three(self):\n",
        "        morty = Mortimer().flip().to_corner(DOWN+LEFT)\n",
        "        three = self.gaussian_factorization[1].copy()\n",
        "        three.generate_target()\n",
        "        three.target.next_to(morty, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            MoveToTarget(three), \n",
        "            morty.change, \"angry\", three.target\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        for factors in self.left_factors, self.right_factors:\n",
        "            self.play(\n",
        "                three.next_to, factors, DOWN,\n",
        "                morty.change, \"sassy\", factors.get_bottom()\n",
        "            )\n",
        "            self.wait()\n",
        "        self.right_factors.add(three)\n",
        "        self.play(morty.change_mode, \"pondering\")\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_left_and_right_factors(self):\n",
        "        factors = self.gaussian_factorization.copy()[1:]\n",
        "        return VGroup(*factors[1::2]), VGroup(*factors[2::2])\n",
        "\n",
        "class Show375Circle(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 20,\n",
        "    }\n",
        "    def construct(self):\n",
        "        radius = np.sqrt(375)\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line, root_label = self.get_radial_line_with_label(radius)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            Write(root_label, run_time = 1)\n",
        "        )\n",
        "        self.add_foreground_mobject(root_label)\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                radial_line,\n",
        "                rate_func = smooth,\n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            ShowCreation(circle),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        group = VGroup(\n",
        "            self.plane, radial_line, root_label, circle\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class RecipeFor1125(IntroduceRecipe):\n",
        "    CONFIG = {\n",
        "        \"N_string\" : \"1125\",\n",
        "        \"integer_factors\" : [3, 3, 5, 5, 5],\n",
        "        \"gaussian_factors\" : [\n",
        "            3, 3,\n",
        "            complex(2, 1), complex(2, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.mention_conjugate_rule()\n",
        "        self.take_product_of_columns()\n",
        "        self.mark_left_product_as_result()\n",
        "        self.swap_factors()\n",
        "        self.write_last_step()\n",
        "\n",
        "    def write_last_step(self):\n",
        "        words = OldTexText(\n",
        "            \"Multiply by \\\\\\\\ \", \n",
        "            \"$1$, $i$, $-1$ or $-i$\"\n",
        "        )\n",
        "        words.scale(0.7)\n",
        "        words.to_corner(DOWN+LEFT)\n",
        "        product = self.product_mobjects[0]\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class Show125CircleSimple(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"radius_squared\" : 125,\n",
        "        \"y_radius\" : 12,\n",
        "        \"max_lattice_point_radius\" : 12,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.plane.set_stroke(width = 1)\n",
        "        radius = np.sqrt(self.radius_squared)\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line, root_label = self.get_radial_line_with_label(radius)\n",
        "        dots = self.get_lattice_points_on_r_squared_circle(self.radius_squared)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            Write(root_label, run_time = 1)\n",
        "        )\n",
        "        self.add_foreground_mobject(root_label)\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                radial_line,\n",
        "                rate_func = smooth,\n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            ShowCreation(circle),\n",
        "            LaggedStartMap(\n",
        "                DrawBorderThenFill,\n",
        "                dots,\n",
        "                stroke_width = 4,\n",
        "                stroke_color = PINK,\n",
        "            ),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class Show1125Circle(Show125CircleSimple):\n",
        "    CONFIG = {\n",
        "        \"radius_squraed\" : 1125,\n",
        "        \"y_radius\" : 35,\n",
        "        \"max_lattice_point_radius\" : 35,\n",
        "    }\n",
        "\n",
        "class SummarizeCountingRule(Show125Circle):\n",
        "    CONFIG = {\n",
        "        \"dot_radius\" : 0.075,\n",
        "        \"N_str\" : \"N\",\n",
        "        \"rect_opacity\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_count_words()\n",
        "        self.draw_circle()\n",
        "        self.add_full_screen_rect()\n",
        "        self.talk_through_rules()\n",
        "        self.ask_about_two()\n",
        "\n",
        "    def add_count_words(self):\n",
        "        words = OldTexText(\n",
        "            \"\\\\# Lattice points \\\\\\\\ on $\\\\sqrt{%s}$ circle\"%self.N_str\n",
        "        )\n",
        "        words.to_corner(UP+LEFT)\n",
        "        words.add_background_rectangle()\n",
        "        self.add(words)\n",
        "        self.count_words = words\n",
        "\n",
        "    def draw_circle(self):\n",
        "        radius = np.sqrt(self.radius_squared)\n",
        "        circle = self.get_circle(radius)\n",
        "        radial_line, num_root_label = self.get_radial_line_with_label(radius)\n",
        "        root_label = OldTex(\"\\\\sqrt{%s}\"%self.N_str)\n",
        "        root_label.next_to(radial_line, UP, SMALL_BUFF)\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                self.plane.coords_to_point(*coords),\n",
        "                radius = self.dot_radius,\n",
        "                color = self.dot_color\n",
        "            )\n",
        "            for coords in self.coords_list\n",
        "        ])\n",
        "        for angle in np.pi/2, np.pi, -np.pi/2:\n",
        "            dots.add(*dots.copy().rotate(angle))\n",
        "\n",
        "        self.play(\n",
        "            Write(root_label),\n",
        "            ShowCreation(radial_line)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                radial_line, \n",
        "                rate_func = smooth, \n",
        "                about_point = self.plane_center\n",
        "            ),\n",
        "            ShowCreation(circle),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill,\n",
        "            dots,\n",
        "            stroke_width = 4,\n",
        "            stroke_color = PINK\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def add_full_screen_rect(self):\n",
        "        rect = FullScreenFadeRectangle(\n",
        "            fill_opacity = self.rect_opacity\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Animation(self.count_words)\n",
        "        )\n",
        "\n",
        "    def talk_through_rules(self):\n",
        "        factorization = OldTex(\n",
        "            \"N =\", \n",
        "            \"3\", \"^4\", \"\\\\cdot\",\n",
        "            \"5\", \"^3\", \"\\\\cdot\",\n",
        "            \"13\", \"^2\"\n",
        "        )\n",
        "        factorization.next_to(ORIGIN, RIGHT)\n",
        "        factorization.to_edge(UP)\n",
        "\n",
        "        three, five, thirteen = [\n",
        "            factorization.get_part_by_tex(str(n), substring = False)\n",
        "            for n in (3, 5, 13)\n",
        "        ]\n",
        "        three_power = factorization.get_part_by_tex(\"^4\")\n",
        "        five_power = factorization.get_part_by_tex(\"^3\")\n",
        "        thirteen_power = factorization.get_part_by_tex(\"^2\")\n",
        "        alt_three_power = five_power.copy().move_to(three_power)\n",
        "\n",
        "        three_brace = Brace(VGroup(*factorization[1:3]), DOWN)\n",
        "        five_brace = Brace(VGroup(*factorization[3:6]), DOWN)\n",
        "        thirteen_brace = Brace(VGroup(*factorization[6:9]), DOWN)\n",
        "\n",
        "        three_choices = three_brace.get_tex(\"(\", \"1\", \")\")\n",
        "        five_choices = five_brace.get_tex(\n",
        "            \"(\", \"3\", \"+\", \"1\", \")\"\n",
        "        )\n",
        "        thirteen_choices = thirteen_brace.get_tex(\n",
        "            \"(\", \"2\", \"+\", \"1\", \")\"\n",
        "        )\n",
        "        all_choices = VGroup(three_choices, five_choices, thirteen_choices)\n",
        "        for choices in all_choices:\n",
        "            choices.scale(0.75, about_point = choices.get_top())\n",
        "        thirteen_choices.next_to(five_choices, RIGHT)\n",
        "        three_choices.next_to(five_choices, LEFT)\n",
        "        alt_three_choices = OldTex(\"(\", \"0\", \")\")\n",
        "        alt_three_choices.scale(0.75)\n",
        "        alt_three_choices.move_to(three_choices, RIGHT)\n",
        "\n",
        "\n",
        "        self.play(FadeIn(factorization))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            five.set_color, GREEN,\n",
        "            thirteen.set_color, GREEN,\n",
        "            FadeIn(five_brace),\n",
        "            FadeIn(thirteen_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        for choices, power in (five_choices, five_power), (thirteen_choices, thirteen_power):\n",
        "            self.play(\n",
        "                Write(VGroup(choices[0], *choices[2:])),\n",
        "                ReplacementTransform(\n",
        "                    power.copy(), choices[1]\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            three.set_color, RED,\n",
        "            FadeIn(three_brace)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(VGroup(three_choices[0], three_choices[2])),\n",
        "            ReplacementTransform(\n",
        "                three_power.copy(), three_choices[1]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        movers = three_power, three_choices\n",
        "        for mob in movers:\n",
        "            mob.save_state()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                three_power, alt_three_power,\n",
        "                path_arc = np.pi\n",
        "            ),\n",
        "            Transform(three_choices, alt_three_choices)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *[mob.restore for mob in movers],\n",
        "            path_arc = -np.pi\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        equals_four = OldTex(\"=\", \"4\")\n",
        "        four = equals_four.get_part_by_tex(\"4\")\n",
        "        four.set_color(YELLOW)\n",
        "        final_choice_words = OldTexText(\n",
        "            \"Mutiply\", \"by $1$, $i$, $-1$ or $-i$\"\n",
        "        )\n",
        "        final_choice_words.set_color(YELLOW)\n",
        "        final_choice_words.next_to(four, DOWN, LARGE_BUFF, LEFT)\n",
        "        final_choice_words.to_edge(RIGHT)\n",
        "        final_choice_arrow = Arrow(\n",
        "            final_choice_words[0].get_top(),\n",
        "            four.get_bottom(),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        choices_copy = all_choices.copy()\n",
        "        choices_copy.generate_target()\n",
        "\n",
        "        choices_copy.target.scale(1./0.75)\n",
        "        choices_copy.target.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        choices_copy.target.next_to(equals_four, RIGHT, SMALL_BUFF)\n",
        "        choices_copy.target.shift(0.25*SMALL_BUFF*DOWN)\n",
        "        self.play(\n",
        "            self.count_words.next_to, equals_four, LEFT,\n",
        "            MoveToTarget(choices_copy),\n",
        "            FadeIn(equals_four)\n",
        "        )\n",
        "        self.play(*list(map(FadeIn, [final_choice_words, final_choice_arrow])))\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_two(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.scale(0.7)\n",
        "        randy.to_edge(LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"What about \\\\\\\\ factors of 2?\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            bubble_config = {\"height\" : 3, \"width\" : 3},\n",
        "            target_mode = \"confused\",\n",
        "            look_at = self.count_words\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class ThisIsTheHardestPart(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_student_changes(\"horrified\", \"confused\", \"pleading\")\n",
        "        self.teacher_says(\"This is the \\\\\\\\ hardest part\")\n",
        "        self.play_student_changes(\"thinking\", \"happy\", \"pondering\")\n",
        "        self.wait(2)\n",
        "\n",
        "class RecipeFor10(IntroduceRecipe):\n",
        "    CONFIG = {\n",
        "        \"N_string\" : \"10\",\n",
        "        \"integer_factors\" : [2, 5],\n",
        "        \"gaussian_factors\" : [\n",
        "            complex(1, 1), complex(1, -1),\n",
        "            complex(2, 1), complex(2, -1),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_ordinary_factorization()\n",
        "        self.subfactor_ordinary_factorization()\n",
        "        self.organize_factors_into_columns()\n",
        "        self.take_product_of_columns()\n",
        "        self.mark_left_product_as_result()\n",
        "        self.swap_two_factors()\n",
        "        self.write_last_step()\n",
        "\n",
        "    def swap_two_factors(self):\n",
        "        left = self.left_factors[0]\n",
        "        right = self.right_factors[0]\n",
        "        arrow = Arrow(right, left, buff = SMALL_BUFF)\n",
        "        times_i = OldTex(\"\\\\times i\")\n",
        "        times_i.next_to(arrow, DOWN, 0)\n",
        "        times_i.add_background_rectangle()\n",
        "        curr_product = self.product_mobjects[0].copy()\n",
        "\n",
        "        for x in range(2):\n",
        "            self.swap_factors_at_index(0)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(times_i, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(curr_product.to_edge, LEFT)\n",
        "        self.swap_factors_at_index(0)\n",
        "        new_arrow = Arrow(\n",
        "            self.result_surrounding_rect, curr_product, \n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(arrow, new_arrow),\n",
        "            MaintainPositionRelativeTo(times_i, arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [arrow, times_i, curr_product])))\n",
        "\n",
        "class FactorsOfTwoNeitherHelpNorHurt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Factors of\", \"$2^k$\", \"neither \\\\\\\\ help nor hurt\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"2\", YELLOW)\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class EffectOfPowersOfTwo(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 9,\n",
        "        \"max_lattice_point_radius\" : 9,\n",
        "        \"square_radii\" : [5, 10, 20, 40, 80],\n",
        "    }\n",
        "    def construct(self):\n",
        "        radii = list(map(np.sqrt, self.square_radii))\n",
        "        circles = list(map(self.get_circle, radii))\n",
        "        radial_lines, root_labels = list(zip(*list(map(\n",
        "            self.get_radial_line_with_label, radii\n",
        "        ))))\n",
        "        dots_list = list(map(\n",
        "            self.get_lattice_points_on_r_squared_circle,\n",
        "            self.square_radii\n",
        "        ))\n",
        "        groups = [\n",
        "            VGroup(*mobs)\n",
        "            for mobs in zip(radial_lines, circles, root_labels, dots_list)\n",
        "        ]\n",
        "        group = groups[0]\n",
        "\n",
        "        self.add(group)\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, dots_list[0],\n",
        "            stroke_width = 4,\n",
        "            stroke_color = PINK\n",
        "        ))\n",
        "        self.wait()\n",
        "        for new_group in groups[1:]:\n",
        "            self.play(Transform(group, new_group))\n",
        "            self.wait(2)\n",
        "\n",
        "class NumberTheoryAtItsBest(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Number theory at its best!\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceChi(FactorizationPattern):\n",
        "    CONFIG = {\n",
        "        \"numbers_list\" : [\n",
        "            list(range(i, 36, d))\n",
        "            for i, d in [(1, 4), (3, 4), (2, 2)]\n",
        "        ],\n",
        "        \"colors\" : [GREEN, RED, YELLOW]\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_number_line()\n",
        "        self.add_define_chi_label()\n",
        "        for index in range(3):\n",
        "            self.describe_values(index)\n",
        "        self.fade_out_labels()\n",
        "        self.cyclic_pattern()\n",
        "        self.write_multiplicative_label()\n",
        "        self.show_multiplicative()\n",
        "\n",
        "\n",
        "    def add_define_chi_label(self):\n",
        "        label = OldTexText(\"Define $\\\\chi(n)$:\")\n",
        "        chi_expressions = VGroup(*[\n",
        "            self.get_chi_expression(numbers, color)\n",
        "            for numbers, color in zip(\n",
        "                self.numbers_list,\n",
        "                self.colors\n",
        "            )\n",
        "        ])\n",
        "        chi_expressions.scale(0.9)\n",
        "        chi_expressions.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        chi_expressions.to_corner(UP+RIGHT)\n",
        "        brace = Brace(chi_expressions, LEFT)\n",
        "        label.next_to(brace, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.define_chi_label = label\n",
        "        self.chi_expressions = chi_expressions\n",
        "\n",
        "    def describe_values(self, index):\n",
        "        numbers = self.numbers_list[index]\n",
        "        color = self.colors[index]\n",
        "        dots, arrows, labels = self.get_dots_arrows_and_labels(\n",
        "            numbers, color\n",
        "        )\n",
        "        chi_expression = self.chi_expressions[index]\n",
        "\n",
        "        self.introduce_dots_arrows_and_labels(dots, arrows, labels)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(VGroup(*[\n",
        "                part \n",
        "                for part in chi_expression\n",
        "                if part not in chi_expression.inputs\n",
        "            ])), \n",
        "        *[\n",
        "            ReplacementTransform(label.copy(), num_mob)\n",
        "            for label, num_mob in zip(\n",
        "                labels, chi_expression.inputs\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def fade_out_labels(self):\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.last_dots, self.last_arrows, self.last_labels,\n",
        "            self.number_line\n",
        "        ])))\n",
        "\n",
        "    def cyclic_pattern(self):\n",
        "        input_range = list(range(1, 9))\n",
        "        chis = VGroup(*[\n",
        "            OldTex(\"\\\\chi(%d)\"%n)\n",
        "            for n in input_range\n",
        "        ])\n",
        "        chis.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        chis.set_stroke(WHITE, width = 1)\n",
        "        numbers = VGroup()\n",
        "        arrows = VGroup()\n",
        "        for chi, n in zip(chis, input_range):\n",
        "            arrow = OldTex(\"\\\\Uparrow\")\n",
        "            arrow.next_to(chi, UP, SMALL_BUFF)\n",
        "            arrows.add(arrow)\n",
        "            value = OldTex(str(chi_func(n)))\n",
        "            for tex, color in zip([\"1\", \"-1\", \"0\"], self.colors):\n",
        "                value.set_color_by_tex(tex, color)\n",
        "            value.next_to(arrow, UP)\n",
        "            numbers.add(value)\n",
        "        group = VGroup(chis, arrows, numbers)\n",
        "        group.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        group.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(*[\n",
        "            FadeIn(\n",
        "                mob, \n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "            for mob in [chis, arrows, numbers]\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            numbers,\n",
        "            lambda m : (m.shift, MED_SMALL_BUFF*UP),\n",
        "            rate_func = there_and_back,\n",
        "            lag_ratio = 0.2,\n",
        "            run_time = 6\n",
        "        ))\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [chis, arrows, numbers])))\n",
        "\n",
        "    def write_multiplicative_label(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"$\\\\chi$ is ``multiplicative''\",\n",
        "            bubble_config = {\"height\" : 2.5, \"width\" : 5}\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.morty = morty\n",
        "\n",
        "    def show_multiplicative(self):\n",
        "        pairs = [(3, 5), (5, 5), (2, 13), (3, 11)]\n",
        "        expressions = VGroup()\n",
        "        for x, y in pairs:\n",
        "            expression = OldTex(\n",
        "                \"\\\\chi(%d)\"%x,\n",
        "                \"\\\\cdot\",\n",
        "                \"\\\\chi(%d)\"%y,\n",
        "                \"=\", \n",
        "                \"\\\\chi(%d)\"%(x*y)\n",
        "            )\n",
        "            braces = [\n",
        "                Brace(expression[i], UP) \n",
        "                for i in (0, 2, 4)\n",
        "            ]\n",
        "            for brace, n in zip(braces, [x, y, x*y]):\n",
        "                output = chi_func(n)\n",
        "                label = brace.get_tex(str(output))\n",
        "                label.set_color(self.number_to_color(output))\n",
        "                brace.add(label)\n",
        "                expression.add(brace)\n",
        "            expressions.add(expression)\n",
        "\n",
        "        expressions.next_to(ORIGIN, LEFT)\n",
        "        expressions.shift(DOWN)\n",
        "        expression = expressions[0]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(expression),\n",
        "            self.morty.change, \"pondering\", expression\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for new_expression in expressions[1:]:\n",
        "            self.play(Transform(expression, new_expression))\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_dots_arrows_and_labels(self, numbers, color):\n",
        "        dots = VGroup()\n",
        "        arrows = VGroup()\n",
        "        labels = VGroup()\n",
        "        for number in numbers:\n",
        "            point = self.number_line.number_to_point(number)\n",
        "            dot = Dot(point)\n",
        "            label = OldTex(str(number))\n",
        "            label.scale(0.8)\n",
        "            label.next_to(dot, UP, LARGE_BUFF)\n",
        "            arrow = Arrow(label, dot, buff = SMALL_BUFF)\n",
        "            VGroup(dot, label, arrow).set_color(color)\n",
        "            dots.add(dot)\n",
        "            arrows.add(arrow)\n",
        "            labels.add(label)\n",
        "        return dots, arrows, labels\n",
        "\n",
        "    def introduce_dots_arrows_and_labels(self, dots, arrows, labels):\n",
        "        if hasattr(self, \"last_dots\"):\n",
        "            self.play(\n",
        "                ReplacementTransform(self.last_dots, dots),\n",
        "                ReplacementTransform(self.last_arrows, arrows),\n",
        "                ReplacementTransform(self.last_labels, labels),\n",
        "            )\n",
        "        else:\n",
        "            self.play(\n",
        "                Write(labels),\n",
        "                FadeIn(arrows, lag_ratio = 0.5),\n",
        "                LaggedStartMap(\n",
        "                    DrawBorderThenFill, dots,\n",
        "                    stroke_width = 4,\n",
        "                    stroke_color = YELLOW\n",
        "                ),\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.last_dots = dots\n",
        "        self.last_arrows = arrows\n",
        "        self.last_labels = labels\n",
        "\n",
        "    def get_chi_expression(self, numbers, color, num_terms = 4):\n",
        "        truncated_numbers = numbers[:num_terms]\n",
        "        output = str(chi_func(numbers[0]))\n",
        "        result = OldTex(*it.chain(*[\n",
        "            [\"\\\\chi(\", str(n), \")\", \"=\"]\n",
        "            for n in truncated_numbers\n",
        "        ] + [\n",
        "            [\"\\\\cdots =\", output]\n",
        "        ]))\n",
        "        result.inputs = VGroup()\n",
        "        for n in truncated_numbers:\n",
        "            num_mob = result.get_part_by_tex(str(n), substring = False)\n",
        "            num_mob.set_color(color)\n",
        "            result.inputs.add(num_mob)\n",
        "        result.set_color_by_tex(output, color, substring = False)\n",
        "        return result\n",
        "\n",
        "    def number_to_color(self, n):\n",
        "        output = chi_func(n)\n",
        "        if n == 1:\n",
        "            return self.colors[0]\n",
        "        elif n == -1:\n",
        "            return self.colors[1]\n",
        "        else:\n",
        "            return self.colors[2]\n",
        "\n",
        "class WriteCountingRuleWithChi(SummarizeCountingRule):\n",
        "    CONFIG = {\n",
        "        \"colors\" : [GREEN, RED, YELLOW]\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_count_words()\n",
        "        self.draw_circle()\n",
        "        self.add_full_screen_rect()\n",
        "\n",
        "        self.add_factorization_and_rule()\n",
        "        self.write_chi_expression()\n",
        "        self.walk_through_expression_terms()\n",
        "        self.circle_four()\n",
        "\n",
        "    def add_factorization_and_rule(self):\n",
        "        factorization = OldTex(\n",
        "            \"N\", \"=\", \n",
        "            \"2\", \"^2\", \"\\\\cdot\",\n",
        "            \"3\", \"^4\", \"\\\\cdot\",\n",
        "            \"5\", \"^3\",\n",
        "        )\n",
        "        for tex, color in zip([\"5\", \"3\", \"2\"], self.colors):\n",
        "            factorization.set_color_by_tex(tex, color, substring = False)\n",
        "        factorization.to_edge(UP)\n",
        "        factorization.shift(LEFT)\n",
        "\n",
        "        count = VGroup(\n",
        "            OldTex(\"=\", \"4\"),\n",
        "            OldTex(\"(\", \"1\", \")\"),\n",
        "            OldTex(\"(\", \"1\", \")\"),\n",
        "            OldTex(\"(\", \"3+1\", \")\"),\n",
        "        )\n",
        "        count.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        for i, color in zip([3, 2, 1], self.colors):\n",
        "            count[i][1].set_color(color)\n",
        "        count.next_to(\n",
        "            factorization.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(factorization),\n",
        "            self.count_words.next_to, count, LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(factorization.get_part_by_tex(\n",
        "                    tex, substring = False\n",
        "                )).copy(),\n",
        "                part\n",
        "            )\n",
        "            for tex, part in zip([\"=\", \"2\", \"3\", \"5\"], count)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.factorization = factorization\n",
        "        self.count = count\n",
        "\n",
        "    def write_chi_expression(self):\n",
        "        equals_four = OldTex(\"=\", \"4\")\n",
        "        expression = VGroup(equals_four)\n",
        "        for n, k, color in zip([2, 3, 5], [2, 4, 3], reversed(self.colors)):\n",
        "            args = [\"(\", \"\\\\chi(\", \"1\", \")\", \"+\"]\n",
        "            for i in range(1, k+1):\n",
        "                args += [\"\\\\chi(\", str(n), \"^%d\"%i, \")\", \"+\"]\n",
        "            args[-1] = \")\"\n",
        "            factor = OldTex(*args)\n",
        "            factor.set_color_by_tex(str(n), color, substring = False)\n",
        "            factor.set_color_by_tex(\"1\", color, substring = False)\n",
        "            factor.scale(0.8)\n",
        "            expression.add(factor)\n",
        "        expression.arrange(\n",
        "            DOWN, buff = MED_SMALL_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        equals_four.next_to(expression[1], LEFT, SMALL_BUFF)\n",
        "        expression.shift(\n",
        "            self.count[0].get_center() + LARGE_BUFF*DOWN -\\\n",
        "            equals_four.get_center()\n",
        "        )\n",
        "\n",
        "        count_copy = self.count.copy()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                c_part.move_to, e_part, LEFT,\n",
        "                path_arc = -np.pi/2,\n",
        "                run_time = 2\n",
        "            )\n",
        "            for c_part, e_part in zip(count_copy, expression)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            count_copy, expression,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.chi_expression = expression\n",
        "\n",
        "    def walk_through_expression_terms(self):\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        groups = [\n",
        "            VGroup(\n",
        "                self.chi_expression[index],\n",
        "                self.count[index],\n",
        "                self.factorization.get_part_by_tex(tex1, substring = False),\n",
        "                self.factorization.get_part_by_tex(tex2, substring = False),\n",
        "            )\n",
        "            for index, tex1, tex2 in [\n",
        "                (-1, \"5\", \"^3\"), (-2, \"3\", \"^4\"), (-3, \"2\", \"^2\")\n",
        "            ]\n",
        "        ]\n",
        "        evaluation_strings = [\n",
        "            \"(1+1+1+1)\",\n",
        "            \"(1-1+1-1+1)\",\n",
        "            \"(1+0+0)\",\n",
        "        ]\n",
        "\n",
        "        for group, tex in zip(groups, evaluation_strings):\n",
        "            chi_sum, count, base, exp = group\n",
        "            brace = Brace(chi_sum, DOWN)\n",
        "            evaluation = brace.get_tex(*tex)\n",
        "            evaluation.set_color(base.get_color())\n",
        "            evaluation_rect = BackgroundRectangle(evaluation)\n",
        "\n",
        "            self.play(FadeIn(rect), Animation(group))\n",
        "            self.play(GrowFromCenter(brace))\n",
        "            self.play(\n",
        "                FadeIn(evaluation_rect),\n",
        "                ReplacementTransform(chi_sum.copy(), evaluation),\n",
        "            )\n",
        "            self.wait(2)\n",
        "            self.play(Indicate(count, color = PINK))\n",
        "            self.wait()\n",
        "            if base.get_tex() is \"3\":\n",
        "                new_exp = OldTex(\"3\")\n",
        "                new_exp.replace(exp)\n",
        "                count_num = count[1]\n",
        "                new_count = OldTex(\"0\")\n",
        "                new_count.replace(count_num, dim_to_match = 1)\n",
        "                new_count.set_color(count_num.get_color())\n",
        "                evaluation_point = VectorizedPoint(evaluation[-4].get_right())\n",
        "                chi_sum_point = VectorizedPoint(chi_sum[-7].get_right())\n",
        "                new_brace = Brace(VGroup(*chi_sum[:-6]), DOWN)\n",
        "\n",
        "                to_save = [brace, exp, evaluation, count_num, chi_sum]\n",
        "                for mob in to_save:\n",
        "                    mob.save_state()\n",
        "\n",
        "                self.play(FocusOn(exp))\n",
        "                self.play(Transform(exp, new_exp))\n",
        "                self.play(\n",
        "                    Transform(brace, new_brace),\n",
        "                    Transform(\n",
        "                        VGroup(*evaluation[-3:-1]),\n",
        "                        evaluation_point\n",
        "                    ),\n",
        "                    evaluation[-1].next_to, evaluation_point, RIGHT, SMALL_BUFF,\n",
        "                    Transform(\n",
        "                        VGroup(*chi_sum[-6:-1]),\n",
        "                        chi_sum_point\n",
        "                    ),\n",
        "                    chi_sum[-1].next_to, chi_sum_point, RIGHT, SMALL_BUFF\n",
        "                )\n",
        "                self.play(Transform(count_num, new_count))\n",
        "                self.play(Indicate(count_num, color = PINK))\n",
        "                self.wait()\n",
        "                self.play(*[mob.restore for mob in to_save])\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(VGroup(\n",
        "                    rect, brace, evaluation_rect, evaluation\n",
        "                )),\n",
        "                Animation(group)\n",
        "            )\n",
        "\n",
        "    def circle_four(self):\n",
        "        four = self.chi_expression[0][1]\n",
        "        rect = SurroundingRectangle(four)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class WeAreGettingClose(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"We're getting close...\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class ExpandCountWith45(SummarizeCountingRule):\n",
        "    CONFIG = {\n",
        "        \"N_str\" : \"45\",\n",
        "        \"coords_list\" : [(3, 6), (6, 3)],\n",
        "        \"radius_squared\" : 45,\n",
        "        \"y_radius\" : 7,\n",
        "        \"rect_opacity\" : 0.75,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_count_words()\n",
        "        self.draw_circle()\n",
        "        self.add_full_screen_rect()\n",
        "        self.add_factorization_and_count()\n",
        "        self.expand_expression()\n",
        "        self.show_divisor_sum()\n",
        "\n",
        "\n",
        "    def add_factorization_and_count(self):\n",
        "        factorization = OldTex(\n",
        "            \"45\", \"=\", \"3\", \"^2\", \"\\\\cdot\", \"5\",\n",
        "        )\n",
        "        for tex, color in zip([\"5\", \"3\",], [GREEN, RED]):\n",
        "            factorization.set_color_by_tex(tex, color, substring = False)\n",
        "        factorization.to_edge(UP)\n",
        "        factorization.shift(1.7*LEFT)\n",
        "\n",
        "        equals_four = OldTex(\"=\", \"4\")\n",
        "        expression = VGroup(equals_four)\n",
        "        for n, k, color in zip([3, 5], [2, 1], [RED, GREEN]):\n",
        "            args = [\"(\"]\n",
        "            [\"\\\\chi(1)\", \"+\"]\n",
        "            for i in range(k+1):\n",
        "                if i == 0:\n",
        "                    input_str = \"1\"\n",
        "                elif i == 1:\n",
        "                    input_str = str(n)\n",
        "                else:\n",
        "                    input_str = \"%d^%d\"%(n, i)\n",
        "                args += [\"\\\\chi(%s)\"%input_str, \"+\"]\n",
        "            args[-1] = \")\"\n",
        "            factor = OldTex(*args)\n",
        "            for part in factor[1::2]:\n",
        "                part[2].set_color(color)\n",
        "            factor.scale(0.8)\n",
        "            expression.add(factor)\n",
        "        expression.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        expression.next_to(\n",
        "            factorization[1], DOWN, \n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        braces = VGroup(*[\n",
        "            Brace(part, UP)\n",
        "            for part in expression[1:]\n",
        "        ])\n",
        "        for brace, num, color in zip(braces, [1, 2], [RED, GREEN]):\n",
        "            num_mob = brace.get_tex(str(num), buff = SMALL_BUFF)\n",
        "            num_mob.set_color(color)\n",
        "            brace.add(num_mob)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(factorization),\n",
        "            self.count_words.next_to, expression, LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(factorization.get_part_by_tex(\n",
        "                    tex, substring = False\n",
        "                )).copy(),\n",
        "                part\n",
        "            )\n",
        "            for tex, part in zip([\"=\", \"3\", \"5\"], expression)\n",
        "        ])\n",
        "        self.play(FadeIn(braces))\n",
        "        self.wait()\n",
        "\n",
        "        self.chi_expression = expression\n",
        "        self.factorization = factorization\n",
        "\n",
        "    def expand_expression(self):\n",
        "        equals, four, lp, rp = list(map(Tex, [\n",
        "            \"=\", \"4\", \"\\\\big(\", \"\\\\big)\"\n",
        "        ]))\n",
        "        expansion = VGroup(equals, four, lp)\n",
        "        chi_pairs = list(it.product(*[\n",
        "            factor[1::2]\n",
        "            for factor in self.chi_expression[1:]\n",
        "        ]))\n",
        "        num_pairs = list(it.product([1, 3, 9], [1, 5]))\n",
        "        products = list(it.starmap(op.mul, num_pairs))\n",
        "        sorted_indices = np.argsort(products)\n",
        "        mover_groups = [VGroup(), VGroup()]\n",
        "        plusses = VGroup()\n",
        "        prime_pairs = VGroup()\n",
        "        for index in sorted_indices:\n",
        "            pair = chi_pairs[index]\n",
        "            prime_pair = VGroup()\n",
        "            for chi, movers in zip(pair, mover_groups):\n",
        "                mover = chi.copy()\n",
        "                mover.generate_target()\n",
        "                expansion.add(mover.target)\n",
        "                movers.add(mover)\n",
        "                prime_pair.add(mover.target[2])\n",
        "            prime_pairs.add(prime_pair)\n",
        "            if index != sorted_indices[-1]:\n",
        "                plus = OldTex(\"+\")\n",
        "                plusses.add(plus)\n",
        "                expansion.add(plus)\n",
        "        expansion.add(rp)\n",
        "        expansion.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        expansion.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        expansion.next_to(ORIGIN, UP)\n",
        "        rect = BackgroundRectangle(expansion)\n",
        "        rect.stretch_in_place(1.5, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    self.chi_expression[i][j].copy(),\n",
        "                    mob\n",
        "                )\n",
        "                for i, j, mob in [\n",
        "                    (0, 0, equals),\n",
        "                    (0, 1, four),\n",
        "                    (1, 0, lp),\n",
        "                    (2, -1, rp),\n",
        "                ]\n",
        "            ]\n",
        "        )\n",
        "        for movers in mover_groups:\n",
        "            self.wait()\n",
        "            self.play(movers.next_to, rect, DOWN)\n",
        "            self.play(*list(map(MoveToTarget, movers)))\n",
        "        self.play(Write(plusses))\n",
        "        self.wait()\n",
        "\n",
        "        self.expansion = expansion\n",
        "        self.prime_pairs = prime_pairs\n",
        "\n",
        "    def show_divisor_sum(self):\n",
        "        equals, four, lp, rp = list(map(Tex, [\n",
        "            \"=\", \"4\", \"\\\\big(\", \"\\\\big)\"\n",
        "        ]))\n",
        "        divisor_sum = VGroup(equals, four, lp)\n",
        "\n",
        "        num_pairs = list(it.product([1, 3, 9], [1, 5]))\n",
        "        products = list(it.starmap(op.mul, num_pairs))\n",
        "        products.sort()\n",
        "        color = BLACK\n",
        "        product_mobs = VGroup()\n",
        "        chi_mobs = VGroup()\n",
        "        for product in products:\n",
        "            chi_mob = OldTex(\"\\\\chi(\", str(product), \")\")\n",
        "            product_mob = chi_mob.get_part_by_tex(str(product))\n",
        "            product_mob.set_color(color)\n",
        "            product_mobs.add(product_mob)\n",
        "            divisor_sum.add(chi_mob)\n",
        "            chi_mobs.add(chi_mob)\n",
        "            if product != products[-1]:\n",
        "                divisor_sum.add(OldTex(\"+\"))\n",
        "        divisor_sum.add(rp)\n",
        "        divisor_sum.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        divisor_sum.next_to(self.expansion, DOWN, MED_LARGE_BUFF)\n",
        "        rect = BackgroundRectangle(divisor_sum)\n",
        "\n",
        "        prime_pairs = self.prime_pairs.copy()\n",
        "        for prime_pair, product_mob in zip(prime_pairs, product_mobs):\n",
        "            prime_pair.target = product_mob.copy()\n",
        "            prime_pair.target.set_color(YELLOW)\n",
        "\n",
        "        braces = VGroup(*[Brace(m, DOWN) for m in chi_mobs])\n",
        "        for brace, product in zip(braces, products):\n",
        "            value = brace.get_tex(str(chi_func(product)))\n",
        "            brace.add(value)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Write(divisor_sum, run_time = 2)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, prime_pairs, \n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.25,\n",
        "        ))\n",
        "        self.remove(prime_pairs)\n",
        "        product_mobs.set_color(YELLOW)\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            product_mobs,\n",
        "            lambda m : (m.shift, MED_LARGE_BUFF*DOWN),\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.play(FadeIn(\n",
        "            braces, \n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class CountLatticePointsInBigCircle(LatticePointScene):\n",
        "    CONFIG = {\n",
        "        \"y_radius\" : 2*11,\n",
        "        \"max_lattice_point_radius\" : 10,\n",
        "        \"dot_radius\" : 0.05\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.resize_plane()\n",
        "        self.introduce_points()\n",
        "        self.show_rings()\n",
        "        self.ignore_center_dot()\n",
        "\n",
        "    def resize_plane(self):\n",
        "        self.plane.set_stroke(width = 2)\n",
        "        self.plane.scale(2)\n",
        "        self.lattice_points.scale(2)\n",
        "        for point in self.lattice_points:\n",
        "            point.scale(0.5)\n",
        "\n",
        "    def introduce_points(self):\n",
        "        circle = self.get_circle(radius = self.max_lattice_point_radius)\n",
        "        radius = Line(ORIGIN, circle.get_right())\n",
        "        radius.set_color(RED)\n",
        "        R = OldTex(\"R\").next_to(radius, UP)\n",
        "        R_rect = BackgroundRectangle(R)\n",
        "        R_group = VGroup(R_rect, R)\n",
        "        pi_R_squared = OldTex(\"\\\\pi\", \"R\", \"^2\")\n",
        "        pi_R_squared.next_to(ORIGIN, UP)\n",
        "        pi_R_squared.to_edge(RIGHT)\n",
        "        pi_R_squared_rect = BackgroundRectangle(pi_R_squared)\n",
        "        pi_R_squared_group = VGroup(pi_R_squared_rect, pi_R_squared)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [circle, radius, R_group])))\n",
        "        self.add_foreground_mobject(R_group)\n",
        "        self.draw_lattice_points()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(R_rect),\n",
        "            FadeIn(pi_R_squared_rect),\n",
        "            ReplacementTransform(R, pi_R_squared.get_part_by_tex(\"R\")),\n",
        "            Write(VGroup(*[\n",
        "                part for part in pi_R_squared\n",
        "                if part is not pi_R_squared.get_part_by_tex(\"R\")\n",
        "            ]))\n",
        "        )\n",
        "        self.remove(R_group)\n",
        "        self.add_foreground_mobject(pi_R_squared_group)\n",
        "        self.wait()\n",
        "\n",
        "        self.circle = circle\n",
        "        self.radius = radius\n",
        "\n",
        "    def show_rings(self):\n",
        "        N_range = list(range(self.max_lattice_point_radius**2))\n",
        "        rings = VGroup(*[\n",
        "            self.get_circle(radius = np.sqrt(N))\n",
        "            for N in N_range\n",
        "        ])\n",
        "        rings.set_color_by_gradient(TEAL, GREEN)\n",
        "        rings.set_stroke(width = 2)\n",
        "        dot_groups = VGroup(*[\n",
        "            self.get_lattice_points_on_r_squared_circle(N)\n",
        "            for N in N_range\n",
        "        ])\n",
        "        radicals = self.get_radicals()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, rings),\n",
        "            Animation(self.lattice_points),\n",
        "            LaggedStartMap(FadeIn, radicals),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.add_foreground_mobject(radicals)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod,\n",
        "                dot_groups,\n",
        "                lambda m : (m.set_stroke, PINK, 5),\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 4,\n",
        "                lag_ratio = 0.1,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.rings = rings\n",
        "\n",
        "    def ignore_center_dot(self):\n",
        "        center_dot = self.lattice_points[0]\n",
        "        circle = Circle(color = RED)\n",
        "        circle.replace(center_dot)\n",
        "        circle.scale(2)\n",
        "        arrow = Arrow(ORIGIN, UP+RIGHT, color = RED)\n",
        "        arrow.next_to(circle, DOWN+LEFT, SMALL_BUFF)\n",
        "        new_max = 2*self.max_lattice_point_radius\n",
        "        new_dots = VGroup(*[\n",
        "            Dot(\n",
        "                self.plane.coords_to_point(x, y),\n",
        "                color = self.dot_color,\n",
        "                radius = self.dot_radius,\n",
        "            )\n",
        "            for x in range(-new_max, new_max+1)\n",
        "            for y in range(-new_max, new_max+1)\n",
        "            if (x**2 + y**2) > self.max_lattice_point_radius**2\n",
        "            if (x**2 + y**2) < new_max**2\n",
        "        ])\n",
        "        new_dots.sort(get_norm)\n",
        "\n",
        "        self.play(*list(map(ShowCreation, [circle, arrow])))\n",
        "        self.play(*list(map(FadeOut, [circle, arrow])))\n",
        "        self.play(FadeOut(center_dot))\n",
        "        self.lattice_points.remove(center_dot)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(m.scale, 0.5)\n",
        "            for m in [\n",
        "                self.plane,\n",
        "                self.circle,\n",
        "                self.radius,\n",
        "                self.rings,\n",
        "                self.lattice_points\n",
        "            ]\n",
        "        ])\n",
        "        new_dots.scale(0.5)\n",
        "        self.play(FadeOut(self.rings))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VGroup(self.circle, self.radius).scale, 2,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                DrawBorderThenFill,\n",
        "                new_dots,\n",
        "                stroke_width = 4,\n",
        "                stroke_color = PINK,\n",
        "                lag_ratio = 0.2,\n",
        "            ),\n",
        "            run_time = 4,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    #####\n",
        "\n",
        "    @staticmethod\n",
        "    def get_radicals():\n",
        "        radicals = VGroup(*[\n",
        "            OldTex(\"\\\\sqrt{%d}\"%N)\n",
        "            for N in range(1, 13)\n",
        "        ])\n",
        "        radicals.add(\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            OldTex(\"\\\\sqrt{R^2}\")\n",
        "        )\n",
        "        radicals.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        radicals.set_height(FRAME_HEIGHT - MED_LARGE_BUFF)\n",
        "        radicals.to_edge(DOWN, buff = MED_SMALL_BUFF)\n",
        "        radicals.to_edge(LEFT)\n",
        "        for radical in radicals:\n",
        "            radical.add_background_rectangle()\n",
        "        return radicals\n",
        "\n",
        "class AddUpGrid(Scene):\n",
        "    def construct(self):\n",
        "        self.add_radicals()\n",
        "        self.add_row_lines()\n",
        "        self.add_chi_sums()\n",
        "        self.put_four_in_corner()\n",
        "        self.talk_through_rows()\n",
        "        self.organize_into_columns()\n",
        "        self.add_count_words()\n",
        "        self.collapse_columns()\n",
        "        self.factor_out_R()\n",
        "        self.show_chi_sum_values()\n",
        "        self.compare_to_pi_R_squared()\n",
        "        self.celebrate()\n",
        "\n",
        "    def add_radicals(self):\n",
        "        self.radicals = CountLatticePointsInBigCircle.get_radicals()\n",
        "        self.add(self.radicals)\n",
        "\n",
        "    def add_row_lines(self):\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS - MED_LARGE_BUFF)\n",
        "        h_line.set_stroke(WHITE, 1)\n",
        "        row_lines = VGroup(*[\n",
        "            h_line.copy().next_to(\n",
        "                radical, DOWN,\n",
        "                buff = SMALL_BUFF,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "            for radical in self.radicals\n",
        "        ])\n",
        "        row_lines[-2].shift(\n",
        "            row_lines[-1].get_left()[0]*RIGHT -\\\n",
        "            row_lines[-2].get_left()[0]*RIGHT\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, row_lines))\n",
        "        self.wait()\n",
        "\n",
        "        self.row_lines = row_lines\n",
        "\n",
        "    def add_chi_sums(self):\n",
        "        chi_sums = VGroup()\n",
        "        chi_mobs = VGroup()\n",
        "        plusses = VGroup()\n",
        "        fours = VGroup()\n",
        "        parens = VGroup()\n",
        "        arrows = VGroup()\n",
        "        for N, radical in zip(list(range(1, 13)), self.radicals):\n",
        "            arrow, four, lp, rp = list(map(Tex, [\n",
        "                \"\\\\Rightarrow\", \"4\", \"\\\\big(\", \"\\\\big)\"\n",
        "            ]))\n",
        "            fours.add(four)\n",
        "            parens.add(lp, rp)\n",
        "            arrows.add(arrow)\n",
        "            chi_sum = VGroup(arrow, four, lp)\n",
        "            for d in range(1, N+1):\n",
        "                if N%d != 0:\n",
        "                    continue\n",
        "                chi_mob = OldTex(\"\\\\chi(\", str(d), \")\")\n",
        "                chi_mob[1].set_color(YELLOW)\n",
        "                chi_mob.d = d\n",
        "                chi_mobs.add(chi_mob)\n",
        "                chi_sum.add(chi_mob)\n",
        "                if d != N:\n",
        "                    plus = OldTex(\"+\")\n",
        "                    plus.chi_mob = chi_mob\n",
        "                    plusses.add(plus)\n",
        "                    chi_sum.add(plus)\n",
        "            chi_sum.add(rp)\n",
        "            chi_sum.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            chi_sum.scale(0.7)\n",
        "            chi_sum.next_to(radical, RIGHT)\n",
        "            chi_sums.add(chi_sum)\n",
        "            radical.chi_sum = chi_sum\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            Write, chi_sums, \n",
        "            run_time = 5,\n",
        "            rate_func = lambda t : t,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        digest_locals(self, [\n",
        "            \"chi_sums\", \"chi_mobs\", \"plusses\", \n",
        "            \"fours\", \"parens\", \"arrows\",\n",
        "        ])\n",
        "\n",
        "    def put_four_in_corner(self):\n",
        "        corner_four = OldTex(\"4\")\n",
        "        corner_four.to_corner(DOWN+RIGHT, buff = MED_SMALL_BUFF)\n",
        "        rect = SurroundingRectangle(corner_four, color = BLUE)\n",
        "        corner_four.rect = rect\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.fours, VGroup(corner_four),\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            FadeOut(self.parens)\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "\n",
        "        self.corner_four = corner_four\n",
        "\n",
        "    def talk_through_rows(self):\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLUE_C,\n",
        "            fill_opacity = 0.3,\n",
        "        )\n",
        "        rect.stretch_to_fit_width(\n",
        "            VGroup(self.radicals, self.chi_mobs).get_width()\n",
        "        )\n",
        "        rect.stretch_to_fit_height(self.radicals[0].get_height())\n",
        "\n",
        "        composite_rects, prime_rects = [\n",
        "            VGroup(*[\n",
        "                rect.copy().move_to(self.radicals[N-1], LEFT)\n",
        "                for N in numbers\n",
        "            ])\n",
        "            for numbers in ([6, 12], [2, 3, 5, 7, 11])\n",
        "        ]\n",
        "        prime_rects.set_color(GREEN)\n",
        "\n",
        "        randy = Randolph().flip()\n",
        "        randy.next_to(self.chi_mobs, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change_mode, \"pleading\")\n",
        "        self.play(\n",
        "            FadeIn(composite_rects),\n",
        "            randy.look_at, composite_rects.get_bottom()\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(composite_rects),\n",
        "            FadeIn(prime_rects),\n",
        "            randy.look_at, prime_rects.get_top(),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [prime_rects, randy])))\n",
        "\n",
        "    def organize_into_columns(self):\n",
        "        left_x = self.arrows.get_right()[0] + SMALL_BUFF\n",
        "        spacing = self.chi_mobs[-1].get_width() + SMALL_BUFF\n",
        "        for chi_mob in self.chi_mobs:\n",
        "            y = chi_mob.get_left()[1]\n",
        "            x = left_x + (chi_mob.d - 1)*spacing\n",
        "            chi_mob.generate_target()\n",
        "            chi_mob.target.move_to(x*RIGHT + y*UP, LEFT)\n",
        "        for plus in self.plusses:\n",
        "            plus.generate_target()\n",
        "            plus.target.scale(0.5)\n",
        "            plus.target.next_to(\n",
        "                plus.chi_mob.target, RIGHT, SMALL_BUFF\n",
        "            )\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(MoveToTarget, self.chi_mobs)),\n",
        "            list(map(MoveToTarget, self.plusses)),\n",
        "        ), run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "    def add_count_words(self):\n",
        "        rect = Rectangle(\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 2,\n",
        "            fill_color = average_color(BLUE_E, BLACK),\n",
        "            fill_opacity = 1,\n",
        "            height = 1.15,\n",
        "            width = FRAME_WIDTH - 2*MED_SMALL_BUFF,\n",
        "        )\n",
        "        rect.move_to(3*LEFT, LEFT)\n",
        "        rect.to_edge(UP, buff = SMALL_BUFF)\n",
        "        words = OldTexText(\"Total\")\n",
        "        words.scale(0.8)\n",
        "        words.next_to(rect.get_left(), RIGHT, SMALL_BUFF)\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.scale(0.7)\n",
        "        approx.next_to(words, RIGHT, SMALL_BUFF)\n",
        "        words.add(approx)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [rect, words])))\n",
        "        self.wait()\n",
        "\n",
        "        self.count_rect = rect\n",
        "        self.count_words = words\n",
        "\n",
        "    def collapse_columns(self):\n",
        "        chi_mob_columns = [VGroup() for i in range(12)]\n",
        "        for chi_mob in self.chi_mobs:\n",
        "            chi_mob_columns[chi_mob.d - 1].add(chi_mob)\n",
        "\n",
        "        full_sum = VGroup()\n",
        "        for d in range(1, 7):\n",
        "            R_args = [\"{R^2\"]\n",
        "            if d != 1:\n",
        "                R_args.append(\"\\\\over %d}\"%d)\n",
        "            term = VGroup(\n",
        "                OldTex(*R_args),\n",
        "                OldTex(\"\\\\chi(\", str(d), \")\"),\n",
        "                OldTex(\"+\")\n",
        "            )\n",
        "            term.arrange(RIGHT, SMALL_BUFF)\n",
        "            term[1][1].set_color(YELLOW)\n",
        "            full_sum.add(term)\n",
        "        full_sum.arrange(RIGHT, SMALL_BUFF)\n",
        "        full_sum.scale(0.7)\n",
        "        full_sum.next_to(self.count_words, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        for column, term in zip(chi_mob_columns, full_sum):\n",
        "            rect = SurroundingRectangle(column)\n",
        "            rect.stretch_to_fit_height(FRAME_HEIGHT)\n",
        "            rect.move_to(column, UP)\n",
        "            rect.set_stroke(width = 0)\n",
        "            rect.set_fill(YELLOW, 0.3)\n",
        "\n",
        "            self.play(FadeIn(rect))\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    column.copy(),\n",
        "                    VGroup(term[1]),\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                Write(term[0]),\n",
        "                Write(term[2]),\n",
        "            )\n",
        "            self.wait()\n",
        "            if term is full_sum[2]:\n",
        "                vect = sum([\n",
        "                    self.count_rect.get_left()[0],\n",
        "                    FRAME_X_RADIUS,\n",
        "                    -MED_SMALL_BUFF,\n",
        "                ])*LEFT\n",
        "                self.play(*[\n",
        "                    ApplyMethod(m.shift, vect)\n",
        "                    for m in [\n",
        "                        self.count_rect,\n",
        "                        self.count_words,\n",
        "                    ]+list(full_sum[:3])\n",
        "                ])\n",
        "                VGroup(*full_sum[3:]).shift(vect)\n",
        "            self.play(FadeOut(rect))\n",
        "\n",
        "        self.full_sum = full_sum\n",
        "\n",
        "    def factor_out_R(self):\n",
        "        self.corner_four.generate_target()\n",
        "        R_squared = OldTex(\"R^2\")\n",
        "        dots = OldTex(\"\\\\cdots\")\n",
        "        lp, rp = list(map(Tex, [\"\\\\big(\", \"\\\\big)\"]))\n",
        "        new_sum = VGroup(\n",
        "            self.corner_four.target, R_squared, lp\n",
        "        )\n",
        "\n",
        "        R_fracs, chi_terms, plusses = full_sum_parts = [\n",
        "            VGroup(*[term[i] for term in self.full_sum])\n",
        "            for i in range(3)\n",
        "        ]\n",
        "        targets = []\n",
        "        for part in full_sum_parts:\n",
        "            part.generate_target()\n",
        "            targets.append(part.target)\n",
        "        for R_frac, chi_term, plus in zip(*targets):\n",
        "            chi_term.scale(0.9)\n",
        "            chi_term.move_to(R_frac[0], DOWN)\n",
        "            if R_frac is R_fracs.target[0]:\n",
        "                new_sum.add(chi_term)\n",
        "            else:\n",
        "                new_sum.add(VGroup(chi_term, R_frac[1]))\n",
        "            new_sum.add(plus)\n",
        "        new_sum.add(dots)\n",
        "        new_sum.add(rp)\n",
        "        new_sum.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        new_sum.next_to(self.count_words, RIGHT, SMALL_BUFF)\n",
        "        R_squared.shift(0.5*SMALL_BUFF*UP)\n",
        "        R_movers = VGroup()\n",
        "        for R_frac in R_fracs.target:\n",
        "            if R_frac is R_fracs.target[0]:\n",
        "                mover = R_frac\n",
        "            else:\n",
        "                mover = R_frac[0]\n",
        "            Transform(mover, R_squared).update(1)\n",
        "            R_movers.add(mover)\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, [lp, rp, dots])), \n",
        "            list(map(MoveToTarget, full_sum_parts)),\n",
        "        ), run_time = 2)\n",
        "        self.remove(R_movers)\n",
        "        self.add(R_squared)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(self.corner_four, run_time = 2),\n",
        "            FadeOut(self.corner_four.rect)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.remove(self.full_sum, self.corner_four)\n",
        "        self.add(new_sum)\n",
        "\n",
        "        self.new_sum = new_sum\n",
        "\n",
        "    def show_chi_sum_values(self):\n",
        "        alt_rhs = OldTex(\n",
        "            \"\\\\approx\", \"4\", \"R^2\", \n",
        "            \"\\\\left(1 - \\\\frac{1}{3} + \\\\frac{1}{5}\" + \\\n",
        "            \"-\\\\frac{1}{7} + \\\\frac{1}{9} - \\\\frac{1}{11}\" + \\\n",
        "            \"+ \\\\cdots \\\\right)\",\n",
        "        )\n",
        "        alt_rhs.scale(0.9)\n",
        "        alt_rhs.next_to(\n",
        "            self.count_words[-1], DOWN,\n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            *list(map(FadeOut, [\n",
        "                self.chi_mobs, self.plusses, self.arrows,\n",
        "                self.radicals, self.row_lines\n",
        "            ])) + [\n",
        "            FadeOut(self.count_rect),\n",
        "            Animation(self.new_sum),\n",
        "            Animation(self.count_words),\n",
        "            ]\n",
        "        )\n",
        "        self.play(Write(alt_rhs))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.alt_rhs = alt_rhs\n",
        "\n",
        "    def compare_to_pi_R_squared(self):\n",
        "        approx, pi, R_squared = area_rhs = OldTex(\n",
        "            \"\\\\approx\", \"\\\\pi\", \"R^2\"\n",
        "        )\n",
        "        area_rhs.next_to(self.alt_rhs, RIGHT)\n",
        "\n",
        "        brace = Brace(\n",
        "            VGroup(self.alt_rhs, area_rhs), DOWN\n",
        "        )\n",
        "        brace.add(brace.get_text(\n",
        "            \"Arbitrarily good as $R \\\\to \\\\infty$\"\n",
        "        ))\n",
        "\n",
        "        pi_sum = OldTex(\n",
        "            \"4\", self.alt_rhs[-1].get_tex(),\n",
        "            \"=\", \"\\\\pi\"\n",
        "        )\n",
        "        pi_sum.scale(0.9)\n",
        "        pi = pi_sum.get_part_by_tex(\"pi\")\n",
        "        pi.scale(2, about_point = pi.get_left())\n",
        "        pi.set_color(YELLOW)\n",
        "        pi_sum.shift(\n",
        "            self.alt_rhs[-1].get_bottom(),\n",
        "            MED_SMALL_BUFF*DOWN,\n",
        "            -pi_sum[1].get_top()\n",
        "        )\n",
        "\n",
        "        self.play(Write(area_rhs))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(brace))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(brace))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(m.copy(), pi_sum_part)\n",
        "            for pi_sum_part, m in zip(pi_sum, [\n",
        "                self.alt_rhs.get_part_by_tex(\"4\"),\n",
        "                self.alt_rhs[-1],\n",
        "                area_rhs[0],\n",
        "                area_rhs[1],\n",
        "            ])\n",
        "        ])\n",
        "\n",
        "    def celebrate(self):\n",
        "        creatures = TeacherStudentsScene().get_pi_creatures()\n",
        "        self.play(FadeIn(creatures))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"hooray\", self.alt_rhs)\n",
        "            for pi in creatures\n",
        "        ])\n",
        "        self.wait()\n",
        "        for i in 0, 2, 3:\n",
        "            self.play(Blink(creatures[i]))\n",
        "            self.wait()\n",
        "\n",
        "class IntersectionOfTwoFields(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        circles = VGroup()\n",
        "        for vect, color, adj in (LEFT, BLUE, \"Algebraic\"), (RIGHT, YELLOW, \"Analytic\"):\n",
        "            circle = Circle(color = WHITE)\n",
        "            circle.set_fill(color, opacity = 0.3)\n",
        "            circle.stretch_to_fit_width(7)\n",
        "            circle.stretch_to_fit_height(4)\n",
        "            circle.shift(FRAME_X_RADIUS*vect/3.0 + LEFT)\n",
        "            title = OldTexText(\"%s \\\\\\\\ number theory\"%adj)\n",
        "            title.scale(0.7)\n",
        "            title.move_to(circle)\n",
        "            title.to_edge(UP, buff = SMALL_BUFF)\n",
        "            circle.next_to(title, DOWN, SMALL_BUFF)\n",
        "            title.set_color(color)\n",
        "            circle.title = title\n",
        "            circles.add(circle)\n",
        "        new_number_systems = OldTexText(\n",
        "            \"New \\\\\\\\ number systems\"\n",
        "        )\n",
        "        gaussian_integers = OldTexText(\n",
        "            \"e.g. Gaussian \\\\\\\\ integers\"\n",
        "        )\n",
        "        new_number_systems.next_to(circles[0].get_top(), DOWN, MED_SMALL_BUFF)\n",
        "        new_number_systems.shift(MED_LARGE_BUFF*(DOWN+2*LEFT))\n",
        "        gaussian_integers.next_to(new_number_systems, DOWN)\n",
        "        gaussian_integers.set_color(BLUE)\n",
        "        circles[0].words = VGroup(new_number_systems, gaussian_integers)\n",
        "\n",
        "        zeta = OldTex(\"\\\\zeta(s) = \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\")\n",
        "        L_function = OldTex(\n",
        "            \"L(s, \\\\chi) = \\\\sum_{n=1}^\\\\infty \\\\frac{\\\\chi(n)}{n^s}\"\n",
        "        )\n",
        "        for mob in zeta, L_function:\n",
        "            mob.scale(0.8)\n",
        "        zeta.next_to(circles[1].get_top(), DOWN, MED_LARGE_BUFF)\n",
        "        zeta.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        L_function.next_to(zeta, DOWN, MED_LARGE_BUFF)\n",
        "        L_function.set_color(YELLOW)\n",
        "        circles[1].words = VGroup(zeta, L_function)\n",
        "\n",
        "        mid_words = OldTexText(\"Where\\\\\\\\ we \\\\\\\\ were\")\n",
        "        mid_words.scale(0.7)\n",
        "        mid_words.move_to(circles)\n",
        "\n",
        "        for circle in circles:\n",
        "            self.play(\n",
        "                Write(circle.title, run_time = 2),\n",
        "                DrawBorderThenFill(circle, run_time = 2),\n",
        "                self.teacher.change_mode, \"raise_right_hand\"\n",
        "            )\n",
        "        self.wait()\n",
        "        for circle in circles:\n",
        "            for word in circle.words:\n",
        "                self.play(\n",
        "                    Write(word, run_time = 2),\n",
        "                    self.teacher.change, \"speaking\",\n",
        "                    *[\n",
        "                        ApplyMethod(pi.change, \"pondering\")\n",
        "                        for pi in self.get_students()\n",
        "                    ]\n",
        "                )\n",
        "                self.wait()\n",
        "        self.play(\n",
        "            Write(mid_words),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"thinking\"]*3,\n",
        "            look_at = mid_words\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class LeibnizPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Guido Gambardella\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"John Haley\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Suraj Pratap\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Ahmad Bamieh\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Sponsorship(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        logo = SVGMobject(\n",
        "            file_name = \"remix_logo\",\n",
        "        )\n",
        "        logo.set_height(1)\n",
        "        logo.center()\n",
        "        logo.set_stroke(width = 0)\n",
        "        logo.set_fill(BLUE_D, 1)\n",
        "        VGroup(*logo[6:]).set_color_by_gradient(BLUE_B, BLUE_E)\n",
        "        logo.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "\n",
        "        url = OldTexText(\"www.remix.com\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "        rect = ScreenRectangle(height = 5)\n",
        "        rect.next_to(url, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            LaggedStartMap(DrawBorderThenFill, logo, run_time = 3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            logo.scale, 0.8,\n",
        "            logo.to_corner, UP+RIGHT,\n",
        "            morty.change, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(url))\n",
        "        self.wait(3)\n",
        "        for mode in \"confused\", \"pondering\", \"happy\":\n",
        "            self.play(morty.change_mode, mode)\n",
        "            self.wait(3)\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.set_height(5)\n",
        "        body_copy = randy.body.copy()\n",
        "        body_copy.set_stroke(YELLOW, width = 3)\n",
        "        body_copy.set_fill(opacity = 0)\n",
        "        self.add(randy)\n",
        "\n",
        "        primes = [\n",
        "            n for n in range(2, 1000)\n",
        "            if all(n%k != 0 for k in list(range(2, n)))\n",
        "        ]\n",
        "        prime_mobs = VGroup()\n",
        "        x_spacing = 1.7\n",
        "        y_spacing = 1.5\n",
        "        n_rows = 10\n",
        "        n_cols = 8\n",
        "        for i, prime in enumerate(primes[:n_rows*n_cols]):\n",
        "            prime_mob = Integer(prime)\n",
        "            prime_mob.scale(1.5)\n",
        "            x = i%n_cols\n",
        "            y = i//n_cols\n",
        "            prime_mob.shift(x*x_spacing*RIGHT + y*y_spacing*DOWN)\n",
        "            prime_mobs.add(prime_mob)\n",
        "            prime_mob.set_color({\n",
        "                -1 : YELLOW,\n",
        "                0 : RED,\n",
        "                1 : BLUE_C,\n",
        "            }[chi_func(prime)])\n",
        "        prime_mobs.center().to_edge(UP)\n",
        "        for i in range(7):\n",
        "            self.add(SurroundingRectangle(\n",
        "                VGroup(*prime_mobs[n_cols*i:n_cols*(i+1)]),\n",
        "                fill_opacity = 0.7,\n",
        "                fill_color = BLACK,\n",
        "                stroke_width = 0,\n",
        "                buff = 0,\n",
        "            ))\n",
        "        self.add(prime_mobs)\n",
        "        self.add(body_copy)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}