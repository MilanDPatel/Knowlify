{
    "topic": "The mathematical concept being demonstrated is the derivative and integral of a function.",
    "code": [
        "# -*- coding: utf-8 -*-\n",
        "from manim_imports_ext import *\n",
        "\n",
        "class Chapter7OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \" Calculus required \",\n",
        "            \"continuity\",\n",
        "            \", and \",\n",
        "            \"continuity \",\n",
        "            \"was supposed to require the \",\n",
        "            \"infinitely little\",\n",
        "            \"; but nobody could discover what the \",\n",
        "            \"infinitely little\",\n",
        "            \" might be. \",\n",
        "        ],\n",
        "        \"quote_arg_separator\" : \"\",\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"continuity\" : BLUE,\n",
        "            \"infinitely\" : GREEN,\n",
        "        },\n",
        "        \"author\" : \"Bertrand Russell\",\n",
        "    }\n",
        "\n",
        "class ThisVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        deriv_videos = VGroup(*series[1:6])\n",
        "        this_video = series[6]\n",
        "        integral_videos = VGroup(*series[7:9])\n",
        "        video_groups = [deriv_videos, this_video, integral_videos]\n",
        "\n",
        "        braces = list(map(Brace, video_groups))\n",
        "        deriv_brace, this_brace, integral_brace = braces\n",
        "\n",
        "        tex_mobs = [\n",
        "            OldTex(*args)\n",
        "            for args in [\n",
        "                (\"{df \", \" \\\\over \\\\, \", \" dx}\"),\n",
        "                (\"\\\\lim_{h \\\\to 0}\",),\n",
        "                (\"\\\\int \", \"f(x)\", \"\\\\,dx\"),\n",
        "            ]\n",
        "        ]\n",
        "        deriv_tex, this_tex, integral_tex = tex_mobs\n",
        "        for tex_mob, brace in zip(tex_mobs, braces):\n",
        "            tex_mob.set_color_by_tex(\"f\", GREEN)\n",
        "            tex_mob.set_color_by_tex(\"dx\", YELLOW)\n",
        "            tex_mob.next_to(brace, DOWN)\n",
        "        integral_tex.shift(LARGE_BUFF*RIGHT)\n",
        "\n",
        "        lim_to_deriv_arrow = Arrow(this_tex, deriv_tex, color = WHITE)\n",
        "\n",
        "        self.add(series)\n",
        "        for index in 0, 2:\n",
        "            videos = video_groups[index]\n",
        "            brace = braces[index]\n",
        "            tex_mob = tex_mobs[index]\n",
        "            self.play(ApplyWave(\n",
        "                videos,\n",
        "                direction = DOWN,\n",
        "            ))\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(tex_mob, run_time = 2)\n",
        "            )\n",
        "        self.play(\n",
        "            this_video.set_color, YELLOW,\n",
        "            GrowFromCenter(this_brace),\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "            self.get_teacher().look_at, this_video\n",
        "        )\n",
        "        self.play(Write(this_tex))\n",
        "        self.wait(2)\n",
        "        self.play(self.get_teacher().change_mode, \"sassy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class LimitJustMeansApproach(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"dx_color\" : GREEN,\n",
        "        \"max_num_zeros\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        limit_expression = self.get_limit_expression()\n",
        "        limit_expression.shift(2*LEFT)\n",
        "        limit_expression.to_edge(UP)\n",
        "\n",
        "        evaluated_expressions = self.get_evaluated_expressions()\n",
        "        evaluated_expressions.next_to(limit_expression, DOWN, buff = LARGE_BUFF)\n",
        "        brace = Brace(evaluated_expressions[0][-1], DOWN)\n",
        "        question = OldTexText(\"What does this ``approach''?\")\n",
        "        question.next_to(brace, DOWN)\n",
        "\n",
        "        point = VectorizedPoint(limit_expression.get_right())\n",
        "        expression = VGroup(\n",
        "            limit_expression[1].copy(), \n",
        "            point, point.copy()\n",
        "        )\n",
        "        self.add(limit_expression)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        for next_expression in evaluated_expressions:\n",
        "            next_expression.move_to(evaluated_expressions[0], RIGHT)\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    expression, next_expression,\n",
        "                    lag_ratio = 0.5,\n",
        "                ),\n",
        "                self.pi_creature.look_at, next_expression[-1]\n",
        "            )\n",
        "            if brace not in self.get_mobjects():\n",
        "                self.play(\n",
        "                    GrowFromCenter(brace),\n",
        "                    Write(question)\n",
        "                )\n",
        "            self.wait(0.5)\n",
        "        self.wait(2)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Mortimer().flip()\n",
        "        self.pi_creature.to_corner(DOWN+LEFT)\n",
        "        return self.pi_creature\n",
        "\n",
        "    def get_limit_expression(self):\n",
        "        lim = OldTex(\"\\\\lim_\", \"{dx\", \" \\\\to 0}\")\n",
        "        lim.set_color_by_tex(\"dx\", self.dx_color)\n",
        "        ratio = self.get_expression(\"dx\")\n",
        "        ratio.next_to(lim, RIGHT)\n",
        "        limit_expression = VGroup(lim, ratio)\n",
        "        return limit_expression\n",
        "\n",
        "    def get_evaluated_expressions(self):\n",
        "        result = VGroup()\n",
        "        for num_zeros in range(1, self.max_num_zeros+1):\n",
        "            dx_str = \"0.\" + \"0\"*num_zeros + \"1\"\n",
        "            expression = self.get_expression(dx_str)            \n",
        "            dx = float(dx_str)\n",
        "            ratio = ((2+dx)**3-2**3)/dx\n",
        "            ratio_mob = OldTex(\"%.6f\\\\dots\"%ratio)\n",
        "            group = VGroup(expression, OldTex(\"=\"), ratio_mob)\n",
        "            group.arrange(RIGHT)\n",
        "            result.add(group)\n",
        "        return result\n",
        "\n",
        "    def get_expression(self, dx):\n",
        "        result = OldTex(\n",
        "            \"{(2 + \", str(dx), \")^3 - 2^3 \\\\over\", str(dx)\n",
        "        )\n",
        "        result.set_color_by_tex(dx, self.dx_color)\n",
        "        return result\n",
        "\n",
        "class Goals(Scene):\n",
        "    def construct(self):\n",
        "        goals = [\n",
        "            OldTexText(\"Goal %d:\"%d, s)\n",
        "            for d, s in [\n",
        "                (1, \"Formal definition of derivatives\"),\n",
        "                (2, \"$(\\\\epsilon, \\\\delta)$ definition of a limit\"),\n",
        "                (3, \"L'H\u00f4pital's rule\"),\n",
        "            ]\n",
        "        ]\n",
        "        for goal in goals:\n",
        "            goal.scale(1.3)\n",
        "            goal.shift(3*DOWN).to_edge(LEFT)\n",
        "\n",
        "        curr_goal = goals[0]\n",
        "        self.play(FadeIn(curr_goal))\n",
        "        self.wait(2)\n",
        "        for goal in goals[1:]:\n",
        "            self.play(Transform(curr_goal, goal))\n",
        "            self.wait(2)\n",
        "\n",
        "class RefreshOnDerivativeDefinition(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 2,\n",
        "        \"start_dx\" : 0.7,\n",
        "        \"df_color\" : YELLOW,\n",
        "        \"dx_color\" : GREEN,\n",
        "        \"secant_line_color\" : MAROON_B,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        def func(x):\n",
        "            u = 0.3*x - 1.5\n",
        "            return -u**3 + 5*u + 7\n",
        "        graph = self.get_graph(func)\n",
        "        graph_label = self.get_graph_label(graph)\n",
        "        start_x_v_line, nudged_x_v_line = [\n",
        "            self.get_vertical_line_to_graph(\n",
        "                self.start_x + nudge, graph, \n",
        "                line_class = DashedLine,\n",
        "                color = RED\n",
        "            )\n",
        "            for nudge in (0, self.start_dx)\n",
        "        ]\n",
        "        nudged_x_v_line.save_state()\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            self.start_x, graph,\n",
        "            dx = self.start_dx,\n",
        "            dx_label = \"dx\",\n",
        "            df_label = \"df\",\n",
        "            df_line_color = self.df_color,\n",
        "            dx_line_color = self.dx_color,\n",
        "            secant_line_color = self.secant_line_color,\n",
        "        )\n",
        "        derivative = OldTex(\n",
        "            \"{df\", \"\\\\over \\\\,\", \"dx}\", \"(\", str(self.start_x), \")\"\n",
        "        )\n",
        "        derivative.set_color_by_tex(\"df\", self.df_color)\n",
        "        derivative.set_color_by_tex(\"dx\", self.dx_color)\n",
        "        derivative.set_color_by_tex(str(self.start_x), RED)\n",
        "        df = derivative.get_part_by_tex(\"df\")\n",
        "        dx = derivative.get_part_by_tex(\"dx\")\n",
        "        input_x = derivative.get_part_by_tex(str(self.start_x))\n",
        "        derivative.move_to(self.coords_to_point(7, 4))\n",
        "        derivative.save_state()\n",
        "        deriv_brace = Brace(derivative)\n",
        "        dx_to_0 = OldTex(\"dx\", \"\\\\to 0\")\n",
        "        dx_to_0.set_color_by_tex(\"dx\", self.dx_color)\n",
        "        dx_to_0.next_to(deriv_brace, DOWN)\n",
        "\n",
        "        #Introduce graph\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label, run_time = 1))\n",
        "        self.play(Write(derivative))\n",
        "        self.wait()\n",
        "        input_copy = input_x.copy()\n",
        "        self.play(\n",
        "            input_copy.next_to, \n",
        "            self.coords_to_point(self.start_x, 0),\n",
        "            DOWN\n",
        "        )\n",
        "        self.play(ShowCreation(start_x_v_line))\n",
        "        self.wait()\n",
        "\n",
        "        #ss_group_development\n",
        "        self.play(\n",
        "            ShowCreation(ss_group.dx_line),\n",
        "            ShowCreation(ss_group.dx_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(ss_group.df_line))\n",
        "        self.play(Write(ss_group.df_label))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(ss_group.dx_label.copy(), dx),\n",
        "            ReplacementTransform(ss_group.df_label.copy(), df),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(ShowCreation(ss_group.secant_line))\n",
        "        self.wait()\n",
        "\n",
        "        #Let dx approach 0\n",
        "        self.play(\n",
        "            GrowFromCenter(deriv_brace),\n",
        "            Write(dx_to_0),\n",
        "        )\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_dx = 0.01,\n",
        "            run_time = 5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Write out fuller limit\n",
        "        new_deriv = OldTex(\n",
        "            \"{f\", \"(\", str(self.start_x), \"+\", \"dx\", \")\", \n",
        "            \"-\", \"f\", \"(\", str(self.start_x), \")\",\n",
        "            \"\\\\over \\\\,\", \"dx\"\n",
        "        )\n",
        "        new_deriv.set_color_by_tex(\"dx\", self.dx_color)\n",
        "        new_deriv.set_color_by_tex(\"f\", self.df_color)\n",
        "        new_deriv.set_color_by_tex(str(self.start_x), RED)\n",
        "        deriv_to_new_deriv = dict([\n",
        "            (\n",
        "                VGroup(derivative.get_part_by_tex(s)), \n",
        "                VGroup(*new_deriv.get_parts_by_tex(s))\n",
        "            )\n",
        "            for s in [\"f\", \"over\", \"dx\", \"(\", str(self.start_x), \")\"]\n",
        "        ])\n",
        "        covered_new_deriv_parts = list(it.chain(*list(deriv_to_new_deriv.values())))\n",
        "        uncovered_new_deriv_parts = [part for part in new_deriv if part not in covered_new_deriv_parts]\n",
        "        new_deriv.move_to(derivative)\n",
        "        new_brace = Brace(new_deriv, DOWN)\n",
        "\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_dx = self.start_dx,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(ShowCreation(nudged_x_v_line))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(*pair, run_time = 2)\n",
        "            for pair in list(deriv_to_new_deriv.items())\n",
        "        ]+[\n",
        "            Transform(deriv_brace, new_brace),\n",
        "            dx_to_0.next_to, new_brace, DOWN\n",
        "        ])\n",
        "        self.play(Write(VGroup(*uncovered_new_deriv_parts), run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        #Introduce limit notation\n",
        "        lim = OldTex(\"\\\\lim\").scale(1.3)\n",
        "        dx_to_0.generate_target()\n",
        "        dx_to_0.target.scale(0.7)\n",
        "        dx_to_0.target.next_to(lim, DOWN, buff = SMALL_BUFF)\n",
        "        lim_group = VGroup(lim, dx_to_0.target)\n",
        "        lim_group.move_to(new_deriv, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(deriv_brace, lim),\n",
        "            MoveToTarget(dx_to_0),\n",
        "            new_deriv.next_to, lim_group, RIGHT,\n",
        "            run_time = 2\n",
        "        )\n",
        "        for sf, color in (1.2, YELLOW), (1/1.2, WHITE):\n",
        "            self.play(\n",
        "                lim.scale, sf,\n",
        "                lim.set_color, color,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "        self.wait(2)\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group, target_dx = 0.01,\n",
        "            run_time = 5,\n",
        "            added_anims = [\n",
        "                Transform(nudged_x_v_line, start_x_v_line, run_time = 5)\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Record attributes for DiscussLowercaseDs below\n",
        "        digest_locals(self)\n",
        "\n",
        "class RantOpenAndClose(Scene):\n",
        "    def construct(self):\n",
        "        opening, closing = [\n",
        "            OldTexText(\n",
        "                start, \"Rant on infinitesimals\", \"$>$\",\n",
        "                arg_separator = \"\"\n",
        "            )\n",
        "            for start in (\"$<$\", \"$<$/\")\n",
        "        ]\n",
        "        self.play(FadeIn(opening))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(opening, closing))\n",
        "        self.wait(2)\n",
        "\n",
        "class DiscussLowercaseDs(RefreshOnDerivativeDefinition, PiCreatureScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"zoomed_canvas_corner\" : UP+LEFT\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.skip_superclass_anims()\n",
        "        self.replace_dx_terms()\n",
        "        self.compare_rhs_and_lhs()\n",
        "        self.h_is_finite()\n",
        "\n",
        "    def skip_superclass_anims(self):\n",
        "        self.remove(self.pi_creature)        \n",
        "        self.force_skipping()\n",
        "        RefreshOnDerivativeDefinition.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.animate_secant_slope_group_change(\n",
        "            self.ss_group, target_dx = self.start_dx,\n",
        "            added_anims = [\n",
        "                self.nudged_x_v_line.restore,\n",
        "                Animation(self.ss_group.df_line)\n",
        "            ],\n",
        "            run_time = 1\n",
        "        )\n",
        "        everything = self.get_top_level_mobjects()\n",
        "        everything.remove(self.derivative)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, 2.5*LEFT)\n",
        "            for mob in everything\n",
        "        ] + [\n",
        "            FadeIn(self.pi_creature)\n",
        "        ])\n",
        "\n",
        "    def replace_dx_terms(self):\n",
        "        dx_list = [self.dx_to_0[0]]\n",
        "        dx_list += self.new_deriv.get_parts_by_tex(\"dx\")\n",
        "        mover = dx_list[0]\n",
        "        mover_scale_val = 1.5\n",
        "        mover.initial_right = mover.get_right()\n",
        "\n",
        "        self.play(\n",
        "            mover.scale, mover_scale_val,\n",
        "            mover.next_to, self.pi_creature.get_corner(UP+LEFT), \n",
        "                UP, MED_SMALL_BUFF,\n",
        "            self.pi_creature.change_mode, \"sassy\",\n",
        "            path_arc = np.pi/2,\n",
        "        )\n",
        "        self.blink()\n",
        "        self.wait()\n",
        "        for tex in \"\\\\Delta x\", \"h\":\n",
        "            dx_list_replacement = [\n",
        "                OldTex(\n",
        "                    tex\n",
        "                ).set_color(self.dx_color).move_to(dx, DOWN)\n",
        "                for dx in dx_list\n",
        "            ]\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    VGroup(*dx_list),\n",
        "                    VGroup(*dx_list_replacement),\n",
        "                ),\n",
        "                self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            mover.scale, 0.9,\n",
        "            mover.move_to, mover.initial_right, RIGHT,\n",
        "            self.pi_creature.change_mode, \"happy\",\n",
        "        )\n",
        "        self.play(\n",
        "            self.dx_to_0.next_to, self.lim, DOWN, SMALL_BUFF,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def compare_rhs_and_lhs(self):\n",
        "        self.derivative.restore()\n",
        "        lhs = self.derivative\n",
        "        equals = OldTex(\"=\")\n",
        "        rhs = VGroup(self.lim, self.dx_to_0, self.new_deriv)\n",
        "        rhs.generate_target()\n",
        "        rhs.target.next_to(self.pi_creature, UP, MED_LARGE_BUFF)\n",
        "        rhs.target.to_edge(RIGHT)\n",
        "        equals.next_to(rhs.target, LEFT)\n",
        "        lhs.next_to(equals, LEFT)\n",
        "\n",
        "        d_circles = VGroup(*[\n",
        "            Circle(color = BLUE_B).replace(\n",
        "                lhs.get_part_by_tex(tex)[0],\n",
        "                stretch = True,\n",
        "            ).scale(1.5).rotate(-np.pi/12)\n",
        "            for tex in (\"df\", \"dx\")\n",
        "        ])\n",
        "        d_words = OldTexText(\"\"\"\n",
        "            Limit idea is\n",
        "            built in\n",
        "        \"\"\")\n",
        "        d_words.next_to(d_circles, DOWN)\n",
        "        d_words.set_color(d_circles[0].get_color())\n",
        "\n",
        "        lhs_rect, rhs_rect = rects = [\n",
        "            Rectangle(color = GREEN_B).replace(\n",
        "                mob, stretch = True\n",
        "            )\n",
        "            for mob in (lhs, rhs.target)\n",
        "        ]\n",
        "        for rect in rects:\n",
        "            rect.stretch_to_fit_width(rect.get_width()+2*MED_SMALL_BUFF)\n",
        "            rect.stretch_to_fit_height(rect.get_height()+2*MED_SMALL_BUFF)\n",
        "        formal_definition_words = OldTexText(\"\"\"\n",
        "            Formal derivative definition \n",
        "        \"\"\")\n",
        "        formal_definition_words.set_width(rhs_rect.get_width())\n",
        "        formal_definition_words.next_to(rhs_rect, UP)\n",
        "        formal_definition_words.set_color(rhs_rect.get_color())\n",
        "        formal_definition_words.add_background_rectangle()\n",
        "\n",
        "        df = VGroup(lhs.get_part_by_tex(\"df\"))\n",
        "        df_target = VGroup(*self.new_deriv.get_parts_by_tex(\"f\"))\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rhs),\n",
        "            Write(lhs),\n",
        "            Write(equals),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(d_circles, run_time = 2),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.play(Write(d_words))\n",
        "        self.animate_secant_slope_group_change(\n",
        "            self.ss_group, target_dx = 0.01,\n",
        "            added_anims = [\n",
        "                Transform(\n",
        "                    self.nudged_x_v_line, self.start_x_v_line,\n",
        "                    run_time = 3\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(lhs_rect),\n",
        "            FadeOut(d_circles),\n",
        "            FadeOut(d_words),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(lhs_rect, rhs_rect),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            df.copy(), df_target, \n",
        "            path_arc = -np.pi/2,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(Indicate(\n",
        "            VGroup(*rhs[:2]),\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(formal_definition_words))\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"happy\",\n",
        "            self.pi_creature.look_at, formal_definition_words\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        lhs.add_background_rectangle()\n",
        "        self.add(rhs_rect, rhs)\n",
        "        self.definition_group = VGroup(\n",
        "            lhs, equals, rhs_rect, rhs, formal_definition_words\n",
        "        )\n",
        "        self.lhs, self.rhs, self.rhs_rect = lhs, rhs, rhs_rect\n",
        "\n",
        "    def h_is_finite(self):\n",
        "        self.play(\n",
        "            FadeOut(self.graph_label),\n",
        "            self.definition_group.center,\n",
        "            self.definition_group.to_corner, UP+RIGHT,\n",
        "            self.pi_creature.change_mode, \"sassy\",\n",
        "            self.pi_creature.look_at, 4*UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        words = OldTexText(\"No ``infinitely small''\")\n",
        "        words.next_to(\n",
        "            self.definition_group, DOWN,\n",
        "            buff = LARGE_BUFF, \n",
        "        ) \n",
        "        arrow = Arrow(words.get_top(), self.rhs_rect.get_bottom())\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        h_group = VGroup(\n",
        "            self.rhs[1].get_part_by_tex(\"dx\"),\n",
        "            *self.rhs[2].get_parts_by_tex(\"dx\")\n",
        "        )\n",
        "        moving_h = h_group[0]\n",
        "        moving_h.original_center = moving_h.get_center()\n",
        "        dx_group = VGroup()\n",
        "        for h in h_group:\n",
        "            dx = OldTex(\"dx\")\n",
        "            dx.set_color(h.get_color())\n",
        "            dx.replace(h, dim_to_match = 1)\n",
        "            dx_group.add(dx)\n",
        "        moving_dx = dx_group[0]       \n",
        "\n",
        "        self.play(Write(words), ShowCreation(arrow))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            moving_h.next_to, self.pi_creature.get_corner(UP+RIGHT), UP,\n",
        "            self.pi_creature.change_mode, \"raise_left_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "        moving_dx.move_to(moving_h)\n",
        "        h_group.save_state()\n",
        "        self.play(Transform(\n",
        "            h_group, dx_group, \n",
        "            path_arc = np.pi,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(h_group.restore, path_arc = np.pi)\n",
        "        self.play(\n",
        "            moving_h.move_to, moving_h.original_center,\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Zoom in\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle\n",
        "        lil_rect.move_to(self.ss_group)\n",
        "        lil_rect.scale(3)\n",
        "        lil_rect.save_state()\n",
        "        self.wait()\n",
        "        self.add(self.rhs)\n",
        "        self.play(\n",
        "            lil_rect.set_width,\n",
        "            self.ss_group.dx_line.get_width()*4,\n",
        "            run_time = 4\n",
        "        )\n",
        "        self.wait()\n",
        "        dx = self.ss_group.dx_label\n",
        "        dx.save_state()\n",
        "        h = OldTex(\"h\")\n",
        "        h.set_color(dx.get_color())\n",
        "        h.replace(dx, dim_to_match = 1)\n",
        "        self.play(Transform(dx, h, path_arc = np.pi))\n",
        "        self.play(Indicate(dx))\n",
        "        self.wait()\n",
        "        self.play(dx.restore, path_arc = np.pi)\n",
        "        self.play(lil_rect.restore, run_time = 4)\n",
        "        self.wait()\n",
        "        self.disactivate_zooming()\n",
        "        self.wait()\n",
        "\n",
        "        #Last approaching reference\n",
        "        for target_dx in 3, 0.01, -2, 0.01:\n",
        "            self.animate_secant_slope_group_change(\n",
        "                self.ss_group, target_dx = target_dx,\n",
        "                run_time = 4,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class OtherViewsOfDx(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        definition = OldTex(\n",
        "            \"{df\", \"\\\\over \\\\,\", \"dx}\", \"(\", \"2\", \")\", \"=\",\n",
        "            \"\\\\lim\", \"_{h\", \"\\\\to\", \"0}\", \n",
        "            \"{f\", \"(\", \"2\", \"+\", \"h\", \")\", \"-\", \"f\", \"(\", \"2\", \")\",\n",
        "            \"\\\\over \\\\,\", \"h}\"\n",
        "        )\n",
        "        tex_to_color = {\n",
        "            \"df\" : YELLOW,\n",
        "            \"f\" : YELLOW,\n",
        "            \"dx\" : GREEN,\n",
        "            \"h\" : GREEN,\n",
        "            \"2\" : RED\n",
        "        }\n",
        "        for tex, color in list(tex_to_color.items()):\n",
        "            definition.set_color_by_tex(tex, color)\n",
        "        definition.scale(0.8)\n",
        "        definition.to_corner(UP+LEFT)\n",
        "        dx_group = VGroup(*definition.get_parts_by_tex(\"dx\"))\n",
        "        h_group = VGroup(*definition.get_parts_by_tex(\"h\"))\n",
        "        self.add(definition)\n",
        "\n",
        "        statements = [\n",
        "            OldTexText(*args)\n",
        "            for args in [\n",
        "                (\"Why the new \\\\\\\\ variable\", \"$h$\", \"?\"),\n",
        "                (\"$dx$\", \"is more $\\\\dots$ contentious.\"),\n",
        "                (\"$dx$\", \"is infinitely small\"),\n",
        "                (\"$dx$\", \"is nothing more \\\\\\\\ than a symbol\"),\n",
        "            ]\n",
        "        ]\n",
        "        for statement in statements:\n",
        "            statement.h, statement.dx = [\n",
        "                VGroup(*statement.get_parts_by_tex(\n",
        "                    tex, substring = False\n",
        "                )).set_color(GREEN)\n",
        "                for tex in (\"$h$\", \"$dx$\")\n",
        "            ]\n",
        "\n",
        "        #Question\n",
        "        self.student_says(\n",
        "            statements[0],\n",
        "            index = 1,\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            statements[0].h.copy(), h_group,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        #Teacher answer\n",
        "        self.teacher_says(\n",
        "            statements[1],\n",
        "            target_mode = \"hesitant\",\n",
        "            bubble_creation_class = FadeIn,\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            statements[1].dx.copy(), dx_group, \n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        #First alternate view\n",
        "        moving_dx = dx_group.copy()\n",
        "        bubble_intro = PiCreatureBubbleIntroduction(\n",
        "            self.get_students()[2],\n",
        "            statements[2],\n",
        "            target_mode = \"hooray\",\n",
        "            bubble_creation_class = FadeIn,\n",
        "        )\n",
        "        bubble_intro.update(1)\n",
        "        dx_movement = Transform(\n",
        "            moving_dx, statements[2].dx,\n",
        "            run_time = 2\n",
        "        )\n",
        "        bubble_intro.update(0)\n",
        "        self.play(\n",
        "            bubble_intro, dx_movement,\n",
        "            RemovePiCreatureBubble(self.get_teacher()),\n",
        "        )   \n",
        "        self.play(self.get_teacher().change_mode, \"erm\")\n",
        "        self.wait()\n",
        "\n",
        "        #Next alternate view\n",
        "        bubble_intro = PiCreatureBubbleIntroduction(\n",
        "            self.get_students()[0],\n",
        "            statements[3],\n",
        "            target_mode = \"maybe\",\n",
        "            look_at = 3*UP,\n",
        "            bubble_creation_class = FadeIn,\n",
        "        )\n",
        "        bubble_intro.update(1)\n",
        "        dx_movement = Transform(\n",
        "            moving_dx, statements[3].dx,\n",
        "            run_time = 2\n",
        "        )\n",
        "        bubble_intro.update(0)\n",
        "        last_bubble = self.get_students()[2].bubble\n",
        "        self.play(\n",
        "            bubble_intro, dx_movement,\n",
        "            FadeOut(last_bubble),\n",
        "            FadeOut(last_bubble.content),\n",
        "            *it.chain(*[\n",
        "                [\n",
        "                    pi.change_mode, \"pondering\", \n",
        "                    pi.look_at, bubble_intro.mobject\n",
        "                ]\n",
        "                for pi in self.get_students()[1:]\n",
        "            ])\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class GoalsListed(Scene):\n",
        "    def construct(self):\n",
        "        goals = VGroup(*[\n",
        "            OldTexText(\"Goal %d: %s\"%(d, s))\n",
        "            for d, s in zip(it.count(1), [\n",
        "                \"Formal definition of a derivative\",\n",
        "                \"$(\\\\epsilon, \\\\delta)$ definition of limits\",\n",
        "                \"L'H\u00f4pital's rule\",\n",
        "            ])\n",
        "        ])\n",
        "        goals.arrange(\n",
        "            DOWN, buff = LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        for goal in goals:\n",
        "            self.play(FadeIn(goal))\n",
        "            self.wait()\n",
        "        for i, goal in enumerate(goals):\n",
        "            anims = [goal.set_color, YELLOW]\n",
        "            if i > 0:\n",
        "                anims += [goals[i-1].set_color, WHITE]\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "\n",
        "class GraphLimitExpression(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 2,\n",
        "        \"h_color\" : GREEN,\n",
        "        \"f_color\" : YELLOW,\n",
        "        \"two_color\" : RED,\n",
        "        \"graph_origin\" : 3*DOWN+LEFT,\n",
        "        \"x_min\" : -8,\n",
        "        \"x_max\" : 5,\n",
        "        \"x_axis_label\" : \"$h$\",\n",
        "        \"x_labeled_nums\" : list(range(-8, 6, 2)),\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 20,\n",
        "        \"y_tick_frequency\" : 1,\n",
        "        \"y_labeled_nums\" : list(range(5, 25, 5)),\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"big_delta\" : 0.7,\n",
        "        \"small_delta\" : 0.01,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.func = lambda h : 3*(2**2) + 3*2*h + h**2\n",
        "        self.setup_axes()\n",
        "        self.introduce_function()\n",
        "        self.emphasize_non_definedness_at_0()\n",
        "        self.draw_limit_point_hole()\n",
        "        self.show_limit()\n",
        "        self.skeptic_asks()\n",
        "        self.show_epsilon_delta_intuition()\n",
        "\n",
        "    def introduce_function(self):\n",
        "        expression = OldTex(\n",
        "            \"{(\", \"2\", \"+\", \"h\", \")\", \"^3\",\n",
        "            \"-\", \"(\", \"2\", \")\", \"^3\",\n",
        "            \"\\\\over \\\\,\", \"h}\",\n",
        "            arg_separator = \"\",\n",
        "        )\n",
        "        limit = OldTex(\"\\\\lim\", \"_{h\", \"\\\\to 0}\")\n",
        "        derivative = OldTex(\n",
        "            \"{d(x^3)\", \"\\\\over \\\\,\", \"dx}\", \"(\", \"2\", \")\"\n",
        "        )\n",
        "        tex_to_color = {\n",
        "            \"h\" : self.h_color,\n",
        "            \"dx\" : self.h_color,\n",
        "            \"2\" : self.two_color\n",
        "        }\n",
        "        for tex_mob in expression, limit, derivative:\n",
        "            for tex, color in list(tex_to_color.items()):\n",
        "                tex_mob.set_color_by_tex(tex, color)\n",
        "            tex_mob.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "            tex_mob.to_edge(UP)\n",
        "\n",
        "        expression.save_state()\n",
        "        expression.generate_target()\n",
        "        expression.target.next_to(limit, RIGHT)\n",
        "        brace = Brace(VGroup(limit, expression.target))\n",
        "        derivative.next_to(brace, DOWN)\n",
        "\n",
        "\n",
        "\n",
        "        indices = [0, 6, 11, 13]\n",
        "        funcs = [\n",
        "            lambda h : (2+h)**3,\n",
        "            lambda h : (2+h)**3 - 2**3,\n",
        "            self.func\n",
        "        ]\n",
        "        graph = None\n",
        "        for i, j, func in zip(indices, indices[1:], funcs):\n",
        "            anims = [FadeIn(\n",
        "                VGroup(*expression[i:j]),\n",
        "                lag_ratio = 0.5,\n",
        "            )]\n",
        "            new_graph = self.get_graph(func, color = BLUE)\n",
        "            if graph is None:\n",
        "                graph = new_graph\n",
        "                anims.append(FadeIn(graph))\n",
        "            else:\n",
        "                anims.append(Transform(graph, new_graph))\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(expression),\n",
        "            FadeIn(limit, lag_ratio = 0.5),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.play(Write(derivative))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            expression.restore,\n",
        "            *list(map(FadeOut, [derivative, brace, limit]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        colored_graph = graph.copy().set_color(YELLOW)\n",
        "        self.play(ShowCreation(colored_graph))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.remove(colored_graph)\n",
        "        self.wait()\n",
        "\n",
        "        self.expression = expression\n",
        "        self.limit = limit\n",
        "        self.graph = graph\n",
        "\n",
        "    def emphasize_non_definedness_at_0(self):\n",
        "        expression = self.expression\n",
        "        \n",
        "        dot = Dot(self.graph_origin, color = GREEN)\n",
        "        h_equals_0 = OldTex(\"h\", \"=\", \"0\", \"?\")\n",
        "        h_equals_0.next_to(self.graph_origin, UP+RIGHT, LARGE_BUFF)\n",
        "        for tex in \"h\", \"0\":\n",
        "            h_equals_0.set_color_by_tex(tex, GREEN)\n",
        "\n",
        "        arrow = Arrow(h_equals_0.get_left(), self.graph_origin)\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        new_expression = expression.deepcopy()\n",
        "        h_group = VGroup(*new_expression.get_parts_by_tex(\"h\"))\n",
        "        for h in h_group:\n",
        "            zero = OldTex(\"0\")\n",
        "            zero.set_color(h.get_color())\n",
        "            zero.replace(h, dim_to_match = 1)\n",
        "            Transform(h, zero).update(1)\n",
        "        rhs = OldTex(\"=\", \"{\\\\, 0\\\\,\", \"\\\\over \\\\,\", \"0\\\\,}\")\n",
        "        rhs.set_color_by_tex(\"0\", GREEN)\n",
        "        rhs.next_to(new_expression, RIGHT)\n",
        "        equation = VGroup(new_expression, rhs)\n",
        "        equation.next_to(expression, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        ud_brace = Brace(VGroup(*rhs[1:]), DOWN)\n",
        "        undefined = OldTexText(\"Undefined\")\n",
        "        undefined.next_to(ud_brace, DOWN)\n",
        "        undefined.to_edge(RIGHT)\n",
        "\n",
        "        self.play(Write(h_equals_0, run_time = 2))\n",
        "        self.play(*list(map(ShowCreation, [arrow, dot])))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            expression.copy(), new_expression\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(ud_brace),\n",
        "            Write(undefined)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.point_to_zero_group = VGroup(\n",
        "            h_equals_0, arrow, dot\n",
        "        )\n",
        "        self.plug_in_zero_group = VGroup(\n",
        "            new_expression, rhs, ud_brace, undefined\n",
        "        )\n",
        "\n",
        "    def draw_limit_point_hole(self):\n",
        "        dx = 0.07\n",
        "        color = self.graph.get_color()\n",
        "        circle = Circle(\n",
        "            radius = dx, \n",
        "            stroke_color = color,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        circle.move_to(self.coords_to_point(0, 12))\n",
        "        colored_circle = circle.copy()\n",
        "        colored_circle.set_stroke(YELLOW)\n",
        "        colored_circle.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(GrowFromCenter(circle))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(colored_circle))\n",
        "        self.play(ShowCreation(\n",
        "            circle.copy().set_fill(opacity = 0),\n",
        "            remover = True\n",
        "        ))\n",
        "        self.remove(colored_circle)\n",
        "        self.play(\n",
        "            circle.scale, 0.3,\n",
        "            run_time = 2,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.limit_point_hole = circle\n",
        "\n",
        "    def show_limit(self):\n",
        "        dot = self.point_to_zero_group[-1]\n",
        "        ed_group = self.get_epsilon_delta_group(self.big_delta)\n",
        "\n",
        "        left_v_line, right_v_line = ed_group.delta_lines\n",
        "        bottom_h_line, top_h_line = ed_group.epsilon_lines\n",
        "        ed_group.delta_lines.save_state()\n",
        "        ed_group.epsilon_lines.save_state()\n",
        "\n",
        "        brace = Brace(ed_group.input_range, UP)\n",
        "        brace_text = brace.get_text(\"Inputs around 0\", buff = SMALL_BUFF)\n",
        "        brace_text.add_background_rectangle()\n",
        "        brace_text.shift(RIGHT)\n",
        "\n",
        "        limit_point_hole_copy = self.limit_point_hole.copy()\n",
        "        limit_point_hole_copy.set_stroke(YELLOW)\n",
        "        h_zero_hole = limit_point_hole_copy.copy()\n",
        "        h_zero_hole.move_to(self.graph_origin)\n",
        "\n",
        "        ed_group.input_range.add(h_zero_hole)\n",
        "        ed_group.output_range.add(limit_point_hole_copy)\n",
        "\n",
        "        #Show range around 0\n",
        "        self.play(\n",
        "            FadeOut(self.plug_in_zero_group),\n",
        "            FadeOut(VGroup(*self.point_to_zero_group[:-1])),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text),\n",
        "            ReplacementTransform(dot, ed_group.input_range),\n",
        "        )\n",
        "        self.add(h_zero_hole)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                ed_group.input_range.copy(), \n",
        "                ed_group.output_range, \n",
        "                run_time = 2\n",
        "            ),\n",
        "        )\n",
        "        self.remove(self.limit_point_hole)\n",
        "\n",
        "        #Show approaching\n",
        "        self.play(*list(map(FadeOut, [brace, brace_text])))\n",
        "        for v_line, h_line in (right_v_line, top_h_line), (left_v_line, bottom_h_line):\n",
        "            self.play(\n",
        "                ShowCreation(v_line),\n",
        "                ShowCreation(h_line)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                v_line.move_to, self.coords_to_point(0, 0), DOWN,\n",
        "                h_line.move_to, self.coords_to_point(0, self.func(0)),\n",
        "                run_time = 3\n",
        "            )\n",
        "            self.play(\n",
        "                VGroup(h_line, v_line).set_stroke, GREY, 2,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        #Write limit\n",
        "        limit = self.limit\n",
        "        limit.next_to(self.expression, LEFT)\n",
        "        equals, twelve = rhs = OldTex(\"=\", \"12\")\n",
        "        rhs.next_to(self.expression, RIGHT)\n",
        "        twelve_copy = twelve.copy()\n",
        "        limit_group = VGroup(limit, rhs)\n",
        "\n",
        "        self.play(Write(limit_group))\n",
        "        self.wait()\n",
        "        self.play(twelve_copy.next_to, top_h_line, RIGHT)\n",
        "        self.wait()\n",
        "\n",
        "        self.twelve_copy = twelve_copy\n",
        "        self.rhs = rhs\n",
        "        self.ed_group = ed_group\n",
        "        self.input_range_brace_group = VGroup(brace, brace_text)\n",
        "\n",
        "    def skeptic_asks(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.9)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"\"\"\n",
        "                What \\\\emph{exactly} do you\n",
        "                mean by ``approach''\n",
        "            \"\"\",\n",
        "            bubble_config = {\n",
        "                \"height\" : 3,\n",
        "                \"width\" : 5,\n",
        "                \"fill_opacity\" : 1,\n",
        "                \"direction\" : LEFT,\n",
        "            },\n",
        "            target_mode = \"sassy\"\n",
        "        ))\n",
        "        self.remove(self.twelve_copy)\n",
        "        self.play(randy.look, OUT)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            randy, target_mode = \"pondering\",\n",
        "            look_at = self.limit_point_hole\n",
        "        ))\n",
        "        self.play(\n",
        "            self.ed_group.delta_lines.restore,\n",
        "            self.ed_group.epsilon_lines.restore,\n",
        "            Animation(randy),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 5,\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "    def show_epsilon_delta_intuition(self):\n",
        "        self.play(\n",
        "            FadeOut(self.ed_group.epsilon_lines),\n",
        "            FadeIn(self.input_range_brace_group)\n",
        "        )\n",
        "        self.ed_group.epsilon_lines.restore()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.ed_group.delta_lines.restore, \n",
        "            Animation(self.input_range_brace_group),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeOut(self.input_range_brace_group))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.ed_group.input_range.copy(),\n",
        "                self.ed_group.output_range,\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(GrowFromCenter, self.ed_group.epsilon_lines)))\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                line.copy().set_stroke(GREY, 2).move_to,\n",
        "                self.coords_to_point(0, self.func(0)),\n",
        "                run_time = 3,\n",
        "                rate_func = there_and_back,\n",
        "                remover = True,\n",
        "            )\n",
        "            for line in self.ed_group.epsilon_lines\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        holes = VGroup(\n",
        "            self.ed_group.input_range.submobjects.pop(),\n",
        "            self.ed_group.output_range.submobjects.pop(),\n",
        "        )\n",
        "        holes.save_state()\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            self.ed_group,\n",
        "            target_delta = self.small_delta,\n",
        "            run_time = 8,\n",
        "            rate_func = lambda t : smooth(t, 2),\n",
        "            added_anims = [\n",
        "                ApplyMethod(\n",
        "                    hole.scale, 0.5,\n",
        "                    run_time = 8\n",
        "                )\n",
        "                for hole in holes\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.holes = holes\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_epsilon_delta_group(\n",
        "        self, \n",
        "        delta,\n",
        "        limit_x = 0,\n",
        "        dashed_line_stroke_width = 3,\n",
        "        dashed_line_length = FRAME_HEIGHT,\n",
        "        input_range_color = YELLOW,\n",
        "        input_range_stroke_width = 6,\n",
        "        ):\n",
        "        kwargs = dict(locals())\n",
        "        result = VGroup()\n",
        "        kwargs.pop(\"self\")\n",
        "        result.delta = kwargs.pop(\"delta\")\n",
        "        result.limit_x = kwargs.pop(\"limit_x\")\n",
        "        result.kwargs = kwargs\n",
        "        dashed_line = DashedLine(\n",
        "            ORIGIN, dashed_line_length*RIGHT,\n",
        "            stroke_width = dashed_line_stroke_width\n",
        "        )\n",
        "        x_values = [limit_x-delta, limit_x+delta]\n",
        "        x_axis_points = [self.coords_to_point(x, 0) for x in x_values]\n",
        "        result.delta_lines = VGroup(*[\n",
        "            dashed_line.copy().rotate(np.pi/2).move_to(\n",
        "                point, DOWN\n",
        "            )\n",
        "            for point in x_axis_points\n",
        "        ])\n",
        "        if self.func(limit_x) < 0:\n",
        "            result.delta_lines.rotate(\n",
        "                np.pi, RIGHT, \n",
        "                about_point = result.delta_lines.get_bottom()\n",
        "            )\n",
        "        basically_zero = 0.00001\n",
        "        result.input_range, result.output_range = [\n",
        "            VGroup(*[\n",
        "                self.get_graph(\n",
        "                    func,\n",
        "                    color = input_range_color,\n",
        "                    x_min = x_min,\n",
        "                    x_max = x_max,\n",
        "                )\n",
        "                for x_min, x_max in [\n",
        "                    (limit_x-delta, limit_x-basically_zero),\n",
        "                    (limit_x+basically_zero, limit_x+delta),\n",
        "                ]\n",
        "            ]).set_stroke(width = input_range_stroke_width)\n",
        "            for func in ((lambda h : 0), self.func)\n",
        "        ]\n",
        "        result.epsilon_lines = VGroup(*[\n",
        "            dashed_line.copy().move_to(\n",
        "                self.coords_to_point(limit_x, 0)[0]*RIGHT+\\\n",
        "                result.output_range.get_edge_center(vect)[1]*UP\n",
        "            )\n",
        "            for vect in (DOWN, UP)\n",
        "        ])\n",
        "\n",
        "        result.digest_mobject_attrs()\n",
        "        return result\n",
        "\n",
        "    def animate_epsilon_delta_group_change(\n",
        "        self, epsilon_delta_group, target_delta,\n",
        "        **kwargs\n",
        "        ):\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        limit_x = epsilon_delta_group.limit_x\n",
        "        start_delta = epsilon_delta_group.delta\n",
        "        ed_group_kwargs = epsilon_delta_group.kwargs\n",
        "        def update_ed_group(ed_group, alpha):\n",
        "            delta = interpolate(start_delta, target_delta, alpha)\n",
        "            new_group = self.get_epsilon_delta_group(\n",
        "                delta, limit_x = limit_x,\n",
        "                **ed_group_kwargs\n",
        "            )\n",
        "            Transform(ed_group, new_group).update(1)\n",
        "            return ed_group\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                epsilon_delta_group, update_ed_group,\n",
        "                **kwargs\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "class LimitCounterExample(GraphLimitExpression):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -8,\n",
        "        \"x_max\" : 8,\n",
        "        \"x_labeled_nums\" : list(range(-8, 10, 2)),\n",
        "        \"x_axis_width\" : FRAME_WIDTH - LARGE_BUFF,\n",
        "        \"y_min\" : -4,\n",
        "        \"y_max\" : 4,\n",
        "        \"y_labeled_nums\" : list(range(-2, 4, 1)),\n",
        "        \"y_axis_height\" : FRAME_HEIGHT+2*LARGE_BUFF,\n",
        "        \"graph_origin\" : DOWN,\n",
        "        \"graph_color\" : BLUE,\n",
        "        \"hole_radius\" : 0.075,\n",
        "        \"smaller_hole_radius\" : 0.04,\n",
        "        \"big_delta\" : 1.5,\n",
        "        \"small_delta\" : 0.05,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_func()\n",
        "        self.setup_axes()\n",
        "        self.draw_graph()\n",
        "        self.approach_zero()\n",
        "        self.write_limit_not_defined()\n",
        "        self.show_epsilon_delta_intuition()\n",
        "\n",
        "    def add_func(self):\n",
        "        def func(h):\n",
        "            square = 0.25*h**2\n",
        "            if h < 0:\n",
        "                return -square + 1\n",
        "            else:\n",
        "                return square + 2\n",
        "        self.func = func\n",
        "\n",
        "    def draw_graph(self):\n",
        "        epsilon = 0.1\n",
        "        left_graph, right_graph = [\n",
        "            self.get_graph(\n",
        "                self.func,\n",
        "                color = self.graph_color,\n",
        "                x_min = x_min,\n",
        "                x_max = x_max,\n",
        "            )\n",
        "            for x_min, x_max in [\n",
        "                (self.x_min, -epsilon),\n",
        "                (epsilon, self.x_max),\n",
        "            ]\n",
        "        ]\n",
        "        left_hole = self.get_hole(0, 1, color = self.graph_color)\n",
        "        right_hole = self.get_hole(0, 2, color = self.graph_color)\n",
        "        graph = VGroup(\n",
        "            left_graph, left_hole, \n",
        "            right_hole, right_graph\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(graph, run_time = 5))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            left_hole.copy().set_stroke(YELLOW), right_hole\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_holes = VGroup(left_hole, right_hole)\n",
        "\n",
        "    def approach_zero(self):\n",
        "        ed_group = self.get_epsilon_delta_group(self.big_delta)\n",
        "        left_v_line, right_v_line = ed_group.delta_lines\n",
        "        bottom_h_line, top_h_line = ed_group.epsilon_lines\n",
        "        ed_group.delta_lines.save_state()\n",
        "        ed_group.epsilon_lines.save_state()\n",
        "\n",
        "        right_lines = VGroup(right_v_line, top_h_line)\n",
        "        left_lines = VGroup(left_v_line, bottom_h_line)\n",
        "\n",
        "        basically_zero = 0.00001\n",
        "        def update_lines(lines, alpha):\n",
        "            v_line, h_line = lines\n",
        "            sign = 1 if v_line is right_v_line else -1\n",
        "            x_val = interpolate(sign*self.big_delta, sign*basically_zero, alpha)\n",
        "            v_line.move_to(self.coords_to_point(x_val, 0), DOWN)\n",
        "            h_line.move_to(self.coords_to_point(0, self.func(x_val)))\n",
        "            return lines\n",
        "\n",
        "        for lines in right_lines, left_lines:\n",
        "            self.play(*list(map(ShowCreation, lines)))\n",
        "            self.play(UpdateFromAlphaFunc(\n",
        "                lines, update_lines,\n",
        "                run_time = 3\n",
        "            ))\n",
        "            self.play(lines.set_stroke, GREY, 3)\n",
        "            self.wait()\n",
        "\n",
        "        self.ed_group = ed_group\n",
        "\n",
        "    def write_limit_not_defined(self):\n",
        "        limit = OldTex(\n",
        "            \"\\\\lim\", \"_{h\", \"\\\\to 0}\", \"f(\", \"h\", \")\"\n",
        "        )\n",
        "        limit.set_color_by_tex(\"h\", GREEN)\n",
        "        limit.move_to(self.coords_to_point(2, 1.5))\n",
        "\n",
        "        words = OldTexText(\"is not defined\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(limit, RIGHT, align_using_submobjects = True)\n",
        "\n",
        "        limit_group = VGroup(limit, words)\n",
        "\n",
        "        self.play(Write(limit))\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(limit_group.to_corner, UP+LEFT)\n",
        "        self.wait()\n",
        "\n",
        "    def show_epsilon_delta_intuition(self):\n",
        "        ed_group = self.ed_group\n",
        "        self.play(\n",
        "            ed_group.delta_lines.restore,\n",
        "            ed_group.epsilon_lines.restore,\n",
        "        )\n",
        "        self.play(ShowCreation(ed_group.input_range))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            ed_group.input_range.copy(),\n",
        "            ed_group.output_range,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.graph.remove(*self.graph_holes)\n",
        "        self.remove(*self.graph_holes)\n",
        "        self.wait()\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            ed_group, target_delta = self.small_delta,\n",
        "            run_time = 6\n",
        "        )\n",
        "        self.hole_radius = self.smaller_hole_radius\n",
        "\n",
        "        brace = Brace(self.ed_group.epsilon_lines, RIGHT, buff = SMALL_BUFF)\n",
        "        brace_text = brace.get_text(\"Can't get \\\\\\\\ smaller\", buff = SMALL_BUFF)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        run_time_rate_func_pairs = [\n",
        "            (3, lambda t : 1 - there_and_back(t)),\n",
        "            (1, lambda t : 1 - 0.2*there_and_back(3*t % 1)),\n",
        "            (1, lambda t : 1 - 0.2*there_and_back(5*t % 1)),\n",
        "        ]\n",
        "        for run_time, rate_func in run_time_rate_func_pairs:\n",
        "            self.animate_epsilon_delta_group_change(\n",
        "                ed_group, target_delta = self.small_delta,\n",
        "                run_time = run_time,\n",
        "                rate_func = rate_func,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_epsilon_delta_group(self, delta, **kwargs):\n",
        "        ed_group = GraphLimitExpression.get_epsilon_delta_group(self, delta, **kwargs)\n",
        "        color = ed_group.kwargs[\"input_range_color\"]\n",
        "        radius = min(delta/2, self.hole_radius)\n",
        "        pairs = [\n",
        "            (ed_group.input_range[0], (0, 0)),\n",
        "            (ed_group.input_range[1], (0, 0)),\n",
        "            (ed_group.output_range[0], (0, 1)),\n",
        "            (ed_group.output_range[1], (0, 2)),\n",
        "        ]\n",
        "        for mob, coords in pairs:\n",
        "            mob.add(self.get_hole(\n",
        "                *coords, \n",
        "                color = color,\n",
        "                radius = radius\n",
        "            ))\n",
        "        return ed_group\n",
        "\n",
        "    def get_hole(self, *coords, **kwargs):\n",
        "        color = kwargs.get(\"color\", BLUE)\n",
        "        radius = kwargs.get(\"radius\", self.hole_radius)\n",
        "        return Circle(\n",
        "            radius = radius,\n",
        "            stroke_color = color,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        ).move_to(self.coords_to_point(*coords))\n",
        "\n",
        "class PrefaceToEpsilonDeltaDefinition(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTex(\"(\\\\epsilon, \\\\delta) \\\\text{ definition}\")\n",
        "        title.next_to(self.get_teacher().get_corner(UP+LEFT), UP)\n",
        "        title.save_state()\n",
        "        title.shift(DOWN)\n",
        "        title.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            title.restore,\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"Isn't that pretty \\\\\\\\ technical?\",\n",
        "            target_mode = \"guilty\",\n",
        "            added_anims = [\n",
        "                title.to_edge, UP,\n",
        "                self.get_teacher().change_mode, \"plain\",\n",
        "                self.get_teacher().look_at, self.get_students()[1].eyes\n",
        "            ]\n",
        "        )\n",
        "        self.look_at(self.get_teacher().eyes, self.get_students())\n",
        "        self.wait()\n",
        "        self.teacher_says(\"\", bubble_config = {\"stroke_width\" : 0})\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = UP+LEFT,\n",
        "            added_anims = [self.get_teacher().look_at, UP+LEFT]\n",
        "        )\n",
        "        self.wait(3)\n",
        "        words = OldTexText(\n",
        "            \"It's a glimpse of\\\\\\\\\",\n",
        "            \"real analysis\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"real\", YELLOW)\n",
        "        self.teacher_says(\n",
        "            words, \n",
        "            bubble_config = {\"height\" : 3, \"width\" : 6}\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(6)\n",
        "\n",
        "class EpsilonDeltaExample(GraphLimitExpression, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"epsilon_list\" : [2, 1, 0.5],\n",
        "        \"zoomed_canvas_corner\" : DOWN+RIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.delta_list = [\n",
        "            epsilon/6.0 for epsilon in self.epsilon_list\n",
        "        ]\n",
        "        self.skip_superclass_anims()\n",
        "        self.introduce_epsilon()\n",
        "        self.match_epsilon()\n",
        "        self.zoom_in()\n",
        "        self.introduce_delta()\n",
        "        self.smaller_epsilon()\n",
        "\n",
        "    def skip_superclass_anims(self):\n",
        "        self.force_skipping()\n",
        "        GraphLimitExpression.construct(self)\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            self.ed_group,\n",
        "            target_delta = self.big_delta,\n",
        "        )\n",
        "        self.holes.restore()\n",
        "        self.add(self.holes)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def introduce_epsilon(self):\n",
        "        epsilon_group, small_epsilon_group = list(map(\n",
        "            self.get_epsilon_group,\n",
        "            self.epsilon_list[:2]\n",
        "        ))\n",
        "\n",
        "        twelve_line = epsilon_group.limit_line\n",
        "        twelve = self.rhs[-1]\n",
        "        twelve_copy = twelve.copy()\n",
        "        twelve_copy.next_to(twelve_line)\n",
        "\n",
        "        distance = OldTexText(\"Distance\")\n",
        "        distance.next_to(epsilon_group.labels, DOWN, LARGE_BUFF)\n",
        "        distance.to_edge(RIGHT)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(distance.get_top(), label.get_right())\n",
        "            for label in epsilon_group.labels\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(twelve_line))\n",
        "        self.play(Write(twelve_copy))\n",
        "        self.play(ReplacementTransform(twelve_copy, twelve))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ReplacementTransform(twelve_line.copy(), line)\n",
        "                for line in epsilon_group.epsilon_lines\n",
        "            ], \n",
        "            list(map(GrowFromCenter, epsilon_group.braces)),\n",
        "        ))\n",
        "        self.play(*list(map(Write, epsilon_group.labels)))\n",
        "        self.play(\n",
        "            Write(distance),\n",
        "            ShowCreation(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [distance, arrows])))\n",
        "        self.play(Transform(\n",
        "            epsilon_group, small_epsilon_group,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.epsilon_group = epsilon_group\n",
        "\n",
        "    def match_epsilon(self):\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            self.ed_group, target_delta = self.delta_list[1],\n",
        "            run_time = 2,\n",
        "            added_anims = [\n",
        "                ApplyMethod(\n",
        "                    hole.scale, 0.25,\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for hole in self.holes\n",
        "            ]\n",
        "        )\n",
        "        self.ed_group.delta = self.delta_list[1]\n",
        "        self.ed_group.input_range.make_jagged()\n",
        "        self.wait()\n",
        "\n",
        "    def zoom_in(self):\n",
        "        self.ed_group.input_range.make_jagged()\n",
        "\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle\n",
        "        lil_rect.move_to(self.graph_origin)\n",
        "        lil_rect.scale(self.zoom_factor)\n",
        "        self.add(self.holes)\n",
        "        self.wait()\n",
        "        self.play(lil_rect.scale, 1./self.zoom_factor)\n",
        "        self.wait()\n",
        "\n",
        "    def introduce_delta(self):\n",
        "        delta_group = self.get_delta_group(self.delta_list[1])\n",
        "        self.play(*list(map(GrowFromCenter, delta_group.braces)))\n",
        "        self.play(*list(map(Write, delta_group.labels)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.ed_group.input_range.copy(),\n",
        "                self.ed_group.output_range,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Animation(self.holes),\n",
        "        )\n",
        "        self.play(ApplyWave(\n",
        "            VGroup(self.ed_group.output_range, self.holes[1]),\n",
        "            direction = RIGHT\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.delta_group = delta_group\n",
        "\n",
        "    def smaller_epsilon(self):\n",
        "        new_epsilon = self.epsilon_list[-1]\n",
        "        new_delta = self.delta_list[-1]\n",
        "        self.play(Transform(\n",
        "            self.epsilon_group,\n",
        "            self.get_epsilon_group(new_epsilon)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            self.ed_group, target_delta = new_delta,\n",
        "            added_anims = [\n",
        "                Transform(\n",
        "                    self.delta_group,\n",
        "                    self.get_delta_group(new_delta)\n",
        "                )\n",
        "            ] + [\n",
        "                ApplyMethod(hole.scale, 0.5)\n",
        "                for hole in self.holes\n",
        "            ]\n",
        "        )\n",
        "        self.ed_group.input_range.make_jagged()\n",
        "        self.wait(2)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_epsilon_group(self, epsilon, limit_value = 12):\n",
        "        result = VGroup()\n",
        "        line_length = FRAME_HEIGHT\n",
        "        lines = [\n",
        "            Line(\n",
        "                ORIGIN, line_length*RIGHT,\n",
        "            ).move_to(self.coords_to_point(0, limit_value+nudge))\n",
        "            for nudge in (0, -epsilon, epsilon)\n",
        "        ]\n",
        "        result.limit_line = lines[0]\n",
        "        result.limit_line.set_stroke(RED, width = 3)\n",
        "        result.epsilon_lines = VGroup(*lines[1:])\n",
        "        result.epsilon_lines.set_stroke(MAROON_B, width = 2)\n",
        "        brace = Brace(Line(ORIGIN, 0.5*UP), RIGHT)\n",
        "        result.braces = VGroup(*[\n",
        "            brace.copy().set_height(\n",
        "                group.get_height()\n",
        "            ).next_to(group, RIGHT, SMALL_BUFF)\n",
        "            for i in (1, 2)\n",
        "            for group in [VGroup(lines[0], lines[i])]\n",
        "        ])\n",
        "        result.labels = VGroup(*[\n",
        "            brace.get_text(\"\\\\Big $\\\\epsilon$\", buff = SMALL_BUFF)\n",
        "            for brace in result.braces\n",
        "        ])\n",
        "        for label, brace in zip(result.labels, result.braces):\n",
        "            label.set_height(min(\n",
        "                label.get_height(),\n",
        "                0.8*brace.get_height()\n",
        "            ))\n",
        "\n",
        "        result.digest_mobject_attrs()\n",
        "        return result\n",
        "\n",
        "    def get_delta_group(self, delta):\n",
        "        result = VGroup()\n",
        "        brace = Brace(Line(ORIGIN, RIGHT), DOWN)\n",
        "        brace.set_width(\n",
        "            (self.coords_to_point(delta, 0)-self.graph_origin)[0]\n",
        "        )\n",
        "        result.braces = VGroup(*[\n",
        "            brace.copy().move_to(self.coords_to_point(x, 0))\n",
        "            for x in (-delta/2, delta/2)\n",
        "        ])\n",
        "        result.braces.shift(self.holes[0].get_height()*DOWN)\n",
        "        result.labels = VGroup(*[\n",
        "            OldTex(\"\\\\delta\").scale(\n",
        "                1./self.zoom_factor\n",
        "            )\n",
        "            for brace in result.braces\n",
        "        ])\n",
        "        for label, brace in zip(result.labels, result.braces):\n",
        "            label.next_to(\n",
        "                brace, DOWN, \n",
        "                buff = SMALL_BUFF/self.zoom_factor\n",
        "            )\n",
        "\n",
        "        result.digest_mobject_attrs()\n",
        "        return result\n",
        "\n",
        "class EpsilonDeltaCounterExample(LimitCounterExample, EpsilonDeltaExample):\n",
        "    def construct(self):\n",
        "        self.hole_radius = 0.04\n",
        "        self.add_func()\n",
        "        self.setup_axes()\n",
        "        self.draw_graph()\n",
        "        self.introduce_epsilon()\n",
        "        self.introduce_epsilon_delta_group()\n",
        "        self.move_epsilon_group_up_and_down()\n",
        "\n",
        "    def introduce_epsilon(self):\n",
        "        epsilon_group = self.get_epsilon_group(0.4, 1.5)\n",
        "        rhs = OldTex(\"=0.4\")\n",
        "        label = epsilon_group.labels[1]\n",
        "        rhs.next_to(label, RIGHT)\n",
        "        epsilon_group.add(rhs)\n",
        "\n",
        "        self.play(ShowCreation(epsilon_group.limit_line))\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ReplacementTransform(\n",
        "                    epsilon_group.limit_line.copy(),\n",
        "                    line\n",
        "                )\n",
        "                for line in epsilon_group.epsilon_lines\n",
        "            ],\n",
        "            list(map(GrowFromCenter, epsilon_group.braces))\n",
        "        ))\n",
        "        self.play(*list(map(Write, epsilon_group.labels)))\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "\n",
        "        self.epsilon_group = epsilon_group\n",
        "\n",
        "    def introduce_epsilon_delta_group(self):\n",
        "        ed_group = self.get_epsilon_delta_group(self.big_delta)\n",
        "\n",
        "        self.play(*list(map(ShowCreation, ed_group.delta_lines)))\n",
        "        self.play(ShowCreation(ed_group.input_range))\n",
        "        self.play(ReplacementTransform(\n",
        "            ed_group.input_range.copy(),\n",
        "            ed_group.output_range,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.remove(self.graph_holes)\n",
        "        self.play(*list(map(GrowFromCenter, ed_group.epsilon_lines)))\n",
        "        self.wait(2)\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            ed_group, target_delta = self.small_delta,\n",
        "            run_time = 3\n",
        "        )\n",
        "        ed_group.delta = self.small_delta\n",
        "        self.wait()\n",
        "\n",
        "        self.ed_group = ed_group\n",
        "\n",
        "    def move_epsilon_group_up_and_down(self):\n",
        "        vects = [\n",
        "            self.coords_to_point(0, 2) - self.coords_to_point(0, 1.5),\n",
        "            self.coords_to_point(0, 1) - self.coords_to_point(0, 2),\n",
        "            self.coords_to_point(0, 1.5) - self.coords_to_point(0, 1),\n",
        "        ]\n",
        "        for vect in vects:\n",
        "            self.play(self.epsilon_group.shift, vect)\n",
        "            self.wait()\n",
        "            self.shake_ed_group()\n",
        "            self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def shake_ed_group(self):\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            self.ed_group, target_delta = self.big_delta,\n",
        "            rate_func = lambda t : 0.2*there_and_back(2*t%1)\n",
        "        )\n",
        "\n",
        "class TheoryHeavy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        lhs = OldTex(\n",
        "            \"{df\", \"\\\\over \\\\,\", \"dx}\", \"(\", \"x\", \")\"\n",
        "        )\n",
        "        equals = OldTex(\"=\")\n",
        "        rhs = OldTex(\n",
        "            \"\\\\lim\", \"_{h\", \"\\\\to 0}\", \n",
        "            \"{f\", \"(\", \"x\", \"+\", \"h\", \")\", \"-\", \"f\", \"(\", \"x\", \")\",\n",
        "            \"\\\\over \\\\,\", \"h}\"\n",
        "        )\n",
        "        derivative = VGroup(lhs, equals, rhs)\n",
        "        derivative.arrange(RIGHT)\n",
        "        for tex_mob in derivative:\n",
        "            tex_mob.set_color_by_tex(\"x\", RED)\n",
        "            tex_mob.set_color_by_tex(\"h\", GREEN)\n",
        "            tex_mob.set_color_by_tex(\"dx\", GREEN)\n",
        "            tex_mob.set_color_by_tex(\"f\", YELLOW)\n",
        "        derivative.next_to(self.get_pi_creatures(), UP, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        lim = rhs.get_part_by_tex(\"lim\")\n",
        "        epsilon_delta = OldTex(\"(\\\\epsilon, \\\\delta)\")\n",
        "        epsilon_delta.next_to(lim, UP, buff = 1.5*LARGE_BUFF)\n",
        "        arrow = Arrow(epsilon_delta, lim, color = WHITE)\n",
        "\n",
        "\n",
        "        self.student_says(\n",
        "            \"Too much theory!\",\n",
        "            target_mode = \"angry\",\n",
        "            content_introduction_kwargs = {\"run_time\" : 2},\n",
        "        )\n",
        "        self.wait()\n",
        "        student = self.get_students()[1]\n",
        "        Scene.play(self,\n",
        "            Write(lhs),\n",
        "            FadeOut(student.bubble),\n",
        "            FadeOut(student.bubble.content),\n",
        "            *[\n",
        "                ApplyFunction(\n",
        "                    lambda pi : pi.change_mode(\"pondering\").look_at(epsilon_delta),\n",
        "                    pi\n",
        "                )\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        student.bubble = None\n",
        "        part_tex_pairs = [\n",
        "            (\"df\", \"f\"),\n",
        "            (\"over\", \"+\"),\n",
        "            (\"over\", \"-\"),\n",
        "            (\"over\", \"to\"),\n",
        "            (\"over\", \"over\"),\n",
        "            (\"dx\", \"h\"),\n",
        "            (\"(\", \"(\"),\n",
        "            (\"x\", \"x\"),\n",
        "            (\")\", \")\"),\n",
        "        ]\n",
        "        self.play(Write(equals), Write(lim), *[\n",
        "            ReplacementTransform(\n",
        "                VGroup(*lhs.get_parts_by_tex(t1)).copy(),\n",
        "                VGroup(*rhs.get_parts_by_tex(t2)),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, alpha, alpha+0.5)\n",
        "            )\n",
        "            for (t1, t2), alpha in zip(\n",
        "                part_tex_pairs,\n",
        "                np.linspace(0, 0.5, len(part_tex_pairs))\n",
        "            )\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(epsilon_delta),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        derivative.add(epsilon_delta, arrow)\n",
        "        self.student_says(\n",
        "            \"How do you \\\\\\\\ compute limits?\",\n",
        "            index = 2,\n",
        "            added_anims = [\n",
        "                derivative.scale, 0.8,\n",
        "                derivative.to_corner, UP+LEFT\n",
        "            ]\n",
        "        )\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class LHopitalExample(LimitCounterExample, PiCreatureScene, ZoomedScene, ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : ORIGIN,\n",
        "        \"x_axis_width\" : FRAME_WIDTH,\n",
        "        \"x_min\" : -5,\n",
        "        \"x_max\" : 5,\n",
        "        \"x_labeled_nums\" : list(range(-6, 8, 2)),\n",
        "        \"x_axis_label\" : \"$x$\",\n",
        "        \"y_axis_height\" : FRAME_HEIGHT,\n",
        "        \"y_min\" : -3.1,\n",
        "        \"y_max\" : 3.1,\n",
        "        \"y_bottom_tick\" : -4,\n",
        "        \"y_labeled_nums\" : list(range(-2, 4, 2)),\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_color\" : RED,\n",
        "        \"hole_radius\" : 0.07,\n",
        "        \"big_delta\" : 0.5,\n",
        "        \"small_delta\" : 0.01,\n",
        "        \"dx\" : 0.06,\n",
        "        \"dx_color\" : WHITE,\n",
        "        \"tex_scale_value\" : 0.9,\n",
        "        \"sin_color\" : GREEN,\n",
        "        \"parabola_color\" : YELLOW,\n",
        "        \"zoomed_canvas_corner\" : DOWN+LEFT,\n",
        "        \"zoom_factor\" : 10,\n",
        "        \"zoomed_canvas_frame_shape\" : (5, 5),\n",
        "        \"zoomed_canvas_corner_buff\" : MED_SMALL_BUFF,\n",
        "        \"zoomed_rect_center_coords\" : (1 + 0.1, -0.03),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.introduce_function()\n",
        "        self.show_non_definedness_at_one()\n",
        "        self.plug_in_value_close_to_one()\n",
        "        self.ask_about_systematic_process()\n",
        "        self.show_graph_of_numerator_and_denominator()\n",
        "        self.zoom_in_to_trouble_point()\n",
        "        self.talk_through_sizes_of_nudges()\n",
        "        self.show_final_ratio()\n",
        "        self.show_final_height()\n",
        "\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        ZoomedScene.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "        self.remove(*self.get_pi_creatures()) \n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        self.x_axis_label_mob.set_color(self.x_color)\n",
        "\n",
        "    def introduce_function(self):\n",
        "        graph = self.get_graph(self.func)\n",
        "        colored_graph = graph.copy().set_color(YELLOW)\n",
        "        func_label = self.get_func_label()\n",
        "        func_label.next_to(ORIGIN, RIGHT, buff = LARGE_BUFF)\n",
        "        func_label.to_edge(UP)\n",
        "\n",
        "        x_copy = self.x_axis_label_mob.copy()\n",
        "\n",
        "        self.play(\n",
        "            Write(func_label),\n",
        "            Transform(\n",
        "                x_copy, VGroup(*func_label.get_parts_by_tex(\"x\")),\n",
        "                remover = True\n",
        "            )\n",
        "        )\n",
        "        self.play(ShowCreation(\n",
        "            graph,\n",
        "            run_time = 3,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait(4) ## Overly oscillation\n",
        "        self.play(ShowCreation(colored_graph, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(graph, run_time = 2))\n",
        "        self.remove(colored_graph)\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.func_label = func_label\n",
        "\n",
        "    def show_non_definedness_at_one(self):\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        words = OldTex(\"\\\\text{Try }\", \"x\", \"=1\")\n",
        "        words.set_color_by_tex(\"x\", self.x_color, substring = False)\n",
        "\n",
        "        v_line, alt_v_line = [\n",
        "            self.get_vertical_line_to_graph(\n",
        "                x, self.graph, \n",
        "                line_class = DashedLine,\n",
        "                color = self.x_color\n",
        "            )\n",
        "            for x in (1, -1)\n",
        "        ]\n",
        "        hole, alt_hole = [\n",
        "            self.get_hole(x, self.func(x))\n",
        "            for x in (1, -1)\n",
        "        ]\n",
        "        ed_group = self.get_epsilon_delta_group(\n",
        "            self.big_delta, limit_x = 1,\n",
        "        )\n",
        "\n",
        "        func_1 = self.get_func_label(\"1\")\n",
        "        func_1.next_to(self.func_label, DOWN, buff = MED_LARGE_BUFF)\n",
        "        rhs = OldTex(\"\\\\Rightarrow \\\\frac{0}{0}\")\n",
        "        rhs.next_to(func_1, RIGHT)\n",
        "        func_1_group = VGroup(func_1, *rhs)\n",
        "        func_1_group.add_to_back(BackgroundRectangle(func_1_group))\n",
        "\n",
        "        lim = OldTex(\"\\\\lim\", \"_{x\", \"\\\\to 1}\")\n",
        "        lim.set_color_by_tex(\"x\", self.x_color)\n",
        "        lim.move_to(self.func_label, LEFT)\n",
        "        self.func_label.generate_target()\n",
        "        self.func_label.target.next_to(lim, RIGHT)\n",
        "        equals_q = OldTex(\"=\", \"???\")\n",
        "        equals_q.next_to(self.func_label.target, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(morty, words))\n",
        "        self.play(\n",
        "            Blink(morty),\n",
        "            ShowCreation(v_line)\n",
        "        )\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                morty, target_mode = \"pondering\",\n",
        "                look_at = func_1\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.func_label.copy(),\n",
        "                func_1\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(VGroup(*rhs[:-1])))\n",
        "        self.wait()\n",
        "        self.play(Write(rhs[-1]))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(hole))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(alt_v_line))\n",
        "        self.play(GrowFromCenter(alt_hole))\n",
        "        self.wait()\n",
        "        alt_group = VGroup(alt_v_line, alt_hole)\n",
        "        self.play(alt_group.set_stroke, GREY, 2)\n",
        "        self.play(FocusOn(hole))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(GrowFromCenter(ed_group.input_range))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                ed_group.input_range.copy(),\n",
        "                ed_group.output_range\n",
        "            ),\n",
        "            *list(map(ShowCreation, ed_group.delta_lines))\n",
        "        )\n",
        "        self.play(*list(map(GrowFromCenter, ed_group.epsilon_lines)))\n",
        "        self.play(morty.change_mode, \"thinking\")\n",
        "        self.animate_epsilon_delta_group_change(\n",
        "            ed_group, target_delta = self.small_delta,\n",
        "            run_time = 4\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(lim),\n",
        "            MoveToTarget(self.func_label),\n",
        "            Write(equals_q),\n",
        "            morty.change_mode, \"confused\", \n",
        "            morty.look_at, lim\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            func_1_group.to_corner, UP+LEFT,\n",
        "            *list(map(FadeOut, [morty, ed_group]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.lim_group = VGroup(lim, self.func_label, equals_q)\n",
        "        for part in self.lim_group:\n",
        "            part.add_background_rectangle()\n",
        "        self.func_1_group = func_1_group\n",
        "        self.v_line = v_line\n",
        "\n",
        "    def plug_in_value_close_to_one(self):\n",
        "        num = 1.00001\n",
        "        result = self.func(num)\n",
        "        label = self.get_func_label(num)\n",
        "        label.add_background_rectangle()\n",
        "        rhs = OldTex(\"= %.4f\\\\dots\"%result)\n",
        "        rhs.next_to(label, RIGHT)\n",
        "        approx_group = VGroup(label, rhs)\n",
        "        approx_group.set_width(FRAME_X_RADIUS-2*MED_LARGE_BUFF)\n",
        "        approx_group.next_to(ORIGIN, UP, buff = MED_LARGE_BUFF)\n",
        "        approx_group.to_edge(RIGHT)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.func_label.copy(),\n",
        "            label\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "\n",
        "        self.approx_group = approx_group\n",
        "\n",
        "    def ask_about_systematic_process(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.change_mode(\"plain\")\n",
        "\n",
        "        self.func_1_group.save_state()\n",
        "        to_fade = VGroup(\n",
        "            *self.x_axis.numbers[:len(self.x_axis.numbers)/2]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(morty),\n",
        "            FadeOut(to_fade)\n",
        "        )\n",
        "        self.x_axis.remove(*to_fade)\n",
        "\n",
        "        self.pi_creature_says(\n",
        "            morty, \"Is there a \\\\\\\\ better way?\",\n",
        "            bubble_config = {\n",
        "                \"height\" : 3,\n",
        "                \"width\" : 4,\n",
        "            },\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                morty, target_mode = \"raise_left_hand\",\n",
        "                look_at = self.func_1_group\n",
        "            ),\n",
        "            self.func_1_group.scale, self.tex_scale_value,\n",
        "            self.func_1_group.move_to, \n",
        "                morty.get_corner(UP+LEFT), DOWN+LEFT,\n",
        "            self.func_1_group.shift, MED_LARGE_BUFF*UP,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look, UP+RIGHT,\n",
        "            FadeOut(self.approx_group),\n",
        "            self.func_1_group.restore,\n",
        "            self.lim_group.next_to, \n",
        "                morty.get_corner(UP+RIGHT), RIGHT,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(self.func_1_group),\n",
        "            self.lim_group.scale, self.tex_scale_value,\n",
        "            self.lim_group.to_corner, UP+LEFT,\n",
        "            # self.lim_group.next_to, ORIGIN, UP, MED_LARGE_BUFF,\n",
        "            # self.lim_group.to_edge, LEFT,\n",
        "            morty.change_mode, \"plain\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(morty))\n",
        "\n",
        "    def show_graph_of_numerator_and_denominator(self):\n",
        "        sine_graph = self.get_graph(\n",
        "            lambda x : np.sin(np.pi*x), \n",
        "            color = self.sin_color\n",
        "        )\n",
        "        sine_label = self.get_graph_label(\n",
        "            sine_graph, \"\\\\sin(\\\\pi x)\",\n",
        "            x_val = 4.5,\n",
        "            direction = UP\n",
        "        )\n",
        "        parabola = self.get_graph(\n",
        "            lambda x : x**2 - 1,\n",
        "            color = self.parabola_color\n",
        "        )\n",
        "        parabola_label = self.get_graph_label(\n",
        "            parabola, \"x^2 - 1\"\n",
        "        )\n",
        "        fader = VGroup(*[\n",
        "            Rectangle(\n",
        "                width = FRAME_WIDTH,\n",
        "                height = FRAME_HEIGHT,\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 0.75,\n",
        "                fill_color = BLACK,\n",
        "            ).next_to(self.coords_to_point(1, 0), vect, MED_LARGE_BUFF)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sine_graph, run_time = 2),\n",
        "            Animation(self.lim_group)\n",
        "        )\n",
        "        self.play(FadeIn(sine_label))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(parabola, run_time = 2))\n",
        "        self.play(FadeIn(parabola_label))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(fader, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(fader))\n",
        "\n",
        "        self.sine_graph = sine_graph\n",
        "        self.sine_label = sine_label\n",
        "        self.parabola = parabola\n",
        "        self.parabola_label = parabola_label\n",
        "\n",
        "    def zoom_in_to_trouble_point(self):\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle\n",
        "        lil_rect.scale(self.zoom_factor)\n",
        "        lil_rect.move_to(self.coords_to_point(\n",
        "            *self.zoomed_rect_center_coords\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(lil_rect.scale, 1./self.zoom_factor)\n",
        "        self.wait()\n",
        "\n",
        "    def talk_through_sizes_of_nudges(self):\n",
        "        arrow_tip_length = 0.15/self.zoom_factor\n",
        "        zoom_tex_scale_factor = min(\n",
        "            0.75/self.zoom_factor,\n",
        "            1.5*self.dx\n",
        "        )\n",
        "\n",
        "        dx_arrow = Arrow(\n",
        "            self.coords_to_point(1, 0),\n",
        "            self.coords_to_point(1+self.dx, 0),\n",
        "            tip_length = arrow_tip_length,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        dx_label = OldTex(\"dx\")\n",
        "        dx_label.scale(zoom_tex_scale_factor)\n",
        "        dx_label.next_to(dx_arrow, UP, buff = SMALL_BUFF/self.zoom_factor)\n",
        "\n",
        "        d_sine_arrow, d_parabola_arrow = [\n",
        "            Arrow(\n",
        "                self.coords_to_point(1+self.dx, 0),\n",
        "                self.coords_to_point(\n",
        "                    1+self.dx, \n",
        "                    graph.underlying_function(1+self.dx)\n",
        "                ),\n",
        "                tip_length = arrow_tip_length,\n",
        "                color = graph.get_color()\n",
        "            )\n",
        "            for graph in (self.sine_graph, self.parabola)\n",
        "        ]\n",
        "        tex_arrow_pairs = [\n",
        "            [(\"d\\\\big(\", \"\\\\sin(\", \"\\\\pi\", \"x\", \")\", \"\\\\big)\"), d_sine_arrow],\n",
        "            [(\"d\\\\big(\", \"x\", \"^2\", \"-1\", \"\\\\big)\"), d_parabola_arrow],\n",
        "            [(\"\\\\cos(\", \"\\\\pi\", \"x\", \")\", \"\\\\pi \", \"\\\\, dx\"), d_sine_arrow],\n",
        "            [(\"2\", \"x\", \"\\\\, dx\"), d_parabola_arrow],\n",
        "        ]\n",
        "        d_labels = []\n",
        "        for tex_args, arrow in tex_arrow_pairs:\n",
        "            label = OldTex(*tex_args)\n",
        "            label.set_color_by_tex(\"x\", self.x_color)\n",
        "            label.set_color_by_tex(\"dx\", self.dx_color)\n",
        "            label.scale(zoom_tex_scale_factor)\n",
        "            label.next_to(arrow, RIGHT, buff = SMALL_BUFF/self.zoom_factor)\n",
        "            d_labels.append(label)\n",
        "        d_sine_label, d_parabola_label, cos_dx, two_x_dx = d_labels\n",
        "\n",
        "        #Show dx        \n",
        "        self.play(ShowCreation(dx_arrow))\n",
        "        self.play(Write(dx_label))\n",
        "        self.wait()\n",
        "\n",
        "        #Show d_sine bump\n",
        "        point = VectorizedPoint(self.coords_to_point(1, 0))\n",
        "        self.play(ReplacementTransform(point, d_sine_arrow))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(dx_label[1].copy()),\n",
        "            d_sine_label,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            d_sine_label.shift, d_sine_label.get_height()*UP\n",
        "        )\n",
        "        tex_pair_lists = [\n",
        "            [\n",
        "                (\"sin\", \"cos\"),\n",
        "                (\"pi\", \"pi\"),\n",
        "                (\"x\", \"x\"),\n",
        "                (\")\", \")\"),\n",
        "            ],\n",
        "            [\n",
        "                (\"pi\", \"\\\\pi \"), #Space there is important, though hacky\n",
        "            ],\n",
        "            [\n",
        "                (\"d\\\\big(\", \"dx\"),\n",
        "                (\"\\\\big)\", \"dx\"),\n",
        "            ]\n",
        "        ]\n",
        "        for tex_pairs in tex_pair_lists:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    d_sine_label.get_part_by_tex(t1).copy(), \n",
        "                    cos_dx.get_part_by_tex(t2)\n",
        "                )\n",
        "                for t1, t2 in tex_pairs\n",
        "            ])\n",
        "            self.wait()\n",
        "        self.play(FadeOut(d_sine_label))\n",
        "        self.wait()\n",
        "\n",
        "        #Substitute x = 1\n",
        "        self.substitute_x_equals_1(cos_dx, zoom_tex_scale_factor)\n",
        "\n",
        "        #Proportionality constant\n",
        "        cos_pi = VGroup(*cos_dx[:-1])\n",
        "        cos = VGroup(*cos_dx[:-2])\n",
        "        brace = Brace(Line(LEFT, RIGHT), UP)\n",
        "        brace.set_width(cos_pi.get_width())\n",
        "        brace.move_to(cos_pi.get_top(), DOWN)\n",
        "        brace_text = OldTexText(\n",
        "            \"\"\"\n",
        "                \\\\begin{flushleft} \n",
        "                Proportionality\n",
        "                constant \n",
        "                \\\\end{flushleft}\n",
        "            \"\"\"\n",
        "        )\n",
        "        brace_text.scale(0.9*zoom_tex_scale_factor)\n",
        "        brace_text.add_background_rectangle()\n",
        "        brace_text.next_to(brace, UP, SMALL_BUFF/self.zoom_factor, LEFT)\n",
        "        neg_one = OldTex(\"-\", \"1\")\n",
        "        neg_one.add_background_rectangle()\n",
        "        neg_one.scale(zoom_tex_scale_factor)\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(brace_text))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            brace.set_width, cos.get_width(),\n",
        "            brace.next_to, cos, UP, SMALL_BUFF/self.zoom_factor,\n",
        "            FadeOut(brace_text)\n",
        "        )\n",
        "        neg_one.next_to(brace, UP, SMALL_BUFF/self.zoom_factor)\n",
        "        self.play(Write(neg_one))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(cos))\n",
        "        neg = neg_one.get_part_by_tex(\"-\").copy()\n",
        "        self.play(neg.next_to, cos_dx[-2], LEFT, SMALL_BUFF/self.zoom_factor)\n",
        "        self.play(*list(map(FadeOut, [neg_one, brace])))\n",
        "        neg_pi_dx = VGroup(neg, *cos_dx[-2:])\n",
        "        self.play(\n",
        "            neg_pi_dx.next_to, d_sine_arrow, \n",
        "            RIGHT, SMALL_BUFF/self.zoom_factor\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Show d_parabola bump\n",
        "        point = VectorizedPoint(self.coords_to_point(1, 0))\n",
        "        self.play(ReplacementTransform(point, d_parabola_arrow))\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(dx_label[1].copy()),\n",
        "            d_parabola_label,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            d_parabola_label.shift, d_parabola_label.get_height()*UP\n",
        "        )\n",
        "        tex_pair_lists = [\n",
        "            [\n",
        "                (\"2\", \"2\"),\n",
        "                (\"x\", \"x\"),\n",
        "            ],\n",
        "            [\n",
        "                (\"d\\\\big(\", \"dx\"),\n",
        "                (\"\\\\big)\", \"dx\"),\n",
        "            ]\n",
        "        ]\n",
        "        for tex_pairs in tex_pair_lists:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    d_parabola_label.get_part_by_tex(t1).copy(), \n",
        "                    two_x_dx.get_part_by_tex(t2)\n",
        "                )\n",
        "                for t1, t2 in tex_pairs\n",
        "            ])\n",
        "        self.wait()\n",
        "        self.play(FadeOut(d_parabola_label))\n",
        "        self.wait()\n",
        "\n",
        "        #Substitute x = 1\n",
        "        self.substitute_x_equals_1(two_x_dx, zoom_tex_scale_factor)\n",
        "\n",
        "    def substitute_x_equals_1(self, tex_mob, zoom_tex_scale_factor):\n",
        "        x = tex_mob.get_part_by_tex(\"x\")\n",
        "        equation = OldTex(\"x\", \"=\", \"1\")\n",
        "        eq_x, equals, one = equation\n",
        "        equation.scale(zoom_tex_scale_factor)\n",
        "        equation.next_to(\n",
        "            x, UP, \n",
        "            buff = MED_SMALL_BUFF/self.zoom_factor,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        equation.set_color_by_tex(\"x\", self.x_color)\n",
        "        equation.set_color_by_tex(\"1\", self.x_color)\n",
        "        dot_one = OldTex(\"\\\\cdot\", \"1\")\n",
        "        dot_one.scale(zoom_tex_scale_factor)\n",
        "        dot_one.set_color(self.x_color)\n",
        "        dot_one.move_to(x, DOWN+LEFT)\n",
        "\n",
        "        self.play(x.move_to, eq_x)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(x.copy(), eq_x),\n",
        "            Transform(x, one),\n",
        "            Write(equals)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(x, dot_one))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [eq_x, equals])))\n",
        "        self.wait()\n",
        "\n",
        "    def show_final_ratio(self):\n",
        "        lim, ratio, equals_q = self.lim_group\n",
        "        self.remove(self.lim_group)\n",
        "        self.add(*self.lim_group)\n",
        "        numerator = VGroup(*ratio[1][:3])\n",
        "        denominator = VGroup(*ratio[1][-2:])\n",
        "        rhs = OldTex(\n",
        "            \"\\\\approx\", \n",
        "            \"{-\\\\pi\", \"\\\\, dx\", \"\\\\over \\\\,\", \"2\", \"\\\\, dx}\"\n",
        "        )\n",
        "        rhs.add_background_rectangle()\n",
        "        rhs.move_to(equals_q, LEFT)\n",
        "        equals = OldTex(\"=\")\n",
        "        approx = rhs.get_part_by_tex(\"approx\")\n",
        "        equals.move_to(approx)\n",
        "\n",
        "        dxs = VGroup(*rhs.get_parts_by_tex(\"dx\"))\n",
        "        circles = VGroup(*[\n",
        "            Circle(color = GREEN).replace(dx).scale(1.3)\n",
        "            for dx in dxs\n",
        "        ])\n",
        "\n",
        "        #Show numerator and denominator\n",
        "        self.play(FocusOn(ratio))\n",
        "        for mob in numerator, denominator:\n",
        "            self.play(ApplyWave(\n",
        "                mob, direction = UP+RIGHT, amplitude = 0.1\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.play(ReplacementTransform(equals_q, rhs))\n",
        "        self.wait()\n",
        "\n",
        "        #Cancel dx's\n",
        "        self.play(*list(map(ShowCreation, circles)), run_time = 2)\n",
        "        self.wait()\n",
        "        self.play(dxs.fade, 0.75, FadeOut(circles))\n",
        "        self.wait()\n",
        "\n",
        "        #Shrink dx\n",
        "        self.transition_to_alt_config(\n",
        "            transformation_kwargs = {\"run_time\" : 2},\n",
        "            dx = self.dx/10\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(approx, equals))\n",
        "        self.play(Indicate(approx))\n",
        "        self.wait()\n",
        "\n",
        "        self.final_ratio = rhs\n",
        "\n",
        "    def show_final_height(self):\n",
        "        brace = Brace(self.v_line, LEFT)\n",
        "        height = brace.get_text(\"$\\\\dfrac{-\\\\pi}{2}$\")\n",
        "        height.add_background_rectangle()\n",
        "        \n",
        "        self.disactivate_zooming()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.sine_graph, self.sine_label,\n",
        "            self.parabola, self.parabola_label,\n",
        "        ])) + [\n",
        "            Animation(self.final_ratio)\n",
        "        ])\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(height))\n",
        "        self.wait(2)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Mortimer().flip().to_corner(DOWN+LEFT)\n",
        "        return self.pi_creature\n",
        "\n",
        "    def func(self, x):\n",
        "        if abs(x) != 1:\n",
        "            return np.sin(x*np.pi) / (x**2 - 1)\n",
        "        else:\n",
        "            return np.pi*np.cos(x*np.pi) / (2*x)\n",
        "\n",
        "    def get_func_label(self, argument = \"x\"):\n",
        "        in_tex = \"{%s}\"%str(argument)\n",
        "        result = OldTex(\n",
        "            \"{\\\\sin(\\\\pi \", in_tex, \")\", \" \\\\over \\\\,\",\n",
        "            in_tex, \"^2 - 1}\"\n",
        "        )\n",
        "        result.set_color_by_tex(in_tex, self.x_color)\n",
        "        return result\n",
        "\n",
        "    def get_epsilon_delta_group(self, delta, **kwargs):\n",
        "        ed_group = GraphLimitExpression.get_epsilon_delta_group(self, delta, **kwargs)\n",
        "        color = ed_group.kwargs[\"input_range_color\"]\n",
        "        radius = min(delta/2, self.hole_radius)\n",
        "        pairs = [\n",
        "            # (ed_group.input_range[0], (1, 0)),\n",
        "            (ed_group.input_range[1], (1, 0)),\n",
        "            # (ed_group.output_range[0], (1, self.func(1))),\n",
        "            (ed_group.output_range[1], (1, self.func(1))),\n",
        "        ]\n",
        "        for mob, coords in pairs:\n",
        "            mob.add(self.get_hole(\n",
        "                *coords, \n",
        "                color = color,\n",
        "                radius = radius\n",
        "            ))\n",
        "        return ed_group\n",
        "\n",
        "class DerivativeLimitReciprocity(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Arrow(LEFT, RIGHT, color = WHITE)\n",
        "        lim = OldTex(\"\\\\lim\", \"_{h\", \"\\\\to 0}\")\n",
        "        lim.set_color_by_tex(\"h\", GREEN)\n",
        "        lim.next_to(arrow, LEFT)\n",
        "        deriv = OldTex(\"{df\", \"\\\\over\\\\,\", \"dx}\")\n",
        "        deriv.set_color_by_tex(\"dx\", GREEN)\n",
        "        deriv.set_color_by_tex(\"df\", YELLOW)\n",
        "        deriv.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(lim, lag_ratio = 0.5))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(FadeIn(deriv, lag_ratio = 0.5))\n",
        "        self.wait()\n",
        "        self.play(Rotate(arrow, np.pi, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "class GeneralLHoptial(LHopitalExample):\n",
        "    CONFIG = {\n",
        "        \"f_color\" : BLUE,\n",
        "        \"g_color\" : YELLOW,\n",
        "        \"a_value\" : 2.5,\n",
        "        \"zoomed_rect_center_coords\" : (2.55, 0),\n",
        "        \"zoom_factor\" : 15,\n",
        "        \"image_height\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graphs()\n",
        "        self.zoom_in()\n",
        "        self.show_limit_in_symbols()\n",
        "        self.show_tiny_nudge()\n",
        "        self.show_derivative_ratio()\n",
        "        self.show_example()\n",
        "        self.show_bernoulli_and_lHopital()\n",
        "\n",
        "    def add_graphs(self):\n",
        "        f_graph = self.get_graph(self.f, self.f_color)\n",
        "        f_label = self.get_graph_label(\n",
        "            f_graph, \"f(x)\", \n",
        "            x_val = 3, \n",
        "            direction = RIGHT\n",
        "        )\n",
        "        g_graph = ParametricCurve(\n",
        "            lambda y : self.coords_to_point(np.exp(y)+self.a_value-1, y),\n",
        "            t_min = self.y_min,\n",
        "            t_max = self.y_max,\n",
        "            color = self.g_color\n",
        "        )\n",
        "        g_graph.underlying_function = self.g\n",
        "        g_label = self.get_graph_label(\n",
        "            g_graph, \"g(x)\", x_val = 4, direction = UP\n",
        "        )\n",
        "\n",
        "        a_dot = Dot(self.coords_to_point(self.a_value, 0))\n",
        "        a_label = OldTex(\"x = a\")\n",
        "        a_label.next_to(a_dot, UP, LARGE_BUFF)\n",
        "        a_arrow = Arrow(a_label.get_bottom(), a_dot, buff = SMALL_BUFF)\n",
        "        VGroup(a_dot, a_label, a_arrow).set_color(self.x_color)\n",
        "\n",
        "        self.play(ShowCreation(f_graph), Write(f_label))\n",
        "        self.play(ShowCreation(g_graph), Write(g_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(a_label),\n",
        "            ShowCreation(a_arrow),\n",
        "            ShowCreation(a_dot),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [a_label, a_arrow])))\n",
        "\n",
        "        self.a_dot = a_dot\n",
        "        self.f_graph = f_graph\n",
        "        self.f_label = f_label\n",
        "        self.g_graph = g_graph\n",
        "        self.g_label = g_label\n",
        "\n",
        "    def zoom_in(self):\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle\n",
        "        lil_rect.scale(self.zoom_factor)\n",
        "        lil_rect.move_to(self.coords_to_point(\n",
        "            *self.zoomed_rect_center_coords\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lil_rect.scale, 1./self.zoom_factor,\n",
        "            self.a_dot.scale, 1./self.zoom_factor,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_limit_in_symbols(self):\n",
        "        frac_a = self.get_frac(\"a\", self.x_color)\n",
        "        frac_x = self.get_frac(\"x\")\n",
        "        lim = OldTex(\"\\\\lim\", \"_{x\", \"\\\\to\", \"a}\")\n",
        "        lim.set_color_by_tex(\"a\", self.x_color)\n",
        "        equals_zero_over_zero = OldTex(\n",
        "            \"=\", \"{\\\\, 0 \\\\,\", \"\\\\over \\\\,\", \"0 \\\\,}\"\n",
        "        )\n",
        "        equals_q = OldTex(*\"=???\")\n",
        "        frac_x.next_to(lim, RIGHT, SMALL_BUFF)\n",
        "        VGroup(lim, frac_x).to_corner(UP+LEFT)\n",
        "        frac_a.move_to(frac_x)\n",
        "        equals_zero_over_zero.next_to(frac_a, RIGHT)\n",
        "        equals_q.next_to(frac_a, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*self.f_label).copy(), \n",
        "                VGroup(frac_a.numerator)\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                VGroup(*self.g_label).copy(),\n",
        "                VGroup(frac_a.denominator)\n",
        "            ),\n",
        "            Write(frac_a.over),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(equals_zero_over_zero))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*frac_a.get_parts_by_tex(\"a\")),\n",
        "                VGroup(lim.get_part_by_tex(\"a\"))\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(VGroup(*lim[:-1])))\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(*lim.get_parts_by_tex(\"x\")).copy(),\n",
        "            VGroup(*frac_x.get_parts_by_tex(\"x\"))\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            equals_zero_over_zero, equals_q\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(frac_a)\n",
        "        self.add(frac_x)\n",
        "        self.frac_x = frac_x\n",
        "        self.remove(equals_q)\n",
        "        self.add(*equals_q)\n",
        "        self.equals_q = equals_q\n",
        "\n",
        "    def show_tiny_nudge(self):\n",
        "        arrow_tip_length = 0.15/self.zoom_factor\n",
        "        zoom_tex_scale_factor = min(\n",
        "            0.75/self.zoom_factor,\n",
        "            1.5*self.dx\n",
        "        )\n",
        "        z_small_buff = SMALL_BUFF/self.zoom_factor\n",
        "\n",
        "        dx_arrow = Arrow(\n",
        "            self.coords_to_point(self.a_value, 0),\n",
        "            self.coords_to_point(self.a_value+self.dx, 0),\n",
        "            tip_length = arrow_tip_length,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        dx_label = OldTex(\"dx\")\n",
        "        dx_label.scale(zoom_tex_scale_factor)\n",
        "        dx_label.next_to(dx_arrow, UP, buff = z_small_buff)\n",
        "        dx_label.shift(z_small_buff*RIGHT)\n",
        "\n",
        "        df_arrow, dg_arrow = [\n",
        "            Arrow(\n",
        "                self.coords_to_point(self.a_value+self.dx, 0),\n",
        "                self.coords_to_point(\n",
        "                    self.a_value+self.dx, \n",
        "                    graph.underlying_function(self.a_value+self.dx)\n",
        "                ),\n",
        "                tip_length = arrow_tip_length,\n",
        "                color = graph.get_color()\n",
        "            )\n",
        "            for graph in (self.f_graph, self.g_graph)\n",
        "        ]\n",
        "        v_labels = []\n",
        "        for char, arrow in (\"f\", df_arrow), (\"g\", dg_arrow):\n",
        "            label = OldTex(\n",
        "                \"\\\\frac{d%s}{dx}\"%char, \"(\", \"a\", \")\", \"\\\\,dx\"\n",
        "            )\n",
        "            label.scale(zoom_tex_scale_factor)\n",
        "            label.set_color_by_tex(\"a\", self.x_color)\n",
        "            label.set_color_by_tex(\"frac\", arrow.get_color())\n",
        "            label.next_to(arrow, RIGHT, z_small_buff)\n",
        "            v_labels.append(label)\n",
        "        df_label, dg_label = v_labels\n",
        "\n",
        "        self.play(ShowCreation(dx_arrow))\n",
        "        self.play(Write(dx_label))\n",
        "        self.play(Indicate(dx_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(ShowCreation(df_arrow))\n",
        "        self.play(Write(df_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(dg_arrow))\n",
        "        self.play(Write(dg_label))\n",
        "        self.wait()\n",
        "\n",
        "    def show_derivative_ratio(self):\n",
        "        q_marks = VGroup(*self.equals_q[1:])\n",
        "\n",
        "        deriv_ratio = OldTex(\n",
        "            \"{ \\\\frac{df}{dx}\", \"(\", \"a\", \")\", \"\\\\,dx\",\n",
        "            \"\\\\over \\\\,\",\n",
        "            \"\\\\frac{dg}{dx}\", \"(\", \"a\", \")\", \"\\\\,dx}\",\n",
        "        )\n",
        "        deriv_ratio.set_color_by_tex(\"a\", self.x_color)\n",
        "        deriv_ratio.set_color_by_tex(\"df\", self.f_color)\n",
        "        deriv_ratio.set_color_by_tex(\"dg\", self.g_color)\n",
        "        deriv_ratio.move_to(q_marks, LEFT)\n",
        "\n",
        "        dxs = VGroup(*deriv_ratio.get_parts_by_tex(\"\\\\,dx\"))\n",
        "        circles = VGroup(*[\n",
        "            Circle(color = GREEN).replace(dx).scale(1.3)\n",
        "            for dx in dxs\n",
        "        ])\n",
        "\n",
        "        self.play(FadeOut(q_marks))\n",
        "        self.play(Write(deriv_ratio))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(FadeIn(circles))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(circles), dxs.fade, 0.75)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.transition_to_alt_config(\n",
        "            transformation_kwargs = {\"run_time\" : 2},\n",
        "            dx = self.dx/10,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_example(self):\n",
        "        lhs = OldTex(\n",
        "            \"\\\\lim\", \"_{x \\\\to\", \"0}\",\n",
        "            \"{\\\\sin(\", \"x\", \")\", \"\\\\over \\\\,\", \"x}\",\n",
        "        )\n",
        "        rhs = OldTex(\n",
        "            \"=\", \n",
        "            \"{\\\\cos(\", \"0\", \")\", \"\\\\over \\\\,\", \"1}\",\n",
        "            \"=\", \"1\"\n",
        "        )\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "        equation = VGroup(lhs, rhs)\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        for part in equation:\n",
        "            part.set_color_by_tex(\"0\", self.x_color)\n",
        "        brace = Brace(lhs, DOWN)\n",
        "        brace_text = brace.get_text(\"Looks like 0/0\")\n",
        "        brace_text.add_background_rectangle()\n",
        "\n",
        "        name = OldTexText(\n",
        "            \"``\", \"L'H\u00f4pital's\", \" rule\", \"''\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        name.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        name.to_edge(UP)\n",
        "\n",
        "        self.play(Write(lhs))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(rhs[0]), ReplacementTransform(\n",
        "            VGroup(*lhs[3:6]).copy(),\n",
        "            VGroup(*rhs[1:4])\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(*lhs[6:8]).copy(),\n",
        "            VGroup(*rhs[4:6]),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(*rhs[6:])))\n",
        "        self.wait(2)\n",
        "\n",
        "        ##Slide away\n",
        "        example = VGroup(lhs, rhs, brace, brace_text)\n",
        "        self.play(\n",
        "            example.scale, 0.7,\n",
        "            example.to_corner, DOWN+RIGHT, SMALL_BUFF,\n",
        "            path_arc = 7*np.pi/6,\n",
        "        )\n",
        "        self.play(Write(name))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.rule_name = name\n",
        "\n",
        "    def show_bernoulli_and_lHopital(self):\n",
        "        lhopital_name = self.rule_name.get_part_by_tex(\"L'H\u00f4pital's\")\n",
        "        strike = Line(\n",
        "            lhopital_name.get_left(),\n",
        "            lhopital_name.get_right(),\n",
        "            color = RED\n",
        "        )\n",
        "        bernoulli_name = OldTexText(\"Bernoulli's\")\n",
        "        bernoulli_name.next_to(lhopital_name, DOWN)\n",
        "\n",
        "        bernoulli_image = ImageMobject(\"Johann_Bernoulli2\")\n",
        "        lhopital_image = ImageMobject(\"Guillaume_de_L'Hopital\")\n",
        "        for image in bernoulli_image, lhopital_image:\n",
        "            image.set_height(self.image_height)\n",
        "            image.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(ORIGIN, DOWN, buff = 0, color = GREEN)\n",
        "        arrow.next_to(lhopital_image, DOWN, buff = SMALL_BUFF)\n",
        "        dollars = VGroup(*[Tex(\"\\\\$\") for x in range(5)])\n",
        "        for dollar, alpha in zip(dollars, np.linspace(0, 1, len(dollars))):\n",
        "            angle = alpha*np.pi\n",
        "            dollar.move_to(np.sin(angle)*RIGHT + np.cos(angle)*UP)\n",
        "        dollars.set_color(GREEN)\n",
        "        dollars.next_to(arrow, RIGHT, MED_LARGE_BUFF)\n",
        "        dollars[0].set_fill(opacity = 0)\n",
        "        dollars.save_state()\n",
        "\n",
        "        self.play(ShowCreation(strike))\n",
        "        self.play(\n",
        "            Write(bernoulli_name),\n",
        "            FadeIn(bernoulli_image)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(lhopital_image),\n",
        "            bernoulli_image.next_to, arrow, DOWN, SMALL_BUFF,\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(dollars)\n",
        "        )\n",
        "\n",
        "        for x in range(10):\n",
        "            dollars.restore()\n",
        "            self.play(*[\n",
        "                Transform(*pair)\n",
        "                for pair in zip(dollars, dollars[1:])\n",
        "            ] + [\n",
        "                FadeOut(dollars[-1])\n",
        "            ])\n",
        "\n",
        "    ####\n",
        "\n",
        "    def f(self, x):\n",
        "        return -0.1*(x-self.a_value)*x*(x+4.5)\n",
        "\n",
        "    def g(self, x):\n",
        "        return np.log(x-self.a_value+1)\n",
        "\n",
        "    def get_frac(self, input_tex, color = WHITE):\n",
        "        result = OldTex(\n",
        "            \"{f\", \"(\", input_tex, \")\", \"\\\\over \\\\,\",\n",
        "            \"g\", \"(\", input_tex, \")}\"\n",
        "        )\n",
        "        result.set_color_by_tex(\"f\", self.f_color)\n",
        "        result.set_color_by_tex(\"g\", self.g_color)\n",
        "        result.set_color_by_tex(input_tex, color)\n",
        "\n",
        "        result.numerator = VGroup(*result[:4])\n",
        "        result.denominator = VGroup(*result[-4:])\n",
        "        result.over = result.get_part_by_tex(\"over\")\n",
        "\n",
        "        return result\n",
        "\n",
        "class CannotUseLHopital(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        deriv = OldTex(\n",
        "            \"{d(e^x)\", \"\\\\over \\\\,\", \"dx}\", \"(\", \"x\", \")\", \"=\",\n",
        "            \"\\\\lim\", \"_{h\", \"\\\\to 0}\",\n",
        "            \"{e^{\", \"x\", \"+\", \"h}\", \n",
        "            \"-\", \"e^\", \"x\",\n",
        "            \"\\\\over \\\\,\", \"h}\"\n",
        "        )\n",
        "        deriv.to_edge(UP)\n",
        "        deriv.set_color_by_tex(\"x\", RED)\n",
        "        deriv.set_color_by_tex(\"dx\", GREEN)\n",
        "        deriv.set_color_by_tex(\"h\", GREEN)\n",
        "        deriv.set_color_by_tex(\"e^\", YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(deriv),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"pondering\", pi.look_at, deriv]\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"Use L'H\u00f4pital's rule!\", \n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        answer = OldTex(\n",
        "            \"\\\\text{That requires knowing }\",\n",
        "            \"{d(e^x)\", \"\\\\over \\\\,\", \"dx}\"\n",
        "        )\n",
        "        answer.set_color_by_tex(\"e^\", YELLOW)\n",
        "        answer.set_color_by_tex(\"dx\", GREEN)\n",
        "        self.teacher_says(\n",
        "            answer,\n",
        "            bubble_config = {\"height\" : 2.5},\n",
        "            target_mode = \"hesitant\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class NextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        next_video = series[7]\n",
        "        brace = Brace(next_video, DOWN)\n",
        "\n",
        "        integral = OldTex(\"\\\\int\", \"f(x)\", \"dx\")\n",
        "        ftc = OldTex(\n",
        "            \"F(b)\", \"-\", \"F(a)\", \"=\", \"\\\\int_a^b\", \n",
        "            \"{dF\", \"\\\\over \\\\,\", \"dx}\", \"(x)\", \"dx\"\n",
        "        )\n",
        "        for tex_mob in integral, ftc:\n",
        "            tex_mob.set_color_by_tex(\"dx\", GREEN)\n",
        "            tex_mob.set_color_by_tex(\"f\", YELLOW)\n",
        "            tex_mob.set_color_by_tex(\"F\", YELLOW)\n",
        "            tex_mob.next_to(brace, DOWN)\n",
        "\n",
        "        self.add(series)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            next_video.set_color, YELLOW,\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "            self.get_teacher().look_at, next_video\n",
        "        )\n",
        "        self.play(Write(integral))\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(*integral.get_parts_by_tex(p1)),\n",
        "                VGroup(*ftc.get_parts_by_tex(p2)),\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi/2,\n",
        "                rate_func = squish_rate_func(smooth, alpha, alpha+0.5)\n",
        "            )\n",
        "            for alpha, (p1, p2) in zip(np.linspace(0, 0.5, 3), [\n",
        "                (\"int\", \"int\"),\n",
        "                (\"f\", \"F\"),\n",
        "                (\"dx\", \"dx\"),\n",
        "            ])\n",
        "        ]+[\n",
        "            Write(VGroup(*ftc.get_parts_by_tex(part)))\n",
        "            for part in (\"-\", \"=\", \"over\", \"(x)\")\n",
        "        ])\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class Chapter7PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali  Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Nathan Pellegrin\",\n",
        "            \"Karan Bhargava\", \n",
        "            \"Ankit   Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Daan Smedinga\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Albert Nguyen\",\n",
        "            \"Nils Schneider\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        lim = OldTex(\"\\\\lim\", \"_{h\", \"\\\\to 0}\")\n",
        "        lim.set_color_by_tex(\"h\", GREEN)\n",
        "        lim.set_height(5)\n",
        "        self.add(lim)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}