{
    "topic": "demonstrates the concept of a continued fraction, which is a way of representing a decimal",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "from fractions import Fraction, gcd\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from .inventing_math import Underbrace\n",
        "\n",
        "import random\n",
        "\n",
        "MOVIE_PREFIX = \"music_and_measure/\"\n",
        "\n",
        "INTERVAL_RADIUS = 6\n",
        "NUM_INTERVAL_TICKS = 16\n",
        "TICK_STRETCH_FACTOR = 4\n",
        "INTERVAL_COLOR_PALETTE = [\n",
        "    \"yellow\",\n",
        "    \"green\",\n",
        "    \"skyblue\",\n",
        "    \"#AD1457\",\n",
        "    \"#6A1B9A\",\n",
        "    \"#26C6DA\",\n",
        "    \"#FF8F00\",\n",
        "]\n",
        "\n",
        "def rationals():\n",
        "    curr = Fraction(1, 2)\n",
        "    numerator, denominator = 1, 2\n",
        "    while True:\n",
        "        yield curr\n",
        "        if curr.numerator < curr.denominator - 1:\n",
        "            new_numerator = curr.numerator + 1\n",
        "            while gcd(new_numerator, curr.denominator) != 1:\n",
        "                new_numerator += 1\n",
        "            curr = Fraction(new_numerator, curr.denominator)\n",
        "        else:\n",
        "            curr = Fraction(1, curr.denominator + 1)\n",
        "\n",
        "def fraction_mobject(fraction):\n",
        "    n, d = fraction.numerator, fraction.denominator\n",
        "    return OldTex(\"\\\\frac{%d}{%d}\"%(n, d))\n",
        "\n",
        "def continued_fraction(int_list):\n",
        "    if len(int_list) == 1:\n",
        "        return int_list[0]\n",
        "    return int_list[0] + Fraction(1, continued_fraction(int_list[1:]))\n",
        "\n",
        "def zero_to_one_interval():\n",
        "    interval = NumberLine(\n",
        "        radius = INTERVAL_RADIUS,\n",
        "        interval_size = 2.0*INTERVAL_RADIUS/NUM_INTERVAL_TICKS\n",
        "    )\n",
        "    interval.elongate_tick_at(-INTERVAL_RADIUS, TICK_STRETCH_FACTOR)\n",
        "    interval.elongate_tick_at(INTERVAL_RADIUS, TICK_STRETCH_FACTOR)\n",
        "    interval.add(OldTex(\"0\").shift(INTERVAL_RADIUS*LEFT+DOWN))\n",
        "    interval.add(OldTex(\"1\").shift(INTERVAL_RADIUS*RIGHT+DOWN))\n",
        "    return interval\n",
        "\n",
        "class LeftParen(Mobject):\n",
        "    def init_points(self):\n",
        "        self.add(OldTex(\"(\"))\n",
        "        self.center()    \n",
        "\n",
        "    def get_center(self):\n",
        "        return Mobject.get_center(self) + 0.04*LEFT\n",
        "\n",
        "class RightParen(Mobject):\n",
        "    def init_points(self):\n",
        "        self.add(OldTex(\")\"))\n",
        "        self.center()\n",
        "\n",
        "    def get_center(self):\n",
        "        return Mobject.get_center(self) + 0.04*RIGHT\n",
        "\n",
        "\n",
        "class OpenInterval(Mobject):\n",
        "    def __init__(self, center_point = ORIGIN, width = 2, **kwargs):\n",
        "        digest_config(self, kwargs, locals())\n",
        "        left = LeftParen().shift(LEFT*width/2)\n",
        "        right = RightParen().shift(RIGHT*width/2)\n",
        "        Mobject.__init__(self, left, right, **kwargs)\n",
        "         # scale_factor = width / 2.0\n",
        "        # self.stretch(scale_factor, 0)\n",
        "        # self.stretch(0.5+0.5*scale_factor, 1)\n",
        "        self.shift(center_point)\n",
        "\n",
        "class Piano(ImageMobject):\n",
        "    CONFIG = {\n",
        "        \"stroke_width\" : 1,\n",
        "        \"invert\" : False, \n",
        "        \"scale_factorue\" : 0.5\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        ImageMobject.__init__(self, \"piano_keyboard\")\n",
        "        jump = self.get_width()/24        \n",
        "        self.center()\n",
        "        self.half_note_jump = self.get_width()/24\n",
        "        self.ivory_jump = self.get_width()/14\n",
        "\n",
        "    def split(self):\n",
        "        left = self.get_left()[0]\n",
        "        keys = []\n",
        "        for count in range(14):\n",
        "            key = Mobject(\n",
        "                color = \"white\",\n",
        "                stroke_width = 1\n",
        "            )\n",
        "            x0 = left + count*self.ivory_jump\n",
        "            x1 = x0 + self.ivory_jump\n",
        "            key.add_points(\n",
        "                self.get_points()[\n",
        "                    (self.get_points()[:,0] > x0)*(self.get_points()[:,0] < x1)\n",
        "                ]\n",
        "            )\n",
        "            keys.append(key)\n",
        "        return keys\n",
        "\n",
        "\n",
        "class Vibrate(Animation):\n",
        "    CONFIG = {\n",
        "        \"num_periods\" : 1,\n",
        "        \"overtones\" : 4,\n",
        "        \"amplitude\" : 0.5,\n",
        "        \"radius\" : INTERVAL_RADIUS,\n",
        "        \"center\" : ORIGIN,\n",
        "        \"color\" : \"white\",\n",
        "        \"run_time\" : 3.0,\n",
        "        \"rate_func\" : None\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        def func(x, t):\n",
        "            return sum([\n",
        "                (self.amplitude/((k+1)**2.5))*np.sin(2*mult*t)*np.sin(k*mult*x)\n",
        "                for k in range(self.overtones)\n",
        "                for mult in [(self.num_periods+k)*np.pi]\n",
        "            ])\n",
        "        self.func = func\n",
        "        Animation.__init__(self, Mobject1D(color = self.color), **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        self.mobject.reset_points()\n",
        "        epsilon = self.mobject.epsilon\n",
        "        self.mobject.add_points([\n",
        "            [x*self.radius, self.func(x, alpha*self.run_time)+y, 0]\n",
        "            for x in np.arange(-1, 1, epsilon/self.radius)\n",
        "            for y in epsilon*np.arange(3)\n",
        "        ])\n",
        "        self.mobject.shift(self.center)\n",
        "\n",
        "\n",
        "class IntervalScene(NumberLineScene):\n",
        "    def construct(self):\n",
        "        self.number_line = UnitInterval()\n",
        "        self.displayed_numbers = [0, 1]\n",
        "        self.number_mobs = self.number_line.get_number_mobjects(*self.displayed_numbers)\n",
        "        self.add(self.number_line, *self.number_mobs)\n",
        "\n",
        "    def show_all_fractions(self, \n",
        "                           num_fractions = 27, \n",
        "                           pause_time = 1.0,\n",
        "                           remove_as_you_go = True):\n",
        "        shrink = not remove_as_you_go\n",
        "        for fraction, count in zip(rationals(), list(range(num_fractions))):\n",
        "            frac_mob, tick  = self.add_fraction(fraction, shrink)\n",
        "            self.wait(pause_time)\n",
        "            if remove_as_you_go:\n",
        "                self.remove(frac_mob, tick)\n",
        "\n",
        "    def add_fraction(self, fraction, shrink = False):\n",
        "        point = self.number_line.number_to_point(fraction)\n",
        "        tick_rad = self.number_line.tick_size*TICK_STRETCH_FACTOR        \n",
        "        frac_mob = fraction_mobject(fraction)\n",
        "        if shrink:\n",
        "            scale_factor = 2.0/fraction.denominator\n",
        "            frac_mob.scale(scale_factor)\n",
        "            tick_rad *= scale_factor\n",
        "        frac_mob.shift(point + frac_mob.get_height()*UP)\n",
        "        tick = Line(point + DOWN*tick_rad, point + UP*tick_rad)\n",
        "        tick.set_color(\"yellow\")\n",
        "        self.add(frac_mob, tick)\n",
        "        return frac_mob, tick\n",
        "\n",
        "    def add_fraction_ticks(self, num_fractions = 1000, run_time = 0):\n",
        "        long_tick_size = self.number_line.tick_size*TICK_STRETCH_FACTOR\n",
        "        all_ticks = []\n",
        "        for frac, count in zip(rationals(), list(range(num_fractions))):\n",
        "            point = self.number_line.number_to_point(frac)\n",
        "            tick_rad = 2.0*long_tick_size/frac.denominator\n",
        "            tick = Line(point+tick_rad*DOWN, point+tick_rad*UP)\n",
        "            tick.set_color(\"yellow\")\n",
        "            all_ticks.append(tick)\n",
        "        all_ticks = Mobject(*all_ticks)\n",
        "        if run_time > 0:\n",
        "            self.play(ShowCreation(all_ticks))\n",
        "        else:\n",
        "            self.add(all_ticks)\n",
        "        return all_ticks\n",
        "\n",
        "\n",
        "    def cover_fractions(self, \n",
        "                        epsilon = 0.3, \n",
        "                        num_fractions = 10,\n",
        "                        run_time_per_interval = 0.5):\n",
        "        intervals = []\n",
        "        lines = []\n",
        "        num_intervals = 0\n",
        "        all_rationals = rationals()\n",
        "        count = 0\n",
        "        while True:\n",
        "            fraction = next(all_rationals)\n",
        "            count += 1\n",
        "            if num_intervals >= num_fractions:\n",
        "                break\n",
        "            if fraction < self.number_line.left_num or fraction > self.number_line.right_num:\n",
        "                continue\n",
        "            num_intervals += 1\n",
        "            interval, line = self.add_open_interval(\n",
        "                fraction,\n",
        "                epsilon / min(2**count, 2**30),\n",
        "                run_time = run_time_per_interval\n",
        "            )\n",
        "            intervals.append(interval)\n",
        "            lines.append(line)\n",
        "        return intervals, lines\n",
        "\n",
        "    def add_open_interval(self, num, width, color = None, run_time = 0):\n",
        "        spatial_width = width*self.number_line.unit_length_to_spatial_width\n",
        "        center_point = self.number_line.number_to_point(num)\n",
        "        open_interval = OpenInterval(center_point, spatial_width)\n",
        "        color = color or \"yellow\"\n",
        "        interval_line = Line(\n",
        "            center_point+spatial_width*LEFT/2,\n",
        "            center_point+spatial_width*RIGHT/2\n",
        "        )\n",
        "        interval_line.do_in_place(interval_line.sort_points, get_norm)\n",
        "        interval_line.set_color(color)\n",
        "        if run_time > 0:\n",
        "            squished_interval = deepcopy(open_interval).stretch_to_fit_width(0)\n",
        "            self.play(\n",
        "                Transform(squished_interval, open_interval),\n",
        "                ShowCreation(interval_line),\n",
        "                run_time = run_time\n",
        "            )\n",
        "            self.remove(squished_interval)\n",
        "        self.add(open_interval, interval_line)\n",
        "        return open_interval, interval_line\n",
        "\n",
        "\n",
        "class TwoChallenges(Scene):\n",
        "    def construct(self):\n",
        "        two_challenges = OldTexText(\"Two Challenges\", size = \"\\\\Huge\").to_edge(UP)\n",
        "        one, two = list(map(TexText, [\"1.\", \"2.\"]))\n",
        "        one.shift(UP).to_edge(LEFT)\n",
        "        two.shift(DOWN).to_edge(LEFT)\n",
        "        notes = ImageMobject(\"musical_notes\").scale(0.3)\n",
        "        notes.next_to(one)\n",
        "        notes.set_color(\"blue\")\n",
        "        measure = OldTexText(\"Measure Theory\").next_to(two)\n",
        "        probability = OldTexText(\"Probability\")\n",
        "        probability.next_to(measure).shift(DOWN+RIGHT)\n",
        "        integration = OldTex(\"\\\\int\")\n",
        "        integration.next_to(measure).shift(UP+RIGHT)\n",
        "        arrow_to_prob = Arrow(measure, probability)\n",
        "        arrow_to_int = Arrow(measure, integration)\n",
        "        for arrow in arrow_to_prob, arrow_to_int:\n",
        "            arrow.set_color(\"yellow\")\n",
        "\n",
        "\n",
        "        self.add(two_challenges)\n",
        "        self.wait()\n",
        "        self.add(one, notes)\n",
        "        self.wait()\n",
        "        self.add(two, measure)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow_to_int))\n",
        "        self.add(integration)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow_to_prob))\n",
        "        self.add(probability)\n",
        "        self.wait()\n",
        "\n",
        "class MeasureTheoryToHarmony(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.cover_fractions()\n",
        "        self.wait()\n",
        "        all_mobs = Mobject(*self.mobjects)\n",
        "        all_mobs.sort_points()\n",
        "        self.clear()\n",
        "        radius = self.interval.radius\n",
        "        line = Line(radius*LEFT, radius*RIGHT).set_color(\"white\")\n",
        "        self.play(DelayByOrder(Transform(all_mobs, line)))\n",
        "        self.clear()\n",
        "        self.play(Vibrate(rate_func = smooth))\n",
        "        self.clear()\n",
        "        self.add(line)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ChallengeOne(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Challenge #1\").to_edge(UP)\n",
        "        start_color = Color(\"blue\")\n",
        "        colors = start_color.range_to(\"white\", 6)\n",
        "        self.bottom_vibration = Vibrate(\n",
        "            num_periods = 1, run_time = 3.0, \n",
        "            center = DOWN, color = start_color\n",
        "        )\n",
        "        top_vibrations = [\n",
        "            Vibrate(\n",
        "                num_periods = freq, run_time = 3.0,\n",
        "                center = 2*UP, color = next(colors)\n",
        "            )\n",
        "            for freq in [1, 2, 5.0/3, 4.0/3, 2]\n",
        "        ]\n",
        "        freq_220 = OldTexText(\"220 Hz\")\n",
        "        freq_r220 = OldTexText(\"$r\\\\times$220 Hz\")\n",
        "        freq_330 = OldTexText(\"1.5$\\\\times$220 Hz\")\n",
        "        freq_sqrt2 = OldTexText(\"$\\\\sqrt{2}\\\\times$220 Hz\")\n",
        "        freq_220.shift(1.5*DOWN)\n",
        "        for freq in freq_r220, freq_330, freq_sqrt2:\n",
        "            freq.shift(1.5*UP)\n",
        "        r_constraint = OldTex(\"(1<r<2)\", size = \"\\\\large\")\n",
        "\n",
        "        self.add(title)\n",
        "        self.wait()\n",
        "        self.vibrate(1)\n",
        "        self.add(freq_220)\n",
        "        self.vibrate(1)\n",
        "        self.add(r_constraint)\n",
        "        self.vibrate(1)\n",
        "        self.add(freq_r220)\n",
        "        self.vibrate(2, top_vibrations[1])\n",
        "        self.remove(freq_r220, r_constraint)\n",
        "        self.add(freq_330)\n",
        "        self.vibrate(2, top_vibrations[2])\n",
        "        self.remove(freq_330)\n",
        "        self.add(freq_sqrt2)\n",
        "        self.vibrate(1, top_vibrations[3])\n",
        "        self.remove(freq_sqrt2)\n",
        "        self.continuously_vary_frequency(top_vibrations[0], top_vibrations[4])\n",
        "\n",
        "    def vibrate(self, num_repeats, *top_vibrations):\n",
        "        anims = [self.bottom_vibration] + list(top_vibrations)\n",
        "        for count in range(num_repeats):\n",
        "            self.play(*anims)\n",
        "        self.remove(*[a.mobject for a in anims])\n",
        "\n",
        "    def continuously_vary_frequency(self, top_vib_1, top_vib_2):\n",
        "        number_line = NumberLine(interval_size = 1).add_numbers()\n",
        "\n",
        "        one, two = 2*number_line.interval_size*RIGHT, 4*number_line.interval_size*RIGHT\n",
        "        arrow1 = Arrow(one+UP, one)\n",
        "        arrow2 = Arrow(two+UP, two)\n",
        "        r1 = OldTex(\"r\").next_to(arrow1, UP)\n",
        "        r2 = OldTex(\"r\").next_to(arrow2, UP)\n",
        "        kwargs = {\n",
        "            \"run_time\" : 5.0,\n",
        "            \"rate_func\" : there_and_back\n",
        "        }\n",
        "        run_time = 3.0\n",
        "        vibrations = [self.bottom_vibration, top_vib_1, top_vib_2]\n",
        "\n",
        "        self.add(number_line, r1, arrow1)\n",
        "        self.play(bottom_vibration, top_vib_1)\n",
        "        for vib in vibrations:\n",
        "            vib.set_run_time(kwargs[\"run_time\"])\n",
        "        self.play(\n",
        "            self.bottom_vibration,\n",
        "            Transform(arrow1, arrow2, **kwargs),\n",
        "            Transform(r1, r2, **kwargs),\n",
        "            TransformAnimations(top_vib_1, top_vib_2, **kwargs)\n",
        "        )\n",
        "        for vib in vibrations:\n",
        "            vib.set_run_time(3.0)\n",
        "        self.play(bottom_vibration, top_vib_1)\n",
        "\n",
        "class JustByAnalyzingTheNumber(Scene):\n",
        "    def construct(self):\n",
        "        nums = [\n",
        "            1.5,\n",
        "            np.sqrt(2),\n",
        "            2**(5/12.),\n",
        "            4/3.,\n",
        "            1.2020569031595942,\n",
        "        ]\n",
        "        last = None\n",
        "        r_equals = OldTex(\"r=\").shift(2*LEFT)\n",
        "        self.add(r_equals)\n",
        "        for num in nums:\n",
        "            mob = OldTex(str(num)).next_to(r_equals)\n",
        "            mob.set_color()\n",
        "            mob.sort_points()\n",
        "            if last:\n",
        "                self.play(DelayByOrder(Transform(last, mob, run_time = 0.5)))\n",
        "                self.remove(last)\n",
        "                self.add(mob)\n",
        "            else:\n",
        "                self.add(mob)\n",
        "            self.wait()\n",
        "            last = mob\n",
        "\n",
        "class QuestionAndAnswer(Scene):\n",
        "    def construct(self):\n",
        "        Q = OldTexText(\"Q:\").shift(UP).to_edge(LEFT)\n",
        "        A = OldTexText(\"A:\").shift(DOWN).to_edge(LEFT)\n",
        "        string1 = Vibrate(center = 3*UP, color = \"blue\")\n",
        "        string2 = Vibrate(num_periods = 2, center = 3.5*UP, color = \"green\")\n",
        "        twotwenty = OldTex(\"220\").scale(0.25).next_to(string1.mobject, LEFT)\n",
        "        r220 = OldTex(\"r\\\\times220\").scale(0.25).next_to(string2.mobject, LEFT)\n",
        "        question = OldTexText(\n",
        "            \"For what values of $r$ will the frequencies 220~Hz and \\\n",
        "            $r\\\\times$220~Hz sound nice together?\"\n",
        "        ).next_to(Q)\n",
        "        answer = OldTexText([\n",
        "            \"When $r$ is\", \n",
        "            \"sufficiently close to\",\n",
        "            \"a rational number\"\n",
        "        ], size = \"\\\\small\").scale(1.5)\n",
        "        answer.next_to(A)\n",
        "        correction1 = OldTexText(\n",
        "            \"with sufficiently low denominator\",\n",
        "            size = \"\\\\small\"\n",
        "        ).scale(1.5)\n",
        "        correction1.set_color(\"yellow\")\n",
        "        correction1.next_to(A).shift(2*answer.get_height()*DOWN)\n",
        "        answer = answer.split()\n",
        "        answer[1].set_color(\"green\")\n",
        "        temp_answer_end = deepcopy(answer[-1]).next_to(answer[0], buff = 0.2)\n",
        "\n",
        "        self.add(Q, A, question, twotwenty, r220)\n",
        "        self.play(string1, string2)\n",
        "        self.add(answer[0], temp_answer_end)\n",
        "        self.play(string1, string2)\n",
        "        self.play(ShimmerIn(correction1), string1, string2)\n",
        "        self.play(string1, string2, run_time = 3.0)\n",
        "        self.play(\n",
        "            Transform(Point(answer[1].get_left()), answer[1]),\n",
        "            Transform(temp_answer_end, answer[2]),\n",
        "            string1, string2\n",
        "        )\n",
        "        self.play(string1, string2, run_time = 3.0)\n",
        "\n",
        "class PlaySimpleRatio(Scene):\n",
        "    args_list = [\n",
        "        (Fraction(3, 2), \"green\"),\n",
        "        (Fraction(4, 3), \"purple\"),\n",
        "        (Fraction(8, 5), \"skyblue\"),\n",
        "        (Fraction(211, 198), \"orange\"),\n",
        "        (Fraction(1093, 826), \"red\"),\n",
        "        ((np.exp(np.pi)-np.pi)/15, \"#7e008e\")\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(fraction, color):\n",
        "        return str(fraction).replace(\"/\", \"_to_\")\n",
        "\n",
        "    def construct(self, fraction, color):\n",
        "        string1 = Vibrate(\n",
        "            num_periods = 1, run_time = 5.0, \n",
        "            center = DOWN, color = \"blue\"\n",
        "        )\n",
        "        string2 = Vibrate(\n",
        "            num_periods = fraction, run_time = 5.0,\n",
        "            center = 2*UP, color = color\n",
        "        )\n",
        "        if isinstance(fraction, Fraction):\n",
        "            mob = fraction_mobject(fraction).shift(0.5*UP)\n",
        "        else:\n",
        "            mob = OldTex(\"\\\\frac{e^\\\\pi - \\\\pi}{15} \\\\approx \\\\frac{4}{3}\")\n",
        "            mob.shift(0.5*UP)\n",
        "        self.add(mob)\n",
        "        self.play(string1, string2)\n",
        "\n",
        "class LongSine(Mobject1D):\n",
        "    def init_points(self):\n",
        "        self.add_points([\n",
        "            (x, np.sin(2*np.pi*x), 0)\n",
        "            for x in np.arange(0, 100, self.epsilon/10)\n",
        "        ])\n",
        "\n",
        "class DecomposeMusicalNote(Scene):\n",
        "    def construct(self):\n",
        "        line = Line(FRAME_Y_RADIUS*DOWN, FRAME_Y_RADIUS*UP)\n",
        "        sine = LongSine()\n",
        "        kwargs = {\n",
        "            \"run_time\" : 4.0,\n",
        "            \"rate_func\" : None\n",
        "        }\n",
        "        words = OldTexText(\"Imagine 220 per second...\")\n",
        "        words.shift(2*UP)\n",
        "\n",
        "        self.add(line)\n",
        "        self.play(ApplyMethod(sine.shift, 4*LEFT, **kwargs))\n",
        "        self.add(words)\n",
        "        kwargs[\"rate_func\"] = rush_into\n",
        "        self.play(ApplyMethod(sine.shift, 80*LEFT, **kwargs))\n",
        "        kwargs[\"rate_func\"] = None\n",
        "        kwargs[\"run_time\"] = 1.0\n",
        "        sine.to_edge(LEFT, buff = 0)\n",
        "        for x in range(5):\n",
        "            self.play(ApplyMethod(sine.shift, 85*LEFT, **kwargs))\n",
        "\n",
        "class DecomposeTwoFrequencies(Scene):\n",
        "    def construct(self):\n",
        "        line = Line(FRAME_Y_RADIUS*DOWN, FRAME_Y_RADIUS*UP)\n",
        "        sine1 = LongSine().shift(2*UP).set_color(\"yellow\")\n",
        "        sine2 = LongSine().shift(DOWN).set_color(\"lightgreen\")\n",
        "        sine1.stretch(2.0/3, 0)\n",
        "        comp = Mobject(sine1, sine2)\n",
        "\n",
        "        self.add(line)\n",
        "        self.play(ApplyMethod(\n",
        "            comp.shift, 15*LEFT,\n",
        "            run_time = 7.5,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "\n",
        "\n",
        "class MostRationalsSoundBad(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Most rational numbers sound bad!\"))\n",
        "\n",
        "class FlashOnXProximity(Animation):\n",
        "    def __init__(self, mobject, x_val, *close_mobjects, **kwargs):\n",
        "        self.x_val = x_val\n",
        "        self.close_mobjects = close_mobjects\n",
        "        Animation.__init__(self, mobject, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        for mob in self.close_mobjects:\n",
        "            if np.min(np.abs(mob.get_points()[:,0] - self.x_val)) < 0.1:\n",
        "                self.mobject.set_color()\n",
        "                return\n",
        "        self.mobject.to_original_color()\n",
        "\n",
        "class PatternInFrequencies(Scene):\n",
        "    args_list = [\n",
        "        (3, 2, \"green\"),\n",
        "        (4, 3, \"purple\"),\n",
        "        (8, 5, \"skyblue\"),\n",
        "        (35, 43, \"red\"),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(num1, num2, color):\n",
        "        return \"%d_to_%d\"%(num1, num2)\n",
        "\n",
        "    def construct(self, num1, num2, color):\n",
        "        big_line = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        big_line.set_color(\"white\").shift(2*LEFT)\n",
        "        line_template = Line(UP, DOWN)\n",
        "        line_template.shift(2*UP+2*LEFT)\n",
        "        setup_width = FRAME_WIDTH\n",
        "        num_top_lines = int(setup_width)\n",
        "        num_bot_lines = int(setup_width*num1/num2)\n",
        "        top_lines = Mobject(*[\n",
        "            deepcopy(line_template).shift(k*(float(num1)/num2)*RIGHT)\n",
        "            for k in range(num_top_lines)\n",
        "        ])\n",
        "        line_template.shift(4*DOWN)\n",
        "        bottom_lines = Mobject(*[\n",
        "            deepcopy(line_template).shift(k*RIGHT)\n",
        "            for k in range(num_bot_lines)\n",
        "        ])\n",
        "        bottom_lines.set_color(\"blue\")\n",
        "        top_lines.set_color(color)\n",
        "        kwargs = {\n",
        "            \"run_time\" : 10,\n",
        "            \"rate_func\" : None\n",
        "        }\n",
        "\n",
        "        self.add(big_line)\n",
        "        self.add(OldTex(\"%d:%d\"%(num1, num2)))\n",
        "        fracs = (\n",
        "            1.0/(num_top_lines-1), \n",
        "            1.0/(num_bot_lines-1)\n",
        "        )\n",
        "        anims = [\n",
        "            ApplyMethod(mob.shift, setup_width*LEFT, **kwargs)\n",
        "            for mob in (top_lines, bottom_lines)\n",
        "        ]\n",
        "        anim_mobs = [anim.mobject for anim in anims]\n",
        "        self.play(\n",
        "            FlashOnXProximity(big_line, -2, *anim_mobs, **kwargs),\n",
        "            *anims\n",
        "        )\n",
        "\n",
        "\n",
        "class CompareFractionComplexity(Scene):\n",
        "    def construct(self):\n",
        "        fractions = []\n",
        "        for num, den in [(4, 3), (1093,826)]:\n",
        "            top = OldTex(\"%d \\\\over\"%num)\n",
        "            bottom = OldTex(str(den)).next_to(top, DOWN, buff = 0.3)\n",
        "            fractions.append(Mobject(top, bottom))\n",
        "        frac0 = fractions[0].shift(3*LEFT).split()\n",
        "        frac1 = fractions[1].shift(3*RIGHT).split()\n",
        "        arrow1 = Arrow(UP, ORIGIN).next_to(frac0[0], UP)\n",
        "        arrow2 = Arrow(UP, ORIGIN).next_to(frac1[0], UP)\n",
        "        simple = OldTexText(\"Simple\").next_to(arrow1, UP)\n",
        "        simple.set_color(\"green\")\n",
        "        complicated = OldTexText(\"Complicated\").next_to(arrow2, UP)\n",
        "        complicated.set_color(\"red\")\n",
        "        indicates = OldTexText(\"Indicates complexity\").shift(2*DOWN)\n",
        "        arrow3 = Arrow(indicates.get_top(), frac0[1])\n",
        "        arrow4 = Arrow(indicates.get_top(), frac1[1])\n",
        "\n",
        "        self.add(*frac0 + frac1)\n",
        "        self.wait()\n",
        "        self.add(simple, complicated)\n",
        "        self.play(*[\n",
        "            ShowCreation(arrow)\n",
        "            for arrow in (arrow1, arrow2)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            DelayByOrder(ApplyMethod(frac[1].set_color, \"yellow\"))\n",
        "            for frac in (frac0, frac1)\n",
        "        ])\n",
        "        self.play(\n",
        "            FadeIn(indicates),\n",
        "            ShowCreation(arrow3),\n",
        "            ShowCreation(arrow4)\n",
        "        )\n",
        "        self.wait()\n",
        "        \n",
        "class IrrationalGang(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.mouth.set_color(randy.DEFAULT_COLOR)\n",
        "        randy.sync_parts()\n",
        "        sqrt13 = OldTex(\"\\\\sqrt{13}\").shift(2*LEFT)\n",
        "        sqrt13.set_color(\"green\")\n",
        "        zeta3 = OldTex(\"\\\\zeta(3)\").shift(2*RIGHT)\n",
        "        zeta3.set_color(\"grey\")\n",
        "        eyes = Mobject(*randy.eyes)\n",
        "        eyes.scale(0.5)\n",
        "        sqrt13.add(eyes.next_to(sqrt13, UP, buff = 0).shift(0.25*RIGHT))\n",
        "        eyes.scale(0.5)\n",
        "        zeta3.add(eyes.next_to(zeta3, UP, buff = 0).shift(0.3*LEFT+0.08*DOWN))\n",
        "        speech_bubble = SpeechBubble()\n",
        "        speech_bubble.pin_to(randy)\n",
        "        speech_bubble.write(\"We want to play too!\")\n",
        "\n",
        "        self.add(randy, sqrt13, zeta3, speech_bubble, speech_bubble.content)\n",
        "        self.play(BlinkPiCreature(randy))\n",
        "\n",
        "\n",
        "class ConstructPiano(Scene):\n",
        "    def construct(self):\n",
        "        piano = Piano()\n",
        "        keys = piano.split()\n",
        "        anims = []\n",
        "        askew = deepcopy(keys[-1])\n",
        "        keys[-1].rotate(np.pi/5)\n",
        "        for key in keys:\n",
        "            key.stroke_width = 1\n",
        "            key_copy = deepcopy(key).to_corner(DOWN+LEFT)\n",
        "            key_copy.scale(0.25)\n",
        "            key_copy.shift(1.8*random.random()*FRAME_X_RADIUS*RIGHT)\n",
        "            key_copy.shift(1.8*random.random()*FRAME_Y_RADIUS*UP)\n",
        "            key_copy.rotate(2*np.pi*random.random())\n",
        "            anims.append(Transform(key_copy, key))\n",
        "        self.play(*anims, run_time = 3.0)\n",
        "        self.wait()\n",
        "        self.play(Transform(anims[-1].mobject, askew))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PianoTuning(Scene):\n",
        "    def construct(self):\n",
        "        piano = self.piano = Piano()\n",
        "        jump = piano.half_note_jump\n",
        "        semicircle = Circle().filter_out(lambda p : p[1] < 0)\n",
        "        semicircle.scale(jump/semicircle.get_width())\n",
        "        semicircles = Mobject(*[\n",
        "            deepcopy(semicircle).shift(jump*k*RIGHT)\n",
        "            for k in range(23)\n",
        "        ])\n",
        "        semicircles.set_color(\"white\")\n",
        "        semicircles.next_to(piano, UP, buff = 0)\n",
        "        semicircles.shift(0.05*RIGHT)\n",
        "        semicircles.sort_points(lambda p : p[0])\n",
        "        first_jump = semicircles.split()[0]\n",
        "        twelfth_root = OldTex(\"2^{\\\\left(\\\\frac{1}{12}\\\\right)}\")\n",
        "        twelfth_root.scale(0.75).next_to(first_jump, UP, buff = 1.5)\n",
        "        line = Line(twelfth_root, first_jump).set_color(\"grey\")\n",
        "        self.keys = piano.split()\n",
        "        self.semicircles = semicircles.split()\n",
        "\n",
        "        self.add(piano)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(first_jump))\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeIn(twelfth_root)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(semicircles, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "        self.show_interval(5, 7)\n",
        "        self.show_interval(4, 5)\n",
        "\n",
        "    def show_interval(self, interval, half_steps):\n",
        "        whole_notes_to_base = 5\n",
        "        half_notes_to_base = 9\n",
        "\n",
        "        self.clear()\n",
        "        self.add(self.piano)\n",
        "        colors = list(Color(\"blue\").range_to(\"yellow\", 7))\n",
        "        low = self.keys[whole_notes_to_base]\n",
        "        high = self.keys[whole_notes_to_base + interval - 1]\n",
        "        u_brace = Underbrace(low.get_bottom(), high.get_bottom())\n",
        "        u_brace.set_color(\"yellow\")\n",
        "        ratio = OldTex(\"2^{\\\\left(\\\\frac{%d}{12}\\\\right)}\"%half_steps)\n",
        "        ratio.next_to(u_brace, DOWN, buff = 0.2)\n",
        "        semicircles = self.semicircles[half_notes_to_base:half_notes_to_base+half_steps]\n",
        "        product = OldTex(\n",
        "            [\"\\\\left(2^{\\\\left(\\\\frac{1}{12}\\\\right)}\\\\right)\"]*half_steps,\n",
        "            size = \"\\\\small\"\n",
        "        ).next_to(self.piano, UP, buff = 1.0)\n",
        "        approximate_form = OldTex(\"\\\\approx\"+str(2**(float(half_steps)/12)))\n",
        "        approximate_form.scale(0.75)\n",
        "        approximate_form.next_to(ratio)\n",
        "        if interval == 5:\n",
        "            num_den = (3, 2)\n",
        "        elif interval == 4:\n",
        "            num_den = (4, 3)\n",
        "        should_be = OldTexText(\"Should be $\\\\frac{%d}{%d}$\"%num_den)\n",
        "        should_be.next_to(u_brace, DOWN)\n",
        "\n",
        "        self.play(ApplyMethod(low.set_color, colors[0]))\n",
        "        self.play(\n",
        "            ApplyMethod(high.set_color, colors[interval]),\n",
        "            Transform(Point(u_brace.get_left()), u_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(should_be))\n",
        "        self.wait()\n",
        "        self.remove(should_be)\n",
        "        terms = product.split()\n",
        "        for term, semicircle in zip(terms, semicircles):\n",
        "            self.add(term, semicircle)\n",
        "            self.wait(0.25)\n",
        "        self.wait()\n",
        "        product.sort_points(lambda p : p[1])\n",
        "        self.play(DelayByOrder(Transform(product, ratio)))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(approximate_form))\n",
        "        self.wait()\n",
        "\n",
        "class PowersOfTwelfthRoot(Scene):\n",
        "    def construct(self):\n",
        "        max_height = FRAME_Y_RADIUS-0.5\n",
        "        min_height = -max_height\n",
        "        num_terms = 11\n",
        "        mob_list = []\n",
        "        fraction_map = {\n",
        "            1 : Fraction(16, 15),\n",
        "            2 : Fraction(9, 8),\n",
        "            3 : Fraction(6, 5),\n",
        "            4 : Fraction(5, 4),\n",
        "            5 : Fraction(4, 3),\n",
        "            7 : Fraction(3, 2),\n",
        "            8 : Fraction(8, 5),\n",
        "            9 : Fraction(5, 3),\n",
        "            10 : Fraction(16, 9),\n",
        "        }\n",
        "        approx = OldTex(\"\\\\approx\").scale(0.5)\n",
        "        curr_height = max_height*UP\n",
        "        spacing = UP*(max_height-min_height)/(len(fraction_map)-1.0)\n",
        "        for i in range(1, num_terms+1):\n",
        "            if i not in fraction_map:\n",
        "                continue\n",
        "            term = OldTex(\"2^{\\\\left(\\\\frac{%d}{12}\\\\right)}\"%i)\n",
        "            term.shift(curr_height)\n",
        "            curr_height -= spacing\n",
        "            term.shift(4*LEFT)\n",
        "            value = 2**(i/12.0)\n",
        "            approx_form = OldTex(str(value)[:10])\n",
        "            approx_copy = deepcopy(approx).next_to(term)\n",
        "            approx_form.scale(0.5).next_to(approx_copy)\n",
        "            words = OldTexText(\"is close to\")\n",
        "            words.scale(approx_form.get_height()/words.get_height())\n",
        "            words.next_to(approx_form)\n",
        "            frac = fraction_map[i]\n",
        "            frac_mob = OldTex(\"%d/%d\"%(frac.numerator, frac.denominator))\n",
        "            frac_mob.scale(0.5).next_to(words)\n",
        "            percent_error = abs(100*((value - frac) / frac))\n",
        "            error_string = OldTexText([\n",
        "                \"with\", str(percent_error)[:4] + \"\\\\%\", \"error\"\n",
        "            ])\n",
        "            error_string = error_string.split()\n",
        "            error_string[1].set_color()\n",
        "            error_string = Mobject(*error_string)\n",
        "            error_string.scale(approx_form.get_height()/error_string.get_height())\n",
        "            error_string.next_to(frac_mob)\n",
        "\n",
        "            mob_list.append(Mobject(*[\n",
        "                term, approx_copy, approx_form, words, frac_mob, error_string\n",
        "            ]))\n",
        "        self.play(ShimmerIn(Mobject(*mob_list), run_time = 3.0))\n",
        "\n",
        "class InterestingQuestion(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Interesting Question:\", size = \"\\\\Huge\")\n",
        "        words.scale(2.0)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class SupposeThereIsASavant(Scene):\n",
        "    def construct(self):\n",
        "        words = \"Suppose there is a musical savant \" + \\\n",
        "                \"who finds pleasure in all pairs of \" + \\\n",
        "                \"notes whose frequencies have a rational ratio\"\n",
        "        words = words.split(\" \")\n",
        "        word_mobs = OldTexText(words).split()\n",
        "        word_mobs[4].set_color()\n",
        "        word_mobs[5].set_color()\n",
        "        for word, word_mob in zip(words, word_mobs):\n",
        "            self.add(word_mob)\n",
        "            self.wait(0.1*len(word))\n",
        "\n",
        "class AllValuesBetween1And2(NumberLineScene):\n",
        "    def construct(self):\n",
        "        NumberLineScene.construct(self)\n",
        "        irrational = 1.2020569031595942        \n",
        "        cont_frac = [1, 4, 1, 18, 1, 1, 1, 4, 1, 9, 9, 2, 1, 1, 1, 2]        \n",
        "        one, two, irr = list(map(\n",
        "            self.number_line.number_to_point, \n",
        "            [1, 2, irrational]\n",
        "        ))\n",
        "        top_arrow = Arrow(one+UP, one)\n",
        "        bot_arrow = Arrow(irr+2*DOWN, irr)\n",
        "        r = OldTex(\"r\").next_to(top_arrow, UP)\n",
        "        irr_mob = OldTex(str(irrational)+\"\\\\dots\").next_to(bot_arrow, DOWN)\n",
        "\n",
        "        approximations = [\n",
        "            continued_fraction(cont_frac[:k])\n",
        "            for k in range(1, len(cont_frac))[:8]\n",
        "        ]\n",
        "\n",
        "        kwargs = {\n",
        "            \"run_time\" : 3.0,\n",
        "            \"rate_func\" : there_and_back\n",
        "        }\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, RIGHT, **kwargs)\n",
        "            for mob in (r, top_arrow)\n",
        "        ])\n",
        "        self.wait() \n",
        "        self.remove(r, top_arrow)\n",
        "        self.play(\n",
        "            ShimmerIn(irr_mob),\n",
        "            ShowCreation(bot_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(irr_mob, bot_arrow)\n",
        "\n",
        "        frac_mob = Point(top_arrow.get_top())\n",
        "        max_num_zooms = 4\n",
        "        num_zooms = 0\n",
        "        for approx in approximations:\n",
        "            point = self.number_line.number_to_point(approx)\n",
        "            new_arrow = Arrow(point+UP, point)\n",
        "            mob = fraction_mobject(approx).next_to(new_arrow, UP)\n",
        "            self.play(\n",
        "                Transform(top_arrow, new_arrow),\n",
        "                Transform(frac_mob, mob),\n",
        "                run_time = 0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            points = list(map(self.number_line.number_to_point, [approx, irrational]))\n",
        "            distance = get_norm(points[1]-points[0])\n",
        "            if distance < 0.3*FRAME_X_RADIUS and num_zooms < max_num_zooms:\n",
        "                num_zooms += 1\n",
        "                new_distance = 0.75*FRAME_X_RADIUS\n",
        "                self.zoom_in_on(irrational, new_distance/distance)\n",
        "                for mob in irr_mob, bot_arrow:\n",
        "                    mob.shift(mob.get_center()[0]*LEFT)\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class ChallengeTwo(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Challenge #2\"))\n",
        "\n",
        "class CoveringSetsWithOpenIntervals(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        dots = Mobject(*[\n",
        "            Dot().shift(self.number_line.number_to_point(num)+UP)\n",
        "            for num in set([0.2, 0.25, 0.45, 0.6, 0.65])\n",
        "        ])\n",
        "        theorems = [\n",
        "            OldTexText(words).shift(UP)\n",
        "            for words in [\n",
        "                \"Heine-Borel Theorem\",\n",
        "                \"Lebesgue's Number Lemma\",\n",
        "                \"Vitali Covering Lemma\",\n",
        "                \"Besicovitch Covering Theorem\",\n",
        "                \"$\\\\vdots$\"\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        self.add(dots)\n",
        "        self.play(DelayByOrder(ApplyMethod(dots.shift, DOWN, run_time = 2)))\n",
        "        self.wait()\n",
        "        for center in 0.225, 0.475, 0.625:\n",
        "            self.add_open_interval(center, 0.1, run_time = 1.0)\n",
        "        self.wait()\n",
        "        for x in range(2*len(theorems)):\n",
        "            self.play(*[\n",
        "                ApplyMethod(th.shift, UP, rate_func=linear)\n",
        "                for th in theorems[:x+1]\n",
        "            ])\n",
        "\n",
        "class DefineOpenInterval(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        open_interval, line = self.add_open_interval(0.5, 0.75, run_time = 1.0)\n",
        "        left, right = open_interval.get_left(), open_interval.get_right()\n",
        "        a, less_than1, x, less_than2, b = \\\n",
        "            OldTex([\"a\", \"<\", \"x\", \"<\", \"b\"]).shift(UP).split()\n",
        "        left_arrow = Arrow(a.get_corner(DOWN+LEFT), left)\n",
        "        right_arrow = Arrow(b.get_corner(DOWN+RIGHT), right)\n",
        "\n",
        "        self.play(*[ShimmerIn(mob) for mob in (a, less_than1, x)])\n",
        "        self.play(ShowCreation(left_arrow))\n",
        "        self.wait()\n",
        "        self.play(*[ShimmerIn(mob) for mob in (less_than2, b)])\n",
        "        self.play(ShowCreation(right_arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowAllFractions(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.show_all_fractions(\n",
        "            num_fractions = 100,\n",
        "            remove_as_you_go = False, \n",
        "            pause_time = 0.3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(mob, Point(mob.get_center()))\n",
        "            for mob in self.mobjects\n",
        "            if isinstance(mob, ImageMobject)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class NaiveFractionCover(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.add_fraction_ticks(100)\n",
        "        self.add_fraction_ticks(run_time = 5.0)\n",
        "        last_interval = None\n",
        "        centers = np.arange(0, 1.1, .1)\n",
        "        random.shuffle(centers)\n",
        "        for num, count in zip(centers, it.count()):\n",
        "            if count == 0:\n",
        "                kwargs = {\n",
        "                    \"run_time\" : 1.0,\n",
        "                    \"rate_func\" : rush_into\n",
        "                }\n",
        "            elif count == 10:\n",
        "                kwargs = {\n",
        "                    \"run_time\" : 1.0,\n",
        "                    \"rate_func\" : rush_from\n",
        "                }\n",
        "            else:\n",
        "                kwargs = {\n",
        "                    \"run_time\" : 0.25,\n",
        "                    \"rate_func\" : None\n",
        "                }\n",
        "            open_interval, line = self.add_open_interval(num, 0.1)\n",
        "            open_interval.shift(UP)\n",
        "            self.remove(line)\n",
        "            anims = [ApplyMethod(open_interval.shift, DOWN, **kwargs)]\n",
        "            last_interval = open_interval\n",
        "            self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "class CoverFractionsWithWholeInterval(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.add_fraction_ticks()\n",
        "        self.wait()\n",
        "        self.add_open_interval(0.5, 1, color = \"red\", run_time = 2.0)\n",
        "        self.wait()\n",
        "\n",
        "class SumOfIntervalsMustBeLessThan1(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.add_fraction_ticks()\n",
        "        anims = []\n",
        "        last_plus = Point((FRAME_X_RADIUS-0.5)*LEFT+2*UP)        \n",
        "        for num in np.arange(0, 1.1, .1):\n",
        "            open_interval, line = self.add_open_interval(num, 0.1)\n",
        "            self.remove(line)\n",
        "            int_copy = deepcopy(open_interval)\n",
        "            int_copy.scale(0.6).next_to(last_plus, buff = 0.1)\n",
        "            last_plus = OldTex(\"+\").scale(0.3)\n",
        "            last_plus.next_to(int_copy, buff = 0.1)\n",
        "            anims.append(Transform(open_interval, int_copy))\n",
        "            if num < 1.0:\n",
        "                anims.append(FadeIn(last_plus))\n",
        "        less_than1 = OldTex(\"<1\").scale(0.5)\n",
        "        less_than1.next_to(int_copy)\n",
        "        dots = OldTex(\"\\\\dots\").replace(int_copy)\n",
        "        words = OldTexText(\"Use infinitely many intervals\")\n",
        "        words.shift(UP)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*anims)\n",
        "        self.play(ShimmerIn(less_than1))\n",
        "        self.wait()\n",
        "        self.play(Transform(anims[-1].mobject, dots))\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "\n",
        "class RationalsAreDense(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        words = OldTexText([\"Rationals are\", \"\\\\emph{dense}\", \"in the reals\"])\n",
        "        words.shift(2*UP)\n",
        "        words = words.split()\n",
        "        words[1].set_color()\n",
        "\n",
        "        self.add(words[0])\n",
        "        self.play(ShimmerIn(words[1]))\n",
        "        self.add(words[2])\n",
        "        self.wait()\n",
        "        ticks = self.add_fraction_ticks(run_time = 5.0)\n",
        "        self.wait()\n",
        "        for center, width in [(0.5, 0.1), (0.2, 0.05), (0.7, 0.01)]:\n",
        "            oi, line = self.add_open_interval(center, width, run_time = 1)\n",
        "            self.remove(line)\n",
        "        self.wait()\n",
        "        for compound in oi, ticks:\n",
        "            self.remove(compound)\n",
        "            self.add(*compound.split())\n",
        "        self.zoom_in_on(0.7, 100)\n",
        "        self.play(ShowCreation(ticks, run_time = 2.0))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SurelyItsImpossible(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Surely it's impossible!\"))\n",
        "\n",
        "class HowCanYouNotCoverEntireInterval(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        small_words = OldTexText(\"\"\"\n",
        "            In case you are wondering, it is indeed true \n",
        "            that if you cover all real numbers between 0 \n",
        "            and 1 with a set of open intervals, the sum \n",
        "            of the lengths of those intervals must be at \n",
        "            least 1. While intuitive, this is not actually \n",
        "            as obvious as it might seem, just try to prove \n",
        "            it for yourself!\n",
        "        \"\"\")\n",
        "        small_words.scale(0.5).to_corner(UP+RIGHT)        \n",
        "        big_words = OldTexText(\"\"\"\n",
        "            Covering all numbers from 0 to 1 \\\\emph{will}\n",
        "            force the sum of the lengths of your intervals\n",
        "            to be at least 1.\n",
        "        \"\"\")\n",
        "        big_words.next_to(self.number_line, DOWN, buff = 0.5)\n",
        "\n",
        "        ticks = self.add_fraction_ticks()\n",
        "        left  = self.number_line.number_to_point(0)\n",
        "        right = self.number_line.number_to_point(1)\n",
        "        full_line = Line(left, right)\n",
        "        full_line.set_color(\"red\")\n",
        "        # dot = Dot().shift(left).set_color(\"red\")\n",
        "        # point = Point(left).set_color(\"red\")\n",
        "        intervals = []\n",
        "        for num in np.arange(0, 1.1, .1):\n",
        "            open_interval, line = self.add_open_interval(num, 0.1)\n",
        "            self.remove(line)\n",
        "            intervals.append(open_interval)\n",
        "        self.wait()\n",
        "        self.remove(ticks)\n",
        "        self.play(*[\n",
        "            Transform(tick, full_line)\n",
        "            for tick in ticks.split()\n",
        "        ])\n",
        "        self.play(ShimmerIn(big_words))\n",
        "        self.wait()\n",
        "        # self.play(DelayByOrder(FadeToColor(full_line, \"red\")))\n",
        "        self.play(ShimmerIn(small_words))\n",
        "        self.wait()\n",
        "\n",
        "class PauseNow(Scene):\n",
        "    def construct(self):\n",
        "        top_words = OldTexText(\"Try for yourself!\").scale(2).shift(3*UP)\n",
        "        bot_words = OldTexText(\"\"\"\n",
        "            If you've never seen this before, you will get \n",
        "            the most out of the solution and the intuitions\n",
        "            I illustrate only after pulling out a pencil and\n",
        "            paper and taking a wack at it yourself.\n",
        "        \"\"\").next_to(top_words, DOWN, buff = 0.5)\n",
        "        self.add(top_words, bot_words)\n",
        "\n",
        "class StepsToSolution(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        self.spacing = 0.7\n",
        "        steps = list(map(TexText, [\n",
        "            \"Enumerate all rationals in (0, 1)\",\n",
        "            \"Assign one interval to each rational\",\n",
        "            \"Choose sum of the form $\\\\mathlarger{\\\\sum}_{n=1}^\\\\infty a_n = 1$\",\n",
        "            \"Pick any $\\\\epsilon$ such that $0 < \\\\epsilon < 1$\",\n",
        "            \"Stretch the $n$th interval to have length $\\\\epsilon/2^n$\",\n",
        "        ]))\n",
        "        for step in steps:\n",
        "            step.shift(DOWN)\n",
        "        for step in steps[2:]:\n",
        "            step.shift(DOWN)\n",
        "        for step, count in zip(steps, it.count()):\n",
        "            self.add(step)\n",
        "            self.wait()\n",
        "            if count == 0:\n",
        "                self.enumerate_rationals()\n",
        "            elif count == 1:\n",
        "                self.assign_intervals_to_rationals()\n",
        "            elif count == 2:\n",
        "                self.add_terms()\n",
        "            elif count == 3:\n",
        "                self.multiply_by_epsilon()\n",
        "            elif count == 4:\n",
        "                self.stretch_intervals()\n",
        "            self.remove(step)\n",
        "\n",
        "    def enumerate_rationals(self):\n",
        "        ticks = self.add_fraction_ticks(run_time = 2.0)\n",
        "        anims = []\n",
        "        commas = Mobject()\n",
        "        denom_to_mobs = {}\n",
        "        for frac, count in zip(rationals(), list(range(1,28))):\n",
        "            mob, tick = self.add_fraction(frac, shrink = True)\n",
        "            self.wait(0.1)\n",
        "            self.remove(tick)\n",
        "            if frac.denominator not in denom_to_mobs:\n",
        "                denom_to_mobs[frac.denominator] = []\n",
        "            denom_to_mobs[frac.denominator].append(mob)\n",
        "            mob_copy = deepcopy(mob).center()\n",
        "            mob_copy.shift((2.4-mob_copy.get_bottom()[1])*UP)\n",
        "            mob_copy.shift((-FRAME_X_RADIUS+self.spacing*count)*RIGHT)\n",
        "            comma = OldTexText(\",\").next_to(mob_copy, buff = 0.1, aligned_edge = DOWN)\n",
        "            anims.append(Transform(mob, mob_copy))\n",
        "            commas.add(comma)\n",
        "        anims.append(ShimmerIn(commas))\n",
        "        new_ticks = []\n",
        "        for tick, count in zip(ticks.split(), it.count(1)):\n",
        "            tick_copy = deepcopy(tick).center().shift(1.6*UP)\n",
        "            tick_copy.shift((-FRAME_X_RADIUS+self.spacing*count)*RIGHT)\n",
        "            new_ticks.append(tick_copy)\n",
        "        new_ticks = Mobject(*new_ticks)\n",
        "        anims.append(DelayByOrder(Transform(ticks, new_ticks)))\n",
        "        self.wait()\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "        for denom in range(2, 10):\n",
        "            for mob in denom_to_mobs[denom]:\n",
        "                mob.set_color(\"green\")\n",
        "            self.wait()\n",
        "            for mob in denom_to_mobs[denom]:\n",
        "                mob.to_original_color()\n",
        "        self.ticks = ticks.split()[:20]\n",
        "\n",
        "    def assign_intervals_to_rationals(self):\n",
        "        anims = []\n",
        "        for tick in self.ticks:\n",
        "            interval = OpenInterval(tick.get_center(), self.spacing)\n",
        "            interval.scale(0.5)\n",
        "            squished = deepcopy(interval).stretch_to_fit_width(0)\n",
        "            anims.append(Transform(squished, interval))\n",
        "        self.play(*anims)\n",
        "        self.show_frame()\n",
        "        self.wait()\n",
        "        to_remove = [self.number_line] + self.number_mobs\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, FRAME_WIDTH*RIGHT)\n",
        "            for mob in to_remove\n",
        "        ])\n",
        "        self.remove(*to_remove)\n",
        "        self.wait()\n",
        "\n",
        "        self.intervals = [a.mobject for a in anims]\n",
        "        kwargs = {\n",
        "            \"run_time\" : 2.0,\n",
        "            \"rate_func\" : there_and_back\n",
        "        }\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.scale, 0.5*random.random(), **kwargs)\n",
        "            for mob in self.intervals\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def add_terms(self):\n",
        "        self.ones = []\n",
        "        scale_factor = 0.6\n",
        "        plus = None\n",
        "        for count in range(1, 10):\n",
        "            frac_bottom = OldTex(\"\\\\over %d\"%(2**count))\n",
        "            frac_bottom.scale(scale_factor)\n",
        "            one = OldTex(\"1\").scale(scale_factor)\n",
        "            one.next_to(frac_bottom, UP, buff = 0.1)\n",
        "            compound = Mobject(frac_bottom, one)\n",
        "            if plus:\n",
        "                compound.next_to(plus)\n",
        "            else:\n",
        "                compound.to_edge(LEFT)\n",
        "            plus = OldTex(\"+\").scale(scale_factor)\n",
        "            plus.next_to(compound)\n",
        "            frac_bottom, one = compound.split()\n",
        "            self.ones.append(one)\n",
        "            self.add(frac_bottom, one, plus)\n",
        "            self.wait(0.2)\n",
        "        dots = OldTex(\"\\\\dots\").scale(scale_factor).next_to(plus)\n",
        "        arrow = Arrow(ORIGIN, RIGHT).next_to(dots)\n",
        "        one = OldTex(\"1\").next_to(arrow)\n",
        "        self.ones.append(one)\n",
        "        self.play(*[ShowCreation(mob) for mob in (dots, arrow, one)])\n",
        "        self.wait()\n",
        "\n",
        "    def multiply_by_epsilon(self):\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(\n",
        "                one,\n",
        "                OldTex(\"\\\\epsilon\").replace(one)\n",
        "            )\n",
        "            for one in self.ones\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def stretch_intervals(self):\n",
        "        for interval, count in zip(self.intervals, it.count(1)):\n",
        "            self.play(\n",
        "                ApplyMethod(interval.scale, 1.0/(count**2)),\n",
        "                run_time = 1.0/count\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OurSumCanBeArbitrarilySmall(Scene):\n",
        "    def construct(self):\n",
        "        step_size = 0.01\n",
        "        epsilon = OldTex(\"\\\\epsilon\")\n",
        "        equals = OldTex(\"=\").next_to(epsilon)\n",
        "        self.add(epsilon, equals)\n",
        "        for num in np.arange(1, 0, -step_size):\n",
        "            parts = list(map(Tex, str(num)))\n",
        "            parts[0].next_to(equals)\n",
        "            for i in range(1, len(parts)):\n",
        "                parts[i].next_to(parts[i-1], buff = 0.1, aligned_edge = DOWN)\n",
        "            self.add(*parts)\n",
        "            self.wait(0.05)\n",
        "            self.remove(*parts)\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        words = OldTexText([\n",
        "            \"Not only can the sum be $< 1$,\\\\\\\\\",\n",
        "            \"it can be \\\\emph{arbitrarily small} !\"\n",
        "        ]).split()\n",
        "        self.add(words[0])\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(words[1].set_color()))\n",
        "        self.wait()\n",
        "\n",
        "class ProofDoesNotEqualIntuition(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Proof $\\\\ne$ Intuition\"))\n",
        "\n",
        "class StillFeelsCounterintuitive(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        ticks = self.add_fraction_ticks(run_time = 1.0)\n",
        "        epsilon, equals, num = list(map(Tex, [\"\\\\epsilon\", \"=\", \"0.3\"]))\n",
        "        epsilon.shift(2*UP)\n",
        "        equals.next_to(epsilon)\n",
        "        num.next_to(equals)\n",
        "        self.add(epsilon, equals, num)\n",
        "        self.cover_fractions()\n",
        "        self.remove(ticks)\n",
        "        self.add(*ticks.split())\n",
        "        self.zoom_in_on(np.sqrt(2)/2, 100)\n",
        "        self.play(ShowCreation(ticks))\n",
        "        self.wait()\n",
        "\n",
        "class VisualIntuition(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Visual Intuition:\"))\n",
        "\n",
        "class SideNote(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"(Brief Sidenote)\"))\n",
        "\n",
        "class TroubleDrawingSmallInterval(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        interval, line = self.add_open_interval(0.5, 0.5)\n",
        "        big = Mobject(interval, line)\n",
        "        small_int, small_line = self.add_open_interval(0.5, 0.01)\n",
        "        small = Mobject(small_int, line.scale(0.01/0.5))\n",
        "        shrunk = deepcopy(big).scale(0.01/0.5)\n",
        "        self.clear()\n",
        "        IntervalScene.construct(self)\n",
        "        words = OldTexText(\"This tiny stretch\")\n",
        "        words.shift(2*UP+2*LEFT)\n",
        "        arrow = Arrow(words, line)\n",
        "\n",
        "        for target in shrunk, small:\n",
        "            mob = deepcopy(big)\n",
        "            self.play(Transform(\n",
        "                mob, target,\n",
        "                run_time = 2.0\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.play(Transform(mob, big))\n",
        "            self.wait()\n",
        "            self.remove(mob)\n",
        "        self.play(Transform(big, small))\n",
        "        self.play(ShimmerIn(words), ShowCreation(arrow))\n",
        "        self.play(Transform(\n",
        "            line, deepcopy(line).scale(10).shift(DOWN),\n",
        "            run_time = 2.0,\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class WhatDoesItLookLikeToBeOutside(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\n",
        "            \"What does it look like for a number to be outside a dense set of intervals?\"\n",
        "        ))\n",
        "\n",
        "class ZoomInOnSqrt2Over2(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        epsilon, equals, num = list(map(Tex, [\"\\\\epsilon\", \"=\", \"0.3\"]))\n",
        "        equals.next_to(epsilon)\n",
        "        num.next_to(equals)\n",
        "        self.add(Mobject(epsilon, equals, num).center().shift(2*UP))\n",
        "        intervals, lines = self.cover_fractions()\n",
        "        self.remove(*lines)\n",
        "        irr = OldTex(\"\\\\frac{\\\\sqrt{2}}{2}\")\n",
        "        point = self.number_line.number_to_point(np.sqrt(2)/2)\n",
        "        arrow = Arrow(point+UP, point)\n",
        "        irr.next_to(arrow, UP)\n",
        "        self.play(ShimmerIn(irr), ShowCreation(arrow))\n",
        "        for count in range(4):\n",
        "            self.remove(*intervals)\n",
        "            self.remove(*lines)\n",
        "            self.zoom_in_on(np.sqrt(2)/2, 20)\n",
        "            for mob in irr, arrow:\n",
        "                mob.shift(mob.get_center()[0]*LEFT)\n",
        "            intervals, lines = self.cover_fractions()\n",
        "\n",
        "class NotCoveredMeansCacophonous(Scene):\n",
        "    def construct(self):\n",
        "        statement1 = OldTexText(\"$\\\\frac{\\\\sqrt{2}}{2}$ is not covered\")\n",
        "        implies = OldTex(\"\\\\Rightarrow\")\n",
        "        statement2 = OldTexText(\"Rationals which are close to $\\\\frac{\\\\sqrt{2}}{2}$ must have large denominators\")\n",
        "        statement1.to_edge(LEFT)\n",
        "        implies.next_to(statement1)\n",
        "        statement2.next_to(implies)\n",
        "        implies.sort_points()\n",
        "\n",
        "        self.add(statement1)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(implies))\n",
        "        self.play(ShimmerIn(statement2))\n",
        "        self.wait()\n",
        "\n",
        "class ShiftSetupByOne(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        new_interval = UnitInterval(\n",
        "            number_at_center = 1.5,\n",
        "            leftmost_tick = 1,\n",
        "            big_tick_numbers = [1, 2],\n",
        "        )\n",
        "        new_interval.add_numbers(1, 2)\n",
        "        side_shift_val = self.number_line.number_to_point(1)\n",
        "        side_shift_val -= new_interval.number_to_point(1)\n",
        "        new_interval.shift(side_shift_val)\n",
        "        self.add(new_interval)\n",
        "        self.number_line.add_numbers(0)\n",
        "        self.remove(*self.number_mobs)\n",
        "        epsilon_mob = OldTex(\"\\\\epsilon = 0.01\").to_edge(UP)\n",
        "        self.add(epsilon_mob)\n",
        "        fraction_ticks = self.add_fraction_ticks()\n",
        "        self.remove(fraction_ticks)\n",
        "        intervals, lines = self.cover_fractions(\n",
        "            epsilon = 0.01,\n",
        "            num_fractions = 150,\n",
        "            run_time_per_interval = 0,\n",
        "        )\n",
        "        self.remove(*intervals+lines)        \n",
        "        for interval, frac in zip(intervals, rationals()):\n",
        "            interval.scale(2.0/frac.denominator)\n",
        "\n",
        "\n",
        "        for interval in intervals[:10]:\n",
        "            squished = deepcopy(interval).stretch_to_fit_width(0)\n",
        "            self.play(Transform(squished, interval), run_time = 0.2)\n",
        "            self.remove(squished)\n",
        "            self.add(interval)\n",
        "        for interval in intervals[10:50]:\n",
        "            self.add(interval)\n",
        "            self.wait(0.1)\n",
        "        for interval in intervals[50:]:\n",
        "            self.add(interval)\n",
        "        self.wait()\n",
        "        mobs_shifts = [\n",
        "            (intervals, UP),\n",
        "            ([self.number_line, new_interval], side_shift_val*LEFT),\n",
        "            (intervals, DOWN)\n",
        "        ]\n",
        "        for mobs, shift_val in mobs_shifts:\n",
        "            self.play(*[\n",
        "                ApplyMethod(mob.shift, shift_val)\n",
        "                for mob in mobs\n",
        "            ])\n",
        "        self.number_line = new_interval\n",
        "        self.wait()\n",
        "        words = OldTexText(\n",
        "            \"Almost all the covered numbers are harmonious!\",\n",
        "            size = \"\\\\small\"\n",
        "        ).shift(2*UP)\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "        for num in [7, 5]:\n",
        "            point = self.number_line.number_to_point(2**(num/12.))\n",
        "            arrow = Arrow(point+DOWN, point)\n",
        "            mob = OldTex(\n",
        "                \"2^{\\\\left(\\\\frac{%d}{12}\\\\right)}\"%num\n",
        "            ).next_to(arrow, DOWN)\n",
        "            self.play(ShimmerIn(mob), ShowCreation(arrow))\n",
        "            self.wait()\n",
        "            self.remove(mob, arrow)\n",
        "        self.remove(words)\n",
        "        words = OldTexText(\n",
        "            \"Cacophonous covered numbers:\",\n",
        "            size = \"\\\\small\"\n",
        "        )\n",
        "        words.shift(2*UP)\n",
        "        answer1 = OldTexText(\"Complicated rationals,\", size = \"\\\\small\")\n",
        "        answer2 = OldTexText(\n",
        "            \"real numbers \\\\emph{very very very} close to them\",\n",
        "            size = \"\\\\small\"\n",
        "        )\n",
        "        compound = Mobject(answer1, answer2.next_to(answer1))\n",
        "        compound.next_to(words, DOWN)\n",
        "        answer1, answer2 = compound.split()\n",
        "\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "        self.remove(*intervals)\n",
        "        self.add(answer1)\n",
        "        self.play(ShowCreation(fraction_ticks, run_time = 5.0))\n",
        "        self.add(answer2)\n",
        "        self.wait()\n",
        "        self.remove(words, answer1, answer2)\n",
        "        words = OldTexText([\n",
        "            \"To a\", \"savant,\", \"harmonious numbers could be \",\n",
        "            \"\\\\emph{precisely}\", \"those 1\\\\% covered by the intervals\"\n",
        "        ]).shift(2*UP)\n",
        "        words = words.split()\n",
        "        words[1].set_color()\n",
        "        words[3].set_color()\n",
        "        self.add(*words)\n",
        "        self.play(ShowCreation(\n",
        "            Mobject(*intervals),\n",
        "            run_time = 5.0\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class FinalEquivalence(IntervalScene):\n",
        "    def construct(self):\n",
        "        IntervalScene.construct(self)\n",
        "        ticks = self.add_fraction_ticks()\n",
        "        intervals, lines = self.cover_fractions(\n",
        "            epsilon = 0.01,\n",
        "            num_fractions = 150,\n",
        "            run_time_per_interval = 0,\n",
        "        )\n",
        "        for interval, frac in zip(intervals, rationals()):\n",
        "            interval.scale(2.0/frac.denominator)\n",
        "        self.remove(*intervals+lines)\n",
        "        intervals = Mobject(*intervals)\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        top_words = OldTexText(\"Harmonious numbers are rare,\")\n",
        "        bot_words = OldTexText(\"even for the savant\")\n",
        "        bot_words.set_color().next_to(top_words, DOWN)\n",
        "        words = Mobject(top_words, bot_words)\n",
        "        words.next_to(arrow)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ticks),\n",
        "            Transform(\n",
        "                deepcopy(intervals).stretch_to_fit_height(0),\n",
        "                intervals\n",
        "            )\n",
        "        )\n",
        "        everything = Mobject(*self.mobjects)\n",
        "        self.clear()\n",
        "        self.play(Transform(\n",
        "            everything,\n",
        "            deepcopy(everything).scale(0.5).to_edge(LEFT)\n",
        "        ))\n",
        "        self.add(arrow)\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    command_line_create_scene(MOVIE_PREFIX)\n",
        "\n",
        "\n"
    ]
}