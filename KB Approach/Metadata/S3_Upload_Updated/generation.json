{
    "topic": "demonstrates the use of a GPT-2 language model to predict the next token in",
    "code": [
        "from transformers.models.videomae import image_processing_videomae\n",
        "from manim_imports_ext import *\n",
        "from _2024.transformers.helpers import *\n",
        "\n",
        "from transformers import GPT2Tokenizer\n",
        "from transformers import GPT2LMHeadModel\n",
        "from transformers import PreTrainedModel\n",
        "import torch\n",
        "import openai\n",
        "import tiktoken\n",
        "\n",
        "\n",
        "@lru_cache(maxsize=1)\n",
        "def get_gpt2_tokenizer(model_name='gpt2'):\n",
        "    return GPT2Tokenizer.from_pretrained(model_name)\n",
        "\n",
        "\n",
        "@lru_cache(maxsize=1)\n",
        "def get_gpt2_model(model_name='gpt2'):\n",
        "    return GPT2LMHeadModel.from_pretrained(model_name)\n",
        "\n",
        "\n",
        "def gpt2_predict_next_token(text, n_shown=7):\n",
        "    tokenizer = get_gpt2_tokenizer()\n",
        "    model = get_gpt2_model()\n",
        "    # Encode the input text\n",
        "    indexed_tokens = tokenizer.encode(\n",
        "        text, add_special_tokens=False, return_tensors='pt'\n",
        "    )\n",
        "\n",
        "    # Predict all tokens\n",
        "    with torch.no_grad():\n",
        "        outputs = model(indexed_tokens)\n",
        "        # Pull out the first batch, and the last token prediction\n",
        "        predictions = outputs[0][0, -1, :]\n",
        "\n",
        "    # Get the predicted next token\n",
        "    indices = torch.argsort(predictions)\n",
        "    top_indices = reversed(indices[-n_shown:])\n",
        "    tokens = list(map(tokenizer.decode, top_indices))\n",
        "    probs = softmax(predictions)[top_indices]\n",
        "\n",
        "    return tokens, probs\n",
        "\n",
        "\n",
        "def gpt3_predict_next_token(text, n_shown=10, random_seed=0):\n",
        "    openai.api_key = os.getenv('OPENAI_KEY')\n",
        "    response = openai.Completion.create(\n",
        "        # Or another model version, adjust as necessary\n",
        "        engine=\"gpt-3.5-turbo-instruct\",\n",
        "        prompt=text,\n",
        "        max_tokens=1,\n",
        "        n=1,\n",
        "        temperature=1.0,\n",
        "        user=str(random_seed),\n",
        "        logprobs=50  # I think this is actually set to a max of 20?\n",
        "    )\n",
        "    top_logprob_dict = response.choices[0][\"logprobs\"][\"top_logprobs\"][0]\n",
        "    tokens, logprobs = zip(*top_logprob_dict.items())\n",
        "    probs = np.exp(logprobs)\n",
        "    indices = np.argsort(-probs)\n",
        "    shown_tokens = [tokens[i] for i in indices[:n_shown]]\n",
        "    return shown_tokens, probs[indices[:n_shown]]\n",
        "\n",
        "\n",
        "def clean_text(text):\n",
        "    return \" \".join(filter(lambda s: s.strip(), re.split(r\"\\s\", text)))\n",
        "\n",
        "\n",
        "def next_token_bar_chart(\n",
        "    words, probs,\n",
        "    reference_point=ORIGIN,\n",
        "    font_size=24,\n",
        "    width_100p=1.0,\n",
        "    prob_exp=0.75,\n",
        "    bar_height=0.25,\n",
        "    bar_space_factor=0.5,\n",
        "    buff=1.2,\n",
        "    show_ellipses=True,\n",
        "    use_percent=True,\n",
        "):\n",
        "    labels = VGroup(Text(word, font_size=font_size) for word in words)\n",
        "    bars = VGroup(\n",
        "        Rectangle(prob**(prob_exp) * width_100p, bar_height)\n",
        "        for prob, label in zip(probs, labels)\n",
        "    )\n",
        "    bars.arrange(DOWN, aligned_edge=LEFT, buff=bar_space_factor * bar_height)\n",
        "    bars.set_fill(opacity=1)\n",
        "    bars.set_submobject_colors_by_gradient(TEAL, YELLOW)\n",
        "    bars.set_stroke(WHITE, 1)\n",
        "\n",
        "    bar_groups = VGroup()\n",
        "    for label, bar, prob in zip(labels, bars, probs):\n",
        "        if use_percent:\n",
        "            prob_label = Integer(int(100 * prob), unit=\"%\", font_size=0.75 * font_size)\n",
        "        else:\n",
        "            prob_label = DecimalNumber(prob, font_size=0.75 * font_size)\n",
        "        prob_label.next_to(bar, RIGHT, buff=SMALL_BUFF)\n",
        "        label.next_to(bar, LEFT)\n",
        "        bar_groups.add(VGroup(label, bar, prob_label))\n",
        "\n",
        "    if show_ellipses:\n",
        "        ellipses = Tex(R\"\\vdots\", font_size=font_size)\n",
        "        ellipses.next_to(bar_groups[-1][0], DOWN)\n",
        "        bar_groups.add(ellipses)\n",
        "\n",
        "    bar_groups.shift(reference_point - bars.get_left() + buff * RIGHT)\n",
        "\n",
        "    return bar_groups\n",
        "\n",
        "\n",
        "class SimpleAutogregression(InteractiveScene):\n",
        "    text_corner = 3.5 * UP + 0.75 * RIGHT\n",
        "    line_len = 31\n",
        "    font_size = 35\n",
        "    n_shown_predictions = 12\n",
        "    seed_text = \"Behold, a wild pi creature, foraging in its native\"\n",
        "    seed_text_color = BLUE_B\n",
        "    machine_name = \"Transformer\"\n",
        "    machine_phi = 10 * DEGREES\n",
        "    machine_theta = 12 * DEGREES\n",
        "    n_predictions = 120\n",
        "    skip_through = False\n",
        "    random_seed = 0\n",
        "    model = \"gpt2\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Repeatedly generate\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        for n in range(self.n_predictions):\n",
        "            text_mob = self.new_selection_cycle(\n",
        "                text_mob, next_word_line, machine,\n",
        "                quick=(n > 10),\n",
        "                skip_anims=self.skip_through,\n",
        "            )\n",
        "\n",
        "    def init_text_and_machine(self):\n",
        "        # Set up active text\n",
        "        self.cur_str = self.seed_text\n",
        "        text_mob = self.string_to_mob(self.cur_str)\n",
        "        text_mob.set_color(self.seed_text_color)\n",
        "        next_word_line = self.get_next_word_line(text_mob)\n",
        "\n",
        "        # Set up Transformer as some sort of machine\n",
        "        machine = self.get_transformer_drawing()\n",
        "        machine.set_y(0).to_edge(LEFT, buff=-0.6)\n",
        "\n",
        "        self.add(text_mob)\n",
        "        self.add(next_word_line)\n",
        "        self.add(machine)\n",
        "\n",
        "        return text_mob, next_word_line, machine\n",
        "\n",
        "    def string_to_mob(self, text):\n",
        "        text += \" l\"  # Dumb hack for alignment\n",
        "        result = get_paragraph(\n",
        "            text.replace(\"\\n\", \" \").split(\" \"),\n",
        "            self.line_len,\n",
        "            self.font_size\n",
        "        )\n",
        "        result.move_to(self.text_corner, UL)\n",
        "        result[-1].set_fill(BLACK, 0)  # Continue dumb hack\n",
        "        result[-1].stretch(0, 0, about_edge=LEFT)\n",
        "        return result\n",
        "\n",
        "    def get_next_word_line(self, text_mob, char_len=7):\n",
        "        next_word_line = Underline(text_mob[:char_len])\n",
        "        next_word_line.set_stroke(TEAL, 2)\n",
        "        next_word_line.next_to(text_mob[-1], RIGHT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "        if self.skip_through:\n",
        "            next_word_line.set_opacity(0)\n",
        "        return next_word_line\n",
        "\n",
        "    def get_transformer_drawing(self):\n",
        "        self.camera.light_source.move_to([-5, 5, 10])\n",
        "        self.frame.set_field_of_view(20 * DEGREES)\n",
        "        blocks = VGroup(\n",
        "            VPrism(3, 2, 0.2)\n",
        "            for n in range(10)\n",
        "        )\n",
        "        blocks.set_fill(GREY_D, 1)\n",
        "        blocks.set_stroke(width=0)\n",
        "        blocks.set_shading(0.25, 0.5, 0.2)\n",
        "        blocks.arrange(OUT)\n",
        "        blocks.move_to(ORIGIN, OUT)\n",
        "        blocks.rotate(self.machine_phi, RIGHT, about_edge=OUT)\n",
        "        blocks.rotate(self.machine_theta, UP, about_edge=OUT)\n",
        "\n",
        "        blocks.deactivate_depth_test()\n",
        "        for block in blocks:\n",
        "            block.sort(lambda p: p[2])\n",
        "\n",
        "        word = Text(self.machine_name, alignment=\"LEFT\")\n",
        "        word.next_to(blocks[-1], UP)\n",
        "        word.shift(0.1 * UP + 0.4 * LEFT)\n",
        "        word.move_to(blocks[-1])\n",
        "        word.set_backstroke(BLACK, 5)\n",
        "        out_arrow = Vector(\n",
        "            0.5 * RIGHT, stroke_width=10,\n",
        "            max_tip_length_to_length_ratio=0.5,\n",
        "            max_width_to_length_ratio=12\n",
        "        )\n",
        "        out_arrow.next_to(blocks[-1], RIGHT, buff=SMALL_BUFF)\n",
        "        out_arrow.set_opacity(0)\n",
        "\n",
        "        result = VGroup(blocks, word, out_arrow)\n",
        "        return result\n",
        "\n",
        "    def get_distribution(\n",
        "        self, words, probs, machine,\n",
        "        font_size=24,\n",
        "        width_100p=1.8,\n",
        "        bar_height=0.25,\n",
        "        show_ellipses=True\n",
        "    ):\n",
        "        labels = VGroup(Text(word, font_size=font_size) for word in words)\n",
        "        bars = VGroup(\n",
        "            Rectangle(prob * width_100p, bar_height)\n",
        "            for prob, label in zip(probs, labels)\n",
        "        )\n",
        "        bars.arrange(DOWN, aligned_edge=LEFT, buff=0.5 * bar_height)\n",
        "        bars.set_fill(opacity=1)\n",
        "        bars.set_submobject_colors_by_gradient(TEAL, YELLOW)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "\n",
        "        bar_groups = VGroup()\n",
        "        for label, bar, prob in zip(labels, bars, probs):\n",
        "            prob_label = Integer(int(100 * prob), unit=\"%\", font_size=0.75 * font_size)\n",
        "            prob_label.next_to(bar, RIGHT, buff=SMALL_BUFF)\n",
        "            label.next_to(bar, LEFT)\n",
        "            bar_groups.add(VGroup(label, bar, prob_label))\n",
        "\n",
        "        if show_ellipses:\n",
        "            ellipses = Tex(R\"\\vdots\", font_size=font_size)\n",
        "            ellipses.next_to(bar_groups[-1][0], DOWN)\n",
        "            bar_groups.add(ellipses)\n",
        "\n",
        "        arrow_point = machine[-1].get_right()\n",
        "        bar_groups.shift(arrow_point - bars.get_left() + 1.5 * RIGHT)\n",
        "        bar_groups.align_to(machine, UP)\n",
        "\n",
        "        return bar_groups\n",
        "\n",
        "    def animate_text_input(self, text_mob, machine, position_text_over_machine=True, added_anims=[], lag_ratio=0.02):\n",
        "        blocks = machine[0]\n",
        "        text_copy = text_mob.copy()\n",
        "        if position_text_over_machine:\n",
        "            text_copy.target = text_copy.generate_target()\n",
        "            text_copy.target.set_max_width(4)\n",
        "            text_copy.target.next_to(blocks[0], UP)\n",
        "            text_copy.target.shift_onto_screen()\n",
        "            self.play(MoveToTarget(text_copy, path_arc=-45 * DEGREES))\n",
        "        self.play(LaggedStart(\n",
        "            *added_anims,\n",
        "            Transform(\n",
        "                text_copy,\n",
        "                VGroup(VectorizedPoint(machine.get_top())),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=1,\n",
        "                path_arc=-45 * DEGREES,\n",
        "                remover=True,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (\n",
        "                    block.animate.set_color(\n",
        "                        block.get_color() if block is blocks[-1] else TEAL\n",
        "                    ).set_anim_args(rate_func=there_and_back)\n",
        "                    for block in blocks\n",
        "                ),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1\n",
        "            ),\n",
        "            Animation(machine[1:]),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "    def animate_prediction_ouptut(self, machine, cur_str):\n",
        "        words, probs = self.predict_next_token(cur_str)\n",
        "        bar_groups = self.get_distribution(words, probs, machine)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeInFromPoint(bar_group, machine[0][-1].get_right())\n",
        "                for bar_group in bar_groups),\n",
        "                lag_ratio=0.025,\n",
        "                group=bar_groups,\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        return bar_groups\n",
        "\n",
        "    def animate_random_sample(self, bar_groups):\n",
        "        widths = np.array([group[1].get_width() for group in bar_groups[:-1]])\n",
        "        dist = widths / widths.sum()\n",
        "        seed = random.randint(0, 1000)\n",
        "        buff = 0.025\n",
        "        highlight_rect = SurroundingRectangle(bar_groups[0], buff=buff)\n",
        "        highlight_rect.set_stroke(YELLOW, 2)\n",
        "        highlight_rect.set_fill(YELLOW, 0.25)\n",
        "\n",
        "        def highlight_randomly(rect, dist, alpha):\n",
        "            np.random.seed(seed + int(10 * alpha))\n",
        "            index = np.random.choice(np.arange(len(dist)), p=dist)\n",
        "            rect.surround(bar_groups[index], buff=buff)\n",
        "            rect.stretch(1.1, 0)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(highlight_rect, lambda rect, a: highlight_randomly(rect, dist, a)),\n",
        "            Animation(bar_groups)\n",
        "        )\n",
        "\n",
        "        bar_groups.add_to_back(highlight_rect)\n",
        "\n",
        "    def animate_word_addition(self, bar_groups, text_mob, next_word_line, force_unskip=False):\n",
        "        # Choose the highlighted_group\n",
        "        bar_group = None\n",
        "        if isinstance(bar_groups[0], Rectangle):\n",
        "            # Use the highlight rect to find the group element\n",
        "            bars = bar_groups[1:-1]\n",
        "            diffs = [abs(bg.get_y() - bar_groups[0].get_y()) for bg in bars]\n",
        "            bar_group = bar_groups[1:][np.argmin(diffs)]\n",
        "        if bar_group is None:\n",
        "            bar_group = bar_groups[0]\n",
        "\n",
        "        # Animate selection\n",
        "        word = bar_group[0].get_text()\n",
        "        new_str = self.cur_str + word\n",
        "        new_text_mob = self.string_to_mob(new_str)\n",
        "        new_text_mob[:len(self.seed_text.replace(\" \", \"\"))].set_color(self.seed_text_color)\n",
        "\n",
        "        word_targets = new_text_mob[word.strip()]\n",
        "        if len(word_targets) > 0:\n",
        "            target = word_targets[-1]\n",
        "        else:\n",
        "            target = new_text_mob[-len(word) - 1:-1]\n",
        "\n",
        "        # target = new_text_mob[-len(word):]\n",
        "\n",
        "        self.add(bar_groups)\n",
        "        self.play(\n",
        "            FadeTransform(bar_group[0].copy(), target),\n",
        "            Transform(\n",
        "                next_word_line,\n",
        "                self.get_next_word_line(new_text_mob),\n",
        "            ),\n",
        "        )\n",
        "        if force_unskip:\n",
        "            self.skip_animations = False\n",
        "            target.save_state()\n",
        "            target.set_fill(YELLOW)\n",
        "            self.wait(0.5)\n",
        "            target.restore()\n",
        "            self.skip_animations = True\n",
        "        self.play(\n",
        "            FadeOut(bar_groups),\n",
        "        )\n",
        "\n",
        "        self.remove(text_mob)\n",
        "        self.add(new_text_mob)\n",
        "\n",
        "        self.cur_str = new_str\n",
        "\n",
        "        return new_text_mob\n",
        "\n",
        "    def new_selection_cycle(self, text_mob, next_word_line, machine, quick=False, skip_anims=False):\n",
        "        if skip_anims:\n",
        "            self.skip_animations = True\n",
        "\n",
        "        if quick:\n",
        "            words, probs = self.predict_next_token(self.cur_str)\n",
        "            bar_groups = self.get_distribution(words, probs, machine)\n",
        "            self.add(bar_groups)\n",
        "        else:\n",
        "            self.animate_text_input(text_mob, machine)\n",
        "            bar_groups = self.animate_prediction_ouptut(machine, self.cur_str)\n",
        "        self.animate_random_sample(bar_groups)\n",
        "        new_text_mob = self.animate_word_addition(\n",
        "            bar_groups, text_mob, next_word_line,\n",
        "            force_unskip=skip_anims\n",
        "        )\n",
        "        return new_text_mob\n",
        "\n",
        "    #\n",
        "\n",
        "    def predict_next_token(self, text):\n",
        "        result = None\n",
        "        n_shown = self.n_shown_predictions\n",
        "        if self.model == \"gpt3\":\n",
        "            try:\n",
        "                result = gpt3_predict_next_token(\n",
        "                    text, n_shown, random_seed=self.random_seed\n",
        "                )\n",
        "            except Exception as e:\n",
        "                pass\n",
        "        if result is None:\n",
        "            result = gpt2_predict_next_token(text, n_shown)\n",
        "        return result\n",
        "\n",
        "\n",
        "class AltSimpleAutoRegression(SimpleAutogregression):\n",
        "    n_predictions = 1\n",
        "    line_len = 25\n",
        "\n",
        "    def reposition_transformer_drawing(self, machine):\n",
        "        machine.move_to(0.5 * RIGHT)\n",
        "        in_arrow = machine[-1].copy()\n",
        "        in_arrow.rotate(-45 * DEGREES)\n",
        "        in_arrow.next_to(machine, UL)\n",
        "        self.add(in_arrow)\n",
        "        return machine\n",
        "\n",
        "\n",
        "class AnnotateNextWord(SimpleAutogregression):\n",
        "    def construct(self):\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        self.add(machine, *machine[1:])\n",
        "        words, probs = self.predict_next_token(self.cur_str)\n",
        "        bar_groups = self.get_distribution(words, probs, machine[-1].get_right())\n",
        "\n",
        "        self.add(bar_groups)\n",
        "\n",
        "        # Initial text\n",
        "        from manimlib.mobject.boolean_ops import Union\n",
        "        highlight = Union(\n",
        "            SurroundingRectangle(text_mob[\"Behold, a wild pi creature,\"]),\n",
        "            SurroundingRectangle(text_mob[\"foraging in its native\"]),\n",
        "        )\n",
        "        highlight.set_stroke(BLUE, 3)\n",
        "        arrow = Vector(LEFT, stroke_width=10)\n",
        "        arrow.next_to(highlight, RIGHT).match_y(text_mob[0])\n",
        "\n",
        "        dist_rect = SurroundingRectangle(bar_groups)\n",
        "        dist_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(highlight),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            arrow.animate.rotate(PI / 2).next_to(dist_rect, UP),\n",
        "            ReplacementTransform(highlight, dist_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dist_rect),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "\n",
        "        # Flash through\n",
        "        self.remove(bar_groups)\n",
        "        text_mob = self.new_selection_cycle(\n",
        "            text_mob, next_word_line, machine,\n",
        "        )\n",
        "\n",
        "\n",
        "class QuickerRegression(SimpleAutogregression):\n",
        "    skip_through = True\n",
        "\n",
        "\n",
        "class AutoregressionGPT3(SimpleAutogregression):\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class QuickRegressionGPT3(SimpleAutogregression):\n",
        "    skip_through = True\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class GPT3CleverestAutocomplete(QuickRegressionGPT3):\n",
        "    seed_text = \"To date, the cleverest thinker of all time was\"\n",
        "    n_predictions = 70\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        for n in range(self.n_predictions):\n",
        "            text_mob = self.new_selection_cycle(\n",
        "                text_mob, next_word_line, machine,\n",
        "                skip_anims=(n > 2),\n",
        "            )\n",
        "\n",
        "\n",
        "class GPT3OnLearningSimpler(QuickRegressionGPT3):\n",
        "    seed_text = \"The most effective way to learn computer science is\"\n",
        "    text_corner = 3.5 * UP + 3 * LEFT\n",
        "    line_len = 35\n",
        "    font_size = 35\n",
        "    n_predictions = 300\n",
        "    time_per_prediction = 0.2\n",
        "    random_seed = 313\n",
        "    model = \"gpt3\"\n",
        "    min_y = -3\n",
        "    up_shift = 5 * UP\n",
        "    show_dist = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        cur_str = self.seed_text\n",
        "        text_mob = VGroup()\n",
        "        for n in range(self.n_predictions):\n",
        "            self.clear()\n",
        "            words, probs = self.predict_next_token(cur_str, n_shown=20)\n",
        "            index = np.random.choice(np.arange(len(words)), p=(probs / probs.sum()))\n",
        "            new_word = words[index]\n",
        "            cur_str += new_word\n",
        "            text_mob = self.string_to_mob(cur_str)\n",
        "\n",
        "            # Color seed\n",
        "            if self.color_seed:\n",
        "                text_mob[:len(self.seed_text.replace(\" \", \"\"))].set_color(BLUE)\n",
        "\n",
        "            # Add to text, shift if necessary\n",
        "            text_mob[new_word.strip()][-1].set_color(YELLOW)\n",
        "            if text_mob.get_bottom()[1] < self.min_y:\n",
        "                text_mob.shift(self.up_shift)\n",
        "                self.text_corner += self.up_shift\n",
        "            self.add(text_mob)\n",
        "\n",
        "            # Add the distribution\n",
        "            if self.show_dist:\n",
        "                dist = self.get_distribution(\n",
        "                    words[:self.n_shown_predictions],\n",
        "                    probs[:self.n_shown_predictions],\n",
        "                    buff=0\n",
        "                )\n",
        "                dist.set_height(4)\n",
        "                dist.to_edge(DOWN)\n",
        "                rect = SurroundingRectangle(dist[min(index, len(dist) - 1)])\n",
        "                self.add(dist, rect)\n",
        "\n",
        "            self.wait(self.time_per_prediction)\n",
        "\n",
        "\n",
        "class GPT3OnLongPassages(GPT3OnLearningSimpler):\n",
        "    seed_text = \"Writing long passages seems to involve more foresight and planning than what single-word prediction\"\n",
        "    n_predictions = 100\n",
        "    color_seed = False\n",
        "\n",
        "\n",
        "class GPT3CreaturePrediction(GPT3CleverestAutocomplete):\n",
        "    seed_text = \"the fluffy blue creature\"\n",
        "    n_predictions = 1\n",
        "\n",
        "\n",
        "class GPT3CreaturePrediction2(GPT3CleverestAutocomplete):\n",
        "    seed_text = \"the fluffy blue creature roamed the\"\n",
        "    n_predictions = 1\n",
        "\n",
        "\n",
        "class LowTempExample(GPT3OnLearningSimpler):\n",
        "    seed_text = \"Once upon a time, there was a\"\n",
        "    model = \"gpt3\"\n",
        "    min_y = 1\n",
        "    up_shift = 2 * UP\n",
        "    show_dist = True\n",
        "    temp = 0\n",
        "    n_predictions = 200\n",
        "    time_per_prediction = 0.25\n",
        "\n",
        "    def predict_next_token(self, text, n_shown=None):\n",
        "        words, probs = super().predict_next_token(text, n_shown)\n",
        "        if self.temp == 0:\n",
        "            probs = np.zeros_like(probs)\n",
        "            probs[0] = 1\n",
        "        else:\n",
        "            probs = probs**(1 / self.temp)\n",
        "            probs /= probs.sum()\n",
        "        return words, probs\n",
        "\n",
        "\n",
        "class HighTempExample(LowTempExample):\n",
        "    temp = 5\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class MidTempExample(LowTempExample):\n",
        "    seed_text = \"If you could see the underlying probability distributions a large language model uses when generating text, then\"\n",
        "    temp = 1\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class ChatBotPrompt(SimpleAutogregression):\n",
        "    system_prompt = \"\"\"\n",
        "        What follows is a conversation between a user and a helpful,\n",
        "        very knowledgeable AI assistant.\n",
        "    \"\"\"\n",
        "    user_prompt = \"User: Give me some ideas for what to do when visiting Paris.\"\n",
        "    ai_seed = \"AI Assistant: \"\n",
        "    machine_name = \"Large\\nLanguage\\nModel\"\n",
        "\n",
        "    line_len = 28\n",
        "    font_size = 36\n",
        "    color_seed = False\n",
        "\n",
        "    n_predictions = 60\n",
        "    model = \"gpt3\"\n",
        "    random_seed = 12\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "\n",
        "        all_strs = list(map(clean_text, [self.system_prompt, self.user_prompt, self.ai_seed]))\n",
        "\n",
        "        system_prompt, user_prompt, ai_seed = all_text = VGroup(\n",
        "            get_paragraph(\n",
        "                s.split(\" \"),\n",
        "                font_size=self.font_size,\n",
        "                line_len=self.line_len\n",
        "            )\n",
        "            for s in all_strs\n",
        "        )\n",
        "        all_text.arrange(DOWN, aligned_edge=LEFT, buff=0.75)\n",
        "        all_text.move_to(self.text_corner, UL)\n",
        "        self.remove(text_mob)\n",
        "        self.add(all_text)\n",
        "\n",
        "        text_mob = ai_seed\n",
        "        self.text_corner = text_mob.get_corner(UL)\n",
        "        next_word_line.next_to(ai_seed, RIGHT, aligned_edge=DOWN)\n",
        "\n",
        "        self.cur_str = \"\\n\\n\".join(all_strs)\n",
        "\n",
        "        # Comment on system prompt\n",
        "        sys_rect = SurroundingRectangle(system_prompt)\n",
        "        sys_rect.set_stroke(GREEN, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sys_rect),\n",
        "            system_prompt.animate.set_color(GREEN_B)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Users prompt\n",
        "        from manimlib.mobject.boolean_ops import Union\n",
        "\n",
        "        top_line = user_prompt[\"Give me some ideas for what\"]\n",
        "        low_line = user_prompt[\"to do when visiting Santiago.\"]\n",
        "        user_rect = Union(\n",
        "            SurroundingRectangle(low_line),\n",
        "            SurroundingRectangle(top_line),\n",
        "        )\n",
        "        user_rect.set_stroke(BLUE, 2)\n",
        "\n",
        "        sys_rect.insert_n_curves(100)\n",
        "        self.play(\n",
        "            ReplacementTransform(sys_rect, user_rect),\n",
        "            top_line.animate.set_color(BLUE_B),\n",
        "            low_line.animate.set_color(BLUE_B),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(user_rect),\n",
        "        )\n",
        "\n",
        "        # Run predictions\n",
        "        text_mob = all_text\n",
        "        self.add(all_text.copy())\n",
        "        for n in range(self.n_predictions):\n",
        "            text_mob = self.new_selection_cycle(\n",
        "                text_mob, next_word_line, machine,\n",
        "                skip_anims=(n > 0),\n",
        "            )\n",
        "\n",
        "    def string_to_mob(self, text):\n",
        "        seed = self.ai_seed.strip()\n",
        "        if seed in text:\n",
        "            text = text[text.index(seed):]\n",
        "        return super().string_to_mob(text)\n",
        "\n",
        "\n",
        "class ChatBotPrompt2(ChatBotPrompt):\n",
        "    user_prompt = \"User: Can you explain what temperature is, in the context of softmax?\"\n",
        "\n",
        "\n",
        "class ChatBotPrompt3(ChatBotPrompt):\n",
        "    user_prompt = \"User: Can you give me some ideas for what to do while visiting Munich?\"\n",
        "\n",
        "\n",
        "class VoiceToTextExample(SimpleAutogregression):\n",
        "    model_name = \"voice-to-text\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Add model\n",
        "        box = Rectangle(4, 3)\n",
        "        box.set_stroke(WHITE, 2)\n",
        "        name = Text(self.model_name, font_size=60)\n",
        "        name.set_max_width(box.get_width())\n",
        "        name.next_to(box, UP)\n",
        "        machine = self.get_transformer_drawing()\n",
        "        machine.center()\n",
        "        machine.set_max_width(0.75 * box.get_width())\n",
        "        machine.move_to(box)\n",
        "        arrows = Vector(0.75 * RIGHT, stroke_width=8).replicate(2)\n",
        "        arrows[0].next_to(box, LEFT, SMALL_BUFF)\n",
        "        arrows[1].next_to(box, RIGHT, SMALL_BUFF)\n",
        "        model = Group(box, name, arrows, machine)\n",
        "\n",
        "        self.add(*model)\n",
        "        self.add(Point())\n",
        "\n",
        "        # Process input\n",
        "        max_width = 3.75\n",
        "        in_mob = self.get_input().set_max_width(max_width)\n",
        "        out_mob = self.get_output().set_max_width(max_width)\n",
        "        in_mob.next_to(arrows, LEFT)\n",
        "        out_mob.next_to(arrows, RIGHT)\n",
        "\n",
        "        self.add(in_mob)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOutToPoint(\n",
        "                in_mob.copy(), machine.get_left(),\n",
        "                path_arc=-45 * DEGREES,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (block.animate.set_color(TEAL).set_anim_args(rate_func=there_and_back)\n",
        "                for block in machine[0][:-1]),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1,\n",
        "            ),\n",
        "            FadeInFromPoint(\n",
        "                out_mob.copy(), machine.get_right(),\n",
        "                path_arc=45 * DEGREES,\n",
        "                lag_ratio=0.02\n",
        "            ),\n",
        "            lag_ratio=0.7\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def get_input(self) -> Mobject:\n",
        "        result =ImageMobject(\"AudioSnippet\").set_width(3.75)\n",
        "        result.set_height(3, stretch=True)\n",
        "        return result\n",
        "\n",
        "    def get_output(self) -> Mobject:\n",
        "        return Text(\"\"\"\n",
        "            Some models take\n",
        "            in audio and\n",
        "            produce a transcript\n",
        "        \"\"\", alignment=\"LEFT\")\n",
        "\n",
        "\n",
        "class TextToVoiceExample(VoiceToTextExample):\n",
        "    model_name = \"text-to-voice\"\n",
        "\n",
        "    def get_input(self):\n",
        "        return Text(\"\"\"\n",
        "            This sentence comes from\n",
        "            a model going the other\n",
        "            way around, producing\n",
        "            synthetic speech just\n",
        "            from text.\n",
        "        \"\"\", alignment=\"LEFT\")\n",
        "\n",
        "    def get_output(self):\n",
        "        return super().get_input()\n",
        "\n",
        "\n",
        "class TextToImage(VoiceToTextExample):\n",
        "    model_name = \"text-to-image\"\n",
        "    prompt = \"\"\"\n",
        "        1960s photograph of a cute fluffy blue wild pi\n",
        "        creature, a creature whose body is shaped like\n",
        "        the symbol \u03c0, who is foraging in its native territory,\n",
        "        staring back at the camera with an exotic scene\n",
        "        in the background.\n",
        "    \"\"\"\n",
        "    image_name = \"PiCreatureDalle3_5\"\n",
        "\n",
        "    def get_clean_prompt(self):\n",
        "        return clean_text(self.prompt)\n",
        "\n",
        "    def get_input(self):\n",
        "        return get_paragraph(self.get_clean_prompt().split(\" \"), line_len=25)\n",
        "\n",
        "    def get_output(self):\n",
        "        return ImageMobject(self.image_name)\n",
        "\n",
        "    def generate_output(self):\n",
        "        # Test\n",
        "        self.prompt = \"\"\"\n",
        "            1960s photograph of a cute fluffy blue wild pi\n",
        "            creature, a creature whose face bears a subtle resemblence\n",
        "            to the shape of the symbol \u03c0, who is foraging in its native\n",
        "            territory, staring back at the camera with an exotic scene\n",
        "            in the background.\n",
        "        \"\"\"\n",
        "\n",
        "        self.prompt = \"abstract depiction of furry fluffiness\"\n",
        "\n",
        "        openai.api_key = os.getenv('OPENAI_KEY')\n",
        "        prompt = self.get_clean_prompt()\n",
        "\n",
        "        response = openai.Image.create(\n",
        "            model=\"dall-e-3\",\n",
        "            prompt=prompt,\n",
        "            size=\"1024x1024\",\n",
        "            quality=\"standard\",\n",
        "            n=1,\n",
        "        )\n",
        "\n",
        "        image_url = response.data[0].url\n",
        "        print(prompt)\n",
        "        print(image_url)\n",
        "\n",
        "        response = openai.Image.create_variation(\n",
        "          image=open(\"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/images/raster/PiCreatureDalle3_17.png\", \"rb\"),\n",
        "          n=1,\n",
        "          size=\"1024x1024\"\n",
        "        )\n",
        "\n",
        "\n",
        "class TranslationExample(VoiceToTextExample):\n",
        "    model_name = \"machine translation\"\n",
        "\n",
        "    def get_input(self):\n",
        "        return Text(\"Attention is all\\nyou need\")\n",
        "\n",
        "    def get_output(self):\n",
        "        return Group(Point(), *Text(\"\u6ce8\u610f\u529b\u5c31\u662f\u4f60\u6240\u9700\u8981\u7684\u4e00\u5207\"))\n",
        "\n",
        "\n",
        "class PredictionVsGeneration(SimpleAutogregression):\n",
        "    model = \"gpt2\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.add(FullScreenRectangle())\n",
        "        morty = Mortimer()\n",
        "        morty.to_edge(DOWN)\n",
        "        morty.body.insert_n_curves(100)\n",
        "        self.add(morty)\n",
        "\n",
        "        # Words\n",
        "        words = VGroup(Text(\"Prediction\"), Text(\"Generation\"))\n",
        "        words.scale(1.5)\n",
        "        for vect, word in zip([UL, UR], words):\n",
        "            word.next_to(morty, vect)\n",
        "            word.shift(0.5 * UP)\n",
        "\n",
        "        # Create prediction object\n",
        "        seed_text = \"The goal of predicting the next\"\n",
        "        self.n_shown_predictions = 8\n",
        "        tokens, probs = self.predict_next_token(seed_text)\n",
        "        dist = self.get_distribution(tokens, probs)\n",
        "        brace = Brace(dist, LEFT, SMALL_BUFF)\n",
        "        words = Text(seed_text, font_size=36).next_to(brace, LEFT)\n",
        "        prediction = VGroup(words, brace, dist)\n",
        "        prediction.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        prediction.next_to(morty, UL)\n",
        "        prediction.shift(0.5 * UP).shift_onto_screen()\n",
        "        self.add(prediction)\n",
        "\n",
        "        # Animations\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\", prediction),\n",
        "            FadeIn(prediction[0], UP),\n",
        "            GrowFromCenter(prediction[1]),\n",
        "            LaggedStart(\n",
        "                (FadeInFromPoint(bar, prediction[1].get_center())\n",
        "                for bar in prediction[2]),\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            morty.change(\"raise_left_hand\", 3 * UR),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ManyParallelPredictions(SimpleAutogregression):\n",
        "    line_len = 200\n",
        "    n_shown_predictions = 8\n",
        "    model = \"gpt3\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.fake_machine = VectorizedPoint().replicate(3)\n",
        "        full_string = \"Harry Potter was a highly unusual boy\"\n",
        "\n",
        "        # Draw last layer vectors\n",
        "        last_layer = VGroup(\n",
        "            NumericEmbedding(length=10)\n",
        "            for n in range(12)\n",
        "        )\n",
        "        last_layer.arrange(RIGHT, buff=0.35 * last_layer[0].get_width())\n",
        "        last_layer.set_height(3)\n",
        "        last_layer.to_edge(DOWN)\n",
        "        # self.add(last_layer)\n",
        "\n",
        "        rects = VGroup(map(SurroundingRectangle, last_layer))\n",
        "        rects.set_stroke(YELLOW, 2)\n",
        "        arrows = VGroup(Vector(0.5 * UP).next_to(rect, UP, buff=0.1) for rect in rects)\n",
        "        arrows.set_stroke(YELLOW)\n",
        "\n",
        "        # Show prediction groups\n",
        "        words = full_string.split(\" \")\n",
        "        substrings = [\n",
        "            \" \".join(words[:n + 1])\n",
        "            for n in range(len(words))\n",
        "        ]\n",
        "\n",
        "        predictions = VGroup(\n",
        "            self.get_prediction_group(substring)\n",
        "            for substring in substrings\n",
        "        )\n",
        "        predictions[0].to_edge(UP, buff=1.25).align_to(rects[1], LEFT)\n",
        "        for prediction, arrow, rect in zip(predictions, arrows, rects):\n",
        "            prediction.move_to(predictions[0], LEFT)\n",
        "            arrow.become(Arrow(\n",
        "                rect.get_top(),\n",
        "                prediction[1].get_left(),\n",
        "            ))\n",
        "            arrow.set_stroke(YELLOW)\n",
        "\n",
        "        last_group = VGroup(\n",
        "            rects[0].copy().set_opacity(0),\n",
        "            arrows[0].copy().set_opacity(0),\n",
        "            predictions[0].copy().set_opacity(0),\n",
        "        )\n",
        "        for rect, arrow, prediction in zip(rects, arrows, predictions):\n",
        "            self.remove(last_group)\n",
        "            self.play(\n",
        "                TransformFromCopy(last_group[0], rect),\n",
        "                TransformFromCopy(last_group[1], arrow),\n",
        "                TransformMatchingStrings(last_group[2][0].copy(), prediction[0], run_time=1),\n",
        "                FadeTransform(last_group[2][1].copy(), prediction[1]),\n",
        "                FadeTransform(last_group[2][2].copy(), prediction[2]),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_group = VGroup(rect, arrow, prediction)\n",
        "\n",
        "    def get_prediction_group(self, text):\n",
        "        words, probs = self.predict_next_token(text)\n",
        "        dist = self.get_distribution(\n",
        "            words, probs,\n",
        "            width_100p=2.0\n",
        "        )\n",
        "        dist.set_max_height(2.5)\n",
        "        brace = Brace(dist, LEFT)\n",
        "        prefix = Text(text, font_size=30)\n",
        "        prefix.next_to(brace, LEFT)\n",
        "\n",
        "        result = VGroup(prefix, brace, dist)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class PeekUnderTheHood(SimpleAutogregression):\n",
        "    def construct(self):\n",
        "        # Add parts\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        blocks, label, arrow = machine\n",
        "        self.remove(text_mob, next_word_line)\n",
        "\n",
        "        # Zoom in\n",
        "        self.camera.light_source.move_to([-15, 5, 10])\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        blocks.rotate(-5 * DEGREES, UP, about_edge=OUT)\n",
        "        blocks.rotate(-10 * DEGREES, RIGHT, about_edge=OUT)\n",
        "        blocks.target = blocks.generate_target()\n",
        "        blocks.target.set_height(5)\n",
        "        blocks.target.center()\n",
        "        blocks.target[5:].set_opacity(0.3)\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-23, -12, 0, (1.79, -0.56, 1.27), 8.40).set_anim_args(run_time=3),\n",
        "            MoveToTarget(blocks, run_time=3),\n",
        "            FadeOut(arrow, RIGHT),\n",
        "            FadeOut(label, 2 * OUT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        blocks[5:].set_opacity(0.3)\n",
        "\n",
        "        # Add matrices\n",
        "        matrices = VGroup(WeightMatrix(shape=(8, 8)) for x in range(9))\n",
        "        matrices.arrange_in_grid(h_buff_ratio=0.25, v_buff_ratio=0.4)\n",
        "        matrices.match_width(blocks)\n",
        "        index = 6\n",
        "        matrices.move_to(blocks[index], OUT)\n",
        "        self.add(matrices, blocks[index:])"
    ]
}