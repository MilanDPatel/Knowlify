{
    "topic": "The mathematical concept being demonstrated is the computation of the derivative of a function using the limit definition. The",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2017.eoc.chapter2 import DISTANCE_COLOR, TIME_COLOR, \\\n",
        "    VELOCITY_COLOR, Car, MoveCar\n",
        "\n",
        "OUTPUT_COLOR = DISTANCE_COLOR\n",
        "INPUT_COLOR = TIME_COLOR\n",
        "DERIVATIVE_COLOR = VELOCITY_COLOR\n",
        "\n",
        "class Chapter3OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"You know, for a mathematician, he did not have \\\\\\\\ enough\",\n",
        "            \"imagination.\", \n",
        "            \"But he has become a poet and \\\\\\\\ now he is fine.\",\n",
        "        ],\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"imagination.\" : BLUE,\n",
        "        },\n",
        "        \"author\" : \"David Hilbert\"\n",
        "    }\n",
        "\n",
        "class PoseAbstractDerivative(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Given $f(x) = x^2 \\\\sin(x)$, \\\\\\\\\n",
        "            compute $\\\\frac{df}{dx}(x)$\n",
        "        \"\"\")\n",
        "        content_copy = self.teacher.bubble.content.copy()\n",
        "        self.play_student_changes(\"sad\", \"confused\", \"erm\")\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"Why?\", target_mode = \"sassy\",\n",
        "            added_anims = [\n",
        "                content_copy.scale, 0.8,\n",
        "                content_copy.to_corner, UP+LEFT\n",
        "            ]\n",
        "        )\n",
        "        self.play(self.teacher.change_mode, \"pondering\")\n",
        "        self.wait(2)\n",
        "\n",
        "class ContrastAbstractAndConcrete(Scene):\n",
        "    def construct(self):\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        l_title = OldTexText(\"Abstract functions\")\n",
        "        l_title.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        l_title.to_edge(UP)\n",
        "        r_title = OldTexText(\"Applications\")\n",
        "        r_title.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        r_title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.shift((r_title.get_bottom()[1]-MED_SMALL_BUFF)*UP)\n",
        "\n",
        "        functions = VGroup(*list(map(Tex, [\n",
        "            \"f(x) = 2x^2 - x^3\",\n",
        "            \"f(x) = \\\\sin(x)\",\n",
        "            \"f(x) = e^x\",\n",
        "            \"\\\\v_dots\"\n",
        "        ])))\n",
        "        functions.arrange(\n",
        "            DOWN, \n",
        "            aligned_edge = LEFT,\n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "        functions.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        functions[-1].shift(MED_LARGE_BUFF*RIGHT)\n",
        "\n",
        "        self.add(l_title, r_title)\n",
        "        self.play(*list(map(ShowCreation, [h_line, v_line])))\n",
        "        self.play(Write(functions))\n",
        "        self.wait()\n",
        "        anims = [\n",
        "            method(func_mob)\n",
        "            for func_mob, method in zip(functions, [\n",
        "                self.get_car_anim,\n",
        "                self.get_spring_anim,\n",
        "                self.get_population_anim,\n",
        "            ])\n",
        "        ]\n",
        "        for anim in anims:\n",
        "            self.play(FadeIn(anim.mobject))\n",
        "            self.play(anim)\n",
        "            self.play(FadeOut(anim.mobject))\n",
        "\n",
        "\n",
        "    def get_car_anim(self, alignement_mob):\n",
        "        car = Car()\n",
        "        point = 2*RIGHT + alignement_mob.get_bottom()[1]*UP\n",
        "        target_point = point + 5*RIGHT\n",
        "        car.move_to(point)\n",
        "        return MoveCar(\n",
        "            car, target_point, \n",
        "            run_time = 5,\n",
        "        )\n",
        "\n",
        "    def get_spring_anim(self, alignement_mob):\n",
        "        compact_spring, extended_spring = [\n",
        "            ParametricCurve(\n",
        "                lambda t : (t/denom)*RIGHT+np.sin(t)*UP+np.cos(t)*OUT,\n",
        "                t_max = 12*np.pi,\n",
        "            )\n",
        "            for denom in (12.0, 4.0)\n",
        "        ]\n",
        "        for spring in compact_spring, extended_spring:\n",
        "            spring.scale(0.5)\n",
        "            spring.rotate(np.pi/6, UP)\n",
        "            spring.set_color(GREY)\n",
        "            spring.next_to(ORIGIN, RIGHT)\n",
        "            spring.shift(\n",
        "                alignement_mob.get_center()[1]*UP + SMALL_BUFF*RIGHT \\\n",
        "                -spring.get_points()[0]\n",
        "            )\n",
        "            weight = Square(\n",
        "                side_length = 0.5,\n",
        "                stroke_width = 0, \n",
        "                fill_color = GREY_B,\n",
        "                fill_opacity = 1,\n",
        "            )\n",
        "            weight.move_to(spring.get_points()[-1])\n",
        "            spring.add(weight)\n",
        "\n",
        "        return Transform(\n",
        "            compact_spring, extended_spring, \n",
        "            rate_func = lambda t : 1+np.sin(6*np.pi*t),\n",
        "            run_time = 5\n",
        "        )\n",
        "\n",
        "    def get_population_anim(self, alignement_mob):\n",
        "        colors = color_gradient([BLUE_B, BLUE_E], 12)\n",
        "        pis = VGroup(*[\n",
        "            Randolph(\n",
        "                mode = \"happy\",\n",
        "                color = random.choice(colors)\n",
        "            ).shift(\n",
        "                4*x*RIGHT + 4*y*UP + \\\n",
        "                2*random.random()*RIGHT + \\\n",
        "                2*random.random()*UP\n",
        "            )\n",
        "            for x in range(20)\n",
        "            for y in range(10)\n",
        "        ])\n",
        "        pis.set_height(3)\n",
        "        pis.center()\n",
        "        pis.to_edge(DOWN, buff = SMALL_BUFF)\n",
        "        pis.shift(FRAME_X_RADIUS*RIGHT/2.)\n",
        "\n",
        "        anims = []\n",
        "        for index, pi in enumerate(pis):\n",
        "            if index < 2:\n",
        "                anims.append(FadeIn(pi))\n",
        "                continue\n",
        "            mom_index, dad_index = random.choice(\n",
        "                list(it.combinations(list(range(index)), 2))\n",
        "            )\n",
        "            pi.parents = VGroup(pis[mom_index], pis[dad_index]).copy()\n",
        "            pi.parents.set_fill(opacity = 0)\n",
        "        exp = 1\n",
        "        while 2**exp < len(pis):\n",
        "            low_index = 2**exp\n",
        "            high_index = min(2**(exp+1), len(pis))\n",
        "            these_pis = pis[low_index:high_index]\n",
        "            anims.append(Transform(\n",
        "                VGroup(*[pi.parents for pi in these_pis]),\n",
        "                VGroup(*[VGroup(pi, pi.copy()) for pi in these_pis]),\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2,\n",
        "            ))\n",
        "            exp += 1\n",
        "\n",
        "        return Succession(*anims, rate_func=linear)\n",
        "\n",
        "class ApplicationNames(Scene):\n",
        "    def construct(self):\n",
        "        for name in \"Velocity\", \"Oscillation\", \"Population growth\":\n",
        "            mob = OldTexText(name)\n",
        "            mob.scale(2)\n",
        "            self.play(Write(mob))\n",
        "            self.wait(2)\n",
        "            self.play(FadeOut(mob))\n",
        "\n",
        "class ListOfRules(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"use_morty\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        rules = VGroup(*list(map(Tex, [\n",
        "            \"\\\\frac{d}{dx} x^n = nx^{n-1}\",\n",
        "            \"\\\\frac{d}{dx} \\\\sin(x) = \\\\cos(x)\",\n",
        "            \"\\\\frac{d}{dx} \\\\cos(x) = -\\\\sin(x)\",\n",
        "            \"\\\\frac{d}{dx} a^x = \\\\ln(a) a^x\",\n",
        "            \"\\\\vdots\"\n",
        "        ])))\n",
        "        rules.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        rules[-1].shift(MED_LARGE_BUFF*RIGHT)\n",
        "        rules.set_height(FRAME_HEIGHT-1)\n",
        "        rules.next_to(self.pi_creature, RIGHT)\n",
        "        rules.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(rules),\n",
        "            self.pi_creature.change_mode, \"pleading\",\n",
        "        )\n",
        "        self.change_mode(\"tired\")\n",
        "        self.wait()\n",
        "\n",
        "class DerivativeOfXSquaredAsGraph(GraphScene, ZoomedScene, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 2,\n",
        "        \"big_x\" : 3,\n",
        "        \"dx\" : 0.1,\n",
        "        \"x_min\" : -9,\n",
        "        \"x_labeled_nums\" : list(range(-8, 0, 2)) + list(range(2, 10, 2)),\n",
        "        \"y_labeled_nums\" : list(range(2, 12, 2)),\n",
        "        \"little_rect_nudge\" : 0.5*(1.5*UP+RIGHT),\n",
        "        \"graph_origin\" : 2.5*DOWN + LEFT,\n",
        "        \"zoomed_canvas_corner\" : UP+LEFT,\n",
        "        \"zoomed_canvas_frame_shape\" : (4, 4),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_graph()\n",
        "        self.ask_about_df_dx()\n",
        "        self.show_differing_slopes()\n",
        "        self.mention_alternate_view()\n",
        "\n",
        "    def draw_graph(self):\n",
        "        self.setup_axes(animate = True)\n",
        "        graph = self.get_graph(lambda x : x**2)\n",
        "        label = self.get_graph_label(\n",
        "            graph, \"f(x) = x^2\",\n",
        "        )\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "        self.graph = graph\n",
        "\n",
        "    def ask_about_df_dx(self):\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            self.start_x, self.graph,\n",
        "            dx = self.dx,\n",
        "            dx_label = \"dx\",\n",
        "            df_label = \"df\",\n",
        "        )\n",
        "        secant_line = ss_group.secant_line\n",
        "        ss_group.remove(secant_line)\n",
        "\n",
        "        v_line, nudged_v_line = [\n",
        "            self.get_vertical_line_to_graph(\n",
        "                x, self.graph,\n",
        "                line_class = DashedLine,\n",
        "                color = RED,\n",
        "                dash_length = 0.025\n",
        "            )\n",
        "            for x in (self.start_x, self.start_x+self.dx)\n",
        "        ]\n",
        "\n",
        "        df_dx = OldTex(\"\\\\frac{df}{dx} ?\")\n",
        "        VGroup(*df_dx[:2]).set_color(ss_group.df_line.get_color())\n",
        "        VGroup(*df_dx[3:5]).set_color(ss_group.dx_line.get_color())\n",
        "        df_dx.next_to(\n",
        "            self.input_to_graph_point(self.start_x, self.graph),\n",
        "            DOWN+RIGHT,\n",
        "            buff = MED_SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        derivative_q = OldTexText(\"Derivative?\")\n",
        "        derivative_q.next_to(self.pi_creature.get_corner(UP+LEFT), UP)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Write(derivative_q, run_time = 1),\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(derivative_q),\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(Transform(v_line.copy(), nudged_v_line))\n",
        "        self.remove(self.get_mobjects_from_last_animation()[0])\n",
        "        self.add(nudged_v_line)\n",
        "        self.wait()\n",
        "        self.activate_zooming()\n",
        "        self.little_rectangle.replace(self.big_rectangle)\n",
        "        self.play(\n",
        "            FadeIn(self.little_rectangle),\n",
        "            FadeIn(self.big_rectangle),\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                lambda r : self.position_little_rectangle(r, ss_group),\n",
        "                self.little_rectangle\n",
        "            ),\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look_at, ss_group\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(ss_group.dx_line),\n",
        "            Write(ss_group.dx_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(ss_group.df_line),\n",
        "            Write(ss_group.df_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(df_dx))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            v_line, nudged_v_line,\n",
        "        ])))\n",
        "        self.ss_group = ss_group\n",
        "\n",
        "    def position_little_rectangle(self, rect, ss_group):\n",
        "        rect.set_width(3*self.dx)\n",
        "        rect.move_to(\n",
        "            ss_group.dx_line.get_left()\n",
        "        )\n",
        "        rect.shift(\n",
        "            self.dx*self.little_rect_nudge\n",
        "        )\n",
        "        return rect\n",
        "\n",
        "    def show_differing_slopes(self):\n",
        "        ss_group = self.ss_group\n",
        "        def rect_update(rect):\n",
        "            self.position_little_rectangle(rect, ss_group)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ss_group.secant_line),\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        ss_group.add(ss_group.secant_line)\n",
        "        self.wait()\n",
        "        for target_x in self.big_x, -self.dx/2, 1, 2:\n",
        "            self.animate_secant_slope_group_change(\n",
        "                ss_group, target_x = target_x,\n",
        "                added_anims = [\n",
        "                    UpdateFromFunc(self.little_rectangle, rect_update)\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def mention_alternate_view(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        self.add(self.pi_creature)\n",
        "        self.disactivate_zooming()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                everything.shift, FRAME_WIDTH*LEFT,\n",
        "                rate_func = lambda t : running_start(t, -0.1)\n",
        "            ),\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.say(\"Let's try \\\\\\\\ another view.\", target_mode = \"speaking\")\n",
        "        self.wait(2)\n",
        "\n",
        "class NudgeSideLengthOfSquare(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"square_width\" : 3,\n",
        "        \"alt_square_width\" : 5,\n",
        "        \"dx\" : 0.25,\n",
        "        \"alt_dx\" : 0.01,\n",
        "        \"square_color\" : GREEN,\n",
        "        \"square_fill_opacity\" : 0.75,\n",
        "        \"three_color\" : GREEN,\n",
        "        \"dx_color\" : BLUE_B,\n",
        "        \"is_recursing_on_dx\" : False,\n",
        "        \"is_recursing_on_square_width\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        ApplyMethod(self.pi_creature.change_mode, \"speaking\").update(1)\n",
        "        self.add_function_label()\n",
        "        self.introduce_square()\n",
        "        self.increase_area()\n",
        "        self.write_df_equation()\n",
        "        self.set_color_shapes()\n",
        "        self.examine_thin_rectangles()\n",
        "        self.examine_tiny_square()\n",
        "        self.show_smaller_dx()\n",
        "        self.rule_of_thumb()\n",
        "        self.write_out_derivative()\n",
        "\n",
        "    def add_function_label(self):\n",
        "        label = OldTex(\"f(x) = x^2\")\n",
        "        label.next_to(ORIGIN, RIGHT, buff = (self.square_width-3)/2.)\n",
        "        label.to_edge(UP)\n",
        "        self.add(label)\n",
        "        self.function_label = label\n",
        "\n",
        "    def introduce_square(self):\n",
        "        square = Square(\n",
        "            side_length = self.square_width,\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = self.square_fill_opacity,\n",
        "            fill_color = self.square_color,\n",
        "        )\n",
        "        square.to_corner(UP+LEFT, buff = LARGE_BUFF)\n",
        "        x_squared = OldTex(\"x^2\")\n",
        "        x_squared.move_to(square)\n",
        "\n",
        "        braces = VGroup()\n",
        "        for vect in RIGHT, DOWN:\n",
        "            brace = Brace(square, vect)\n",
        "            text = brace.get_text(\"$x$\")\n",
        "            brace.add(text)\n",
        "            braces.add(brace)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(square),\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(*list(map(GrowFromCenter, braces)))\n",
        "        self.play(Write(x_squared))\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "\n",
        "        self.square = square\n",
        "        self.side_braces = braces\n",
        "\n",
        "    def increase_area(self):\n",
        "        color_kwargs = {\n",
        "            \"fill_color\" : YELLOW,\n",
        "            \"fill_opacity\" : self.square_fill_opacity,\n",
        "            \"stroke_width\" : 0,\n",
        "        }\n",
        "        right_rect = Rectangle(\n",
        "            width = self.dx,\n",
        "            height = self.square_width,\n",
        "            **color_kwargs\n",
        "        )\n",
        "        bottom_rect = right_rect.copy().rotate(-np.pi/2)\n",
        "        right_rect.next_to(self.square, RIGHT, buff = 0)\n",
        "        bottom_rect.next_to(self.square, DOWN, buff = 0)\n",
        "        corner_square = Square(\n",
        "            side_length = self.dx,\n",
        "            **color_kwargs\n",
        "        )\n",
        "        corner_square.next_to(self.square, DOWN+RIGHT, buff = 0)\n",
        "\n",
        "        right_line = Line(\n",
        "            self.square.get_corner(UP+RIGHT),\n",
        "            self.square.get_corner(DOWN+RIGHT),\n",
        "            stroke_width = 0\n",
        "        )\n",
        "        bottom_line = Line(\n",
        "            self.square.get_corner(DOWN+RIGHT),\n",
        "            self.square.get_corner(DOWN+LEFT),\n",
        "            stroke_width = 0\n",
        "        )\n",
        "        corner_point = VectorizedPoint(\n",
        "            self.square.get_corner(DOWN+RIGHT)\n",
        "        )\n",
        "\n",
        "        little_braces = VGroup()\n",
        "        for vect in RIGHT, DOWN:\n",
        "            brace = Brace(\n",
        "                corner_square, vect, \n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "            text = brace.get_text(\"$dx$\", buff = SMALL_BUFF)\n",
        "            text.set_color(self.dx_color)\n",
        "            brace.add(text)\n",
        "            little_braces.add(brace)\n",
        "\n",
        "        right_brace, bottom_brace = self.side_braces\n",
        "        self.play(\n",
        "            Transform(right_line, right_rect),\n",
        "            Transform(bottom_line, bottom_rect),\n",
        "            Transform(corner_point, corner_square),\n",
        "            right_brace.next_to, right_rect, RIGHT, SMALL_BUFF,\n",
        "            bottom_brace.next_to, bottom_rect, DOWN, SMALL_BUFF,\n",
        "        )\n",
        "        self.remove(corner_point, bottom_line, right_line)\n",
        "        self.add(corner_square, bottom_rect, right_rect)\n",
        "        self.play(*list(map(GrowFromCenter, little_braces)))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(*[\n",
        "            [mob.shift, vect*SMALL_BUFF]\n",
        "            for mob, vect in [\n",
        "                (right_rect, RIGHT),\n",
        "                (bottom_rect, DOWN),\n",
        "                (corner_square, DOWN+RIGHT),\n",
        "                (right_brace, RIGHT),\n",
        "                (bottom_brace, DOWN),\n",
        "                (little_braces, DOWN+RIGHT)\n",
        "            ]\n",
        "        ]))\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.right_rect = right_rect\n",
        "        self.bottom_rect = bottom_rect\n",
        "        self.corner_square = corner_square\n",
        "        self.little_braces = little_braces\n",
        "\n",
        "    def write_df_equation(self):\n",
        "        right_rect = self.right_rect\n",
        "        bottom_rect = self.bottom_rect\n",
        "        corner_square = self.corner_square\n",
        "\n",
        "        df_equation = VGroup(\n",
        "            OldTex(\"df\").set_color(right_rect.get_color()),\n",
        "            OldTex(\"=\"),\n",
        "            right_rect.copy(),\n",
        "            OldTexText(\"+\"),\n",
        "            right_rect.copy(),\n",
        "            OldTex(\"+\"),\n",
        "            corner_square.copy()\n",
        "        )\n",
        "        df_equation.arrange()\n",
        "        df_equation.next_to(\n",
        "            self.function_label, DOWN, \n",
        "            aligned_edge = LEFT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        df, equals, r1, plus1, r2, plus2, s = df_equation\n",
        "\n",
        "        pairs = [\n",
        "            (df, self.function_label[0]),\n",
        "            (r1, right_rect), \n",
        "            (r2, bottom_rect), \n",
        "            (s, corner_square),\n",
        "        ]\n",
        "        for mover, origin in pairs:\n",
        "            mover.save_state()\n",
        "            Transform(mover, origin).update(1)\n",
        "        self.play(df.restore)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *[\n",
        "                mob.restore\n",
        "                for mob in (r1, r2, s)\n",
        "            ]+[\n",
        "                Write(symbol)\n",
        "                for symbol in (equals, plus1, plus2)\n",
        "            ], \n",
        "            run_time = 2\n",
        "        )\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait()\n",
        "\n",
        "        self.df_equation = df_equation\n",
        "\n",
        "    def set_color_shapes(self):\n",
        "        df, equals, r1, plus1, r2, plus2, s = self.df_equation\n",
        "\n",
        "        tups = [\n",
        "            (self.right_rect, self.bottom_rect, r1, r2),\n",
        "            (self.corner_square, s)\n",
        "        ]\n",
        "        for tup in tups:\n",
        "            self.play(\n",
        "                *it.chain(*[\n",
        "                    [m.scale, 1.2, m.set_color, RED]\n",
        "                    for m in tup\n",
        "                ]), \n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def examine_thin_rectangles(self):\n",
        "        df, equals, r1, plus1, r2, plus2, s = self.df_equation\n",
        "\n",
        "        rects = VGroup(r1, r2)\n",
        "        thin_rect_brace = Brace(rects, DOWN)\n",
        "        text = thin_rect_brace.get_text(\"$2x \\\\, dx$\")\n",
        "        VGroup(*text[-2:]).set_color(self.dx_color)\n",
        "        text.save_state()\n",
        "        alt_text = thin_rect_brace.get_text(\"$2(3)(0.01)$\")\n",
        "        alt_text[2].set_color(self.three_color)\n",
        "        VGroup(*alt_text[-5:-1]).set_color(self.dx_color)\n",
        "\n",
        "        example_value = OldTex(\"=0.06\")\n",
        "        example_value.next_to(alt_text, DOWN)\n",
        "\n",
        "        self.play(GrowFromCenter(thin_rect_brace))\n",
        "        self.play(\n",
        "            Write(text),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        xs = VGroup(*[\n",
        "            brace[-1] \n",
        "            for brace in self.side_braces\n",
        "        ])\n",
        "        dxs = VGroup(*[\n",
        "            brace[-1]\n",
        "            for brace in self.little_braces\n",
        "        ])\n",
        "        for group, tex, color in (xs, \"3\", self.three_color), (dxs, \"0.01\", self.dx_color):\n",
        "            group.save_state()            \n",
        "            group.generate_target()            \n",
        "            for submob in group.target:\n",
        "                number = OldTex(tex)\n",
        "                number.set_color(color)\n",
        "                number.move_to(submob, LEFT)\n",
        "                Transform(submob, number).update(1)\n",
        "        self.play(MoveToTarget(xs))\n",
        "        self.play(MoveToTarget(dxs))\n",
        "        self.wait()\n",
        "        self.play(Transform(text, alt_text))\n",
        "        self.wait()\n",
        "        self.play(Write(example_value))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(example_value),\n",
        "            *[\n",
        "                mob.restore\n",
        "                for mob in (xs, dxs, text)\n",
        "            ]\n",
        "        )\n",
        "        self.remove(text)\n",
        "        text.restore()\n",
        "        self.add(text)\n",
        "\n",
        "        self.wait()\n",
        "        self.dxs = dxs\n",
        "        self.thin_rect_brace = thin_rect_brace\n",
        "        self.thin_rect_area = text        \n",
        "\n",
        "    def examine_tiny_square(self):\n",
        "        text = OldTex(\"dx^2\")\n",
        "        VGroup(*text[:2]).set_color(self.dx_color)\n",
        "        text.next_to(self.df_equation[-1], UP)\n",
        "        text.save_state()\n",
        "        alt_text = OldTexText(\"0.0001\")\n",
        "        alt_text.move_to(text)\n",
        "\n",
        "        self.play(Write(text))\n",
        "        self.change_mode(\"surprised\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(self.dxs),\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        for submob in self.dxs.target:\n",
        "            number = OldTex(\"0.01\")\n",
        "            number.set_color(self.dx_color)\n",
        "            number.move_to(submob, LEFT)\n",
        "            Transform(submob, number).update(1)\n",
        "        self.play(MoveToTarget(self.dxs))\n",
        "        self.play(\n",
        "            Transform(text, alt_text),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            mob.restore\n",
        "            for mob in (self.dxs, text)\n",
        "        ] + [\n",
        "            self.pi_creature.change_mode, \"erm\"\n",
        "        ])\n",
        "        self.dx_squared = text\n",
        "\n",
        "    def show_smaller_dx(self):\n",
        "        self.mobjects_at_start_of_show_smaller_dx = [\n",
        "            mob.copy() for mob in self.get_mobjects()\n",
        "        ]\n",
        "        if self.is_recursing_on_dx:\n",
        "            return\n",
        "\n",
        "        alt_scene = self.__class__(\n",
        "            skip_animations = True,\n",
        "            dx = self.alt_dx,\n",
        "            is_recursing_on_dx = True\n",
        "        )\n",
        "        for mob in self.get_mobjects():\n",
        "            mob.save_state()\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in zip(\n",
        "                self.get_mobjects(),\n",
        "                alt_scene.mobjects_at_start_of_show_smaller_dx,\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            mob.restore\n",
        "            for mob in self.get_mobjects()\n",
        "        ])\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait()\n",
        "\n",
        "    def rule_of_thumb(self):\n",
        "        circle = Circle(color = RED)\n",
        "        dx_squared_group = VGroup(self.dx_squared, self.df_equation[-1])\n",
        "        circle.replace(dx_squared_group, stretch = True)\n",
        "        dx_squared_group.add(self.df_equation[-2])\n",
        "        circle.scale(1.5)\n",
        "        safe_to_ignore = OldTexText(\"Safe to ignore\")\n",
        "        safe_to_ignore.next_to(circle, DOWN, aligned_edge = LEFT)\n",
        "        safe_to_ignore.set_color(circle.get_color())\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(\n",
        "            Write(safe_to_ignore, run_time = 2),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(circle),\n",
        "            FadeOut(safe_to_ignore),\n",
        "            dx_squared_group.fade, 0.5,\n",
        "            dx_squared_group.to_corner, UP+RIGHT,\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_out_derivative(self):\n",
        "        df, equals, r1, plus1, r2, plus2, s = self.df_equation\n",
        "        frac_line = OldTex(\"-\")\n",
        "        frac_line.stretch_to_fit_width(df.get_width())\n",
        "        frac_line.move_to(df)\n",
        "        dx = VGroup(*self.thin_rect_area[-2:]) \n",
        "        x = self.thin_rect_area[1]\n",
        "\n",
        "        self.play(\n",
        "            Transform(r1, self.right_rect),\n",
        "            Transform(r2, self.bottom_rect),\n",
        "            FadeOut(plus1),\n",
        "            FadeOut(self.thin_rect_brace)\n",
        "        )\n",
        "        self.play(\n",
        "            self.thin_rect_area.next_to, VGroup(df, equals),\n",
        "            RIGHT, MED_SMALL_BUFF, UP,\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ApplyMethod(df.next_to, frac_line, UP, SMALL_BUFF),\n",
        "            ApplyMethod(dx.next_to, frac_line, DOWN, SMALL_BUFF),\n",
        "            Write(frac_line),            \n",
        "            path_arc = -np.pi\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        brace_xs = [\n",
        "            brace[-1]\n",
        "            for brace in self.side_braces\n",
        "        ]\n",
        "        xs = list(brace_xs) + [x]\n",
        "        for x_mob in xs:\n",
        "            number = OldTex(\"(%d)\"%self.square_width)\n",
        "            number.move_to(x_mob, LEFT)\n",
        "            number.shift(\n",
        "                (x_mob.get_bottom()[1] - number[1].get_bottom()[1])*UP\n",
        "            )\n",
        "            x_mob.save_state()\n",
        "            x_mob.target = number\n",
        "        self.play(*list(map(MoveToTarget, xs)))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Recursively transform to what would have happened\n",
        "        #with a wider square width\n",
        "        self.mobjects_at_end_of_write_out_derivative = self.get_mobjects()\n",
        "        if self.is_recursing_on_square_width or self.is_recursing_on_dx:\n",
        "            return\n",
        "        alt_scene = self.__class__(\n",
        "            skip_animations = True,\n",
        "            square_width = self.alt_square_width,\n",
        "            is_recursing_on_square_width = True,\n",
        "        )\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in zip(\n",
        "                self.mobjects_at_end_of_write_out_derivative,\n",
        "                alt_scene.mobjects_at_end_of_write_out_derivative\n",
        "            )\n",
        "        ])\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class ChangeInAreaOverChangeInX(Scene):\n",
        "    def construct(self):\n",
        "        fractions = []\n",
        "        for pair in (\"Change in area\", \"Change in $x$\"), (\"$d(x^2)$\", \"$dx$\"):\n",
        "            top, bottom = list(map(TexText, pair))\n",
        "            top.set_color(YELLOW)\n",
        "            bottom.set_color(BLUE_B)\n",
        "            frac_line = OldTex(\"-\")\n",
        "            frac_line.stretch_to_fit_width(top.get_width())\n",
        "            top.next_to(frac_line, UP, SMALL_BUFF)\n",
        "            bottom.next_to(frac_line, DOWN, SMALL_BUFF)\n",
        "            fractions.append(VGroup(\n",
        "                top, frac_line, bottom\n",
        "            ))\n",
        "        words, symbols = fractions\n",
        "\n",
        "        self.play(Write(words[0], run_time = 1))\n",
        "        self.play(*list(map(Write, words[1:])), run_time = 1)\n",
        "        self.wait()\n",
        "        self.play(Transform(words, symbols))\n",
        "        self.wait()\n",
        "\n",
        "class NudgeSideLengthOfCube(Scene):\n",
        "    CONFIG = {\n",
        "        \"x_color\" : BLUE,\n",
        "        \"dx_color\" : GREEN,\n",
        "        \"df_color\" : YELLOW,\n",
        "        \"use_morty\" : False,\n",
        "        \"x\" : 3,\n",
        "        \"dx\" : 0.2,\n",
        "        \"alt_dx\" : 0.02,\n",
        "        \"offset_vect\" : OUT,\n",
        "        \"pose_angle\" : np.pi/12,\n",
        "        \"pose_axis\" : UP+RIGHT,\n",
        "        \"small_piece_scaling_factor\" : 0.7,\n",
        "        \"allow_recursion\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.states = dict()\n",
        "        if self.allow_recursion:\n",
        "            self.alt_scene = self.__class__(\n",
        "                skip_animations = True,\n",
        "                allow_recursion = False,\n",
        "                dx = self.alt_dx,\n",
        "            )\n",
        "\n",
        "        self.add_title()\n",
        "        self.introduce_cube()\n",
        "        self.write_df_equation()\n",
        "        self.write_derivative()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(x) = x^3\")\n",
        "        title.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        title.to_edge(UP)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "    def introduce_cube(self):\n",
        "        cube = self.get_cube()\n",
        "        cube.to_edge(LEFT, buff = 2*LARGE_BUFF)\n",
        "        cube.shift(DOWN)\n",
        "\n",
        "        dv_pieces = self.get_dv_pices(cube)\n",
        "        original_dx = self.dx\n",
        "        self.dx = 0\n",
        "        alt_dv_pieces = self.get_dv_pices(cube)\n",
        "        self.dx = original_dx\n",
        "        alt_dv_pieces.set_fill(opacity = 0)\n",
        "\n",
        "        x_brace = Brace(cube, LEFT, buff = SMALL_BUFF)\n",
        "        dx_brace = Brace(\n",
        "            dv_pieces[1], LEFT, buff = SMALL_BUFF,\n",
        "        )\n",
        "        dx_brace.stretch_in_place(1.5, 1)\n",
        "        for brace, tex in (x_brace, \"x\"), (dx_brace, \"dx\"):\n",
        "            brace.scale(0.95)\n",
        "            brace.rotate(-np.pi/96)\n",
        "            brace.shift(0.3*(UP+LEFT))\n",
        "            brace.add(brace.get_text(\"$%s$\"%tex))\n",
        "\n",
        "\n",
        "        cube_group = VGroup(cube, dv_pieces, alt_dv_pieces)\n",
        "        self.pose_3d_mobject(cube_group)\n",
        "\n",
        "        self.play(DrawBorderThenFill(cube))\n",
        "        self.play(GrowFromCenter(x_brace))\n",
        "        self.wait()\n",
        "        self.play(Transform(alt_dv_pieces, dv_pieces))\n",
        "        self.remove(alt_dv_pieces)\n",
        "        self.add(dv_pieces)\n",
        "        self.play(GrowFromCenter(dx_brace))\n",
        "        self.wait()\n",
        "        for piece in dv_pieces:\n",
        "            piece.on_cube_state = piece.copy()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                piece.shift, \n",
        "                0.5*(piece.get_center()-cube.get_center())\n",
        "            )\n",
        "            for piece in dv_pieces\n",
        "        ]+[\n",
        "            ApplyMethod(dx_brace.shift, 0.7*UP)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.cube = cube\n",
        "        self.dx_brace = dx_brace\n",
        "        self.faces, self.bars, self.corner_cube = [\n",
        "            VGroup(*[\n",
        "                piece \n",
        "                for piece in dv_pieces\n",
        "                if piece.type == target_type\n",
        "            ])\n",
        "            for target_type in (\"face\", \"bar\", \"corner_cube\")\n",
        "        ]\n",
        "\n",
        "    def write_df_equation(self):\n",
        "        df_equation = VGroup(\n",
        "            OldTex(\"df\"),\n",
        "            OldTex(\"=\"),\n",
        "            self.organize_faces(self.faces.copy()),\n",
        "            OldTex(\"+\"),\n",
        "            self.organize_bars(self.bars.copy()),\n",
        "            OldTex(\"+\"),\n",
        "            self.corner_cube.copy()\n",
        "        )\n",
        "        df, equals, faces, plus1, bars, plus2, corner_cube = df_equation\n",
        "        df.set_color(self.df_color)\n",
        "        for three_d_mob in faces, bars, corner_cube:\n",
        "            three_d_mob.scale(self.small_piece_scaling_factor)\n",
        "            # self.pose_3d_mobject(three_d_mob)\n",
        "        faces.set_fill(opacity = 0.3)\n",
        "        df_equation.arrange(RIGHT)\n",
        "        df_equation.next_to(ORIGIN, RIGHT)\n",
        "        df_equation.to_edge(UP)\n",
        "\n",
        "        faces_brace = Brace(faces, DOWN)\n",
        "        derivative = faces_brace.get_tex(\"3x^2\", \"\\\\, dx\")\n",
        "        extras_brace = Brace(VGroup(bars, corner_cube), DOWN)\n",
        "        ignore_text = extras_brace.get_text(\n",
        "            \"Multiple \\\\\\\\ of $dx^2$\"\n",
        "        )\n",
        "        ignore_text.scale(0.7)\n",
        "        x_squared_dx = OldTex(\"x^2\", \"\\\\, dx\")\n",
        "\n",
        "\n",
        "        self.play(*list(map(Write, [df, equals])))\n",
        "        self.grab_pieces(self.faces, faces)\n",
        "        self.wait()\n",
        "        self.shrink_dx(\"Faces are introduced\")\n",
        "        face = self.faces[0]\n",
        "        face.save_state()\n",
        "        self.play(face.shift, FRAME_X_RADIUS*RIGHT)\n",
        "        x_squared_dx.next_to(face, LEFT)\n",
        "        self.play(Write(x_squared_dx, run_time = 1))\n",
        "        self.wait()\n",
        "        for submob, sides in zip(x_squared_dx, [face[0], VGroup(*face[1:])]):\n",
        "            self.play(\n",
        "                submob.set_color, RED,\n",
        "                sides.set_color, RED,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            face.restore,\n",
        "            Transform(\n",
        "                x_squared_dx, derivative,\n",
        "                replace_mobject_with_target_in_scene = True\n",
        "            ),\n",
        "            GrowFromCenter(faces_brace)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.grab_pieces(self.bars, bars, plus1)\n",
        "        self.grab_pieces(self.corner_cube, corner_cube, plus2)\n",
        "        self.play(\n",
        "            GrowFromCenter(extras_brace),\n",
        "            Write(ignore_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 0.7)\n",
        "            for mob in [\n",
        "                plus1, bars, plus2, corner_cube, \n",
        "                extras_brace, ignore_text\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.df_equation = df_equation\n",
        "        self.derivative = derivative\n",
        "\n",
        "    def write_derivative(self):\n",
        "        df, equals, faces, plus1, bars, plus2, corner_cube = self.df_equation\n",
        "        df = df.copy()\n",
        "        equals = equals.copy()        \n",
        "        df_equals = VGroup(df, equals)        \n",
        "\n",
        "        derivative = self.derivative.copy()\n",
        "        dx = derivative[1]\n",
        "\n",
        "        extra_stuff = OldTex(\"+(\\\\dots)\", \"dx^2\")\n",
        "        dx_squared = extra_stuff[1]\n",
        "\n",
        "        derivative.generate_target()\n",
        "        derivative.target.shift(2*DOWN)\n",
        "        extra_stuff.next_to(derivative.target)\n",
        "        self.play(\n",
        "            MoveToTarget(derivative),\n",
        "            df_equals.next_to, derivative.target[0], LEFT,\n",
        "            df_equals.shift, 0.07*DOWN\n",
        "        )\n",
        "        self.play(Write(extra_stuff))\n",
        "        self.wait()\n",
        "\n",
        "        frac_line = OldTex(\"-\")\n",
        "        frac_line.replace(df)\n",
        "        extra_stuff.generate_target()\n",
        "        extra_stuff.target.next_to(derivative[0])\n",
        "        frac_line2 = OldTex(\"-\")\n",
        "        frac_line2.stretch_to_fit_width(\n",
        "            extra_stuff.target[1].get_width()\n",
        "        )\n",
        "        frac_line2.move_to(extra_stuff.target[1])\n",
        "        extra_stuff.target[1].next_to(frac_line2, UP, buff = SMALL_BUFF)\n",
        "        dx_below_dx_squared = OldTex(\"dx\")\n",
        "        dx_below_dx_squared.next_to(frac_line2, DOWN, buff = SMALL_BUFF)\n",
        "        self.play(\n",
        "            FadeIn(frac_line),\n",
        "            FadeIn(frac_line2),\n",
        "            df.next_to, frac_line, UP, SMALL_BUFF,\n",
        "            dx.next_to, frac_line, DOWN, SMALL_BUFF,\n",
        "            MoveToTarget(extra_stuff),\n",
        "            Write(dx_below_dx_squared),\n",
        "            path_arc = -np.pi\n",
        "        )\n",
        "        self.wait()\n",
        "        inner_dx = VGroup(*dx_squared[:-1])\n",
        "        self.play(\n",
        "            FadeOut(frac_line2),\n",
        "            FadeOut(dx_below_dx_squared),\n",
        "            dx_squared[-1].set_color, BLACK,\n",
        "            inner_dx.next_to, extra_stuff[0], RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "        self.shrink_dx(\"Derivative is written\", restore = False)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 0.7)\n",
        "            for mob in (extra_stuff, inner_dx)\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        anims = []\n",
        "        for mob in list(self.faces)+list(self.bars)+list(self.corner_cube):\n",
        "            vect = mob.get_center()-self.cube.get_center()\n",
        "            anims += [\n",
        "                mob.shift, -(1./3)*vect\n",
        "            ]\n",
        "        anims += self.dx_brace.shift, 0.7*DOWN\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def grab_pieces(self, start_pieces, end_pices, to_write = None):\n",
        "        for piece in start_pieces:\n",
        "            piece.generate_target()\n",
        "            piece.target.rotate(\n",
        "                np.pi/12, piece.get_center()-self.cube.get_center()\n",
        "            )\n",
        "            piece.target.set_color(RED)\n",
        "        self.play(*list(map(MoveToTarget, start_pieces)), rate_func = wiggle)\n",
        "        self.wait()\n",
        "        added_anims = []\n",
        "        if to_write is not None:\n",
        "            added_anims.append(Write(to_write))\n",
        "        self.play(\n",
        "            Transform(start_pieces.copy(), end_pices),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def shrink_dx(self, state_name, restore = True):\n",
        "        mobjects = self.get_mobjects()\n",
        "        mobjects_with_points = [\n",
        "            m for m in mobjects\n",
        "            if m.get_num_points() > 0\n",
        "        ]\n",
        "        #Alt_scene will reach this point, and save copy of self\n",
        "        #in states dict\n",
        "        self.states[state_name] = [\n",
        "            mob.copy() for mob in mobjects_with_points\n",
        "        ] \n",
        "        if not self.allow_recursion:\n",
        "            return\n",
        "        if restore:\n",
        "            movers = self.states[state_name]\n",
        "            for mob in movers:\n",
        "                mob.save_state()\n",
        "            self.remove(*mobjects)\n",
        "        else:\n",
        "            movers = mobjects_with_points\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in zip(\n",
        "                movers,\n",
        "                self.alt_scene.states[state_name]\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        if restore:\n",
        "            self.play(*[m.restore for m in movers])\n",
        "            self.remove(*movers)\n",
        "            self.mobjects = mobjects\n",
        "\n",
        "    def get_cube(self):\n",
        "        cube = self.get_prism(self.x, self.x, self.x)\n",
        "        cube.set_fill(color = BLUE, opacity = 0.3)\n",
        "        cube.set_stroke(color = WHITE, width = 1)\n",
        "        return cube\n",
        "\n",
        "    def get_dv_pices(self, cube):\n",
        "        pieces = VGroup()\n",
        "        for vect in it.product([0, 1], [0, 1], [0, 1]):\n",
        "            if np.all(vect == ORIGIN):\n",
        "                continue\n",
        "            args = [\n",
        "                self.x if bit is 0 else self.dx\n",
        "                for bit in vect\n",
        "            ]\n",
        "            piece = self.get_prism(*args)\n",
        "            piece.next_to(cube, np.array(vect), buff = 0)\n",
        "            pieces.add(piece)\n",
        "            if sum(vect) == 1:\n",
        "                piece.type = \"face\"\n",
        "            elif sum(vect) == 2:\n",
        "                piece.type = \"bar\"\n",
        "            else:\n",
        "                piece.type = \"corner_cube\"\n",
        "\n",
        "        return pieces\n",
        "\n",
        "    def organize_faces(self, faces):\n",
        "        self.unpose_3d_mobject(faces)\n",
        "        for face in faces:\n",
        "            dimensions = [\n",
        "                face.length_over_dim(dim)\n",
        "                for dim in range(3)\n",
        "            ]\n",
        "            thin_dim = np.argmin(dimensions)\n",
        "            if thin_dim == 0:\n",
        "                face.rotate(np.pi/2, DOWN)\n",
        "            elif thin_dim == 1:\n",
        "                face.rotate(np.pi/2, RIGHT)\n",
        "        faces.arrange(OUT, buff = LARGE_BUFF)\n",
        "        self.pose_3d_mobject(faces)\n",
        "        return faces\n",
        "\n",
        "    def organize_bars(self, bars):\n",
        "        self.unpose_3d_mobject(bars)\n",
        "        for bar in bars:\n",
        "            dimensions = [\n",
        "                bar.length_over_dim(dim)\n",
        "                for dim in range(3)\n",
        "            ]\n",
        "            thick_dim = np.argmax(dimensions)\n",
        "            if thick_dim == 0:\n",
        "                bar.rotate(np.pi/2, OUT)\n",
        "            elif thick_dim == 2:\n",
        "                bar.rotate(np.pi/2, LEFT)\n",
        "        bars.arrange(OUT, buff = LARGE_BUFF)\n",
        "        self.pose_3d_mobject(bars)\n",
        "        return bars\n",
        "\n",
        "    def get_corner_cube(self):\n",
        "        return self.get_prism(self.dx, self.dx,  self.dx)\n",
        "\n",
        "    def get_prism(self, width, height, depth):\n",
        "        color_kwargs = {\n",
        "            \"fill_color\" : YELLOW,\n",
        "            \"fill_opacity\" : 0.4,\n",
        "            \"stroke_color\" : WHITE,            \n",
        "            \"stroke_width\" : 0.1,\n",
        "        }\n",
        "        front = Rectangle(\n",
        "            width = width,\n",
        "            height = height,\n",
        "            **color_kwargs\n",
        "        )\n",
        "        face = VGroup(front)\n",
        "        for vect in LEFT, RIGHT, UP, DOWN:\n",
        "            if vect is LEFT or vect is RIGHT:\n",
        "                side = Rectangle(\n",
        "                    height = height, \n",
        "                    width = depth, \n",
        "                    **color_kwargs\n",
        "                )\n",
        "            else:\n",
        "                side = Rectangle(\n",
        "                    height = depth,\n",
        "                    width = width, \n",
        "                    **color_kwargs\n",
        "                )\n",
        "            side.next_to(front, vect, buff = 0)\n",
        "            side.rotate(\n",
        "                np.pi/2, rotate_vector(vect, -np.pi/2),\n",
        "                about_point = front.get_edge_center(vect)\n",
        "            )\n",
        "            face.add(side)\n",
        "        return face\n",
        "\n",
        "    def pose_3d_mobject(self, mobject):\n",
        "        mobject.rotate(self.pose_angle, self.pose_axis)\n",
        "        return mobject\n",
        "\n",
        "    def unpose_3d_mobject(self, mobject):\n",
        "        mobject.rotate(-self.pose_angle, self.pose_axis)\n",
        "        return mobject\n",
        "\n",
        "class ShowCubeDVIn3D(Scene):\n",
        "    def construct(self):\n",
        "        raise Exception(\"This scene is only here for the stage_scenes script.\")\n",
        "\n",
        "class GraphOfXCubed(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -6,\n",
        "        \"x_max\" : 6,\n",
        "        \"x_axis_width\" : FRAME_WIDTH,\n",
        "        \"x_labeled_nums\" : list(range(-6, 7)),\n",
        "        \"y_min\" : -35,\n",
        "        \"y_max\" : 35,\n",
        "        \"y_axis_height\" : FRAME_HEIGHT,\n",
        "        \"y_tick_frequency\" : 5,\n",
        "        \"y_labeled_nums\" : list(range(-30, 40, 10)),\n",
        "        \"graph_origin\" : ORIGIN,\n",
        "        \"dx\" : 0.2,\n",
        "        \"deriv_x_min\" : -3,\n",
        "        \"deriv_x_max\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        graph = self.get_graph(lambda x : x**3)\n",
        "        label = self.get_graph_label(\n",
        "            graph, \"f(x) = x^3\",\n",
        "            direction = LEFT,\n",
        "        )\n",
        "\n",
        "\n",
        "        deriv_graph, full_deriv_graph = [\n",
        "            self.get_derivative_graph(\n",
        "                graph,\n",
        "                color = DERIVATIVE_COLOR,\n",
        "                x_min = low_x,\n",
        "                x_max = high_x,\n",
        "            )\n",
        "            for low_x, high_x in [\n",
        "                (self.deriv_x_min, self.deriv_x_max),\n",
        "                (self.x_min, self.x_max),\n",
        "            ]\n",
        "        ]\n",
        "        deriv_label = self.get_graph_label(\n",
        "            deriv_graph,\n",
        "            \"\\\\frac{df}{dx}(x) = 3x^2\",\n",
        "            x_val = -3, \n",
        "            direction = LEFT\n",
        "        )\n",
        "        deriv_label.shift(0.5*DOWN)\n",
        "\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            self.deriv_x_min, graph, \n",
        "            dx = self.dx,\n",
        "            dx_line_color = WHITE,\n",
        "            df_line_color = WHITE,\n",
        "            secant_line_color = YELLOW,\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(label, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(Write(deriv_label, run_time = 1))\n",
        "        self.play(ShowCreation(ss_group, lag_ratio = 0))\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_x = self.deriv_x_max,\n",
        "            run_time = 10,\n",
        "            added_anims = [\n",
        "                ShowCreation(deriv_graph, run_time = 10)\n",
        "            ]\n",
        "        )\n",
        "        self.play(FadeIn(full_deriv_graph))\n",
        "        self.wait()\n",
        "        for x_val in -2, -self.dx/2, 2:\n",
        "            self.animate_secant_slope_group_change(\n",
        "                ss_group,\n",
        "                target_x = x_val,\n",
        "                run_time = 2\n",
        "            )\n",
        "            if x_val != -self.dx/2:\n",
        "                v_line = self.get_vertical_line_to_graph(\n",
        "                    x_val, deriv_graph,\n",
        "                    line_class = DashedLine\n",
        "                )\n",
        "                self.play(ShowCreation(v_line))\n",
        "                self.play(FadeOut(v_line))\n",
        "\n",
        "class PatternForPowerRule(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"num_exponents\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_pattern()\n",
        "        self.generalize_pattern()\n",
        "        self.show_hopping()\n",
        "\n",
        "    def introduce_pattern(self):\n",
        "        exp_range = list(range(1, 1+self.num_exponents))\n",
        "        colors = color_gradient([BLUE_D, YELLOW], self.num_exponents)\n",
        "        derivatives = VGroup()\n",
        "        for exponent, color in zip(exp_range, colors):\n",
        "            derivative = OldTex(\n",
        "                \"\\\\frac{d(x^%d)}{dx} = \"%exponent,\n",
        "                \"%d x^{%d}\"%(exponent, exponent-1)\n",
        "            )\n",
        "            VGroup(*derivative[0][2:4]).set_color(color)\n",
        "            derivatives.add(derivative)\n",
        "        derivatives.arrange(\n",
        "            DOWN, aligned_edge = LEFT,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        derivatives.set_height(FRAME_HEIGHT-1)\n",
        "        derivatives.to_edge(LEFT)\n",
        "\n",
        "        self.play(FadeIn(derivatives[0]))\n",
        "        for d1, d2 in zip(derivatives, derivatives[1:]):\n",
        "            self.play(Transform(\n",
        "                d1.copy(), d2,\n",
        "                replace_mobject_with_target_in_scene = True  \n",
        "            ))\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        for derivative in derivatives[-2:]:\n",
        "            derivative.save_state()\n",
        "            self.play(\n",
        "                derivative.scale, 2,\n",
        "                derivative.next_to, derivative,\n",
        "                RIGHT, SMALL_BUFF, DOWN,\n",
        "            )\n",
        "            self.wait(2)\n",
        "            self.play(derivative.restore)\n",
        "            self.remove(derivative)\n",
        "            derivative.restore()\n",
        "            self.add(derivative)\n",
        "\n",
        "        self.derivatives = derivatives\n",
        "        self.colors = colors\n",
        "\n",
        "    def generalize_pattern(self):\n",
        "        derivatives = self.derivatives\n",
        "\n",
        "\n",
        "        power_rule = OldTex(\n",
        "            \"\\\\frac{d (x^n)}{dx} = \",\n",
        "            \"nx^{n-1}\"\n",
        "        )\n",
        "        title = OldTexText(\"``Power rule''\")        \n",
        "        title.next_to(power_rule, UP, MED_LARGE_BUFF)\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                deriv.get_right(), power_rule.get_left(),\n",
        "                buff = MED_SMALL_BUFF,\n",
        "                color = deriv[0][2].get_color()\n",
        "            )\n",
        "            for deriv in derivatives\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                VGroup(*[d[0].copy() for d in derivatives]),\n",
        "                VGroup(power_rule[0]),\n",
        "                replace_mobject_with_target_in_scene = True\n",
        "            ),\n",
        "            ShowCreation(lines),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(power_rule[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_hopping(self):\n",
        "        exp_range = list(range(2, 2+self.num_exponents-1))\n",
        "        self.change_mode(\"tired\")\n",
        "        for exp, color in zip(exp_range, self.colors[1:]):\n",
        "            form = OldTex(\n",
        "                \"x^\",\n",
        "                str(exp),\n",
        "                \"\\\\rightarrow\",\n",
        "                str(exp),\n",
        "                \"x^\",\n",
        "                str(exp-1)\n",
        "            )\n",
        "            form.set_color(color)\n",
        "            form.to_corner(UP+RIGHT, buff = LARGE_BUFF)\n",
        "            lhs = VGroup(*form[:2])\n",
        "            lhs_copy = lhs.copy()\n",
        "            rhs = VGroup(*form[-2:])\n",
        "            arrow = form[2]\n",
        "\n",
        "            self.play(Write(lhs))\n",
        "            self.play(\n",
        "                lhs_copy.move_to, rhs, DOWN+LEFT,\n",
        "                Write(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    lhs_copy[1].replace, form[3],\n",
        "                    path_arc = np.pi,\n",
        "                    rate_func = running_start,\n",
        "                ),\n",
        "                FadeIn(\n",
        "                    form[5],\n",
        "                    rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "                )   \n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                self.pi_creature.change_mode, \"hesitant\",\n",
        "                self.pi_creature.look_at, lhs_copy\n",
        "            )\n",
        "            self.play(*list(map(FadeOut, [form, lhs_copy])))\n",
        "\n",
        "class PowerRuleAlgebra(Scene):\n",
        "    CONFIG = {\n",
        "        \"dx_color\" : YELLOW,\n",
        "        \"x_color\" : BLUE,\n",
        "    }\n",
        "    def construct(self):\n",
        "        x_to_n = OldTex(\"x^n\")\n",
        "        down_arrow = Arrow(UP, DOWN, buff = MED_LARGE_BUFF)\n",
        "        paren_strings = [\"(\", \"x\", \"+\", \"dx\", \")\"]\n",
        "        x_dx_to_n = OldTex(*paren_strings +[\"^n\"])\n",
        "        equals = OldTex(\"=\")\n",
        "        equals2 = OldTex(\"=\")\n",
        "        full_product = OldTex(\n",
        "            *paren_strings*3+[\"\\\\cdots\"]+paren_strings\n",
        "        )\n",
        "\n",
        "        x_to_n.set_color(self.x_color)\n",
        "        for mob in x_dx_to_n, full_product:\n",
        "            mob.set_color_by_tex(\"dx\", self.dx_color)\n",
        "            mob.set_color_by_tex(\"x\", self.x_color)\n",
        "\n",
        "        nudge_group = VGroup(x_to_n, down_arrow, x_dx_to_n)\n",
        "        nudge_group.arrange(DOWN)\n",
        "        nudge_group.to_corner(UP+LEFT)\n",
        "        down_arrow.next_to(x_to_n[0], DOWN)\n",
        "        equals.next_to(x_dx_to_n)\n",
        "        full_product.next_to(equals)\n",
        "        equals2.next_to(equals, DOWN, 1.5*LARGE_BUFF)\n",
        "\n",
        "        nudge_brace = Brace(x_dx_to_n, DOWN)\n",
        "        nudged_output = nudge_brace.get_text(\"Nudged \\\\\\\\ output\")\n",
        "        product_brace = Brace(full_product, UP)\n",
        "        product_brace.add(product_brace.get_text(\"$n$ times\"))\n",
        "\n",
        "        self.add(x_to_n)\n",
        "        self.play(ShowCreation(down_arrow))\n",
        "        self.play(\n",
        "            FadeIn(x_dx_to_n),\n",
        "            GrowFromCenter(nudge_brace),\n",
        "            GrowFromCenter(nudged_output)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(VGroup(equals, full_product)),\n",
        "            GrowFromCenter(\n",
        "                product_brace,\n",
        "                rate_func = squish_rate_func(smooth, 0.6, 1)\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.workout_product(equals2, full_product)\n",
        "\n",
        "    def workout_product(self, equals, full_product):\n",
        "        product_part_tex_pairs = list(zip(full_product, full_product.expression_parts))\n",
        "        xs, dxs = [\n",
        "            VGroup(*[\n",
        "                submob\n",
        "                for submob, tex in product_part_tex_pairs\n",
        "                if tex == target_tex\n",
        "            ])\n",
        "            for target_tex in (\"x\", \"dx\")\n",
        "        ]\n",
        "\n",
        "        x_to_n = OldTex(\"x^n\")\n",
        "        extra_stuff = OldTex(\"+(\\\\text{Multiple of }\\\\, dx^2)\")\n",
        "        # extra_stuff.scale(0.8)\n",
        "        VGroup(*extra_stuff[-4:-2]).set_color(self.dx_color)\n",
        "\n",
        "        x_to_n.next_to(equals, RIGHT, align_using_submobjects = True)\n",
        "        x_to_n.set_color(self.x_color)\n",
        "\n",
        "        xs_copy = xs.copy()\n",
        "        full_product.save_state()\n",
        "        self.play(full_product.set_color, WHITE)\n",
        "        self.play(xs_copy.set_color, self.x_color)\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Transform(xs_copy, x_to_n)\n",
        "        )\n",
        "        self.wait()\n",
        "        brace, derivative_term = self.pull_out_linear_terms(\n",
        "            x_to_n, product_part_tex_pairs, xs, dxs\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        circle = Circle(color = DERIVATIVE_COLOR)\n",
        "        circle.replace(derivative_term, stretch = True)\n",
        "        circle.scale(1.4)\n",
        "        circle.rotate(\n",
        "            Line(\n",
        "                derivative_term.get_corner(DOWN+LEFT),\n",
        "                derivative_term.get_corner(UP+RIGHT),\n",
        "            ).get_angle()\n",
        "        )\n",
        "\n",
        "        extra_stuff.next_to(brace, aligned_edge = UP)\n",
        "\n",
        "        self.play(Write(extra_stuff), full_product.restore)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "\n",
        "    def pull_out_linear_terms(self, x_to_n, product_part_tex_pairs, xs, dxs):\n",
        "        last_group = None\n",
        "        all_linear_terms = VGroup()\n",
        "        for dx_index, dx in enumerate(dxs):\n",
        "            if dx is dxs[-1]:\n",
        "                v_dots = OldTex(\"\\\\vdots\")\n",
        "                v_dots.next_to(last_group[0], DOWN)\n",
        "                h_dots_list = [\n",
        "                    submob\n",
        "                    for submob, tex in product_part_tex_pairs\n",
        "                    if tex == \"\\\\cdots\"\n",
        "                ]\n",
        "                h_dots_copy = h_dots_list[0].copy()\n",
        "                self.play(ReplacementTransform(\n",
        "                    h_dots_copy, v_dots,\n",
        "                ))\n",
        "                last_group.add(v_dots)\n",
        "                all_linear_terms.add(v_dots)\n",
        "\n",
        "            dx_copy = dx.copy()\n",
        "            xs_copy = xs.copy()\n",
        "            xs_copy.remove(xs_copy[dx_index])\n",
        "            self.play(\n",
        "                dx_copy.set_color, self.dx_color,\n",
        "                xs_copy.set_color, self.x_color,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "            )\n",
        "\n",
        "            dx_copy.generate_target()\n",
        "            xs_copy.generate_target()\n",
        "            target_list = [dx_copy.target] + list(xs_copy.target)\n",
        "            target_list.sort(\n",
        "                key=lambda m: m.get_center()[0]\n",
        "            )\n",
        "            dots = OldTex(\"+\", \".\", \".\", \"\\\\dots\")\n",
        "            for dot_index, dot in enumerate(dots):\n",
        "                target_list.insert(2*dot_index, dot)\n",
        "            group = VGroup(*target_list)\n",
        "            group.arrange(RIGHT, SMALL_BUFF)\n",
        "            if last_group is None:\n",
        "                group.next_to(x_to_n, RIGHT)\n",
        "            else:\n",
        "                group.next_to(last_group, DOWN, aligned_edge = LEFT)\n",
        "            last_group = group\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(dx_copy),\n",
        "                MoveToTarget(xs_copy),\n",
        "                Write(dots)\n",
        "            )\n",
        "            all_linear_terms.add(dx_copy, xs_copy, dots)\n",
        "\n",
        "        all_linear_terms.generate_target()\n",
        "        all_linear_terms.target.scale(0.7)\n",
        "        brace = Brace(all_linear_terms.target, UP)\n",
        "        compact = OldTex(\"+\\\\,\", \"n\", \"x^{n-1}\", \"\\\\,dx\")\n",
        "        compact.set_color_by_tex(\"x^{n-1}\", self.x_color)\n",
        "        compact.set_color_by_tex(\"\\\\,dx\", self.dx_color)\n",
        "        compact.next_to(brace, UP)\n",
        "        brace.add(compact)\n",
        "        derivative_term = VGroup(*compact[1:3])\n",
        "\n",
        "        VGroup(brace, all_linear_terms.target).shift(\n",
        "            x_to_n[0].get_right()+MED_LARGE_BUFF*RIGHT - \\\n",
        "            compact[0].get_left()\n",
        "        )\n",
        "\n",
        "        self.play(MoveToTarget(all_linear_terms))\n",
        "        self.play(Write(brace, run_time = 1))\n",
        "        return brace, derivative_term\n",
        "\n",
        "class ReactToFullExpansion(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        self.add(randy)\n",
        "\n",
        "        self.play(randy.change_mode, \"pleading\")\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"angry\")\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"thinking\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class OneOverX(PiCreatureScene, GraphScene):\n",
        "    CONFIG = {\n",
        "        \"unit_length\" : 3.0,    \n",
        "        \"graph_origin\" : (FRAME_X_RADIUS - LARGE_BUFF)*LEFT + 2*DOWN,\n",
        "        \"rectangle_color_kwargs\" : {\n",
        "            \"fill_color\" : BLUE,\n",
        "            \"fill_opacity\" : 0.5,\n",
        "            \"stroke_width\" : 1,\n",
        "            \"stroke_color\" : WHITE,\n",
        "        },\n",
        "\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_min\" : 0,\n",
        "        \"y_min\" : 0,\n",
        "        \"x_tick_frequency\" : 0.5,\n",
        "        \"y_tick_frequency\" : 0.5,\n",
        "        \"x_labeled_nums\" : list(range(0, 4)),\n",
        "        \"y_labeled_nums\" : [1],\n",
        "        \"y_axis_height\" : 10,\n",
        "        \"morty_scale_val\" : 0.8,\n",
        "        \"area_label_scale_factor\" : 0.75,\n",
        "        \"dx\" : 0.1,\n",
        "        \"start_x_value\" : 1.3,\n",
        "        \"dx_color\" : GREEN,\n",
        "        \"df_color\" : RED,\n",
        "    }\n",
        "    def setup(self):\n",
        "        for c in self.__class__.__bases__:\n",
        "            c.setup(self)\n",
        "        self.x_max = self.x_axis_width/self.unit_length\n",
        "        self.y_max = self.y_axis_height/self.unit_length\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.introduce_function()\n",
        "        self.introduce_puddle()\n",
        "        self.introduce_graph()\n",
        "        self.perform_nudge()\n",
        "\n",
        "    def introduce_function(self):\n",
        "        func = OldTex(\"f(x) = \", \"\\\\frac{1}{x}\")\n",
        "        func.to_edge(UP)\n",
        "        recip_copy = func[1].copy()\n",
        "        x_to_neg_one = OldTex(\"x^{-1}\")\n",
        "        x_to_neg_one.submobjects.reverse()\n",
        "        neg_one = VGroup(*x_to_neg_one[:2])\n",
        "        neg_two = OldTex(\"-2\")\n",
        "\n",
        "        self.play(\n",
        "            Write(func),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            recip_copy.next_to, self.pi_creature, UP+LEFT,\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        x_to_neg_one.move_to(recip_copy)\n",
        "        neg_two.replace(neg_one)\n",
        "        self.play(ReplacementTransform(recip_copy, x_to_neg_one))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            neg_one.scale, 1.5,\n",
        "            neg_one.next_to, x_to_neg_one, LEFT, SMALL_BUFF, DOWN,\n",
        "            rate_func = running_start,\n",
        "            path_arc = np.pi\n",
        "        )\n",
        "        self.play(FadeIn(neg_two))\n",
        "        self.wait()\n",
        "        self.say(\n",
        "            \"More geometry!\",\n",
        "            target_mode = \"hooray\",\n",
        "            added_anims = [\n",
        "                FadeOut(x_to_neg_one),\n",
        "                FadeOut(neg_two),\n",
        "            ],\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(self.pi_creature))\n",
        "\n",
        "    def introduce_puddle(self):\n",
        "        rect_group = self.get_rectangle_group(self.start_x_value)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(rect_group.rectangle),\n",
        "            Write(rect_group.area_label),\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(rect_group.x_brace),\n",
        "            Write(rect_group.x_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(rect_group.recip_brace),\n",
        "            Write(rect_group.recip_label),\n",
        "        )\n",
        "        self.setup_axes(animate = True)\n",
        "        self.wait()\n",
        "\n",
        "        for d in 2, 3:\n",
        "            self.change_rectangle_group(\n",
        "                rect_group, d,\n",
        "                target_group_kwargs = {\n",
        "                    \"x_label\" : str(d),\n",
        "                    \"one_over_x_label\" : \"\\\\frac{1}{%d}\"%d,\n",
        "                },\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.change_rectangle_group(rect_group, 3)\n",
        "        self.wait()\n",
        "\n",
        "        self.rect_group = rect_group\n",
        "\n",
        "    def introduce_graph(self):\n",
        "        rect_group = self.rect_group\n",
        "        graph = self.get_graph(lambda x : 1./x)\n",
        "        graph.set_points(list(reversed(graph.get_points())))\n",
        "\n",
        "        self.change_rectangle_group(\n",
        "            rect_group, 0.01,\n",
        "            added_anims = [\n",
        "                ShowCreation(graph)\n",
        "            ],\n",
        "            run_time = 5,\n",
        "        )\n",
        "        self.change_mode(\"happy\")\n",
        "        self.change_rectangle_group(rect_group, self.start_x_value)\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "\n",
        "    def perform_nudge(self):\n",
        "        rect_group = self.rect_group\n",
        "        graph = self.graph\n",
        "\n",
        "        rect_copy = rect_group.rectangle.copy()\n",
        "        rect_copy.set_fill(opacity = 0)\n",
        "        new_rect = self.get_rectangle(\n",
        "            self.start_x_value + self.dx\n",
        "        )\n",
        "\n",
        "        recip_brace = rect_group.recip_brace\n",
        "        recip_brace.generate_target()\n",
        "        recip_brace.target.next_to(\n",
        "            new_rect, RIGHT, \n",
        "            buff = SMALL_BUFF,\n",
        "            aligned_edge = DOWN,\n",
        "        )\n",
        "        recip_label = rect_group.recip_label\n",
        "        recip_label.generate_target()\n",
        "        recip_label.target.next_to(recip_brace.target, RIGHT)\n",
        "\n",
        "        h_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                ORIGIN, (rect_copy.get_width()+LARGE_BUFF)*RIGHT, \n",
        "                color = self.df_color,\n",
        "                stroke_width = 2\n",
        "            ).move_to(rect.get_corner(UP+LEFT), LEFT)\n",
        "            for rect in (rect_group.rectangle, new_rect)\n",
        "        ])\n",
        "\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                ORIGIN, (rect_copy.get_height()+MED_LARGE_BUFF)*UP,\n",
        "                color = self.dx_color,\n",
        "                stroke_width = 2\n",
        "            ).move_to(rect.get_corner(DOWN+RIGHT), DOWN)\n",
        "            for rect in (rect_group.rectangle, new_rect)\n",
        "        ])\n",
        "\n",
        "        dx_brace = Brace(v_lines, UP, buff = 0)\n",
        "        dx_label = dx_brace.get_text(\"$dx$\")\n",
        "        dx_brace.add(dx_label)\n",
        "\n",
        "        df_brace = Brace(h_lines, RIGHT, buff = 0)\n",
        "        df_label = df_brace.get_text(\"$d\\\\left(\\\\frac{1}{x}\\\\right)$\")\n",
        "        df_brace.add(df_label)\n",
        "\n",
        "        negative = OldTexText(\"Negative\")\n",
        "        negative.set_color(RED)\n",
        "        negative.next_to(df_label, UP+RIGHT)\n",
        "        negative.shift(RIGHT)\n",
        "        negative_arrow = Arrow(\n",
        "            negative.get_left(),\n",
        "            df_label.get_corner(UP+RIGHT),\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        area_changes = VGroup()\n",
        "        point_pairs = [\n",
        "            (new_rect.get_corner(UP+RIGHT), rect_copy.get_corner(DOWN+RIGHT)),\n",
        "            (new_rect.get_corner(UP+LEFT), rect_copy.get_corner(UP+RIGHT))\n",
        "        ]\n",
        "        for color, point_pair in zip([self.dx_color, self.df_color], point_pairs):\n",
        "            area_change_rect = Rectangle(\n",
        "                fill_opacity = 1,\n",
        "                fill_color = color,\n",
        "                stroke_width = 0\n",
        "            )\n",
        "            area_change_rect.replace(\n",
        "                VGroup(*list(map(VectorizedPoint, point_pair))),\n",
        "                stretch = True\n",
        "            )\n",
        "            area_changes.add(area_change_rect)\n",
        "        area_gained, area_lost = area_changes\n",
        "\n",
        "        area_gained_label = OldTexText(\"Area gained\")\n",
        "        area_gained_label.scale(0.75)\n",
        "        area_gained_label.next_to(\n",
        "            rect_copy.get_corner(DOWN+RIGHT), \n",
        "            UP+LEFT, buff = SMALL_BUFF\n",
        "        )\n",
        "        area_gained_arrow = Arrow(\n",
        "            area_gained_label.get_top(),\n",
        "            area_gained.get_center(),\n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "        \n",
        "        area_lost_label = OldTexText(\"Area lost\")\n",
        "        area_lost_label.scale(0.75)\n",
        "        area_lost_label.next_to(rect_copy.get_left(), RIGHT)\n",
        "        area_lost_arrow = Arrow(\n",
        "            area_lost_label.get_top(),\n",
        "            area_lost.get_center(),\n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        question = OldTex(\n",
        "            \"\\\\frac{d(1/x)}{dx} = ???\"\n",
        "        )\n",
        "        question.next_to(\n",
        "            self.pi_creature.get_corner(UP+LEFT), \n",
        "            UP, buff = MED_SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(rect_group.area_label),\n",
        "            ReplacementTransform(rect_copy, new_rect),\n",
        "            MoveToTarget(recip_brace),\n",
        "            MoveToTarget(recip_label),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(dx_brace),\n",
        "            *list(map(ShowCreation, v_lines))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(df_brace),\n",
        "            *list(map(ShowCreation, h_lines))\n",
        "        )\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(area_gained),\n",
        "            Write(area_gained_label, run_time = 2),\n",
        "            ShowCreation(area_gained_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(area_lost),\n",
        "            Write(area_lost_label, run_time = 2),\n",
        "            ShowCreation(area_lost_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.revert_to_original_skipping_status()###\n",
        "        self.play(\n",
        "            Write(negative),\n",
        "            ShowCreation(negative_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ########\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = PiCreatureScene.create_pi_creature(self)\n",
        "        morty.scale(\n",
        "            self.morty_scale_val, \n",
        "            about_point = morty.get_corner(DOWN+RIGHT)\n",
        "        )\n",
        "        return morty\n",
        "\n",
        "    def draw_graph(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(lambda x : 1./x)\n",
        "\n",
        "        rect_group = self.get_rectangle_group(0.5)\n",
        "\n",
        "        self.add(rect_group)\n",
        "        self.wait()\n",
        "        self.change_rectangle_group(\n",
        "            rect_group, 2,\n",
        "            target_group_kwargs = {\n",
        "                \"x_label\" : \"2\",\n",
        "                \"one_over_x_label\" : \"\\\\frac{1}{2}\",\n",
        "            },\n",
        "            added_anims = [ShowCreation(graph)]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_rectangle_group(\n",
        "        self, x, \n",
        "        x_label = \"x\", \n",
        "        one_over_x_label = \"\\\\frac{1}{x}\"\n",
        "        ):\n",
        "        result = VGroup()\n",
        "        result.x_val = x\n",
        "        result.rectangle = self.get_rectangle(x)\n",
        "\n",
        "        result.x_brace, result.recip_brace = braces = [\n",
        "            Brace(result.rectangle, vect)\n",
        "            for vect in (UP, RIGHT)\n",
        "        ]\n",
        "        result.labels = VGroup()\n",
        "        for brace, label in zip(braces, [x_label, one_over_x_label]):\n",
        "            brace.get_text(\"$%s$\"%label)\n",
        "            result.labels.add(brace.get_text(\"$%s$\"%label))\n",
        "        result.x_label, result.recip_label = result.labels\n",
        "\n",
        "        area_label = OldTexText(\"Area = 1\")\n",
        "        area_label.scale(self.area_label_scale_factor)\n",
        "        max_width = max(result.rectangle.get_width()-2*SMALL_BUFF, 0)\n",
        "        if area_label.get_width() > max_width:\n",
        "            area_label.set_width(max_width)\n",
        "        area_label.move_to(result.rectangle)\n",
        "        result.area_label = area_label\n",
        "\n",
        "        result.add(\n",
        "            result.rectangle,\n",
        "            result.x_brace,\n",
        "            result.recip_brace,\n",
        "            result.labels,\n",
        "            result.area_label,\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def get_rectangle(self, x):\n",
        "        try:\n",
        "            y = 1./x\n",
        "        except ZeroDivisionError:\n",
        "            y = 100\n",
        "\n",
        "        rectangle = Rectangle(\n",
        "            width = x*self.unit_length,\n",
        "            height = y*self.unit_length,\n",
        "            **self.rectangle_color_kwargs\n",
        "        )\n",
        "        rectangle.move_to(self.graph_origin, DOWN+LEFT)\n",
        "        return rectangle\n",
        "\n",
        "    def change_rectangle_group(\n",
        "        self, \n",
        "        rect_group, target_x,\n",
        "        target_group_kwargs = None,\n",
        "        added_anims = [],\n",
        "        **anim_kwargs\n",
        "        ):\n",
        "        target_group_kwargs = target_group_kwargs or {}\n",
        "        if \"run_time\" not in anim_kwargs:\n",
        "            anim_kwargs[\"run_time\"] = 3\n",
        "\n",
        "        target_group = self.get_rectangle_group(target_x, **target_group_kwargs)\n",
        "        target_labels = target_group.labels\n",
        "        labels_transform = Transform(\n",
        "            rect_group.labels,\n",
        "            target_group.labels\n",
        "        )\n",
        "\n",
        "        start_x = float(rect_group.x_val)\n",
        "        def update_rect_group(group, alpha):\n",
        "            x = interpolate(start_x, target_x, alpha)\n",
        "            new_group = self.get_rectangle_group(x, **target_group_kwargs)\n",
        "            Transform(group, new_group).update(1)\n",
        "            labels_transform.update(alpha)\n",
        "            for l1, l2 in zip(rect_group.labels, new_group.labels):\n",
        "                l1.move_to(l2)\n",
        "            return rect_group\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(rect_group, update_rect_group),\n",
        "            *added_anims,\n",
        "            **anim_kwargs\n",
        "        )\n",
        "        rect_group.x_val = target_x\n",
        "\n",
        "class AskRecipriocalQuestion(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"(\\\\text{What number?})\",  \n",
        "            \"\\\\cdot x = 1\"\n",
        "        )\n",
        "        arrow = Arrow(DOWN+LEFT, UP+RIGHT)\n",
        "        arrow.move_to(tex[0].get_top(), DOWN+LEFT)\n",
        "        self.play(Write(tex))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "class SquareRootOfX(Scene):\n",
        "    CONFIG = {\n",
        "        \"square_color_kwargs\" : {\n",
        "            \"stroke_color\" : WHITE,\n",
        "            \"stroke_width\" : 1,\n",
        "            \"fill_color\" : BLUE_E,\n",
        "            \"fill_opacity\" : 1,\n",
        "        },\n",
        "        \"bigger_square_color_kwargs\" : {\n",
        "            \"stroke_color\" : WHITE,\n",
        "            \"stroke_width\" : 1,\n",
        "            \"fill_color\" : YELLOW,\n",
        "            \"fill_opacity\" : 0.7,\n",
        "        },\n",
        "        \"square_corner\" : 6*LEFT+3*UP,\n",
        "        \"square_width\" : 3,\n",
        "        \"d_sqrt_x\" : 0.3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.introduce_square()\n",
        "        self.nudge_square()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(x) = \\\\sqrt{x}\")\n",
        "        title.next_to(ORIGIN, RIGHT)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "    def introduce_square(self):\n",
        "        square = Square(\n",
        "            side_length = self.square_width,\n",
        "            **self.square_color_kwargs\n",
        "        )\n",
        "        square.move_to(self.square_corner, UP+LEFT)\n",
        "        area_label = OldTexText(\"Area $ = x$\")\n",
        "        area_label.move_to(square)\n",
        "\n",
        "        bottom_brace, right_brace = braces = VGroup(*[\n",
        "            Brace(square, vect)\n",
        "            for vect in (DOWN, RIGHT)\n",
        "        ])\n",
        "        for brace in braces:\n",
        "            brace.add(brace.get_text(\"$\\\\sqrt{x}$\"))\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(square),\n",
        "            Write(area_label)\n",
        "        )\n",
        "        self.play(*list(map(FadeIn, braces)))\n",
        "        self.wait()\n",
        "\n",
        "        self.square = square\n",
        "        self.area_label = area_label\n",
        "        self.braces = braces\n",
        "\n",
        "    def nudge_square(self):\n",
        "        square = self.square\n",
        "        area_label = self.area_label\n",
        "        bottom_brace, right_brace = self.braces\n",
        "\n",
        "        bigger_square = Square(\n",
        "            side_length = self.square_width + self.d_sqrt_x,\n",
        "            **self.bigger_square_color_kwargs\n",
        "        )\n",
        "        bigger_square.move_to(self.square_corner, UP+LEFT)\n",
        "\n",
        "        square_copy = square.copy()\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                ORIGIN,\n",
        "                (self.square_width + MED_LARGE_BUFF)*vect,\n",
        "                color = WHITE,\n",
        "                stroke_width = 3\n",
        "            ).shift(s.get_corner(corner))\n",
        "            for corner, vect in [(DOWN+LEFT, RIGHT), (UP+RIGHT, DOWN)]\n",
        "            for s in [square, bigger_square]\n",
        "        ])\n",
        "        little_braces = VGroup(*[\n",
        "            Brace(VGroup(*line_pair), vect, buff = 0)\n",
        "            for line_pair, vect in [(lines[:2], RIGHT), (lines[2:], DOWN)]\n",
        "        ])\n",
        "        for brace in little_braces:\n",
        "            tex = brace.get_text(\"$d\\\\sqrt{x}$\", buff = SMALL_BUFF)\n",
        "            tex.scale(0.8)\n",
        "            brace.add(tex)\n",
        "\n",
        "        area_increase = OldTexText(\"$dx$ = New area\")\n",
        "        area_increase.set_color(bigger_square.get_color())\n",
        "        area_increase.next_to(square, RIGHT, 4)\n",
        "\n",
        "        question = OldTex(\"\\\\frac{d\\\\sqrt{x}}{dx} = ???\")\n",
        "        VGroup(*question[5:7]).set_color(bigger_square.get_color())\n",
        "        question.next_to(\n",
        "            area_increase, DOWN, \n",
        "            aligned_edge = LEFT, \n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "        \n",
        "        self.play(\n",
        "            Transform(square_copy, bigger_square),\n",
        "            Animation(square),\n",
        "            Animation(area_label),\n",
        "            bottom_brace.next_to, bigger_square, DOWN, SMALL_BUFF, LEFT,\n",
        "            right_brace.next_to, bigger_square, RIGHT, SMALL_BUFF, UP,\n",
        "        )\n",
        "        self.play(Write(area_increase))\n",
        "        self.play(*it.chain(\n",
        "            list(map(ShowCreation, lines)),\n",
        "            list(map(FadeIn, little_braces))\n",
        "        ))\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "class MentionSine(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Let's tackle $\\\\sin(\\\\theta)$\")\n",
        "        self.play_student_changes(\"pondering\", \"hooray\", \"erm\")\n",
        "        self.wait(2)\n",
        "        self.student_thinks(\"\")\n",
        "        self.zoom_in_on_thought_bubble()\n",
        "\n",
        "class NameUnitCircle(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Unit circle\")\n",
        "        words.scale(2)\n",
        "        words.set_color(BLUE)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class DerivativeOfSineIsSlope(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"\\\\frac{d(\\\\sin(\\\\theta))}{d\\\\theta} = \",\n",
        "            \"\\\\text{Slope of this graph}\"\n",
        "        )\n",
        "        tex.set_width(FRAME_WIDTH-1)\n",
        "        tex.to_edge(DOWN)\n",
        "        VGroup(*tex[0][2:8]).set_color(BLUE)\n",
        "        VGroup(*tex[1][-9:]).set_color(BLUE)\n",
        "\n",
        "        self.play(Write(tex, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceUnitCircleWithSine(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"unit_length\" : 2.5,\n",
        "        \"graph_origin\" : ORIGIN,\n",
        "        \"x_axis_width\" : 15,\n",
        "        \"y_axis_height\" : 10,\n",
        "        \"x_min\" : -3,\n",
        "        \"x_max\" : 3,\n",
        "        \"y_min\" : -2,\n",
        "        \"y_max\" : 2,\n",
        "        \"x_labeled_nums\" : [-2, -1, 1, 2],\n",
        "        \"y_labeled_nums\" : [-1, 1],\n",
        "        \"x_tick_frequency\" : 0.5,\n",
        "        \"y_tick_frequency\" : 0.5,\n",
        "        \"circle_color\" : BLUE,\n",
        "        \"example_radians\" : 0.8,\n",
        "        \"rotations_per_second\" : 0.25,\n",
        "        \"include_radial_line_dot\" : True,\n",
        "        \"remove_angle_label\" : True,\n",
        "        \"line_class\" : DashedLine,\n",
        "        \"theta_label\" : \"= 0.8\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_title()\n",
        "        self.introduce_unit_circle()\n",
        "        self.draw_example_radians()\n",
        "        self.label_sine()\n",
        "        self.walk_around_circle()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(\\\\theta) = \\\\sin(\\\\theta)\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def introduce_unit_circle(self):\n",
        "        circle = self.get_unit_circle()\n",
        "        radial_line = Line(ORIGIN, self.unit_length*RIGHT)\n",
        "        radial_line.set_color(RED)\n",
        "        if self.include_radial_line_dot:\n",
        "            dot = Dot()\n",
        "            dot.move_to(radial_line.get_end())\n",
        "            radial_line.add(dot)\n",
        "\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(\n",
        "            ShowCreation(circle),            \n",
        "            Rotate(radial_line, 2*np.pi),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.circle = circle\n",
        "        self.radial_line = radial_line\n",
        "\n",
        "    def draw_example_radians(self):\n",
        "        circle = self.circle\n",
        "        radial_line = self.radial_line\n",
        "\n",
        "        line = Line(\n",
        "            ORIGIN, self.example_radians*self.unit_length*UP,\n",
        "            color = YELLOW,\n",
        "        )\n",
        "        line.shift(FRAME_X_RADIUS*RIGHT/3).to_edge(UP)\n",
        "        line.insert_n_curves(10)\n",
        "        line.make_smooth()\n",
        "\n",
        "        arc = Arc(\n",
        "            self.example_radians, radius = self.unit_length,\n",
        "            color = line.get_color(),\n",
        "        )\n",
        "        arc_copy = arc.copy().set_color(WHITE)\n",
        "\n",
        "        brace = Brace(line, RIGHT)\n",
        "        brace_text = brace.get_text(\"$\\\\theta%s$\"%self.theta_label)\n",
        "        brace_text.set_color(line.get_color())\n",
        "        theta_copy = brace_text[0].copy()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(line),\n",
        "            GrowFromCenter(brace),\n",
        "        )\n",
        "        self.play(Write(brace_text))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            line.move_to, radial_line.get_end(), DOWN,\n",
        "            FadeOut(brace)\n",
        "        )\n",
        "        self.play(ReplacementTransform(line, arc))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(radial_line, self.example_radians),\n",
        "            ShowCreation(arc_copy)\n",
        "        )\n",
        "        self.wait()\n",
        "        arc_copy.generate_target()\n",
        "        arc_copy.target.scale(0.2)\n",
        "        theta_copy.generate_target()\n",
        "        theta_copy.target.next_to(\n",
        "            arc_copy.target, RIGHT,\n",
        "            aligned_edge = DOWN,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        theta_copy.target.shift(SMALL_BUFF*UP)\n",
        "        self.play(*list(map(MoveToTarget, [arc_copy, theta_copy])))\n",
        "        self.wait()\n",
        "\n",
        "        self.angle_label = VGroup(arc_copy, theta_copy)\n",
        "        self.example_theta_equation = brace_text\n",
        "\n",
        "    def label_sine(self):\n",
        "        radial_line = self.radial_line\n",
        "\n",
        "        drop_point = radial_line.get_end()[0]*RIGHT\n",
        "        v_line = self.line_class(radial_line.get_end(), drop_point)\n",
        "        brace = Brace(v_line, RIGHT)\n",
        "        brace_text = brace.get_text(\"$\\\\sin(\\\\theta)$\")\n",
        "        brace_text[-2].set_color(YELLOW)\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        faders = [brace, brace_text, self.example_theta_equation]\n",
        "        if self.remove_angle_label:\n",
        "            faders += self.angle_label\n",
        "        self.play(*list(map(FadeOut, faders)))\n",
        "\n",
        "        self.v_line = v_line\n",
        "\n",
        "    def walk_around_circle(self):\n",
        "        radial_line = self.radial_line\n",
        "        v_line = self.v_line\n",
        "\n",
        "        def v_line_update(v_line):\n",
        "            drop_point = radial_line.get_end()[0]*RIGHT\n",
        "            v_line.put_start_and_end_on(\n",
        "                radial_line.get_end(), drop_point\n",
        "            )\n",
        "            return v_line\n",
        "        filler_arc = self.circle.copy()\n",
        "        filler_arc.set_color(YELLOW)\n",
        "        curr_arc_portion = self.example_radians/(2*np.pi)\n",
        "        filler_portion = 1 - curr_arc_portion\n",
        "        filler_arc.pointwise_become_partial(filler_arc, curr_arc_portion, 1)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(radial_line, filler_portion*2*np.pi),\n",
        "            ShowCreation(filler_arc),\n",
        "            UpdateFromFunc(v_line, v_line_update),\n",
        "            run_time = filler_portion/self.rotations_per_second,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        for x in range(5):\n",
        "            self.play(\n",
        "                Rotate(radial_line, 2*np.pi),\n",
        "                UpdateFromFunc(v_line, v_line_update),\n",
        "                run_time = 1./self.rotations_per_second,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "    ##############\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        VGroup(*self.x_axis.numbers[:2]).shift(MED_SMALL_BUFF*LEFT)\n",
        "        VGroup(*self.x_axis.numbers[2:]).shift(SMALL_BUFF*RIGHT)\n",
        "        self.y_axis.numbers[0].shift(MED_SMALL_BUFF*DOWN)\n",
        "        self.y_axis.numbers[1].shift(MED_SMALL_BUFF*UP)\n",
        "\n",
        "    def get_unit_circle(self):\n",
        "        return Circle(\n",
        "            radius = self.unit_length,\n",
        "            color = self.circle_color,\n",
        "        )\n",
        "\n",
        "class DerivativeIntuitionFromSineGraph(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : 6*LEFT,\n",
        "        \"x_axis_width\" : 11,\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 4*np.pi,\n",
        "        \"x_labeled_nums\" : np.arange(0, 4*np.pi, np.pi),\n",
        "        \"x_tick_frequency\" : np.pi/4,\n",
        "        \"x_axis_label\" : \"$\\\\theta$\",\n",
        "        \"y_axis_height\" : 6,\n",
        "        \"y_min\" : -2,\n",
        "        \"y_max\" : 2,\n",
        "        \"y_tick_frequency\" : 0.5,\n",
        "        \"y_axis_label\" : \"\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.draw_sine_graph()\n",
        "        self.draw_derivative_from_slopes()\n",
        "        self.alter_derivative_graph()\n",
        "\n",
        "    def draw_sine_graph(self):\n",
        "        graph = self.get_graph(np.sin)\n",
        "        v_line = DashedLine(ORIGIN, UP)\n",
        "        rps = IntroduceUnitCircleWithSine.CONFIG[\"rotations_per_second\"]\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            UpdateFromFunc(v_line, lambda v : self.v_line_update(v, graph)),\n",
        "            run_time = 2./rps,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.wait()\n",
        "        self.graph = graph\n",
        "\n",
        "    def draw_derivative_from_slopes(self):\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            0, self.graph,\n",
        "            dx = 0.01,\n",
        "            secant_line_color = RED,\n",
        "        )\n",
        "        deriv_graph = self.get_graph(np.cos, color = DERIVATIVE_COLOR)\n",
        "        v_line = DashedLine(\n",
        "            self.graph_origin, self.coords_to_point(0, 1), \n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(ss_group, lag_ratio = 0))\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        last_theta = 0\n",
        "        next_theta = np.pi/2\n",
        "        while last_theta < self.x_max:\n",
        "            deriv_copy = deriv_graph.copy()\n",
        "            self.animate_secant_slope_group_change(\n",
        "                ss_group,\n",
        "                target_x = next_theta,\n",
        "                added_anims = [\n",
        "                    ShowCreation(\n",
        "                        deriv_copy,\n",
        "                        rate_func = lambda t : interpolate(\n",
        "                            last_theta/self.x_max, \n",
        "                            next_theta/self.x_max,\n",
        "                            smooth(t)\n",
        "                        ),\n",
        "                        run_time = 3,\n",
        "                    ),\n",
        "                    UpdateFromFunc(\n",
        "                        v_line, \n",
        "                        lambda v : self.v_line_update(v, deriv_copy),\n",
        "                        run_time = 3\n",
        "                    ),\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "            if next_theta == 2*np.pi:\n",
        "                words = OldTexText(\"Looks a lot like $\\\\cos(\\\\theta)$\")\n",
        "                words.next_to(self.graph_origin, RIGHT)\n",
        "                words.to_edge(UP)\n",
        "                arrow = Arrow(\n",
        "                    words.get_bottom(), \n",
        "                    deriv_graph.point_from_proportion(0.45)\n",
        "                )\n",
        "                VGroup(words, arrow).set_color(deriv_graph.get_color())\n",
        "                self.play(\n",
        "                    Write(words),\n",
        "                    ShowCreation(arrow)\n",
        "                )\n",
        "            self.remove(deriv_copy)\n",
        "            last_theta = next_theta\n",
        "            next_theta += np.pi/2\n",
        "        self.add(deriv_copy)\n",
        "\n",
        "        self.deriv_graph = deriv_copy\n",
        "\n",
        "    def alter_derivative_graph(self):\n",
        "        func_list = [\n",
        "            lambda x : 0.5*(np.cos(x)**3 + np.cos(x)),\n",
        "            lambda x : 0.75*(np.sign(np.cos(x))*np.cos(x)**2 + np.cos(x)),\n",
        "            lambda x : 2*np.cos(x),\n",
        "            lambda x : np.cos(x),\n",
        "        ]\n",
        "        for func in func_list:\n",
        "            new_graph = self.get_graph(func, color = DERIVATIVE_COLOR)\n",
        "            self.play(\n",
        "                Transform(self.deriv_graph, new_graph),\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    ######\n",
        "\n",
        "    def v_line_update(self, v_line, graph):\n",
        "        point = graph.point_from_proportion(1)\n",
        "        drop_point = point[0]*RIGHT\n",
        "        v_line.put_start_and_end_on(drop_point, point)\n",
        "        return v_line\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        self.x_axis.remove(self.x_axis.numbers)\n",
        "        self.remove(self.x_axis.numbers)\n",
        "        for x in range(1, 4):\n",
        "            if x == 1:\n",
        "                label = OldTex(\"\\\\pi\")\n",
        "            else:\n",
        "                label = OldTex(\"%d\\\\pi\"%x)\n",
        "            label.next_to(self.coords_to_point(x*np.pi, 0), DOWN, MED_LARGE_BUFF)\n",
        "            self.add(label)\n",
        "        self.x_axis_label_mob.set_color(YELLOW)\n",
        "\n",
        "class LookToFunctionsMeaning(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Look to the function's\n",
        "            actual meaning\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class DerivativeFromZoomingInOnSine(IntroduceUnitCircleWithSine, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\" : 10,\n",
        "        \"zoomed_canvas_frame_shape\" : (3, 4.5),\n",
        "        \"include_radial_line_dot\" : False,\n",
        "        \"remove_angle_label\" : False,\n",
        "        \"theta_label\" : \"\",\n",
        "        \"line_class\" : Line,\n",
        "        \"example_radians\" : 1.0,\n",
        "        \"zoomed_canvas_corner_buff\" : SMALL_BUFF,\n",
        "        \"d_theta\" : 0.05,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_title()\n",
        "        self.introduce_unit_circle()\n",
        "        self.draw_example_radians()\n",
        "        self.label_sine()\n",
        "\n",
        "        self.zoom_in()\n",
        "        self.perform_nudge()\n",
        "        self.show_similar_triangles()\n",
        "        self.analyze_ratios()\n",
        "\n",
        "    def zoom_in(self):\n",
        "        self.activate_zooming()\n",
        "        self.little_rectangle.next_to(self.radial_line.get_end(), UP, LARGE_BUFF)\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            self.little_rectangle, self.big_rectangle\n",
        "        ])))\n",
        "        self.play(\n",
        "            self.little_rectangle.move_to, \n",
        "            self.radial_line.get_end(), DOWN+RIGHT,\n",
        "            self.little_rectangle.shift, \n",
        "            SMALL_BUFF*(DOWN+RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def perform_nudge(self):\n",
        "        d_theta_arc = Arc(\n",
        "            start_angle = self.example_radians,\n",
        "            angle = self.d_theta,\n",
        "            radius = self.unit_length,\n",
        "            color = MAROON_B,\n",
        "            stroke_width = 6\n",
        "        )\n",
        "        d_theta_arc.scale(self.zoom_factor)\n",
        "        d_theta_brace = Brace(\n",
        "            d_theta_arc,\n",
        "            rotate_vector(RIGHT, self.example_radians)\n",
        "        )\n",
        "        d_theta_label = OldTex(\"d\\\\theta\")\n",
        "        d_theta_label.next_to(\n",
        "            d_theta_brace.get_center(), d_theta_brace.direction, \n",
        "            MED_LARGE_BUFF\n",
        "        )\n",
        "        d_theta_label.set_color(d_theta_arc.get_color())\n",
        "\n",
        "        group = VGroup(d_theta_arc, d_theta_brace, d_theta_label)\n",
        "        group.scale(1./self.zoom_factor)\n",
        "\n",
        "        point = self.radial_line.get_end()\n",
        "        nudged_point = d_theta_arc.point_from_proportion(1)\n",
        "        interim_point = nudged_point[0]*RIGHT+point[1]*UP\n",
        "        h_line = DashedLine(\n",
        "            interim_point, point, \n",
        "            dash_length = 0.01\n",
        "        )\n",
        "        d_sine_line = Line(interim_point, nudged_point, color = DERIVATIVE_COLOR)\n",
        "        d_sine_brace = Brace(Line(ORIGIN, UP), LEFT)\n",
        "        d_sine_brace.set_height(d_sine_line.get_height())\n",
        "        d_sine_brace.next_to(d_sine_line, LEFT, buff = SMALL_BUFF/self.zoom_factor)\n",
        "        d_sine = OldTex(\"d(\\\\sin(\\\\theta))\")\n",
        "        d_sine.set_color(d_sine_line.get_color())\n",
        "        d_sine.set_width(1.5*self.d_theta*self.unit_length)\n",
        "        d_sine.next_to(d_sine_brace, LEFT, SMALL_BUFF/self.zoom_factor)\n",
        "\n",
        "        self.play(ShowCreation(d_theta_arc))\n",
        "        self.play(\n",
        "            GrowFromCenter(d_theta_brace),\n",
        "            FadeIn(d_theta_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            ShowCreation(d_sine_line)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(d_sine_brace),\n",
        "            Write(d_sine)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.little_triangle = Polygon(\n",
        "            nudged_point, point, interim_point\n",
        "        )\n",
        "        self.d_theta_group = VGroup(d_theta_brace, d_theta_label)\n",
        "        self.d_sine_group = VGroup(d_sine_brace, d_sine)\n",
        "\n",
        "    def show_similar_triangles(self):\n",
        "        little_triangle = self.little_triangle\n",
        "        big_triangle = Polygon(\n",
        "            self.graph_origin,\n",
        "            self.radial_line.get_end(),\n",
        "            self.radial_line.get_end()[0]*RIGHT,\n",
        "        )\n",
        "        for triangle in little_triangle, big_triangle:\n",
        "            triangle.set_color(GREEN)\n",
        "            triangle.set_fill(GREEN, opacity = 0.5)\n",
        "        big_triangle_copy = big_triangle.copy()\n",
        "        big_triangle_copy.next_to(ORIGIN, UP+LEFT)\n",
        "\n",
        "        new_angle_label = self.angle_label.copy()\n",
        "        new_angle_label.scale(\n",
        "            little_triangle.get_width()/big_triangle.get_height()\n",
        "        )\n",
        "        new_angle_label.rotate(-np.pi/2)\n",
        "        new_angle_label.shift(little_triangle.get_points()[0])\n",
        "        new_angle_label[1].rotate(np.pi/2)\n",
        "\n",
        "        little_triangle_lines = VGroup(*[\n",
        "            Line(*list(map(little_triangle.get_corner, pair)))\n",
        "            for pair in [\n",
        "                (DOWN+RIGHT, UP+LEFT),\n",
        "                (UP+LEFT, DOWN+LEFT)\n",
        "            ]\n",
        "        ])\n",
        "        little_triangle_lines.set_color(little_triangle.get_color())\n",
        "\n",
        "        self.play(DrawBorderThenFill(little_triangle))\n",
        "        self.play(\n",
        "            little_triangle.scale, 2, little_triangle.get_corner(DOWN+RIGHT),\n",
        "            little_triangle.set_color, YELLOW,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        groups = [self.d_theta_group, self.d_sine_group]\n",
        "        for group, line in zip(groups, little_triangle_lines):\n",
        "            self.play(ApplyMethod(\n",
        "                line.rotate, np.pi/12,\n",
        "                rate_func = wiggle,\n",
        "                remover = True,\n",
        "            ))\n",
        "            self.play(\n",
        "                group.scale, 1.2, group.get_corner(DOWN+RIGHT),\n",
        "                group.set_color, YELLOW,\n",
        "                rate_func = there_and_back,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            little_triangle.copy().set_fill(opacity = 0), \n",
        "            big_triangle_copy,\n",
        "            path_arc = np.pi/2,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(big_triangle_copy, big_triangle),\n",
        "            Animation(self.angle_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.radial_line.rotate, np.pi/12,\n",
        "            Animation(big_triangle),\n",
        "            rate_func = wiggle,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                big_triangle.copy().set_fill(opacity = 0), \n",
        "                little_triangle,\n",
        "                path_arc = -np.pi/2,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.angle_label.copy(),\n",
        "                new_angle_label,\n",
        "                path_arc = -np.pi/2,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            new_angle_label.scale, 2,\n",
        "            new_angle_label.set_color, RED,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def analyze_ratios(self):\n",
        "        d_ratio = OldTex(\"\\\\frac{d(\\\\sin(\\\\theta))}{d\\\\theta} = \")\n",
        "        VGroup(*d_ratio[:9]).set_color(GREEN)\n",
        "        VGroup(*d_ratio[10:12]).set_color(MAROON_B)\n",
        "        trig_ratio = OldTex(\"\\\\frac{\\\\text{Adj.}}{\\\\text{Hyp.}}\")\n",
        "        VGroup(*trig_ratio[:4]).set_color(GREEN)\n",
        "        VGroup(*trig_ratio[5:9]).set_color(MAROON_B)\n",
        "        cos = OldTex(\"= \\\\cos(\\\\theta)\")\n",
        "        cos.add_background_rectangle()\n",
        "\n",
        "        group = VGroup(d_ratio, trig_ratio, cos)\n",
        "        group.arrange()\n",
        "        group.next_to(\n",
        "            self.title, DOWN, \n",
        "            buff = MED_LARGE_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        for mob in group:\n",
        "            self.play(Write(mob))\n",
        "            self.wait()\n",
        "\n",
        "class TryWithCos(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"What about $\\\\cos(\\\\theta)$?\")\n",
        "        words.set_color(YELLOW)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class NextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        next_video = series[3]\n",
        "        series.to_edge(UP)\n",
        "\n",
        "        d_sum = OldTex(\"\\\\frac{d}{dx}(x^3 + x^2)\")\n",
        "        d_product = OldTex(\"\\\\frac{d}{dx} \\\\sin(x)x^2\")\n",
        "        d_composition = OldTex(\"\\\\frac{d}{dx} \\\\cos\\\\left(\\\\frac{1}{x}\\\\right)\")\n",
        "\n",
        "        group = VGroup(d_sum, d_product, d_composition)\n",
        "        group.arrange(RIGHT, buff = 2*LARGE_BUFF)\n",
        "        group.next_to(VGroup(*self.get_pi_creatures()), UP, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                series,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, next_video)\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            next_video.set_color, YELLOW,\n",
        "            next_video.shift, MED_LARGE_BUFF*DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "        for mob in group:\n",
        "            self.play(\n",
        "                Write(mob, run_time = 1),\n",
        "                *[\n",
        "                    ApplyMethod(pi.look_at, mob)\n",
        "                    for pi in self.get_pi_creatures()\n",
        "                ]\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "class Chapter3PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht   \",\n",
        "            \"Jonathan    Eppele\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"https://brilliant.org/3b1b/\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "class Thumbnail(NudgeSideLengthOfCube):\n",
        "    def construct(self):\n",
        "        self.introduce_cube()\n",
        "        VGroup(*self.get_mobjects()).to_edge(DOWN)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{d(x^3)}{dx} = 3x^2\"\n",
        "        )\n",
        "        VGroup(*formula[:5]).set_color(YELLOW)\n",
        "        VGroup(*formula[-3:]).set_color(GREEN_B)\n",
        "        formula.set_width(FRAME_X_RADIUS-1)\n",
        "        formula.to_edge(RIGHT)\n",
        "        self.add(formula)\n",
        "\n",
        "        title = OldTexText(\"Geometric derivatives\")\n",
        "        title.set_width(FRAME_WIDTH-1)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}