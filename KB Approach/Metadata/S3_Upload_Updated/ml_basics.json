{
    "topic": "demonstrates the concept of Deep Learning and its various models such as Multilayer Percept",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2024.transformers.helpers import *\n",
        "from _2024.transformers.embedding import *\n",
        "from _2024.transformers.generation import *\n",
        "\n",
        "\n",
        "class DialTest(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        dial = Dial(radius=0.5)\n",
        "        self.add(dial)\n",
        "        self.play(dial.animate_set_value(0.5, run_time=1))\n",
        "\n",
        "        # Test\n",
        "        machine = MachineWithDials()\n",
        "        self.add(machine)\n",
        "        self.play(machine.random_change_animation())\n",
        "\n",
        "\n",
        "class MLWithinDeepL(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Organize boxes\n",
        "        kw = dict(font_size=36, opacity=0.25)\n",
        "        model_boxes = VGroup(\n",
        "            self.get_titled_box(\"Multilayer Perceptrons\", BLUE_D, **kw),\n",
        "            self.get_titled_box(\"Convolutional Neural Networks\", BLUE_D, **kw),\n",
        "            self.get_titled_box(\"Transformers\", BLUE, **kw),\n",
        "        )\n",
        "        for box in model_boxes:\n",
        "            box.box.set_width(model_boxes.get_width(), stretch=True)\n",
        "        dots = Tex(R\"\\vdots\", font_size=72)\n",
        "        model_boxes.add(dots)\n",
        "        model_boxes.arrange(DOWN, buff=0.1)\n",
        "        dots.shift(0.2 * DOWN)\n",
        "        transformer_box = model_boxes[2]\n",
        "\n",
        "        dl_box = self.get_titled_box(\n",
        "            \"Deep Learning\", TEAL,\n",
        "            font_size=60,\n",
        "            y_space=model_boxes.get_height() + 1.0,\n",
        "            x_space=2.75,\n",
        "            opacity=0.05\n",
        "        )\n",
        "\n",
        "        model_boxes.next_to(dl_box.title, DOWN)\n",
        "\n",
        "        # Animate in word\n",
        "        transformer_box.save_state()\n",
        "        transformer_box.box.set_opacity(0)\n",
        "        transformer_box.set_height(1)\n",
        "        transformer_box.move_to(np.array([-1.58, -2.01, 0]))\n",
        "\n",
        "        self.add(transformer_box)\n",
        "        self.wait()\n",
        "        self.add(dl_box, transformer_box)\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(dl_box, scale=1.2),\n",
        "            Restore(transformer_box),\n",
        "            *(FadeIn(model_boxes[i]) for i in [0, 1, 3]),\n",
        "        ), lag_ratio=0.75, run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        dl_box.add(model_boxes)\n",
        "        self.add(dl_box)\n",
        "\n",
        "        # Place within ML box\n",
        "        ml_box = self.get_titled_box(\n",
        "            \"Machine Learning\",\n",
        "            GREEN,\n",
        "            opacity=0.1,\n",
        "            font_size=72,\n",
        "            x_space=6.0,\n",
        "            y_space=5.0\n",
        "        )\n",
        "        dl_box.target = dl_box.generate_target()\n",
        "        blank_boxes = dl_box.box.replicate(2)\n",
        "        inner_boxes = VGroup(*blank_boxes, dl_box.target)\n",
        "        reg_drawing = self.get_regression_drawing()\n",
        "        bayes_net = self.get_bayes_net_drawing()\n",
        "        for drawing, box in zip([reg_drawing, bayes_net], blank_boxes):\n",
        "            drawing.set_height(0.8 * box.get_height())\n",
        "            drawing.move_to(box)\n",
        "            box.add(drawing)\n",
        "        inner_boxes.set_height(3.5)\n",
        "        inner_boxes.arrange(RIGHT)\n",
        "        inner_boxes.set_max_width(ml_box.get_width() - 0.5)\n",
        "        inner_boxes.next_to(ml_box.title, DOWN, buff=1.0)\n",
        "\n",
        "        self.add(ml_box, dl_box, blank_boxes)\n",
        "        self.play(\n",
        "            FadeIn(ml_box),\n",
        "            MoveToTarget(dl_box),\n",
        "            LaggedStartMap(FadeIn, blank_boxes, scale=2.0, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ml_box.add(dl_box, blank_boxes)\n",
        "\n",
        "        # Learn from data\n",
        "        words = Text(\"Learn from data\", font_size=72)\n",
        "        words.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        learn = words[\"Learn\"][0]\n",
        "        learn.save_state()\n",
        "        learn.set_x(0)\n",
        "        words[\"data\"].set_color(YELLOW)\n",
        "        ml_box.target = ml_box.generate_target()\n",
        "        ml_box.target.scale(0.75)\n",
        "        ml_box.target.to_edge(DOWN)\n",
        "        arrow = Arrow(ml_box.target, words)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(ml_box),\n",
        "            GrowFromCenter(arrow),\n",
        "            TransformFromCopy(ml_box.title[\"Learn\"][0], learn),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(learn),\n",
        "            FadeIn(words[\"from data\"][0], lag_ratio=0.1, shift=0.2 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(ml_box),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go back to the box\n",
        "        self.clear()\n",
        "        ml_box.center()\n",
        "        self.add(ml_box)\n",
        "\n",
        "        # Pop out\n",
        "        ml_box.remove(dl_box)\n",
        "        ml_box.add(dl_box.copy())\n",
        "        ml_box.target = ml_box.generate_target()\n",
        "        ml_box.target.scale(0.25).to_edge(LEFT)\n",
        "        dl_box.target = dl_box.generate_target()\n",
        "        dl_box.target.scale(2.0)\n",
        "        dl_box.target.next_to(ml_box.target, RIGHT, buff=0.75),\n",
        "        lines = VGroup(*(\n",
        "            Line(\n",
        "                ml_box.target[-1].get_corner(RIGHT + v),\n",
        "                dl_box.target.get_corner(LEFT + v)\n",
        "            )\n",
        "            for v in [UP, DOWN]\n",
        "        ))\n",
        "        lines.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(ml_box),\n",
        "            MoveToTarget(dl_box),\n",
        "            GrowFromPoint(lines[0], dl_box.get_corner(UR)),\n",
        "            GrowFromPoint(lines[1], dl_box.get_corner(DR)),\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a neural network\n",
        "        network = NeuralNetwork([5, 10, 5])\n",
        "        network.next_to(dl_box, RIGHT, buff=1.0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(network.layers[0]),\n",
        "            ShowCreation(network.lines[0], lag_ratio=0.01),\n",
        "            FadeIn(network.layers[1], lag_ratio=0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(network.lines[1], lag_ratio=0.01),\n",
        "            FadeIn(network.layers[2], lag_ratio=0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Ambiently change the network\n",
        "        for _ in range(6):\n",
        "            self.play(\n",
        "                network.animate.randomize_line_style().randomize_layer_values(),\n",
        "                run_time=3,\n",
        "                lag_ratio=1e-4\n",
        "            )\n",
        "\n",
        "        # Pile of matrices\n",
        "        pile_words = Text(\"Pile of matrices\")\n",
        "        pile_words.next_to(network, UP)\n",
        "        path_arc = -60 * DEGREES\n",
        "        arrow = Arrow(dl_box.get_top(), pile_words.get_corner(UL), path_arc=path_arc)\n",
        "        matrices = VGroup(*(\n",
        "            WeightMatrix(shape=(8, 6), ellipses_row=None, ellipses_col=None)\n",
        "            for x in range(10)\n",
        "        ))\n",
        "        matrices.match_width(network)\n",
        "        matrices.move_to(network, UP)\n",
        "        matrices.shift(0.5 * DOWN)\n",
        "        matrix_shift = 0.5 * (IN + RIGHT)\n",
        "\n",
        "        matrices.arrange(OUT, buff=0.25)\n",
        "        matrices.move_to(network)\n",
        "\n",
        "        for matrix in matrices[:-1]:\n",
        "            matrix.target = matrix.generate_target()\n",
        "            for entry in matrix.target.get_entries():\n",
        "                dot = Dot(radius=0.05)\n",
        "                dot.set_fill(entry.get_fill_color(), opacity=0.25)\n",
        "                dot.move_to(entry)\n",
        "                entry.become(dot)\n",
        "            matrix.target[-1].set_opacity(0.25)\n",
        "        matrices[-1].get_entries().set_backstroke(BLACK, 8)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(network, 2 * DOWN),\n",
        "            ShowCreation(arrow),\n",
        "            FadeInFromPoint(pile_words, dl_box.title.get_center(), path_arc=path_arc),\n",
        "            FadeOut(network, DOWN)\n",
        "        )\n",
        "        mat_shift = 0.5 * IN + 0.25 * DOWN\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                Succession(\n",
        "                    FadeIn(matrix, shift=mat_shift),\n",
        "                    MoveToTarget(matrix)\n",
        "                )\n",
        "                for matrix in matrices[:-1]\n",
        "            ), lag_ratio=0.25, run_time=5),\n",
        "            Animation(Point()),\n",
        "            FadeIn(matrices[-1], shift=mat_shift, time_span=(3.75, 4.75))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_titled_box(self, text, color, font_size=48, y_space=0.5, x_space=0.5, opacity=0.1):\n",
        "        title = Text(text, font_size=font_size)\n",
        "        box = Rectangle(\n",
        "            title.get_width() + x_space,\n",
        "            title.get_height() + y_space\n",
        "        )\n",
        "        box.set_fill(interpolate_color(BLACK, color, opacity), 1)\n",
        "        box.set_stroke(color, 2)\n",
        "        title.next_to(box.get_top(), DOWN, buff=MED_SMALL_BUFF)\n",
        "        result = VGroup(box, title)\n",
        "        result.box = box\n",
        "        result.title = title\n",
        "        return result\n",
        "\n",
        "    def get_regression_drawing(self):\n",
        "        axes = Axes((-1, 10), (-1, 10))\n",
        "        m = 0.5\n",
        "        y0 = 2\n",
        "        line = axes.get_graph(lambda x: y0 + m * x)\n",
        "        line.set_stroke(YELLOW, 2)\n",
        "        dots = VGroup(\n",
        "            Dot(axes.c2p(x, y0 + m * x + np.random.normal()))\n",
        "            for x in np.random.uniform(0, 10, 15)\n",
        "        )\n",
        "\n",
        "        reg_drawing = VGroup(axes, dots, line)\n",
        "        return reg_drawing\n",
        "\n",
        "    def get_bayes_net_drawing(self):\n",
        "        radius = MED_SMALL_BUFF\n",
        "        node = Circle(radius=radius)\n",
        "        node.set_stroke(GREY_B, 2)\n",
        "        node.shift(2 * DOWN)\n",
        "        nodes = VGroup(\n",
        "            node.copy().shift(x * RIGHT + y * UP)\n",
        "            for x, y in [\n",
        "                (-1, 0),  \n",
        "                (1, 0),\n",
        "                (-2, 2),\n",
        "                (0, 2),\n",
        "                (2, 2),\n",
        "                (-2, 4),\n",
        "                (0, 4),\n",
        "            ]\n",
        "        )\n",
        "        edge_index_pairs = [\n",
        "            (2, 0),\n",
        "            (3, 0),\n",
        "            (3, 1),\n",
        "            (4, 1),\n",
        "            (5, 2),\n",
        "            (6, 3),\n",
        "        ]\n",
        "        edges = VGroup()\n",
        "        for i1, i2 in edge_index_pairs:\n",
        "            n1, n2 = nodes[i1], nodes[i2]\n",
        "            edge = Arrow(\n",
        "                n1.get_center(), \n",
        "                n2.get_center(),\n",
        "                buff=radius,\n",
        "                color=WHITE,\n",
        "                stroke_width=3\n",
        "            )\n",
        "            edges.add(edge)\n",
        "\n",
        "        network = VGroup(nodes, edges)\n",
        "        return network\n",
        "\n",
        "\n",
        "class ShowCross(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        cross = Cross(Square(side_length=5))\n",
        "        cross.set_stroke(width=[0, 30, 0])\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FlashThroughImageData(InteractiveScene):\n",
        "    time_per_example = 0.1\n",
        "\n",
        "    def construct(self):\n",
        "        # Images\n",
        "        image_data = load_image_net_data()\n",
        "        arrow = Vector(RIGHT)\n",
        "\n",
        "        for path, text in ProgressDisplay(image_data):\n",
        "            image = ImageMobject(str(path))\n",
        "            label = Text(text.split(\",\")[0])\n",
        "            label.use_winding_fill(False)\n",
        "            image.next_to(arrow, LEFT)\n",
        "            label.next_to(arrow, RIGHT)\n",
        "            self.add(image, arrow, label)\n",
        "            self.wait(self.time_per_example)\n",
        "            self.remove(image, label)\n",
        "\n",
        "            if hasattr(image, \"shader_wrapper\"):\n",
        "                for tid in image.shader_wrapper.texture_names_to_ids.values():\n",
        "                    release_texture(tid)\n",
        "\n",
        "\n",
        "class FlashThroughTextData2(InteractiveScene):\n",
        "    n_examples = 200\n",
        "    time_per_example = 0.1\n",
        "    window_size = 50\n",
        "    line_len = 35\n",
        "    ul_point = 5 * LEFT + 3 * UP\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        totc = read_in_book(name=\"tale_of_two_cities\")\n",
        "        words = re.split(r\"\\s\", totc)\n",
        "        words = list(filter(lambda s: s, words))\n",
        "\n",
        "        for n in range(self.n_examples):\n",
        "            index = random.randint(0, len(words) - self.window_size)\n",
        "            window = words[index:index + self.window_size]\n",
        "            phrase = get_paragraph(window, line_len=self.line_len)\n",
        "            phrase.move_to(self.ul_point, UL)\n",
        "\n",
        "            word = phrase[window[-1]][-1]\n",
        "            rect = SurroundingRectangle(word, buff=0.1)\n",
        "            rect.set_stroke(YELLOW, 2)\n",
        "            rect.set_fill(YELLOW, 0.5)\n",
        "\n",
        "            self.add(phrase)\n",
        "            self.wait(self.time_per_example)\n",
        "            self.remove(phrase)\n",
        "\n",
        "\n",
        "class TweakedMachine(InteractiveScene):\n",
        "    n_tweaks = 200\n",
        "    time_per_example = 0.1\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        machine = MachineWithDials(\n",
        "            dial_config=dict(\n",
        "                value_to_color_config=dict(\n",
        "                    low_negative_color=BLUE_E,\n",
        "                    high_negative_color=BLUE_B,\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        machine.move_to(2 * DOWN)\n",
        "        machine.set_width(4)\n",
        "        arrow = Vector(DOWN, stroke_width=10)\n",
        "        arrow.next_to(machine, UP)\n",
        "\n",
        "        self.add(machine, arrow)\n",
        "\n",
        "        values = np.array([d.get_random_value() for d in machine.dials])\n",
        "\n",
        "        for n in range(self.n_tweaks):\n",
        "            nudges = np.random.uniform(-1, 1, values.shape)\n",
        "            values += 0.1 * nudges\n",
        "            values[values > 1.0] = 0.9\n",
        "            values[values < 0.0] = 0.1\n",
        "            for dial, value in zip(machine.dials, values):\n",
        "                dial.set_value(value)\n",
        "            self.wait(self.time_per_example)\n",
        "\n",
        "\n",
        "class PremiseOfML(InteractiveScene):\n",
        "    box_center = RIGHT\n",
        "    n_examples = 50\n",
        "    random_seed = 316\n",
        "    show_matrices = False\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_data()\n",
        "\n",
        "        # Set up input and output\n",
        "        machine = self.get_machine()\n",
        "        machine.set_width(4)\n",
        "        machine.move_to(self.box_center)\n",
        "        model_label = Text(\"Model\", font_size=72)\n",
        "        model_label.move_to(machine.box)\n",
        "        in_arrow = Vector(RIGHT).next_to(machine, LEFT)\n",
        "        out_arrow = Vector(RIGHT).next_to(machine, RIGHT)\n",
        "\n",
        "        self.add(machine.box)\n",
        "        self.add(in_arrow, out_arrow)\n",
        "        self.add(model_label)\n",
        "\n",
        "        # Show initial input and output\n",
        "        in_data, out_data = self.new_input_output_example(in_arrow, out_arrow)\n",
        "\n",
        "        in_word, out_word = [\n",
        "            Text(word).next_to(machine, UP).match_x(mob).shift_onto_screen()\n",
        "            for word, mob in [(\"Input\", in_data), (\"Output\", out_data)]\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(in_data, lag_ratio=0.001),\n",
        "            FadeIn(in_word, 0.5 * UP),\n",
        "        )\n",
        "        self.play(FadeOutToPoint(in_data.copy(), machine.get_left(), lag_ratio=0.005, path_arc=-60 * DEGREES))\n",
        "        self.play(\n",
        "            FadeInFromPoint(out_data, machine.get_right(), lag_ratio=0.1, path_arc=60 * DEGREES),\n",
        "            FadeIn(out_word, 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show code\n",
        "        model_label.target = model_label.generate_target()\n",
        "        model_label.target.scale(in_word[0].get_height() / model_label[0].get_height())\n",
        "        model_label.target.align_to(in_word, UP)\n",
        "        code = self.get_code()\n",
        "        code.set_height(machine.get_height() - MED_SMALL_BUFF)\n",
        "        code.set_max_width(machine.get_width() - MED_SMALL_BUFF)\n",
        "        code.move_to(machine, UP).shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(model_label),\n",
        "            ShowIncreasingSubsets(code, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show tunable parameters\n",
        "        param_label = Text(\"Tunable parameters\")\n",
        "        param_label.next_to(machine, UP)\n",
        "        param_label.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(code, 0.25 * DOWN, lag_ratio=0.01),\n",
        "            Write(machine.dials, lag_ratio=0.001),\n",
        "            FadeOut(model_label, 0.5 * UP),\n",
        "            FadeIn(param_label, 0.5 * UP),\n",
        "        )\n",
        "        self.play(machine.rotate_all_dials())\n",
        "        self.wait()\n",
        "\n",
        "        # Show lots of new data\n",
        "        for n in range(self.n_examples):\n",
        "            new_in_data, new_out_data = self.new_input_output_example(in_arrow, out_arrow)\n",
        "            self.add(in_data, out_data)\n",
        "            time_span = (0, 0.35)\n",
        "            self.play(\n",
        "                machine.random_change_animation(run_time=0.5),\n",
        "                FadeOut(in_data, time_span=time_span),\n",
        "                FadeOut(out_data, time_span=time_span),\n",
        "                FadeIn(new_in_data, time_span=time_span),\n",
        "                FadeIn(new_out_data, time_span=time_span),\n",
        "            )\n",
        "            in_data, out_data = new_in_data, new_out_data\n",
        "\n",
        "        if not self.show_matrices:\n",
        "            return\n",
        "\n",
        "        # Make room\n",
        "        up_shift = 1.5 * UP\n",
        "        down_shift = 1.75 * DOWN\n",
        "\n",
        "        down_group = Group(in_arrow, machine, param_label, out_arrow, out_data, out_word)\n",
        "        self.play(\n",
        "            in_data.animate.scale(0.75).shift(up_shift + 0.5 * UP),\n",
        "            UpdateFromFunc(out_data, lambda m: m.match_y(in_data)),\n",
        "            in_word.animate.shift(up_shift),\n",
        "            down_group.animate.shift(down_shift),\n",
        "        )\n",
        "\n",
        "        # Create pixels\n",
        "        image = in_data\n",
        "        pixels = create_pixels(in_data)\n",
        "\n",
        "        # Show input array\n",
        "        in_array = NumericEmbedding(shape=(10, 10), ellipses_col=-2)\n",
        "        in_array.match_height(machine)\n",
        "        in_array.next_to(in_arrow, LEFT)\n",
        "        image.set_opacity(0.8)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                pixels,\n",
        "                VGroup(*(in_array.get_entries().family_members_with_points())),\n",
        "                run_time=2,\n",
        "                lag_ratio=1e-3\n",
        "            ),\n",
        "            FadeInFromPoint(in_array.get_brackets(), image.get_bottom()),\n",
        "            Write(in_array.get_ellipses(), time_span=(1, 2))\n",
        "        )\n",
        "        self.play(image.animate.set_opacity(1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show one dimensional array\n",
        "        vector = NumericEmbedding(length=10)\n",
        "        vector.replace(in_array, dim_to_match=1)\n",
        "        vector.move_to(in_array, RIGHT)\n",
        "\n",
        "        self.remove(in_array)\n",
        "        self.play(\n",
        "            TransformFromCopy(in_array.get_brackets(), vector.get_brackets()),\n",
        "            TransformFromCopy(in_array.get_columns()[5], vector.get_columns()[0]),\n",
        "            *map(FadeOut, in_array.get_columns()),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(vector)\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(vector.get_brackets(), in_array.get_brackets()),\n",
        "            TransformFromCopy(vector.get_columns()[0], in_array.get_columns()[5]),\n",
        "            *(\n",
        "                FadeIn(col, shift=col.get_center() - vector.get_center())\n",
        "                for col in in_array.get_columns()\n",
        "            )\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show 3d tensor\n",
        "        self.frame.set_field_of_view(30 * DEGREES)\n",
        "        dot_array = in_array.copy()\n",
        "        for entry in (*dot_array.get_entries(), *dot_array.get_ellipses()):\n",
        "            dot = Dot(entry.get_center(), radius=0.06)\n",
        "            entry.set_submobjects([dot])\n",
        "\n",
        "        tensor = VGroup(*(\n",
        "            dot_array.copy()\n",
        "            for n in range(5)\n",
        "        ))\n",
        "        for layer in tensor:\n",
        "            for dot in (*layer.get_entries(), *layer.get_ellipses()):\n",
        "                dot.set_fill(\n",
        "                    interpolate_color(GREY_C, GREY_B, random.random()),\n",
        "                    opacity=0.5,\n",
        "                )\n",
        "                dot.set_backstroke(BLACK, 2)\n",
        "        tensor.arrange(OUT, buff=0.25)\n",
        "        tensor.move_to(in_array, RIGHT)\n",
        "        tensor.rotate(5 * DEGREES, RIGHT)\n",
        "        tensor.rotate(5 * DEGREES, UP)\n",
        "\n",
        "        self.remove(in_array)\n",
        "        self.play(TransformFromCopy(VGroup(in_array), tensor))\n",
        "        self.play(Rotate(tensor, 20 * DEGREES, axis=UP, run_time=4))\n",
        "        self.play(Transform(tensor, VGroup(in_array), remover=True))\n",
        "        self.add(in_array)\n",
        "\n",
        "        # Express output as an array of numbers\n",
        "        values = np.random.uniform(0, 1, (10, 1))\n",
        "        values[5] = 9.7\n",
        "        out_array = DecimalMatrix(values, ellipses_row=-2)\n",
        "        out_array.match_height(machine)\n",
        "        out_array.match_y(out_arrow)\n",
        "        out_array.match_x(out_word)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromPoint(out_array, machine.get_right(), lag_ratio=1e-3),\n",
        "            out_data.animate.scale(0.75).fade(0.5).rotate(-PI / 2).next_to(out_array, RIGHT, buff=0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Describe parameters as weights\n",
        "        weights_label = Text(\"Weights\")\n",
        "        weights_label.next_to(machine, UP, buff=0.5)\n",
        "        weights_label.match_color(param_label)\n",
        "        equiv = Tex(R\"\\Updownarrow\")\n",
        "        equiv.next_to(weights_label, UP)\n",
        "\n",
        "        top_dials = machine.dials[:8]\n",
        "        dial_rects = VGroup(*map(SurroundingRectangle, top_dials))\n",
        "        dial_rects.set_stroke(TEAL, 2)\n",
        "        dial_arrows = VGroup(*(\n",
        "            Arrow(weights_label.get_bottom(), rect.get_top(), buff=0.05)\n",
        "            for rect in dial_rects\n",
        "        ))\n",
        "        dial_arrows.set_stroke(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(weights_label, scale=2),\n",
        "            param_label.animate.next_to(equiv, UP),\n",
        "            Write(equiv),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                VFadeInThenOut(VGroup(arrow, rect))\n",
        "                for arrow, rect in zip(dial_arrows, dial_rects)\n",
        "            ), lag_ratio=0.25, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show weighted sum\n",
        "        machine.dials.save_state()\n",
        "        weights_label.set_backstroke(BLACK, 5)\n",
        "        weights_label.target = weights_label.generate_target()\n",
        "        weights_label.target.next_to(top_dials, DOWN, buff=0.25)\n",
        "        weighted_sum = Tex(\n",
        "            R\"w_1 x_1 + w_2 x_2 + w_3 x_3 + \\cdots + w_n x_n\",\n",
        "            font_size=42,\n",
        "        )\n",
        "        weighted_sum.next_to(machine, UP, buff=1.0)\n",
        "        weight_parts = weighted_sum[re.compile(r\"w_\\d|w_n\")]\n",
        "        weight_parts.set_color(BLUE)\n",
        "        data_parts = weighted_sum[re.compile(r\"x_\\d|x_n\")]\n",
        "        data_parts.set_color(GREY_A)\n",
        "\n",
        "        indices = [0, 1, 2, -1]\n",
        "        dial_lines = VGroup(*(\n",
        "            Line(top_dials[n].get_top(), weight_parts[n].get_bottom(), buff=0.1)\n",
        "            for n in indices\n",
        "        ))\n",
        "        ellipses = weighted_sum[R\"\\cdots\"]\n",
        "        dial_lines.set_stroke(BLUE_B, 1)\n",
        "\n",
        "        column = in_array.get_columns()[-1]\n",
        "        col_rect = SurroundingRectangle(column)\n",
        "        col_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(col_rect))\n",
        "        self.play(\n",
        "            FadeOut(VGroup(param_label, equiv), UP),\n",
        "            MoveToTarget(weights_label),\n",
        "            machine.dials[8:].animate.fade(0.75),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(column[n], data_parts[n])\n",
        "                for n in indices\n",
        "            )),\n",
        "            Group(in_data, in_word).animate.to_edge(LEFT, buff=0.25)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(weighted_sum[\"+\"]),\n",
        "            Write(weighted_sum[R\"\\cdots\"]),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(top_dials[n].copy(), weight_parts[n])\n",
        "                for n in indices\n",
        "            )),\n",
        "            LaggedStartMap(ShowCreation, dial_lines),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(3):\n",
        "            self.play(*(\n",
        "                dial.animate_set_value(dial.get_random_value())\n",
        "                for dial in top_dials\n",
        "            ))\n",
        "\n",
        "        # Wrap a function around it\n",
        "        func_wrapper = Tex(R\"f()\")\n",
        "        func_wrapper[:2].next_to(weighted_sum, LEFT, buff=SMALL_BUFF)\n",
        "        func_wrapper[2].next_to(weighted_sum, RIGHT, buff=SMALL_BUFF)\n",
        "        func_wrapper.set_color(PINK)\n",
        "\n",
        "        nl_words = Text(\"Simple nonlinear\\nfunction\", font_size=42, alignment=\"LEFT\")\n",
        "        nl_words.next_to(func_wrapper, UP, buff=1.5, aligned_edge=LEFT)\n",
        "        nl_words.match_color(func_wrapper)\n",
        "        nl_arrow = Arrow(nl_words, func_wrapper[0].get_top())\n",
        "        nl_arrow.match_color(nl_words)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(func_wrapper),\n",
        "            FadeIn(nl_words, lag_ratio=0.1),\n",
        "            ShowCreation(nl_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show next layer\n",
        "        weights_label.target = weights_label.generate_target()\n",
        "        weights_label.target.next_to(weighted_sum, UP, buff=1.0)\n",
        "        dial_lines.target = VGroup(*(\n",
        "            Line(\n",
        "                weights_label.target, weight_parts[index].get_top(),\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            for index in indices\n",
        "        ))\n",
        "        dial_lines.target.match_style(dial_lines)\n",
        "\n",
        "        layer1 = NumericEmbedding(shape=(10, 5), ellipses_col=-2)\n",
        "        layer1.match_height(in_array)\n",
        "        layer1.next_to(in_arrow, RIGHT)\n",
        "        mid_arrow = in_arrow.copy()\n",
        "        mid_arrow.next_to(layer1, RIGHT)\n",
        "        dots = Tex(R\"\\dots\").next_to(mid_arrow, RIGHT)\n",
        "\n",
        "        expr_rect = SurroundingRectangle(func_wrapper)\n",
        "        expr_rect.set_stroke(PINK, 2)\n",
        "        x01_rect = SurroundingRectangle(layer1.elements[0])\n",
        "        x01_rect.match_style(expr_rect)\n",
        "        rect_lines = VGroup(*(\n",
        "            Line(expr_rect.get_corner(DOWN + v), x01_rect.get_corner(UP + v))\n",
        "            for v in [LEFT, RIGHT]\n",
        "        ))\n",
        "        rect_lines.match_style(expr_rect)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(weights_label),\n",
        "            FadeOut(dial_lines),\n",
        "            FadeOut(nl_words),\n",
        "            FadeOut(nl_arrow),\n",
        "            FadeOut(col_rect),\n",
        "            FadeOut(machine),\n",
        "            FadeIn(expr_rect),\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(in_array.get_brackets(), layer1.get_brackets()),\n",
        "            TransformFromCopy(in_arrow, mid_arrow),\n",
        "            out_arrow.animate.next_to(dots, RIGHT),\n",
        "            Write(dots),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(expr_rect, x01_rect),\n",
        "            ShowCreation(rect_lines, lag_ratio=0),\n",
        "            FadeInFromPoint(layer1.elements[0], expr_rect.get_center()),\n",
        "        )\n",
        "        self.play(ShowIncreasingSubsets(layer1[1:-1]))\n",
        "        self.add(layer1)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight a subset of the data\n",
        "        in_subset = VGroup(*(\n",
        "            elem\n",
        "            for row in in_array.get_rows()[:3]\n",
        "            for elem in row[:3]\n",
        "        ))\n",
        "        in_subset_rects = VGroup(*map(SurroundingRectangle, in_subset))\n",
        "        data_part_rects = VGroup(*map(SurroundingRectangle, data_parts))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreationThenFadeOut, in_subset_rects, lag_ratio=0.02),\n",
        "            LaggedStartMap(ShowCreationThenFadeOut, data_part_rects, lag_ratio=0.04),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show added layers\n",
        "        to_fade = VGroup(\n",
        "            func_wrapper, expr_rect, rect_lines, x01_rect,\n",
        "            weighted_sum\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, to_fade, run_time=1),\n",
        "            in_arrow.animate.scale(0.5, about_edge=LEFT),\n",
        "            layer1.animate.rotate(70 * DEGREES, UP).next_to(in_arrow, RIGHT, buff=-0.25),\n",
        "            mid_arrow.animate.scale(0.5).next_to(in_arrow, RIGHT, buff=0.75),\n",
        "        )\n",
        "\n",
        "        layer1_group = VGroup(layer1, mid_arrow)\n",
        "        layer2_group, layer3_group = layer1_group.replicate(2)\n",
        "        layer2_group.next_to(layer1_group, RIGHT, buff=SMALL_BUFF)\n",
        "        layer3_group.next_to(layer2_group, RIGHT, buff=SMALL_BUFF)\n",
        "        self.play(TransformFromCopy(layer1_group, layer2_group))\n",
        "        self.play(\n",
        "            TransformFromCopy(layer2_group, layer3_group),\n",
        "            VGroup(dots, out_arrow).animate.next_to(layer3_group, RIGHT),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                dot.animate.shift(0.1 * UP).set_anim_args(rate_func=there_and_back)\n",
        "                for dot in dots\n",
        "            ), lag_ratio=0.25)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring back machine\n",
        "        layers = VGroup(layer1_group, layer2_group, layer3_group, dots)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(machine, scale=0.8),\n",
        "            FadeIn(weights_label, shift=DOWN),\n",
        "            ShowCreation(dial_lines, lag_ratio=0.1),\n",
        "            FadeIn(weighted_sum, shift=UP),\n",
        "            FadeOut(layers, scale=0.8),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            machine.random_change_animation()\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a matrix\n",
        "        frame = self.frame\n",
        "        matrix, vector, equals, rhs = get_full_matrix_vector_product()\n",
        "        mat_prod_group = VGroup(matrix, vector, equals, rhs)\n",
        "        mat_prod_group.next_to(machine, UP, buff=2.0)\n",
        "        mat_prod_group.shift(0.5 * LEFT)\n",
        "\n",
        "        p0 = machine.get_corner(UL)\n",
        "        p1 = matrix.get_corner(DL)\n",
        "        p2 = machine.get_corner(UR)\n",
        "        p3 = rhs.get_corner(DR)\n",
        "        brace = VGroup(\n",
        "            CubicBezier(p0, p0 + 2 * UP, p1 + 2 * DOWN, p1 + 0.1 * DOWN),\n",
        "            CubicBezier(p2, p2 + 2 * UP, p3 + 2 * DOWN, p3 + 0.1 * DOWN),\n",
        "        )\n",
        "        brace.set_stroke(WHITE, 5)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(data_parts, vector.get_columns()[0]),\n",
        "            TransformFromCopy(weight_parts, matrix.get_rows()[0]),\n",
        "            FadeTransform(weighted_sum, rhs.get_rows()[0]),\n",
        "            frame.animate.set_height(10, about_edge=DOWN),\n",
        "            FadeOut(in_data, DOWN),\n",
        "            FadeOut(out_data, DOWN),\n",
        "            in_word.animate.next_to(in_array, UP),\n",
        "            FadeIn(matrix, lag_ratio=0.1),\n",
        "            ShowCreation(brace, lag_ratio=0),\n",
        "            weights_label.animate.set_height(0.5).next_to(matrix, UP, buff=MED_SMALL_BUFF),\n",
        "            Uncreate(dial_lines, lag_ratio=0.1),\n",
        "            FadeOut(col_rect),\n",
        "            machine.dials.animate.restore(),\n",
        "            FadeIn(vector.get_brackets()),\n",
        "            FadeIn(rhs.get_brackets()),\n",
        "            FadeIn(equals),\n",
        "            run_time=3,\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Animate matrix vector product\n",
        "        ghost_row = rhs.get_rows()[0].copy()\n",
        "        ghost_row.set_opacity(0.25)\n",
        "        self.add(ghost_row)\n",
        "        show_symbolic_matrix_vector_product(\n",
        "            self, matrix, vector, rhs,\n",
        "            run_time_per_row=1.5\n",
        "        )\n",
        "        self.remove(ghost_row)\n",
        "        self.wait()\n",
        "\n",
        "        # Associate weights with dials\n",
        "        w_elems = matrix.get_entries()\n",
        "        moving_dials = machine.dials[:len(w_elems)].copy()\n",
        "        moving_dials.target = moving_dials.generate_target()\n",
        "        for dial, w_elem in zip(moving_dials.target, w_elems):\n",
        "            dial.move_to(w_elem)\n",
        "            dial.scale(2)\n",
        "\n",
        "        self.play(\n",
        "            w_elems.animate.set_opacity(0.25),\n",
        "            MoveToTarget(moving_dials, run_time=2),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                dial.animate_set_value(dial.get_random_value())\n",
        "                for dial in moving_dials\n",
        "            ), lag_ratio=0.02, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(moving_dials),\n",
        "            w_elems.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "        # Vector an data slice\n",
        "        v_rect = SurroundingRectangle(vector.get_entries())\n",
        "        self.play(\n",
        "            ShowCreation(v_rect),\n",
        "            ShowCreation(col_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(v_rect),\n",
        "            FadeOut(col_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show many matrices\n",
        "        lhs = VGroup(matrix, vector)\n",
        "        small_mat_product = Tex(R\"W_{10} v_{11}\")\n",
        "        small_mat_product[R\"W_{10}\"].set_color(BLUE)\n",
        "        w_index = small_mat_product.make_number_changeable(\"10\")\n",
        "        v_index = small_mat_product.make_number_changeable(\"11\")\n",
        "        small_mat_products = VGroup()\n",
        "        n_rows, n_cols = 16, 8\n",
        "        for n in range(n_rows * n_cols):\n",
        "            w_index.set_value(n + 1)\n",
        "            v_index.set_value(n + 1)\n",
        "            new_prod = small_mat_product.copy()\n",
        "            new_prod.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "            small_mat_products.add(new_prod)\n",
        "        small_mat_products.arrange_in_grid(n_rows, n_cols, v_buff_ratio=2.0)\n",
        "        small_mat_products.replace(machine.dials)\n",
        "\n",
        "        mv_label = Text(\"matrix-vector products\")\n",
        "        mv_label.next_to(machine, UP, buff=1.0)\n",
        "        mv_label[-1].set_opacity(0)\n",
        "        mv_top_label = Text(\"Many, many\")\n",
        "        mv_top_label.next_to(mv_label, UP)\n",
        "        mv_arrows = VGroup(*(\n",
        "            Arrow(mv_label.get_bottom(), smp.get_top(), buff=0.1)\n",
        "            for smp in small_mat_products\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(mat_prod_group, small_mat_products[0]),\n",
        "            Uncreate(brace, lag_ratio=0),\n",
        "            FadeOut(machine.dials, run_time=0.5),\n",
        "            FadeTransform(weights_label, mv_label),\n",
        "            GrowFromPoint(mv_arrows[0], weights_label.get_bottom()),\n",
        "            frame.animate.set_height(FRAME_HEIGHT).move_to(DOWN).set_anim_args(time_span=(1, 2)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(mv_arrows)\n",
        "        self.play(\n",
        "            FadeIn(mv_top_label, UP),\n",
        "            mv_label[-1].animate.set_opacity(1),\n",
        "            ShowIncreasingSubsets(small_mat_products, rate_func=linear, run_time=12, int_func=np.ceil),\n",
        "            ShowSubmobjectsOneByOne(mv_arrows, rate_func=linear, run_time=12, int_func=np.ceil),\n",
        "        )\n",
        "        self.remove(mv_arrows)\n",
        "        self.play(FadeOut(mv_arrows[-1]))\n",
        "        self.wait()\n",
        "\n",
        "    def init_data(self):\n",
        "        self.image_data = load_image_net_data()\n",
        "\n",
        "    def new_input_output_example(self, in_arrow, out_arrow) -> tuple[Mobject, Mobject]:\n",
        "        path, label_text = random.choice(self.image_data)\n",
        "        image = ImageMobject(str(path))\n",
        "        image.set_width(4)\n",
        "        image.next_to(in_arrow, LEFT)\n",
        "        label = Text(label_text.split(\",\")[0])\n",
        "        label.set_max_width(2.5)\n",
        "        label.next_to(out_arrow, RIGHT)\n",
        "        return image, label\n",
        "\n",
        "    def get_machine(self):\n",
        "        return MachineWithDials()\n",
        "\n",
        "    def get_code(self):\n",
        "        # Test\n",
        "        src = \"\"\"\n",
        "            #include <opencv2/opencv.hpp>\n",
        "            #include <iostream>\n",
        "\n",
        "            using namespace cv;\n",
        "            using namespace std;\n",
        "\n",
        "            int main(int argc, char** argv) {\n",
        "                Mat image = imread(argv[1], IMREAD_GRAYSCALE);\n",
        "                if (image.empty()) {\n",
        "                    cout << \"Could not open image\" << endl;\n",
        "                    return -1;\n",
        "                }\n",
        "\n",
        "                // Blur the image to reduce noise\n",
        "                Mat blurredImage;\n",
        "                GaussianBlur(image, blurredImage, Size(5, 5), 0);\n",
        "\n",
        "                // Detect edges with Canny\n",
        "                Mat edges;\n",
        "                Canny(blurredImage, edges, 100, 200);\n",
        "        \"\"\"\n",
        "        return Code(src, language=\"C++\", alignment=\"LEFT\")\n",
        "\n",
        "\n",
        "class PremiseOfMLWithText(PremiseOfML):\n",
        "    random_seed = 316\n",
        "\n",
        "    def init_data(self):\n",
        "        totc = read_in_book(name=\"tale_of_two_cities\")\n",
        "        words = re.split(r\"\\s\", totc)\n",
        "        words = list(filter(lambda s: s, words))\n",
        "        self.all_words = words\n",
        "\n",
        "    def new_input_output_example(self, in_arrow, out_arrow):\n",
        "        words = self.all_words\n",
        "        window_size = 25\n",
        "        index = random.randint(0, len(words) - window_size)\n",
        "        window = words[index:index + window_size]\n",
        "        in_text = get_paragraph(window[:-1], line_len=25)\n",
        "        in_text.set_max_width(4)\n",
        "        in_text.next_to(in_arrow, LEFT)\n",
        "        out_text = Text(window[-1])\n",
        "        out_text.next_to(out_arrow, RIGHT)\n",
        "        return in_text, out_text\n",
        "\n",
        "    def get_machine(self):\n",
        "        machine = super().get_machine()\n",
        "        machine.add(VectorizedPoint().next_to(machine, DOWN, buff=0.5))\n",
        "        return machine\n",
        "\n",
        "    def get_code(self):\n",
        "        # Test\n",
        "        src = \"\"\"\n",
        "            using namespace std;\n",
        "\n",
        "            vector<string> findCapitalizedWords(const string& text) {\n",
        "                vector<string> capitalizedWords;\n",
        "                stringstream ss(text);\n",
        "                string word;\n",
        "\n",
        "                while (ss >> word) {\n",
        "                    // Check for uppercase\n",
        "                    if (!word.empty() && isupper(word[0])) {\n",
        "                        capitalizedWords.push_back(word);\n",
        "                    }\n",
        "                }\n",
        "\n",
        "                return capitalizedWords;\n",
        "            }\n",
        "\n",
        "            int main() {\n",
        "                string text;\n",
        "                cout << \"Enter text: \";\n",
        "                getline(cin, text); // Using getline to read spaces\n",
        "        \"\"\"\n",
        "        return Code(src, language=\"C++\", alignment=\"LEFT\")\n",
        "\n",
        "\n",
        "class PremiseOfMLWithMatrices(PremiseOfML):\n",
        "    # Skip to animation 9\n",
        "    show_matrices = True\n",
        "    n_examples = 0\n",
        "    random_seed = 6\n",
        "\n",
        "\n",
        "class LinearRegression(InteractiveScene):\n",
        "    radom_seed = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up axes\n",
        "        x_min, x_max = (-1, 12)\n",
        "        y_min, y_max = (-1, 10)\n",
        "        axes = Axes((x_min, x_max), (y_min, y_max), width=12, height=6)\n",
        "        axes.to_edge(DOWN)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Add data\n",
        "        n_data_points = 30\n",
        "        m = 0.75\n",
        "        y0 = 1\n",
        "\n",
        "        data = np.array([\n",
        "            (x, y0 + m * x + 0.75 * np.random.normal(0, 1))\n",
        "            for x in np.random.uniform(2, x_max, n_data_points)\n",
        "        ])\n",
        "        points = axes.c2p(data[:, 0], data[:, 1])\n",
        "        dots = DotCloud(points)\n",
        "\n",
        "        dots.set_color(YELLOW)\n",
        "        dots.set_glow_factor(1)\n",
        "        dots.set_radius(0.075)\n",
        "\n",
        "        self.add(dots)\n",
        "\n",
        "        # Make title\n",
        "        title = Text(\"Linear Regression\", font_size=72)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        # Show line\n",
        "        m_tracker = ValueTracker(m)\n",
        "        y0_tracker = ValueTracker(y0)\n",
        "        line = Line()\n",
        "        line.set_stroke(TEAL, 2)\n",
        "\n",
        "        def update_line(line):\n",
        "            curr_y0 = y0_tracker.get_value()\n",
        "            curr_m = m_tracker.get_value()\n",
        "            line.put_start_and_end_on(\n",
        "                axes.c2p(0, curr_y0),\n",
        "                axes.c2p(x_max, curr_y0 + curr_m * x_max),\n",
        "            )\n",
        "\n",
        "        line.add_updater(update_line)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(title, UP),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label inputs and outputs\n",
        "        in_labels = VGroup(Text(\"Input\"), Text(\"Square footage\"))\n",
        "        out_labels = VGroup(Text(\"Output\"), Text(\"Price\"))\n",
        "        for in_label in in_labels:\n",
        "            in_label.next_to(axes.x_axis, DOWN, buff=0.1, aligned_edge=RIGHT)\n",
        "        for out_label in out_labels:\n",
        "            out_label.rotate(90 * DEGREES)\n",
        "            out_label.next_to(axes.y_axis, LEFT, aligned_edge=UP)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(in_labels[0], lag_ratio=0.1),\n",
        "            FadeIn(out_labels[0], lag_ratio=0.1),\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(*in_labels),\n",
        "            FadeTransform(*out_labels),\n",
        "            lag_ratio=0.8,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize line\n",
        "        self.play(\n",
        "            VShowPassingFlash(\n",
        "                line.copy().set_stroke(BLUE, 8).scale(1.1).insert_n_curves(100),\n",
        "                time_width=1.5,\n",
        "                run_time=2\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add line parameter updaters\n",
        "        words = [\"slope\", \"y-intercept\"]\n",
        "        value_ranges = [(0, 2, 0.2), (-2, 3, 0.5)]\n",
        "        m_label, y0_label = labels = VGroup(\n",
        "            VGroup(\n",
        "                Dial(value_range=value_range),\n",
        "                Text(f\"{text} = \"),\n",
        "                DecimalNumber(),\n",
        "            )\n",
        "            for text, value_range in zip(words, value_ranges)\n",
        "        )\n",
        "        for label, tracker in zip(labels, [m_tracker, y0_tracker]):\n",
        "            label[0].set_height(2 * label[2].get_height())\n",
        "            label.arrange(RIGHT)\n",
        "            label[0].f_always.set_value(tracker.get_value)\n",
        "            label[2].f_always.set_value(tracker.get_value)\n",
        "        labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        labels.next_to(axes.y_axis, RIGHT, buff=1.0)\n",
        "        labels.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title, UP),\n",
        "            FadeIn(m_label, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            m_tracker.animate.set_value(1.5),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(FadeIn(y0_label, UP))\n",
        "        self.play(\n",
        "            y0_tracker.animate.set_value(-2),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Tweak line parameters\n",
        "        for n in range(10):\n",
        "            alpha = random.random()\n",
        "            if alpha > 0.5:\n",
        "                alpha += 1\n",
        "            new_m = interpolate(m_tracker.get_value(), m, alpha)\n",
        "            new_y0 = interpolate(y0_tracker.get_value(), y0, alpha)\n",
        "            self.play(LaggedStart(\n",
        "                m_tracker.animate.set_value(new_m),\n",
        "                y0_tracker.animate.set_value(new_y0),\n",
        "                run_time=1.5,\n",
        "                lag_ratio=0.25,\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class ShowGPT3Numbers(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        gpt3_label = Text(\"GPT-3\", font=\"Consolas\", font_size=72)\n",
        "        openai_logo = SVGMobject(\"OpenAI.svg\")\n",
        "        openai_logo.set_fill(WHITE)\n",
        "        openai_logo.set_height(2.0 * gpt3_label.get_height())\n",
        "        title = VGroup(openai_logo, gpt3_label)\n",
        "        title.arrange(RIGHT)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(title)\n",
        "\n",
        "        # 175b weights\n",
        "        n_param = 175_181_291_520\n",
        "        weights_count = Integer(n_param, color=BLUE)\n",
        "        weights_text = VGroup(Text(\"Total parameters:\"), weights_count)\n",
        "        weights_text.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        weights_text.next_to(title, DOWN, buff=1.0)\n",
        "        weights_arrow = Arrow(weights_count, gpt3_label, stroke_width=6, buff=0.2)\n",
        "\n",
        "        param_shape = (8, 24)\n",
        "        pre_dials = Dial().get_grid(*param_shape)\n",
        "        dial_matrix = MobjectMatrix(\n",
        "            pre_dials, *param_shape,\n",
        "            ellipses_row=-2,\n",
        "            ellipses_col=-2,\n",
        "        )\n",
        "        dial_matrix.set_width(FRAME_WIDTH)\n",
        "        dial_matrix.next_to(weights_text, DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        dials = dial_matrix.get_entries()\n",
        "        dots = dial_matrix.get_ellipses()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(weights_text[:-1], time_span=(0, 3)),\n",
        "            CountInFrom(weights_count, 0),\n",
        "            GrowArrow(weights_arrow, time_span=(0, 3)),\n",
        "            LaggedStartMap(FadeIn, pre_dials, scale=3, lag_ratio=0.1),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (dial.animate_set_value(dial.get_random_value())\n",
        "                for dial in dials),\n",
        "                lag_ratio=1.0 / len(dials),\n",
        "                run_time=5\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change name to weights\n",
        "        new_name = Text(\"Total weights: \")\n",
        "        new_name.move_to(weights_text[0], RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Transform(weights_text[0][\"Total\"][0], new_name[\"Total\"][0]),\n",
        "            Transform(weights_text[0][\"parameters:\"][0], new_name[\"weights:\"][0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Organize dials into matrices\n",
        "        mat_text = Text(\"Organized into 27,938 matrices\")\n",
        "        mat_text[\"27,938\"].set_color(TEAL)\n",
        "        mat_text.next_to(weights_text, DOWN, buff=MED_SMALL_BUFF)\n",
        "        mat_text.shift((weights_count.get_x(LEFT) - mat_text[\"27,938\"].get_x(LEFT)) * RIGHT)\n",
        "\n",
        "        mat_grid_shape = n, m = (3, 7)\n",
        "        matrices = VGroup(\n",
        "            WeightMatrix(shape=(5, 5))\n",
        "            for n in range(np.product(mat_grid_shape))\n",
        "        )\n",
        "        matrices.arrange_in_grid(\n",
        "            *mat_grid_shape,\n",
        "            v_buff_ratio=0.3,\n",
        "            h_buff_ratio=0.2,\n",
        "        )\n",
        "        matrices.set_width(FRAME_WIDTH - 1)\n",
        "        mat_dots = VGroup(\n",
        "            *(\n",
        "                Tex(R\"\\dots\").next_to(mat, RIGHT)\n",
        "                for mat in matrices[m - 1::m]\n",
        "            ),\n",
        "            *(\n",
        "                Tex(R\"\\vdots\").next_to(mat, DOWN)\n",
        "                for mat in matrices[-m:]\n",
        "            )\n",
        "        )\n",
        "        matrices_group = VGroup(matrices, mat_dots)\n",
        "        matrices_group.set_width(FRAME_WIDTH - 1)\n",
        "        matrices_group.next_to(mat_text, DOWN, buff=0.5)\n",
        "        matrices_group.set_x(0)\n",
        "        all_entries = VGroup(\n",
        "            entry\n",
        "            for mat in matrices\n",
        "            for row in mat.get_rows()\n",
        "            for entry in row\n",
        "        )\n",
        "\n",
        "        pre_entries = []\n",
        "        height = all_entries[0].get_height()\n",
        "        for n, entry in enumerate(all_entries):\n",
        "            index = n * len(dials) // len(all_entries)\n",
        "            dial = dials[min(index, len(dials) - 1)].copy()\n",
        "            dial.target = dial.generate_target()\n",
        "            dial.target.set_height(height)\n",
        "            dial.target.move_to(entry)\n",
        "            pre_entries.append(dial)\n",
        "        pre_entries = VGroup(*pre_entries)\n",
        "\n",
        "        self.remove(dial_matrix)\n",
        "        lag_ratio = 1 / len(all_entries)\n",
        "        self.play(\n",
        "            Write(mat_text),\n",
        "            LaggedStartMap(MoveToTarget, pre_entries, lag_ratio=lag_ratio),\n",
        "            TransformFromCopy(dots, mat_dots),\n",
        "            *(FadeIn(mat.get_brackets()) for mat in matrices)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(pre_entries, lag_ratio=0.2 * lag_ratio),\n",
        "            FadeIn(all_entries, lag_ratio=0.2 * lag_ratio),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add(matrices)\n",
        "        self.wait()\n",
        "\n",
        "        # Show 8 different categories\n",
        "        count_text = VGroup(weights_text, mat_text)\n",
        "        title_scale_factor = 0.75\n",
        "        count_text.target = count_text.generate_target()\n",
        "        count_text.target.scale(title_scale_factor)\n",
        "        count_text.target.to_edge(UP, MED_SMALL_BUFF).to_edge(LEFT)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(count_text.target, DOWN).set_x(0)\n",
        "        h_line.insert_n_curves(10)\n",
        "        h_line.set_stroke(width=[0, 3, 3, 3, 0])\n",
        "\n",
        "        category_names = VGroup(*map(TexText, [\n",
        "            \"Embedding\",\n",
        "            \"Key\",\n",
        "            \"Query\",\n",
        "            # \"Value\",  # Dumb alignment hack\n",
        "            # \"Output\",\n",
        "            R\"Value$_\\downarrow$\",\n",
        "            R\"Value$_\\uparrow$\",\n",
        "            \"Up-projection\",\n",
        "            \"Down-projection\",\n",
        "            \"Unembedding\",\n",
        "        ]))\n",
        "        # category_names[3][-1].set_fill(BLACK)  # Dumb alignment hack\n",
        "        category_names.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        category_names.set_height(5.5)\n",
        "        category_names.next_to(h_line, DOWN, buff=MED_LARGE_BUFF)\n",
        "        category_names.to_edge(LEFT, buff=0.5)\n",
        "        category_names.set_fill(border_width=0.2)\n",
        "\n",
        "        mat_index = 0\n",
        "        counts = [1, * 6 * [3], 1]\n",
        "        mat_groups = VGroup()\n",
        "        for name, count, dots in zip(category_names, counts, mat_dots):\n",
        "            new_mat_index = mat_index + count\n",
        "            mat_group = matrices[mat_index:new_mat_index]\n",
        "            mat_index = new_mat_index\n",
        "\n",
        "            mat_group.target = mat_group.generate_target()\n",
        "            if len(mat_group) > 1:\n",
        "                mat_group.target.add(*mat_group.copy())\n",
        "            mat_group.target.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "            mat_group.target.set_height(0.25)\n",
        "            mat_group.target.next_to(category_names, RIGHT)\n",
        "            mat_group.target.match_y(name)\n",
        "\n",
        "            dots.target = dots.generate_target()\n",
        "            if dots.get_width() < dots.get_height():\n",
        "                dots.target.rotate(90 * DEGREES)\n",
        "            dots.target.next_to(mat_group.target, RIGHT)\n",
        "            mat_groups.add(mat_group)\n",
        "        mat_dots[0].target.set_opacity(0)\n",
        "        mat_dots[7].target.set_opacity(0)\n",
        "\n",
        "        n_groups = len(category_names)\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(count_text),\n",
        "            title.animate.scale(title_scale_factor).next_to(count_text.target, RIGHT, LARGE_BUFF),\n",
        "            FadeOut(weights_arrow),\n",
        "            GrowFromCenter(h_line),\n",
        "            FadeIn(category_names),\n",
        "            LaggedStart(map(MoveToTarget, mat_groups), lag_ratio=0.05),\n",
        "            LaggedStart(map(MoveToTarget, mat_dots[:n_groups]), lag_ratio=0.05),\n",
        "            LaggedStart(map(FadeOut, mat_dots[n_groups:]), lag_ratio=0.05),\n",
        "            FadeOut(matrices[sum(counts):]),\n",
        "        ))\n",
        "\n",
        "        # Add lines\n",
        "        h_lines = Line(LEFT, RIGHT).set_width(13).replicate(n_groups)\n",
        "        h_lines.set_stroke(WHITE, 1, 0.5)\n",
        "        for name, line in zip(category_names, h_lines):\n",
        "            line.next_to(name, DOWN, buff=0.1, aligned_edge=LEFT)\n",
        "            name.line = line\n",
        "        v_line = Line(\n",
        "            mat_groups.get_corner(DL) + 0.5 * DOWN,\n",
        "            mat_groups.get_corner(UL) + 0.25 * UP,\n",
        "        )\n",
        "        v_line.shift(SMALL_BUFF * LEFT)\n",
        "        v_line.match_style(h_lines)\n",
        "\n",
        "        self.play(\n",
        "            Write(h_lines),\n",
        "            Write(v_line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Prepare expressions for parameter counts\n",
        "        const_to_value = {\n",
        "            \"n_vocab\": 50_257,\n",
        "            \"d_embed\": 12_288,\n",
        "            \"d_query\": 128,\n",
        "            \"d_value\": 128,\n",
        "            \"n_heads\": 96,\n",
        "            \"n_layers\": 96,\n",
        "            \"n_neurons\": 4 * 12_288,\n",
        "        }\n",
        "        const_lists = [\n",
        "            [\"d_embed\", \"n_vocab\"],\n",
        "            [\"d_query\", \"d_embed\", \"n_heads\", \"n_layers\",],\n",
        "            [\"d_query\", \"d_embed\", \"n_heads\", \"n_layers\",],\n",
        "            [\"d_value\", \"d_embed\", \"n_heads\", \"n_layers\",],\n",
        "            [\"d_embed\", \"d_value\", \"n_heads\", \"n_layers\"],\n",
        "            [\"n_neurons\", \"d_embed\", \"n_layers\"],\n",
        "            [\"d_embed\", \"n_neurons\", \"n_layers\"],\n",
        "            [\"n_vocab\", \"d_embed\"],\n",
        "        ]\n",
        "\n",
        "        def get_product_expression(category, consts, font_size=30, suffix=None):\n",
        "            values = [const_to_value[const] for const in consts]\n",
        "            result = np.product(values)\n",
        "            result_str = \"{:,}\".format(result)\n",
        "            expr = VGroup()\n",
        "            expr = Text(\n",
        "                \" * \".join(consts) + \" = \" + result_str,\n",
        "                font_size=font_size,\n",
        "            )\n",
        "            expr.next_to(v_line, RIGHT)\n",
        "            expr.align_to(category.line, DOWN)\n",
        "            expr.shift(0.25 * expr.get_height() * UP)\n",
        "            expr.rhs = expr[result_str]\n",
        "            expr.rhs.set_color(BLUE)\n",
        "\n",
        "            counts = VGroup(\n",
        "                Integer(\n",
        "                    const_to_value[const],\n",
        "                    font_size=0.8 * font_size,\n",
        "                )\n",
        "                for const in consts\n",
        "            )\n",
        "            counts.next_to(expr, UP, buff=0.05)\n",
        "            for count, const in zip(counts, consts):\n",
        "                count.match_x(expr[const])\n",
        "            counts.set_fill(GREY_B)\n",
        "\n",
        "            result = VGroup(expr, counts)\n",
        "\n",
        "            if suffix is not None:\n",
        "                label = Text(suffix)\n",
        "                label.match_height(expr)\n",
        "                label.next_to(expr, RIGHT, buff=MED_SMALL_BUFF)\n",
        "                result.add(label)\n",
        "\n",
        "            return result\n",
        "\n",
        "        product_expressions = VGroup(\n",
        "            get_product_expression(category, consts)\n",
        "            for category, consts in zip(category_names, const_lists)\n",
        "        )\n",
        "        exprs = [pe[0] for pe in product_expressions]\n",
        "        counts = [pe[1] for pe in product_expressions]\n",
        "\n",
        "        # Embedding\n",
        "        def highlight_category(*indices):\n",
        "            category_names.target = category_names.generate_target()\n",
        "            category_names.target.set_fill(opacity=0.15, border_width=0)\n",
        "            for index in indices:\n",
        "                category_names.target[index].set_fill(opacity=1, border_width=0.5)\n",
        "            return MoveToTarget(category_names)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(mat_groups),\n",
        "            FadeOut(mat_dots[1:7]),\n",
        "            highlight_category(0)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(exprs[0]),\n",
        "            FadeIn(counts[0], 0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Unembedding\n",
        "        total = Integer(2 * 12_288 * 50_257)\n",
        "        total.to_edge(RIGHT, buff=1.0)\n",
        "        total.set_color(BLUE)\n",
        "        total_box = SurroundingRectangle(total, buff=0.25)\n",
        "        total_box.set_fill(BLACK, 1)\n",
        "        total_box.set_stroke(WHITE, 2)\n",
        "        lines = VGroup(*(Line(exprs[i].get_right(), total_box) for i in [0, 7]))\n",
        "        lines.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.play(\n",
        "            highlight_category(0, 7),\n",
        "            TransformMatchingStrings(exprs[0].copy(), exprs[7]),\n",
        "            TransformFromCopy(counts[0][0].copy(), counts[7][1]),\n",
        "            TransformFromCopy(counts[0][1].copy(), counts[7][0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(lines, lag_ratio=0),\n",
        "            FadeIn(total_box),\n",
        "            FadeTransform(exprs[0][-11:].copy(), total),\n",
        "            FadeTransform(exprs[7][-11:].copy(), total),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(weights_count, time_width=1.5, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(total_box),\n",
        "            FadeOut(total),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Attention matrices\n",
        "        covered_categories = [0, 7]\n",
        "        att_categories = [1, 2, 3, 4]\n",
        "        per_head_factors = [\n",
        "            [\"d_query\", \"d_embed\"],\n",
        "            [\"d_query\", \"d_embed\"],\n",
        "            [\"d_value\", \"d_embed\"],\n",
        "            [\"d_embed\", \"d_value\"],\n",
        "        ]\n",
        "        per_head_exprs = VGroup(\n",
        "            get_product_expression(name, factors, suffix=\"per head\")\n",
        "            for name, factors in zip(category_names[1:5], per_head_factors)\n",
        "        )\n",
        "        per_layer_exprs = VGroup(\n",
        "            get_product_expression(name, factors + [\"n_heads\"], suffix=\"per layer\")\n",
        "            for name, factors in zip(category_names[1:5], per_head_factors)\n",
        "        )\n",
        "        full_att_exprs = product_expressions[1:5]\n",
        "        for group in [per_head_exprs, per_layer_exprs, full_att_exprs]:\n",
        "            sum_box = SurroundingRectangle(\n",
        "                VGroup(expr[0].rhs for expr in group)\n",
        "            )\n",
        "            sum_box.set_stroke(BLUE, 2)\n",
        "            sum_label = Integer(sum(\n",
        "                np.product(list(count.get_value() for count in expr[1]))\n",
        "                for expr in group\n",
        "            ))\n",
        "            sum_label.set_color(BLUE)\n",
        "            sum_label.next_to(sum_box, DOWN)\n",
        "            sum_box.add(sum_label)\n",
        "            group.sum_box = sum_box\n",
        "\n",
        "        self.play(\n",
        "            *(\n",
        "                product_expressions[i].animate.set_fill(opacity=0.25, border_width=0)\n",
        "                for i in covered_categories\n",
        "            ),\n",
        "            highlight_category(att_categories[0]),\n",
        "            FadeIn(per_head_exprs[0], shift=0.5 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, per_head_exprs[1:], shift=0.5 *DOWN, lag_ratio=0.5),\n",
        "            highlight_category(*att_categories),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(per_head_exprs.sum_box, run_time=3, rate_func=there_and_back_with_pause))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(per_head_exprs),\n",
        "            FadeIn(per_layer_exprs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(per_layer_exprs.sum_box, run_time=3, rate_func=there_and_back_with_pause))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(per_layer_exprs),\n",
        "            FadeIn(full_att_exprs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(full_att_exprs.sum_box))\n",
        "        self.wait()\n",
        "\n",
        "        # Compare with total weights\n",
        "        total_weights_rect = SurroundingRectangle(weights_count)\n",
        "        total_weights_rect.set_stroke(BLUE_B, 2)\n",
        "        box = full_att_exprs.sum_box.copy()\n",
        "        box.remove(box.submobjects[0])\n",
        "        self.play(Transform(box, total_weights_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(box),\n",
        "            FadeOut(full_att_exprs.sum_box),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # MLP matrices\n",
        "        mlp_categories = [5, 6]\n",
        "        mlp_exprs = product_expressions[5:7]\n",
        "        per_layer_exprs = VGroup(\n",
        "            get_product_expression(category_names[i], const_lists[i][:2], suffix=\"per layer\")\n",
        "            for i in mlp_categories\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            full_att_exprs.animate.set_fill(opacity=0.25, border_width=0),\n",
        "            highlight_category(*mlp_categories),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(per_layer_exprs[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(per_layer_exprs[0][0].copy(), per_layer_exprs[1][0]),\n",
        "            TransformFromCopy(per_layer_exprs[0][1][0], per_layer_exprs[1][1][1]),\n",
        "            TransformFromCopy(per_layer_exprs[0][1][1], per_layer_exprs[1][1][0]),\n",
        "            TransformFromCopy(per_layer_exprs[0][2], per_layer_exprs[1][2]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(per_layer_exprs),\n",
        "            FadeIn(mlp_exprs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Sum up MLP right hand sides\n",
        "        rhs_rect = SurroundingRectangle(VGroup(expr[0].rhs for expr in mlp_exprs))\n",
        "        rhs_rect.set_stroke(BLUE, 2)\n",
        "        rhs_rect.stretch(1.2, 1, about_edge=DOWN)\n",
        "        c2v = const_to_value\n",
        "        mlp_total = Integer(2 * c2v[\"n_neurons\"] * c2v[\"d_embed\"] * c2v[\"n_layers\"])\n",
        "        mlp_total.next_to(rhs_rect)\n",
        "        mlp_total.set_color(BLUE)\n",
        "        mlp_total_rect = BackgroundRectangle(mlp_total)\n",
        "        mlp_total_rect.set_fill(BLACK, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rhs_rect),\n",
        "            FadeIn(mlp_total_rect),\n",
        "            FadeTransform(mlp_exprs[0][0].rhs.copy(), mlp_total),\n",
        "            FadeTransform(mlp_exprs[1][0].rhs.copy(), mlp_total),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Align all right hand sides\n",
        "        self.play(\n",
        "            category_names.animate.set_fill(opacity=1, border_width=0.5),\n",
        "            product_expressions.animate.set_fill(opacity=1, border_width=0.5),\n",
        "        )\n",
        "\n",
        "        all_rhss = VGroup(\n",
        "            VGroup(expr[0][\"=\"][0], expr[0].rhs)\n",
        "            for expr in product_expressions\n",
        "        )\n",
        "        all_rhss.target = all_rhss.generate_target()\n",
        "        for mob in all_rhss.target:\n",
        "            mob.align_to(product_expressions, RIGHT)\n",
        "            mob.shift(0.5 * RIGHT)\n",
        "        all_rhss_rect = SurroundingRectangle(all_rhss.target)\n",
        "        all_rhss_rect.match_style(rhs_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(mlp_total_rect, RIGHT),\n",
        "            FadeOut(mlp_total, RIGHT),\n",
        "            ReplacementTransform(rhs_rect, all_rhss_rect),\n",
        "            MoveToTarget(all_rhss)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move weights count\n",
        "        self.play(LaggedStart(\n",
        "            h_line.animate.scale(0.5, about_edge=LEFT),\n",
        "            weights_text.animate.arrange(DOWN).scale(1.5).next_to(all_rhss_rect, UP),\n",
        "            FadeOut(mat_text, LEFT),\n",
        "            title.animate.to_edge(LEFT, buff=2.5),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DistinguishWeightsAndData(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up titles\n",
        "        weights_title, data_title = titles = VGroup(\n",
        "            Text(word, font_size=60)\n",
        "            for word in [\"Weights\", \"Data\"]\n",
        "        )\n",
        "        weights_title.set_color(BLUE)\n",
        "        data_title.set_color(GREY_B)\n",
        "\n",
        "        for title, sign in zip(titles, [-1, 1]):\n",
        "            title.set_x(sign * FRAME_WIDTH / 4)\n",
        "            title.to_edge(UP, buff=0.25)\n",
        "            underline = Underline(title, stretch_factor=1.5)\n",
        "            underline.match_color(title)\n",
        "            underline.set_y(title[0].get_y(DOWN) - 0.1)\n",
        "            title.add(underline)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(4.5)\n",
        "        v_line.to_edge(UP, buff=0)\n",
        "        v_line.set_stroke(GREY_A, 2)\n",
        "\n",
        "        # Set up matrices\n",
        "        matrices = VGroup(\n",
        "            WeightMatrix(\n",
        "                shape=(6, 8),\n",
        "                ellipses_row=None,\n",
        "                ellipses_col=None,\n",
        "            )\n",
        "            for n in range(4)\n",
        "        )\n",
        "        matrices.arrange_in_grid(v_buff=1, h_buff=1)\n",
        "        vectors = VGroup(\n",
        "            NumericEmbedding(length=8, ellipses_row=None)\n",
        "            for n in range(8)\n",
        "        )\n",
        "        vectors.arrange(RIGHT)\n",
        "\n",
        "        tensors = VGroup(matrices, vectors)\n",
        "        for group, title in zip(tensors, titles):\n",
        "            group.set_height(2.5)\n",
        "            group.next_to(title, DOWN, buff=0.5)\n",
        "\n",
        "        # Mix up all the numbers\n",
        "        mat_nums = VGroup(\n",
        "            elem\n",
        "            for matrix in matrices\n",
        "            for elem in matrix.get_entries()\n",
        "        )\n",
        "        mat_braces = VGroup(\n",
        "            brace\n",
        "            for matrix in matrices\n",
        "            for brace in matrix.get_brackets()\n",
        "        )\n",
        "        vec_nums = VGroup(\n",
        "            elem\n",
        "            for vector in vectors\n",
        "            for elem in vector.get_entries()\n",
        "        )\n",
        "        vec_braces = VGroup(\n",
        "            brace\n",
        "            for vector in vectors\n",
        "            for brace in vector.get_brackets()\n",
        "        )\n",
        "\n",
        "        def random_point(x_min, x_max, y_min, y_max):\n",
        "            return np.array([\n",
        "                random.uniform(x_min, x_max),\n",
        "                random.uniform(y_min, y_max),\n",
        "                0\n",
        "            ])\n",
        "\n",
        "        all_nums = VGroup(*mat_nums, *vec_nums)\n",
        "        all_nums.shuffle()\n",
        "        for num in all_nums:\n",
        "            states = num.replicate(4)\n",
        "            for state in states[1:]:\n",
        "                state.set_height(0.15)\n",
        "            sign = 1 if num in vec_nums else -1\n",
        "            states[1].move_to(random_point(6.5 * sign, 1 * sign, 0, 3.5))\n",
        "            states[2].move_to(random_point(-8, 8, -4, 4))\n",
        "            states[3].move_to(random_point(-8, 8, -4, 4))\n",
        "            states[3].set_opacity(0)\n",
        "            num.states = states\n",
        "            num.become(states[3])\n",
        "\n",
        "        self.add(all_nums)\n",
        "\n",
        "        # Animations\n",
        "        lag_ratio = 1 / len(all_nums)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (Transform(num, num.states[2], path_arc=PI)\n",
        "                for num in all_nums),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=3\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (LaggedStart(\n",
        "                    (Transform(num, num.states[1])\n",
        "                    for num in group),\n",
        "                    lag_ratio=lag_ratio,\n",
        "                    run_time=2\n",
        "                )\n",
        "                for group in [mat_nums, vec_nums]),\n",
        "                lag_ratio=0.5\n",
        "            ),\n",
        "            ShowCreation(v_line),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(weights_title),\n",
        "            LaggedStart(\n",
        "                (Transform(num, num.states[0])\n",
        "                for num in mat_nums),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeIn(mat_braces, lag_ratio=0.1, time_span=(1, 2)),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(data_title),\n",
        "            LaggedStart(\n",
        "                (Transform(num, num.states[0])\n",
        "                for num in vec_nums),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeIn(vec_braces, lag_ratio=0.1, time_span=(1, 2)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add subtitles\n",
        "        subtitles = VGroup(\n",
        "            Text(\"What defines the model\", font_size=40),\n",
        "            Text(\"What the model processes\", font_size=40),\n",
        "        )\n",
        "        for subtitle, title, group in zip(subtitles, titles, tensors):\n",
        "            subtitle.next_to(title, DOWN)\n",
        "            self.play(\n",
        "                FadeIn(subtitle, lag_ratio=0.1),\n",
        "                group.animate.next_to(subtitle, DOWN, buff=0.5),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class SoftmaxBreakdown(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show example probability distribution\n",
        "        word_strs = ['Dumbledore', 'Flitwick', 'Mcgonagall', 'Quirrell', 'Snape', 'Sprout', 'Trelawney']\n",
        "        words = VGroup(*(Text(word_str, font_size=30) for word_str in word_strs))\n",
        "        values = np.array([-0.8, -5.0, 0.5, 1.5, 3.4, -2.3, 2.5])\n",
        "        prob_values = softmax(values)\n",
        "        chart = BarChart(prob_values, width=10)\n",
        "        chart.bars.set_stroke(width=1)\n",
        "\n",
        "        probs = VGroup(*(DecimalNumber(pv) for pv in prob_values))\n",
        "        probs.arrange(DOWN, buff=0.25)\n",
        "        probs.generate_target()\n",
        "        for prob, bar in zip(probs.target, chart.bars):\n",
        "            prob.scale(0.5)\n",
        "            prob.next_to(bar, UP)\n",
        "\n",
        "        for word, bar in zip(words, chart.bars):\n",
        "            word.scale(0.75)\n",
        "            height = word.get_height()\n",
        "            word.move_to(bar.get_bottom(), LEFT)\n",
        "            word.rotate(-45 * DEGREES, about_point=bar.get_bottom())\n",
        "            word.shift(height * DOWN)\n",
        "\n",
        "        chart.save_state()\n",
        "        for bar in chart.bars:\n",
        "            bar.stretch(0, 1, about_edge=DOWN)\n",
        "        chart.set_opacity(0)\n",
        "\n",
        "        seq_title = Text(\"Sequence of numbers\", font_size=60)\n",
        "        seq_title.next_to(probs, LEFT, buff=0.75)\n",
        "        seq_title.set_color(YELLOW)\n",
        "        prob_title = Text(\"Probability distribution\", font_size=60)\n",
        "        prob_title.set_color(chart.bars[3].get_color())\n",
        "        prob_title.center().to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, probs, shift=0.25 * DOWN, lag_ratio=0.3),\n",
        "            FadeIn(seq_title),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(chart, lag_ratio=0.1),\n",
        "            MoveToTarget(probs),\n",
        "            FadeTransform(seq_title, prob_title),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show constraint between 0 and 1\n",
        "        index = 3\n",
        "        bar = chart.bars[index]\n",
        "        bar.save_state()\n",
        "        prob = probs[index]\n",
        "        prob.bar = bar\n",
        "        max_height = chart.y_axis.get_y(UP) - chart.x_axis.get_y()\n",
        "        prob.f_always.set_value(lambda: prob.bar.get_height() / max_height)\n",
        "        prob.always.match_height(probs[1])\n",
        "        prob.always.next_to(prob.bar, UP)\n",
        "\n",
        "        one_line = DashedLine(*chart.x_axis.get_start_and_end())\n",
        "        one_line.set_stroke(RED, 2)\n",
        "        one_line.align_to(chart.y_axis, UP)\n",
        "\n",
        "        low_line = one_line.copy()\n",
        "        low_line.set_stroke(PINK, 5)\n",
        "        low_line.match_y(chart.x_axis)\n",
        "\n",
        "        self.play(FadeIn(low_line), FadeIn(one_line), FadeOut(prob_title))\n",
        "        self.play(low_line.animate.match_y(one_line))\n",
        "        self.play(FadeOut(low_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(one_line, time_span=(0, 1)),\n",
        "            bar.animate.set_height(max_height, about_edge=DOWN, stretch=True),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            bar.animate.set_height(1e-4, about_edge=DOWN, stretch=True),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Restore(bar))\n",
        "        self.wait()\n",
        "        prob.clear_updaters()\n",
        "\n",
        "        # Show sum\n",
        "        prob_copies = probs.copy()\n",
        "        prob_copies.scale(1.5)\n",
        "        prob_copies.arrange(RIGHT, buff=1.0)\n",
        "        prob_copies.to_edge(UP)\n",
        "        prob_copies.shift(LEFT)\n",
        "        plusses = VGroup(*(\n",
        "            Tex(\"+\").move_to(VGroup(p1, p2))\n",
        "            for p1, p2 in zip(prob_copies, prob_copies[1:])\n",
        "        ))\n",
        "        equals = Tex(\"=\").next_to(prob_copies, RIGHT)\n",
        "        rhs = DecimalNumber(1.00)\n",
        "        rhs.next_to(equals, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(probs, prob_copies),\n",
        "            Write(plusses),\n",
        "            Write(equals),\n",
        "            FadeOut(one_line),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(pc.copy(), rhs)\n",
        "                for pc in prob_copies\n",
        "            ), lag_ratio=0.07)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sum_group = VGroup(*prob_copies, *plusses, equals, rhs)\n",
        "        chart_group = VGroup(chart, probs, words)\n",
        "\n",
        "        # Show example matrix vector output\n",
        "        n = len(words)\n",
        "        vector = NumericEmbedding(length=n, ellipses_row=None)\n",
        "        in_values = np.array([e.get_value() for e in vector.elements])\n",
        "        rows = []\n",
        "        for value in values:\n",
        "            row = np.random.uniform(-1, 1, len(in_values))\n",
        "            row *= value / np.dot(row, in_values)\n",
        "            rows.append(row)\n",
        "        matrix_values = np.array(rows)\n",
        "\n",
        "        matrix = WeightMatrix(\n",
        "            values=matrix_values,\n",
        "            ellipses_row=None,\n",
        "            ellipses_col=None,\n",
        "            num_decimal_places=2,\n",
        "        )\n",
        "        for mob in matrix, vector:\n",
        "            mob.set_height(4)\n",
        "        vector.to_edge(UP).set_x(2.5)\n",
        "        matrix.next_to(vector, LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            chart_group.animate.scale(0.35).to_corner(DL),\n",
        "            FadeOut(sum_group, UP),\n",
        "            FadeIn(matrix, UP),\n",
        "            FadeIn(vector, UP),\n",
        "        ))\n",
        "        eq, rhs = show_matrix_vector_product(self, matrix, vector, x_max=9)\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on output\n",
        "        rhs_rect = SurroundingRectangle(rhs)\n",
        "        rhs_words = Text(\"Not at all a\\nprobability distribution!\")\n",
        "        rhs_words.next_to(rhs_rect, DOWN)\n",
        "\n",
        "        neg_rects = VGroup(*(\n",
        "            SurroundingRectangle(entry)\n",
        "            for entry in rhs.get_entries()\n",
        "            if entry.get_value() < 0\n",
        "        ))\n",
        "        gt1_rects = VGroup(*(\n",
        "            SurroundingRectangle(entry)\n",
        "            for entry in rhs.get_entries()\n",
        "            if entry.get_value() > 1\n",
        "        ))\n",
        "        VGroup(rhs_rect, neg_rects).set_stroke(RED, 4)\n",
        "        gt1_rects.set_stroke(BLUE, 4)\n",
        "\n",
        "        for rect in (*neg_rects, *gt1_rects):\n",
        "            neg = rect in neg_rects\n",
        "            rect.word = Text(\"Negative\" if neg else \"> 1\", font_size=36)\n",
        "            rect.word.match_color(rect)\n",
        "            rect.word.next_to(rhs, RIGHT)\n",
        "            rect.word.match_y(rect)\n",
        "        neg_words = VGroup(*(r.word for r in neg_rects))\n",
        "        gt1_words = VGroup(*(r.word for r in gt1_rects))\n",
        "\n",
        "        sum_arrow = Vector(DOWN).next_to(rhs, DOWN)\n",
        "        sum_sym = Tex(R\"\\sum\", font_size=36).next_to(sum_arrow, LEFT)\n",
        "        sum_num = DecimalNumber(sum(e.get_value() for e in rhs.get_entries()))\n",
        "        sum_num.next_to(sum_arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rhs_rect),\n",
        "            FadeIn(rhs_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(VGroup(rhs_rect), neg_rects),\n",
        "            LaggedStart(*(FadeIn(rect.word, 0.5 * RIGHT) for rect in neg_rects)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(neg_rects, gt1_rects),\n",
        "            FadeTransformPieces(neg_words, gt1_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(rhs_words),\n",
        "                FadeOut(gt1_rects),\n",
        "                FadeOut(gt1_words),\n",
        "            ),\n",
        "            GrowArrow(sum_arrow),\n",
        "            FadeIn(sum_num, DOWN),\n",
        "            FadeIn(sum_sym),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [sum_arrow, sum_sym, sum_num]))\n",
        "\n",
        "        # Preview softmax application\n",
        "        rhs.generate_target()\n",
        "        rhs.target.to_edge(LEFT, buff=1.5)\n",
        "        rhs.target.set_y(0)\n",
        "\n",
        "        softmax_box = Rectangle(width=5, height=6.5)\n",
        "        softmax_box.set_stroke(BLUE, 2)\n",
        "        softmax_box.set_fill(BLUE_E, 0.5)\n",
        "        in_arrow, out_arrow = Vector(RIGHT).replicate(2)\n",
        "        in_arrow.next_to(rhs.target, RIGHT)\n",
        "        softmax_box.next_to(in_arrow, RIGHT)\n",
        "        out_arrow.next_to(softmax_box, RIGHT)\n",
        "\n",
        "        softmax_label = Text(\"softmax\", font_size=60)\n",
        "        softmax_label.move_to(softmax_box)\n",
        "\n",
        "        rhs_values = np.array([e.get_value() for e in rhs.get_entries()])\n",
        "        dist = softmax(rhs_values)\n",
        "        output = DecimalMatrix(dist.reshape((dist.shape[0], 1)))\n",
        "        output.match_height(rhs)\n",
        "        output.next_to(out_arrow, RIGHT)\n",
        "\n",
        "        bars = chart.bars.copy()\n",
        "        for bar, entry in zip(bars, output.get_entries()):\n",
        "            bar.rotate(-PI / 2)\n",
        "            bar.stretch(2, 0)\n",
        "            bar.next_to(output)\n",
        "            bar.match_y(entry)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(matrix, 2 * LEFT),\n",
        "            FadeOut(vector, 3 * LEFT),\n",
        "            FadeOut(eq, 3.5 * LEFT),\n",
        "            FadeOut(chart_group, DL),\n",
        "            GrowArrow(in_arrow),\n",
        "            FadeIn(softmax_box, RIGHT),\n",
        "            FadeIn(softmax_label, RIGHT),\n",
        "            MoveToTarget(rhs),\n",
        "            GrowArrow(out_arrow),\n",
        "            FadeIn(output, RIGHT),\n",
        "            TransformFromCopy(chart.bars, bars),\n",
        "        ), lag_ratio=0.2, run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight larger and smaller parts\n",
        "        rhs_entries = rhs.get_entries()\n",
        "        changer = VGroup(rhs_entries, output.get_entries(), bars)\n",
        "        changer.save_state()\n",
        "        for index in range(4, 0, -1):\n",
        "            changer.target = changer.saved_state.copy()\n",
        "            changer.target.set_fill(border_width=0)\n",
        "            for group in changer.target:\n",
        "                for j, elem in enumerate(group):\n",
        "                    if j != index:\n",
        "                        elem.fade(0.8)\n",
        "            self.play(MoveToTarget(changer))\n",
        "            self.wait()\n",
        "        self.play(Restore(changer))\n",
        "        self.remove(changer)\n",
        "        self.add(rhs, output, bars)\n",
        "        self.wait()\n",
        "\n",
        "        # Swap out for variables\n",
        "        variables = VGroup(*(\n",
        "            Tex(f\"x_{{{n}}}\", font_size=48).move_to(elem)\n",
        "            for n, elem in enumerate(rhs_entries, start=1)\n",
        "        ))\n",
        "\n",
        "        self.remove(rhs_entries)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(entry, variable, path_arc=PI / 2)\n",
        "                for entry, variable in zip(rhs_entries, variables)\n",
        "            ), lag_ratio=0.1, run_time=1.0)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Exponentiate each part\n",
        "        exp_parts = VGroup(*(\n",
        "            Tex(f\"e^{{{var.get_tex()}}}\", font_size=48).move_to(var)\n",
        "            for var in variables\n",
        "        ))\n",
        "        exp_parts.align_to(softmax_box, LEFT)\n",
        "        exp_parts.shift(0.75 * RIGHT)\n",
        "        exp_parts.space_out_submobjects(1.5)\n",
        "        gt0s = VGroup(\n",
        "            Tex(R\"> 0\").next_to(exp_part, aligned_edge=DOWN)\n",
        "            for exp_part in exp_parts\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            softmax_label.animate.next_to(softmax_box, UP, buff=0.15),\n",
        "            LaggedStart(*(\n",
        "                TransformMatchingStrings(var.copy(), exp_part)\n",
        "                for var, exp_part in zip(variables, exp_parts)\n",
        "            ), run_time=1, lag_ratio=0.01)\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, gt0s, shift=0.5 * RIGHT, lag_ratio=0.25, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(gt0s))\n",
        "\n",
        "        # Compute the sum\n",
        "        exp_sum = Tex(R\"\\sum_{n=0}^{N-1} e^{x_{n}}\", font_size=42)\n",
        "        exp_sum[R\"e^{x_{n}}\"].scale(1.5, about_edge=LEFT)\n",
        "        exp_sum.next_to(softmax_box.get_right(), LEFT, buff=0.75)\n",
        "\n",
        "        lines = VGroup(*(Line(exp_part.get_right(), exp_sum.get_left(), buff=0.1) for exp_part in exp_parts))\n",
        "        lines.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(exp_part.copy(), exp_sum)\n",
        "                for exp_part in exp_parts\n",
        "            ), lag_ratio=0.01),\n",
        "            LaggedStartMap(ShowCreation, lines, lag_ratio=0.01),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(lines))\n",
        "\n",
        "        # Divide each part by the sum\n",
        "        lil_denoms = VGroup()\n",
        "        for exp_part in exp_parts:\n",
        "            slash = Tex(\"/\").match_height(exp_sum)\n",
        "            slash.next_to(exp_sum, LEFT, buff=0)\n",
        "            denom = VGroup(slash, exp_sum).copy()\n",
        "            denom.set_height(exp_part.get_height() * 1.5)\n",
        "            denom.next_to(exp_part, RIGHT, buff=0)\n",
        "            lil_denoms.add(denom)\n",
        "        lil_denoms.align_to(softmax_box.get_center(), LEFT)\n",
        "\n",
        "        lines = VGroup(*(Line(exp_sum.get_left(), denom.get_center()) for denom in lil_denoms))\n",
        "        lines.set_stroke(TEAL, 1)\n",
        "\n",
        "        self.remove(exp_sum)\n",
        "        self.play(\n",
        "            exp_parts.animate.next_to(lil_denoms, LEFT, buff=0),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(exp_sum.copy(), denom)\n",
        "                for denom in lil_denoms\n",
        "            ), lag_ratio=0.01),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Resize box\n",
        "        sm_terms = VGroup(*(\n",
        "            VGroup(exp_part, denom)\n",
        "            for exp_part, denom in zip(exp_parts, lil_denoms)\n",
        "        ))\n",
        "        sm_terms.generate_target()\n",
        "\n",
        "        target_height = 5.0\n",
        "        full_output = Group(output, bars)\n",
        "        full_output.generate_target()\n",
        "        full_output.target.set_height(target_height, about_edge=RIGHT)\n",
        "        full_output.target.shift(1.5 * LEFT)\n",
        "        equals = Tex(\"=\")\n",
        "        equals.next_to(full_output.target, LEFT)\n",
        "\n",
        "        softmax_box.generate_target()\n",
        "        softmax_box.target.set_width(3.0, stretch=True)\n",
        "        VGroup(softmax_box.target, sm_terms.target).set_height(target_height + 0.5).next_to(equals, LEFT)\n",
        "\n",
        "        rhs.generate_target()\n",
        "        rhs_entries.become(variables)\n",
        "        self.remove(variables)\n",
        "        rhs.target.set_height(target_height)\n",
        "        rhs.target.next_to(softmax_box.target, LEFT, buff=1.5)\n",
        "\n",
        "        self.play(\n",
        "            softmax_label.animate.next_to(softmax_box.target, UP),\n",
        "            MoveToTarget(softmax_box),\n",
        "            MoveToTarget(sm_terms),\n",
        "            MoveToTarget(full_output),\n",
        "            MoveToTarget(rhs),\n",
        "            FadeTransform(out_arrow, equals),\n",
        "            in_arrow.animate.become(\n",
        "                Arrow(rhs.target, softmax_box.target).match_style(in_arrow)\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Set up updaters\n",
        "        output_entries = output.get_entries()\n",
        "        bar_width_ratio = bars.get_width() / max(o.get_value() for o in output_entries)\n",
        "        temp_tracker = ValueTracker(1)\n",
        "\n",
        "        def update_outs(output_entries):\n",
        "            inputs = [entry.get_value() for entry in rhs_entries]\n",
        "            outputs = softmax(inputs, temp_tracker.get_value())\n",
        "            for entry, output in zip(output_entries, outputs):\n",
        "                entry.set_value(output)\n",
        "\n",
        "        def update_bars(bars):\n",
        "            for bar, entry in zip(bars, output_entries):\n",
        "                width = max(bar_width_ratio * entry.get_value(), 1e-3)\n",
        "                bar.set_width(width, about_edge=LEFT, stretch=True)\n",
        "\n",
        "        output_entries.clear_updaters().save_state()\n",
        "        bars.clear_updaters().save_state()\n",
        "        output_entries.add_updater(update_outs)\n",
        "        bars.add_updater(update_bars)\n",
        "\n",
        "        self.add(bars, output_entries)\n",
        "\n",
        "        # Tweak values\n",
        "        index_value_pairs = [\n",
        "            (6, 4.0),\n",
        "            (4, 4.2),\n",
        "            (2, 4.0),\n",
        "            (0, 6.0),\n",
        "            (4, 9.9)\n",
        "        ]\n",
        "        # index_value_pairs = [  # For emphasizing a max\n",
        "        #     (3, 8.5),\n",
        "        #     (6, 8.0),\n",
        "        #     (2, 8.1),\n",
        "        #     (0, 9.0),\n",
        "        # ]\n",
        "        for index, value in index_value_pairs:\n",
        "            entry = rhs_entries[index]\n",
        "            rect = SurroundingRectangle(entry)\n",
        "            rect.set_stroke(BLUE if value > entry.get_value() else RED, 3)\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(entry, value),\n",
        "                FadeIn(rect, time_span=(0, 1)),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.play(FadeOut(rect))\n",
        "\n",
        "        # Add temperature\n",
        "        frame = self.frame\n",
        "        temp_color = RED\n",
        "        new_title = Text(\"softmax with temperature\")\n",
        "        new_title[\"temperature\"].set_color(temp_color)\n",
        "        get_t = temp_tracker.get_value\n",
        "        t_line = NumberLine(\n",
        "            (0, 10, 0.2),\n",
        "            tick_size=0.025,\n",
        "            big_tick_spacing=1,\n",
        "            longer_tick_multiple=2.0,\n",
        "            width=4\n",
        "        )\n",
        "        t_line.set_stroke(width=1.5)\n",
        "        t_line.next_to(softmax_box, UP)\n",
        "        t_tri = ArrowTip(angle=-90 * DEGREES)\n",
        "        t_tri.set_color(temp_color)\n",
        "        t_tri.set_height(0.2)\n",
        "        t_label = Tex(\"T = 0.00\", font_size=36)\n",
        "        t_label.rhs = t_label.make_number_changeable(\"0.00\")\n",
        "        t_label[\"T\"].set_color(temp_color)\n",
        "        t_tri.add_updater(lambda m: m.move_to(t_line.n2p(get_t()), DOWN))\n",
        "        t_label.add_updater(lambda m: m.rhs.set_value(get_t()))\n",
        "        t_label.add_updater(lambda m: m.next_to(t_tri, UP, buff=0.1, aligned_edge=LEFT))\n",
        "        t_label.update()\n",
        "\n",
        "        new_title.next_to(t_label, UP, buff=0.5).match_x(softmax_box)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.move_to(0.75 * UP),\n",
        "            TransformMatchingStrings(softmax_label, new_title),\n",
        "            FadeIn(t_line),\n",
        "            FadeIn(t_tri),\n",
        "            FadeIn(t_label),\n",
        "            run_time=1\n",
        "        )\n",
        "\n",
        "        # Change formula\n",
        "        template = Tex(R\"e^{x_{0} / T} / \\sum_{n=0}^{N - 1} e^{x_n / T}\")\n",
        "        template[\"T\"].set_color(temp_color)\n",
        "        template[\"/\"][1].scale(1.9, about_edge=LEFT)\n",
        "        template[R\"\\sum_{n=0}^{N - 1}\"][0].scale(0.7, about_edge=RIGHT)\n",
        "        index_part = template.make_number_changeable(\"0\")\n",
        "\n",
        "        new_sm_terms = VGroup()\n",
        "        all_Ts = VGroup()\n",
        "        for n, term in enumerate(sm_terms, start=1):\n",
        "            template.replace(term, dim_to_match=1)\n",
        "            index_part.set_value(n)\n",
        "            new_term = template.copy()\n",
        "            all_Ts.add(*new_term[\"T\"])\n",
        "            new_sm_terms.add(new_term)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(old_term, new_term)\n",
        "                for old_term, new_term in zip(sm_terms, new_sm_terms)\n",
        "            )),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(t_label[0], t_mob[0])\n",
        "                for t_mob in all_Ts\n",
        "            )),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Oscilate between values\n",
        "        for value in [4, 10, 2]:\n",
        "            self.play(temp_tracker.animate.set_value(value), run_time=8)\n",
        "            self.wait()\n",
        "        self.play(temp_tracker.animate.set_value(0), run_time=3)\n",
        "        max_rects = VGroup(\n",
        "            SurroundingRectangle(rhs.get_entries()[4]),\n",
        "            SurroundingRectangle(VGroup(output.get_entries()[4], bars[4])),\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreationThenFadeOut, max_rects))\n",
        "        self.wait()\n",
        "        for value in [5, 1, 7]:\n",
        "            self.play(temp_tracker.animate.set_value(value), run_time=4)\n",
        "            self.wait()\n",
        "\n",
        "        # Describe logits\n",
        "        prob_arrows, logit_arrows = (\n",
        "            VGroup(*(\n",
        "                Vector(-vect).next_to(entry, vect, buff=0.25)\n",
        "                for entry in matrix.get_entries()\n",
        "            ))\n",
        "            for matrix, vect in [(output, RIGHT), (rhs, LEFT)]\n",
        "        )\n",
        "        prob_arrows.next_to(bars, RIGHT)\n",
        "        prob_rects = VGroup(*map(SurroundingRectangle, output.get_entries()))\n",
        "        logit_rects = VGroup(*map(SurroundingRectangle, rhs.get_entries()))\n",
        "        VGroup(prob_rects, logit_rects).set_stroke(width=1)\n",
        "\n",
        "        prob_words = Text(\"Probabilities\")\n",
        "        prob_words.next_to(output, UP, buff=0.25)\n",
        "        logit_words = Text(\"Logits\")\n",
        "        logit_words.next_to(rhs, UP, buff=0.25)\n",
        "\n",
        "        logit_group = VGroup(logit_arrows, logit_words, logit_rects)\n",
        "        logit_group.set_color(TEAL)\n",
        "        prob_group = VGroup(prob_arrows, prob_words, prob_rects)\n",
        "        prob_group.set_color(YELLOW)\n",
        "\n",
        "        for arrows, word, rects in [prob_group, logit_group]:\n",
        "            self.play(\n",
        "                t_line.animate.set_y(3.35),\n",
        "                Write(word),\n",
        "                Write(rects, stroke_width=5, stroke_color=rects[0].get_stroke_color(), lag_ratio=0.3, run_time=3),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class CostFunction(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add graph\n",
        "        axes = Axes((0, 1, 0.1), (0, 5, 1), width=10, height=6)\n",
        "        axes.center().to_edge(LEFT)\n",
        "        axes.x_axis.add_numbers(num_decimal_places=1)\n",
        "        axes.y_axis.add_numbers(num_decimal_places=0, direction=LEFT)\n",
        "        x_label = Tex(\"p\")\n",
        "        x_label.next_to(axes.x_axis.get_right(), UR)\n",
        "        axes.add(x_label)\n",
        "\n",
        "        graph = axes.get_graph(lambda x: -np.log(x), x_range=(0.001, 10, 0.01))\n",
        "        graph.set_color(RED)\n",
        "\n",
        "        expr = Tex(R\"\\text{Cost} = -\\log(p)\", font_size=60)\n",
        "        expr.next_to(axes.i2gp(0.1, graph), UR, buff=0.1)\n",
        "\n",
        "        self.add(axes, graph, expr)\n",
        "\n",
        "        # Add sample phrase\n",
        "        phrase = Text(\"Watching 3Blue1Brown makes you smarter\")\n",
        "        phrase.scale(0.75)\n",
        "        phrase.to_edge(UP)\n",
        "        phrase.align_to(axes.c2p(0.1, 0), LEFT)\n",
        "        pieces = break_into_tokens(phrase)\n",
        "        pieces[-1].set_opacity(0.0)\n",
        "        rects = get_piece_rectangles(pieces, leading_spaces=True, h_buff=0)\n",
        "\n",
        "        self.add(rects, pieces)\n",
        "\n",
        "        # Add predictions\n",
        "        arrow = Vector(0.5 * DOWN)\n",
        "        arrow.next_to(rects[-1], DOWN, SMALL_BUFF)\n",
        "        index = 0\n",
        "\n",
        "        tokens, probs = gpt3_predict_next_token(phrase.get_text()[:-len(\" smarter\")])\n",
        "        bar_chart = next_token_bar_chart(\n",
        "            tokens[:8], probs[:8],\n",
        "            width_100p=7.0,\n",
        "            bar_space_factor=1.0,\n",
        "            use_percent=False,\n",
        "        )\n",
        "        bar_chart.next_to(arrow, DOWN)\n",
        "        bar_chart.shift(1.25 * RIGHT)\n",
        "        bar_chart.set_opacity(0.5)\n",
        "        bar_chart[index].set_opacity(1.0)\n",
        "        rect = SurroundingRectangle(bar_chart[index])\n",
        "\n",
        "        self.add(arrow, bar_chart, rect)\n",
        "\n",
        "        # Animate in graph\n",
        "        self.play(\n",
        "            ShowCreation(graph, run_time=3),\n",
        "            Write(expr, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show point on the graph\n",
        "        line = axes.get_line_from_axis_to_point(0, axes.i2gp(probs[index], graph), line_func=Line)\n",
        "        line.set_stroke(YELLOW)\n",
        "\n",
        "        self.play(FadeTransform(rect.copy(), line))\n",
        "        self.wait()\n"
    ]
}