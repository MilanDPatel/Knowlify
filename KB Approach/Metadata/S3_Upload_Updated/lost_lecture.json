{
    "topic": "The mathematical concept being demonstrated is the orbit of a planet around a star. The code animates the",
    "code": [
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from _2018.div_curl import VectorField\n",
        "from _2018.div_curl import get_force_field_func\n",
        "\n",
        "COBALT = \"#0047AB\"\n",
        "\n",
        "\n",
        "# Warning, this file uses ContinualChangingDecimal,\n",
        "# which has since been been deprecated.  Use a mobject\n",
        "# updater instead\n",
        "\n",
        "\n",
        "# TODO, this is untested after turning it from a\n",
        "# ContinualAnimation into a VGroup\n",
        "class Orbiting(VGroup):\n",
        "    CONFIG = {\n",
        "        \"rate\": 7.5,\n",
        "    }\n",
        "\n",
        "    def __init__(self, planet, star, ellipse, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        self.add(planet)\n",
        "        self.planet = planet\n",
        "        self.star = star\n",
        "        self.ellipse = ellipse\n",
        "        # Proportion of the way around the ellipse\n",
        "        self.proportion = 0\n",
        "        planet.move_to(ellipse.point_from_proportion(0))\n",
        "\n",
        "        self.add_updater(lambda m, dt: m.update(dt))\n",
        "\n",
        "    def update(self, dt):\n",
        "        # time = self.internal_time\n",
        "\n",
        "        planet = self.planet\n",
        "        star = self.star\n",
        "        ellipse = self.ellipse\n",
        "\n",
        "        rate = self.rate\n",
        "        radius_vector = planet.get_center() - star.get_center()\n",
        "        rate *= 1.0 / get_norm(radius_vector)\n",
        "\n",
        "        prop = self.proportion\n",
        "        d_prop = 0.001\n",
        "        ds = get_norm(op.add(\n",
        "            ellipse.point_from_proportion((prop + d_prop) % 1),\n",
        "            -ellipse.point_from_proportion(prop),\n",
        "        ))\n",
        "\n",
        "        delta_prop = (d_prop / ds) * rate * dt\n",
        "\n",
        "        self.proportion = (self.proportion + delta_prop) % 1\n",
        "        planet.move_to(\n",
        "            ellipse.point_from_proportion(self.proportion)\n",
        "        )\n",
        "\n",
        "\n",
        "# TODO, this is untested after turning it from a\n",
        "# ContinualAnimation into a Group\n",
        "class SunAnimation(Group):\n",
        "    CONFIG = {\n",
        "        \"rate\": 0.2,\n",
        "        \"angle\": 60 * DEGREES,\n",
        "    }\n",
        "\n",
        "    def __init__(self, sun, **kwargs):\n",
        "        Group.__init__(self, **kwargs)\n",
        "        self.sun = sun\n",
        "        self.rotated_sun = sun.deepcopy()\n",
        "        self.rotated_sun.rotate(60 * DEGREES)\n",
        "        self.time = 0\n",
        "\n",
        "        self.add(self.sun, self.rotated_sun)\n",
        "        self.add_updater(lambda m, dt: m.update(dt))\n",
        "\n",
        "    def update(self, dt):\n",
        "        time = self.time\n",
        "        self.time += dt\n",
        "        a = (np.sin(self.rate * time * TAU) + 1) / 2.0\n",
        "        self.rotated_sun.rotate(-self.angle)\n",
        "        self.rotated_sun.move_to(self.sun)\n",
        "        self.rotated_sun.rotate(self.angle)\n",
        "        self.rotated_sun.pixel_array = np.array(\n",
        "            a * self.sun.pixel_array,\n",
        "            dtype=self.sun.pixel_array.dtype\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowWord(Animation):\n",
        "    CONFIG = {\n",
        "        \"time_per_char\": 0.06,\n",
        "        \"rate_func\": linear,\n",
        "    }\n",
        "\n",
        "    def __init__(self, word, **kwargs):\n",
        "        assert(isinstance(word, SingleStringTex))\n",
        "        digest_config(self, kwargs)\n",
        "        run_time = kwargs.pop(\n",
        "            \"run_time\",\n",
        "            self.time_per_char * len(word)\n",
        "        )\n",
        "        self.stroke_width = word.get_stroke_width()\n",
        "        Animation.__init__(self, word, run_time=run_time, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        word = self.mobject\n",
        "        stroke_width = self.stroke_width\n",
        "        count = int(alpha * len(word))\n",
        "        remainder = (alpha * len(word)) % 1\n",
        "        word[:count].set_fill(opacity=1)\n",
        "        word[:count].set_stroke(width=stroke_width)\n",
        "        if count < len(word):\n",
        "            word[count].set_fill(opacity=remainder)\n",
        "            word[count].set_stroke(width=remainder * stroke_width)\n",
        "            word[count + 1:].set_fill(opacity=0)\n",
        "            word[count + 1:].set_stroke(width=0)\n",
        "\n",
        "# Animations\n",
        "\n",
        "\n",
        "class TakeOver(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "            \"flip_at_start\": True,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DR,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        gradient = ImageMobject(\"white_black_gradient\")\n",
        "        gradient.set_height(FRAME_HEIGHT)\n",
        "        self.add(gradient)\n",
        "\n",
        "        morty = self.pi_creatures\n",
        "        henry = ImageMobject(\"Henry_As_Stick\")\n",
        "        henry.set_height(4)\n",
        "        henry.to_edge(LEFT)\n",
        "        henry.to_edge(DOWN)\n",
        "\n",
        "        self.add(morty, henry)\n",
        "        self.pi_creature_says(\n",
        "            \"Muahaha!  All \\\\\\\\ mine now.\",\n",
        "            bubble_config={\"fill_opacity\": 0.5},\n",
        "            bubble_creation_class=FadeIn,\n",
        "            target_mode=\"conniving\",\n",
        "            added_anims=[henry.rotate, 5 * DEGREES]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ShowEmergingEllipse(Scene):\n",
        "    CONFIG = {\n",
        "        \"circle_radius\": 3,\n",
        "        \"circle_color\": BLUE,\n",
        "        \"num_lines\": 150,\n",
        "        \"lines_stroke_width\": 1,\n",
        "        \"eccentricity_vector\": 2 * RIGHT,\n",
        "        \"ghost_lines_stroke_color\": GREY_B,\n",
        "        \"ghost_lines_stroke_width\": 0.5,\n",
        "        \"ellipse_color\": PINK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        circle = self.get_circle()\n",
        "        e_point = self.get_eccentricity_point()\n",
        "        e_dot = Dot(e_point, color=YELLOW)\n",
        "        lines = self.get_lines()\n",
        "        ellipse = self.get_ellipse()\n",
        "\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "\n",
        "        line = lines[len(lines) // 5]\n",
        "        line_dot = Dot(line.get_center(), color=YELLOW)\n",
        "        line_dot.scale(0.5)\n",
        "\n",
        "        ghost_line = self.get_ghost_lines(line)\n",
        "        ghost_lines = self.get_ghost_lines(lines)\n",
        "\n",
        "        rot_words = OldTexText(\"Rotate $90^\\\\circ$ \\\\\\\\ about center\")\n",
        "        rot_words.next_to(line_dot, RIGHT)\n",
        "\n",
        "        elbow = self.get_elbow(line)\n",
        "\n",
        "        eccentric_words = OldTexText(\"``Eccentric'' point\")\n",
        "        eccentric_words.next_to(circle.get_center(), DOWN)\n",
        "\n",
        "        ellipse_words = OldTexText(\"Perfect ellipse\")\n",
        "        ellipse_words.next_to(ellipse, UP, SMALL_BUFF)\n",
        "\n",
        "        for text in rot_words, ellipse_words:\n",
        "            text.add_to_back(text.copy().set_stroke(BLACK, 5))\n",
        "\n",
        "        shuffled_lines = VGroup(*lines)\n",
        "        random.shuffle(shuffled_lines.submobjects)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(\n",
        "            FadeIn(e_dot, LEFT),\n",
        "            Write(eccentric_words, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, shuffled_lines),\n",
        "            Animation(VGroup(e_dot, circle)),\n",
        "            FadeOut(eccentric_words)\n",
        "        )\n",
        "        self.add(ghost_lines)\n",
        "        self.add(e_dot, circle)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            Animation(line),\n",
        "            GrowFromCenter(line_dot),\n",
        "            FadeInFromDown(rot_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(ghost_line)\n",
        "        self.play(\n",
        "            MoveToTarget(line, path_arc=90 * DEGREES),\n",
        "            Animation(rot_words),\n",
        "            ShowCreation(elbow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(fade_rect),\n",
        "            FadeOut(line_dot),\n",
        "            FadeOut(rot_words),\n",
        "            FadeOut(elbow),\n",
        "            Animation(line),\n",
        "            Animation(ghost_line)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, lines, run_time=4),\n",
        "            Animation(VGroup(e_dot, circle))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(ellipse),\n",
        "            FadeInFromDown(ellipse_words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_circle(self):\n",
        "        circle = self.circle = Circle(\n",
        "            radius=self.circle_radius,\n",
        "            color=self.circle_color\n",
        "        )\n",
        "        return circle\n",
        "\n",
        "    def get_eccentricity_point(self):\n",
        "        return self.circle.get_center() + self.eccentricity_vector\n",
        "\n",
        "    def get_lines(self):\n",
        "        center = self.circle.get_center()\n",
        "        radius = self.circle.get_width() / 2\n",
        "        e_point = self.get_eccentricity_point()\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                e_point,\n",
        "                center + rotate_vector(radius * RIGHT, angle)\n",
        "            )\n",
        "            for angle in np.linspace(0, TAU, self.num_lines)\n",
        "        ])\n",
        "        lines.set_stroke(width=self.lines_stroke_width)\n",
        "        for line in lines:\n",
        "            line.generate_target()\n",
        "            line.target.rotate(90 * DEGREES)\n",
        "        return lines\n",
        "\n",
        "    def get_ghost_lines(self, lines):\n",
        "        return lines.copy().set_stroke(\n",
        "            color=self.ghost_lines_stroke_color,\n",
        "            width=self.ghost_lines_stroke_width\n",
        "        )\n",
        "\n",
        "    def get_elbow(self, line):\n",
        "        elbow = VGroup(Line(UP, UL), Line(UL, LEFT))\n",
        "        elbow.set_stroke(width=1)\n",
        "        elbow.scale(0.2, about_point=ORIGIN)\n",
        "        elbow.rotate(\n",
        "            line.get_angle() - 90 * DEGREES,\n",
        "            about_point=ORIGIN\n",
        "        )\n",
        "        elbow.shift(line.get_center())\n",
        "        return elbow\n",
        "\n",
        "    def get_ellipse(self):\n",
        "        center = self.circle.get_center()\n",
        "        e_point = self.get_eccentricity_point()\n",
        "        radius = self.circle.get_width() / 2\n",
        "\n",
        "        # Ellipse parameters\n",
        "        a = radius / 2\n",
        "        c = get_norm(e_point - center) / 2\n",
        "        b = np.sqrt(a**2 - c**2)\n",
        "\n",
        "        result = Circle(radius=b, color=self.ellipse_color)\n",
        "        result.stretch(a / b, 0)\n",
        "        result.move_to(Line(center, e_point))\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShowFullStory(Scene):\n",
        "    def construct(self):\n",
        "        directory = os.path.join(\n",
        "            MEDIA_DIR,\n",
        "            \"animations/active_projects/lost_lecture/images\"\n",
        "        )\n",
        "        scene_names = [\n",
        "            \"ShowEmergingEllipse\",\n",
        "            \"ShowFullStory\",\n",
        "            \"FeynmanFameStart\",\n",
        "            \"TheMotionOfPlanets\",\n",
        "            \"FeynmanElementaryQuote\",\n",
        "            \"DrawingEllipse\",\n",
        "            \"ShowEllipseDefiningProperty\",\n",
        "            \"ProveEllipse\",\n",
        "            \"KeplersSecondLaw\",\n",
        "            \"AngularMomentumArgument\",\n",
        "            \"HistoryOfAngularMomentum\",\n",
        "            \"FeynmanRecountingNewton\",\n",
        "            \"IntroduceShapeOfVelocities\",\n",
        "            \"ShowEqualAngleSlices\",\n",
        "            \"PonderOverOffCenterDiagram\",\n",
        "            \"UseVelocityDiagramToDeduceCurve\",\n",
        "        ]\n",
        "        images = Group(*[\n",
        "            ImageMobject(os.path.join(directory, name + \".png\"))\n",
        "            for name in scene_names\n",
        "        ])\n",
        "        for image in images:\n",
        "            image.add(\n",
        "                SurroundingRectangle(image, buff=0, color=WHITE)\n",
        "            )\n",
        "        images.arrange_in_grid(n_rows=4)\n",
        "\n",
        "        images.scale(\n",
        "            1.01 * FRAME_WIDTH / images[0].get_width()\n",
        "        )\n",
        "        images.shift(-images[0].get_center())\n",
        "\n",
        "        self.play(\n",
        "            images.set_width, FRAME_WIDTH - 1,\n",
        "            images.center,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            images.shift, -images[2].get_center(),\n",
        "            images.scale, FRAME_WIDTH / images[2].get_width(),\n",
        "            {\"about_point\": ORIGIN},\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FeynmanAndOrbitingPlannetOnEllipseDiagram(ShowEmergingEllipse):\n",
        "    def construct(self):\n",
        "        circle = self.get_circle()\n",
        "        lines = self.get_lines()\n",
        "        ghost_lines = self.get_ghost_lines(lines)\n",
        "        for line in lines:\n",
        "            MoveToTarget(line).update(1)\n",
        "        ellipse = self.get_ellipse()\n",
        "        e_dot = Dot(self.get_eccentricity_point())\n",
        "        e_dot.set_color(YELLOW)\n",
        "\n",
        "        comet = ImageMobject(\"earth\")\n",
        "        comet.set_width(0.3)\n",
        "\n",
        "        feynman = ImageMobject(\"Feynman\")\n",
        "        feynman.set_height(6)\n",
        "        feynman.next_to(ORIGIN, LEFT)\n",
        "        feynman.to_edge(UP)\n",
        "        feynman_name = OldTexText(\"Richard Feynman\")\n",
        "        feynman_name.next_to(feynman, DOWN)\n",
        "        feynman.save_state()\n",
        "        feynman.shift(2 * DOWN)\n",
        "        feynman_rect = BackgroundRectangle(\n",
        "            feynman, fill_opacity=1\n",
        "        )\n",
        "\n",
        "        group = VGroup(circle, ghost_lines, lines, e_dot, ellipse)\n",
        "\n",
        "        self.add(group)\n",
        "        self.add(Orbiting(comet, e_dot, ellipse))\n",
        "        self.add_foreground_mobjects(comet)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            feynman.restore,\n",
        "            MaintainPositionRelativeTo(feynman_rect, feynman),\n",
        "            VFadeOut(feynman_rect),\n",
        "            group.to_edge, RIGHT,\n",
        "        )\n",
        "        self.play(Write(feynman_name))\n",
        "        self.wait()\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class FeynmanFame(Scene):\n",
        "    def construct(self):\n",
        "        books = VGroup(\n",
        "            ImageMobject(\"Feynman_QED_cover\"),\n",
        "            ImageMobject(\"Surely_Youre_Joking_cover\"),\n",
        "            ImageMobject(\"Feynman_Lectures_cover\"),\n",
        "        )\n",
        "        for book in books:\n",
        "            book.set_height(6)\n",
        "            book.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "\n",
        "        feynman_diagram = self.get_feynman_diagram()\n",
        "        feynman_diagram.next_to(ORIGIN, RIGHT)\n",
        "        fd_parts = VGroup(*reversed(feynman_diagram.family_members_with_points()))\n",
        "\n",
        "        # As a physicist\n",
        "        self.play(self.get_book_intro(books[0]))\n",
        "        self.play(LaggedStartMap(\n",
        "            Write, feynman_diagram,\n",
        "            run_time=4\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.get_book_intro(books[1]),\n",
        "            self.get_book_outro(books[0]),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, fd_parts,\n",
        "                lambda m: (m.scale, 0),\n",
        "                run_time=1\n",
        "            ),\n",
        "        )\n",
        "        self.remove(feynman_diagram)\n",
        "        self.wait()\n",
        "\n",
        "        # As a public figure\n",
        "        safe = SVGMobject(file_name=\"safe\", height=2)\n",
        "        safe_rect = SurroundingRectangle(safe, buff=0)\n",
        "        safe_rect.set_stroke(width=0)\n",
        "        safe_rect.set_fill(GREY_D, 1)\n",
        "        safe.add_to_back(safe_rect)\n",
        "\n",
        "        bongo = SVGMobject(file_name=\"bongo\")\n",
        "        bongo.set_height(1)\n",
        "        bongo.set_color(WHITE)\n",
        "        bongo.next_to(safe, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        objects = VGroup(safe, bongo)\n",
        "\n",
        "        feynman_smile = ImageMobject(\"Feynman_Los_Alamos\")\n",
        "        feynman_smile.set_height(4)\n",
        "        feynman_smile.next_to(objects, DOWN)\n",
        "\n",
        "        VGroup(objects, feynman_smile).next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        joke = OldTexText(\n",
        "            \"``Science is the belief \\\\\\\\ in the ignorance of \\\\\\\\ experts.''\"\n",
        "        )\n",
        "        joke.move_to(objects)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, objects,\n",
        "            lag_ratio=0.75\n",
        "        ))\n",
        "        self.play(self.get_book_intro(feynman_smile))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            objects.shift, 2 * UP,\n",
        "            VFadeOut(objects)\n",
        "        )\n",
        "        self.play(Write(joke))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            self.get_book_intro(books[2]),\n",
        "            self.get_book_outro(books[1]),\n",
        "            LaggedStartMap(FadeOut, joke, run_time=1),\n",
        "            ApplyMethod(\n",
        "                feynman_smile.shift, FRAME_HEIGHT * DOWN,\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # As a teacher\n",
        "        feynman_teacher = ImageMobject(\"Feynman_teaching\")\n",
        "        feynman_teacher.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        feynman_teacher.next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        self.play(self.get_book_intro(feynman_teacher))\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_book_animation(self, book,\n",
        "                           initial_shift,\n",
        "                           animated_shift,\n",
        "                           opacity_func\n",
        "                           ):\n",
        "        rect = BackgroundRectangle(book, fill_opacity=1)\n",
        "        book.shift(initial_shift)\n",
        "\n",
        "        return AnimationGroup(\n",
        "            ApplyMethod(book.shift, animated_shift),\n",
        "            UpdateFromAlphaFunc(\n",
        "                rect, lambda r, a: r.move_to(book).set_fill(\n",
        "                    opacity=opacity_func(a)\n",
        "                ),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def get_book_intro(self, book):\n",
        "        return self.get_book_animation(\n",
        "            book, 2 * DOWN, 2 * UP, lambda a: 1 - a\n",
        "        )\n",
        "\n",
        "    def get_book_outro(self, book):\n",
        "        return ApplyMethod(book.shift, FRAME_HEIGHT * UP, remover=True)\n",
        "\n",
        "    def get_feynman_diagram(self):\n",
        "        x_min = -1.5\n",
        "        x_max = 1.5\n",
        "        arrow = Arrow(LEFT, RIGHT, buff=0)\n",
        "        arrow.tip.move_to(arrow.get_center())\n",
        "        arrows = VGroup(*[\n",
        "            arrow.copy().rotate(angle).next_to(point, vect, buff=0)\n",
        "            for (angle, point, vect) in [\n",
        "                (-45 * DEGREES, x_min * RIGHT, UL),\n",
        "                (-135 * DEGREES, x_min * RIGHT, DL),\n",
        "                (-135 * DEGREES, x_max * RIGHT, UR),\n",
        "                (-45 * DEGREES, x_max * RIGHT, DR),\n",
        "            ]\n",
        "        ])\n",
        "        labels = VGroup(*[\n",
        "            OldTex(tex)\n",
        "            for tex in [\"e^-\", \"e^+\", \"\\\\text{\\\\=q}\", \"q\"]\n",
        "        ])\n",
        "        vects = [UR, DR, UL, DL]\n",
        "        for arrow, label, vect in zip(arrows, labels, vects):\n",
        "            label.next_to(arrow.get_center(), vect, buff=SMALL_BUFF)\n",
        "\n",
        "        wave = FunctionGraph(\n",
        "            lambda x: 0.2 * np.sin(2 * TAU * x),\n",
        "            x_min=x_min,\n",
        "            x_max=x_max,\n",
        "        )\n",
        "        wave_label = OldTex(\"\\\\gamma\")\n",
        "        wave_label.next_to(wave, UP, SMALL_BUFF)\n",
        "        labels.add(wave_label)\n",
        "\n",
        "        squiggle = ParametricCurve(\n",
        "            lambda t: np.array([\n",
        "                t + 0.5 * np.sin(TAU * t),\n",
        "                0.5 * np.cos(TAU * t),\n",
        "                0,\n",
        "            ]),\n",
        "            t_min=0,\n",
        "            t_max=4,\n",
        "        )\n",
        "        squiggle.scale(0.25)\n",
        "        squiggle.set_color(BLUE)\n",
        "        squiggle.rotate(-30 * DEGREES)\n",
        "        squiggle.next_to(\n",
        "            arrows[2].point_from_proportion(0.75),\n",
        "            DR, buff=0\n",
        "        )\n",
        "        squiggle_label = OldTex(\"g\")\n",
        "        squiggle_label.next_to(squiggle, UR, buff=-MED_SMALL_BUFF)\n",
        "        labels.add(squiggle_label)\n",
        "\n",
        "        return VGroup(arrows, wave, squiggle, labels)\n",
        "\n",
        "\n",
        "class FeynmanLecturesScreenCaptureFrame(Scene):\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"http://www.feynmanlectures.caltech.edu/\")\n",
        "        url.to_edge(UP)\n",
        "\n",
        "        screen_rect = ScreenRectangle(height=6)\n",
        "        screen_rect.next_to(url, DOWN)\n",
        "\n",
        "        self.add(url)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TheMotionOfPlanets(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.setup_orbits()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"``The motion of planets around the sun''\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.to_edge(UP)\n",
        "        title.add_to_back(title.copy().set_stroke(BLACK, 5))\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def setup_orbits(self):\n",
        "        sun = ImageMobject(\"sun\")\n",
        "        sun.set_height(0.7)\n",
        "        planets, ellipses, orbits = self.get_planets_ellipses_and_orbits(sun)\n",
        "\n",
        "        archivist_words = OldTexText(\n",
        "            \"Judith Goodstein (Caltech archivist)\"\n",
        "        )\n",
        "        archivist_words.to_corner(UL)\n",
        "        archivist_words.shift(1.5 * DOWN)\n",
        "        archivist_words.add_background_rectangle()\n",
        "        alt_name = OldTexText(\"David Goodstein (Caltech physicist)\")\n",
        "        alt_name.next_to(archivist_words, DOWN, aligned_edge=LEFT)\n",
        "        alt_name.add_background_rectangle()\n",
        "\n",
        "        book = ImageMobject(\"Lost_Lecture_cover\")\n",
        "        book.set_height(4)\n",
        "        book.next_to(alt_name, DOWN)\n",
        "\n",
        "        self.add(SunAnimation(sun))\n",
        "        self.add(ellipses, planets)\n",
        "        self.add(self.title)\n",
        "        self.add(*orbits)\n",
        "        self.add_foreground_mobjects(planets)\n",
        "        self.wait(10)\n",
        "        self.play(\n",
        "            VGroup(ellipses, sun).shift, 3 * RIGHT,\n",
        "            FadeInFromDown(archivist_words),\n",
        "            Animation(self.title)\n",
        "        )\n",
        "        self.add_foreground_mobjects(archivist_words)\n",
        "        self.wait(3)\n",
        "        self.play(FadeInFromDown(alt_name))\n",
        "        self.add_foreground_mobjects(alt_name)\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(book))\n",
        "        self.wait(15)\n",
        "\n",
        "    def get_planets_ellipses_and_orbits(self, sun):\n",
        "        planets = VGroup(\n",
        "            ImageMobject(\"mercury\"),\n",
        "            ImageMobject(\"venus\"),\n",
        "            ImageMobject(\"earth\"),\n",
        "            ImageMobject(\"mars\"),\n",
        "            ImageMobject(\"comet\")\n",
        "        )\n",
        "        sizes = [0.383, 0.95, 1.0, 0.532, 0.3]\n",
        "        orbit_radii = [0.254, 0.475, 0.656, 1.0, 3.0]\n",
        "        orbit_eccentricies = [0.206, 0.006, 0.0167, 0.0934, 0.967]\n",
        "\n",
        "        for planet, size in zip(planets, sizes):\n",
        "            planet.set_height(0.5)\n",
        "            planet.scale(size)\n",
        "\n",
        "        ellipses = VGroup(*[\n",
        "            Circle(radius=r, color=WHITE, stroke_width=1)\n",
        "            for r in orbit_radii\n",
        "        ])\n",
        "        for circle, ec in zip(ellipses, orbit_eccentricies):\n",
        "            a = circle.get_height() / 2\n",
        "            c = ec * a\n",
        "            b = np.sqrt(a**2 - c**2)\n",
        "            circle.stretch(b / a, 1)\n",
        "            c = np.sqrt(a**2 - b**2)\n",
        "            circle.shift(c * RIGHT)\n",
        "        for circle in ellipses:\n",
        "            circle.rotate(\n",
        "                TAU * np.random.random(),\n",
        "                about_point=ORIGIN\n",
        "            )\n",
        "\n",
        "        ellipses.scale(3.5, about_point=ORIGIN)\n",
        "\n",
        "        orbits = [\n",
        "            Orbiting(\n",
        "                planet, sun, circle,\n",
        "                rate=0.25 * r**(2 / 3)\n",
        "            )\n",
        "            for planet, circle, r in zip(planets, ellipses, orbit_radii)\n",
        "        ]\n",
        "        orbits[-1].proportion = 0.15\n",
        "        orbits[-1].rate = 0.5\n",
        "\n",
        "        return planets, ellipses, orbits\n",
        "\n",
        "\n",
        "class TeacherHoldingUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.look_at(ORIGIN)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class AskAboutEllipses(TheMotionOfPlanets):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "        \"sun_height\": 0.5,\n",
        "        \"sun_center\": ORIGIN,\n",
        "        \"animate_sun\": True,\n",
        "        \"a\": 3.5,\n",
        "        \"b\": 2.0,\n",
        "        \"ellipse_color\": WHITE,\n",
        "        \"ellipse_stroke_width\": 1,\n",
        "        \"comet_height\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_sun()\n",
        "        self.add_orbit()\n",
        "        self.add_focus_lines()\n",
        "        self.add_force_labels()\n",
        "        self.comment_on_imperfections()\n",
        "        self.set_up_differential_equations()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = Title(\"Why are orbits ellipses?\")\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def add_sun(self):\n",
        "        sun = ImageMobject(\"sun\", height=self.sun_height)\n",
        "        sun.move_to(self.sun_center)\n",
        "        self.sun = sun\n",
        "        self.add(sun)\n",
        "        if self.animate_sun:\n",
        "            sun_animation = SunAnimation(sun)\n",
        "            self.add(sun_animation)\n",
        "            self.add_foreground_mobjects(\n",
        "                sun_animation.mobject\n",
        "            )\n",
        "        else:\n",
        "            self.add_foreground_mobjects(sun)\n",
        "\n",
        "    def add_orbit(self):\n",
        "        sun = self.sun\n",
        "        comet = self.get_comet()\n",
        "        ellipse = self.get_ellipse()\n",
        "        orbit = Orbiting(comet, sun, ellipse)\n",
        "\n",
        "        self.add(ellipse)\n",
        "        self.add(orbit)\n",
        "\n",
        "        self.ellipse = ellipse\n",
        "        self.comet = comet\n",
        "        self.orbit = orbit\n",
        "\n",
        "    def add_focus_lines(self):\n",
        "        f1, f2 = self.focus_points\n",
        "        comet = self.comet\n",
        "        lines = VGroup(Line(LEFT, RIGHT), Line(LEFT, RIGHT))\n",
        "        lines.set_stroke(GREY_B, 1)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            l1, l2 = lines\n",
        "            P = comet.get_center()\n",
        "            l1.put_start_and_end_on(f1, P)\n",
        "            l2.put_start_and_end_on(f2, P)\n",
        "            return lines\n",
        "\n",
        "        animation = Mobject.add_updater(\n",
        "            lines, update_lines\n",
        "        )\n",
        "        self.add(animation)\n",
        "        self.wait(8)\n",
        "\n",
        "        self.focus_lines = lines\n",
        "        self.focus_lines_animation = animation\n",
        "\n",
        "    def add_force_labels(self):\n",
        "        radial_line = self.focus_lines[0]\n",
        "\n",
        "        # Radial line measurement\n",
        "        radius_measurement_kwargs = {\n",
        "            \"num_decimal_places\": 3,\n",
        "            \"color\": BLUE,\n",
        "        }\n",
        "        radius_measurement = DecimalNumber(1, **radius_measurement_kwargs)\n",
        "\n",
        "        def update_radial_measurement(measurement):\n",
        "            angle = -radial_line.get_angle() + np.pi\n",
        "            radial_line.rotate(angle, about_point=ORIGIN)\n",
        "            new_decimal = DecimalNumber(\n",
        "                radial_line.get_length(),\n",
        "                **radius_measurement_kwargs\n",
        "            )\n",
        "            max_width = 0.6 * radial_line.get_width()\n",
        "            if new_decimal.get_width() > max_width:\n",
        "                new_decimal.set_width(max_width)\n",
        "            new_decimal.next_to(radial_line, UP, SMALL_BUFF)\n",
        "            VGroup(new_decimal, radial_line).rotate(\n",
        "                -angle, about_point=ORIGIN\n",
        "            )\n",
        "            Transform(measurement, new_decimal).update(1)\n",
        "\n",
        "        radius_measurement_animation = Mobject.add_updater(\n",
        "            radius_measurement, update_radial_measurement\n",
        "        )\n",
        "\n",
        "        # Force equation\n",
        "        force_equation = OldTex(\n",
        "            \"F = {GMm \\\\over (0.000)^2}\",\n",
        "            tex_to_color_map={\n",
        "                \"F\": YELLOW,\n",
        "                \"0.000\": BLACK,\n",
        "            }\n",
        "        )\n",
        "        force_equation.next_to(self.title, DOWN)\n",
        "        force_equation.to_edge(RIGHT)\n",
        "        radius_in_denominator_ref = force_equation.get_part_by_tex(\"0.000\")\n",
        "        radius_in_denominator = DecimalNumber(\n",
        "            0, **radius_measurement_kwargs\n",
        "        )\n",
        "        radius_in_denominator.scale(0.95)\n",
        "        update_radius_in_denominator = ContinualChangingDecimal(\n",
        "            radius_in_denominator,\n",
        "            lambda a: radial_line.get_length(),\n",
        "            position_update_func=lambda mob: mob.move_to(\n",
        "                radius_in_denominator_ref, LEFT\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Force arrow\n",
        "        force_arrow, force_arrow_animation = self.get_force_arrow_and_update(\n",
        "            self.comet\n",
        "        )\n",
        "\n",
        "        inverse_square_law_words = OldTexText(\n",
        "            \"``Inverse square law''\"\n",
        "        )\n",
        "        inverse_square_law_words.next_to(force_equation, DOWN, MED_LARGE_BUFF)\n",
        "        inverse_square_law_words.to_edge(RIGHT)\n",
        "        force_equation.next_to(inverse_square_law_words, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        def v_fade_in(mobject):\n",
        "            return UpdateFromAlphaFunc(\n",
        "                mobject,\n",
        "                lambda mob, alpha: mob.set_fill(opacity=alpha)\n",
        "            )\n",
        "\n",
        "        self.add(update_radius_in_denominator)\n",
        "        self.add(radius_measurement_animation)\n",
        "        self.play(\n",
        "            FadeIn(force_equation),\n",
        "            v_fade_in(radius_in_denominator),\n",
        "            v_fade_in(radius_measurement)\n",
        "        )\n",
        "        self.add(force_arrow_animation)\n",
        "        self.play(v_fade_in(force_arrow))\n",
        "        self.wait(8)\n",
        "        self.play(Write(inverse_square_law_words))\n",
        "        self.wait(9)\n",
        "\n",
        "        self.force_equation = force_equation\n",
        "        self.inverse_square_law_words = inverse_square_law_words\n",
        "        self.force_arrow = force_arrow\n",
        "        self.radius_measurement = radius_measurement\n",
        "\n",
        "    def comment_on_imperfections(self):\n",
        "        planets, ellipses, orbits = self.get_planets_ellipses_and_orbits(self.sun)\n",
        "        orbits.pop(-1)\n",
        "        ellipses.submobjects.pop(-1)\n",
        "        planets.submobjects.pop(-1)\n",
        "\n",
        "        scale_factor = 20\n",
        "        center = self.sun.get_center()\n",
        "        ellipses.save_state()\n",
        "        ellipses.scale(scale_factor, about_point=center)\n",
        "\n",
        "        self.add(*orbits)\n",
        "        self.play(ellipses.restore, Animation(planets))\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            ellipses.scale, scale_factor, {\"about_point\": center},\n",
        "            Animation(planets)\n",
        "        )\n",
        "        self.remove(*orbits)\n",
        "        self.remove(planets, ellipses)\n",
        "        self.wait(2)\n",
        "\n",
        "    def set_up_differential_equations(self):\n",
        "        d_dt = OldTex(\"{d \\\\over dt}\")\n",
        "        in_vect = Matrix(np.array([\n",
        "            \"x(t)\",\n",
        "            \"y(t)\",\n",
        "            \"\\\\dot{x}(t)\",\n",
        "            \"\\\\dot{y}(t)\",\n",
        "        ]))\n",
        "        equals = OldTex(\"=\")\n",
        "        out_vect = Matrix(np.array([\n",
        "            \"\\\\dot{x}(t)\",\n",
        "            \"\\\\dot{y}(t)\",\n",
        "            \"-x(t) / (x(t)^2 + y(t)^2)^{3/2}\",\n",
        "            \"-y(t) / (x(t)^2 + y(t)^2)^{3/2}\",\n",
        "        ]), element_alignment_corner=ORIGIN)\n",
        "\n",
        "        equation = VGroup(d_dt, in_vect, equals, out_vect)\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.set_width(6)\n",
        "\n",
        "        equation.to_corner(DR, buff=MED_LARGE_BUFF)\n",
        "        cross = Cross(equation)\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.wait(6)\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait(6)\n",
        "\n",
        "    # Helpers\n",
        "    def get_comet(self):\n",
        "        comet = ImageMobject(\"comet\")\n",
        "        comet.set_height(self.comet_height)\n",
        "        return comet\n",
        "\n",
        "    def get_ellipse(self):\n",
        "        a = self.a\n",
        "        b = self.b\n",
        "        c = np.sqrt(a**2 - b**2)\n",
        "        ellipse = Circle(radius=a)\n",
        "        ellipse.set_stroke(\n",
        "            self.ellipse_color,\n",
        "            self.ellipse_stroke_width,\n",
        "        )\n",
        "        ellipse.stretch(fdiv(b, a), dim=1)\n",
        "        ellipse.move_to(\n",
        "            self.sun.get_center() + c * LEFT,\n",
        "        )\n",
        "        self.focus_points = [\n",
        "            self.sun.get_center(),\n",
        "            self.sun.get_center() + 2 * c * LEFT,\n",
        "        ]\n",
        "        return ellipse\n",
        "\n",
        "    def get_force_arrow_and_update(self, comet, scale_factor=1):\n",
        "        force_arrow = Arrow(LEFT, RIGHT, color=YELLOW)\n",
        "        sun = self.sun\n",
        "\n",
        "        def update_force_arrow(arrow):\n",
        "            radial_line = Line(\n",
        "                sun.get_center(), comet.get_center()\n",
        "            )\n",
        "            radius = radial_line.get_length()\n",
        "            # target_length = 1 / radius**2\n",
        "            target_length = scale_factor / radius  # Lies!\n",
        "            arrow.scale(\n",
        "                target_length / arrow.get_length()\n",
        "            )\n",
        "            arrow.rotate(\n",
        "                np.pi + radial_line.get_angle() - arrow.get_angle()\n",
        "            )\n",
        "            arrow.shift(\n",
        "                radial_line.get_end() - arrow.get_start()\n",
        "            )\n",
        "        force_arrow_animation = Mobject.add_updater(\n",
        "            force_arrow, update_force_arrow\n",
        "        )\n",
        "\n",
        "        return force_arrow, force_arrow_animation\n",
        "\n",
        "    def get_radial_line_and_update(self, comet):\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_stroke(GREY_B, 1)\n",
        "        line_update = Mobject.add_updater(\n",
        "            line, lambda l: l.put_start_and_end_on(\n",
        "                self.sun.get_center(),\n",
        "                comet.get_center(),\n",
        "            )\n",
        "        )\n",
        "        return line, line_update\n",
        "\n",
        "\n",
        "class FeynmanSaysItBest(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Feynman says \\\\\\\\ it best\",\n",
        "            added_anims=[\n",
        "                self.change_students(\n",
        "                    \"hooray\", \"happy\", \"erm\"\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class FeynmanElementaryQuote(Scene):\n",
        "    def construct(self):\n",
        "        quote_text = \"\"\"\n",
        "            \\\\large\n",
        "            I am going to give what I will call an\n",
        "            \\\\emph{elementary} demonstration.  But elementary\n",
        "            does not mean easy to understand.  Elementary\n",
        "            means that very little is required\n",
        "            to know ahead of time in order to understand it,\n",
        "            except to have an infinite amount of intelligence.\n",
        "        \"\"\"\n",
        "        quote_parts = [s for s in quote_text.split(\" \") if s]\n",
        "        quote = OldTexText(\n",
        "            *quote_parts,\n",
        "            tex_to_color_map={\n",
        "                \"\\\\emph{elementary}\": BLUE,\n",
        "                \"elementary\": BLUE,\n",
        "                \"Elementary\": BLUE,\n",
        "                \"infinite\": YELLOW,\n",
        "                \"amount\": YELLOW,\n",
        "                \"of\": YELLOW,\n",
        "                \"intelligence\": YELLOW,\n",
        "                \"very\": RED,\n",
        "                \"little\": RED,\n",
        "            },\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        quote[-1].shift(2 * SMALL_BUFF * LEFT)\n",
        "        quote.set_width(FRAME_WIDTH - 1)\n",
        "        quote.to_edge(UP)\n",
        "        quote.get_part_by_tex(\"of\").set_color(WHITE)\n",
        "\n",
        "        nothing = OldTexText(\"nothing\")\n",
        "        nothing.scale(0.9)\n",
        "        very = quote.get_part_by_tex(\"very\")\n",
        "        nothing.shift(very[0].get_left() - nothing[0].get_left())\n",
        "        nothing.set_color(RED)\n",
        "\n",
        "        for word in quote:\n",
        "            if word is very:\n",
        "                self.add_foreground_mobjects(nothing)\n",
        "                self.play(ShowWord(nothing))\n",
        "                self.wait(0.2)\n",
        "                nothing.sort(lambda p: -p[0])\n",
        "                self.play(LaggedStartMap(\n",
        "                    FadeOut, nothing,\n",
        "                    run_time=1\n",
        "                ))\n",
        "                self.remove_foreground_mobject(nothing)\n",
        "            back_word = word.copy().set_stroke(BLACK, 5)\n",
        "            self.add_foreground_mobjects(back_word, word)\n",
        "            self.play(\n",
        "                ShowWord(back_word),\n",
        "                ShowWord(word),\n",
        "            )\n",
        "            self.wait(0.005 * len(word)**1.5)\n",
        "        self.wait()\n",
        "\n",
        "        # Show thumbnails\n",
        "        images = Group(\n",
        "            ImageMobject(\"Calculus_Thumbnail\"),\n",
        "            ImageMobject(\"Fourier_Thumbnail\"),\n",
        "        )\n",
        "        for image in images:\n",
        "            image.set_height(3)\n",
        "        images.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        images.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        images[1].move_to(images[0])\n",
        "        crosses = VGroup(*list(map(Cross, images)))\n",
        "        crosses.set_stroke(\"RED\", 10)\n",
        "\n",
        "        for image, cross in zip(images, crosses):\n",
        "            image.rect = SurroundingRectangle(\n",
        "                image,\n",
        "                stroke_width=3,\n",
        "                stroke_color=WHITE,\n",
        "                buff=0\n",
        "            )\n",
        "            cross.scale(1.1)\n",
        "        self.play(\n",
        "            FadeInFromDown(images[0]),\n",
        "            FadeInFromDown(images[0].rect)\n",
        "        )\n",
        "        self.play(ShowCreation(crosses[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOutAndShiftDown(images[0]),\n",
        "            FadeOutAndShiftDown(images[0].rect),\n",
        "            FadeOutAndShiftDown(crosses[0]),\n",
        "            FadeInFromDown(images[1]),\n",
        "            FadeInFromDown(images[1].rect),\n",
        "        )\n",
        "        self.play(ShowCreation(crosses[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LostLecturePicture(TODOStub):\n",
        "    CONFIG = {\"camera_config\": {\"background_opacity\": 1}}\n",
        "\n",
        "    def construct(self):\n",
        "        picture = ImageMobject(\"Feynman_teaching\")\n",
        "        picture.set_height(FRAME_WIDTH)\n",
        "        picture.to_corner(UL, buff=0)\n",
        "        picture.fade(0.5)\n",
        "\n",
        "        self.play(\n",
        "            picture.to_corner, DR, {\"buff\": 0},\n",
        "            picture.shift, 1.5 * DOWN,\n",
        "            path_arc=60 * DEGREES,\n",
        "            run_time=20,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "\n",
        "\n",
        "class AskAboutInfiniteIntelligence(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Infinite intelligence?\",\n",
        "            target_mode=\"confused\"\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(\"horrified\", \"confused\", \"sad\"),\n",
        "            self.teacher.change, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Stay focused, \\\\\\\\ go full screen, \\\\\\\\ and you'll be fine.\",\n",
        "            added_anims=[self.change_students(*[\"happy\"] * 3)]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class TableOfContents(Scene):\n",
        "    def construct(self):\n",
        "        items = VGroup(\n",
        "            OldTexText(\"How the ellipse will arise\"),\n",
        "            OldTexText(\"Kepler's 2nd law\"),\n",
        "            OldTexText(\"The shape of velocities\"),\n",
        "        )\n",
        "        items.arrange(\n",
        "            DOWN, buff=LARGE_BUFF, aligned_edge=LEFT\n",
        "        )\n",
        "        items.to_edge(LEFT, buff=1.5)\n",
        "        for item in items:\n",
        "            item.add(Dot().next_to(item, LEFT))\n",
        "            item.generate_target()\n",
        "            item.target.set_fill(GREY, opacity=0.5)\n",
        "\n",
        "        title = Title(\"The plan\")\n",
        "        scale_factor = 1.2\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, items,\n",
        "            run_time=1,\n",
        "            lag_ratio=0.7,\n",
        "        ))\n",
        "        self.wait()\n",
        "        for item in items:\n",
        "            other_items = VGroup(*[m for m in items if m is not item])\n",
        "            new_item = item.copy()\n",
        "            new_item.scale(scale_factor, about_edge=LEFT)\n",
        "            new_item.set_fill(WHITE, 1)\n",
        "            self.play(\n",
        "                Transform(item, new_item),\n",
        "                *list(map(MoveToTarget, other_items))\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class DrawEllipseOverlay(Scene):\n",
        "    def construct(self):\n",
        "        ellipse = Circle()\n",
        "        ellipse.stretch_to_fit_width(7.0)\n",
        "        ellipse.stretch_to_fit_height(3.8)\n",
        "        ellipse.shift(1.05 * UP + 0.48 * LEFT)\n",
        "        ellipse.set_stroke(RED, 8)\n",
        "\n",
        "        image = ImageMobject(\n",
        "            os.path.join(\n",
        "                get_image_output_directory(self.__class__),\n",
        "                \"HeldUpEllipse.jpg\"\n",
        "            )\n",
        "        )\n",
        "        image.set_height(FRAME_HEIGHT)\n",
        "\n",
        "        # self.add(image)\n",
        "        self.play(ShowCreation(ellipse))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(ellipse))\n",
        "\n",
        "\n",
        "class ShowEllipseDefiningProperty(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "        \"ellipse_color\": BLUE,\n",
        "        \"a\": 4.0,\n",
        "        \"b\": 3.0,\n",
        "        \"distance_labels_scale_factor\": 1.0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_ellipse()\n",
        "        self.add_focal_lines()\n",
        "        self.add_distance_labels()\n",
        "        self.label_foci()\n",
        "        self.label_focal_sum()\n",
        "\n",
        "    def add_ellipse(self):\n",
        "        a = self.a\n",
        "        b = self.b\n",
        "        ellipse = Circle(radius=a, color=self.ellipse_color)\n",
        "        ellipse.stretch(fdiv(b, a), dim=1)\n",
        "        ellipse.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        self.ellipse = ellipse\n",
        "        self.add(ellipse)\n",
        "\n",
        "    def add_focal_lines(self):\n",
        "        push_pins = VGroup(*[\n",
        "            SVGMobject(\n",
        "                file_name=\"push_pin\",\n",
        "                color=GREY_B,\n",
        "                fill_opacity=0.8,\n",
        "                height=0.5,\n",
        "            ).move_to(point, DR).shift(0.05 * RIGHT)\n",
        "            for point in self.get_foci()\n",
        "        ])\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.scale(0.5)\n",
        "        position_tracker = ValueTracker(0.125)\n",
        "        dot_update = Mobject.add_updater(\n",
        "            dot,\n",
        "            lambda d: d.move_to(\n",
        "                self.ellipse.point_from_proportion(\n",
        "                    position_tracker.get_value() % 1\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        always_shift(position_tracker, rate=0.05)\n",
        "\n",
        "        lines, lines_update_animation = self.get_focal_lines_and_update(\n",
        "            self.get_foci, dot\n",
        "        )\n",
        "\n",
        "        self.add_foreground_mobjects(push_pins, dot)\n",
        "        self.add(dot_update)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, push_pins,\n",
        "            lambda m: (m, 2 * UP + LEFT),\n",
        "            run_time=1,\n",
        "            lag_ratio=0.75\n",
        "        ))\n",
        "        self.play(ShowCreation(lines))\n",
        "        self.add(lines_update_animation)\n",
        "        self.add(position_tracker)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.position_tracker = position_tracker\n",
        "        self.focal_lines = lines\n",
        "\n",
        "    def add_distance_labels(self):\n",
        "        lines = self.focal_lines\n",
        "        colors = [YELLOW, PINK]\n",
        "\n",
        "        distance_labels, distance_labels_animation = \\\n",
        "            self.get_distance_labels_and_update(lines, colors)\n",
        "\n",
        "        sum_expression, numbers, number_updates = \\\n",
        "            self.get_sum_expression_and_update(\n",
        "                lines, colors, lambda mob: mob.to_corner(UR)\n",
        "            )\n",
        "\n",
        "        sum_expression_fading_rect = BackgroundRectangle(\n",
        "            sum_expression, fill_opacity=1\n",
        "        )\n",
        "\n",
        "        sum_rect = SurroundingRectangle(numbers[-1])\n",
        "        constant_words = OldTexText(\"Stays constant\")\n",
        "        constant_words.next_to(sum_rect, DOWN, aligned_edge=RIGHT)\n",
        "        VGroup(sum_rect, constant_words).set_color(BLUE)\n",
        "\n",
        "        self.add(distance_labels_animation)\n",
        "        self.add(*number_updates)\n",
        "        self.add(sum_expression)\n",
        "        self.add_foreground_mobjects(sum_expression_fading_rect)\n",
        "        self.play(\n",
        "            VFadeIn(distance_labels),\n",
        "            FadeOut(sum_expression_fading_rect),\n",
        "        )\n",
        "        self.remove_foreground_mobject(sum_expression_fading_rect)\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            ShowCreation(sum_rect),\n",
        "            Write(constant_words)\n",
        "        )\n",
        "        self.wait(7)\n",
        "        self.play(FadeOut(sum_rect), FadeOut(constant_words))\n",
        "\n",
        "        self.sum_expression = sum_expression\n",
        "        self.sum_rect = sum_rect\n",
        "\n",
        "    def label_foci(self):\n",
        "        foci = self.get_foci()\n",
        "        focus_words = VGroup(*[\n",
        "            OldTexText(\"Focus\").next_to(focus, DOWN)\n",
        "            for focus in foci\n",
        "        ])\n",
        "        foci_word = OldTexText(\"Foci\")\n",
        "        foci_word.move_to(focus_words)\n",
        "        foci_word.shift(MED_SMALL_BUFF * UP)\n",
        "        connecting_lines = VGroup(*[\n",
        "            Arrow(\n",
        "                foci_word.get_edge_center(-edge),\n",
        "                focus_word.get_edge_center(edge),\n",
        "                buff=MED_SMALL_BUFF,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "            for focus_word, edge in zip(focus_words, [LEFT, RIGHT])\n",
        "        ])\n",
        "\n",
        "        translation = OldTexText(\n",
        "            \"``Foco'' $\\\\rightarrow$ Fireplace\"\n",
        "        )\n",
        "        translation.to_edge(RIGHT)\n",
        "        translation.shift(UP)\n",
        "        sun = ImageMobject(\"sun\", height=0.5)\n",
        "        sun.move_to(foci[0])\n",
        "        sun_animation = SunAnimation(sun)\n",
        "\n",
        "        self.play(FadeInFromDown(focus_words))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(focus_words.copy(), foci_word),\n",
        "        )\n",
        "        self.play(*list(map(ShowCreation, connecting_lines)))\n",
        "        for word in list(focus_words) + [foci_word]:\n",
        "            word.add_background_rectangle()\n",
        "            self.add_foreground_mobjects(word)\n",
        "        self.wait(4)\n",
        "        self.play(Write(translation))\n",
        "        self.wait(2)\n",
        "        self.play(GrowFromCenter(sun))\n",
        "        self.add(sun_animation)\n",
        "        self.wait(8)\n",
        "\n",
        "    def label_focal_sum(self):\n",
        "        sum_rect = self.sum_rect\n",
        "\n",
        "        focal_sum = OldTexText(\"``Focal sum''\")\n",
        "        focal_sum.scale(1.5)\n",
        "        focal_sum.next_to(sum_rect, DOWN, aligned_edge=RIGHT)\n",
        "        VGroup(sum_rect, focal_sum).set_color(RED)\n",
        "\n",
        "        footnote = OldTexText(\n",
        "            \"\"\"\n",
        "            \\\\Large\n",
        "            *This happens to equal the longest distance\n",
        "            across the ellipse, so perhaps the more standard\n",
        "            terminology would be ``major axis'', but I want\n",
        "            some terminology that conveys the idea of adding\n",
        "            two distances to the foci.\n",
        "            \"\"\",\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        footnote.set_width(5)\n",
        "        footnote.to_corner(DR)\n",
        "        footnote.set_stroke(WHITE, 0.5)\n",
        "\n",
        "        self.play(FadeInFromDown(focal_sum))\n",
        "        self.play(Write(sum_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(footnote))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(footnote))\n",
        "        self.wait(8)\n",
        "\n",
        "    # Helpers\n",
        "    def get_foci(self):\n",
        "        ellipse = self.ellipse\n",
        "        a = ellipse.get_width() / 2\n",
        "        b = ellipse.get_height() / 2\n",
        "        c = np.sqrt(a**2 - b**2)\n",
        "        center = ellipse.get_center()\n",
        "        return [\n",
        "            center + c * RIGHT,\n",
        "            center + c * LEFT,\n",
        "        ]\n",
        "\n",
        "    def get_focal_lines_and_update(self, get_foci, focal_sum_point):\n",
        "        lines = VGroup(Line(LEFT, RIGHT), Line(LEFT, RIGHT))\n",
        "        lines.set_stroke(width=2)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            foci = get_foci()\n",
        "            for line, focus in zip(lines, foci):\n",
        "                line.put_start_and_end_on(\n",
        "                    focus, focal_sum_point.get_center()\n",
        "                )\n",
        "            lines[1].rotate(np.pi)\n",
        "        lines_update_animation = Mobject.add_updater(\n",
        "            lines, update_lines\n",
        "        )\n",
        "        return lines, lines_update_animation\n",
        "\n",
        "    def get_distance_labels_and_update(self, lines, colors):\n",
        "        distance_labels = VGroup(\n",
        "            DecimalNumber(0), DecimalNumber(0),\n",
        "        )\n",
        "        for label in distance_labels:\n",
        "            label.scale(self.distance_labels_scale_factor)\n",
        "\n",
        "        def update_distance_labels(labels):\n",
        "            for label, line, color in zip(labels, lines, colors):\n",
        "                angle = -line.get_angle()\n",
        "                if np.abs(angle) > 90 * DEGREES:\n",
        "                    angle = 180 * DEGREES + angle\n",
        "                line.rotate(angle, about_point=ORIGIN)\n",
        "                new_decimal = DecimalNumber(line.get_length())\n",
        "                new_decimal.scale(\n",
        "                    self.distance_labels_scale_factor\n",
        "                )\n",
        "                max_width = 0.6 * line.get_width()\n",
        "                if new_decimal.get_width() > max_width:\n",
        "                    new_decimal.set_width(max_width)\n",
        "                new_decimal.next_to(line, UP, SMALL_BUFF)\n",
        "                new_decimal.set_color(color)\n",
        "                new_decimal.add_to_back(\n",
        "                    new_decimal.copy().set_stroke(BLACK, 5)\n",
        "                )\n",
        "                VGroup(new_decimal, line).rotate(\n",
        "                    -angle, about_point=ORIGIN\n",
        "                )\n",
        "                label.submobjects = list(new_decimal.submobjects)\n",
        "\n",
        "        distance_labels_animation = Mobject.add_updater(\n",
        "            distance_labels, update_distance_labels\n",
        "        )\n",
        "\n",
        "        return distance_labels, distance_labels_animation\n",
        "\n",
        "    def get_sum_expression_and_update(self, lines, colors, sum_position_func):\n",
        "        sum_expression = OldTex(\"0.00\", \"+\", \"0.00\", \"=\", \"0.00\")\n",
        "        sum_position_func(sum_expression)\n",
        "        number_refs = sum_expression.get_parts_by_tex(\"0.00\")\n",
        "        number_refs.set_fill(opacity=0)\n",
        "        numbers = VGroup(*[DecimalNumber(0) for ref in number_refs])\n",
        "        for number, color in zip(numbers, colors):\n",
        "            number.set_color(color)\n",
        "\n",
        "        # Not the most elegant...\n",
        "        number_updates = [\n",
        "            ContinualChangingDecimal(\n",
        "                numbers[0], lambda a: lines[0].get_length(),\n",
        "                position_update_func=lambda m: m.move_to(\n",
        "                    number_refs[1], LEFT\n",
        "                )\n",
        "            ),\n",
        "            ContinualChangingDecimal(\n",
        "                numbers[1], lambda a: lines[1].get_length(),\n",
        "                position_update_func=lambda m: m.move_to(\n",
        "                    number_refs[0], LEFT\n",
        "                )\n",
        "            ),\n",
        "            ContinualChangingDecimal(\n",
        "                numbers[2], lambda a: sum(map(Line.get_length, lines)),\n",
        "                position_update_func=lambda m: m.move_to(\n",
        "                    number_refs[2], LEFT\n",
        "                )\n",
        "            ),\n",
        "        ]\n",
        "\n",
        "        return sum_expression, numbers, number_updates\n",
        "\n",
        "\n",
        "class GeometryProofLand(Scene):\n",
        "    CONFIG = {\n",
        "        \"colors\": [\n",
        "            PINK, RED, YELLOW, GREEN, GREEN_A, BLUE,\n",
        "            MAROON_E, MAROON_B, YELLOW, BLUE,\n",
        "        ],\n",
        "        \"text\": \"Geometry proof land\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        word = self.get_geometry_proof_land_word()\n",
        "        word_outlines = word.deepcopy()\n",
        "        word_outlines.set_fill(opacity=0)\n",
        "        word_outlines.set_stroke(WHITE, 1)\n",
        "        colors = list(self.colors)\n",
        "        random.shuffle(colors)\n",
        "        word_outlines.set_color_by_gradient(*colors)\n",
        "        word_outlines.set_stroke(width=5)\n",
        "\n",
        "        circles = VGroup()\n",
        "        for letter in word:\n",
        "            circle = Circle()\n",
        "            # circle = letter.copy()\n",
        "            circle.replace(letter, dim_to_match=1)\n",
        "            circle.scale(3)\n",
        "            circle.set_stroke(WHITE, 0)\n",
        "            circle.set_fill(letter.get_color(), 0)\n",
        "            circles.add(circle)\n",
        "            circle.target = letter\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, circles),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add(word_outlines, circles)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, word_outlines,\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back,\n",
        "        ), Animation(circles))\n",
        "        self.wait()\n",
        "\n",
        "    def get_geometry_proof_land_word(self):\n",
        "        word = OldTexText(self.text)\n",
        "        word.rotate(-90 * DEGREES)\n",
        "        word.scale(0.25)\n",
        "        word.shift(3 * RIGHT)\n",
        "        word.apply_complex_function(np.exp)\n",
        "        word.rotate(90 * DEGREES)\n",
        "        word.set_width(9)\n",
        "        word.center()\n",
        "        word.to_edge(UP)\n",
        "        word.set_color_by_gradient(*self.colors)\n",
        "        word.set_background_stroke(width=0)\n",
        "        return word\n",
        "\n",
        "\n",
        "class ProveEllipse(ShowEmergingEllipse, ShowEllipseDefiningProperty):\n",
        "    CONFIG = {\n",
        "        \"eccentricity_vector\": 1.5 * RIGHT,\n",
        "        \"ellipse_color\": PINK,\n",
        "        \"distance_labels_scale_factor\": 0.7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_ellipse()\n",
        "        self.hypothesize_foci()\n",
        "        self.setup_and_show_focal_sum()\n",
        "        self.show_circle_radius()\n",
        "        self.limit_to_just_one_line()\n",
        "        self.look_at_perpendicular_bisector()\n",
        "        self.show_orbiting_planet()\n",
        "\n",
        "    def setup_ellipse(self):\n",
        "        circle = self.circle = self.get_circle()\n",
        "        circle.to_edge(LEFT)\n",
        "        ep = self.get_eccentricity_point()\n",
        "        ep_dot = self.ep_dot = Dot(ep, color=YELLOW)\n",
        "        lines = self.lines = self.get_lines()\n",
        "        for line in lines:\n",
        "            line.save_state()\n",
        "        ghost_lines = self.ghost_lines = self.get_ghost_lines(lines)\n",
        "        ellipse = self.ellipse = self.get_ellipse()\n",
        "\n",
        "        self.add(ghost_lines, circle, lines, ep_dot)\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, lines),\n",
        "            Animation(ep_dot),\n",
        "        )\n",
        "        self.play(ShowCreation(ellipse))\n",
        "        self.wait()\n",
        "\n",
        "    def hypothesize_foci(self):\n",
        "        circle = self.circle\n",
        "        ghost_lines = self.ghost_lines\n",
        "        ghost_lines_copy = ghost_lines.copy().set_stroke(YELLOW, 3)\n",
        "\n",
        "        center = circle.get_center()\n",
        "        center_dot = Dot(center, color=RED)\n",
        "        # ep = self.get_eccentricity_point()\n",
        "        ep_dot = self.ep_dot\n",
        "        dots = VGroup(center_dot, ep_dot)\n",
        "\n",
        "        center_label = OldTexText(\"Circle center\")\n",
        "        ep_label = OldTexText(\"Eccentric point\")\n",
        "        labels = VGroup(center_label, ep_label)\n",
        "        vects = [UL, DR]\n",
        "        arrows = VGroup()\n",
        "        for label, dot, vect in zip(labels, dots, vects):\n",
        "            label.next_to(dot, vect, MED_LARGE_BUFF)\n",
        "            label.match_color(dot)\n",
        "            label.add_to_back(\n",
        "                label.copy().set_stroke(BLACK, 5)\n",
        "            )\n",
        "            arrow = Arrow(\n",
        "                label.get_corner(-vect),\n",
        "                dot.get_corner(vect),\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            arrow.match_color(dot)\n",
        "            arrow.add_to_back(arrow.copy().set_stroke(BLACK, 5))\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        labels_target = labels.copy()\n",
        "        labels_target.arrange(\n",
        "            DOWN, aligned_edge=LEFT\n",
        "        )\n",
        "        guess_start = OldTexText(\"Guess: Foci = \")\n",
        "        brace = Brace(labels_target, LEFT)\n",
        "        full_guess = VGroup(guess_start, brace, labels_target)\n",
        "        full_guess.arrange(RIGHT)\n",
        "        full_guess.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(labels[1]),\n",
        "            GrowArrow(arrows[1]),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowPassingFlash, ghost_lines_copy\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(circle.copy(), center_dot))\n",
        "        self.add_foreground_mobjects(dots)\n",
        "        self.play(\n",
        "            FadeInFromDown(labels[0]),\n",
        "            GrowArrow(arrows[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(guess_start),\n",
        "            GrowFromCenter(brace),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(labels.copy(), labels_target)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(labels), FadeOut(arrows))\n",
        "\n",
        "        self.center_dot = center_dot\n",
        "\n",
        "    def setup_and_show_focal_sum(self):\n",
        "        circle = self.circle\n",
        "        ellipse = self.ellipse\n",
        "\n",
        "        focal_sum_point = VectorizedPoint()\n",
        "        focal_sum_point.move_to(circle.get_top())\n",
        "        dots = [self.ep_dot, self.center_dot]\n",
        "        colors = list(map(Mobject.get_color, dots))\n",
        "\n",
        "        def get_foci():\n",
        "            return list(map(Mobject.get_center, dots))\n",
        "\n",
        "        focal_lines, focal_lines_update_animation = \\\n",
        "            self.get_focal_lines_and_update(get_foci, focal_sum_point)\n",
        "        distance_labels, distance_labels_update_animation = \\\n",
        "            self.get_distance_labels_and_update(focal_lines, colors)\n",
        "        sum_expression, numbers, number_updates = \\\n",
        "            self.get_sum_expression_and_update(\n",
        "                focal_lines, colors,\n",
        "                lambda mob: mob.to_edge(RIGHT).shift(UP)\n",
        "            )\n",
        "\n",
        "        to_add = self.focal_sum_things_to_add = [\n",
        "            focal_lines_update_animation,\n",
        "            distance_labels_update_animation,\n",
        "            sum_expression,\n",
        "        ] + list(number_updates)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(focal_lines),\n",
        "            Write(distance_labels),\n",
        "            FadeIn(sum_expression),\n",
        "            Write(numbers),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(*to_add)\n",
        "\n",
        "        points = [\n",
        "            ellipse.get_top(),\n",
        "            circle.point_from_proportion(0.2),\n",
        "            ellipse.point_from_proportion(0.2),\n",
        "            ellipse.point_from_proportion(0.4),\n",
        "        ]\n",
        "        for point in points:\n",
        "            self.play(\n",
        "                focal_sum_point.move_to, point\n",
        "            )\n",
        "            self.wait()\n",
        "        self.remove(*to_add)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            focal_lines, distance_labels,\n",
        "            sum_expression, numbers\n",
        "        ])))\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            focal_lines, focal_lines_update_animation,\n",
        "            focal_sum_point,\n",
        "            distance_labels, distance_labels_update_animation,\n",
        "            sum_expression,\n",
        "            numbers, number_updates\n",
        "        )\n",
        "\n",
        "    def show_circle_radius(self):\n",
        "        circle = self.circle\n",
        "        center = circle.get_center()\n",
        "        point = circle.get_right()\n",
        "        color = GREEN\n",
        "        radius = Line(center, point, color=color)\n",
        "        radius_measurement = DecimalNumber(radius.get_length())\n",
        "        radius_measurement.set_color(color)\n",
        "        radius_measurement.next_to(radius, UP, SMALL_BUFF)\n",
        "        radius_measurement.add_to_back(\n",
        "            radius_measurement.copy().set_stroke(BLACK, 5)\n",
        "        )\n",
        "        group = VGroup(radius, radius_measurement)\n",
        "        group.rotate(30 * DEGREES, about_point=center)\n",
        "\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(Write(radius_measurement))\n",
        "        self.wait()\n",
        "        self.play(Rotating(\n",
        "            group,\n",
        "            rate_func=smooth,\n",
        "            run_time=7,\n",
        "            about_point=center\n",
        "        ))\n",
        "        self.play(FadeOut(group))\n",
        "\n",
        "    def limit_to_just_one_line(self):\n",
        "        lines = self.lines\n",
        "        ghost_lines = self.ghost_lines\n",
        "        ep_dot = self.ep_dot\n",
        "\n",
        "        index = int(0.2 * len(lines))\n",
        "        line = lines[index]\n",
        "        ghost_line = ghost_lines[index]\n",
        "        to_fade = VGroup(*list(lines) + list(ghost_lines))\n",
        "        to_fade.remove(line, ghost_line)\n",
        "\n",
        "        P_dot = Dot(line.saved_state.get_end())\n",
        "        P_label = OldTex(\"P\")\n",
        "        P_label.next_to(P_dot, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add_foreground_mobjects(self.ellipse)\n",
        "        self.play(LaggedStartMap(Restore, lines))\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            ghost_line.set_stroke, YELLOW, 3,\n",
        "            line.set_stroke, WHITE, 3,\n",
        "            ReplacementTransform(ep_dot.copy(), P_dot),\n",
        "        )\n",
        "        self.play(FadeInFromDown(P_label))\n",
        "        self.wait()\n",
        "\n",
        "        for l in lines:\n",
        "            l.generate_target()\n",
        "            l.target.rotate(\n",
        "                90 * DEGREES,\n",
        "                about_point=l.get_center()\n",
        "            )\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            line, ghost_line,\n",
        "            P_dot, P_label\n",
        "        )\n",
        "\n",
        "    def look_at_perpendicular_bisector(self):\n",
        "        # Alright, this method's gonna blow up.  Let's go!\n",
        "        circle = self.circle\n",
        "        ellipse = self.ellipse\n",
        "        ellipse.save_state()\n",
        "        lines = self.lines\n",
        "        line = self.line\n",
        "        ghost_lines = self.ghost_lines\n",
        "        ghost_line = self.ghost_line\n",
        "        P_dot = self.P_dot\n",
        "        P_label = self.P_label\n",
        "\n",
        "        elbow = self.get_elbow(line)\n",
        "        self.play(\n",
        "            MoveToTarget(line, path_arc=90 * DEGREES),\n",
        "            ShowCreation(elbow)\n",
        "        )\n",
        "\n",
        "        # Perpendicular bisector label\n",
        "        label = OldTexText(\"``Perpendicular bisector''\")\n",
        "        label.scale(0.75)\n",
        "        label.set_color(YELLOW)\n",
        "        label.next_to(ORIGIN, UP, MED_SMALL_BUFF)\n",
        "        label.add_background_rectangle()\n",
        "        angle = line.get_angle() + np.pi\n",
        "        label.rotate(angle, about_point=ORIGIN)\n",
        "        label.shift(line.get_center())\n",
        "\n",
        "        # Dot defining Q point\n",
        "        Q_dot = Dot(color=GREEN)\n",
        "        Q_dot.move_to(self.focal_sum_point)\n",
        "        focal_sum_point_animation = turn_animation_into_updater(\n",
        "            MaintainPositionRelativeTo(\n",
        "                self.focal_sum_point, Q_dot\n",
        "            )\n",
        "        )\n",
        "        self.add(focal_sum_point_animation)\n",
        "        Q_dot.move_to(line.point_from_proportion(0.9))\n",
        "        Q_dot.save_state()\n",
        "\n",
        "        Q_label = OldTex(\"Q\")\n",
        "        Q_label.scale(0.7)\n",
        "        Q_label.match_color(Q_dot)\n",
        "        Q_label.add_to_back(Q_label.copy().set_stroke(BLACK, 5))\n",
        "        Q_label.next_to(Q_dot, UL, buff=0)\n",
        "        Q_label_animation = turn_animation_into_updater(\n",
        "            MaintainPositionRelativeTo(Q_label, Q_dot)\n",
        "        )\n",
        "\n",
        "        # Pretty hacky...\n",
        "        def distance_label_shift_update(label):\n",
        "            line = self.focal_lines[0]\n",
        "            if line.get_end()[0] > line.get_start()[0]:\n",
        "                vect = label.get_center() - line.get_center()\n",
        "                label.shift(-2 * vect)\n",
        "        distance_label_shift_update_animation = Mobject.add_updater(\n",
        "            self.distance_labels[0],\n",
        "            distance_label_shift_update\n",
        "        )\n",
        "        self.focal_sum_things_to_add.append(\n",
        "            distance_label_shift_update_animation\n",
        "        )\n",
        "\n",
        "        # Define QP line\n",
        "        QP_line = Line(LEFT, RIGHT)\n",
        "        QP_line.match_style(self.focal_lines)\n",
        "        QP_line_update = Mobject.add_updater(\n",
        "            QP_line, lambda l: l.put_start_and_end_on(\n",
        "                Q_dot.get_center(), P_dot.get_center(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        QE_line = Line(LEFT, RIGHT)\n",
        "        QE_line.set_stroke(YELLOW, 3)\n",
        "        QE_line_update = Mobject.add_updater(\n",
        "            QE_line, lambda l: l.put_start_and_end_on(\n",
        "                Q_dot.get_center(),\n",
        "                self.get_eccentricity_point()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Define similar triangles\n",
        "        triangles = VGroup(*[\n",
        "            Polygon(\n",
        "                Q_dot.get_center(),\n",
        "                line.get_center(),\n",
        "                end_point,\n",
        "                fill_opacity=1,\n",
        "            )\n",
        "            for end_point in [\n",
        "                P_dot.get_center(),\n",
        "                self.get_eccentricity_point()\n",
        "            ]\n",
        "        ])\n",
        "        triangles.set_color_by_gradient(RED_C, COBALT)\n",
        "        triangles.set_stroke(WHITE, 2)\n",
        "\n",
        "        # Add even more distant label updates\n",
        "        def distance_label_rotate_update(label):\n",
        "            QE_line_update.update(0)\n",
        "            angle = QP_line.get_angle() - QE_line.get_angle()\n",
        "            label.rotate(angle, about_point=Q_dot.get_center())\n",
        "            return label\n",
        "\n",
        "        distance_label_rotate_update_animation = Mobject.add_updater(\n",
        "            self.distance_labels[0],\n",
        "            distance_label_rotate_update\n",
        "        )\n",
        "\n",
        "        # Hook up line to P to P_dot\n",
        "        radial_line = DashedLine(ORIGIN, 3 * RIGHT)\n",
        "        radial_line_update = UpdateFromFunc(\n",
        "            radial_line, lambda l: l.put_start_and_end_on(\n",
        "                circle.get_center(),\n",
        "                P_dot.get_center()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        def put_dot_at_intersection(dot):\n",
        "            point = line_intersection(\n",
        "                line.get_start_and_end(),\n",
        "                radial_line.get_start_and_end()\n",
        "            )\n",
        "            dot.move_to(point)\n",
        "            return dot\n",
        "\n",
        "        keep_Q_dot_at_intersection = UpdateFromFunc(\n",
        "            Q_dot, put_dot_at_intersection\n",
        "        )\n",
        "        Q_dot.restore()\n",
        "\n",
        "        ghost_line_update_animation = UpdateFromFunc(\n",
        "            ghost_line, lambda l: l.put_start_and_end_on(\n",
        "                self.get_eccentricity_point(),\n",
        "                P_dot.get_center()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        def update_perp_bisector(line):\n",
        "            line.scale(ghost_line.get_length() / line.get_length())\n",
        "            line.rotate(ghost_line.get_angle() - line.get_angle())\n",
        "            line.rotate(90 * DEGREES)\n",
        "            line.move_to(ghost_line)\n",
        "        perp_bisector_update_animation = UpdateFromFunc(\n",
        "            line, update_perp_bisector\n",
        "        )\n",
        "        elbow_update_animation = UpdateFromFunc(\n",
        "            elbow,\n",
        "            lambda e: Transform(e, self.get_elbow(ghost_line)).update(1)\n",
        "        )\n",
        "\n",
        "        P_dot_movement_updates = [\n",
        "            radial_line_update,\n",
        "            keep_Q_dot_at_intersection,\n",
        "            MaintainPositionRelativeTo(\n",
        "                P_label, P_dot\n",
        "            ),\n",
        "            ghost_line_update_animation,\n",
        "            perp_bisector_update_animation,\n",
        "            elbow_update_animation,\n",
        "        ]\n",
        "\n",
        "        # Comment for tangency\n",
        "        sum_rect = SurroundingRectangle(\n",
        "            self.numbers[-1]\n",
        "        )\n",
        "        tangency_comment = OldTexText(\n",
        "            \"Always $\\\\ge$ radius\"\n",
        "        )\n",
        "        tangency_comment.next_to(\n",
        "            sum_rect, DOWN,\n",
        "            aligned_edge=RIGHT\n",
        "        )\n",
        "        VGroup(sum_rect, tangency_comment).set_color(GREEN)\n",
        "\n",
        "        # Why is this needed?!?\n",
        "        self.add(*self.focal_sum_things_to_add)\n",
        "        self.wait(0.01)\n",
        "        self.remove(*self.focal_sum_things_to_add)\n",
        "\n",
        "        # Show label\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "\n",
        "        # Show Q_dot moving about a little\n",
        "        self.play(\n",
        "            FadeOut(label),\n",
        "            FadeIn(self.focal_lines),\n",
        "            FadeIn(self.distance_labels),\n",
        "            FadeIn(self.sum_expression),\n",
        "            FadeIn(self.numbers),\n",
        "            ellipse.set_stroke, {\"width\": 0.5},\n",
        "        )\n",
        "        self.add(*self.focal_sum_things_to_add)\n",
        "        self.play(\n",
        "            FadeInFromDown(Q_label),\n",
        "            GrowFromCenter(Q_dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(Q_dot)\n",
        "        self.add(Q_label_animation)\n",
        "        self.play(\n",
        "            Q_dot.move_to, line.point_from_proportion(0.05),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show similar triangles\n",
        "        self.play(\n",
        "            FadeIn(triangles[0]),\n",
        "            ShowCreation(QP_line),\n",
        "            Animation(elbow),\n",
        "        )\n",
        "        self.add(QP_line_update)\n",
        "        for i in range(3):\n",
        "            self.play(\n",
        "                FadeIn(triangles[(i + 1) % 2]),\n",
        "                FadeOut(triangles[i % 2]),\n",
        "                Animation(self.distance_labels),\n",
        "                Animation(elbow)\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(triangles[1]),\n",
        "            Animation(self.distance_labels)\n",
        "        )\n",
        "\n",
        "        # Move first distance label\n",
        "        # (boy, this got messy...hopefully no one ever has\n",
        "        # to read this.)\n",
        "        angle = QP_line.get_angle() - QE_line.get_angle()\n",
        "        Q_point = Q_dot.get_center()\n",
        "        for x in range(2):\n",
        "            self.play(ShowCreationThenDestruction(QE_line))\n",
        "        distance_label_copy = self.distance_labels[0].copy()\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                distance_label_rotate_update,\n",
        "                distance_label_copy,\n",
        "                path_arc=angle\n",
        "            ),\n",
        "            Rotate(QE_line, angle, about_point=Q_point)\n",
        "        )\n",
        "        self.play(FadeOut(QE_line))\n",
        "        self.remove(distance_label_copy)\n",
        "        self.add(distance_label_rotate_update_animation)\n",
        "        self.focal_sum_things_to_add.append(\n",
        "            distance_label_rotate_update_animation\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Q_dot.move_to, line.point_from_proportion(0),\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back\n",
        "        )\n",
        "\n",
        "        # Trace out ellipse\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyFunction(put_dot_at_intersection, Q_dot),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                P_dot,\n",
        "                about_point=circle.get_center(),\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "                run_time=10,\n",
        "            ),\n",
        "            ellipse.restore,\n",
        "            *P_dot_movement_updates\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Talk through tangency\n",
        "        self.play(\n",
        "            ShowCreation(sum_rect),\n",
        "            Write(tangency_comment),\n",
        "        )\n",
        "        points = [line.get_end(), line.get_start(), Q_dot.get_center()]\n",
        "        run_times = [1, 3, 2]\n",
        "        for point, run_time in zip(points, run_times):\n",
        "            self.play(Q_dot.move_to, point, run_time=run_time)\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(*self.focal_sum_things_to_add)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            radial_line,\n",
        "            QP_line,\n",
        "            P_dot, P_label,\n",
        "            Q_dot, Q_label,\n",
        "            elbow,\n",
        "            self.distance_labels,\n",
        "            self.numbers,\n",
        "            self.sum_expression,\n",
        "            sum_rect,\n",
        "            tangency_comment,\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "        # Show all lines\n",
        "        lines.remove(line)\n",
        "        ghost_lines.remove(ghost_line)\n",
        "        for line in lines:\n",
        "            line.generate_target()\n",
        "            line.target.rotate(90 * DEGREES)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, ghost_lines),\n",
        "            LaggedStartMap(FadeIn, lines),\n",
        "        )\n",
        "        self.play(LaggedStartMap(MoveToTarget, lines))\n",
        "        self.wait()\n",
        "\n",
        "    def show_orbiting_planet(self):\n",
        "        ellipse = self.ellipse\n",
        "        ep_dot = self.ep_dot\n",
        "        planet = ImageMobject(\"earth\")\n",
        "        planet.set_height(0.25)\n",
        "        orbit = Orbiting(planet, ep_dot, ellipse)\n",
        "\n",
        "        lines = self.lines\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for gl, line in zip(self.ghost_lines, lines):\n",
        "                intersection = line_intersection(\n",
        "                    [self.circle.get_center(), gl.get_end()],\n",
        "                    line.get_start_and_end()\n",
        "                )\n",
        "                distance = get_norm(\n",
        "                    intersection - planet.get_center()\n",
        "                )\n",
        "                if distance < 0.025:\n",
        "                    line.set_stroke(BLUE, 3)\n",
        "                    self.add(line)\n",
        "                else:\n",
        "                    line.set_stroke(WHITE, 1)\n",
        "\n",
        "        lines_update_animation = Mobject.add_updater(\n",
        "            lines, update_lines\n",
        "        )\n",
        "\n",
        "        self.add(orbit)\n",
        "        self.add(lines_update_animation)\n",
        "        self.add_foreground_mobjects(planet)\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class Enthusiast(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        randy.flip()\n",
        "        self.play(randy.change, \"surprised\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleThinking(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        randy.flip()\n",
        "        self.play(randy.change, \"thinking\", 3 * UP)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"hooray\", 3 * UP)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndOfGeometryProofiness(GeometryProofLand):\n",
        "    def construct(self):\n",
        "        geometry_word = self.get_geometry_proof_land_word()\n",
        "        orbital_mechanics = OldTexText(\"Orbital Mechanics\")\n",
        "        orbital_mechanics.scale(1.5)\n",
        "        orbital_mechanics.to_edge(UP)\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.match_width(orbital_mechanics)\n",
        "        underline.next_to(orbital_mechanics, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOutAndShiftDown, geometry_word))\n",
        "        self.play(FadeInFromDown(orbital_mechanics))\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KeplersSecondLaw(AskAboutEllipses):\n",
        "    CONFIG = {\n",
        "        \"sun_center\": 4 * RIGHT + 0.75 * DOWN,\n",
        "        \"animate_sun\": True,\n",
        "        \"a\": 5.0,\n",
        "        \"b\": 3.0,\n",
        "        \"ellipse_stroke_width\": 2,\n",
        "        \"area_color\": COBALT,\n",
        "        \"area_opacity\": 0.75,\n",
        "        \"arc_color\": YELLOW,\n",
        "        \"arc_stroke_width\": 3,\n",
        "        \"n_sample_sweeps\": 5,\n",
        "        \"fade_sample_areas\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_sun()\n",
        "        self.add_orbit()\n",
        "        self.add_foreground_mobjects(self.comet)\n",
        "\n",
        "        self.show_several_sweeps()\n",
        "        self.contrast_close_to_far()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Kepler's 2nd law:\")\n",
        "        title.scale(1.0)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "        subtitle = OldTexText(\n",
        "            \"Orbits sweep a constant area per unit time\"\n",
        "        )\n",
        "        subtitle.next_to(title, DOWN, buff=0.2)\n",
        "        subtitle.set_color(BLUE)\n",
        "        self.add(subtitle)\n",
        "\n",
        "    def show_several_sweeps(self):\n",
        "        shown_areas = VGroup()\n",
        "        for x in range(self.n_sample_sweeps):\n",
        "            self.wait()\n",
        "            area = self.show_area_sweep()\n",
        "            shown_areas.add(area)\n",
        "        self.wait()\n",
        "        if self.fade_sample_areas:\n",
        "            self.play(FadeOut(shown_areas))\n",
        "\n",
        "    def contrast_close_to_far(self):\n",
        "        orbit = self.orbit\n",
        "        sun_point = self.sun.get_center()\n",
        "\n",
        "        start_prop = 0.9\n",
        "        self.wait_until_proportion(start_prop)\n",
        "        self.show_area_sweep()\n",
        "        end_prop = orbit.proportion\n",
        "        arc = self.get_arc(start_prop, end_prop)\n",
        "        radius = Line(sun_point, arc.get_points()[0])\n",
        "        radius.set_color(WHITE)\n",
        "\n",
        "        radius_words = self.get_radius_words(radius, \"Short\")\n",
        "        radius_words.next_to(radius.get_center(), LEFT, SMALL_BUFF)\n",
        "\n",
        "        arc_words = OldTexText(\"Long arc\")\n",
        "        arc_words.rotate(90 * DEGREES)\n",
        "        arc_words.scale(0.5)\n",
        "        arc_words.next_to(RIGHT, RIGHT)\n",
        "        arc_words.apply_complex_function(np.exp)\n",
        "        arc_words.scale(0.8)\n",
        "        arc_words.next_to(\n",
        "            arc, RIGHT, buff=-SMALL_BUFF\n",
        "        )\n",
        "        arc_words.shift(4 * SMALL_BUFF * DOWN)\n",
        "        arc_words.match_color(arc)\n",
        "\n",
        "        # Show stubby arc\n",
        "        # self.remove(orbit)\n",
        "        # self.add(self.comet)\n",
        "        self.play(\n",
        "            ShowCreation(radius),\n",
        "            Write(radius_words),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(arc_words)\n",
        "        )\n",
        "\n",
        "        # Show narrow arc\n",
        "        # (Code repetition...uck)\n",
        "        start_prop = 0.475\n",
        "        self.wait_until_proportion(start_prop)\n",
        "        self.show_area_sweep()\n",
        "        end_prop = orbit.proportion\n",
        "        short_arc = self.get_arc(start_prop, end_prop)\n",
        "        long_radius = Line(sun_point, short_arc.get_points()[0])\n",
        "        long_radius.set_color(WHITE)\n",
        "        long_radius_words = self.get_radius_words(long_radius, \"Long\")\n",
        "\n",
        "        short_arc_words = OldTexText(\"Short arc\")\n",
        "        short_arc_words.scale(0.5)\n",
        "        short_arc_words.rotate(90 * DEGREES)\n",
        "        short_arc_words.next_to(short_arc, LEFT, SMALL_BUFF)\n",
        "        short_arc_words.match_color(short_arc)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(long_radius),\n",
        "            Write(long_radius_words),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(short_arc),\n",
        "            Write(short_arc_words)\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "    # Helpers\n",
        "    def show_area_sweep(self, time=1.0):\n",
        "        orbit = self.orbit\n",
        "        start_prop = orbit.proportion\n",
        "        area = self.get_area(start_prop, start_prop)\n",
        "        area_update = UpdateFromFunc(\n",
        "            area,\n",
        "            lambda a: Transform(\n",
        "                a, self.get_area(start_prop, orbit.proportion)\n",
        "            ).update(1)\n",
        "        )\n",
        "\n",
        "        self.play(area_update, run_time=time)\n",
        "\n",
        "        return area\n",
        "\n",
        "    def get_area(self, prop1, prop2):\n",
        "        \"\"\"\n",
        "        Return a mobject illustrating the area swept\n",
        "        out between a point prop1 of the way along\n",
        "        the ellipse, and prop2 of the way.\n",
        "        \"\"\"\n",
        "        sun_point = self.sun.get_center()\n",
        "        arc = self.get_arc(prop1, prop2)\n",
        "\n",
        "        # Add lines from start\n",
        "        result = VMobject()\n",
        "        result.append_vectorized_mobject(\n",
        "            Line(sun_point, arc.get_points()[0])\n",
        "        )\n",
        "        result.append_vectorized_mobject(arc)\n",
        "        result.append_vectorized_mobject(\n",
        "            Line(arc.get_points()[-1], sun_point)\n",
        "        )\n",
        "\n",
        "        result.set_stroke(WHITE, width=0)\n",
        "        result.set_fill(\n",
        "            self.area_color,\n",
        "            self.area_opacity,\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def get_arc(self, prop1, prop2):\n",
        "        ellipse = self.get_ellipse()\n",
        "        prop1 = prop1 % 1.0\n",
        "        prop2 = prop2 % 1.0\n",
        "\n",
        "        if prop2 > prop1:\n",
        "            arc = VMobject().pointwise_become_partial(\n",
        "                ellipse, prop1, prop2\n",
        "            )\n",
        "        elif prop1 > prop2:\n",
        "            arc, arc_extension = [\n",
        "                VMobject().pointwise_become_partial(\n",
        "                    ellipse, p1, p2\n",
        "                )\n",
        "                for p1, p2 in [(prop1, 1.0), (0.0, prop2)]\n",
        "            ]\n",
        "            arc.append_vectorized_mobject(arc_extension)\n",
        "        else:\n",
        "            arc = VectorizedPoint(\n",
        "                ellipse.point_from_proportion(prop1)\n",
        "            )\n",
        "\n",
        "        arc.set_stroke(\n",
        "            self.arc_color,\n",
        "            self.arc_stroke_width,\n",
        "        )\n",
        "\n",
        "        return arc\n",
        "\n",
        "    def wait_until_proportion(self, prop):\n",
        "        if self.skip_animations:\n",
        "            self.orbit.proportion = prop\n",
        "        else:\n",
        "            while (self.orbit.proportion % 1) < prop:\n",
        "                self.wait(self.frame_duration)\n",
        "\n",
        "    def get_radius_words(self, radius, adjective):\n",
        "        radius_words = OldTexText(\n",
        "            \"%s radius\" % adjective,\n",
        "        )\n",
        "        min_width = 0.8 * radius.get_length()\n",
        "        if radius_words.get_width() > min_width:\n",
        "            radius_words.set_width(min_width)\n",
        "        radius_words.match_color(radius)\n",
        "        radius_words.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "        angle = radius.get_angle()\n",
        "        angle = ((angle + PI) % TAU) - PI\n",
        "        if np.abs(angle) > PI / 2:\n",
        "            angle += PI\n",
        "        radius_words.rotate(angle, about_point=ORIGIN)\n",
        "        radius_words.shift(radius.get_center())\n",
        "        return radius_words\n",
        "\n",
        "\n",
        "class NonEllipticalKeplersLaw(KeplersSecondLaw):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"sun_center\": 2 * RIGHT,\n",
        "        \"n_sample_sweeps\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_sun()\n",
        "        self.add_orbit()\n",
        "        self.show_several_sweeps()\n",
        "\n",
        "    def add_orbit(self):\n",
        "        sun = self.sun\n",
        "        comet = ImageMobject(\"comet\", height=0.5)\n",
        "        orbit_shape = self.get_ellipse()\n",
        "\n",
        "        orbit = self.orbit = Orbiting(comet, sun, orbit_shape)\n",
        "        self.add(orbit_shape)\n",
        "        self.add(orbit)\n",
        "\n",
        "        arrow, arrow_update = self.get_force_arrow_and_update(\n",
        "            comet\n",
        "        )\n",
        "        alt_arrow_update = Mobject.add_updater(\n",
        "            arrow, lambda a: a.scale(\n",
        "                1.0 / a.get_length(),\n",
        "                about_point=a.get_start()\n",
        "            )\n",
        "        )\n",
        "        self.add(arrow_update, alt_arrow_update)\n",
        "        self.add_foreground_mobjects(comet, arrow)\n",
        "\n",
        "        self.ellipse = orbit_shape\n",
        "\n",
        "    def get_ellipse(self):\n",
        "        orbit_shape = ParametricCurve(\n",
        "            lambda t: (1 + 0.2 * np.sin(5 * TAU * t)) * np.array([\n",
        "                np.cos(TAU * t),\n",
        "                np.sin(TAU * t),\n",
        "                0\n",
        "            ])\n",
        "        )\n",
        "        orbit_shape.set_height(7)\n",
        "        orbit_shape.stretch(1.5, 0)\n",
        "        orbit_shape.shift(LEFT)\n",
        "        orbit_shape.set_stroke(GREY_B, 1)\n",
        "        return orbit_shape\n",
        "\n",
        "\n",
        "class AngularMomentumArgument(KeplersSecondLaw):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": False,\n",
        "        \"sun_center\": 4 * RIGHT + DOWN,\n",
        "        \"comet_start_point\": 4 * LEFT,\n",
        "        \"comet_end_point\": 5 * LEFT + DOWN,\n",
        "        \"comet_height\": 0.3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_sun()\n",
        "        self.show_small_sweep()\n",
        "        self.show_sweep_dimensions()\n",
        "        self.show_conservation_of_angular_momentum()\n",
        "\n",
        "    def show_small_sweep(self):\n",
        "        sun_center = self.sun_center\n",
        "        comet_start = self.comet_start_point\n",
        "        comet_end = self.comet_end_point\n",
        "        triangle = Polygon(\n",
        "            sun_center, comet_start, comet_end,\n",
        "            fill_opacity=1,\n",
        "            fill_color=COBALT,\n",
        "            stroke_width=0,\n",
        "        )\n",
        "        triangle.save_state()\n",
        "        alt_triangle = Polygon(\n",
        "            sun_center,\n",
        "            interpolate(comet_start, comet_end, 0.9),\n",
        "            comet_end\n",
        "        )\n",
        "        alt_triangle.match_style(triangle)\n",
        "\n",
        "        comet = self.get_comet()\n",
        "        comet.move_to(comet_start)\n",
        "\n",
        "        velocity_vector = Arrow(\n",
        "            comet_start, comet_end,\n",
        "            color=WHITE,\n",
        "            buff=0\n",
        "        )\n",
        "        velocity_vector_label = OldTex(\"\\\\vec{\\\\textbf{v}}\")\n",
        "        velocity_vector_label.next_to(\n",
        "            velocity_vector.get_center(), UL,\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        small_time_label = OldTexText(\n",
        "            \"Small\", \"time\", \"$\\\\Delta t$\",\n",
        "        )\n",
        "        small_time_label.to_edge(UP)\n",
        "        small = small_time_label.get_part_by_tex(\"Small\")\n",
        "        small_rect = SurroundingRectangle(small)\n",
        "\n",
        "        self.add_foreground_mobjects(comet)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                triangle,\n",
        "                rate_func=lambda t: interpolate(1.0 / 3, 2.0 / 3, t)\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(\n",
        "                velocity_vector, comet\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(\n",
        "                velocity_vector_label,\n",
        "                velocity_vector,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                comet.move_to, comet_end,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Write(small_time_label), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(triangle, alt_triangle),\n",
        "            ShowCreation(small_rect),\n",
        "            small.set_color, YELLOW,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(triangle),\n",
        "            FadeOut(small_rect),\n",
        "            small.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.triangle = triangle\n",
        "        self.comet = comet\n",
        "        self.delta_t = small_time_label.get_part_by_tex(\n",
        "            \"$\\\\Delta t$\"\n",
        "        )\n",
        "        self.velocity_vector = velocity_vector\n",
        "        self.small_time_label = small_time_label\n",
        "\n",
        "    def show_sweep_dimensions(self):\n",
        "        triangle = self.triangle\n",
        "        # velocity_vector = self.velocity_vector\n",
        "        delta_t = self.delta_t\n",
        "        comet = self.comet\n",
        "\n",
        "        triangle_points = triangle.get_anchors()[:3]\n",
        "        top = triangle_points[1]\n",
        "\n",
        "        area_label = OldTex(\n",
        "            \"\\\\text{Area}\", \"=\", \"\\\\frac{1}{2}\",\n",
        "            \"\\\\text{Base}\", \"\\\\times\", \"\\\\text{Height}\",\n",
        "        )\n",
        "        area_label.set_color_by_tex_to_color_map({\n",
        "            \"Base\": PINK,\n",
        "            \"Height\": YELLOW,\n",
        "        })\n",
        "        area_label.to_edge(UP)\n",
        "        equals = area_label.get_part_by_tex(\"=\")\n",
        "        area_expression = OldTex(\n",
        "            \"=\", \"\\\\frac{1}{2}\", \"R\", \"\\\\times\",\n",
        "            \"\\\\vec{\\\\textbf{v}}_\\\\perp\",\n",
        "            \"\\\\Delta t\",\n",
        "        )\n",
        "        area_expression.set_color_by_tex_to_color_map({\n",
        "            \"R\": PINK,\n",
        "            \"textbf{v}\": YELLOW,\n",
        "        })\n",
        "        area_expression.next_to(area_label, DOWN)\n",
        "        area_expression.align_to(equals, LEFT)\n",
        "\n",
        "        self.R_v_perp = VGroup(*area_expression[-4:-1])\n",
        "        self.R_v_perp_rect = SurroundingRectangle(\n",
        "            self.R_v_perp,\n",
        "            stroke_color=BLUE,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "\n",
        "        base = Line(triangle_points[2], triangle_points[0])\n",
        "        base.set_stroke(PINK, 3)\n",
        "        base_point = line_intersection(\n",
        "            base.get_start_and_end(),\n",
        "            [top, top + DOWN]\n",
        "        )\n",
        "        height = Line(top, base_point)\n",
        "        height.set_stroke(YELLOW, 3)\n",
        "\n",
        "        radius_label = OldTexText(\"Radius\")\n",
        "        radius_label.next_to(base, DOWN, SMALL_BUFF)\n",
        "        radius_label.match_color(base)\n",
        "\n",
        "        R_term = area_expression.get_part_by_tex(\"R\")\n",
        "        R_term.save_state()\n",
        "        R_term.move_to(radius_label[0])\n",
        "        R_term.set_fill(opacity=0.5)\n",
        "\n",
        "        v_perp = Arrow(*height.get_start_and_end(), buff=0)\n",
        "        v_perp.set_color(YELLOW)\n",
        "        v_perp.shift(comet.get_center() - v_perp.get_start())\n",
        "        v_perp_label = OldTex(\n",
        "            \"\\\\vec{\\\\textbf{v}}_\\\\perp\"\n",
        "        )\n",
        "        v_perp_label.set_color(YELLOW)\n",
        "        v_perp_label.next_to(v_perp, RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        v_perp_delta_t = VGroup(v_perp_label.copy(), delta_t.copy())\n",
        "        v_perp_delta_t.generate_target()\n",
        "        v_perp_delta_t.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        v_perp_delta_t.target.next_to(height, RIGHT, SMALL_BUFF)\n",
        "        self.small_time_label.add(v_perp_delta_t[1])\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(area_label),\n",
        "            self.small_time_label.scale, 0.5,\n",
        "            self.small_time_label.to_corner, UL,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(base),\n",
        "            Write(radius_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(height))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(v_perp),\n",
        "            Write(v_perp_label, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(v_perp_delta_t))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                area_label.get_part_by_tex(tex).copy(),\n",
        "                area_expression.get_part_by_tex(tex),\n",
        "            )\n",
        "            for tex in (\"=\", \"\\\\frac{1}{2}\", \"\\\\times\")\n",
        "        ])\n",
        "        self.play(Restore(R_term))\n",
        "        self.play(ReplacementTransform(\n",
        "            v_perp_delta_t.copy(),\n",
        "            VGroup(*area_expression[-2:])\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_conservation_of_angular_momentum(self):\n",
        "        R_v_perp = self.R_v_perp\n",
        "        R_v_perp_rect = self.R_v_perp_rect\n",
        "        sun_center = self.sun_center\n",
        "        comet = self.comet\n",
        "        comet.save_state()\n",
        "\n",
        "        vector_field = VectorField(\n",
        "            get_force_field_func((sun_center, -1))\n",
        "        )\n",
        "        vector_field.set_fill(opacity=0.8)\n",
        "        vector_field.sort(\n",
        "            lambda p: -get_norm(p - sun_center)\n",
        "        )\n",
        "\n",
        "        stays_constant = OldTexText(\"Stays constant\")\n",
        "        stays_constant.next_to(\n",
        "            R_v_perp_rect, DR, buff=MED_LARGE_BUFF\n",
        "        )\n",
        "        stays_constant.match_color(R_v_perp_rect)\n",
        "        stays_constant_arrow = Arrow(\n",
        "            stays_constant.get_left(),\n",
        "            R_v_perp_rect.get_bottom(),\n",
        "            color=R_v_perp_rect.get_color()\n",
        "        )\n",
        "\n",
        "        sun_dot = Dot(sun_center, fill_opacity=0.25)\n",
        "        big_dot = Dot(fill_opacity=0, radius=FRAME_WIDTH)\n",
        "\n",
        "        R_v_perp.save_state()\n",
        "        R_v_perp.generate_target()\n",
        "        R_v_perp.target.to_edge(LEFT, buff=MED_LARGE_BUFF)\n",
        "        lp, rp = parens = OldTex(\"()\")\n",
        "        lp.next_to(R_v_perp.target, LEFT)\n",
        "        rp.next_to(R_v_perp.target, RIGHT)\n",
        "\n",
        "        self.play(Transform(\n",
        "            big_dot, sun_dot,\n",
        "            run_time=1,\n",
        "            remover=True\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            DrawBorderThenFill(R_v_perp_rect),\n",
        "            Animation(R_v_perp),\n",
        "            Write(stays_constant, run_time=1),\n",
        "            GrowArrow(stays_constant_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        foreground = VGroup(*self.get_mobjects())\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, vector_field),\n",
        "            Animation(foreground)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    ApplyFunction, vector_field,\n",
        "                    lambda mob: (lambda m: m.scale(1.1).set_fill(opacity=1), mob),\n",
        "                    rate_func=there_and_back,\n",
        "                    run_time=1\n",
        "                ),\n",
        "                Animation(foreground)\n",
        "            )\n",
        "        self.play(\n",
        "            FadeIn(parens),\n",
        "            MoveToTarget(R_v_perp),\n",
        "        )\n",
        "        self.play(\n",
        "            comet.scale, 2,\n",
        "            comet.next_to, parens, RIGHT, {\"buff\": SMALL_BUFF}\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(parens),\n",
        "            R_v_perp.restore,\n",
        "            comet.restore,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class KeplersSecondLawImage(KeplersSecondLaw):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": False,\n",
        "        \"n_sample_sweeps\": 8,\n",
        "        \"fade_sample_areas\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_sun()\n",
        "        self.add_foreground_mobjects(self.sun)\n",
        "        self.add_orbit()\n",
        "        self.add_foreground_mobjects(self.comet)\n",
        "        self.show_several_sweeps()\n",
        "\n",
        "\n",
        "class HistoryOfAngularMomentum(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"fill_opacity\": 1}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        am = VGroup(OldTexText(\"Angular momentum\"))\n",
        "        k2l = OldTexText(\"Kepler's 2nd law\")\n",
        "        arrow = Arrow(ORIGIN, RIGHT)\n",
        "\n",
        "        group = VGroup(am, arrow, k2l)\n",
        "        group.arrange(RIGHT)\n",
        "        group.next_to(self.hold_up_spot, UL)\n",
        "\n",
        "        k2l_image = ImageMobject(\"Kepler2ndLaw\")\n",
        "        k2l_image.match_width(k2l)\n",
        "        k2l_image.next_to(k2l, UP)\n",
        "        k2l.add(k2l_image)\n",
        "\n",
        "        angular_momentum_formula = OldTex(\n",
        "            \"R\", \"\\\\times\", \"m\", \"\\\\vec{\\\\textbf{v}}_\\\\perp\",\n",
        "        )\n",
        "        angular_momentum_formula.set_color_by_tex_to_color_map({\n",
        "            \"R\": PINK,\n",
        "            \"v\": YELLOW,\n",
        "        })\n",
        "        angular_momentum_formula.next_to(am, UP)\n",
        "        am.add(angular_momentum_formula)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(group),\n",
        "            self.change_students(*3 * [\"pondering\"])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            am.next_to, arrow, RIGHT,\n",
        "            {\"index_of_submobject_to_align\": 0},\n",
        "            k2l.next_to, arrow, LEFT,\n",
        "            {\"index_of_submobject_to_align\": 0},\n",
        "            path_arc=90 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class FeynmanRecountingNewton(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        feynman_teaching = ImageMobject(\"Feynman_teaching\")\n",
        "        feynman_teaching.set_width(FRAME_WIDTH)\n",
        "\n",
        "        newton = ImageMobject(\"Newton\")\n",
        "        principia = ImageMobject(\"Principia_equal_area\")\n",
        "        images = [newton, principia]\n",
        "        for image in images:\n",
        "            image.set_height(5)\n",
        "        newton.to_corner(UL)\n",
        "        principia.next_to(newton, RIGHT)\n",
        "        for image in images:\n",
        "            image.rect = SurroundingRectangle(\n",
        "                image, color=WHITE, buff=0,\n",
        "            )\n",
        "\n",
        "        self.play(FadeInFromDown(feynman_teaching, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(newton),\n",
        "            FadeInFromDown(newton.rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            FadeIn(\n",
        "                mob, direction=3 * LEFT\n",
        "            )\n",
        "            for mob in (principia, principia.rect)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceShapeOfVelocities(AskAboutEllipses, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"sun_center\": 2 * RIGHT,\n",
        "        \"a\": 4.0,\n",
        "        \"b\": 3.5,\n",
        "        \"num_vectors\": 25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_orbit()\n",
        "        self.warp_orbit()\n",
        "        self.reference_inverse_square_law()\n",
        "        self.show_velocity_vectors()\n",
        "        self.collect_velocity_vectors()\n",
        "\n",
        "    def setup_orbit(self):\n",
        "        self.add_sun()\n",
        "        self.add_orbit()\n",
        "        self.add_foreground_mobjects(self.comet)\n",
        "\n",
        "    def warp_orbit(self):\n",
        "        def func(z, c=3.5):\n",
        "            return 1 * (np.exp((1.0 / c) * (z) + 1) - np.exp(1))\n",
        "\n",
        "        ellipse = self.ellipse\n",
        "        ellipse.save_state()\n",
        "        ellipse.generate_target()\n",
        "        ellipse.target.stretch(0.7, 1)\n",
        "        ellipse.target.apply_complex_function(func)\n",
        "        ellipse.target.replace(ellipse, dim_to_match=1)\n",
        "\n",
        "        self.wait(5)\n",
        "        self.play(MoveToTarget(ellipse, run_time=2))\n",
        "        self.wait(5)\n",
        "\n",
        "    def reference_inverse_square_law(self):\n",
        "        ellipse = self.ellipse\n",
        "        force_equation = OldTex(\n",
        "            \"F\", \"=\", \"{G\", \"M\", \"m\", \"\\\\over\", \"R^2}\"\n",
        "        )\n",
        "        force_equation.move_to(ellipse)\n",
        "        force_equation.set_color_by_tex(\"F\", YELLOW)\n",
        "\n",
        "        force_arrow, force_arrow_update = self.get_force_arrow_and_update(\n",
        "            self.comet, scale_factor=3,\n",
        "        )\n",
        "        radial_line, radial_line_update = self.get_radial_line_and_update(\n",
        "            self.comet\n",
        "        )\n",
        "\n",
        "        self.add(radial_line_update)\n",
        "        self.add(force_arrow_update)\n",
        "        self.play(\n",
        "            Restore(ellipse),\n",
        "            Write(force_equation),\n",
        "            UpdateFromAlphaFunc(\n",
        "                force_arrow,\n",
        "                lambda m, a: m.set_fill(opacity=a)\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                radial_line,\n",
        "                lambda m, a: m.set_stroke(width=a)\n",
        "            ),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    def show_velocity_vectors(self):\n",
        "        alphas = np.linspace(0, 1, self.num_vectors, endpoint=False)\n",
        "        vectors = VGroup(*[\n",
        "            self.get_velocity_vector(alpha)\n",
        "            for alpha in alphas\n",
        "        ])\n",
        "\n",
        "        moving_vector, moving_vector_animation = self.get_velocity_vector_and_update()\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, vectors,\n",
        "            lag_ratio=0.2,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait(5)\n",
        "\n",
        "        self.add(moving_vector_animation)\n",
        "        self.play(\n",
        "            FadeOut(vectors),\n",
        "            VFadeIn(moving_vector)\n",
        "        )\n",
        "        self.wait(10)\n",
        "        vectors.set_fill(opacity=0.5)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, vectors),\n",
        "            Animation(moving_vector)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.velocity_vectors = vectors\n",
        "        self.moving_vector = moving_vector\n",
        "\n",
        "    def collect_velocity_vectors(self):\n",
        "        vectors = self.velocity_vectors.copy()\n",
        "        frame = self.camera_frame\n",
        "        ellipse = self.ellipse\n",
        "\n",
        "        frame_shift = 2.5 * LEFT\n",
        "        root_point = ellipse.get_left() + 3 * LEFT + 1 * UP\n",
        "        vector_targets = VGroup()\n",
        "        for vector in vectors:\n",
        "            vector.target = Arrow(\n",
        "                root_point,\n",
        "                root_point + vector.get_vector(),\n",
        "                buff=0,\n",
        "                rectangular_stem_width=0.025,\n",
        "                tip_length=0.2,\n",
        "                color=vector.get_color(),\n",
        "            )\n",
        "            vector.target.add_to_back(\n",
        "                vector.target.copy().set_stroke(BLACK, 5)\n",
        "            )\n",
        "            vector_targets.add(vector.target)\n",
        "\n",
        "        circle = Circle(color=YELLOW)\n",
        "        circle.replace(vector_targets)\n",
        "        circle.scale(1.04)\n",
        "\n",
        "        velocity_space = OldTexText(\"Velocity space\")\n",
        "        velocity_space.next_to(circle, UP)\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(circle, velocity_space),\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            color=WHITE,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                frame.shift, frame_shift,\n",
        "                run_time=2,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, vectors,\n",
        "                run_time=4,\n",
        "            ),\n",
        "            FadeInFromDown(velocity_space),\n",
        "            FadeInFromDown(rect),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Animation(vectors)\n",
        "        )\n",
        "        self.wait(24)\n",
        "\n",
        "    # Helpers\n",
        "    def get_velocity_vector(self, alpha, d_alpha=0.01, scalar=3.0):\n",
        "        norm = get_norm\n",
        "        ellipse = self.ellipse\n",
        "        sun_center = self.sun.get_center()\n",
        "\n",
        "        min_length = 0.1 * scalar\n",
        "        max_length = 0.5 * scalar\n",
        "\n",
        "        p1, p2 = [\n",
        "            ellipse.point_from_proportion(a)\n",
        "            for a in (alpha, alpha + d_alpha)\n",
        "        ]\n",
        "        vector = Arrow(\n",
        "            p1, p2, buff=0\n",
        "        )\n",
        "        radius_vector = p1 - sun_center\n",
        "        curr_v_perp = norm(np.cross(\n",
        "            vector.get_vector(),\n",
        "            radius_vector / norm(radius_vector)\n",
        "        ))\n",
        "        vector.scale(\n",
        "            scalar / (norm(curr_v_perp) * norm(radius_vector)),\n",
        "            about_point=vector.get_start()\n",
        "        )\n",
        "        vector.set_color(\n",
        "            interpolate_color(\n",
        "                BLUE, RED, inverse_interpolate(\n",
        "                    min_length, max_length,\n",
        "                    vector.get_length()\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        vector.add_to_back(\n",
        "            vector.copy().set_stroke(BLACK, 5)\n",
        "        )\n",
        "        return vector\n",
        "\n",
        "    def get_velocity_vector_and_update(self):\n",
        "        moving_vector = self.get_velocity_vector(0)\n",
        "\n",
        "        def update_moving_vector(vector):\n",
        "            new_vector = self.get_velocity_vector(\n",
        "                self.orbit.proportion,\n",
        "            )\n",
        "            Transform(vector, new_vector).update(1)\n",
        "\n",
        "        moving_vector_animation = Mobject.add_updater(\n",
        "            moving_vector, update_moving_vector\n",
        "        )\n",
        "        return moving_vector, moving_vector_animation\n",
        "\n",
        "\n",
        "class AskWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Um...why?\",\n",
        "            target_mode=\"confused\",\n",
        "            index=2,\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"happy\",\n",
        "            self.change_students(\n",
        "                \"raise_left_hand\", \"sassy\", \"confused\"\n",
        "            )\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class FeynmanConfusedByNewton(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ShowEqualAngleSlices(IntroduceShapeOfVelocities):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"theta\": 30 * DEGREES,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_orbit()\n",
        "        self.show_equal_angle_slices()\n",
        "        self.ask_about_time_per_slice()\n",
        "        self.areas_are_proportional_to_radius_squared()\n",
        "        self.show_inverse_square_law()\n",
        "        self.directly_compare_velocity_vectors()\n",
        "\n",
        "    def setup_orbit(self):\n",
        "        IntroduceShapeOfVelocities.setup_orbit(self)\n",
        "        self.remove(self.orbit)\n",
        "        self.add(self.comet)\n",
        "\n",
        "    def show_equal_angle_slices(self):\n",
        "        sun_center = self.sun.get_center()\n",
        "        ellipse = self.ellipse\n",
        "\n",
        "        def get_cos_angle_diff(v1, v2):\n",
        "            return np.dot(\n",
        "                v1 / get_norm(v1),\n",
        "                v2 / get_norm(v2),\n",
        "            )\n",
        "\n",
        "        lines = VGroup()\n",
        "        angle_arcs = VGroup()\n",
        "        thetas = VGroup()\n",
        "        angles = np.arange(0, TAU, self.theta)\n",
        "        for angle in angles:\n",
        "            prop = angle / TAU\n",
        "            vect = rotate_vector(RIGHT, angle)\n",
        "            end_point = ellipse.point_from_proportion(prop)\n",
        "            curr_cos = get_cos_angle_diff(\n",
        "                end_point - sun_center, vect\n",
        "            )\n",
        "            coss_diff = (1 - curr_cos)\n",
        "            while abs(coss_diff) > 0.00001:\n",
        "                d_prop = 0.001\n",
        "                alt_end = ellipse.point_from_proportion(\n",
        "                    (prop + d_prop) % 1\n",
        "                )\n",
        "                alt_cos = get_cos_angle_diff(alt_end - sun_center, vect)\n",
        "                d_cos = (alt_cos - curr_cos)\n",
        "\n",
        "                delta_prop = (coss_diff / d_cos) * d_prop\n",
        "                prop += delta_prop\n",
        "                end_point = ellipse.point_from_proportion(prop)\n",
        "                curr_cos = get_cos_angle_diff(end_point - sun_center, vect)\n",
        "                coss_diff = 1 - curr_cos\n",
        "\n",
        "            line = Line(sun_center, end_point)\n",
        "            line.prop = prop\n",
        "            lines.add(line)\n",
        "\n",
        "            angle_arc = AnnularSector(\n",
        "                angle=self.theta,\n",
        "                inner_radius=1,\n",
        "                outer_radius=1.05,\n",
        "            )\n",
        "            angle_arc.rotate(angle, about_point=ORIGIN)\n",
        "            angle_arc.scale(0.5, about_point=ORIGIN)\n",
        "            angle_arc.shift(sun_center)\n",
        "            angle_arc.mid_angle = angle + self.theta / 2\n",
        "            angle_arcs.add(angle_arc)\n",
        "\n",
        "            theta = OldTex(\"\\\\theta\")\n",
        "            theta.scale(0.6)\n",
        "            vect = rotate_vector(RIGHT, angle_arc.mid_angle)\n",
        "            theta.move_to(\n",
        "                angle_arc.get_center() + 0.2 * vect\n",
        "            )\n",
        "            thetas.add(theta)\n",
        "\n",
        "        arcs = VGroup()\n",
        "        wedges = VGroup()\n",
        "        for l1, l2 in adjacent_pairs(lines):\n",
        "            arc = VMobject()\n",
        "            arc.pointwise_become_partial(\n",
        "                ellipse, l1.prop, (l2.prop or 1.0)\n",
        "            )\n",
        "            arcs.add(arc)\n",
        "\n",
        "            wedge = VMobject()\n",
        "            wedge.append_vectorized_mobject(\n",
        "                Line(sun_center, arc.get_points()[0])\n",
        "            )\n",
        "            wedge.append_vectorized_mobject(arc)\n",
        "            wedge.append_vectorized_mobject(\n",
        "                Line(arc.get_points()[-1], sun_center)\n",
        "            )\n",
        "            wedges.add(wedge)\n",
        "\n",
        "        lines.set_stroke(GREY_B, 2)\n",
        "        angle_arcs.set_color_by_gradient(\n",
        "            YELLOW, BLUE, RED, PINK, YELLOW\n",
        "        )\n",
        "        arcs.set_color_by_gradient(BLUE, YELLOW)\n",
        "        wedges.set_stroke(width=0)\n",
        "        wedges.set_fill(opacity=1)\n",
        "        wedges.set_color_by_gradient(BLUE, COBALT, BLUE_E, BLUE)\n",
        "\n",
        "        kwargs = {\n",
        "            \"run_time\": 6,\n",
        "            \"lag_ratio\": 0.2,\n",
        "            \"rate_func\": there_and_back,\n",
        "        }\n",
        "        faders = VGroup(wedges, angle_arcs, thetas)\n",
        "        faders.set_fill(opacity=0.4)\n",
        "        thetas.set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(faders),\n",
        "            *list(map(ShowCreation, lines))\n",
        "        )\n",
        "        self.play(*[\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, fader,\n",
        "                lambda m: (m.set_fill, {\"opacity\": 1}),\n",
        "                **kwargs\n",
        "            )\n",
        "            for fader in faders\n",
        "        ] + [Animation(lines)])\n",
        "        self.wait()\n",
        "\n",
        "        self.lines = lines\n",
        "        self.wedges = wedges\n",
        "        self.arcs = arcs\n",
        "        self.angle_arcs = angle_arcs\n",
        "        self.thetas = thetas\n",
        "\n",
        "    def ask_about_time_per_slice(self):\n",
        "        wedge1 = self.wedges[0]\n",
        "        wedge2 = self.wedges[len(self.wedges) / 2]\n",
        "        arc1 = self.arcs[0]\n",
        "        arc2 = self.arcs[len(self.arcs) / 2]\n",
        "        comet = self.comet\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        words1 = OldTexText(\n",
        "            \"Time spent \\\\\\\\ traversing \\\\\\\\ this slice?\"\n",
        "        )\n",
        "        words2 = OldTexText(\"How about \\\\\\\\ this one?\")\n",
        "\n",
        "        words1.to_corner(UR)\n",
        "        words2.next_to(wedge2, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        arrow1 = Arrow(\n",
        "            words1.get_bottom(),\n",
        "            wedge1.get_center() + wedge1.get_height() * DOWN / 2,\n",
        "            color=WHITE,\n",
        "        )\n",
        "        arrow2 = Arrow(\n",
        "            words2.get_right(),\n",
        "            wedge2.get_center() + wedge2.get_height() * UL / 4,\n",
        "            color=WHITE\n",
        "        )\n",
        "\n",
        "        foreground = VGroup(\n",
        "            self.ellipse, self.angle_arcs,\n",
        "            self.lines, comet,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words1),\n",
        "            wedge1.set_fill, {\"opacity\": 1},\n",
        "            GrowArrow(arrow1),\n",
        "            Animation(foreground),\n",
        "            frame.scale, 1.2,\n",
        "        )\n",
        "        self.play(MoveAlongPath(comet, arc1, rate_func=linear))\n",
        "        self.play(\n",
        "            Write(words2),\n",
        "            wedge2.set_fill, {\"opacity\": 1},\n",
        "            Write(arrow2),\n",
        "            Animation(foreground),\n",
        "        )\n",
        "        self.play(MoveAlongPath(comet, arc2, rate_func=linear, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        self.area_questions = VGroup(words1, words2)\n",
        "        self.area_question_arrows = VGroup(arrow1, arrow2)\n",
        "        self.highlighted_wedges = VGroup(wedge1, wedge2)\n",
        "\n",
        "    def areas_are_proportional_to_radius_squared(self):\n",
        "        wedges = self.highlighted_wedges\n",
        "        wedge = wedges[1]\n",
        "        frame = self.camera_frame\n",
        "        ellipse = self.ellipse\n",
        "        sun_center = self.sun.get_center()\n",
        "\n",
        "        line = self.lines[len(self.lines) / 2]\n",
        "        thick_line = line.copy().set_stroke(PINK, 4)\n",
        "        radius_word = OldTexText(\"Radius\")\n",
        "        radius_word.next_to(thick_line, UP, SMALL_BUFF)\n",
        "        radius_word.match_color(thick_line)\n",
        "\n",
        "        arc = self.arcs[len(self.arcs) / 2]\n",
        "        thick_arc = arc.copy().set_stroke(RED, 4)\n",
        "\n",
        "        scaling_group = VGroup(\n",
        "            wedge, thick_line, radius_word, thick_arc\n",
        "        )\n",
        "\n",
        "        expression = OldTexText(\n",
        "            \"Time\", \"$\\\\propto$\",\n",
        "            \"Area\", \"$\\\\propto$\", \"$(\\\\text{Radius})^2$\"\n",
        "        )\n",
        "        expression.next_to(ellipse, UP, LARGE_BUFF)\n",
        "\n",
        "        prop_to_brace = Brace(expression[1], DOWN, buff=SMALL_BUFF)\n",
        "        prop_to_words = OldTexText(\"(proportional to)\")\n",
        "        prop_to_words.scale(0.7)\n",
        "        prop_to_words.next_to(prop_to_brace, DOWN, SMALL_BUFF)\n",
        "        VGroup(prop_to_words, prop_to_brace).set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            Write(expression[:3]),\n",
        "            frame.shift, 0.5 * UP,\n",
        "            FadeInFromDown(prop_to_words),\n",
        "            GrowFromCenter(prop_to_brace),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(thick_line),\n",
        "            FadeInFromDown(radius_word)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenDestruction(thick_arc))\n",
        "        self.play(ShowCreation(thick_arc))\n",
        "        self.wait()\n",
        "        self.play(Write(expression[3:]))\n",
        "        self.play(\n",
        "            scaling_group.scale, 0.5,\n",
        "            {\"about_point\": sun_center},\n",
        "            Animation(self.area_question_arrows),\n",
        "            Animation(self.comet),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        expression.add(prop_to_brace, prop_to_words)\n",
        "        self.proportionality_expression = expression\n",
        "\n",
        "    def show_inverse_square_law(self):\n",
        "        prop_exp = self.proportionality_expression\n",
        "        comet = self.comet\n",
        "        frame = self.camera_frame\n",
        "        ellipse = self.ellipse\n",
        "        orbit = self.orbit\n",
        "        next_line = self.lines[(len(self.lines) / 2) + 1]\n",
        "\n",
        "        arc = self.arcs[len(self.arcs) / 2]\n",
        "\n",
        "        force_expression = OldTex(\n",
        "            \"ma\", \"=\", \"\\\\text{Force}\",\n",
        "            \"\\\\propto\", \"\\\\frac{1}{(\\\\text{Radius})^2}\"\n",
        "        )\n",
        "        force_expression.next_to(ellipse, LEFT, MED_LARGE_BUFF)\n",
        "        force_expression.align_to(prop_exp, UP)\n",
        "        force_expression.set_color_by_tex(\"Force\", YELLOW)\n",
        "\n",
        "        acceleration_expression = OldTex(\n",
        "            \"a\", \"=\", \"{\\\\Delta v\",\n",
        "            \"\\\\over\", \"\\\\Delta t}\",\n",
        "            \"\\\\propto\", \"{1 \\\\over (\\\\text{Radius})^2}\"\n",
        "        )\n",
        "        acceleration_expression.next_to(\n",
        "            force_expression, DOWN, buff=0.75,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "\n",
        "        delta_v_expression = OldTex(\n",
        "            \"\\\\Delta v}\", \"\\\\propto\",\n",
        "            \"{\\\\Delta t\", \"\\\\over\", \"(\\\\text{Radius})^2}\"\n",
        "        )\n",
        "        delta_v_expression.next_to(\n",
        "            acceleration_expression, DOWN, buff=0.75,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        delta_t_numerator = delta_v_expression.get_part_by_tex(\n",
        "            \"\\\\Delta t\"\n",
        "        )\n",
        "        moving_R_squared = prop_exp.get_part_by_tex(\"Radius\").copy()\n",
        "        moving_R_squared.generate_target()\n",
        "        moving_R_squared.target.move_to(delta_t_numerator, DOWN)\n",
        "        moving_R_squared.target.set_color(GREEN)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.next_to(force_expression, DOWN, LARGE_BUFF)\n",
        "\n",
        "        force_vector, force_vector_update = self.get_force_arrow_and_update(\n",
        "            comet, scale_factor=3,\n",
        "        )\n",
        "        moving_vector, moving_vector_animation = self.get_velocity_vector_and_update()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.area_questions),\n",
        "            FadeOut(self.area_question_arrows),\n",
        "            FadeInFromDown(force_expression),\n",
        "            frame.shift, 2 * LEFT,\n",
        "        )\n",
        "        self.remove(*self.area_questions)\n",
        "        self.play(\n",
        "            randy.change, \"confused\", force_expression,\n",
        "            VFadeIn(randy)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\", force_expression[0],\n",
        "            ShowPassingFlashAround(force_expression[:2]),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeInFromDown(acceleration_expression),\n",
        "            randy.change, \"hooray\", force_expression,\n",
        "            randy.shift, 2 * DOWN,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"thinking\")\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            comet.move_to, arc.get_points()[0],\n",
        "            path_arc=90 * DEGREES\n",
        "        )\n",
        "        force_vector_update.update(0)\n",
        "        self.play(\n",
        "            Blink(randy),\n",
        "            GrowArrow(force_vector)\n",
        "        )\n",
        "        self.add(force_vector_update)\n",
        "        self.add_foreground_mobjects(comet)\n",
        "        # Slightly hacky orbit treatment here...\n",
        "        orbit.proportion = 0.5\n",
        "        moving_vector_animation.update(0)\n",
        "        start_velocity_vector = moving_vector.copy()\n",
        "        self.play(\n",
        "            GrowArrow(start_velocity_vector),\n",
        "            randy.look_at, moving_vector\n",
        "        )\n",
        "        self.add(moving_vector_animation)\n",
        "        self.add(orbit)\n",
        "        while orbit.proportion < next_line.prop:\n",
        "            self.wait(self.frame_duration)\n",
        "        self.remove(orbit)\n",
        "        self.add_foreground_mobjects(comet)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\", force_expression,\n",
        "            randy.shift, 2 * DOWN,\n",
        "            FadeInFromDown(delta_v_expression)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            delta_t_numerator.scale, 1.5, {\"about_edge\": DOWN},\n",
        "            delta_t_numerator.set_color, YELLOW\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(prop_exp[:-2]))\n",
        "        self.play(\n",
        "            delta_t_numerator.fade, 1,\n",
        "            MoveToTarget(moving_R_squared),\n",
        "            randy.change, \"happy\", delta_v_expression\n",
        "        )\n",
        "        delta_v_expression.add(moving_R_squared)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        self.start_velocity_vector = start_velocity_vector\n",
        "        self.end_velocity_vector = moving_vector.copy()\n",
        "        self.moving_vector = moving_vector\n",
        "        self.force_expressions = VGroup(\n",
        "            force_expression,\n",
        "            acceleration_expression,\n",
        "            delta_v_expression,\n",
        "        )\n",
        "\n",
        "    def directly_compare_velocity_vectors(self):\n",
        "        ellipse = self.ellipse\n",
        "        lines = self.lines\n",
        "        expressions = self.force_expressions\n",
        "        vectors = VGroup(*[\n",
        "            self.get_velocity_vector(line.prop)\n",
        "            for line in lines\n",
        "        ])\n",
        "        index = len(vectors) / 2\n",
        "        v1 = vectors[index]\n",
        "        v2 = vectors[index + 1]\n",
        "\n",
        "        root_point = ellipse.get_left() + 3 * LEFT + DOWN\n",
        "        root_dot = Dot(root_point)\n",
        "\n",
        "        for vector in vectors:\n",
        "            vector.save_state()\n",
        "            vector.target = Arrow(\n",
        "                *vector.get_start_and_end(),\n",
        "                color=vector.get_color(),\n",
        "                buff=0\n",
        "            )\n",
        "            vector.target.scale(2)\n",
        "            vector.target.shift(\n",
        "                root_point - vector.target.get_start()\n",
        "            )\n",
        "            vector.target.add_to_back(\n",
        "                vector.target.copy().set_stroke(BLACK, 5)\n",
        "            )\n",
        "\n",
        "        difference_vectors = VGroup()\n",
        "        external_angle_lines = VGroup()\n",
        "        external_angle_arcs = VGroup()\n",
        "        for vect1, vect2 in adjacent_pairs(vectors):\n",
        "            diff_vect = Arrow(\n",
        "                vect1.target.get_end(),\n",
        "                vect2.target.get_end(),\n",
        "                buff=0,\n",
        "                color=YELLOW,\n",
        "                rectangular_stem_width=0.025,\n",
        "                tip_length=0.15\n",
        "            )\n",
        "            diff_vect.add_to_back(\n",
        "                diff_vect.copy().set_stroke(BLACK, 2)\n",
        "            )\n",
        "            difference_vectors.add(diff_vect)\n",
        "\n",
        "            line = Line(\n",
        "                diff_vect.get_start(),\n",
        "                diff_vect.get_start() + 2 * diff_vect.get_vector(),\n",
        "            )\n",
        "            external_angle_lines.add(line)\n",
        "\n",
        "            arc = Arc(self.theta, stroke_width=2)\n",
        "            arc.rotate(line.get_angle(), about_point=ORIGIN)\n",
        "            arc.scale(0.4, about_point=ORIGIN)\n",
        "            arc.shift(line.get_center())\n",
        "            external_angle_arcs.add(arc)\n",
        "        external_angle_lines.set_stroke(GREY_B, 2)\n",
        "        diff_vect = difference_vectors[index]\n",
        "\n",
        "        polygon = Polygon(*[\n",
        "            vect.target.get_end()\n",
        "            for vect in vectors\n",
        "        ])\n",
        "        polygon.set_fill(BLUE_E, opacity=0.8)\n",
        "        polygon.set_stroke(WHITE, 3)\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(v1))\n",
        "        self.play(\n",
        "            MoveToTarget(v1),\n",
        "            GrowFromCenter(root_dot),\n",
        "            expressions.scale, 0.5, {\"about_edge\": UL}\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                v1.saved_state.copy(), v2.saved_state,\n",
        "                path_arc=self.theta\n",
        "            )\n",
        "        )\n",
        "        self.play(MoveToTarget(v2), Animation(root_dot))\n",
        "        self.wait()\n",
        "        self.play(GrowArrow(diff_vect))\n",
        "        self.wait()\n",
        "\n",
        "        n = len(vectors)\n",
        "        for i in range(n - 1):\n",
        "            v1 = vectors[(i + index + 1) % n]\n",
        "            v2 = vectors[(i + index + 2) % n]\n",
        "            diff_vect = difference_vectors[(i + index + 1) % n]\n",
        "            # TODO, v2.saved_state is on screen untracked\n",
        "            self.play(ReplacementTransform(\n",
        "                v1.saved_state.copy(), v2.saved_state,\n",
        "                path_arc=self.theta\n",
        "            ))\n",
        "            self.play(\n",
        "                MoveToTarget(v2),\n",
        "                GrowArrow(diff_vect)\n",
        "            )\n",
        "        self.add(self.orbit)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, external_angle_lines),\n",
        "            LaggedStartMap(ShowCreation, external_angle_arcs),\n",
        "            Animation(difference_vectors),\n",
        "        )\n",
        "        self.add_foreground_mobjects(difference_vectors)\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(polygon))\n",
        "        self.wait(5)\n",
        "        self.play(FadeOut(polygon))\n",
        "        self.wait(15)\n",
        "        self.play(FadeIn(polygon))\n",
        "\n",
        "\n",
        "class ShowEqualAngleSlices15DegreeSlices(ShowEqualAngleSlices):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"theta\": 15 * DEGREES,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowEqualAngleSlices5DegreeSlices(ShowEqualAngleSlices):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"theta\": 5 * DEGREES,\n",
        "    }\n",
        "\n",
        "\n",
        "class IKnowThisIsTricky(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"All you need is \\\\\\\\ infinite intelligence\",\n",
        "            bubble_config={\n",
        "                \"width\": 4,\n",
        "                \"height\": 3,\n",
        "            },\n",
        "            added_anims=[\n",
        "                self.change_students(\n",
        "                    *3 * [\"horrified\"],\n",
        "                    look_at=self.screen\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class PonderOverOffCenterDiagram(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy, morty = self.pi_creatures\n",
        "        velocity_diagram = self.get_velocity_diagram()\n",
        "        bubble = randy.get_bubble()\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            velocity_diagram,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            color=GREY_B\n",
        "        )\n",
        "        rect.stretch(1.2, 1, about_edge=DOWN)\n",
        "        words = OldTexText(\"Velocity space\")\n",
        "        words.next_to(rect.get_top(), DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, velocity_diagram),\n",
        "            randy.change, \"pondering\",\n",
        "            morty.change, \"confused\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(bubble))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            randy.change, \"confused\",\n",
        "            morty.change, \"pondering\",\n",
        "            ShowCreation(rect)\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph(height=2.5)\n",
        "        randy.to_corner(DL)\n",
        "        morty = Mortimer(height=2.5)\n",
        "        morty.to_corner(DR)\n",
        "        return randy, morty\n",
        "\n",
        "    def get_velocity_diagram(self):\n",
        "        circle = Circle(color=WHITE, radius=2)\n",
        "        circle.rotate(90 * DEGREES)\n",
        "        circle.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        root_point = interpolate(\n",
        "            circle.get_center(),\n",
        "            circle.get_bottom(),\n",
        "            0.5,\n",
        "        )\n",
        "        dot = Dot(root_point)\n",
        "        vectors = VGroup()\n",
        "        for a in np.arange(0, 1, 1.0 / 24):\n",
        "            end_point = circle.point_from_proportion(a)\n",
        "            vector = Arrow(root_point, end_point, buff=0)\n",
        "            vector.set_color(interpolate_color(\n",
        "                BLUE, RED,\n",
        "                inverse_interpolate(\n",
        "                    1, 3, vector.get_length(),\n",
        "                )\n",
        "            ))\n",
        "            vector.add_to_back(vector.copy().set_stroke(BLACK, 5))\n",
        "            vectors.add(vector)\n",
        "\n",
        "        vectors.add_to_back(circle)\n",
        "        vectors.add(dot)\n",
        "        return vectors\n",
        "\n",
        "\n",
        "class OneMoreTrick(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        for student in self.students:\n",
        "            student.change(\"tired\")\n",
        "        self.teacher_says(\"Just one more \\\\\\\\ tricky bit!\")\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class UseVelocityDiagramToDeduceCurve(ShowEqualAngleSlices):\n",
        "    CONFIG = {\n",
        "        \"animate_sun\": True,\n",
        "        \"theta\": 15 * DEGREES,\n",
        "        \"index\": 6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_orbit()\n",
        "        self.setup_velocity_diagram()\n",
        "        self.show_theta_degrees()\n",
        "        self.match_velocity_vector_to_tangency()\n",
        "        self.replace_vectors_with_lines()\n",
        "        self.not_that_velocity_vector_is_theta()\n",
        "        self.ask_about_curve()\n",
        "        self.show_90_degree_rotation()\n",
        "        self.show_geometry_of_rotated_diagram()\n",
        "\n",
        "    def setup_orbit(self):\n",
        "        ShowEqualAngleSlices.setup_orbit(self)\n",
        "        self.force_skipping()\n",
        "        self.show_equal_angle_slices()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        orbit_word = self.orbit_word = OldTexText(\"Orbit\")\n",
        "        orbit_word.scale(1.5)\n",
        "        orbit_word.next_to(self.ellipse, UP, LARGE_BUFF)\n",
        "        self.add(orbit_word)\n",
        "\n",
        "    def setup_velocity_diagram(self):\n",
        "        ellipse = self.ellipse\n",
        "        root_point = ellipse.get_left() + 4 * LEFT + DOWN\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        root_dot = Dot(root_point)\n",
        "        vectors = VGroup()\n",
        "        original_vectors = VGroup()\n",
        "        for line in self.lines:\n",
        "            vector = self.get_velocity_vector(line.prop)\n",
        "            vector.save_state()\n",
        "            original_vectors.add(vector.copy())\n",
        "            vector.target = self.get_velocity_vector(\n",
        "                line.prop, scalar=8.0\n",
        "            )\n",
        "            vector.target.shift(\n",
        "                root_point - vector.target.get_start()\n",
        "            )\n",
        "\n",
        "            vectors.add(vector)\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.rotate(92 * DEGREES)\n",
        "        circle.replace(VGroup(*[v.target for v in vectors]))\n",
        "        circle.set_stroke(WHITE, 2)\n",
        "        circle.shift(\n",
        "            (root_point[0] - circle.get_center()[0]) * RIGHT\n",
        "        )\n",
        "        circle.shift(0.035 * LEFT)  # ?!?\n",
        "\n",
        "        velocities_word = OldTexText(\"Velocities\")\n",
        "        velocities_word.scale(1.5)\n",
        "        velocities_word.next_to(circle, UP)\n",
        "        velocities_word.align_to(self.orbit_word, DOWN)\n",
        "\n",
        "        frame.scale(1.2)\n",
        "        frame.shift(3 * LEFT + 0.5 * UP)\n",
        "\n",
        "        self.play(ApplyWave(ellipse))\n",
        "        self.play(*list(map(GrowArrow, vectors)))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, vectors,\n",
        "                lag_ratio=1,\n",
        "                run_time=2\n",
        "            ),\n",
        "            GrowFromCenter(root_dot),\n",
        "            FadeInFromDown(velocities_word),\n",
        "        )\n",
        "        self.add_foreground_mobjects(root_dot)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Animation(vectors),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.vectors = vectors\n",
        "        self.original_vectors = original_vectors\n",
        "        self.velocity_circle = circle\n",
        "        self.root_dot = root_dot\n",
        "        self.circle = circle\n",
        "\n",
        "    def show_theta_degrees(self):\n",
        "        lines = self.lines\n",
        "        ellipse = self.ellipse\n",
        "        circle = self.circle\n",
        "        vectors = self.vectors\n",
        "        comet = self.comet\n",
        "        sun_center = self.sun.get_center()\n",
        "\n",
        "        index = self.index\n",
        "        angle = fdiv(index, len(lines)) * TAU\n",
        "        thick_line = lines[index].copy()\n",
        "        thick_line.set_stroke(RED, 3)\n",
        "        horizontal = lines[0].copy()\n",
        "        horizontal.set_stroke(WHITE, 3)\n",
        "\n",
        "        ellipse_arc = VMobject()\n",
        "        ellipse_arc.pointwise_become_partial(\n",
        "            ellipse, 0, thick_line.prop\n",
        "        )\n",
        "        ellipse_arc.set_stroke(YELLOW, 3)\n",
        "\n",
        "        ellipse_wedge = self.get_wedge(ellipse_arc, sun_center)\n",
        "        ellipse_wedge_start = self.get_wedge(\n",
        "            VectorizedPoint(ellipse.get_right()), sun_center\n",
        "        )\n",
        "\n",
        "        ellipse_angle_arc = Arc(\n",
        "            self.theta * index,\n",
        "            radius=0.5\n",
        "        )\n",
        "        ellipse_angle_arc.shift(sun_center)\n",
        "        ellipse_theta = OldTex(\"\\\\theta\")\n",
        "        ellipse_theta.next_to(ellipse_angle_arc, RIGHT, MED_SMALL_BUFF)\n",
        "        ellipse_theta.shift(2 * SMALL_BUFF * UL)\n",
        "\n",
        "        vector = vectors[index].deepcopy()\n",
        "        vector.set_fill(YELLOW)\n",
        "        vector.save_state()\n",
        "        Transform(vector, vectors[0]).update(1)\n",
        "        vector.set_fill(YELLOW)\n",
        "        circle_arc = VMobject()\n",
        "        circle_arc.pointwise_become_partial(\n",
        "            circle, 0, fdiv(index, len(vectors))\n",
        "        )\n",
        "        circle_arc.set_stroke(RED, 4)\n",
        "        circle_theta = OldTex(\"\\\\theta\")\n",
        "        circle_theta.scale(1.5)\n",
        "        circle_theta.next_to(circle_arc, UP, SMALL_BUFF)\n",
        "        circle_theta.shift(SMALL_BUFF * DL)\n",
        "\n",
        "        circle_wedge = self.get_wedge(circle_arc, circle.get_center())\n",
        "        circle_wedge.set_fill(PINK)\n",
        "        circle_wedge_start = self.get_wedge(\n",
        "            Line(circle.get_top(), circle.get_top()),\n",
        "            circle.get_center()\n",
        "        ).match_style(circle_wedge)\n",
        "\n",
        "        circle_center_dot = Dot(circle.get_center())\n",
        "        # circle_center_dot.set_color(BLUE)\n",
        "\n",
        "        self.play(FocusOn(comet))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                ellipse_wedge_start, ellipse_wedge,\n",
        "                path_arc=angle,\n",
        "            ),\n",
        "            FadeIn(ellipse_arc),\n",
        "            ShowCreation(ellipse_angle_arc),\n",
        "            Write(ellipse_theta),\n",
        "            ReplacementTransform(\n",
        "                lines[0].copy(), thick_line,\n",
        "                path_arc=angle\n",
        "            ),\n",
        "            MoveAlongPath(comet, ellipse_arc),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                circle_wedge_start, circle_wedge,\n",
        "                path_arc=angle\n",
        "            ),\n",
        "            ShowCreation(circle_arc),\n",
        "            Write(circle_theta),\n",
        "            Restore(vector, path_arc=angle),\n",
        "            GrowFromCenter(circle_center_dot),\n",
        "            FadeIn(horizontal),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            index,\n",
        "            ellipse_wedge, ellipse_arc,\n",
        "            ellipse_angle_arc, ellipse_theta,\n",
        "            thick_line, horizontal,\n",
        "            circle_wedge, circle_arc,\n",
        "            circle_theta, circle_center_dot,\n",
        "            highlighted_vector=vector\n",
        "        )\n",
        "\n",
        "    def match_velocity_vector_to_tangency(self):\n",
        "        vector = self.highlighted_vector\n",
        "        comet = self.comet\n",
        "        original_vector = self.original_vectors[self.index].copy()\n",
        "        original_vector.set_fill(YELLOW)\n",
        "\n",
        "        tangent_line = Line(\n",
        "            *original_vector.get_start_and_end()\n",
        "        )\n",
        "        tangent_line.set_stroke(GREY_B, 3)\n",
        "        tangent_line.scale(5)\n",
        "        tangent_line.move_to(comet)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                vector.copy(), original_vector,\n",
        "                run_time=2\n",
        "            ),\n",
        "            Animation(comet),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(tangent_line),\n",
        "            Animation(original_vector),\n",
        "            Animation(comet),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            example_tangent_line=tangent_line,\n",
        "            example_tangent_vector=original_vector,\n",
        "        )\n",
        "\n",
        "    def replace_vectors_with_lines(self):\n",
        "        vectors = self.vectors\n",
        "        original_vectors = self.original_vectors\n",
        "        root_dot = self.root_dot\n",
        "        highlighted_vector = self.highlighted_vector\n",
        "\n",
        "        lines = VGroup()\n",
        "        tangent_lines = VGroup()\n",
        "        for vect, o_vect in zip(vectors, original_vectors):\n",
        "            line = Line(*vect.get_start_and_end())\n",
        "            t_line = Line(*o_vect.get_start_and_end())\n",
        "            t_line.scale(5)\n",
        "            t_line.move_to(o_vect.get_start())\n",
        "\n",
        "            lines.add(line)\n",
        "            tangent_lines.add(t_line)\n",
        "\n",
        "            vect.generate_target()\n",
        "            vect.target.scale(0, about_point=root_dot.get_center())\n",
        "\n",
        "        lines.set_stroke(GREEN, 2)\n",
        "        tangent_lines.set_stroke(GREEN, 2)\n",
        "\n",
        "        highlighted_line = Line(\n",
        "            *highlighted_vector.get_start_and_end(),\n",
        "            stroke_color=YELLOW,\n",
        "            stroke_width=4\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, vectors),\n",
        "            highlighted_vector.scale, 0,\n",
        "            {\"about_point\": root_dot.get_center()},\n",
        "            Animation(highlighted_vector),\n",
        "            Animation(self.circle_wedge),\n",
        "            Animation(self.circle_arc),\n",
        "            Animation(self.circle),\n",
        "            Animation(self.circle_center_dot),\n",
        "        )\n",
        "        self.remove(vectors, highlighted_vector)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            ShowCreation(highlighted_line),\n",
        "            Animation(highlighted_vector),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                lines.copy(),\n",
        "                tangent_lines,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(tangent_lines))\n",
        "\n",
        "        self.eccentric_lines = lines\n",
        "        self.highlighted_line = highlighted_line\n",
        "\n",
        "    def not_that_velocity_vector_is_theta(self):\n",
        "        vector = self.example_tangent_vector\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.move_to(vector.get_start(), DOWN)\n",
        "        angle = vector.get_angle() - 90 * DEGREES\n",
        "        arc = Arc(angle, radius=0.5)\n",
        "        arc.rotate(90 * DEGREES, about_point=ORIGIN)\n",
        "        arc.shift(vector.get_start())\n",
        "\n",
        "        theta_q = OldTex(\"\\\\theta ?\")\n",
        "        theta_q.next_to(arc, UP)\n",
        "        theta_q.shift(SMALL_BUFF * LEFT)\n",
        "        cross = Cross(theta_q)\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            FadeInFromDown(theta_q),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [v_line, arc, theta_q, cross])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.ellipse_theta.copy(), self.circle_theta,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.ellipse_angle_arc.copy(), self.circle_arc,\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.circle.copy(),\n",
        "                self.circle_center_dot,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_curve(self):\n",
        "        ellipse = self.ellipse\n",
        "        circle = self.circle\n",
        "        line = self.highlighted_line.copy()\n",
        "        vector = self.example_tangent_vector\n",
        "\n",
        "        morty = Mortimer(height=2.5)\n",
        "        morty.move_to(ellipse.get_corner(UL))\n",
        "        morty.shift(MED_SMALL_BUFF * LEFT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change, \"confused\", ellipse,\n",
        "            ShowCreationThenDestruction(\n",
        "                ellipse.copy().set_stroke(BLUE, 3),\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Blink(morty),\n",
        "            ApplyWave(ellipse),\n",
        "        )\n",
        "        self.play(morty.look_at, circle)\n",
        "        self.play(morty.change, \"pondering\", circle)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.look_at, ellipse)\n",
        "        self.play(morty.change, \"maybe\", ellipse)\n",
        "        self.play(\n",
        "            line.move_to, vector, run_time=2\n",
        "        )\n",
        "        self.play(FadeOut(line))\n",
        "        self.wait()\n",
        "        self.play(morty.look_at, circle)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(morty))\n",
        "\n",
        "    def show_90_degree_rotation(self):\n",
        "        circle = self.circle\n",
        "        circle_setup = VGroup(\n",
        "            circle, self.eccentric_lines,\n",
        "            self.circle_wedge,\n",
        "            self.circle_arc,\n",
        "            self.highlighted_line,\n",
        "            self.circle_center_dot,\n",
        "            self.root_dot,\n",
        "            self.circle_theta,\n",
        "        )\n",
        "        circle_setup.generate_target()\n",
        "        angle = -90 * DEGREES\n",
        "        circle_setup.target.rotate(\n",
        "            angle,\n",
        "            about_point=circle.get_center()\n",
        "        )\n",
        "        circle_setup.target[-1].rotate(-angle)\n",
        "        circle_setup.target[2].set_fill(opacity=0)\n",
        "        circle_setup.target[2].set_stroke(WHITE, 4)\n",
        "\n",
        "        self.play(MoveToTarget(circle_setup, path_arc=angle))\n",
        "        self.wait()\n",
        "\n",
        "        lines = self.eccentric_lines\n",
        "        highlighted_line = self.highlighted_line\n",
        "        ghost_lines = lines.copy()\n",
        "        ghost_lines.set_stroke(width=1)\n",
        "        ghost_lines[self.index].set_stroke(YELLOW, 4)\n",
        "        for mob in list(lines) + [highlighted_line]:\n",
        "            mob.generate_target()\n",
        "            mob.save_state()\n",
        "            mob.target.rotate(-angle)\n",
        "\n",
        "        foci = [\n",
        "            self.root_dot.get_center(),\n",
        "            circle.get_center(),\n",
        "        ]\n",
        "        a = circle.get_width() / 4\n",
        "        c = get_norm(foci[1] - foci[0]) / 2\n",
        "        b = np.sqrt(a**2 - c**2)\n",
        "        little_ellipse = Circle(radius=a)\n",
        "        little_ellipse.stretch(b / a, 1)\n",
        "        little_ellipse.move_to(center_of_mass(foci))\n",
        "        little_ellipse.set_stroke(PINK, 4)\n",
        "\n",
        "        self.add(ghost_lines)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, lines,\n",
        "                lag_ratio=0.1,\n",
        "                run_time=8,\n",
        "            ),\n",
        "            MoveToTarget(highlighted_line),\n",
        "            path_arc=-angle,\n",
        "        )\n",
        "        self.play(ShowCreation(little_ellipse))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            little_ellipse.replace, self.ellipse,\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back_with_pause\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(*[\n",
        "            Restore(\n",
        "                mob,\n",
        "                path_arc=angle,\n",
        "                run_time=4,\n",
        "                rate_func=there_and_back_with_pause\n",
        "            )\n",
        "            for mob in list(lines) + [highlighted_line]\n",
        "        ] + [Animation(little_ellipse)])\n",
        "\n",
        "        self.ghost_lines = ghost_lines\n",
        "        self.little_ellipse = little_ellipse\n",
        "\n",
        "    def show_geometry_of_rotated_diagram(self):\n",
        "        ellipse = self.ellipse\n",
        "        little_ellipse = self.little_ellipse\n",
        "        circle = self.circle\n",
        "        perp_line = self.highlighted_line.copy()\n",
        "        perp_line.rotate(PI)\n",
        "        circle_arc = self.circle_arc\n",
        "        arc_copy = circle_arc.copy()\n",
        "        center = circle.get_center()\n",
        "        velocity_vector = self.example_tangent_vector\n",
        "\n",
        "        e_line = perp_line.copy().rotate(90 * DEGREES)\n",
        "        c_line = Line(center, e_line.get_end())\n",
        "        c_line.set_stroke(WHITE, 4)\n",
        "\n",
        "        # lines = [c_line, e_line, perp_line]\n",
        "\n",
        "        tangency_point = line_intersection(\n",
        "            perp_line.get_start_and_end(),\n",
        "            c_line.get_start_and_end(),\n",
        "        )\n",
        "        tangency_point_dot = Dot(tangency_point)\n",
        "        tangency_point_dot.set_color(BLUE)\n",
        "        tangency_point_dot.save_state()\n",
        "        tangency_point_dot.scale(5)\n",
        "        tangency_point_dot.set_fill(opacity=0)\n",
        "\n",
        "        def indicate(line):\n",
        "            red_copy = line.copy().set_stroke(RED, 5)\n",
        "            return ShowPassingFlash(red_copy, run_time=2)\n",
        "\n",
        "        self.play(\n",
        "            self.ghost_lines.set_stroke, {\"width\": 0.5},\n",
        "            self.eccentric_lines.set_stroke, {\"width\": 0.5},\n",
        "            *list(map(WiggleOutThenIn, [e_line, c_line]))\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                indicate(e_line),\n",
        "                indicate(c_line),\n",
        "            )\n",
        "        self.play(WiggleOutThenIn(perp_line))\n",
        "        for x in range(2):\n",
        "            self.play(indicate(perp_line))\n",
        "        self.play(Restore(tangency_point_dot))\n",
        "        self.add_foreground_mobjects(tangency_point_dot)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            arc_copy.scale, 0.15, {\"about_point\": center},\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            perp_line.move_to, velocity_vector,\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back_with_pause\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            little_ellipse.replace, ellipse,\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back_with_pause\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "    def get_wedge(self, arc, center_point, opacity=0.8):\n",
        "        wedge = VMobject()\n",
        "        wedge.append_vectorized_mobject(\n",
        "            Line(center_point, arc.get_points()[0])\n",
        "        )\n",
        "        wedge.append_vectorized_mobject(arc)\n",
        "        wedge.append_vectorized_mobject(\n",
        "            Line(arc.get_points()[-1], center_point)\n",
        "        )\n",
        "        wedge.set_stroke(width=0)\n",
        "        wedge.set_fill(COBALT, opacity=opacity)\n",
        "        return wedge\n",
        "\n",
        "\n",
        "class ShowSunVectorField(Scene):\n",
        "    def construct(self):\n",
        "        sun_center = IntroduceShapeOfVelocities.CONFIG[\"sun_center\"]\n",
        "        vector_field = VectorField(\n",
        "            get_force_field_func((sun_center, -1))\n",
        "        )\n",
        "        vector_field.set_fill(opacity=0.8)\n",
        "        vector_field.sort(\n",
        "            lambda p: -get_norm(p - sun_center)\n",
        "        )\n",
        "\n",
        "        for vector in vector_field:\n",
        "            vector.generate_target()\n",
        "            vector.target.set_fill(opacity=1)\n",
        "            vector.target.set_stroke(YELLOW, 0.5)\n",
        "\n",
        "        for x in range(3):\n",
        "            self.play(LaggedStartMap(\n",
        "                MoveToTarget, vector_field,\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.5,\n",
        "            ))\n",
        "\n",
        "\n",
        "class TryToRememberProof(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        words = OldTexText(\"Oh god...how \\\\\\\\ did it go?\")\n",
        "        words.next_to(randy, UP)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            randy.change, \"telepath\",\n",
        "            FadeInFromDown(words)\n",
        "        )\n",
        "        self.look_at(ORIGIN)\n",
        "        self.wait(2)\n",
        "        self.play(randy.change, \"concerned_musician\")\n",
        "        self.look_at(ORIGIN)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class PatYourselfOnTheBack(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Pat yourself \\\\\\\\ on the back!\",\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"happy\")\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode=\"raise_right_hand\"\n",
        "            ),\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=self.screen\n",
        "            )\n",
        "        )\n",
        "        self.look_at(UP)\n",
        "        self.wait(8)\n",
        "        self.play_student_changes(*3 * [\"thinking\"])\n",
        "        self.look_at(UP)\n",
        "        self.wait(12)\n",
        "        self.teacher_says(\"I just love this!\")\n",
        "\n",
        "        feynman = ImageMobject(\"Feynman\", height=4)\n",
        "        feynman.to_corner(UL)\n",
        "        chess = ImageMobject(\"ChessGameOfTheCentury\")\n",
        "        chess.set_height(4)\n",
        "        chess.next_to(feynman)\n",
        "\n",
        "        self.play(FadeInFromDown(feynman))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"happy\"),\n",
        "            FadeInFromDown(chess)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class Thumbnail(ShowEmergingEllipse):\n",
        "    CONFIG = {\n",
        "        \"num_lines\": 50,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        background = ImageMobject(\"Feynman_teaching\")\n",
        "        background.set_width(FRAME_WIDTH)\n",
        "        background.scale(1.05)\n",
        "        background.to_corner(UR, buff=0)\n",
        "        background.shift(2 * UP)\n",
        "\n",
        "        self.add(background)\n",
        "\n",
        "        circle = self.get_circle()\n",
        "        circle.set_stroke(width=6)\n",
        "        circle.set_height(6.5)\n",
        "        circle.to_corner(UL)\n",
        "        circle.set_fill(BLACK, 0.9)\n",
        "        lines = self.get_lines()\n",
        "        lines.set_stroke(YELLOW, 5)\n",
        "        lines.set_color_by_gradient(YELLOW, RED)\n",
        "        ghost_lines = self.get_ghost_lines(lines)\n",
        "        for line in lines:\n",
        "            line.rotate(90 * DEGREES)\n",
        "        ellipse = self.get_ellipse()\n",
        "        ellipse.set_stroke(BLUE, 6)\n",
        "        sun = ImageMobject(\"sun\", height=0.5)\n",
        "        sun.move_to(self.get_eccentricity_point())\n",
        "\n",
        "        circle_group = VGroup(circle, ghost_lines, lines, ellipse, sun)\n",
        "        self.add(circle_group)\n",
        "\n",
        "        l1 = Line(\n",
        "            circle.point_from_proportion(0.175),\n",
        "            6.25 * RIGHT + 0.75 * DOWN\n",
        "        )\n",
        "        l2 = Line(\n",
        "            circle.point_from_proportion(0.75),\n",
        "            6.25 * RIGHT + 2.5 * DOWN\n",
        "        )\n",
        "        l2a = VMobject().pointwise_become_partial(l2, 0, 0.56)\n",
        "        l2b = VMobject().pointwise_become_partial(l2, 0.715, 1)\n",
        "        expand_lines = VGroup(l1, l2a, l2b)\n",
        "\n",
        "        expand_lines.set_stroke(\"RED\", 5)\n",
        "        self.add(expand_lines)\n",
        "        self.add(circle_group)\n",
        "\n",
        "        small_group = circle_group.copy()\n",
        "        small_group.scale(0.2)\n",
        "        small_group.stretch(1.35, 1)\n",
        "        small_group.move_to(6.2 * RIGHT + 1.6 * DOWN)\n",
        "        for mob in small_group:\n",
        "            if isinstance(mob, VMobject) and mob.get_stroke_width() > 1:\n",
        "                mob.set_stroke(width=1)\n",
        "        small_group[0].set_fill(opacity=0.25)\n",
        "        self.add(small_group)\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"Feynman's \\\\\\\\\", \"Lost \\\\\\\\\", \"Lecture\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        title.scale(2.4)\n",
        "        for part in title:\n",
        "            part.add_to_back(\n",
        "                part.copy().set_stroke(BLACK, 12).set_fill(BLACK, 1)\n",
        "            )\n",
        "        title.to_corner(UR)\n",
        "        title[2].to_edge(RIGHT)\n",
        "        title[1].shift(0.9 * RIGHT)\n",
        "        title.shift(0.5 * LEFT)\n",
        "        self.add(title)\n"
    ]
}