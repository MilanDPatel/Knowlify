{
    "topic": "The mathematical concept being demonstrated is the concept of Bayes' theorem, which is a formula for updating",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "#########\n",
        "\n",
        "class BayesOpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"Inside every non-Bayesian there \\\\\\\\ is a Bayesian struggling to get out.\"\n",
        "        ],\n",
        "        \"author\" : \"Dennis V. Lindley\",\n",
        "    }\n",
        "\n",
        "class IntroducePokerHand(PiCreatureScene, SampleSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"community_cards_center\" : 1.5*DOWN,\n",
        "        \"community_card_values\" : [\"10S\", \"QH\", \"AH\", \"2C\", \"5H\"],\n",
        "        \"your_hand_values\" : [\"JS\", \"KC\"],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_cards()\n",
        "        self.indicate_straight()\n",
        "        self.show_flush_potential()\n",
        "        self.compute_flush_probability()\n",
        "        self.show_flush_sample_space()\n",
        "        self.talk_through_sample_space()\n",
        "        self.place_high_bet()\n",
        "        self.change_belief()\n",
        "        self.move_community_cards_out_of_the_way()\n",
        "        self.name_bayes_rule()\n",
        "\n",
        "    def add_cards(self):\n",
        "        you, her = self.you, self.her\n",
        "        community_cards = VGroup(*list(map(\n",
        "            PlayingCard, self.community_card_values\n",
        "        )))\n",
        "        community_cards.arrange(RIGHT)\n",
        "        community_cards.move_to(self.community_cards_center)\n",
        "        deck = VGroup(*[\n",
        "            PlayingCard(turned_over = True)\n",
        "            for x in range(5)\n",
        "        ])\n",
        "        for i, card in enumerate(deck):\n",
        "            card.shift(i*(0.03*RIGHT + 0.015*DOWN))\n",
        "        deck.next_to(community_cards, LEFT)\n",
        "\n",
        "        you.hand = self.get_hand(you, self.your_hand_values)\n",
        "        her.hand = self.get_hand(her, None)\n",
        "        hand_cards = VGroup(*it.chain(*list(zip(you.hand, her.hand))))\n",
        "\n",
        "        self.add(deck)\n",
        "        for group in hand_cards, community_cards:\n",
        "            for card in group:\n",
        "                card.generate_target()\n",
        "                card.scale(0.01)\n",
        "                card.move_to(deck[-1], UP+RIGHT)\n",
        "            self.play(LaggedStartMap(MoveToTarget, group, lag_ratio = 0.8))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.community_cards = community_cards\n",
        "        self.deck = deck\n",
        "\n",
        "    def indicate_straight(self):\n",
        "        you = self.you\n",
        "        community_cards = self.community_cards\n",
        "        you.hand.save_state()\n",
        "        you.hand.generate_target()\n",
        "        for card in you.hand.target:\n",
        "            card.set_height(community_cards.get_height())\n",
        "\n",
        "        selected_community_cards = VGroup(*[card for card in community_cards if card.numerical_value >= 10])\n",
        "        selected_community_cards.submobjects.sort(\n",
        "            key=lambda c: c.numerical_value\n",
        "        )\n",
        "\n",
        "        selected_community_cards.save_state()\n",
        "        for card in selected_community_cards:\n",
        "            card.generate_target()\n",
        "\n",
        "        straight_cards = VGroup(*it.chain(\n",
        "            you.hand.target, \n",
        "            [c.target for c in selected_community_cards]\n",
        "        ))\n",
        "        straight_cards.submobjects.sort(\n",
        "            key=lambda c: c.numerical_value\n",
        "        )\n",
        "        straight_cards.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        straight_cards.next_to(community_cards, UP, aligned_edge = LEFT)\n",
        "        you.hand.target.shift(MED_SMALL_BUFF*UP)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget,\n",
        "            selected_community_cards,\n",
        "            run_time = 1.5\n",
        "        ))\n",
        "        self.play(MoveToTarget(you.hand))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            straight_cards,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 1.5,\n",
        "            lag_ratio = 0.5,\n",
        "            remover = True,\n",
        "        ))\n",
        "        self.play(you.change, \"hooray\", straight_cards)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            selected_community_cards.restore,\n",
        "            you.hand.restore,\n",
        "            you.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_flush_potential(self):\n",
        "        you, her = self.you, self.her\n",
        "        heart_cards = VGroup(*[c for c in self.community_cards if c.suit == \"hearts\"])\n",
        "        heart_cards.save_state()\n",
        "\n",
        "        her.hand.save_state()\n",
        "        her.hand.generate_target()\n",
        "        her.hand.target.arrange(RIGHT)\n",
        "        her.hand.target.next_to(heart_cards, UP)\n",
        "        her.hand.target.to_edge(UP)\n",
        "\n",
        "        her.glasses.save_state()\n",
        "        her.glasses.move_to(her.hand.target)\n",
        "        her.glasses.set_fill(opacity = 0)\n",
        "\n",
        "        heart_qs = VGroup()\n",
        "        hearts = VGroup()\n",
        "        q_marks = VGroup()\n",
        "        for target in her.hand.target:\n",
        "            heart = SuitSymbol(\"hearts\")\n",
        "            q_mark = OldTex(\"?\")\n",
        "            heart_q = VGroup(heart, q_mark)\n",
        "            for mob in heart_q:\n",
        "                mob.set_height(0.5)\n",
        "            heart_q.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            heart_q.move_to(target)\n",
        "            heart_qs.add(heart, q_mark)\n",
        "            hearts.add(heart)\n",
        "            q_marks.add(q_mark)\n",
        "\n",
        "        self.play(heart_cards.shift, heart_cards.get_height()*UP)\n",
        "        self.play(you.change_mode, \"hesitant\")\n",
        "        self.play(MoveToTarget(her.hand))\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, heart_qs))\n",
        "        self.play(\n",
        "            her.change, \"happy\",\n",
        "            her.glasses.restore,\n",
        "        )\n",
        "        self.pi_creatures.remove(her)\n",
        "        new_suit_pairs = [\n",
        "            (\"clubs\", \"diamonds\"),\n",
        "            (\"diamonds\", \"spades\"),\n",
        "            (\"spades\", \"clubs\"),\n",
        "            (\"hearts\", \"hearts\"),\n",
        "        ]\n",
        "        for new_suit_pair in new_suit_pairs:\n",
        "            new_symbols = VGroup(*list(map(SuitSymbol, new_suit_pair)))\n",
        "            for new_symbol, heart in zip(new_symbols, hearts):\n",
        "                new_symbol.replace(heart, dim_to_match = 1)\n",
        "            self.play(Transform(\n",
        "                hearts, new_symbols,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(heart_qs))\n",
        "        self.play(\n",
        "            heart_cards.restore,\n",
        "            her.hand.restore,\n",
        "            you.change_mode, \"pondering\",\n",
        "        )\n",
        "\n",
        "        self.q_marks = q_marks\n",
        "\n",
        "    def compute_flush_probability(self):\n",
        "        you, her = self.you, self.her\n",
        "        equation = OldTex(\n",
        "            \"{ {10 \\\\choose 2}\", \"\\\\over\", \"{45 \\\\choose 2} }\", \n",
        "            \"=\", \"{45 \\\\over 990}\", \"\\\\approx\", \"4.5\\\\%\"\n",
        "        )\n",
        "        equation.next_to(self.community_cards, UP, buff = LARGE_BUFF)\n",
        "        percentage = equation.get_part_by_tex(\"4.5\")\n",
        "\n",
        "        ten = VGroup(*equation[0][1:3])\n",
        "        num_hearts = OldTexText(\"\\\\# Remaining hearts\")\n",
        "        num_hearts.scale(0.75)\n",
        "        num_hearts.next_to(\n",
        "            ten, UP, aligned_edge = LEFT\n",
        "        )\n",
        "        num_hearts.to_edge(UP)\n",
        "        num_hearts.set_color(RED)\n",
        "        num_hearts_arrow = Arrow(\n",
        "            num_hearts.get_bottom(), ten.get_right(),\n",
        "            color = RED, buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        fourty_five = VGroup(*equation[2][1:3])\n",
        "        num_cards = OldTexText(\"\\\\# Remaining cards\")\n",
        "        num_cards.scale(0.75)\n",
        "        num_cards.next_to(fourty_five, LEFT)\n",
        "        num_cards.to_edge(LEFT)\n",
        "        num_cards.set_color(BLUE)\n",
        "        num_cards_arrow = Arrow(\n",
        "            num_cards, fourty_five,\n",
        "            color = BLUE, buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, equation))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(num_hearts), \n",
        "            ShowCreation(num_hearts_arrow),\n",
        "            ten.set_color, RED,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(num_cards), \n",
        "            ShowCreation(num_cards_arrow),\n",
        "            fourty_five.set_color, BLUE\n",
        "        )\n",
        "        self.wait(3)\n",
        "        equation.remove(percentage)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            equation, \n",
        "            num_hearts, num_hearts_arrow,\n",
        "            num_cards, num_cards_arrow,\n",
        "        ])))\n",
        "\n",
        "\n",
        "        self.percentage = percentage\n",
        "\n",
        "    def show_flush_sample_space(self):\n",
        "        you, her = self.you, self.her\n",
        "        percentage = self.percentage\n",
        "\n",
        "        sample_space = self.get_sample_space()\n",
        "        sample_space.add_title(\"Your belief\")\n",
        "        sample_space.move_to(VGroup(you.hand, her.hand))\n",
        "        sample_space.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        p = 1./22\n",
        "        sample_space.divide_horizontally(\n",
        "            p, colors = [SuitSymbol.CONFIG[\"red\"], BLUE_E]\n",
        "        )\n",
        "        braces, labels = sample_space.get_side_braces_and_labels([\n",
        "            percentage.get_tex(), \"95.5\\\\%\"\n",
        "        ])\n",
        "        top_label, bottom_label = labels\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(sample_space),\n",
        "            ReplacementTransform(percentage, top_label)\n",
        "        )\n",
        "        self.play(*list(map(GrowFromCenter, [\n",
        "            brace for brace in braces\n",
        "        ])))\n",
        "        self.wait(2)\n",
        "        self.play(Write(bottom_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.sample_space = sample_space\n",
        "\n",
        "    def talk_through_sample_space(self):\n",
        "        her = self.her\n",
        "        sample_space = self.sample_space\n",
        "        top_part, bottom_part = self.sample_space.horizontal_parts\n",
        "\n",
        "        flush_hands, non_flush_hands = hand_lists = [\n",
        "            [self.get_hand(her, keys) for keys in key_list]\n",
        "            for key_list in [\n",
        "                [(\"3H\", \"8H\"), (\"4H\", \"5H\"), (\"JH\", \"KH\")],\n",
        "                [(\"AC\", \"6D\"), (\"3D\", \"6S\"), (\"JH\", \"4C\")],\n",
        "            ]\n",
        "        ]   \n",
        "        for hand_list, part in zip(hand_lists, [top_part, bottom_part]):\n",
        "            self.play(Indicate(part, scale_factor = 1))\n",
        "            for hand in hand_list:\n",
        "                hand.save_state()\n",
        "                hand.scale(0.01)\n",
        "                hand.move_to(part.get_right())\n",
        "                self.play(hand.restore)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, it.chain(*hand_lists))))\n",
        "\n",
        "    def place_high_bet(self):\n",
        "        you, her = self.you, self.her\n",
        "        pre_money = VGroup(*[\n",
        "            VGroup(*[\n",
        "                OldTex(\"\\\\$\")\n",
        "                for x in range(10)\n",
        "            ]).arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            for y in range(4)\n",
        "        ]).arrange(UP, buff = SMALL_BUFF)\n",
        "        money = VGroup(*it.chain(*pre_money))\n",
        "        money.set_color(GREEN)\n",
        "        money.scale(0.8)\n",
        "        money.next_to(her.hand, DOWN)\n",
        "        for dollar in money:\n",
        "            dollar.save_state()\n",
        "            dollar.scale(0.01)\n",
        "            dollar.move_to(her.get_boundary_point(RIGHT))\n",
        "            dollar.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            money,\n",
        "            lambda m : (m.restore,),\n",
        "            run_time = 5,\n",
        "        ))\n",
        "        self.play(you.change_mode, \"confused\")\n",
        "        self.wait()\n",
        "\n",
        "        self.money = money\n",
        "\n",
        "    def change_belief(self):\n",
        "        numbers = self.sample_space.horizontal_parts.labels\n",
        "        rect = Rectangle(stroke_width = 0)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.stretch_to_fit_width(numbers.get_width())\n",
        "        rect.stretch_to_fit_height(self.sample_space.get_height())\n",
        "        rect.move_to(numbers, UP)\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        anims = self.get_horizontal_division_change_animations(0.2)\n",
        "        anims.append(Animation(rect))\n",
        "        self.play(\n",
        "            *anims,\n",
        "            run_time = 3,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "    def move_community_cards_out_of_the_way(self):\n",
        "        cards = self.community_cards\n",
        "        cards.generate_target()\n",
        "        cards.target.arrange(\n",
        "            RIGHT, buff = -cards[0].get_width() + MED_SMALL_BUFF,\n",
        "        )\n",
        "        cards.target.move_to(self.deck)\n",
        "        cards.target.to_edge(LEFT)\n",
        "\n",
        "        self.sample_space.add_braces_and_labels()\n",
        "\n",
        "        self.play(\n",
        "            self.deck.scale, 0.7,\n",
        "            self.deck.next_to, cards.target, UP,\n",
        "            self.deck.to_edge, LEFT,\n",
        "            self.sample_space.shift, 3*DOWN,\n",
        "            MoveToTarget(cards)\n",
        "        )\n",
        "\n",
        "    def name_bayes_rule(self):\n",
        "        title = OldTexText(\"Bayes' rule\")\n",
        "        title.set_color(BLUE)\n",
        "        title.to_edge(UP)\n",
        "        subtitle = OldTexText(\"Update \", \"prior \", \"beliefs\")\n",
        "        subtitle.scale(0.8)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        prior_word = subtitle.get_part_by_tex(\"prior\")\n",
        "        numbers = self.sample_space.horizontal_parts.labels\n",
        "        rect = SurroundingRectangle(numbers, color = GREEN)\n",
        "        arrow = Arrow(prior_word.get_bottom(), rect.get_top())\n",
        "        arrow.set_color(GREEN)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Maybe she really \\\\\\\\ does have a flush $\\\\dots$\",\n",
        "            alignment = \"\"\n",
        "        )\n",
        "        words.scale(0.7)\n",
        "        words.next_to(self.money, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(title, run_time = 2),\n",
        "            self.you.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(subtitle))\n",
        "        self.play(prior_word.set_color, GREEN)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(Write(words))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        shift_val = 3\n",
        "        you = PiCreature(color = BLUE_D)\n",
        "        her = PiCreature(color = BLUE_B).flip()\n",
        "        for pi in you, her:\n",
        "            pi.scale(0.5)\n",
        "        you.to_corner(UP+LEFT)\n",
        "        her.to_corner(UP+RIGHT)\n",
        "        you.make_eye_contact(her)\n",
        "\n",
        "        glasses = SunGlasses(her)\n",
        "        her.glasses = glasses\n",
        "\n",
        "        self.you = you\n",
        "        self.her = her\n",
        "        return VGroup(you, her)\n",
        "\n",
        "    def get_hand(self, pi_creature, keys = None):\n",
        "        if keys is not None:\n",
        "            hand = VGroup(*list(map(PlayingCard, keys)))\n",
        "        else:\n",
        "            hand = VGroup(*[\n",
        "                PlayingCard(turned_over = True)\n",
        "                for x in range(2)\n",
        "            ])\n",
        "        hand.scale(0.7)\n",
        "        card1, card2 = hand\n",
        "        vect = np.sign(pi_creature.get_center()[0])*LEFT\n",
        "        card2.move_to(card1)\n",
        "        card2.shift(MED_SMALL_BUFF*RIGHT + SMALL_BUFF*DOWN)\n",
        "        hand.next_to(\n",
        "            pi_creature, vect, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = UP\n",
        "        )\n",
        "        return hand\n",
        "    \n",
        "class HowDoesPokerWork(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait, how does \\\\\\\\ poker work again?\",\n",
        "            target_mode = \"confused\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class YourGutKnowsBayesRule(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Your gut knows \\\\\\\\ Bayes' rule.\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"gracious\", \"guilty\")\n",
        "        self.wait(3)\n",
        "\n",
        "class UpdatePokerPrior(SampleSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"double_heart_template\" : \"HH\",\n",
        "        \"cash_string\" : \"\\\\$\\\\$\\\\$\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_sample_space()\n",
        "        self.add_top_conditionals()\n",
        "        self.react_to_top_conditionals()\n",
        "        self.add_bottom_conditionals()\n",
        "        self.ask_where_conditionals_come_from()\n",
        "        self.vary_conditionals()\n",
        "        self.show_restricted_space()\n",
        "        self.write_P_flush_given_bet()\n",
        "        self.reshape_rectangles()\n",
        "        self.compare_prior_to_posterior()\n",
        "        self.preview_tweaks()\n",
        "        self.tweak_non_flush_case()\n",
        "        self.tweak_flush_case()\n",
        "        self.tweak_prior()\n",
        "        self.compute_posterior()\n",
        "\n",
        "    def add_sample_space(self):\n",
        "        p = 1./22\n",
        "        sample_space = SampleSpace(fill_opacity = 0)\n",
        "        sample_space.shift(LEFT)\n",
        "        sample_space.divide_horizontally(p, colors = [\n",
        "            SuitSymbol.CONFIG[\"red\"], BLUE_E\n",
        "        ])\n",
        "        labels = self.get_prior_labels(p)\n",
        "        braces_and_labels = sample_space.get_side_braces_and_labels(labels)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, sample_space),\n",
        "            Write(braces_and_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sample_space.add(braces_and_labels)\n",
        "        self.sample_space = sample_space\n",
        "\n",
        "    def add_top_conditionals(self):\n",
        "        top_part = self.sample_space.horizontal_parts[0]\n",
        "        color = average_color(YELLOW, GREEN, GREEN)\n",
        "        p = 0.97\n",
        "        top_part.divide_vertically(p, colors = [color, BLUE])\n",
        "        label = self.get_conditional_label(p, True)\n",
        "        brace, _ignore = top_part.get_top_braces_and_labels([label])\n",
        "\n",
        "        explanation = OldTexText(\n",
        "            \"Probability of\", \"high bet\", \"given\", \"flush\"\n",
        "        )\n",
        "        explanation.set_color_by_tex(\"high bet\", GREEN)\n",
        "        explanation.set_color_by_tex(\"flush\", RED)\n",
        "        explanation.scale(0.6)\n",
        "        explanation.next_to(label, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(top_part.vertical_parts),\n",
        "            FadeIn(label),\n",
        "            GrowFromCenter(brace),\n",
        "        )\n",
        "        self.play(Write(explanation, run_time = 3))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.sample_space.add(brace, label)\n",
        "\n",
        "        self.top_explanation = explanation\n",
        "        self.top_conditional_rhs = label[-1]\n",
        "\n",
        "    def react_to_top_conditionals(self):\n",
        "        her = PiCreature(color = BLUE_B).flip()\n",
        "        her.next_to(self.sample_space, RIGHT)\n",
        "        her.to_edge(RIGHT)\n",
        "        glasses = SunGlasses(her)\n",
        "        glasses.save_state()\n",
        "        glasses.shift(UP)\n",
        "        glasses.set_fill(opacity = 0)\n",
        "        her.glasses = glasses\n",
        "\n",
        "        self.play(FadeIn(her))\n",
        "        self.play(glasses.restore)\n",
        "        self.play(\n",
        "            her.change_mode, \"happy\", \n",
        "            Animation(glasses)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.her = her\n",
        "        \n",
        "    def add_bottom_conditionals(self):\n",
        "        her = self.her\n",
        "        bottom_part = self.sample_space.horizontal_parts[1]\n",
        "        p = 0.3\n",
        "        bottom_part.divide_vertically(p, colors = [GREEN_E, BLUE_E])\n",
        "        label = self.get_conditional_label(p, False)\n",
        "        brace, _ignore = bottom_part.get_bottom_braces_and_labels([label])\n",
        "\n",
        "        explanation = OldTexText(\n",
        "            \"Probability of\", \"high bet\", \"given\", \"no flush\"\n",
        "        )\n",
        "        explanation.set_color_by_tex(\"high bet\", GREEN)\n",
        "        explanation.set_color_by_tex(\"no flush\", RED)\n",
        "        explanation.scale(0.6)\n",
        "        explanation.next_to(label, DOWN)\n",
        "\n",
        "        self.play(DrawBorderThenFill(bottom_part.vertical_parts))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(label)\n",
        "        )\n",
        "        self.play(\n",
        "            her.change_mode, \"shruggie\",\n",
        "            MaintainPositionRelativeTo(her.glasses, her.eyes)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(*label[i1:i2]).copy(),\n",
        "                VGroup(explanation[j]),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.5)\n",
        "            )\n",
        "            for a, (i1, i2, j) in zip(np.linspace(0, 0.5, 4), [\n",
        "                (0, 1, 0),\n",
        "                (1, 2, 1),\n",
        "                (2, 3, 2),\n",
        "                (3, 6, 3),\n",
        "            ])\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(*label[-2:])))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [her, her.glasses])))\n",
        "\n",
        "        self.sample_space.add(brace, label)\n",
        "        self.bottom_explanation = explanation\n",
        "        self.bottom_conditional_rhs = label[-1]\n",
        "\n",
        "    def ask_where_conditionals_come_from(self):\n",
        "        randy = Randolph().flip()\n",
        "        randy.scale(0.75)\n",
        "        randy.to_edge(RIGHT)\n",
        "        randy.shift(2*DOWN)\n",
        "        words = OldTexText(\"Where do these \\\\\\\\\", \"numbers\", \"come from?\")\n",
        "        numbers_word = words.get_part_by_tex(\"numbers\")\n",
        "        numbers_word.set_color(YELLOW)\n",
        "        words.scale(0.7)\n",
        "        bubble = ThoughtBubble(height = 3, width = 4)\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        bubble.add_content(words)\n",
        "\n",
        "        numbers = VGroup(\n",
        "            self.top_conditional_rhs, \n",
        "            self.bottom_conditional_rhs\n",
        "        )\n",
        "        numbers.save_state()\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                numbers_word.get_left(), \n",
        "                num.get_right(), \n",
        "                buff = 2*SMALL_BUFF\n",
        "            )\n",
        "            for num in numbers\n",
        "        ])\n",
        "\n",
        "        questions = VGroup(*list(map(TexText, [\n",
        "            \"Does she bluff?\",\n",
        "            \"How much does she have?\",\n",
        "            \"Does she take risks?\",\n",
        "            \"What's her model of me?\",\n",
        "            \"\\\\vdots\"\n",
        "        ])))\n",
        "        questions.arrange(DOWN, aligned_edge = LEFT)\n",
        "        questions[-1].next_to(questions[-2], DOWN)\n",
        "        questions.scale(0.7)\n",
        "        questions.next_to(randy, UP)\n",
        "        questions.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(words, run_time = 2)\n",
        "        )\n",
        "        self.play(*list(map(ShowCreation, arrows)))\n",
        "        self.play(numbers.set_color, YELLOW)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"maybe\")\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            bubble, words, arrows\n",
        "        ])))\n",
        "        for question in questions:\n",
        "            self.play(\n",
        "                FadeIn(question),\n",
        "                randy.look_at, question\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            FadeOut(questions)\n",
        "        )\n",
        "\n",
        "        self.randy = randy\n",
        "\n",
        "    def vary_conditionals(self):\n",
        "        randy = self.randy\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                VGroup(explanation),\n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "            for explanation, rhs in zip(\n",
        "                [self.top_explanation, self.bottom_explanation],\n",
        "                [self.top_conditional_rhs, self.bottom_conditional_rhs],\n",
        "            )\n",
        "        ])\n",
        "\n",
        "        new_conditionals = [\n",
        "            (0.91, 0.4),\n",
        "            (0.83, 0.1),\n",
        "            (0.99, 0.2),\n",
        "            (0.97, 0.3),\n",
        "        ]\n",
        "\n",
        "        self.play(*list(map(ShowCreation, rects)))\n",
        "        self.play(FadeOut(rects))\n",
        "        for i, value in enumerate(it.chain(*new_conditionals)):\n",
        "            self.play(\n",
        "                randy.look_at, rects[i%2],\n",
        "                *self.get_conditional_change_anims(i%2, value)\n",
        "            )\n",
        "            if i%2 == 1:\n",
        "                self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "    def show_restricted_space(self):\n",
        "        high_bet_space, low_bet_space = [\n",
        "            VGroup(*[\n",
        "                self.sample_space.horizontal_parts[i].vertical_parts[j]\n",
        "                for i in range(2)\n",
        "            ])\n",
        "            for j in range(2)\n",
        "        ]\n",
        "        words = OldTex(\"P(\", self.cash_string, \")\")\n",
        "        words.set_color_by_tex(self.cash_string, GREEN)\n",
        "        words.next_to(self.sample_space, RIGHT)\n",
        "        low_bet_space.generate_target()\n",
        "        for submob in low_bet_space.target:\n",
        "            submob.set_color(average_color(\n",
        "                submob.get_color(), *[BLACK]*4\n",
        "            ))\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                words.get_left(),\n",
        "                submob.get_edge_center(vect),\n",
        "                color = submob.get_color()\n",
        "            )\n",
        "            for submob, vect in zip(high_bet_space, [DOWN, RIGHT])\n",
        "        ])\n",
        "\n",
        "        self.play(MoveToTarget(low_bet_space))\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            *list(map(ShowCreation, arrows))\n",
        "        )\n",
        "        self.wait()\n",
        "        for rect in high_bet_space:\n",
        "            self.play(Indicate(rect, scale_factor = 1))\n",
        "        self.play(*list(map(FadeOut, [words, arrows])))\n",
        "\n",
        "        self.high_bet_space = high_bet_space\n",
        "\n",
        "    def write_P_flush_given_bet(self):\n",
        "        posterior_tex = OldTex(\n",
        "            \"P(\", self.double_heart_template, \n",
        "            \"|\", self.cash_string, \")\"\n",
        "        )\n",
        "        posterior_tex.scale(0.7)\n",
        "        posterior_tex.set_color_by_tex(self.cash_string, GREEN)\n",
        "        self.insert_double_heart(posterior_tex)\n",
        "        rects = self.high_bet_space.copy()\n",
        "        rects = [rects[0].copy()] + list(rects)\n",
        "        for rect in rects:\n",
        "            rect.generate_target()\n",
        "        numerator = rects[0].target\n",
        "        plus = OldTex(\"+\")\n",
        "        denominator = VGroup(rects[1].target, plus, rects[2].target)\n",
        "        denominator.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        frac_line = OldTex(\"\\\\over\")\n",
        "        frac_line.stretch_to_fit_width(denominator.get_width())\n",
        "        fraction = VGroup(numerator, frac_line, denominator)\n",
        "        fraction.arrange(DOWN)\n",
        "\n",
        "        arrow = OldTex(\"\\\\downarrow\")\n",
        "        group = VGroup(posterior_tex, arrow, fraction)\n",
        "        group.arrange(DOWN)\n",
        "        group.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, posterior_tex))\n",
        "        self.play(Write(arrow))\n",
        "        self.play(MoveToTarget(rects[0]))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, [frac_line, plus])),\n",
        "            list(map(MoveToTarget, rects[1:]))\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [arrow, fraction] + rects)))\n",
        "\n",
        "        self.posterior_tex = posterior_tex\n",
        "\n",
        "    def reshape_rectangles(self):\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        braces, labels = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [self.posterior_tex.copy()]\n",
        "        )\n",
        "        height_rect = SurroundingRectangle(braces)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                prior_rects.copy(), post_rects,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(self.posterior_tex, labels[0]))\n",
        "        self.posterior_tex = labels[0]\n",
        "        self.play(GrowFromCenter(braces))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(height_rect))\n",
        "        self.play(FadeOut(height_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.post_rects = post_rects\n",
        "\n",
        "    def compare_prior_to_posterior(self):\n",
        "        prior_tex = self.sample_space.horizontal_parts.labels[0]\n",
        "        post_tex = self.posterior_tex\n",
        "        prior_rect, post_rect = [\n",
        "            SurroundingRectangle(tex, stroke_width = 2)\n",
        "            for tex in [prior_tex, post_tex]\n",
        "        ]\n",
        "\n",
        "        post_words = OldTexText(\"Posterior\", \"probability\")\n",
        "        post_words.scale(0.8)\n",
        "        post_words.to_corner(UP+RIGHT)\n",
        "        post_arrow = Arrow(\n",
        "            post_words[0].get_bottom(), post_tex.get_top(),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(prior_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(prior_rect, post_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(post_rect))\n",
        "        self.play(Indicate(post_tex.get_part_by_tex(self.cash_string)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(post_words),\n",
        "            ShowCreation(post_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(post_words[1].fade, 0.8)\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [post_words, post_arrow])))\n",
        "\n",
        "    def preview_tweaks(self):\n",
        "        post_rects = self.post_rects\n",
        "        new_value_lists = [\n",
        "            (0.85, 0.1, 0.11),\n",
        "            (0.97, 0.3, 1./22),\n",
        "        ]\n",
        "        for new_values in new_value_lists:\n",
        "            for i, value in zip(list(range(2)), new_values):\n",
        "                self.play(*self.get_conditional_change_anims(\n",
        "                    i, value, post_rects\n",
        "                ))\n",
        "            self.play(*self.get_prior_change_anims(\n",
        "                new_values[-1], post_rects\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def tweak_non_flush_case(self):\n",
        "        her = self.her\n",
        "        her.scale(0.7)\n",
        "        her.change_mode(\"plain\")\n",
        "        her.shift(DOWN)\n",
        "        her.glasses = SunGlasses(her)\n",
        "        post_rects = self.post_rects\n",
        "        posterior = VGroup(post_rects.braces, post_rects.labels)\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        risk_averse_words = OldTexText(\n",
        "            \"Suppose risk \\\\\\\\ averse \\\\dots\"\n",
        "        )\n",
        "        risk_averse_words.scale(0.7)\n",
        "        risk_averse_words.next_to(her, DOWN)\n",
        "        risk_averse_words.shift_onto_screen()\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(ORIGIN, LEFT, tip_length = SMALL_BUFF)\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        arrows.arrange(DOWN)\n",
        "        arrows.next_to(prior_rects[1], RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeIn, [her, her.glasses])))\n",
        "        self.play(LaggedStartMap(FadeIn, risk_averse_words))\n",
        "        self.play(her.change_mode, \"sad\", Animation(her.glasses))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrows))\n",
        "        self.play(\n",
        "            *it.chain(\n",
        "                self.get_conditional_change_anims(1, 0.1, post_rects),\n",
        "                [Animation(arrows)]\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(FadeOut(arrows))\n",
        "        self.wait(2)\n",
        "        post_surrounding_rect = SurroundingRectangle(posterior)\n",
        "        self.play(ShowCreation(post_surrounding_rect))\n",
        "        self.play(FadeOut(post_surrounding_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(risk_averse_words),\n",
        "            *self.get_conditional_change_anims(1, 0.3, post_rects),\n",
        "            run_time = 2\n",
        "        )\n",
        "\n",
        "    def tweak_flush_case(self):\n",
        "        her = self.her\n",
        "        post_rects = self.post_rects\n",
        "\n",
        "        self.play(\n",
        "            her.change_mode, \"erm\", Animation(her.glasses)\n",
        "        )\n",
        "        self.play(\n",
        "            *self.get_conditional_change_anims(0, 0.47, post_rects),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*self.get_conditional_change_anims(\n",
        "            0, 0.97, post_rects\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def tweak_prior(self):\n",
        "        her = self.her\n",
        "        post_rects = self.post_rects\n",
        "\n",
        "        self.play(\n",
        "            her.change_mode, \"happy\", Animation(her.glasses)\n",
        "        )\n",
        "        self.play(\n",
        "            *self.get_prior_change_anims(0.3, post_rects),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            *self.get_prior_change_anims(1./22, post_rects),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [her, her.glasses])))\n",
        "\n",
        "    def compute_posterior(self):\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        post_tex = self.posterior_tex\n",
        "        prior_rhs_group = self.get_prior_rhs_group()\n",
        "\n",
        "        fraction = OldTex(\n",
        "            \"{(0.045)\", \"(0.97)\", \"\\\\over\", \n",
        "            \"(0.995)\", \"(0.3)\", \"+\", \"(0.045)\", \"(0.97)}\"\n",
        "        )\n",
        "        products = [\n",
        "            VGroup(*[\n",
        "                fraction.get_parts_by_tex(tex)[i]\n",
        "                for tex in tex_list\n",
        "            ])\n",
        "            for i, tex_list in [\n",
        "                (0, [\"0.045\", \"0.97\"]),\n",
        "                (0, [\"0.995\", \"0.3\"]),\n",
        "                (1, [\"0.045\", \"0.97\"]),\n",
        "            ]\n",
        "        ]\n",
        "        for i in 0, 2:\n",
        "            products[i].set_color(prior_rects[0].get_color())\n",
        "        products[1].set_color(prior_rects[1].get_color())\n",
        "        fraction.scale(0.65)\n",
        "        fraction.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n",
        "        arrow_kwargs = {\n",
        "            \"color\" : WHITE,\n",
        "            \"tip_length\" : 0.15,\n",
        "        }\n",
        "        rhs = OldTex(\"\\\\approx\", \"0.13\")\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(post_tex, RIGHT)\n",
        "        to_rhs_arrow = Arrow(\n",
        "            fraction.get_bottom(), rhs.get_top(),\n",
        "            **arrow_kwargs\n",
        "        )\n",
        "\n",
        "        pre_top_rect_products = VGroup(\n",
        "            prior_rhs_group[0], self.top_conditional_rhs\n",
        "        )\n",
        "        pre_bottom_rect_products = VGroup(\n",
        "            prior_rhs_group[1], self.bottom_conditional_rhs\n",
        "        )\n",
        "\n",
        "        self.play(Indicate(prior_rects[0], scale_factor = 1))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mob.copy(), term,\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for mob, term in zip(\n",
        "                pre_top_rect_products, products[0]\n",
        "            )\n",
        "        ])\n",
        "        self.play(Write(fraction.get_part_by_tex(\"over\")))\n",
        "        for pair in zip(pre_top_rect_products, products[0]):\n",
        "            self.play(*list(map(Indicate, pair)))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(Indicate(prior_rects[1], scale_factor = 1))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mob.copy(), term,\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for mob, term in zip(\n",
        "                pre_bottom_rect_products, products[1]\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        for pair in zip(pre_bottom_rect_products, products[1]):\n",
        "            self.play(*list(map(Indicate, pair)))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            Write(fraction.get_part_by_tex(\"+\")),\n",
        "            ReplacementTransform(products[0].copy(), products[2])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(to_rhs_arrow))\n",
        "        self.play(Write(rhs))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_prior_labels(self, value):\n",
        "        p_str = \"%0.3f\"%value\n",
        "        q_str = \"%0.3f\"%(1-value)\n",
        "        labels = [\n",
        "            OldTex(\n",
        "                \"P(\", s, self.double_heart_template, \")\",\n",
        "                \"= \", num\n",
        "            )\n",
        "            for s, num in ((\"\", p_str), (\"\\\\text{not }\", q_str))\n",
        "        ]\n",
        "        for label in labels:\n",
        "            label.scale(0.7)\n",
        "            self.insert_double_heart(label)\n",
        "\n",
        "        return labels\n",
        "\n",
        "    def get_prior_rhs_group(self):\n",
        "        labels = self.sample_space.horizontal_parts.labels\n",
        "        return VGroup(*[label[-1] for label in labels])\n",
        "\n",
        "    def get_conditional_label(self, value, given_flush = True):\n",
        "        label = OldTex(\n",
        "            \"P(\", self.cash_string, \"|\", \n",
        "            \"\" if given_flush else \"\\\\text{not }\",\n",
        "            self.double_heart_template, \")\",\n",
        "            \"=\", str(value)\n",
        "        )\n",
        "        self.insert_double_heart(label)\n",
        "        label.set_color_by_tex(self.cash_string, GREEN)\n",
        "        label.scale(0.7)\n",
        "        return label\n",
        "\n",
        "    def insert_double_heart(self, tex_mob):\n",
        "        double_heart = SuitSymbol(\"hearts\")\n",
        "        double_heart.add(SuitSymbol(\"hearts\"))\n",
        "        double_heart.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        double_heart.get_tex = lambda : self.double_heart_template\n",
        "        template = tex_mob.get_part_by_tex(self.double_heart_template)\n",
        "        double_heart.replace(template)\n",
        "        tex_mob.submobjects[tex_mob.index_of_part(template)] = double_heart\n",
        "        return tex_mob\n",
        "\n",
        "    def get_prior_change_anims(self, value, post_rects = None):\n",
        "        space = self.sample_space\n",
        "        parts = space.horizontal_parts\n",
        "        anims = self.get_horizontal_division_change_animations(\n",
        "            value, new_label_kwargs = {\n",
        "                \"labels\" : self.get_prior_labels(value)\n",
        "            }\n",
        "        )\n",
        "        if post_rects is not None:\n",
        "            anims += self.get_posterior_rectangle_change_anims(post_rects)\n",
        "        return anims\n",
        "\n",
        "    def get_conditional_change_anims(\n",
        "        self, sub_sample_space_index, value,\n",
        "        post_rects = None\n",
        "        ):\n",
        "        given_flush = (sub_sample_space_index == 0)\n",
        "        label = self.get_conditional_label(value, given_flush)\n",
        "        return SampleSpaceScene.get_conditional_change_anims(\n",
        "            self, sub_sample_space_index, value, post_rects,\n",
        "            new_label_kwargs = {\"labels\" : [label]},\n",
        "        )\n",
        "\n",
        "class BayesRuleInMemory(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        bubble = ThoughtBubble(height = 4)\n",
        "        bubble.pin_to(randy)\n",
        "        B = \"\\\\text{Belief}\"\n",
        "        D = \"\\\\text{Data}\"\n",
        "        rule = OldTex(\n",
        "            \"P(\", B, \"|\", D, \")\", \"=\", \n",
        "            \"P(\", \"B\", \")\", \n",
        "            \"{P(\", D, \"|\", B, \")\", \"\\\\over\", \"P(\", D, \")}\"\n",
        "        )\n",
        "        rule.set_color_by_tex(B, RED)\n",
        "        rule.set_color_by_tex(D, GREEN)\n",
        "        rule.next_to(randy, RIGHT, LARGE_BUFF, UP)\n",
        "        rule.generate_target()\n",
        "        bubble.add_content(rule.target)\n",
        "        screen_rect = ScreenRectangle()\n",
        "        screen_rect.next_to(randy, UP+RIGHT)\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, rule),\n",
        "            randy.change, \"erm\", rule\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            MoveToTarget(rule),\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(rule.fade, 0.7, run_time = 2)\n",
        "        self.play(randy.change, \"confused\", rule)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(VGroup(bubble, rule)),\n",
        "            randy.change, \"pondering\", screen_rect,\n",
        "        )\n",
        "        self.play(\n",
        "            randy.look_at, screen_rect.get_right(),\n",
        "            ShowCreation(screen_rect),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "class NextVideoWrapper(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Upcoming chapter: Bayesian networks\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(self.title)\n",
        "        title.scale(0.8)\n",
        "        title.to_edge(UP, buff = SMALL_BUFF)\n",
        "        screen = ScreenRectangle(height = 4)\n",
        "        screen.next_to(title, DOWN)\n",
        "        title.save_state()\n",
        "        title.shift(DOWN)\n",
        "        title.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            title.restore,\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(screen))\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = screen\n",
        "        )\n",
        "        self.play(Animation(screen))\n",
        "        self.wait(5)\n",
        "\n",
        "class BayesianNetworkPreview(Scene):\n",
        "    def construct(self):\n",
        "        self.add_network()\n",
        "        self.show_propogation(self.network.nodes[0])\n",
        "        self.show_propogation(self.network.nodes[-1])\n",
        "\n",
        "    def add_network(self):\n",
        "        radius = MED_SMALL_BUFF\n",
        "        node = Circle(color = WHITE, radius = radius)\n",
        "        node.shift(2*DOWN)\n",
        "        nodes = VGroup(*[\n",
        "            node.copy().shift(x*RIGHT + y*UP)\n",
        "            for x, y in [\n",
        "                (-1, 0),  \n",
        "                (1, 0),\n",
        "                (-2, 2),\n",
        "                (0, 2),\n",
        "                (2, 2),\n",
        "                (-2, 4),\n",
        "                (0, 4),\n",
        "            ]\n",
        "        ])\n",
        "        for node in nodes:\n",
        "            node.children = VGroup()\n",
        "            node.parents = VGroup()\n",
        "            node.outgoing_edges = VGroup()\n",
        "        edge_index_pairs = [\n",
        "            (2, 0),\n",
        "            (3, 0),\n",
        "            (3, 1),\n",
        "            (4, 1),\n",
        "            (5, 2),\n",
        "            (6, 3),\n",
        "        ]\n",
        "        edges = VGroup()\n",
        "        for i1, i2 in edge_index_pairs:\n",
        "            n1, n2 = nodes[i1], nodes[i2]\n",
        "            edge = Arrow(\n",
        "                n1.get_center(), \n",
        "                n2.get_center(),\n",
        "                buff = radius,\n",
        "                color = WHITE,\n",
        "            )\n",
        "            n1.outgoing_edges.add(edge)\n",
        "            edges.add(edge)\n",
        "            n1.children.add(n2)\n",
        "            n2.parents.add(n1)\n",
        "\n",
        "        network = VGroup(nodes, edges)\n",
        "        network.nodes = nodes\n",
        "        network.edges = edges\n",
        "        self.add(network)\n",
        "        self.network = network\n",
        "\n",
        "    def show_propogation(self, node):\n",
        "        self.set_network_fills()\n",
        "        all_ghosts = VGroup()\n",
        "        curr_nodes = [node]\n",
        "        covered_nodes = set()\n",
        "        self.play(GrowFromCenter(node.fill))\n",
        "        self.remove(node.fill)\n",
        "        while curr_nodes:\n",
        "            next_nodes = set([])\n",
        "            anims = []\n",
        "            for node in curr_nodes:\n",
        "                node.ghost = node.fill.copy().fade()\n",
        "                self.add(node.ghost)\n",
        "                all_ghosts.add(node.ghost)\n",
        "                connected_nodes = [n for n in it.chain(node.children, node.parents) if n not in covered_nodes]\n",
        "                for next_node in connected_nodes:\n",
        "                    if next_node in covered_nodes:\n",
        "                        continue\n",
        "                    next_nodes.add(next_node)\n",
        "                    anims.append(Transform(\n",
        "                        node.fill.copy(), next_node.fill,\n",
        "                        remover = True\n",
        "                    ))\n",
        "                if len(connected_nodes) == 0:\n",
        "                    anims.append(FadeOut(node.fill))\n",
        "            if anims:\n",
        "                self.play(*anims)\n",
        "            covered_nodes.update(curr_nodes)\n",
        "            curr_nodes = list(next_nodes)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(all_ghosts))\n",
        "\n",
        "\n",
        "    def set_network_fills(self):\n",
        "        for node in self.network.nodes:\n",
        "            node.fill = self.get_fill(node)\n",
        "\n",
        "\n",
        "    def get_fill(self, node):\n",
        "        fill = node.copy()\n",
        "        fill.set_fill(YELLOW, 1)\n",
        "        fill.set_stroke(width = 0)\n",
        "        return fill\n",
        "\n",
        "class GeneralizeBayesRule(SampleSpaceScene):\n",
        "    def construct(self):\n",
        "        self.add_sample_space()\n",
        "        self.add_title()\n",
        "        self.add_posterior_rectangles()\n",
        "        self.add_bayes_rule()\n",
        "        self.talk_through_terms()\n",
        "        self.name_likelihood()\n",
        "        self.dont_memorize()\n",
        "        self.show_space_restriction()\n",
        "\n",
        "    def add_sample_space(self):\n",
        "        sample_space = SampleSpace(\n",
        "            full_space_config = {\n",
        "                \"height\" : 3,\n",
        "                \"width\" : 3,\n",
        "                \"fill_opacity\" : 0\n",
        "            }\n",
        "        )\n",
        "        sample_space.divide_horizontally(0.4)\n",
        "        sample_space.horizontal_parts.set_fill(opacity = 0)\n",
        "        labels = [\n",
        "            OldTex(\"P(\", \"B\", \")\"),\n",
        "            OldTex(\"P(\\\\text{not }\", \"B\", \")\"),\n",
        "        ]\n",
        "        for label in labels:\n",
        "            label.scale(0.7)\n",
        "            self.color_label(label)\n",
        "        sample_space.get_side_braces_and_labels(labels)\n",
        "        sample_space.add_braces_and_labels()\n",
        "\n",
        "        parts = sample_space.horizontal_parts\n",
        "        values = [0.8, 0.4]\n",
        "        given_strs = [\"\", \"\\\\text{not }\"]\n",
        "        color_pairs = [(GREEN, BLUE), (GREEN_E, BLUE_E)]\n",
        "        vects = [UP, DOWN]\n",
        "        for tup in zip(parts, values, given_strs, color_pairs, vects):\n",
        "            part, value, given_str, colors, vect = tup\n",
        "            part.divide_vertically(value, colors = colors)\n",
        "            part.vertical_parts.set_fill(opacity = 0.8)\n",
        "            label = OldTex(\n",
        "                \"P(\", \"I\", \"|\", given_str, \"B\", \")\"\n",
        "            )\n",
        "            label.scale(0.7)\n",
        "            self.color_label(label)\n",
        "            part.get_subdivision_braces_and_labels(\n",
        "                part.vertical_parts, [label], vect\n",
        "            )\n",
        "            sample_space.add(\n",
        "                part.vertical_parts.braces,\n",
        "                part.vertical_parts.labels,\n",
        "            )\n",
        "        sample_space.to_edge(LEFT)\n",
        "\n",
        "        self.add(sample_space)\n",
        "        self.sample_space = sample_space\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            \"Updating\", \"Beliefs\", \"from new\", \"Information\"\n",
        "        )\n",
        "        self.color_label(title)\n",
        "        title.scale(0.8)\n",
        "        title.to_corner(UP+LEFT)\n",
        "\n",
        "        self.add(title)\n",
        "\n",
        "    def add_posterior_rectangles(self):\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "\n",
        "        label = OldTex(\"P(\", \"B\", \"|\", \"I\", \")\")\n",
        "        label.scale(0.7)\n",
        "        self.color_label(label)\n",
        "        braces, labels = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [label]\n",
        "        )\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            prior_rects.copy(), post_rects,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.play(\n",
        "            GrowFromCenter(braces),\n",
        "            Write(label)\n",
        "        )\n",
        "\n",
        "        self.post_rects = post_rects\n",
        "        self.posterior_tex = label\n",
        "\n",
        "    def add_bayes_rule(self):\n",
        "        rule = OldTex(\n",
        "             \"=\", \"{P(\", \"B\", \")\", \"P(\", \"I\", \"|\", \"B\", \")\",\n",
        "            \"\\\\over\", \"P(\", \"I\", \")}\",\n",
        "        )\n",
        "        self.color_label(rule)\n",
        "        rule.scale(0.7)\n",
        "        rule.next_to(self.posterior_tex, RIGHT)\n",
        "\n",
        "        bayes_rule_words = OldTexText(\"Bayes' rule\")\n",
        "        bayes_rule_words.next_to(VGroup(*rule[1:]), UP, LARGE_BUFF)\n",
        "        bayes_rule_words.shift_onto_screen()\n",
        "\n",
        "        self.play(FadeIn(rule))\n",
        "        self.play(Write(bayes_rule_words))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.bayes_rule_words = bayes_rule_words\n",
        "        self.bayes_rule = rule\n",
        "\n",
        "    def talk_through_terms(self):\n",
        "        prior = self.sample_space.horizontal_parts.labels[0]\n",
        "        posterior = self.posterior_tex\n",
        "        prior_target = VGroup(*self.bayes_rule[1:4])\n",
        "        likelihood = VGroup(*self.bayes_rule[4:9])\n",
        "        P_I = VGroup(*self.bayes_rule[-3:])\n",
        "\n",
        "        prior_word = OldTexText(\"Prior\")\n",
        "        posterior_word = OldTexText(\"Posterior\")\n",
        "        words = [prior_word, posterior_word]\n",
        "        for word in words:\n",
        "            word.set_color(YELLOW)\n",
        "            word.scale(0.7)\n",
        "        prior_rect = SurroundingRectangle(prior)\n",
        "        posterior_rect = SurroundingRectangle(posterior)\n",
        "        for rect in prior_rect, posterior_rect:\n",
        "            rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        prior_word.next_to(prior, UP, LARGE_BUFF)\n",
        "        posterior_word.next_to(posterior, DOWN, LARGE_BUFF)\n",
        "        for word in words:\n",
        "            word.shift_onto_screen()\n",
        "        prior_arrow = Arrow(\n",
        "            prior_word.get_bottom(), prior.get_top(),\n",
        "            tip_length = 0.15\n",
        "        )\n",
        "        posterior_arrow = Arrow(\n",
        "            posterior_word.get_top(), posterior.get_bottom(),\n",
        "            tip_length = 0.15\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(prior_word), \n",
        "            ShowCreation(prior_arrow), \n",
        "            ShowCreation(prior_rect),\n",
        "        ) \n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            prior.copy(), prior_target,\n",
        "            run_time = 2,\n",
        "            path_arc = -np.pi/3,\n",
        "            remover = True,\n",
        "        ))\n",
        "        self.wait()\n",
        "        parts = self.sample_space[0].vertical_parts\n",
        "        self.play(\n",
        "            Indicate(likelihood),\n",
        "            Indicate(parts.labels),\n",
        "            Indicate(parts.braces),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Indicate(P_I))\n",
        "        self.play(FocusOn(self.sample_space[0][0]))\n",
        "        for i in range(2):\n",
        "            self.play(Indicate(\n",
        "                self.sample_space[i][0], \n",
        "                scale_factor = 1\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(posterior_word), \n",
        "            ShowCreation(posterior_arrow), \n",
        "            ShowCreation(posterior_rect),\n",
        "        )\n",
        "\n",
        "        self.prior_label = VGroup(prior_word, prior_arrow, prior_rect)\n",
        "        self.posterior_label = VGroup(posterior_word, posterior_arrow, posterior_rect)\n",
        "        self.likelihood = likelihood\n",
        "\n",
        "    def name_likelihood(self):\n",
        "        likelihoods = [\n",
        "            self.sample_space[0].vertical_parts.labels[0],\n",
        "            self.likelihood\n",
        "        ]\n",
        "        rects = [\n",
        "            SurroundingRectangle(mob, buff = SMALL_BUFF)\n",
        "            for mob in likelihoods\n",
        "        ]\n",
        "        name = OldTexText(\"Likelihood\")\n",
        "        name.scale(0.7)\n",
        "        name.next_to(self.posterior_tex, UP, 1.5*LARGE_BUFF)\n",
        "        arrows = [\n",
        "            Arrow(\n",
        "                name, rect.get_edge_center(vect), \n",
        "                tip_length = 0.15\n",
        "            )\n",
        "            for rect, vect in zip(rects, [RIGHT, UP])\n",
        "        ]\n",
        "        VGroup(name, *arrows+rects).set_color(YELLOW)\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.5)\n",
        "        morty.next_to(rects[1], UP, buff = 0)\n",
        "        morty.shift(SMALL_BUFF*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            self.bayes_rule_words.to_edge, UP,\n",
        "            Write(name),\n",
        "            *list(map(ShowCreation, arrows+rects))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(morty.change, \"confused\", name)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.look, DOWN)\n",
        "        self.wait()\n",
        "        self.play(morty.look_at, name)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"shruggie\")\n",
        "\n",
        "        self.play(FadeOut(VGroup(name, *arrows+rects)))\n",
        "        self.play(FadeOut(morty))\n",
        "        self.play(FadeOut(self.posterior_label))\n",
        "        self.play(FadeOut(self.prior_label))\n",
        "\n",
        "    def dont_memorize(self):\n",
        "        rule = VGroup(*self.bayes_rule[1:])\n",
        "        word = OldTexText(\"Memorize\")\n",
        "        word.scale(0.7)\n",
        "        word.next_to(rule, DOWN)\n",
        "        cross = VGroup(\n",
        "            Line(UP+LEFT, DOWN+RIGHT),\n",
        "            Line(UP+RIGHT, DOWN+LEFT),\n",
        "        )\n",
        "        cross.set_stroke(RED, 6)\n",
        "        cross.replace(word, stretch = True)\n",
        "\n",
        "        self.play(Write(word))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(cross, word)))\n",
        "        self.play(FadeOut(self.bayes_rule))\n",
        "        self.play(\n",
        "            FadeOut(self.post_rects),\n",
        "            FadeOut(self.post_rects.braces),\n",
        "            FadeOut(self.post_rects.labels),\n",
        "        )\n",
        "\n",
        "    def show_space_restriction(self):\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        non_I_rects = VGroup(*[\n",
        "            self.sample_space[i][1]\n",
        "            for i in range(2)\n",
        "        ])\n",
        "        post_rects = self.post_rects\n",
        "\n",
        "        self.play(non_I_rects.fade, 0.8)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            prior_rects,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back,\n",
        "            lag_ratio = 0.7\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            prior_rects.copy(), post_rects,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            post_rects.braces, post_rects.labels\n",
        "        ])))\n",
        "        self.wait()\n",
        "        self.play(*self.get_conditional_change_anims(1, 0.2, post_rects))\n",
        "        self.play(*self.get_conditional_change_anims(0, 0.6, post_rects))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            self.get_division_change_animations(\n",
        "                self.sample_space, \n",
        "                self.sample_space.horizontal_parts,\n",
        "                0.1\n",
        "            ),\n",
        "            self.get_posterior_rectangle_change_anims(post_rects)\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def color_label(self, label):\n",
        "        label.set_color_by_tex(\"B\", RED)\n",
        "        label.set_color_by_tex(\"I\", GREEN)\n",
        "\n",
        "class MoreExamples(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"More examples!\", target_mode = \"hooray\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class MusicExample(SampleSpaceScene, PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.introduce_musician()\n",
        "        self.add_prior()\n",
        "        self.record_track()\n",
        "        self.add_bottom_conditionl()\n",
        "        self.friend_gives_compliment()\n",
        "        self.friends_dont_like()\n",
        "        self.false_compliment()\n",
        "        self.add_top_conditionl()\n",
        "        self.get_positive_review()\n",
        "        self.restrict_space()\n",
        "        self.show_posterior_rectangles()\n",
        "        self.show_prior_rectangle_areas()\n",
        "        self.show_posterior_probability()\n",
        "        self.intuition_of_positive_feedback()\n",
        "        self.make_friends_honest()\n",
        "        self.fade_out_post_rect()\n",
        "        self.get_negative_feedback()\n",
        "        self.compare_prior_to_post_given_negative()\n",
        "        self.intuition_of_negative_feedback()\n",
        "\n",
        "    def introduce_musician(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.change_mode(\"soulful_musician\")\n",
        "        randy.arms = randy.get_arm_copies()\n",
        "        guitar = randy.guitar = Guitar()\n",
        "        guitar.move_to(randy)\n",
        "        guitar.shift(0.31*RIGHT + 0.6*UP)\n",
        "\n",
        "        randy.change_mode(\"plain\")\n",
        "        self.play(\n",
        "            randy.change_mode, \"soulful_musician\",\n",
        "            path_arc = np.pi/6,\n",
        "        )\n",
        "        self.play(\n",
        "            Animation(randy),\n",
        "            DrawBorderThenFill(guitar),\n",
        "            Animation(randy.arms)\n",
        "        )\n",
        "        randy.add(guitar, randy.arms)\n",
        "        self.wait()\n",
        "        self.play_notes(guitar)\n",
        "        self.change_pi_creature_with_guitar(\"concerned_musician\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            randy.scale, 0.7,\n",
        "            randy.to_corner, UP+LEFT,\n",
        "        )\n",
        "        self.play_notes(guitar)\n",
        "\n",
        "    def add_prior(self):\n",
        "        sample_space = SampleSpace()\n",
        "        sample_space.shift(DOWN)\n",
        "        sample_space.divide_horizontally(0.8, colors = [MAROON_D, BLUE_E])\n",
        "        labels = VGroup(\n",
        "            OldTex(\"P(S) = \", \"0.8\"),\n",
        "            OldTex(\"P(\\\\text{not } S) = \", \"0.2\"),\n",
        "        )\n",
        "        labels.scale(0.7)\n",
        "        braces, labels = sample_space.get_side_braces_and_labels(labels)\n",
        "        VGroup(sample_space, braces, labels).to_edge(LEFT)\n",
        "        words = list(map(TexText, [\n",
        "            \"Blunt honesty\", \"Some confidence\"\n",
        "        ]))\n",
        "        for word, part in zip(words, sample_space.horizontal_parts):\n",
        "            word.scale(0.6)\n",
        "            word.move_to(part)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, sample_space, run_time = 1))\n",
        "        self.play(*list(map(GrowFromCenter, braces)))\n",
        "        for label in labels:\n",
        "            self.play(Write(label, run_time = 2))\n",
        "            self.wait()\n",
        "        for word, mode in zip(words, [\"maybe\", \"soulful_musician\"]):\n",
        "            self.play(LaggedStartMap(FadeIn, word, run_time = 1))\n",
        "            self.change_pi_creature_with_guitar(mode)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, words)))\n",
        "\n",
        "        self.sample_space = sample_space\n",
        "\n",
        "    def record_track(self):\n",
        "        randy = self.pi_creature\n",
        "        friends = VGroup(*[\n",
        "            PiCreature(mode = \"happy\", color = color).flip()\n",
        "            for color in (BLUE_B, GREY_BROWN, MAROON_E)\n",
        "        ])\n",
        "        friends.scale(0.6)\n",
        "        friends.arrange(RIGHT)\n",
        "        friends.next_to(randy, RIGHT, LARGE_BUFF, DOWN)\n",
        "        friends.to_edge(RIGHT)\n",
        "        for friend in friends:\n",
        "            friend.look_at(randy.eyes)\n",
        "\n",
        "        headphones = VGroup(*list(map(Headphones, friends)))\n",
        "\n",
        "        self.play(FadeIn(friends))\n",
        "        self.pi_creatures.add(*friends)\n",
        "        self.play(\n",
        "            FadeIn(headphones), \n",
        "            Animation(friends)\n",
        "        )\n",
        "        self.play_notes(randy.guitar)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, friends,\n",
        "            lambda pi : (pi.change, \"hooray\"),\n",
        "            run_time = 2,\n",
        "        ))\n",
        "\n",
        "        self.friends = friends\n",
        "        self.headphones = headphones\n",
        "\n",
        "    def add_bottom_conditionl(self):\n",
        "        p = 0.99\n",
        "        bottom_part = self.sample_space[1]\n",
        "        bottom_part.divide_vertically(p, colors = [GREEN_E, YELLOW])\n",
        "        label = self.get_conditional_label(p, False)\n",
        "        braces, labels = bottom_part.get_bottom_braces_and_labels([label])\n",
        "        brace = braces[0]\n",
        "\n",
        "        self.play(FadeIn(bottom_part.vertical_parts))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "\n",
        "    def friend_gives_compliment(self):\n",
        "        friends = self.friends\n",
        "        bubble = SpeechBubble(\n",
        "            height = 1.25, width = 3, direction = RIGHT,\n",
        "            fill_opacity = 0,\n",
        "        )\n",
        "        content = OldTexText(\"Phenomenal!\")\n",
        "        content.scale(0.75)\n",
        "        bubble.add_content(content)\n",
        "        VGroup(bubble, content).next_to(friends, LEFT, SMALL_BUFF)\n",
        "        VGroup(bubble, content).to_edge(UP, SMALL_BUFF)\n",
        "    \n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, friends,\n",
        "            lambda pi : (pi.change_mode, \"conniving\")\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content, run_time = 1),\n",
        "            ApplyMethod(friends[0].change_mode, \"hooray\"),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, VGroup(*friends[1:]),\n",
        "                lambda pi : (pi.change_mode, \"happy\")\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [bubble, content])))\n",
        "\n",
        "    def friends_dont_like(self):\n",
        "        friends = self.friends\n",
        "        pi1, pi2, pi3 = friends\n",
        "        for friend in friends:\n",
        "            friend.generate_target()\n",
        "        pi1.target.change(\"guilty\", pi2.eyes)\n",
        "        pi2.target.change(\"hesitant\", pi1.eyes)\n",
        "        pi3.target.change(\"pondering\", pi2.eyes)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, friends\n",
        "        ))\n",
        "        self.change_pi_creature_with_guitar(\"concerned_musician\")\n",
        "        self.wait()\n",
        "\n",
        "    def false_compliment(self):\n",
        "        friend = self.friends[0]\n",
        "        bubble = SpeechBubble(\n",
        "            height = 1.25, width = 4.5, direction = RIGHT,\n",
        "            fill_opacity = 0,\n",
        "        )\n",
        "        content = OldTexText(\"The beat was consistent.\")\n",
        "        content.scale(0.75)\n",
        "        bubble.add_content(content)\n",
        "        VGroup(bubble, content).next_to(friend, LEFT, SMALL_BUFF)\n",
        "        VGroup(bubble, content).to_edge(UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            friend.change_mode, \"maybe\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(content)\n",
        "        )\n",
        "        self.change_pi_creature_with_guitar(\"happy\")\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [bubble, content])))\n",
        "\n",
        "        self.bubble = bubble\n",
        "\n",
        "    def add_top_conditionl(self):\n",
        "        p = 0.9\n",
        "        top_part = self.sample_space[0]\n",
        "        top_part.divide_vertically(p, colors = [TEAL_E, RED_E])\n",
        "        label = self.get_conditional_label(p, True)\n",
        "        braces, labels = top_part.get_top_braces_and_labels([label])\n",
        "        brace = braces[0]\n",
        "\n",
        "        self.play(FadeIn(top_part.vertical_parts))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(label, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def get_positive_review(self):\n",
        "        friends = self.friends\n",
        "\n",
        "        self.change_pi_creature_with_guitar(\n",
        "            \"soulful_musician\",\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, friends, \n",
        "                lambda pi : (pi.change, \"happy\"),\n",
        "                run_time = 1,\n",
        "            )\n",
        "        )\n",
        "        self.play_notes(self.pi_creature.guitar)\n",
        "\n",
        "    def restrict_space(self):\n",
        "        positive_space, negative_space = [\n",
        "            VGroup(*[\n",
        "                self.sample_space[i][j]\n",
        "                for i in range(2)\n",
        "            ])\n",
        "            for j in range(2)\n",
        "        ]\n",
        "        negative_space.save_state()\n",
        "\n",
        "        self.play(negative_space.fade, 0.8)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, positive_space,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.7,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.negative_space = negative_space\n",
        "\n",
        "    def show_posterior_rectangles(self):\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "        label = OldTex(\"P(S | \", \"\\\\checkmark\", \")\")\n",
        "        label.scale(0.7)\n",
        "        label.set_color_by_tex(\"\\\\checkmark\", GREEN)\n",
        "        braces, labels = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [label]\n",
        "        )\n",
        "        brace = braces[0]\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            prior_rects.copy(), post_rects,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "\n",
        "        self.post_rects = post_rects\n",
        "        self.post_tex = label\n",
        "\n",
        "    def show_prior_rectangle_areas(self):\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        products = VGroup(\n",
        "            OldTex(\"(\", \"0.8\", \")(\", \"0.9\", \")\"),\n",
        "            OldTex(\"(\", \"0.2\", \")(\", \"0.99\", \")\"),\n",
        "        )\n",
        "        top_product, bottom_product = products\n",
        "        for product, rect in zip(products, prior_rects):\n",
        "            product.scale(0.7)\n",
        "            product.move_to(rect)\n",
        "        side_labels = self.sample_space.horizontal_parts.labels\n",
        "        top_labels = self.sample_space[0].vertical_parts.labels\n",
        "        bottom_labels = self.sample_space[1].vertical_parts.labels\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                side_labels[0][-1].copy(),\n",
        "                top_product[1],\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                top_labels[0][-1].copy(),\n",
        "                top_product[3],\n",
        "            ),\n",
        "            Write(VGroup(*top_product[::2]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                side_labels[1][-1].copy(),\n",
        "                bottom_product[1],\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                bottom_labels[0][-1].copy(),\n",
        "                bottom_product[3],\n",
        "            ),\n",
        "            Write(VGroup(*bottom_product[::2]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.products = products\n",
        "\n",
        "    def show_posterior_probability(self):\n",
        "        post_tex = self.post_tex\n",
        "        rhs = OldTex(\"\\\\approx\", \"0.78\")\n",
        "        rhs.scale(0.7)\n",
        "        rhs.next_to(post_tex, RIGHT)\n",
        "        ratio = OldTex(\n",
        "            \"{(0.8)(0.9)\", \"\\\\over\", \n",
        "            \"(0.8)(0.9)\", \"+\", \"(0.2)(0.99)}\"\n",
        "        )\n",
        "        ratio.scale(0.6)\n",
        "        ratio.next_to(VGroup(post_tex, rhs), DOWN, LARGE_BUFF)\n",
        "        ratio.to_edge(RIGHT)\n",
        "        arrow_kwargs = {\n",
        "            \"tip_length\" : 0.15, \n",
        "            \"color\" : WHITE,\n",
        "            \"buff\" : 2*SMALL_BUFF,\n",
        "        }\n",
        "        to_ratio_arrow = Arrow(\n",
        "            post_tex.get_bottom(), ratio.get_top(), **arrow_kwargs\n",
        "        )\n",
        "        to_rhs_arrow = Arrow(\n",
        "            ratio.get_top(), rhs[1].get_bottom(), **arrow_kwargs\n",
        "        )\n",
        "\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(to_ratio_arrow),\n",
        "            FadeIn(ratio)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for mob in prior_rects, prior_rects[0]:\n",
        "            self.play(\n",
        "                mob.set_color, YELLOW,\n",
        "                Animation(self.products),\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(to_rhs_arrow))\n",
        "        self.play(Write(rhs, run_time = 1))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.post_rhs = rhs\n",
        "        self.ratio_group = VGroup(ratio, to_ratio_arrow, to_rhs_arrow)\n",
        "\n",
        "    def intuition_of_positive_feedback(self):\n",
        "        friends = self.friends\n",
        "        prior_num = self.sample_space.horizontal_parts.labels[0][-1]\n",
        "        prior_num_ghost = prior_num.copy().set_fill(opacity = 0.5)\n",
        "        post_num = self.post_rhs[-1]\n",
        "        prior_rect = SurroundingRectangle(prior_num)\n",
        "        post_rect = SurroundingRectangle(post_num)\n",
        "\n",
        "        self.play(ShowCreation(prior_rect))\n",
        "        self.play(Transform(\n",
        "            prior_num_ghost, post_num,\n",
        "            remover = True,\n",
        "            path_arc = -np.pi/6,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.play(ShowCreation(post_rect))\n",
        "        self.wait(2)\n",
        "        for mode, time in (\"shruggie\", 2), (\"hesitant\", 0):\n",
        "            self.play(LaggedStartMap(\n",
        "                ApplyMethod, friends,\n",
        "                lambda pi : (pi.change, mode),\n",
        "                run_time = 2,\n",
        "            ))\n",
        "            self.wait(time)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            prior_rect, post_rect,\n",
        "            self.ratio_group, self.post_rhs\n",
        "        ])))\n",
        "\n",
        "        self.prior_num_rect = prior_rect\n",
        "\n",
        "    def make_friends_honest(self):\n",
        "        post_rects = self.post_rects\n",
        "\n",
        "        self.play(FadeOut(self.products))\n",
        "        for value in 0.5, 0.1, 0.9:\n",
        "            label = self.get_conditional_label(value)\n",
        "            self.play(*self.get_top_conditional_change_anims(\n",
        "                value, post_rects, \n",
        "                new_label_kwargs = {\"labels\" : [label]},\n",
        "            ), run_time = 2)\n",
        "            self.wait(2)\n",
        "\n",
        "    def fade_out_post_rect(self):\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.post_rects, \n",
        "            self.post_rects.braces, \n",
        "            self.post_rects.labels, \n",
        "        ])))\n",
        "        self.play(self.negative_space.restore)\n",
        "\n",
        "    def get_negative_feedback(self):\n",
        "        friends = self.friends\n",
        "        old_prior_rects = self.get_prior_rectangles()\n",
        "        for part in self.sample_space.horizontal_parts:\n",
        "            part.vertical_parts.submobjects.reverse()\n",
        "        new_prior_rects = self.get_prior_rectangles()\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "        label = OldTex(\n",
        "            \"P(S | \\\\text{not } \", \"\\\\checkmark\", \")\",\n",
        "            \"\\\\approx\", \"0.98\"\n",
        "        )\n",
        "        label.scale(0.7)\n",
        "        label.set_color_by_tex(\"\\\\checkmark\", GREEN)\n",
        "        braces, labels = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [label]\n",
        "        )\n",
        "        brace = braces[0]\n",
        "\n",
        "        self.play(old_prior_rects.fade, 0.8)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, friends,\n",
        "            lambda pi : (pi.change, \"pondering\", post_rects),\n",
        "            run_time = 1\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            new_prior_rects.copy(), post_rects,\n",
        "            run_time = 2            \n",
        "        ))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.wait(2)\n",
        "        self.play(Write(label))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.post_rects = post_rects\n",
        "\n",
        "    def compare_prior_to_post_given_negative(self):\n",
        "        post_num = self.post_rects.labels[0][-1]\n",
        "        post_num_rect = SurroundingRectangle(post_num)\n",
        "\n",
        "        self.play(ShowCreation(self.prior_num_rect))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(post_num_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.post_num_rect = post_num_rect\n",
        "\n",
        "    def intuition_of_negative_feedback(self):\n",
        "        friends = self.friends\n",
        "        randy = self.pi_creature\n",
        "        bubble = self.bubble\n",
        "\n",
        "        modes = [\"sassy\", \"pleading\", \"horrified\"]\n",
        "        for friend, mode in zip(friends, modes):\n",
        "            friend.generate_target()\n",
        "            friend.target.change(mode, randy.eyes)\n",
        "        content = OldTexText(\"Horrible.  Just horrible.\")\n",
        "        content.scale(0.6)\n",
        "        bubble.add_content(content)\n",
        "\n",
        "        self.play(*list(map(MoveToTarget, friends)))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.change_pi_creature_with_guitar(\"sad\")\n",
        "        self.wait()\n",
        "        self.change_pi_creature_with_guitar(\"concerned_musician\")\n",
        "        self.wait(3)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = Randolph()\n",
        "        randy.left_arm_range = [.36, .45]\n",
        "        self.randy = randy\n",
        "        return randy\n",
        "\n",
        "    def get_conditional_label(self, value, given_suck = True):\n",
        "        positive_str = \"\\\\checkmark\"\n",
        "        label = OldTex(\n",
        "            \"P(\", positive_str, \"|\", \n",
        "            \"\" if given_suck else \"\\\\text{not }\",\n",
        "            \"S\", \")\",\n",
        "            \"=\", str(value)\n",
        "        )\n",
        "        label.set_color_by_tex(positive_str, GREEN)\n",
        "        label.scale(0.7)\n",
        "        return label\n",
        "\n",
        "    def change_pi_creature_with_guitar(self, target_mode, *added_anims):\n",
        "        randy = self.pi_creature\n",
        "        randy.remove(randy.arms, randy.guitar)\n",
        "        target = randy.copy()\n",
        "        target.change_mode(target_mode)\n",
        "        target.arms = target.get_arm_copies()\n",
        "        target.guitar = randy.guitar.copy()\n",
        "        for pi in randy, target:\n",
        "            pi.add(pi.guitar, pi.arms)\n",
        "        self.play(Transform(randy, target), *added_anims)\n",
        "\n",
        "    def play_notes(self, guitar):\n",
        "        note = SVGMobject(file_name = \"8th_note\")\n",
        "        note.set_height(0.5)\n",
        "        note.set_stroke(width = 0)\n",
        "        note.set_fill(BLUE, 1)\n",
        "        note.move_to(guitar)\n",
        "        note.shift(MED_SMALL_BUFF*(DOWN+2*LEFT))\n",
        "        notes = VGroup(*[note.copy() for x in range(10)])\n",
        "        sine_wave = FunctionGraph(np.sin, x_min = -5, x_max = 5)\n",
        "        sine_wave.scale(0.75)\n",
        "        sine_wave.rotate(np.pi/6, about_point = ORIGIN)\n",
        "        sine_wave.shift(\n",
        "            notes.get_center() - \\\n",
        "            sine_wave.point_from_proportion(0)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveAlongPath, notes, \n",
        "            lambda n : (n, sine_wave),\n",
        "            path_arc = np.pi/2,\n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.5,\n",
        "            rate_func = lambda t : t,\n",
        "        ))\n",
        "\n",
        "class FinalWordsOnRule(SampleSpaceScene):\n",
        "    def construct(self):\n",
        "        self.add_sample_space()\n",
        "        self.add_uses()\n",
        "        self.tweak_values()\n",
        "\n",
        "    def add_sample_space(self):\n",
        "        sample_space = self.sample_space = SampleSpace()\n",
        "        prior = 0.2\n",
        "        top_conditional = 0.8\n",
        "        bottom_condional = 0.3\n",
        "        sample_space.divide_horizontally(prior)\n",
        "        sample_space[0].divide_vertically(\n",
        "            top_conditional, colors = [GREEN, RED]\n",
        "        )\n",
        "        sample_space[1].divide_vertically(\n",
        "            bottom_condional, colors = [GREEN_E, RED_E]\n",
        "        )\n",
        "        B = \"\\\\text{Belief}\"\n",
        "        D = \"\\\\text{Data}\"\n",
        "        P_B = OldTex(\"P(\", B, \")\")\n",
        "        P_D_given_B = OldTex(\"P(\", D, \"|\", B, \")\")\n",
        "        P_D_given_not_B = OldTex(\n",
        "            \"P(\", D, \"|\", \"\\\\text{not }\", B, \")\"\n",
        "        )\n",
        "        P_B_given_D = OldTex(\"P(\", B, \"|\", D, \")\")\n",
        "        labels = VGroup(P_B, P_D_given_B, P_D_given_not_B, P_B_given_D)\n",
        "        for label in labels:\n",
        "            label.scale(0.7)\n",
        "            label.set_color_by_tex(B, BLUE)\n",
        "            label.set_color_by_tex(D, GREEN)\n",
        "\n",
        "        prior_rects = self.get_prior_rectangles()\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "        for i in range(2):\n",
        "            sample_space[i][1].fade(0.7)\n",
        "\n",
        "        braces = VGroup()\n",
        "        bs, ls = sample_space.get_side_braces_and_labels([P_B])\n",
        "        braces.add(*bs)\n",
        "        bs, ls = sample_space[0].get_top_braces_and_labels([P_D_given_B])\n",
        "        braces.add(*bs)\n",
        "        bs, ls = sample_space[1].get_bottom_braces_and_labels([P_D_given_not_B])\n",
        "        braces.add(*bs)\n",
        "        bs, ls = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [P_B_given_D]\n",
        "        )\n",
        "        braces.add(*bs)\n",
        "\n",
        "        group = VGroup(sample_space, braces, labels, post_rects)\n",
        "        group.to_corner(DOWN + LEFT)\n",
        "        self.add(group)\n",
        "\n",
        "        self.post_rects = post_rects\n",
        "\n",
        "    def add_uses(self):\n",
        "        uses = OldTexText(\n",
        "            \"Machine learning, \", \n",
        "            \"scientific inference, $\\\\dots$\",\n",
        "        )\n",
        "        uses.to_edge(UP)\n",
        "        for use in uses:\n",
        "            self.play(Write(use, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def tweak_values(self):\n",
        "        post_rects = self.post_rects\n",
        "        new_value_lists = [\n",
        "            (0.85, 0.1, 0.11),\n",
        "            (0.3, 0.9, 0.4),\n",
        "            (0.97, 0.3, 1./22),\n",
        "        ]\n",
        "        for new_values in new_value_lists:\n",
        "            for i, value in zip(list(range(2)), new_values):\n",
        "                self.play(*self.get_conditional_change_anims(\n",
        "                    i, value, post_rects\n",
        "                ))\n",
        "                self.wait()\n",
        "            self.play(*it.chain(\n",
        "                self.get_horizontal_division_change_animations(new_values[-1]),\n",
        "                self.get_posterior_rectangle_change_anims(post_rects)\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "class FootnoteWrapper(NextVideoWrapper):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Thoughts on the classic Bayes example\"\n",
        "    }\n",
        "\n",
        "class PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"Mark Zollo\",\n",
        "            \"James Park\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Michael McGuffin\",\n",
        "            \"John Haley\",\n",
        "            \"Mourits de Beer\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Tomohiro Furusawa\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(SampleSpaceScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Bayes' rule\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        prior_label = OldTex(\"P(\", \"H\", \")\")\n",
        "        post_label = OldTex(\"P(\", \"H\", \"|\", \"D\", \")\")\n",
        "        for label in prior_label, post_label:\n",
        "            label.set_color_by_tex(\"H\", YELLOW)\n",
        "            label.set_color_by_tex(\"D\", GREEN)\n",
        "            label.scale(1.5)\n",
        "\n",
        "        sample_space = self.get_sample_space()\n",
        "        sample_space.set_height(4.5)\n",
        "        sample_space.divide_horizontally(0.3)\n",
        "        sample_space[0].divide_vertically(0.8, colors = [GREEN, BLUE])\n",
        "        sample_space[1].divide_vertically(0.3, colors = [GREEN_E, BLUE_E])\n",
        "        sample_space.get_side_braces_and_labels([prior_label])\n",
        "        sample_space.add_braces_and_labels()\n",
        "        post_rects = self.get_posterior_rectangles()\n",
        "        group = self.get_posterior_rectangle_braces_and_labels(\n",
        "            post_rects, [post_label]\n",
        "        )\n",
        "        post_rects.add(group)\n",
        "\n",
        "        VGroup(sample_space, post_rects).next_to(title, DOWN, LARGE_BUFF)\n",
        "        self.add(sample_space, post_rects)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}