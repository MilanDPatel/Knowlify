{
    "topic": "demonstrates the concept of a lozenge, which is a type of geometric shape that",
    "code": [
        "from __future__ import annotations\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def get_lozenge(side_length=1):\n",
        "    verts = [math.sqrt(3) * LEFT, UP, math.sqrt(3) * RIGHT, DOWN]\n",
        "    result = Polygon(*verts)\n",
        "    result.scale(side_length / get_norm(verts[0] - verts[1]))\n",
        "    return result\n",
        "\n",
        "\n",
        "class ShowLozenge(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add Lozenge\n",
        "        lozenge = get_lozenge()\n",
        "        lozenge.scale(4)\n",
        "        lozenge.set_stroke(TEAL)\n",
        "\n",
        "        arc1 = Arc(-30 * DEGREES, 60 * DEGREES, arc_center=lozenge.get_left(), radius=0.75)\n",
        "        arc2 = Arc(-150 * DEGREES, 120 * DEGREES, arc_center=lozenge.get_top(), radius=0.5)\n",
        "\n",
        "        VGroup(lozenge, arc1, arc2).stretch(0.95, 0)  # Remove\n",
        "\n",
        "        # arc1_label = Tex(R\"60^\\circ\")\n",
        "        arc1_label = Tex(R\"70.5^\\circ\")\n",
        "        arc1_label.next_to(arc1, RIGHT, MED_SMALL_BUFF)\n",
        "        # arc2_label = Tex(R\"120^\\circ\")\n",
        "        arc2_label = Tex(R\"109.5^\\circ\")\n",
        "        arc2_label.next_to(arc2, DOWN, MED_SMALL_BUFF)\n",
        "        angle_labels = VGroup(\n",
        "            arc1, arc1_label,\n",
        "            arc2, arc2_label,\n",
        "        )\n",
        "        angle_labels.set_z_index(1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lozenge, time_span=(1, 2.5)),\n",
        "            VShowPassingFlash(lozenge.copy().insert_n_curves(20).set_stroke(width=5), time_width=2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            Write(arc1_label),\n",
        "            ShowCreation(arc1),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(arc2_label),\n",
        "            ShowCreation(arc2),\n",
        "        )\n",
        "        self.add(angle_labels)\n",
        "        self.wait()\n",
        "\n",
        "        # Tile the plane\n",
        "        verts = lozenge.get_anchors()[:4]\n",
        "        v1 = verts[1] - verts[0]\n",
        "        v2 = verts[-1] - verts[0]\n",
        "        row = VGroup(lozenge.copy().shift(x * v1) for x in range(-10, 11))\n",
        "        rows = VGroup(row.copy().shift(y * v2) for y in range(-10, 11))\n",
        "        tiles = VGroup(*rows.family_members_with_points())\n",
        "        tiles.sort(lambda p: get_norm(p))\n",
        "\n",
        "        for mob in row, rows:\n",
        "            mob.set_fill(GREY, 1)\n",
        "            mob.set_stroke(WHITE, 2)\n",
        "            mob.shift(-tiles[0].get_center())\n",
        "\n",
        "        n_center_tiles = 501\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.set_height(40),\n",
        "            lozenge.animate.set_fill(GREY, 1),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(lozenge, tile, path_arc=30 * DEGREES) for tile in row),\n",
        "                lag_ratio=1.0 / len(row),\n",
        "                time_span=(1, 3),\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(row, row2, path_arc=30 * DEGREES) for row2 in rows),\n",
        "                lag_ratio=1.0 / len(rows),\n",
        "                run_time=3,\n",
        "            ),\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(rows, angle_labels)\n",
        "\n",
        "        # Squish it\n",
        "        self.play(FadeOut(angle_labels))\n",
        "        rows.save_state()\n",
        "        self.play(rows.animate.stretch(2, 0), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(Restore(rows), run_time=2)\n",
        "        self.play(Write(angle_labels))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CubesAsHexagonTiling(InteractiveScene):\n",
        "    n = 4\n",
        "    colors = [GREY, GREY, GREY]\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        n = self.n\n",
        "\n",
        "        # Set up axes and camera angle\n",
        "        self.frame.set_field_of_view(1 * DEGREES)\n",
        "        self.frame.reorient(135, 55, 0)\n",
        "        self.axes = ThreeDAxes((-5, 5), (-5, 5), (-5, 5))\n",
        "\n",
        "        # Add base\n",
        "        self.base_cube = self.get_half_cube(\n",
        "            side_length=n,\n",
        "            shared_corner=[-1, -1, -1],\n",
        "            grid=True\n",
        "        )\n",
        "        self.add(self.base_cube)\n",
        "        self.add(Point())\n",
        "\n",
        "        # Block pattern\n",
        "        self.block_pattern = np.zeros((n, n, n))\n",
        "        self.cubes = VGroup()\n",
        "\n",
        "    def pre_populate(self):\n",
        "        for x in range(self.n**3 // 2):\n",
        "            new_cube = self.random_new_cube()\n",
        "            self.add_cube(new_cube)\n",
        "\n",
        "    def get_new_cube(self, x, y):\n",
        "        zero_indices = np.where(self.block_pattern[x, y, :] == 0)\n",
        "        if len(zero_indices) == 0:\n",
        "            print(\"Column full\")\n",
        "            return\n",
        "        min_z = np.min(zero_indices)\n",
        "        min_y = np.min(np.where(self.block_pattern[x, :, min_z] == 0))\n",
        "        min_x = np.min(np.where(self.block_pattern[:, min_y, min_z] == 0))\n",
        "\n",
        "        return self.get_half_cube((min_x, min_y, min_z))\n",
        "\n",
        "    def random_new_cube(self):\n",
        "        empty_spaces = np.transpose(np.where(self.block_pattern[:, :, :] == 0))\n",
        "        x, y, z = random.choice(empty_spaces)\n",
        "        return self.get_new_cube(x, y)\n",
        "\n",
        "    def get_random_cube_from_stack(self):\n",
        "        filled_spaces = np.transpose(np.where(self.block_pattern[:, :, :] == 1))\n",
        "        x, y, z = random.choice(filled_spaces)\n",
        "        max_x = np.max(np.where(self.block_pattern[:, y, z] == 1))\n",
        "        max_y = np.max(np.where(self.block_pattern[max_x, :, z] == 1))\n",
        "        max_z = np.max(np.where(self.block_pattern[max_x, max_y, :] == 1))\n",
        "        for cube in self.cubes:\n",
        "            if all(cube.get_corner([-1, -1, -1]).astype(int) == (max_x, max_y, max_z)):\n",
        "                return cube\n",
        "        return self.cubes[-1]\n",
        "\n",
        "    def add_cube(self, cube):\n",
        "        self.cubes.add(cube)\n",
        "        cube.spacer = Mobject()\n",
        "        self.add(cube, cube.spacer)\n",
        "        self.refresh_block_pattern()\n",
        "\n",
        "    def remove_cube(self, cube):\n",
        "        self.cubes.remove(cube)\n",
        "        self.remove(cube, cube.spacer)\n",
        "        self.refresh_block_pattern()\n",
        "\n",
        "    def refresh_block_pattern(self):\n",
        "        self.block_pattern[:, :, :] = 0\n",
        "        for cube in self.cubes:\n",
        "            coords = cube.get_corner([-1, -1, -1]).astype(int)\n",
        "            self.block_pattern[*coords] = 1\n",
        "\n",
        "    def get_half_cube(self, coords=(0, 0, 0), side_length=1, colors=None, shared_corner=[1, 1, 1], grid=False):\n",
        "        if colors is None:\n",
        "            colors = self.colors\n",
        "        squares = Square(side_length).replicate(3)\n",
        "        if grid:\n",
        "            for square in squares:\n",
        "                grid = Square(side_length=1).get_grid(side_length, side_length, buff=0)\n",
        "                grid.move_to(square)\n",
        "                square.add(grid)\n",
        "        axes = [OUT, DOWN, LEFT]\n",
        "        for square, color, axis in zip(squares, colors, axes):\n",
        "            square.set_fill(color, 1)\n",
        "            square.set_stroke(color, 0)\n",
        "            square.rotate(90.1 * DEGREES, axis)  # Why 0.1 ?\n",
        "            square.move_to(ORIGIN, shared_corner)\n",
        "        squares.move_to(coords, np.array([-1, -1, -1]))\n",
        "        squares.set_stroke(WHITE, 2)\n",
        "\n",
        "        return squares\n",
        "\n",
        "    def animate_in_with_rotation(self, cube, color=TEAL, run_time=2):\n",
        "        cube.save_state()\n",
        "        cube.rotate(-60 * DEGREES, axis=[1, 1, 1])\n",
        "        cube.set_fill(color)\n",
        "        blackness = cube.copy().set_color(BLACK)\n",
        "        spacer = Mobject()\n",
        "        self.play(FadeIn(cube))\n",
        "        self.add(blackness, spacer, cube)\n",
        "        self.play(Rotate(cube, 60 * DEGREES, axis=[1, 1, 1], run_time=run_time))\n",
        "        self.play(Restore(cube))\n",
        "        self.add_cube(cube)\n",
        "        self.remove(blackness, spacer)\n",
        "\n",
        "    def animate_out_with_rotation(self, cube, color=TEAL, run_time=2):\n",
        "        blackness = cube.copy().set_color(BLACK)\n",
        "        spacer = Mobject()\n",
        "        self.play(cube.animate.set_fill(color))\n",
        "        self.add(blackness, spacer, cube)\n",
        "        self.play(Rotate(cube, 60 * DEGREES, axis=[1, 1, 1], run_time=run_time))\n",
        "        self.remove(blackness, spacer)\n",
        "        self.play(FadeOut(cube))\n",
        "        self.remove_cube(cube)\n",
        "\n",
        "\n",
        "class AmbientTilingChanges(CubesAsHexagonTiling):\n",
        "    n = 10\n",
        "    # n = 5\n",
        "\n",
        "    def construct(self):\n",
        "        # Hugely inefficient\n",
        "        self.pre_populate()\n",
        "        for x in range(10):\n",
        "            new_cube = self.random_new_cube()\n",
        "            self.animate_in_with_rotation(new_cube)\n",
        "            old_cube = self.get_random_cube_from_stack()\n",
        "            if old_cube is not new_cube:\n",
        "                self.animate_out_with_rotation(old_cube)\n",
        "\n",
        "\n",
        "class RotationMove(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add hex\n",
        "        lozenge = Polygon(math.sqrt(3) * LEFT, UP, math.sqrt(3) * RIGHT, DOWN)\n",
        "        lozenge.move_to(ORIGIN, DOWN)\n",
        "        hexagon = VGroup(\n",
        "            lozenge,\n",
        "            lozenge.copy().rotate(TAU / 3, about_point=ORIGIN),\n",
        "            lozenge.copy().rotate(2 * TAU / 3, about_point=ORIGIN),\n",
        "        )\n",
        "        hexagon.set_fill(TEAL_E, 1)\n",
        "        hexagon.set_stroke(WHITE, 3)\n",
        "        hexagon.set_height(3)\n",
        "        hexagon.move_to(3 * LEFT)\n",
        "\n",
        "        rot_hex = hexagon.copy()\n",
        "        hexagon.rotate(-60 * DEGREES)\n",
        "        rot_hex.move_to(3 * RIGHT)\n",
        "\n",
        "        arrow1 = Arrow(hexagon, rot_hex, thickness=5, path_arc=60 * DEGREES).shift(DOWN)\n",
        "        arrow2 = Arrow(rot_hex, hexagon, thickness=5, path_arc=60 * DEGREES).shift(UP)\n",
        "\n",
        "        self.add(hexagon, rot_hex, arrow1, arrow2)\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            VShowPassingFlash(arrow1.copy().set_stroke(YELLOW, 3)),\n",
        "            TransformFromCopy(hexagon, rot_hex, path_arc=60 * DEGREES),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AmbientTilingChangesHexagonBound(AmbientTilingChanges):\n",
        "    n = 4\n",
        "\n",
        "\n",
        "class IntroduceHexagonFilling(InteractiveScene):\n",
        "    N = 15\n",
        "    tile_color = GREY_C\n",
        "    highlight_color = TEAL\n",
        "    drag_to_pan = False\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        # Create hexagonal tiling\n",
        "        lozenge = get_lozenge()\n",
        "        lozenge.set_stroke(WHITE, 1)\n",
        "        lozenge.set_fill(self.tile_color, 1)\n",
        "        lozenge.move_to(ORIGIN, DOWN)\n",
        "        lozenges = VGroup(lozenge.copy().rotate(theta, about_point=ORIGIN) for theta in np.arange(0, TAU, TAU / 3))\n",
        "\n",
        "        tiling = VGroup()\n",
        "        for template in lozenges:\n",
        "            v1 = template.get_vertices()[0]\n",
        "            v2 = template.get_vertices()[2]\n",
        "            for x, y in it.product(*2 * [range(self.N)]):\n",
        "                tiling.add(template.copy().shift(x * v1 + y * v2))\n",
        "\n",
        "        self.add(tiling)\n",
        "        self.tiling = tiling\n",
        "\n",
        "        # Add hexagon\n",
        "        hexagon = RegularPolygon(6, radius=self.N, start_angle=90 * DEGREES)\n",
        "        hexagon.set_stroke(YELLOW, 3)\n",
        "        self.add(hexagon)\n",
        "        self.hexagon = hexagon\n",
        "\n",
        "        self.selected_set = VGroup()\n",
        "\n",
        "    def construct(self):\n",
        "        # Just play around\n",
        "        self.wait(10)\n",
        "        pass\n",
        "\n",
        "    def rotate_selection(self):\n",
        "        trip = self.selected_set\n",
        "        trip.target = trip.generate_target()\n",
        "        trip.target.rotate(TAU / 6)\n",
        "        trip.target.set_fill(self.tile_color)\n",
        "        self.add(trip)\n",
        "        self.play(MoveToTarget(trip, path_arc=TAU / 6))\n",
        "        self.selected_set.clear()\n",
        "        self.add(self.tiling)\n",
        "\n",
        "        for tile in self.tiling:\n",
        "            tile.refresh_bounding_box()\n",
        "\n",
        "    def fill_with_current_tiles(self):\n",
        "        # Populate\n",
        "        starter = self.tiling[0].copy()\n",
        "        starter.to_corner(UL)\n",
        "\n",
        "        random_order = VGroup(*self.tiling)\n",
        "        random_order.shuffle()\n",
        "\n",
        "        self.remove(self.tiling)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(starter, tile)\n",
        "                for tile in random_order),\n",
        "                lag_ratio=1.0 / len(self.tiling),\n",
        "                run_time=5\n",
        "            )\n",
        "        )\n",
        "        self.add(self.tiling)\n",
        "\n",
        "    def on_mouse_release(\n",
        "        self,\n",
        "        point: Vect3,\n",
        "        button: int,\n",
        "        mods: int\n",
        "    ) -> None:\n",
        "        super().on_mouse_release(point, button, mods)\n",
        "        if len(self.selected_set) == 3:\n",
        "            return\n",
        "        mouse_center = self.mouse_point.get_center()\n",
        "        dists = [get_norm(tile.get_center() - mouse_center) for tile in self.tiling]\n",
        "        tile = self.tiling[np.argmin(dists)]\n",
        "        tile.set_fill(self.highlight_color)\n",
        "        if tile in self.selected_set:\n",
        "            tile.set_fill(self.tile_color)\n",
        "            self.selected_set.remove(tile)\n",
        "        else:\n",
        "            self.selected_set.add(tile)\n",
        "\n",
        "    def on_key_release(\n",
        "        self,\n",
        "        symbol: int,\n",
        "        modifiers: int\n",
        "    ) -> None:\n",
        "        super().on_key_release(symbol, modifiers)\n",
        "        if chr(symbol) == \"p\":\n",
        "            self.fill_with_current_tiles()\n",
        "\n",
        "        if len(self.selected_set) != 3:\n",
        "            return\n",
        "\n",
        "        if chr(symbol) == \"r\":\n",
        "            self.rotate_selection()\n",
        "\n",
        "\n",
        "class HexagonStack(CubesAsHexagonTiling):\n",
        "    n = 5\n",
        "    colors = [BLUE_B, BLUE_D, BLUE_E]\n",
        "\n",
        "    def construct(self):\n",
        "        # Add hexagonal stack\n",
        "        for x in range(self.n):\n",
        "            for y in range(self.n - x):\n",
        "                for z in range(self.n - x - y):\n",
        "                    self.add_cube(self.get_new_cube(x, y))\n",
        "        self.remove(self.base_cube)\n",
        "        self.cubes.set_fill(BLUE_D)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DrawHexagon(IntroduceHexagonFilling):\n",
        "    def construct(self):\n",
        "        self.remove(self.tiling)\n",
        "\n",
        "        # Test\n",
        "        tiles = self.tiling\n",
        "        tiles.add(*tiles.copy().rotate(60 * DEGREES))\n",
        "        tiles.set_fill(opacity=0)\n",
        "        tiles.set_stroke(WHITE, 0.5, 0.5)\n",
        "        frame = self.frame\n",
        "        hexagon = self.hexagon\n",
        "        brace = Brace(Line(ORIGIN, 4 * UP), RIGHT)\n",
        "        brace.next_to(hexagon, RIGHT, SMALL_BUFF)\n",
        "        brace_label = brace.get_text(\"4\")\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(hexagon),\n",
        "            VShowPassingFlash(hexagon.copy().set_stroke(width=5).insert_n_curves(20), time_width=2),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_label),\n",
        "            FadeIn(tiles),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowAsThreeD(CubesAsHexagonTiling):\n",
        "    colors = [BLUE_B, BLUE_D, BLUE_E]\n",
        "\n",
        "    def construct(self):\n",
        "        # self.pre_populate()\n",
        "\n",
        "        # Color\n",
        "        grey_cubes = self.cubes.copy()\n",
        "        grey_cubes.set_fill(GREY)\n",
        "        full_grey = Group()\n",
        "        for cube in grey_cubes:\n",
        "            full_grey.add(cube, Point())\n",
        "        self.add(full_grey)\n",
        "        self.base_cube.save_state()\n",
        "        self.base_cube.set_fill(GREY)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(self.base_cube),\n",
        "            FadeOut(full_grey),\n",
        "        )\n",
        "\n",
        "        # Change perspective\n",
        "        self.pre_populate()\n",
        "        self.pre_populate()\n",
        "        self.play(\n",
        "            # self.frame.animate.reorient(118, 79, 0, (-1.01, 0.75, 1.54), 8.00)\n",
        "            self.frame.animate.reorient(118, 79, 0, (-1.01, 0.75, 1.54), 12.00).set_field_of_view(40 * DEGREES),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            # self.frame.animate.reorient(163, 83, 0, (1.82, -0.33, 1.89), 8.00),\n",
        "            self.frame.animate.reorient(163, 83, 0, (1.82, -0.33, 1.89), 12.00),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(self.frame.animate.reorient(135, 55, 0, ORIGIN, 8).set_field_of_view(1 * DEGREES), run_time=3)\n",
        "\n",
        "        # Rotation is adding\n",
        "        new_cube = self.random_new_cube()\n",
        "        self.animate_in_with_rotation(new_cube)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            new_cube.animate.shift(5 * RIGHT + 3 * OUT),\n",
        "            run_time=6,\n",
        "            rate_func=there_and_back_with_pause\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add or remove a few\n",
        "        for x in range(2):\n",
        "            new_cube = self.random_new_cube()\n",
        "            self.animate_in_with_rotation(new_cube, run_time=1)\n",
        "            old_cube = self.get_random_cube_from_stack()\n",
        "            if old_cube is not new_cube:\n",
        "                self.animate_out_with_rotation(old_cube, run_time=1)\n",
        "\n",
        "        # Remove all\n",
        "        while len(self.cubes) > 0:\n",
        "            cube = self.get_random_cube_from_stack()\n",
        "            self.play(FadeOut(cube, 0.25 * OUT, run_time=0.25))\n",
        "            self.remove_cube(cube)\n",
        "\n",
        "        self.wait()\n",
        "        for x in range(self.n**3):\n",
        "            cube = self.random_new_cube()\n",
        "            self.play(FadeIn(cube, shift=0.25 * IN, run_time=0.25))\n",
        "            self.add_cube(cube)\n",
        "\n",
        "\n",
        "class Project3DCube(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set axes\n",
        "        frame = self.frame\n",
        "        light_source = self.camera.light_source\n",
        "\n",
        "        frame.reorient(28, 68, 0, (0.99, 0.63, 0.66), 2.89)\n",
        "        light_source.move_to([3, 5, 7])\n",
        "\n",
        "        axes = ThreeDAxes(\n",
        "            (-3, 3), (-3, 3), (-3, 3),\n",
        "            axis_config=dict(tick_size=0.05)\n",
        "        )\n",
        "        axes.set_stroke(GREY_A, 1)\n",
        "        plane = NumberPlane((-3, 3), (-3, 3))\n",
        "        plane.axes.set_stroke(GREY_A, 1)\n",
        "        plane.background_lines.set_stroke(BLUE_E, 0.5)\n",
        "        plane.faded_lines.set_stroke(BLUE_E, 0.5, 0.25)\n",
        "\n",
        "        self.add(plane, axes)\n",
        "\n",
        "        # Add cube\n",
        "        vertices = np.array(list(it.product(*3 * [[0, 1]])))\n",
        "        vert_dots = DotCloud(vertices)\n",
        "        vert_dots.make_3d()\n",
        "        vert_dots.set_radius(0.025)\n",
        "        vert_dots.set_color(TEAL)\n",
        "\n",
        "        cube_shell = VGroup(\n",
        "            Line(vertices[i], vertices[j])\n",
        "            for i, p1 in enumerate(vertices)\n",
        "            for j, p2 in enumerate(vertices[i + 1:], start=i + 1)\n",
        "            if get_norm(p2 - p1) == 1\n",
        "        )\n",
        "        cube_shell.set_stroke(YELLOW, 1)\n",
        "        cube_shell.set_anti_alias_width(1)\n",
        "        cube_shell.set_width(1)\n",
        "        cube_shell.move_to(ORIGIN, [-1, -1, -1])\n",
        "\n",
        "        self.play(Write(cube_shell, lag_ratio=0.1, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the coordinates\n",
        "        labels = VGroup()\n",
        "        for vert in vertices:\n",
        "            coords = vert.astype(int)\n",
        "            label = Tex(str(tuple(coords)), font_size=12)\n",
        "            label.next_to(vert, DR, buff=0.05)\n",
        "            label.rotate(45 * DEGREES, RIGHT, about_point=vert)\n",
        "            label.set_backstroke(BLACK, 2)\n",
        "            labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, labels),\n",
        "            FadeIn(vert_dots),\n",
        "            frame.animate.reorient(10, 61, 0, (0.9, 0.51, 0.48), 2.44),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(note=\"Talk through the coordinates\")\n",
        "\n",
        "        # Show base and top square\n",
        "        edges = VGroup(*cube_shell)\n",
        "        edges.sort(lambda p: p[2])\n",
        "\n",
        "        self.play(\n",
        "            edges[4:].animate.set_stroke(width=0.5, opacity=0.25),\n",
        "            labels[1::2].animate.set_opacity(0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            edges[8:].animate.set_stroke(width=2, opacity=1),\n",
        "            labels[1::2].animate.set_opacity(1),\n",
        "            edges[:4].animate.set_stroke(width=0.5, opacity=0.25),\n",
        "            labels[0::2].animate.set_opacity(0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            edges.animate.set_stroke(width=1, opacity=1),\n",
        "            labels.animate.set_opacity(1)\n",
        "        )\n",
        "\n",
        "        self.play(FadeOut(labels))\n",
        "\n",
        "        # Orient to look down the corner\n",
        "        self.play(frame.animate.reorient(135.795, 55.795, 0, (-0.02, -0.08, 0.05), 3.61), run_time=4)\n",
        "        self.wait(2, note=\"Take a moment to look down the corner\")\n",
        "        self.play(frame.animate.reorient(50, 68, 0, (-0.46, 0.29, 0.23), 3.45), run_time=4)\n",
        "\n",
        "        # Show the flat projection\n",
        "        diag_vect = Vector([1, 1, 1], thickness=2)\n",
        "        diag_vect.set_perpendicular_to_camera(frame)\n",
        "        diag_label = labels[-1].copy()\n",
        "\n",
        "        proj_mat = self.construct_proj_matrix()\n",
        "        perp_plane = Square3D().set_width(20)\n",
        "        perp_plane.set_color(GREY_E, 0.5)\n",
        "        perp_plane.apply_matrix(proj_mat)\n",
        "\n",
        "        proj_cube_shell = cube_shell.copy().apply_matrix(proj_mat)\n",
        "        proj_vert_dots = vert_dots.copy().apply_matrix(proj_mat)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(diag_vect),\n",
        "            FadeIn(diag_label, shift=np.ones(3)),\n",
        "            cube_shell.animate.set_stroke(opacity=0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(cube_shell, proj_cube_shell),\n",
        "            TransformFromCopy(vert_dots, proj_vert_dots),\n",
        "        )\n",
        "\n",
        "        self.wait(10, note=\"Talk through projection\")\n",
        "        frame.save_state()\n",
        "        self.play(\n",
        "            frame.animate.reorient(134.75, 54.47, 0, (-0.46, 0.29, 0.23), 3.45).set_field_of_view(1 * DEGREES),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(frame, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Project more cubes down\n",
        "        cube_grid = VGroup(\n",
        "            cube_shell.copy().shift(vect)\n",
        "            for vect in it.product(*3 * [[0, 1, 2]])\n",
        "        )\n",
        "        cube_grid.remove(cube_grid[0])\n",
        "        proj_cube_grid = cube_grid.copy().apply_matrix(proj_mat)\n",
        "        proj_cube_grid.set_stroke(YELLOW, 2, 0.5)\n",
        "\n",
        "        ghost_cube = cube_shell.copy().set_opacity(0)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(ghost_cube, new_cube)\n",
        "                for new_cube in cube_grid),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            frame.animate.reorient(40, 72, 0, (1.25, 1.69, 0.99), 5.10),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(cube_grid, proj_cube_grid),\n",
        "            frame.animate.reorient(60, 68, 0, (0.81, 1.09, 0.94), 5.36),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(note=\"Any commentary?\")\n",
        "        self.play(\n",
        "            FadeOut(cube_grid),\n",
        "            FadeOut(proj_cube_grid),\n",
        "            FadeOut(diag_label),\n",
        "            FadeOut(diag_vect),\n",
        "            FadeOut(vert_dots),\n",
        "            FadeOut(proj_vert_dots),\n",
        "            frame.animate.reorient(42, 62, 0, (0.68, 0.48, 0.41), 2.34),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show cube faces\n",
        "        cube = Cube()\n",
        "        cube.set_color(BLUE_E, 1)\n",
        "        cube.set_shading(0.75, 0.25, 0.5)\n",
        "        cube.replace(cube_shell)\n",
        "        cube.sort(lambda p: np.dot(p, np.ones(3)))\n",
        "        inner_faces = cube[:3]\n",
        "        outer_faces = cube[3:]\n",
        "\n",
        "        for mob in [cube_shell, proj_cube_shell, plane]:  # No axes?\n",
        "            mob.apply_depth_test()\n",
        "        self.add(axes, cube, cube_shell, plane, proj_cube_shell)\n",
        "        self.play(\n",
        "            FadeIn(cube),\n",
        "            proj_cube_shell.animate.set_stroke(width=1, opacity=0.2),\n",
        "        )\n",
        "        self.wait(10, note=\"Note the outer faces\")\n",
        "        self.add(axes, inner_faces, cube_shell, plane, proj_cube_shell)\n",
        "        self.play(\n",
        "            FadeOut(outer_faces),\n",
        "            inner_faces.animate.set_submobject_colors_by_gradient(RED, GREEN, BLUE),\n",
        "        )\n",
        "        self.wait(10, note=\"Gesture at inner faces\")\n",
        "        inner_faces.save_state()\n",
        "        self.play(inner_faces.animate.apply_matrix(proj_mat), run_time=2)\n",
        "        self.play(inner_faces.animate.space_out_submobjects(1.2), rate_func=there_and_back, run_time=2)\n",
        "        self.wait(10)\n",
        "\n",
        "        # Shuffle faces around\n",
        "        inner_proj_state = inner_faces.copy()\n",
        "        self.wait()\n",
        "        self.play(Restore(inner_faces), run_time=2)\n",
        "        inner_faces.target = inner_faces.generate_target()\n",
        "        for face, vect in zip(inner_faces.target, [UP, RIGHT, OUT]):\n",
        "            face.shift(vect)\n",
        "        outer_state = inner_faces.target.copy()\n",
        "        self.play(MoveToTarget(inner_faces, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(inner_faces.animate.apply_matrix(proj_mat), run_time=2)\n",
        "        self.play(inner_faces.animate.space_out_submobjects(1.2), rate_func=there_and_back, run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        for u in [-1, 1]:\n",
        "            self.play(Rotate(inner_faces, u * PI / 3, axis=np.ones(3), run_time=2))\n",
        "            self.wait()\n",
        "\n",
        "        for group in inner_faces, inner_proj_state:\n",
        "            for i, mob in enumerate(group):\n",
        "                mob.shift(i * 0.0001 * IN)\n",
        "        self.play(Transform(inner_faces, inner_proj_state, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(Restore(inner_faces), run_time=2)\n",
        "\n",
        "        # Show coordinates for inner faces\n",
        "        bases = np.identity(3, dtype=int)\n",
        "        vects = VGroup(Vector(basis, thickness=2) for basis in bases)\n",
        "        coord_labels = VGroup(\n",
        "            Tex(str(tuple(basis)), font_size=16).next_to(basis, UR, buff=0.05).rotate(45 * DEGREES, RIGHT, about_point=basis)\n",
        "            for basis in bases\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            axes.animate.set_stroke(width=0.5),\n",
        "            plane.axes.animate.set_stroke(width=0.5),\n",
        "            FadeOut(inner_faces),\n",
        "            LaggedStartMap(GrowArrow, vects),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, coord_labels),\n",
        "            frame.animate.reorient(9, 63, 0, (1.03, 0.61, 0.56), 2.72),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize pairs\n",
        "        vects_state = vects.copy()\n",
        "        labels_state = coord_labels.copy()\n",
        "        last_face = VectorizedPoint()\n",
        "        ordered_faces = Group(inner_faces[i] for i in [1, 0, 2])\n",
        "        ordered_faces.set_opacity(0.8)\n",
        "        ordered_faces.deactivate_depth_test()\n",
        "\n",
        "        for i in range(3):\n",
        "            vects_target = vects_state.copy()\n",
        "            labels_target = labels_state.copy()\n",
        "            vects_target[i].fade(0.8)\n",
        "            labels_target[i].fade(0.8)\n",
        "            self.add(ordered_faces[i], vects, coord_labels)\n",
        "            self.play(\n",
        "                Transform(vects, vects_target),\n",
        "                Transform(coord_labels, labels_target),\n",
        "                FadeIn(ordered_faces[i]),\n",
        "                FadeOut(last_face),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            last_face = ordered_faces[i]\n",
        "\n",
        "        # Project all the vectors\n",
        "        proj_vects = VGroup(\n",
        "            Vector(np.dot(basis, proj_mat.T), thickness=3)\n",
        "            for basis in np.identity(3)\n",
        "        )\n",
        "        proj_coords = VGroup(\n",
        "            Tex(f\"P{str(tuple(basis))}\", font_size=16)\n",
        "            for basis in np.identity(3, dtype=int)\n",
        "        )\n",
        "        for label, vect in zip(proj_coords, proj_vects):\n",
        "            label.move_to(vect.get_end() + 0.25 * vect.get_vector())\n",
        "            label.rotate(45 * DEGREES, RIGHT)\n",
        "            label.rotate(45 * DEGREES, OUT)\n",
        "            vect.set_perpendicular_to_camera(self.frame)\n",
        "        proj_coords[1].shift(0.25 * UP)\n",
        "        faces = Group(ordered_faces[2], ordered_faces[0], ordered_faces[1])\n",
        "\n",
        "        self.add(faces, vects, coord_labels)\n",
        "        self.play(\n",
        "            Transform(vects, vects_state),\n",
        "            Transform(coord_labels, labels_state),\n",
        "            FadeIn(faces),\n",
        "            frame.animate.reorient(44, 55, 0, (1.03, 0.61, 0.56), 2.72),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(vects, proj_vects),\n",
        "            Transform(coord_labels, proj_coords),\n",
        "            faces.animate.apply_matrix(proj_mat),\n",
        "        )\n",
        "        self.play(frame.animate.reorient(56, 58, 0, (0.7, 0.32, 0.6), 2.72), run_time=5)\n",
        "\n",
        "    def add_coordinate_labels(self, axes):\n",
        "        coordinate_config = dict(font_size=12, buff=0.1)\n",
        "        axes.add_coordinate_labels(**coordinate_config)\n",
        "        axes.z_axis.add_numbers(\n",
        "            **coordinate_config,\n",
        "            excluding=[0],\n",
        "            direction=LEFT\n",
        "        )\n",
        "        for number in axes.z_axis.numbers:\n",
        "            number.scale(0.75, about_edge=RIGHT)\n",
        "            number.rotate(90 * DEGREES, RIGHT)\n",
        "\n",
        "    def construct_proj_matrix(self):\n",
        "        diag = normalize(np.ones(3))\n",
        "        id3 = np.identity(3)\n",
        "        return np.array([self.project(basis, diag) for basis in id3]).T\n",
        "\n",
        "    def gram_schmitt(self, vects):\n",
        "        for i in range(len(vects)):\n",
        "            for j in range(i):\n",
        "                vects[i] = self.project(vects[i], vects[j])\n",
        "            vects[i] = normalize(vects[i])\n",
        "        return vects\n",
        "\n",
        "    def project(self, vect, unit_norm):\n",
        "        \"\"\"\n",
        "        Project v1 onto the orthogonal subspace of norm\n",
        "        \"\"\"\n",
        "        return vect - np.dot(unit_norm, vect) * unit_norm\n",
        "\n",
        "\n",
        "class Project4DCube(Project3DCube):\n",
        "    def construct(self):\n",
        "        # Get hypercube data\n",
        "        frame = self.frame\n",
        "        hypercube_points, edge_indices = self.get_hypercube_data()\n",
        "\n",
        "        # Prepare pre-projectiong\n",
        "        w_shift = 2 * RIGHT + UP + OUT\n",
        "\n",
        "        cube_verts = np.array(list(it.product(*3 * [[0, 1]])))\n",
        "        cube_shell = VGroup(\n",
        "            Line(cube_verts[i], cube_verts[j])\n",
        "            for i, p1 in enumerate(cube_verts)\n",
        "            for j, p2 in enumerate(cube_verts[i + 1:], start=i + 1)\n",
        "            if get_norm(p2 - p1) == 1\n",
        "        )\n",
        "        cube_shells = cube_shell.replicate(2)\n",
        "        cube_shells[1].shift(w_shift)\n",
        "        edge_connectors = VGroup(Line(v, v + w_shift) for v in cube_verts)\n",
        "\n",
        "        cube_shells[0].set_stroke(BLUE, 2)\n",
        "        cube_shells[1].set_stroke(YELLOW, 2)\n",
        "        edge_connectors.set_stroke(WHITE, 1)\n",
        "\n",
        "        coord_labels = VGroup()\n",
        "        for point in hypercube_points:\n",
        "            label = Tex(str(tuple(point)), font_size=12)\n",
        "            point_3d = point[:3] + point[3] * w_shift\n",
        "            label.next_to(point_3d, DR, buff=0.05)\n",
        "            label.rotate(45 * DEGREES, RIGHT, about_point=point_3d)\n",
        "            coord_labels.add(label)\n",
        "        coord_labels.set_backstroke(BLACK, 2)\n",
        "\n",
        "        low_labels = coord_labels[0::2]\n",
        "        high_labels = coord_labels[1::2]\n",
        "        low_labels.set_z_index(1)\n",
        "        high_labels.set_z_index(1)\n",
        "        for group in [low_labels, high_labels]:\n",
        "            group.generate_target()\n",
        "            for part in group.target:\n",
        "                part[-2].set_fill(RED)\n",
        "\n",
        "        # Show lists of coordinates\n",
        "        titles = VGroup(Text(f\"{n}D Cube Vertices\") for n in [3, 4])\n",
        "        coords3d = VGroup(Tex(str(tuple(coords))) for coords in it.product(*3 * [[0, 1]]))\n",
        "        coords4d = VGroup(Tex(str(tuple(coords))) for coords in it.product(*4 * [[0, 1]]))\n",
        "\n",
        "        coords3d.scale(0.75).arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        coords4d.scale(0.75).arrange_in_grid(8, 2, v_buff=MED_SMALL_BUFF, h_buff=0.5)\n",
        "\n",
        "        for title, vect, coords in zip(titles, [LEFT, RIGHT], [coords3d, coords4d]):\n",
        "            title.move_to(vect * FRAME_WIDTH / 4).to_edge(UP)\n",
        "            title.add(Underline(title))\n",
        "            coords.set_backstroke(BLACK, 2)\n",
        "            coords.next_to(title, DOWN)\n",
        "\n",
        "        self.add(titles)\n",
        "        self.add(coords3d)\n",
        "        self.play(LaggedStartMap(FadeIn, coords4d, shift=0.1 * DOWN, lag_ratio=0.1, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        label_group3d = VGroup(titles[0], coords3d)\n",
        "        label_group4d = VGroup(titles[1], coords4d)\n",
        "        VGroup(label_group3d, label_group4d).fix_in_frame()\n",
        "\n",
        "        # Show pre-projection\n",
        "        pre_low_labels = coords4d[0::2].copy()\n",
        "        pre_low_labels.unfix_from_frame()\n",
        "        pre_low_labels.set_backstroke(BLACK, 2)\n",
        "\n",
        "        label_group4d.target = label_group4d.generate_target()\n",
        "        label_group4d.target.scale(0.5).to_corner(UL)\n",
        "        label_group4d.target[1][1::2].set_opacity(0.2)\n",
        "\n",
        "        self.play(\n",
        "            Write(cube_shells[0]),\n",
        "            TransformFromCopy(pre_low_labels, low_labels),\n",
        "            frame.animate.reorient(11, 67, 0, (1.08, 0.47, 0.77), 3.22),\n",
        "            FadeOut(label_group3d, 3 * LEFT),\n",
        "            MoveToTarget(label_group4d),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(6, note=\"Pan somewhat\")\n",
        "        self.play(\n",
        "            MoveToTarget(low_labels),\n",
        "            LaggedStart(\n",
        "                (FlashUnder(label[-3:], color=RED)\n",
        "                for label in low_labels),\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(edge_connectors, lag_ratio=0),\n",
        "            TransformFromCopy(*cube_shells),\n",
        "            TransformFromCopy(low_labels, high_labels),\n",
        "            label_group4d[1][1::2].animate.set_opacity(1),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(high_labels),\n",
        "            LaggedStart(\n",
        "                (FlashUnder(label[-3:], color=RED)\n",
        "                for label in high_labels),\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait(20, note=\"Pan and gesture\")\n",
        "\n",
        "        # Put pre-projection in the corner\n",
        "        axes = ThreeDAxes((-3, 3), (-3, 3), (-3, 3))\n",
        "        axes.set_height(12)\n",
        "        pre_proj_points = np.array([\n",
        "            *hypercube_points[:8, 1:],\n",
        "            *(hypercube_points[:8, 1:] + w_shift),\n",
        "        ])\n",
        "        pre_proj_frame = VGroup(\n",
        "            Line(pre_proj_points[i], pre_proj_points[j])\n",
        "            for i, j in edge_indices\n",
        "        )\n",
        "        pre_proj_frame.set_stroke(WHITE, 1)\n",
        "        pre_proj_frame.generate_target()\n",
        "        pre_proj_frame.target.fix_in_frame()\n",
        "        pre_proj_frame.target.set_height(1.0)\n",
        "        pre_proj_frame.target.rotate(60 * DEGREES, LEFT).rotate(45 * DEGREES, UP).rotate(15 * DEGREES, OUT)\n",
        "        pre_proj_frame.target.to_corner(UL, buff=LARGE_BUFF)\n",
        "\n",
        "        cloud = ThoughtBubble(Rectangle(2, 1.5))[0][3]\n",
        "        cloud.set_fill(GREY_E, 1)\n",
        "        cloud.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        cloud.fix_in_frame()\n",
        "        cloud_label = Text(\"4D\")\n",
        "        cloud_label.next_to(cloud, DOWN)\n",
        "        cloud_label.fix_in_frame()\n",
        "        pre_proj_frame.target.move_to(cloud)\n",
        "\n",
        "        arrow = Arrow(cloud.get_right(), UL, path_arc=-60 * DEGREES, thickness=5)\n",
        "        arrow.set_fill(border_width=0.5)\n",
        "        arrow.fix_in_frame()\n",
        "        arrow_label = TexText(\"Project along [1, 1, 1, 1]\", font_size=24)\n",
        "        arrow_label.next_to(arrow.pfp(0.15), UR, buff=0.15)\n",
        "        arrow_label.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(label_group4d),\n",
        "            FadeOut(VGroup(cube_shells, edge_connectors, coord_labels)),\n",
        "            FadeIn(pre_proj_frame),\n",
        "        )\n",
        "        self.add(cloud, pre_proj_frame),\n",
        "        self.play(\n",
        "            FadeIn(cloud, time_span=(2, 3)),\n",
        "            Write(cloud_label, time_span=(2, 3)),\n",
        "            MoveToTarget(pre_proj_frame),\n",
        "            frame.animate.reorient(22, 76, 0, (-1.33, 0.51, 0.63), 7.64),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow, path_arc=-30 * DEGREES),\n",
        "            Write(arrow_label),\n",
        "            Write(axes),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        corner_group = VGroup(cloud, cloud_label, pre_proj_frame, arrow, arrow_label)\n",
        "\n",
        "        # Project down\n",
        "        proj_coords = self.project_along_diagonal(hypercube_points)\n",
        "        proj_points = axes.c2p(*proj_coords.T)\n",
        "        proj_frame = VGroup(\n",
        "            Line(proj_points[i], proj_points[j])\n",
        "            for i, j in edge_indices\n",
        "        )\n",
        "        proj_frame.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.add(Point(), pre_proj_frame)\n",
        "        self.play(Transform(pre_proj_frame.copy(), proj_frame.copy(), run_time=3, remover=True))\n",
        "        self.add(Point(), proj_frame)\n",
        "        self.wait()\n",
        "\n",
        "        # Show solid faces\n",
        "        inner_cells = self.get_rhombic_dodec(side_length=axes.x_axis.get_unit_size())\n",
        "        inner_cells.set_color(BLUE_E, 1)\n",
        "\n",
        "        axes.apply_depth_test()\n",
        "        self.play(\n",
        "            FadeOut(proj_frame),\n",
        "            FadeIn(inner_cells),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Break up inner cells\n",
        "        space_factor = 1.5\n",
        "        ghost_cells = inner_cells.copy()\n",
        "        ghost_cells.deactivate_depth_test()\n",
        "        ghost_cells.set_opacity(0.1)\n",
        "        inner_cells.target = inner_cells.generate_target()\n",
        "        inner_cells.target.space_out_submobjects(space_factor)\n",
        "\n",
        "        for group in [inner_cells.target, ghost_cells]:\n",
        "            group.set_submobject_colors_by_gradient(RED_E, GREEN_E, BLUE_E, PINK)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(inner_cells),\n",
        "            FadeOut(corner_group),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(inner_cells),\n",
        "            FadeIn(ghost_cells, scale=0.8),\n",
        "        )\n",
        "\n",
        "        # Projected bases\n",
        "        proj_bases = self.construct_proj_matrix().T\n",
        "        proj_basis_vectors = VGroup(\n",
        "            Vector(axes.c2p(*basis))\n",
        "            for basis in proj_bases\n",
        "        )\n",
        "        proj_basis_labels = VGroup(\n",
        "            Tex(Rf\"P{tuple(basis)}\", font_size=24)\n",
        "            for basis in np.identity(4).astype(int)\n",
        "        )\n",
        "        for vect, label in zip(proj_basis_vectors, proj_basis_labels):\n",
        "            vect.set_perpendicular_to_camera(frame)  # Always?\n",
        "            label.next_to(vect.get_end(), RIGHT, SMALL_BUFF)\n",
        "            label.rotate(45 * DEGREES, about_point=vect.get_end(), axis=RIGHT)\n",
        "        proj_basis_labels[0].shift(0.25 * DOWN) \n",
        "\n",
        "        self.play(\n",
        "            axes.animate.set_stroke(width=1),\n",
        "            LaggedStartMap(GrowArrow, proj_basis_vectors, suspend_mobject_updating=True),\n",
        "            FadeIn(proj_basis_labels),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ghost_cells.animate.space_out_submobjects(space_factor).set_opacity(0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Iterate through triplets\n",
        "        ordered_cells = Group(ghost_cells[i] for i in [0, 1, 2, 3])\n",
        "        vect_groups = VGroup(\n",
        "            VGroup(vect, label)\n",
        "            for vect, label in zip(proj_basis_vectors, proj_basis_labels)\n",
        "        )\n",
        "        self.add(ordered_cells)\n",
        "        for i in range(4):\n",
        "            vect_groups.generate_target()\n",
        "            vect_groups.target.set_fill(opacity=1)\n",
        "            vect_groups.target[i].set_fill(opacity=0.1)\n",
        "            ordered_cells.generate_target()\n",
        "            ordered_cells.target.set_opacity(0.05)\n",
        "            ordered_cells.target[i].set_opacity(0.5)\n",
        "            self.play(\n",
        "                MoveToTarget(vect_groups),\n",
        "                MoveToTarget(ordered_cells),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(vect_groups),\n",
        "            FadeOut(ordered_cells),\n",
        "            FadeIn(inner_cells),\n",
        "        )\n",
        "\n",
        "        # Play more\n",
        "        self.wait(5)\n",
        "        self.play(inner_cells.animate.space_out_submobjects(1.0 / space_factor))\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show inversion\n",
        "        self.play(FadeOut(inner_cells[1:]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            inner_cells[0].animate.move_to(-inner_cells[0].get_center()),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(inner_cells[1:]))\n",
        "        self.wait()\n",
        "\n",
        "        inner_cells.save_state()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (cell.animate.move_to(-cell.get_center())\n",
        "                for cell in inner_cells),\n",
        "                group=inner_cells,\n",
        "                group_type=Group,\n",
        "                run_time=3,\n",
        "                lag_ratio=0.25\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(inner_cells))\n",
        "        self.wait()\n",
        "\n",
        "        # Tile space\n",
        "        N = 4\n",
        "        small_space_factor = 1.1\n",
        "        tiling = Group()\n",
        "\n",
        "        for i in range(4):\n",
        "            indices = list(range(4))\n",
        "            indices.remove(i)\n",
        "            bases = proj_bases[indices]\n",
        "            for coords in it.product(*3 * [list(range(N))]):\n",
        "                vect = axes.c2p(*np.dot(coords, bases))\n",
        "                new_cell = inner_cells[i].copy().shift(vect)\n",
        "                tiling.add(new_cell)\n",
        "\n",
        "        tiling.space_out_submobjects(small_space_factor)\n",
        "        tiling.sort(lambda p: get_norm(p))\n",
        "        colored_tiling = tiling.copy()\n",
        "        tiling.set_color(BLUE_E)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(inner_cells[:2]),\n",
        "            FadeOut(inner_cells[3:]),\n",
        "            axes.animate.set_stroke(width=0, opacity=0),\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "        self.remove(inner_cells)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(inner_cells[2], cell)\n",
        "                for cell in tiling),\n",
        "                group_type=Group,\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            frame.animate.reorient(19, 65, 0, (1.39, 1.51, 0.57), 21.55),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait(20)\n",
        "        self.play(frame.animate.reorient(36, 66, 0, (-1.32, 0.25, -0.7), 22.55), run_time=3)\n",
        "        self.play(frame.animate.increment_theta(PI), run_time=10)\n",
        "        self.play(Transform(tiling, colored_tiling))\n",
        "        self.wait()\n",
        "\n",
        "    def get_hypercube_data(self):\n",
        "        points = np.array(list(it.product(*4 * [[0, 1]])))\n",
        "        edge_indices = [\n",
        "            (i, j)\n",
        "            for i, p1 in enumerate(points)\n",
        "            for j, p2 in enumerate(points[i + 1:], start=i + 1)\n",
        "            if get_norm(p2 - p1) == 1\n",
        "        ]\n",
        "\n",
        "        return points, edge_indices\n",
        "\n",
        "    def project_along_diagonal(self, points):\n",
        "        if not hasattr(self, \"diag_4d_projection\"):\n",
        "            self.diag_4d_projection = self.construct_proj_matrix()\n",
        "        return np.dot(points, self.diag_4d_projection.T)\n",
        "\n",
        "    def construct_proj_matrix(self):\n",
        "        diag = normalize(np.ones(4))\n",
        "        id4 = np.identity(4)\n",
        "        pre_basis = np.array([diag, id4[1] - id4[0], id4[2], id4[3]])\n",
        "        basis = self.gram_schmitt(pre_basis)\n",
        "        return basis[1:, :]\n",
        "\n",
        "    def get_rhombic_dodec(self, side_length=1):\n",
        "        cube = Cube()\n",
        "        cube.set_width(side_length)\n",
        "        cube.move_to(ORIGIN, -np.ones(3))\n",
        "\n",
        "        proj_bases = self.project_along_diagonal(np.identity(4))\n",
        "        cells = Group()\n",
        "        for i in range(4):\n",
        "            indices = list(range(4))\n",
        "            indices.remove(i)\n",
        "            mat = proj_bases[indices]\n",
        "            cells.add(cube.copy().apply_matrix(mat.T, about_point=ORIGIN))\n",
        "\n",
        "        cells.set_color(BLUE_E, 1)\n",
        "        return cells\n",
        "\n",
        "\n",
        "class ShowRhombicDodecTesselation(Project4DCube):\n",
        "    def construct(self):\n",
        "        # Create tiling pattern\n",
        "        frame = self.frame\n",
        "        proj_bases = self.project_along_diagonal(np.identity(4))\n",
        "        dodec = self.get_rhombic_dodec()\n",
        "\n",
        "        N = 6\n",
        "        coords = [\n",
        "            coords\n",
        "            for coords in it.product(*4 * [list(range(N))])\n",
        "            if sum(coords) == 8\n",
        "        ]\n",
        "        pieces = Group(\n",
        "            dodec.copy().shift(np.dot(coord, proj_bases))\n",
        "            for coord in coords\n",
        "        )\n",
        "        pieces.sort(lambda p: get_norm(p))\n",
        "        for piece in pieces:\n",
        "            piece.set_color(random_bright_color(hue_range=(0.5, 0.55), luminance_range=(0.25, 0.5)))\n",
        "            piece.save_state()\n",
        "\n",
        "        pieces.space_out_submobjects(1.25)\n",
        "        pieces.set_opacity(0)\n",
        "\n",
        "        frame.reorient(31, 77, 0).set_height(6)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (Restore(piece)\n",
        "                for piece in pieces),\n",
        "                lag_ratio=0.5,\n",
        "                group_type=Group\n",
        "            ),\n",
        "            frame.animate.reorient(-93, 68, 0, (0.07, 0.22, 0.17), 15),\n",
        "            run_time=12,\n",
        "        )\n",
        "\n",
        "\n",
        "class CubeToHypercubeAnalogy(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Vertices\n",
        "\n",
        "        # Numbers of faces/cells\n",
        "\n",
        "        # Which specific cells touch the origin\n",
        "        pass\n",
        "\n",
        "\n",
        "class AskStripQuestion(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add circle\n",
        "        radius = 2.5\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(YELLOW, 2)\n",
        "        radial_line = Line(circle.get_center(), circle.get_right())\n",
        "        radial_line.set_stroke(WHITE, 2)\n",
        "        radius_label = Integer(1)\n",
        "        radius_label.next_to(radial_line, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            FadeIn(radius_label, RIGHT)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(radial_line, 2 * PI, about_point=circle.get_center()),\n",
        "            ShowCreation(circle),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show first strip\n",
        "        r0_tracker = ValueTracker(0.2)\n",
        "        r1_tracker = ValueTracker(0.8)\n",
        "        strip1 = always_redraw(lambda: self.get_strip(\n",
        "            circle,\n",
        "            r0_tracker.get_value(), r1_tracker.get_value(),\n",
        "            theta=TAU / 3,\n",
        "            color=TEAL,\n",
        "            include_arrow=True,\n",
        "            label=\"\"\n",
        "        ))\n",
        "        radius = radial_line.get_length()\n",
        "        width_label = DecimalNumber(0)\n",
        "        width_label.add_updater(lambda m: m.set_value(r1_tracker.get_value() - r0_tracker.get_value()))\n",
        "        width_label.add_updater(lambda m: m.set_height(min(0.33, 0.5 * strip1.submobjects[0].get_height())))\n",
        "        width_label.always.next_to(strip1.submobjects[0].get_center(), UR, SMALL_BUFF)\n",
        "\n",
        "        d_label = Tex(R\"d_1\")\n",
        "        d_label.move_to(width_label, DL)\n",
        "\n",
        "        strip1.suspend_updating()\n",
        "        self.animate_strip_in(strip1)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(width_label, suspend_mobject_updating=True))\n",
        "        strip1.resume_updating()\n",
        "        self.play(\n",
        "            r0_tracker.animate.set_value(0.49),\n",
        "            r1_tracker.animate.set_value(0.51),\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        strip1.clear_updaters()\n",
        "        width_label.clear_updaters()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(width_label, d_label))\n",
        "        strip1.add(d_label)\n",
        "\n",
        "        # Add first couple strips\n",
        "        new_strips = VGroup(\n",
        "            self.get_strip(\n",
        "                circle, r0, r1, angle,\n",
        "                color=color,\n",
        "                include_arrow=True,\n",
        "                label=f\"d_{n}\",\n",
        "            )\n",
        "            for n, r0, r1, angle, color in [\n",
        "                (2, 0.5, 0.75, 2 * TAU / 3, GREEN),\n",
        "                (3, 0.1, 0.3, 0.8 * TAU, BLUE_D),\n",
        "                (4, 0.4, 0.7, 0.1 * TAU, BLUE_B),\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        for strip in new_strips:\n",
        "            self.animate_strip_in(strip)\n",
        "\n",
        "        # Cover in lots of strips\n",
        "        np.random.seed(0)\n",
        "        strips = VGroup(\n",
        "            self.get_strip(\n",
        "                circle,\n",
        "                *sorted(np.random.uniform(-1, 1, 2)),\n",
        "                TAU * np.random.uniform(0, TAU),\n",
        "                opacity=0.25\n",
        "            ).set_stroke(width=1)\n",
        "            for n in range(10)\n",
        "        )\n",
        "        self.add(strips, strip1, new_strips, circle, radius_label)\n",
        "        self.play(FadeIn(strips, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Add together all the widths\n",
        "        frame = self.frame\n",
        "        arrows = VGroup(strip.submobjects[0] for strip in (strip1, *new_strips))\n",
        "        d_labels = VGroup(strip.submobjects[1] for strip in (strip1, *new_strips))\n",
        "\n",
        "        top_expr = Tex(R\"d_1 + d_2 + d_3 + d_4 + \\cdots + d_n\")\n",
        "        top_expr.to_edge(UP, buff=0)\n",
        "        d_labels.target = VGroup(\n",
        "            top_expr[f\"d_{n}\"][0]\n",
        "            for n in range(1, 5)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                MoveToTarget(d_labels, lag_ratio=0.01),\n",
        "                Write(top_expr[\"+\"]),\n",
        "                Write(top_expr[R\"\\cdots\"]),\n",
        "                Write(top_expr[R\"d_n\"]),\n",
        "                lag_ratio=0.5\n",
        "            ),\n",
        "            FadeOut(arrows),\n",
        "            frame.animate.move_to(UP).set_anim_args(run_time=2)\n",
        "        )\n",
        "        self.remove(d_labels)\n",
        "        self.add(top_expr)\n",
        "        self.wait()\n",
        "\n",
        "        # Compress sum\n",
        "        short_expr = Tex(R\"\\min\\left( \\sum_i d_i \\right)\")\n",
        "        short_expr.move_to(top_expr)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                ReplacementTransform(top_expr[re.compile(\"d_.\")], short_expr[\"d_i\"]),\n",
        "                ReplacementTransform(top_expr[\"+\"], short_expr[R\"\\sum\"]),\n",
        "                ReplacementTransform(top_expr[R\"\\cdots\"], short_expr[\"i\"][1]),\n",
        "                lag_ratio=0.25\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            Write(short_expr[R\"\\min\\left(\"]),\n",
        "            Write(short_expr[R\"\\right)\"]),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show various alternate coverings\n",
        "        d_labels.set_opacity(0)\n",
        "        arrows.set_opacity(0)\n",
        "        curr_strips = VGroup(strip1, *new_strips, *strips)\n",
        "        og_strips = curr_strips\n",
        "\n",
        "        for _ in range(4):\n",
        "            self.play(FadeOut(curr_strips))\n",
        "            base_hue = random.random()\n",
        "            curr_strips = VGroup(\n",
        "                self.get_strip(\n",
        "                    circle,\n",
        "                    *sorted(np.random.uniform(-1, 1, 2)),\n",
        "                    TAU * np.random.uniform(0, TAU),\n",
        "                    color=random_bright_color(hue_range=(base_hue, base_hue + 0.2)),\n",
        "                    opacity=0.25\n",
        "                ).set_stroke(width=1)\n",
        "                for n in range(15)\n",
        "            )\n",
        "            self.play(ShowIncreasingSubsets(curr_strips))\n",
        "\n",
        "        self.play(FadeOut(curr_strips))\n",
        "        self.play(ShowIncreasingSubsets(og_strips))\n",
        "\n",
        "        # Show trivial covering\n",
        "        fat_strip = self.get_strip(circle, -1, 1, 0, RED_B)\n",
        "        fat_strip.rect.set_height(6, stretch=True)\n",
        "        fat_strip.pre_rect.move_to(fat_strip.rect, DOWN)\n",
        "\n",
        "        top_brace = Brace(fat_strip.rect, UP)\n",
        "        top_label = top_brace.get_text(\"2\")\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(og_strips),\n",
        "            short_expr.animate.next_to(circle, RIGHT, buff=LARGE_BUFF),\n",
        "            frame.animate.move_to(0.5 * UP)\n",
        "        )\n",
        "        self.play(Transform(fat_strip.pre_rect, fat_strip.rect))\n",
        "        self.play(GrowFromCenter(top_brace), Write(top_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Subdivide trivial covering\n",
        "        subdivision = sorted([-1, 1, *np.random.uniform(-1, 1, 10)])\n",
        "        strips = VGroup(\n",
        "            self.get_strip(circle, r0, r1, theta=0, color=random_bright_color(hue_range=(0.3, 0.5)))\n",
        "            for r0, r1 in zip(subdivision, subdivision[1:])\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(fat_strip.pre_rect),\n",
        "            FadeIn(strips, lag_ratio=0.5, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show suggestive fan covering\n",
        "        fan_covering = VGroup(\n",
        "            self.get_strip(circle, -0.4, 0.4, theta=theta)\n",
        "            for theta in np.arange(0, TAU, TAU / 3)\n",
        "        )\n",
        "        fan_covering.add(*(\n",
        "            self.get_strip(circle, 0.6, 0.9, theta=theta)\n",
        "            for theta in np.arange(TAU / 12, TAU, TAU / 3)\n",
        "        ))\n",
        "\n",
        "        self.play(FadeOut(strips))\n",
        "        for strip in fan_covering:\n",
        "            self.animate_strip_in(strip)\n",
        "        self.wait()\n",
        "\n",
        "    def get_strip(self, circle, r0, r1, theta, color=None, opacity=0.5, include_arrow=False, label=\"\", rect_length=10.0):\n",
        "        diam = circle.get_width()\n",
        "        width = (r1 - r0) * diam / 2\n",
        "        if color is None:\n",
        "            color = random_bright_color(luminance_range=(0.5, 0.7))\n",
        "\n",
        "        rect = Rectangle(width, rect_length)\n",
        "        rect.move_to(\n",
        "            interpolate(circle.get_center(), circle.get_right(), r0),\n",
        "            LEFT,\n",
        "        )\n",
        "        rect.set_fill(color, opacity)\n",
        "        rect.set_stroke(color, 1)\n",
        "        pre_rect = rect.copy().stretch(0, 1, about_edge=DOWN)\n",
        "        pre_rect.set_stroke(width=0)\n",
        "        VGroup(rect, pre_rect).rotate(theta, about_point=circle.get_center())\n",
        "\n",
        "        strip = Intersection(rect, circle)\n",
        "        strip.match_style(rect)\n",
        "        strip.rect = rect\n",
        "        strip.pre_rect = pre_rect\n",
        "\n",
        "        if include_arrow:\n",
        "            arrow = Tex(R\"\\longleftrightarrow\")\n",
        "            arrow.set_width(width, stretch=True)\n",
        "            arrow.rotate(theta)\n",
        "            arrow.move_to(rect)\n",
        "            strip.add(arrow)\n",
        "        if len(label) > 0:\n",
        "            label = Tex(label, font_size=36)\n",
        "            label.move_to(rect.get_center())\n",
        "            vect = 0.25 * rotate_vector(UP, theta)\n",
        "            vect *= np.sign(vect[1])\n",
        "            label.shift(vect)\n",
        "            strip.add(label)\n",
        "\n",
        "        return strip\n",
        "\n",
        "    def animate_strip_in(self, strip):\n",
        "        self.play(Transform(strip.pre_rect, strip.rect))\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(strip),\n",
        "            FadeOut(strip.pre_rect),\n",
        "            lag_ratio=0.5,\n",
        "            run_time=1,\n",
        "        ))\n",
        "\n",
        "\n",
        "class StruggleWithStrips(AskStripQuestion):\n",
        "    def construct(self):\n",
        "        # Add circle\n",
        "        radius = 2.5\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(YELLOW, 2)\n",
        "        radial_line = Line(circle.get_center(), circle.get_right())\n",
        "        radial_line.set_stroke(WHITE, 2)\n",
        "        radius_label = Integer(1)\n",
        "        radius_label.next_to(radial_line, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(circle, radial_line, radius_label)\n",
        "\n",
        "        # Show fan strategy\n",
        "        angles = [*np.arange(0, TAU, TAU / 3), *np.arange(TAU / 12, TAU, TAU / 3)]\n",
        "        widths = [*3 * [0.8], *3 * [0.25]]\n",
        "        strips = VGroup(\n",
        "            self.get_strip(circle, -0.4, 0.4, theta=theta, include_arrow=True)\n",
        "            for theta in angles[:3]\n",
        "        )\n",
        "        strips.add(*(\n",
        "            self.get_strip(circle, 0.7, 0.95, theta=theta, include_arrow=True)\n",
        "            for theta in angles[3:]\n",
        "        ))\n",
        "        arrows = VGroup()\n",
        "        for strip in strips:\n",
        "            arrow = strip[0]\n",
        "            strip.remove(arrow)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            (TransformFromCopy(strip.pre_rect, strip.rect)\n",
        "            for strip in strips),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        rects = VGroup(strip.rect for strip in strips)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, rects),\n",
        "            LaggedStartMap(FadeIn, strips),\n",
        "        )\n",
        "\n",
        "        # Show the sum\n",
        "        sum_expr = Tex(\"0.00 + 0.00 + 0.00 + 0.00 + 0.00 + 0.00 = 0.00\")\n",
        "        sum_expr.to_edge(UP)\n",
        "        decimals = sum_expr.make_number_changeable(\"0.00\", replace_all=True)\n",
        "        width_terms = decimals[:6]\n",
        "        sum_term = decimals[6]\n",
        "        plusses = sum_expr[\"+\"]\n",
        "        equals = sum_expr[\"=\"][0]\n",
        "        plusses.add_to_back(VectorizedPoint(sum_expr.get_left()))\n",
        "\n",
        "        sum_term.set_fill(RED)\n",
        "\n",
        "        last_arrow = VGroup()\n",
        "        for i in range(len(strips)):\n",
        "            width_term = width_terms[i]\n",
        "            width_term.set_value(widths[i])\n",
        "            width_term.save_state()\n",
        "\n",
        "            arrow = arrows[i]\n",
        "            width_term.next_to(\n",
        "                arrow.get_center(),\n",
        "                rotate_vector(UP, angles[i])\n",
        "            )\n",
        "\n",
        "            strips.target = strips.generate_target()\n",
        "            strips.target.set_opacity(0.2)\n",
        "            strips.target[i].set_fill(opacity=0.5)\n",
        "            strips.target[i].set_stroke(opacity=1)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(strips),\n",
        "                FadeIn(width_term),\n",
        "                FadeIn(arrow),\n",
        "                FadeOut(last_arrow),\n",
        "            )\n",
        "            self.play(\n",
        "                Restore(width_term),\n",
        "                FadeIn(plusses[i])\n",
        "            )\n",
        "\n",
        "            last_arrow = arrow\n",
        "\n",
        "        sum_term.set_value(sum(wt.get_value() for wt in width_terms))\n",
        "        self.play(\n",
        "            FadeOut(last_arrow),\n",
        "            strips.animate.set_fill(opacity=0.5).set_stroke(opacity=1),\n",
        "            Write(equals),\n",
        "            FadeIn(sum_term),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Turn into parallel strips\n",
        "        np.random.seed(3)\n",
        "        subdivision = sorted([-1, 1, *np.random.uniform(-1, 1, 5)])\n",
        "        r_pairs = list(zip(subdivision, subdivision[1:]))\n",
        "        new_widths = [r1 - r0 for r0, r1 in r_pairs]\n",
        "\n",
        "        new_strips = VGroup(\n",
        "            self.get_strip(circle, r0, r1, theta=0)\n",
        "            for r0, r1 in r_pairs\n",
        "        )\n",
        "        new_strips.match_style(strips)\n",
        "        new_rects = VGroup(s.rect for s in new_strips)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(strips),\n",
        "            FadeIn(rects),\n",
        "        )\n",
        "        self.play(\n",
        "            # Transform(strips, new_strips),\n",
        "            ReplacementTransform(rects, new_rects),\n",
        "            *(\n",
        "                ChangeDecimalToValue(width_term, new_width)\n",
        "                for width_term, new_width in zip(width_terms, new_widths)\n",
        "            ),\n",
        "            ChangeDecimalToValue(sum_term, 2.0),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeOut(new_rects), FadeIn(new_strips))\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum of the area\n",
        "        width_sum = Tex(R\"\\sum_{\\text{strip}} \\textbf{Width}(\\text{strip})\")\n",
        "        area_sum = Tex(R\"\\sum_{\\text{strip}} \\textbf{Area}(\\text{strip})\")\n",
        "        area_sum_rhs = Tex(R\"\\ge \\pi r^2 = \\pi\")\n",
        "        width_sum.to_corner(UR)\n",
        "        area_sum.to_corner(UL)\n",
        "        area_sum_rhs.next_to(area_sum[-1], RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        width_brace = Brace(width_sum, DOWN)\n",
        "        width_annotation = width_brace.get_text(\"We want to\\ncontrol this\")\n",
        "        width_annotation.set_color(YELLOW)\n",
        "\n",
        "        self.play(FadeTransformPieces(sum_expr, width_sum))\n",
        "        self.play(GrowFromCenter(width_brace), Write(width_annotation))\n",
        "        self.wait()\n",
        "        self.play(Write(area_sum))\n",
        "        self.wait()\n",
        "        self.play(Write(area_sum_rhs))\n",
        "        self.wait()\n",
        "\n",
        "        # Add area and width label for strip\n",
        "        strip = new_strips[1]\n",
        "        area_label = TexText(R\"Area = $0.00$\")\n",
        "        area_dec = area_label.make_number_changeable(\"0.00\")\n",
        "        area_dec.add_updater(lambda m: m.set_value(\n",
        "            get_norm(strip.get_area_vector()) / radius**2\n",
        "        ))\n",
        "        area_label.add_updater(lambda m: m.next_to(strip, LEFT))\n",
        "        area_label.match_color(strip)\n",
        "\n",
        "        arrow = Tex(R\"\\leftrightarrow\").stretch(2, 0)\n",
        "        arrow.match_width(strip)\n",
        "        arrow.always.move_to(strip)\n",
        "\n",
        "        width_label = VGroup(\n",
        "            Text(\"Width\"),\n",
        "            Tex(\"=\").rotate(90 * DEGREES),\n",
        "            DecimalNumber(1),\n",
        "        )\n",
        "        width_label.arrange(DOWN)\n",
        "        width_label.set_width(strip.get_width() * 0.8)\n",
        "        width_label[2].add_updater(lambda m: m.set_value(strip.get_width() / radius))\n",
        "        width_label.always.next_to(arrow, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(new_strips[:1]),\n",
        "            FadeOut(new_strips[2:]),\n",
        "            FadeOut(radial_line),\n",
        "            FadeOut(radius_label),\n",
        "        )\n",
        "        self.play(Write(area_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(arrow),\n",
        "            FadeIn(width_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show varying strip\n",
        "        r0 = subdivision[1]\n",
        "        delta_r = subdivision[2] - subdivision[1]\n",
        "        delta_r_tracker = ValueTracker(delta_r)\n",
        "        r0_tracker = ValueTracker(r0)\n",
        "\n",
        "        strip.add_updater(lambda m: m.match_points(self.get_strip(\n",
        "            circle,\n",
        "            r0_tracker.get_value(),\n",
        "            r0_tracker.get_value() + delta_r_tracker.get_value(),\n",
        "            theta=0\n",
        "        )))\n",
        "        for value in [-1, 0.6, r0]:\n",
        "            self.play(r0_tracker.animate.set_value(value), run_time=4)\n",
        "\n",
        "        self.play(\n",
        "            delta_r_tracker.animate.set_value(0.3),\n",
        "            arrow.animate.scale(0.3 / 0.44),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        strip.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(area_label),\n",
        "            FadeOut(width_label),\n",
        "            FadeOut(arrow),\n",
        "            FadeIn(new_strips[:1]),\n",
        "            FadeIn(new_strips[2:]),\n",
        "        )\n",
        "\n",
        "        # Show the dream of proportionality\n",
        "        width_label_group = VGroup(width_sum, width_brace, width_annotation)\n",
        "        circle_group = VGroup(circle, new_strips)\n",
        "\n",
        "        dream_sum = Tex(R\"\\sum_{\\text{strip}} {k} \\cdot \\textbf{Width}(\\text{strip})\")\n",
        "        dream_sum[R\"{k}\"].set_color(YELLOW)\n",
        "        dream_sum.next_to(area_sum, DOWN, buff=2.0)\n",
        "        dream_sum.shift_onto_screen()\n",
        "\n",
        "        down_arrow = Arrow(area_sum, dream_sum, thickness=5)\n",
        "        arrow_words = Text(\"If only...\")\n",
        "        arrow_words.next_to(down_arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            circle_group.animate.shift(3 * RIGHT),\n",
        "            width_label_group.animate.scale(0.5, about_edge=UR),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(down_arrow),\n",
        "            FadeIn(arrow_words, lag_ratio=0.1)\n",
        "        )\n",
        "        self.play(TransformMatchingStrings(area_sum.copy(), dream_sum))\n",
        "        self.wait()\n",
        "\n",
        "    def get_strip(self, *args, **kwargs):\n",
        "        kwargs[\"rect_length\"] = kwargs.get(\"rect_length\", 6.0)\n",
        "        return super().get_strip(*args, **kwargs)\n",
        "\n",
        "\n",
        "class SphereStrips(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        frame = self.frame\n",
        "        frame.set_height(3)\n",
        "        axes = ThreeDAxes((-2, 2), (-2, 2), (-2, 2))\n",
        "        axes.set_stroke(width=1)\n",
        "        plane = NumberPlane((-2, 2), (-2, 2))\n",
        "        plane.fade(0.5)\n",
        "        self.add(axes)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Circle\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(YELLOW, 3)\n",
        "        circle.set_fill(BLACK, 0.0)\n",
        "        self.add(circle)\n",
        "\n",
        "        # Sphere\n",
        "        sphere = ParametricSurface(\n",
        "            lambda u, v: [\n",
        "                np.sin(u) * np.cos(v),\n",
        "                np.sin(u) * np.sin(v),\n",
        "                np.cos(u)\n",
        "            ],\n",
        "            u_range=(0, PI),\n",
        "            v_range=(0, 2 * PI)\n",
        "        )\n",
        "        sphere.set_opacity(0.5)\n",
        "        sphere.set_shading(0.5, 0.5, 0.5)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "        sphere.set_clip_plane(OUT, 1e-3)\n",
        "\n",
        "        # Show pre_strip\n",
        "        delta_x = 0.25\n",
        "        x0 = 0.5\n",
        "        strip = self.get_strip(x0, x0 + delta_x, 0)\n",
        "        pre_strip = strip.copy()\n",
        "        pre_strip.stretch(1e-3, 2)\n",
        "        pre_strip.set_z_index(1)\n",
        "        circle.set_clip_plane(UP, 10)  # Why?\n",
        "        plane.set_clip_plane(UP, 10)  # Why?\n",
        "\n",
        "        self.play(ShowCreation(pre_strip, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Expand\n",
        "        pre_sphere = sphere.copy()\n",
        "        pre_sphere.stretch(0, 2)\n",
        "        pre_sphere.shift(1e-2 * IN)\n",
        "        pre_sphere.set_opacity(0)\n",
        "\n",
        "        strip.save_state()\n",
        "        strip.become(pre_strip)\n",
        "        sphere.save_state()\n",
        "        sphere.become(pre_sphere)\n",
        "\n",
        "        self.remove(pre_strip)\n",
        "        self.add(strip, sphere)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-34, 59, 0),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(pre_sphere, pre_strip)\n",
        "        self.play(\n",
        "            Restore(strip),\n",
        "            Restore(sphere),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(40, 59, 0),\n",
        "            run_time=7\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Note the area\n",
        "        brace = Brace(pre_strip, UP)\n",
        "        brace.add(brace.get_tex(R\"d\", font_size=24, buff=0.05))\n",
        "        brace.rotate(90 * DEGREES, RIGHT)\n",
        "        brace.next_to(strip, OUT, buff=0)\n",
        "\n",
        "        area_label = TexText(R\"Area = $\\pi d$\")\n",
        "        area_label.to_corner(UR)\n",
        "        area_label.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace, time_span=(1, 2)),\n",
        "            frame.animate.reorient(-2, 94, 0, (0.31, 0.11, 0.63), 2.35),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(area_label),\n",
        "            Transform(\n",
        "                brace[-1].copy(),\n",
        "                brace[-1].copy().scale(0.5).shift(1.5 * RIGHT + 0.25 * OUT).set_opacity(0),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        self.play(FlashAround(area_label, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Move strip around\n",
        "        x0_tracker = ValueTracker(x0)\n",
        "        strip.add_updater(lambda m: m.become(self.get_strip(\n",
        "            x0_tracker.get_value(),\n",
        "            x0_tracker.get_value() + delta_x,\n",
        "            theta=0\n",
        "        )))\n",
        "        brace.add_updater(lambda m: m.next_to(strip, OUT, buff=0))\n",
        "\n",
        "        self.play(\n",
        "            x0_tracker.animate.set_value(-0.99),\n",
        "            frame.animate.reorient(-24, 82, 0, (0.4, 0.08, 0.63), 2.67),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            x0_tracker.animate.set_value(0.5),\n",
        "            frame.animate.reorient(2, 76, 0, (0.4, 0.08, 0.63), 2.67),\n",
        "            run_time=5\n",
        "        )\n",
        "        strip.clear_updaters()\n",
        "        brace.clear_updaters()\n",
        "        self.play(FadeOut(brace), FadeOut(area_label))\n",
        "\n",
        "        # Reorient and add make full sphere\n",
        "        self.play(\n",
        "            frame.animate.reorient(29, 74, 0, ORIGIN, 3.00).set_anim_args(run_time=2),\n",
        "            sphere.animate.set_clip_plane(OUT, 1),\n",
        "            strip.animate.set_clip_plane(OUT, 1),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(7, 67, 0),\n",
        "            Rotate(strip, PI / 2, DOWN, about_point=ORIGIN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add cylinder\n",
        "        clyinder = ParametricSurface(\n",
        "            lambda u, v: [np.cos(v), np.sin(v), u],\n",
        "            u_range=[-1, 1],\n",
        "            v_range=[0, TAU],\n",
        "        )\n",
        "        cylinder_mesh = SurfaceMesh(clyinder, resolution=(33, 51))\n",
        "        cylinder_mesh.set_stroke(WHITE, 1, 0.25)\n",
        "        cylinder_mesh.set_clip_plane(UP, 20)\n",
        "        cylinder_mesh.match_height(sphere)\n",
        "\n",
        "        self.play(ShowCreation(cylinder_mesh, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "\n",
        "        # Project the strip\n",
        "        def clyinder_projection(points):\n",
        "            radii = np.apply_along_axis(np.linalg.norm, 1, points[:, :2])\n",
        "            return np.transpose([points[:, 0] / radii, points[:, 1] / radii, points[:, 2]])\n",
        "\n",
        "        def get_proj_strip(strip):\n",
        "            return strip.copy().apply_points_function(clyinder_projection).set_opacity(0.8)\n",
        "\n",
        "        proj_strip = get_proj_strip(strip)\n",
        "        proj_strip.save_state()\n",
        "        proj_strip.become(strip)\n",
        "\n",
        "        self.add(proj_strip, cylinder_mesh)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-28, 62, 0).set_anim_args(run_time=4),\n",
        "            Restore(proj_strip, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Vary the height of the strip\n",
        "        strip.add_updater(lambda m: m.become(\n",
        "            self.get_strip(\n",
        "                x0_tracker.get_value(),\n",
        "                x0_tracker.get_value() + delta_x,\n",
        "                theta=0,\n",
        "            ).rotate(PI / 2, DOWN, about_point=ORIGIN)\n",
        "        ))\n",
        "        proj_strip.add_updater(lambda m: m.match_z(strip))\n",
        "        sphere.set_clip_plane(UP, 20)\n",
        "\n",
        "        self.add(sphere, cylinder_mesh)\n",
        "        frame.add_ambient_rotation()\n",
        "        for value in [0.75, 0, 0.5]:\n",
        "            self.play(x0_tracker.animate.set_value(value), run_time=6)\n",
        "\n",
        "        frame.clear_updaters()\n",
        "        strip.clear_updaters()\n",
        "        proj_strip.clear_updaters()\n",
        "\n",
        "        # Go back to the hemisphere state\n",
        "        self.play(\n",
        "            FadeOut(cylinder_mesh),\n",
        "            FadeOut(proj_strip, 5 * OUT),\n",
        "        )\n",
        "        strip.set_clip_plane(OUT, 0)\n",
        "        sphere.set_clip_plane(OUT, 1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(23, 68, 0),\n",
        "            sphere.animate.set_clip_plane(OUT, 0),\n",
        "            Rotate(strip, PI / 2, axis=UP, about_point=ORIGIN),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Cover with more strips\n",
        "        strips = Group(\n",
        "            self.get_strip(\n",
        "                *sorted(np.random.random(2)),\n",
        "                theta=random.uniform(0, TAU),\n",
        "                color=random_bright_color(),\n",
        "            ).shift(x * 1e-3 * OUT)\n",
        "            for x in range(1, 20)\n",
        "        )\n",
        "        strips.set_opacity(0.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(strips, lag_ratio=0.9),\n",
        "            frame.animate.reorient(-17, 31, 0),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-24, 64, 0),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_strip(self, x0, x1, theta, color=BLUE):\n",
        "        strip = ParametricSurface(\n",
        "            lambda u, v: [\n",
        "                np.cos(u),\n",
        "                np.sin(u) * np.cos(v),\n",
        "                np.sin(u) * np.sin(v),\n",
        "            ],\n",
        "            u_range=(math.acos(x1), math.acos(x0)),\n",
        "            v_range=(0, TAU),\n",
        "        )\n",
        "        strip.rotate(theta, OUT, about_point=ORIGIN)\n",
        "        strip.scale(1.001, about_point=ORIGIN)\n",
        "        strip.set_color(color)\n",
        "        strip.set_shading(0.5, 0.5, 0.5)\n",
        "        strip.set_clip_plane(OUT, 1e-3)\n",
        "        return strip\n",
        "\n",
        "\n",
        "class MongesTheorem(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add circles\n",
        "        circ1, circ2, circ3 = circles = self.get_initial_circles()\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, circles, lag_ratio=0.5, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Add tangents\n",
        "        tangent_pairs = always_redraw(lambda: self.get_all_external_tangents(circles))\n",
        "        intersection_dots = always_redraw(lambda: self.get_all_intersection_dots(tangent_pairs))\n",
        "\n",
        "        dependents = Group(tangent_pairs, intersection_dots)\n",
        "        dependents.suspend_updating()\n",
        "\n",
        "        for tangents, dot, circle_pair in zip(tangent_pairs, intersection_dots, it.combinations(circles, 2)):\n",
        "            c1, c2 = (c.copy() for c in circle_pair)\n",
        "            self.play(*map(GrowFromCenter, tangents), run_time=1.5)\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    c1.animate.scale(0, about_point=dot.get_center()),\n",
        "                    c2.animate.scale(0, about_point=dot.get_center()),\n",
        "                    FadeIn(dot),\n",
        "                    lag_ratio=0.2,\n",
        "                )\n",
        "            )\n",
        "            self.remove(c1, c2)\n",
        "            self.wait()\n",
        "\n",
        "        # Manipuate the circles\n",
        "        dependents.resume_updating()\n",
        "        circles.save_state()\n",
        "        self.add(*dependents)\n",
        "\n",
        "        self.add(*circles)\n",
        "        self.wait(note=\"Play with circle positions. Be careful!\")\n",
        "\n",
        "        # Show the line between them\n",
        "        monge_line = Line()\n",
        "        monge_line.f_always.put_start_and_end_on(\n",
        "            intersection_dots[0].get_center,\n",
        "            intersection_dots[2].get_center,\n",
        "        )\n",
        "        monge_line.always.set_length(100)\n",
        "        monge_line.set_stroke(WHITE, 3)\n",
        "        monge_line.suspend_updating()\n",
        "\n",
        "        self.play(GrowFromCenter(monge_line))\n",
        "        self.wait()\n",
        "\n",
        "        # Manipulate again\n",
        "        monge_line.resume_updating()\n",
        "        self.add(*circles)\n",
        "        self.wait(30, note=\"Play with circle positions. Be careful!\")\n",
        "        self.play(Restore(circles), self.frame.animate.to_default_state(), run_time=3)\n",
        "\n",
        "        dependents.suspend_updating()\n",
        "        self.play(FadeOut(monge_line))\n",
        "        self.wait()\n",
        "\n",
        "        # Setup spheres and tangent groups\n",
        "        plane = NumberPlane((-8, 8), (-8, 8))\n",
        "        plane.background_lines.set_stroke(GREY, 1)\n",
        "        plane.faded_lines.set_stroke(GREY, 1, 0.25)\n",
        "        plane.axes.set_stroke(GREY, 1)\n",
        "\n",
        "        spheres = self.get_spheres(circles)\n",
        "        tangent_groups = always_redraw(lambda: self.get_tangent_groups(circles))\n",
        "\n",
        "        tangent_groups.suspend_updating()\n",
        "\n",
        "        # Show spheres\n",
        "        frame = self.frame\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-11, 69, 0),\n",
        "            FadeIn(plane),\n",
        "            FadeIn(spheres, lag_ratio=0.25),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reposition\n",
        "        self.play(self.frame.animate.reorient(-41, 72, 0), run_time=5)\n",
        "\n",
        "        # Show various external tangents\n",
        "        self.play(\n",
        "            frame.animate.reorient(-67, 76, 0),\n",
        "            LaggedStartMap(GrowFromCenter, tangent_groups[2], lag_ratio=0.1),\n",
        "            spheres[0].animate.set_opacity(0.05),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(10, note=\"Emphasize how it's formed\")\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-105, 46, 0),\n",
        "            LaggedStartMap(GrowFromCenter, tangent_groups[1], lag_ratio=0.1),\n",
        "            spheres[0].animate.set_opacity(0.5),\n",
        "            spheres[1].animate.set_opacity(0.05),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-175, 51, 0, (1.2, 0.92, -0.26)),\n",
        "            LaggedStartMap(GrowFromCenter, tangent_groups[0], lag_ratio=0.1),\n",
        "            spheres[1].animate.set_opacity(0.5),\n",
        "            spheres[2].animate.set_opacity(0.05),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-70, 59, 0, (0.22, 0.32, -1.5), 9.17),\n",
        "            spheres[2].animate.set_opacity(0.5),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show mutually tangent plane (Fudged, but it works)\n",
        "        xy_plane = Square3D(resolution=(100, 100)).rotate(PI)\n",
        "        xy_plane.set_color(BLUE_E, 0.35)\n",
        "        xy_plane.replace(plane)\n",
        "\n",
        "        inter_points = [dot.get_center() for dot in intersection_dots]\n",
        "        blue_tip = self.get_cone_tips(circles[2:], angle=84 * DEGREES)[0]\n",
        "        tangent_plane = self.get_plane_through_points([inter_points[2], inter_points[0], blue_tip])\n",
        "\n",
        "        plane_lines = VGroup(\n",
        "            tangent_groups[2][19].copy(),\n",
        "            tangent_groups[0][31].copy(),\n",
        "            tangent_groups[1][25].copy(),\n",
        "        )\n",
        "        plane_lines.set_stroke(width=4, opacity=1)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-50, 74, 0, (0.22, 0.32, -1.5), 9.17),\n",
        "            ShowCreation(tangent_plane, time_span=(0, 2)),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-77, 63, 0, (0.22, 0.32, -1.5), 9.17),\n",
        "            FadeOut(tangent_groups),\n",
        "            run_time=4\n",
        "        )\n",
        "        for line in plane_lines:\n",
        "            self.play(ShowCreation(line, run_time=2))\n",
        "            self.wait()\n",
        "\n",
        "        self.add(xy_plane, tangent_plane, plane_lines)\n",
        "        self.play(ShowCreation(xy_plane, time_span=(0, 2)))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(monge_line, suspend_mobject_updating=True))\n",
        "        self.wait()\n",
        "\n",
        "        # Move circles to problem position\n",
        "        self.play(\n",
        "            FadeOut(xy_plane),\n",
        "            FadeOut(tangent_plane),\n",
        "            FadeOut(plane_lines),\n",
        "            self.frame.animate.to_default_state(),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        dependents.resume_updating()\n",
        "        self.add(dependents)\n",
        "        self.play(\n",
        "            circles[1].animate.move_to(2 * LEFT),\n",
        "            circles[0].animate.move_to(0.2 * UP),\n",
        "            circles[2].animate.move_to(3 * RIGHT),\n",
        "            run_time=3\n",
        "        )\n",
        "        dependents.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "        # Show the outside plane\n",
        "        angle = abs(tangent_pairs[2][0].get_angle())\n",
        "        partial_tangent_plane = xy_plane.copy()\n",
        "        pivot_point = intersection_dots[2].get_center()\n",
        "        partial_tangent_plane.rotate(angle, axis=DOWN, about_point=pivot_point)\n",
        "        partial_tangent_plane.set_height(5, stretch=True)\n",
        "        partial_tangent_plane.set_color(GREY_C, 0.5)\n",
        "        partial_tangent_plane.set_shading(0.25, 0.25, 0.25)\n",
        "\n",
        "        self.add(partial_tangent_plane)\n",
        "        self.play(ShowCreation(partial_tangent_plane))\n",
        "        self.wait()\n",
        "        self.play(self.frame.animate.reorient(27, 75, 0))\n",
        "        self.play(\n",
        "            Rotating(partial_tangent_plane, PI / 2, axis=RIGHT, about_point=pivot_point),\n",
        "            run_time=8,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(partial_tangent_plane),\n",
        "            self.frame.animate.to_default_state(),\n",
        "            run_time=3\n",
        "        )\n",
        "        dependents.resume_updating()\n",
        "        self.add(dependents)\n",
        "        self.play(circles[0].animate.move_to(2 * UP), run_time=3)\n",
        "        dependents.suspend_updating()\n",
        "\n",
        "        # Show the cones\n",
        "        cones = self.get_cones(circles)\n",
        "\n",
        "        def upadte_cone_positions(cones):\n",
        "            for cone, circle in zip(cones, circles):\n",
        "                cone.match_width(circle)\n",
        "                cone.move_to(circle, IN)\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-74, 72, 0, (-1.2, 0.14, -0.2), 8.00),\n",
        "            run_time=3\n",
        "        )\n",
        "        spheres.clear_updaters()\n",
        "        self.play(ReplacementTransform(spheres, cones, lag_ratio=0.5, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the center of similarity\n",
        "        def get_tip_lines():\n",
        "            result = VGroup()\n",
        "            for i, j, k in [(2, 2, 2), (1, 2, 1), (0, 1, 0)]:\n",
        "                line = Line(intersection_dots[i].get_center(), cones[j].get_zenith())\n",
        "                line.match_color(tangent_pairs[k][0])\n",
        "                line.scale(2, about_point=line.get_start())\n",
        "                result.add(line)\n",
        "            return result\n",
        "        tip_lines = always_redraw(get_tip_lines)\n",
        "        tip_lines.suspend_updating()\n",
        "\n",
        "        self.play(ShowCreation(tip_lines[0]))\n",
        "        self.play(self.frame.animate.reorient(-1, 83, 0, (-1.2, 0.14, -0.2)), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        cone_ghost = cones[2].copy().set_opacity(0.5)\n",
        "        cone_ghost.deactivate_depth_test()\n",
        "        self.add(cones, cone_ghost)\n",
        "        self.play(FadeIn(cone_ghost))\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                cone_ghost.animate.scale(1e-2, about_point=intersection_dots[2].get_center()),\n",
        "                run_time=8,\n",
        "                rate_func=there_and_back\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(self.frame.animate.reorient(0, 7, 0, (-1.92, 0.22, 0.0)), run_time=3)\n",
        "        self.play(\n",
        "            FadeOut(cone_ghost),\n",
        "            self.frame.animate.reorient(-129, 75, 0, (-1.92, 0.22, 0.0)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(ShowCreation(tip_lines[1:], lag_ratio=0.5, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Add plane\n",
        "        plane = always_redraw(lambda: self.get_plane_through_points([\n",
        "            intersection_dots[2].get_center(),\n",
        "            intersection_dots[0].get_center(),\n",
        "            cones[2].get_zenith()\n",
        "        ]))\n",
        "        plane.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(plane),\n",
        "            self.frame.animate.reorient(-74, 66, 0, (-1.92, 0.22, 0.0)),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Move the circles all about\n",
        "        dependents.add(tip_lines, plane)\n",
        "        dependents.resume_updating()\n",
        "        cones.add_updater(upadte_cone_positions)\n",
        "        self.add(cones, dependents)\n",
        "\n",
        "        self.play(circles[0].animate.move_to(0.2 * UP), run_time=3)\n",
        "        dependents.suspend_updating()\n",
        "        self.play(self.frame.animate.reorient(-173, 69, 0, (-1.36, 0.7, 1.01), 7.14), run_time=10)\n",
        "        self.wait(note=\"Reorient\")\n",
        "        dependents.resume_updating()\n",
        "        self.play(\n",
        "            circles[0].animate.move_to(2 * UP),\n",
        "            self.frame.animate.reorient(-122, 54, 0, (-1.54, 0.75, 0.38), 8.65),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.manipulate_circle_positions(circles)\n",
        "        dependents.suspend_updating()\n",
        "\n",
        "    def get_initial_circles(self):\n",
        "        centers = [[-3, 3, 0], [-6, -1.5, 0], [3, -1.5, 0]]\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "        radii = [1, 2, 4]\n",
        "        circles = VGroup(\n",
        "            Circle(radius=radius).move_to(center).set_color(color)\n",
        "            for radius, center, color in zip(radii, centers, colors)\n",
        "        )\n",
        "        circles.scale(0.5)\n",
        "        circles.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        return circles\n",
        "\n",
        "    def get_plane_through_points(self, points, color=GREY_B, opacity=0.5):\n",
        "        v1 = points[1] - points[0]\n",
        "        v2 = points[2] - points[0]\n",
        "        perp = normalize(cross(v2, v1))\n",
        "        vert_angle = math.acos(perp[2])\n",
        "\n",
        "        plane = Square3D(resolution=(100, 100))\n",
        "        plane.set_width(get_norm(v1))\n",
        "        plane.move_to(ORIGIN, DL)\n",
        "        plane.rotate(angle_of_vector(v1), about_point=ORIGIN)\n",
        "        plane.rotate(PI - vert_angle, axis=v1, about_point=ORIGIN)\n",
        "        plane.shift(points[0])\n",
        "        plane.scale(2, about_point=points[0])\n",
        "\n",
        "        plane.set_color(color, opacity=opacity)\n",
        "\n",
        "        return plane\n",
        "\n",
        "    def get_cones(self, circles, angle=90 * DEGREES):\n",
        "        cones = Group()\n",
        "        for circle in circles:\n",
        "            radius = circle.get_width() / 2\n",
        "            cone = Cone(radius=radius, height=radius / math.tan(angle / 2))\n",
        "            cone.move_to(circle, IN)\n",
        "            cone.set_color(circle.get_color())\n",
        "            cone.set_opacity(0.5)\n",
        "            cone.always_sort_to_camera(self.camera)\n",
        "            cones.add(cone)\n",
        "        return cones\n",
        "\n",
        "    def get_cone_tips(self, circles, angle=90 * DEGREES):\n",
        "        points = []\n",
        "        for circle in circles:\n",
        "            radius = circle.get_width() / 2\n",
        "            height = radius / math.tan(angle / 2)\n",
        "            point = circle.get_center() + height * OUT\n",
        "            points.append(point)\n",
        "        return points\n",
        "\n",
        "    def get_spheres(self, circles, opacity=0.5):\n",
        "        spheres = Group()\n",
        "        for circle in circles:\n",
        "            sphere = Sphere(radius=circle.get_radius())\n",
        "            sphere.set_color(circle.get_color(), opacity)\n",
        "            sphere.circle = circle\n",
        "            sphere.always_sort_to_camera(self.camera)\n",
        "            sphere.always.match_width(circle)\n",
        "            sphere.always.move_to(circle)\n",
        "            spheres.add(sphere)\n",
        "        return spheres\n",
        "\n",
        "    def get_tangent_groups(self, circles, n_lines=24):\n",
        "        tangent_groups = VGroup()\n",
        "        for circ1, circ2 in it.combinations(circles, 2):\n",
        "            tangent_pair = self.get_external_tangents(circ1, circ2)\n",
        "            point = self.get_intersection(*tangent_pair)\n",
        "            axis = circ2.get_center() - circ1.get_center()\n",
        "            group = VGroup()\n",
        "            for angle in np.arange(0, PI, PI / n_lines):\n",
        "                group.add(*tangent_pair.copy().rotate(angle, axis=axis, about_point=point))\n",
        "            for line in group:\n",
        "                line.shift(point - line.get_start())\n",
        "            group.set_stroke(width=1, opacity=0.5)\n",
        "            tangent_groups.add(group)\n",
        "        return tangent_groups\n",
        "\n",
        "    def get_all_intersection_dots(self, line_pairs):\n",
        "        return Group(\n",
        "            GlowDot(self.get_intersection(*pair))\n",
        "            for pair in line_pairs\n",
        "        )\n",
        "\n",
        "    def get_all_external_tangents(self, circles, **kwargs):\n",
        "        return VGroup(\n",
        "            self.get_external_tangents(circ1, circ2)\n",
        "            for circ1, circ2 in it.combinations(circles, 2)\n",
        "        )\n",
        "\n",
        "    def get_external_tangents(self, circle1, circle2, length=100, color=None):\n",
        "        c1 = circle1.get_center()\n",
        "        c2 = circle2.get_center()\n",
        "        r1 = circle1.get_radius()\n",
        "        r2 = circle2.get_radius()\n",
        "\n",
        "        if get_norm(c1 - c2) <= max(r1, r2):\n",
        "            return VectorizedPoint().replicate(2)\n",
        "\n",
        "        # Distance to intersection of external tangents\n",
        "        L1 = get_norm(c1 - c2) / (1 - r2 / r1)\n",
        "        intersection = c1 + L1 * normalize(c2 - c1)\n",
        "        theta = math.asin(r1 / L1)\n",
        "\n",
        "        line1 = Line(c1, c2)\n",
        "        line1.insert_n_curves(20)\n",
        "        line1.rotate(theta, about_point=intersection)\n",
        "        line1.set_length(length)\n",
        "        line2 = line1.copy().rotate(PI, axis=(c2 - c1), about_point=intersection)\n",
        "\n",
        "        result = VGroup(line1, line2)\n",
        "        if color is None:\n",
        "            color = interpolate_color(circle1.get_color(), circle2.get_color(), 0.5)\n",
        "        result.set_stroke(color, width=2)\n",
        "        return result\n",
        "\n",
        "    def get_intersection(self, line1, line2):\n",
        "        try:\n",
        "            return line_intersection(\n",
        "                line1.get_start_and_end(),\n",
        "                line2.get_start_and_end(),\n",
        "            )\n",
        "        except Exception:\n",
        "            return midpoint(line1.get_end(), line2.get_end())\n",
        "\n",
        "    def manipulate_circle_positions(self, circles):\n",
        "        circ1, circ2, circ3 = circles\n",
        "        # Example\n",
        "        self.play(circ2.animate.shift(LEFT), run_time=2)\n",
        "        self.play(circ2.animate.scale(0.75), run_time=2)\n",
        "        self.play(circ1.animate.scale(0.5).shift(0.2 * DOWN), run_time=2)\n",
        "        self.play(circ3.animate.scale(0.7).shift(0.2 * DOWN), run_time=4)\n",
        "        self.wait()\n",
        "        self.play(Restore(circles), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GeneralCentersOfSimilarity(MongesTheorem):\n",
        "    def construct(self):\n",
        "        # Show centers of similarity\n",
        "        circles = self.get_initial_circles()\n",
        "        cos_dots = always_redraw(lambda: self.get_center_of_similarity_dots(circles))\n",
        "        similarity_lines = always_redraw(lambda: self.get_all_similarity_lines(circles))\n",
        "        theorem_line = Line().set_stroke(WHITE, 2).insert_n_curves(20)\n",
        "        theorem_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            cos_dots[0].get_center(), cos_dots[2].get_center()\n",
        "        ).scale(100))\n",
        "        labels = VGroup()\n",
        "\n",
        "        self.add(circles)\n",
        "        for lines, dot, pair in zip(similarity_lines, cos_dots, it.combinations(circles, 2)):\n",
        "            bigger = pair[0] if pair[0].get_width() > pair[1].get_width() else pair[1]\n",
        "            ghost = bigger.copy()\n",
        "            label = Text(\"Center of similarity\", font_size=36)\n",
        "            label.next_to(dot, DL, SMALL_BUFF)\n",
        "            label.shift_onto_screen()\n",
        "            self.play(\n",
        "                ghost.animate.scale(0, about_point=dot.get_center()),\n",
        "                ShowCreation(lines, lag_ratio=0),\n",
        "                FadeIn(dot),\n",
        "                FadeIn(label)\n",
        "            )\n",
        "            self.remove(ghost)\n",
        "            self.wait()\n",
        "            labels.add(label)\n",
        "\n",
        "        theorem_line.update()\n",
        "        theorem_line.suspend_updating()\n",
        "        self.play(\n",
        "            FadeOut(labels),\n",
        "            GrowFromCenter(theorem_line)\n",
        "        )\n",
        "        theorem_line.resume_updating()\n",
        "        self.add(cos_dots)\n",
        "        self.add(similarity_lines)\n",
        "        self.add(theorem_line)\n",
        "        self.add(*circles)\n",
        "\n",
        "        # Play around\n",
        "        self.wait(20, note=\"Play!\")\n",
        "\n",
        "        # Change shapes\n",
        "        pis = VGroup(\n",
        "            Tex(R\"\\pi\")[0].match_style(circle).replace(circle)\n",
        "            for circle in circles\n",
        "        )\n",
        "\n",
        "        self.play(Transform(circles, pis, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "        self.add(*circles)\n",
        "\n",
        "        # Play some more\n",
        "        self.wait(15, note=\"Play!\")\n",
        "\n",
        "        # Show the cones\n",
        "        frame = self.frame\n",
        "        cones = VGroup(self.get_cone(shape) for shape in circles)\n",
        "        cones.set_stroke(opacity=0.75)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeIn(cone, lag_ratio=0.05)\n",
        "                for cone in cones),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            frame.animate.reorient(16, 70, 0),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "    def get_center_of_similarity_dots(self, shapes):\n",
        "        return Group(\n",
        "            GlowDot(self.get_center_of_similarity(*pair))\n",
        "            for pair in it.combinations(shapes, 2)\n",
        "        )\n",
        "\n",
        "    def get_center_of_similarity(self, shape1, shape2):\n",
        "        w1 = shape1.get_width()\n",
        "        w2 = shape2.get_width()\n",
        "        c1 = shape1.get_center()\n",
        "        c2 = shape2.get_center()\n",
        "\n",
        "        vect = c2 - c1\n",
        "        dist = get_norm(vect)\n",
        "        # Desired ratio: (x - dist) / x = w2 / w1\n",
        "        # -------------> x - dist = x (w2 / w1)\n",
        "        # -------------> x (1 - w2 / w1) = dist\n",
        "        # -------------> result = c1 + x * (vect / dist)\n",
        "        return c1 + vect / (1.0 - w2 / w1)\n",
        "\n",
        "    def get_all_similarity_lines(self, shapes, **kwargs):\n",
        "        return VGroup(\n",
        "            self.get_similarity_lines(*pair, **kwargs)\n",
        "            for pair in it.combinations(shapes, 2)\n",
        "        )\n",
        "\n",
        "    def get_similarity_lines(self, shape1, shape2, n_lines=25):\n",
        "        point = self.get_center_of_similarity(shape1, shape2)\n",
        "        big = shape1 if shape1.get_width() > shape2.get_width() else shape2\n",
        "        color = interpolate_color(shape1.get_color(), shape2.get_color(), 0.5)\n",
        "\n",
        "        if big.get_num_points() == 0:\n",
        "            return VGroup()\n",
        "\n",
        "        result = VGroup(\n",
        "            Line(big.pfp(alpha), point)\n",
        "            for alpha in np.linspace(0, 1, n_lines)\n",
        "        )\n",
        "        result.set_stroke(color, 1, 0.5)\n",
        "        return result\n",
        "\n",
        "    def get_cone(self, shape):\n",
        "        top_z = 0.5 * shape.get_width()\n",
        "        return VGroup(\n",
        "            shape.copy().scale(a).set_z(z).set_stroke(width=1)\n",
        "            for a, z in zip(np.linspace(1, 0), np.linspace(0, top_z))\n",
        "        )\n",
        "\n",
        "\n",
        "class SimilarDiagrams(MongesTheorem):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        circle1, circle2 = circles = VGroup(\n",
        "            Circle(radius=1).move_to(LEFT).set_color(GREEN),\n",
        "            Circle(radius=2).move_to(4 * RIGHT).set_color(BLUE),\n",
        "        )\n",
        "        lines = self.get_external_tangents(*circles)\n",
        "        int_point = self.get_intersection(*lines)\n",
        "\n",
        "        angle = lines[0].get_angle()\n",
        "        t_point1 = circle1.get_center() + rotate_vector(UP, -angle)\n",
        "        t_point2 = t_point1.copy()\n",
        "        t_point2[1] *= -1\n",
        "        t_points = [t_point1, t_point2]\n",
        "        radii = VGroup(\n",
        "            Line(circle1.get_center(), t_point)\n",
        "            for t_point in t_points\n",
        "        )\n",
        "        elbows = VGroup(\n",
        "            Elbow(width=0.1).rotate(PI - angle, about_point=ORIGIN).shift(t_point1),\n",
        "            Elbow(width=0.1).rotate(-1.5 * PI + angle, about_point=ORIGIN).shift(t_point2),\n",
        "        )\n",
        "        elbows.set_stroke(width=2)\n",
        "        tangents = VGroup(Line(t_point, int_point) for t_point in t_points)\n",
        "        tangents.set_color(TEAL)\n",
        "\n",
        "        self.add(circle1, radii, tangents, elbows)\n",
        "        self.wait()\n",
        "\n",
        "        self.add(radii.copy(), elbows.copy())\n",
        "        self.play(\n",
        "            TransformFromCopy(circle1, circle2),\n",
        "            VGroup(tangents, radii, elbows).animate.scale(2, about_point=int_point),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutVolumeOfParallelpiped(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes and plane\n",
        "        frame = self.frame\n",
        "        axes = ThreeDAxes((-8, 8), (-4, 4), (-4, 4))\n",
        "        axes.set_stroke(WHITE, 2)\n",
        "        plane = NumberPlane()\n",
        "        frame.reorient(-43, 73, 0, (1.18, 0.21, 1.19), 5.96)\n",
        "        self.add(plane, axes)\n",
        "\n",
        "        # Tetrahedron\n",
        "        verts = [\n",
        "            (-2, 1, 1),\n",
        "            (1, 0, 3),\n",
        "            (3, 0, 0),\n",
        "            (2, -2, 0),\n",
        "        ]\n",
        "        tetrahedron = VGroup(\n",
        "            Polygon(*subset)\n",
        "            for subset in it.combinations(verts, 3)\n",
        "        )\n",
        "        tetrahedron.set_stroke(WHITE, 1)\n",
        "        tetrahedron.set_fill(TEAL_E, 0.5)\n",
        "        tetrahedron.set_shading(0.5, 0.5, 0)\n",
        "        dots = DotCloud(verts, radius=0.05)\n",
        "        dots.make_3d()\n",
        "        dots.set_color(WHITE)\n",
        "\n",
        "        self.add(tetrahedron)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Add vertex labels\n",
        "        labels = VGroup(\n",
        "            Tex(f\"(x_{n}, y_{n}, z_{n})\", font_size=36)\n",
        "            for n in range(1, 5)\n",
        "        )\n",
        "        vects = [OUT + LEFT, OUT, OUT + RIGHT, OUT + RIGHT]\n",
        "        for label, point, vect in zip(labels, dots.get_points(), vects):\n",
        "            label.rotate(89 * DEGREES, RIGHT)\n",
        "            label.next_to(point, vect, buff=SMALL_BUFF)\n",
        "\n",
        "        frame.reorient(-33, 84, 0, (0.34, 0.8, 1.42), 7.12)\n",
        "        frame.add_updater(lambda m: m.set_theta(-math.cos(7 * self.time * DEGREES) * 35 * DEGREES))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, labels, shift=0.5 * OUT, lag_ratio=0.5, run_time=3))\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class TriangleAreaFormula(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up triangle\n",
        "        plane = NumberPlane(faded_line_ratio=1)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "        plane.background_lines.set_stroke(opacity=0.75)\n",
        "        plane.faded_lines.set_stroke(opacity=0.25)\n",
        "        verts = [\n",
        "            (1, 1, 0),\n",
        "            (2, -1, 0),\n",
        "            (3, 2, 0),\n",
        "        ]\n",
        "        triangle = Polygon(*verts)\n",
        "        triangle.set_stroke(YELLOW, 3)\n",
        "        dots = Group(TrueDot(vert, radius=0.1) for vert in verts)\n",
        "        dots.set_color(WHITE)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(triangle)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Add labels\n",
        "        labels = VGroup(\n",
        "            Tex(Rf\"(x_{n}, y_{n})\", font_size=36)\n",
        "            for n in [1, 2, 3]\n",
        "        )\n",
        "        labels.set_backstroke(BLACK, 3)\n",
        "        for label, dot, vect in zip(labels, dots, [UP, DOWN, UP]):\n",
        "            label.next_to(dot, vect, SMALL_BUFF)\n",
        "        labels[0].shift(0.3 * LEFT)\n",
        "\n",
        "        self.frame.reorient(0, 0, 0, (2.02, 0.72, 0.0), 4.49),\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, labels, shift=0.25 * UP, lag_ratio=0.5, run_time=2),\n",
        "            self.frame.animate.to_default_state().set_anim_args(run_time=6),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(triangle.animate.set_fill(YELLOW, 0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Set up 3D labels\n",
        "        labels_3d = VGroup(\n",
        "            Tex(Rf\"(x_{n}, y_{n}, 1)\", font_size=36)\n",
        "            for n in [1, 2, 3]\n",
        "        )\n",
        "        for label, dot, vect in zip(labels_3d, dots, [LEFT, UR, RIGHT]):\n",
        "            label.rotate(89 * DEGREES, RIGHT)\n",
        "            label.next_to(dot, vect + OUT, SMALL_BUFF)\n",
        "            label.shift(OUT)\n",
        "\n",
        "        # Move up to 3d\n",
        "        frame = self.frame\n",
        "        z_axis = NumberLine((-4, 4))\n",
        "        z_axis.rotate(PI / 2, DOWN)\n",
        "        z_axis.set_flat_stroke(False)\n",
        "        ghost_plane = plane.copy()\n",
        "        ghost_plane.fade(0.5)\n",
        "        ghost_plane.shift(OUT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-13, 75, 0, (-0.14, 0.7, 1.48), 9.34).set_anim_args(run_time=2),\n",
        "            FadeIn(z_axis),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(15, 81, 0, (-0.56, 0.95, 1.43), 9.34).set_anim_args(run_time=8),\n",
        "            TransformFromCopy(plane, ghost_plane),\n",
        "            triangle.animate.shift(OUT),\n",
        "            Transform(labels, labels_3d),\n",
        "            *(\n",
        "                dot.animate.shift(OUT).make_3d()\n",
        "                for dot in dots\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show parallelpiped\n",
        "        cube = VCube(side_length=1)\n",
        "        cube.set_stroke(WHITE, 2)\n",
        "        cube.set_fill(WHITE, 0.1)\n",
        "        cube.deactivate_depth_test()\n",
        "        cube.move_to(ORIGIN, [-1, -1, -1])\n",
        "        cube.apply_matrix(np.transpose([\n",
        "            dot.get_center()\n",
        "            for dot in dots\n",
        "        ]))\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-5, 63, 0, (-0.04, 0.69, 0.39), 7.73).set_anim_args(run_time=5),\n",
        "            Write(cube),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show tetrehedron\n",
        "        tetrahedron = VGroup(\n",
        "            triangle.copy(),\n",
        "            Polygon(ORIGIN, dots[0].get_center(), dots[1].get_center()),\n",
        "            Polygon(ORIGIN, dots[0].get_center(), dots[2].get_center()),\n",
        "            Polygon(ORIGIN, dots[1].get_center(), dots[2].get_center()),\n",
        "        )\n",
        "        tetrahedron.set_stroke(width=0)\n",
        "        tetrahedron.set_fill(YELLOW, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-4, 77, 0, (0.28, 0.78, 0.41), 7.73).set_anim_args(run_time=4),\n",
        "            Write(tetrahedron)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-5, 64, 0, (0.22, 0.72, -0.04), 7.14),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LogicForArea(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        det_tex = Tex(R\"\"\"\n",
        "            = \\frac{1}{2}\\det\\left[\\begin{array}{ccc}\n",
        "            x_1 & x_2 & x_3 \\\\\n",
        "            y_1 & y_2 & y_3 \\\\\n",
        "            1 & 1 & 1\n",
        "            \\end{array}\\right]\n",
        "        \"\"\")\n",
        "        equations = VGroup(\n",
        "            TexText(R\"Volume(Tetra.) = $\\frac{1}{3}$ Area(Tri.) $\\times 1$\"),\n",
        "            TexText(R\"Volume(Tetra.) = $\\frac{1}{6}$ Volume(Para.)\"),\n",
        "            Tex(R\"\\Downarrow\"),\n",
        "            TexText(R\"Area(Tri.) = $\\frac{1}{2}$ Volume(Para.)\"),\n",
        "        )\n",
        "        for eq in [det_tex, *equations]:\n",
        "            eq[\"Tetra.\"].set_color(YELLOW)\n",
        "            eq[\"Tri.\"].set_color(YELLOW)\n",
        "            eq[\"Para.\"].set_color(YELLOW)\n",
        "\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        equations.to_corner(UL)\n",
        "        equations[2].scale(2)\n",
        "        det_tex.next_to(equations[-1][\"=\"], DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.frame.set_height(10)\n",
        "        self.add(det_tex)\n",
        "        self.add(equations)\n",
        "\n",
        "\n",
        "class FourDDet(InteractiveScene):\n",
        "    def construct(self):\n",
        "        det_tex = Tex(R\"\"\"\n",
        "            \\frac{1}{6}\\det\\left[\\begin{array}{cccc}\n",
        "            x_1 & x_2 & x_3 & x_4 \\\\\n",
        "            y_1 & y_2 & y_3 & y_4 \\\\\n",
        "            z_1 & z_2 & z_3 & z_4 \\\\\n",
        "            1 & 1 & 1 & 1\n",
        "            \\end{array}\\right]\n",
        "        \"\"\")\n",
        "        group = VGroup(\n",
        "            Text(\"Volume\", font_size=72),\n",
        "            Tex(\"=\", font_size=72).rotate(90 * DEGREES),\n",
        "            det_tex\n",
        "        )\n",
        "        group.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        self.add(group)\n",
        "\n",
        "\n",
        "class RandomVectorStatistics(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show 2d distribution\n",
        "        chart = self.get_random_angle_data_histogram(2, step_size=2)\n",
        "\n",
        "        label = VGroup(Integer(2, edge_to_fix=UR), Text(\"D\"))\n",
        "        label.arrange(RIGHT, buff=0.05)\n",
        "        label.next_to(chart.get_corner(UL), DR)\n",
        "        label.shift(RIGHT)\n",
        "\n",
        "        self.add(label)\n",
        "        self.add(chart)\n",
        "\n",
        "        # Many random vectors\n",
        "        center = chart.get_center() + 0.5 * UP\n",
        "        for _ in range(0):\n",
        "            vects = VGroup(\n",
        "                Vector(\n",
        "                    1.5 * rotate_vector(RIGHT, random.uniform(0, TAU)),\n",
        "                    thickness=4\n",
        "                ).set_fill(random_bright_color(), border_width=1)\n",
        "                for _ in range(2)\n",
        "            )\n",
        "            vects.shift(center)\n",
        "            angle = (vects[0].get_angle() - vects[1].get_angle()) % TAU\n",
        "            if angle > PI:\n",
        "                angle = TAU - angle\n",
        "\n",
        "            bar = chart.bars[int(angle / DEGREES) // 2].copy()\n",
        "            bar.set_color(YELLOW)\n",
        "\n",
        "            self.add(vects, bar)\n",
        "            self.wait(0.5)\n",
        "            self.remove(vects, bar)\n",
        "\n",
        "        # Animate an increase in charts\n",
        "        dim_tracker = ValueTracker(2)\n",
        "\n",
        "        def get_dim():\n",
        "            return int(dim_tracker.get_value())\n",
        "\n",
        "        label.add_updater(lambda m: m[0].set_value(get_dim()))\n",
        "\n",
        "        self.play(\n",
        "            dim_tracker.animate.set_value(1000).set_anim_args(rate_func=rush_into),\n",
        "            UpdateFromFunc(chart, lambda m: m.become(\n",
        "                self.get_random_angle_data_histogram(\n",
        "                    get_dim(),\n",
        "                    n_vects=50000000 // get_dim(),\n",
        "                    # n_vects=500000 // get_dim(),\n",
        "                    step_size=1 if get_dim() < 100 else 0.5\n",
        "                )\n",
        "            )),\n",
        "            run_time=20\n",
        "        )\n",
        "\n",
        "    def get_random_angle_data_histogram(self, dim, n_vects=1000000, step_size=1):\n",
        "        vects1, vects2 = all_vects = [np.random.normal(0, 1, (n_vects, dim)) for _ in range(2)]\n",
        "\n",
        "        for vects in all_vects:\n",
        "            norms = np.linalg.norm(vects, axis=1)\n",
        "            vects /= norms[:, np.newaxis]\n",
        "\n",
        "        angles = np.arccos((vects1 * vects2).sum(1)) / DEGREES\n",
        "\n",
        "        return self.get_histogram(angles, step_size=step_size)\n",
        "\n",
        "    def get_histogram(self, data, min_val=0, max_val=180, step_size=5, bar_color=BLUE_D):\n",
        "        bins = np.arange(min_val, max_val + 1, step_size)\n",
        "        bucket_counts, _ = np.histogram(data, bins=bins, range=(min_val, max_val))\n",
        "\n",
        "        bin_width = step_size / (max_val - min_val)\n",
        "        densities = (bucket_counts / bucket_counts.sum()) / (bin_width)\n",
        "\n",
        "        y_max = 16.0\n",
        "        if densities.max() > y_max:\n",
        "            densities *= (y_max / densities.max())**0.5\n",
        "\n",
        "        axes = Axes(\n",
        "            x_range=(min_val, max_val, 5),\n",
        "            y_range=(0, y_max, 2),  # TODO\n",
        "            width=6, height=4\n",
        "        )\n",
        "        axes.x_axis.add_numbers(np.arange(min_val, max_val + 1, 45), font_size=24, unit_tex=R\"^\\circ\")\n",
        "        x_unit = axes.x_axis.get_unit_size()\n",
        "        y_unit = axes.y_axis.get_unit_size()\n",
        "\n",
        "        bar_width = x_unit * step_size\n",
        "\n",
        "        bars = VGroup(\n",
        "            Rectangle(width=bar_width, height=density * y_unit).move_to(axes.c2p(x, 0), DL)\n",
        "            for x, density in zip(bins, densities)\n",
        "        )\n",
        "        bars.set_fill(bar_color, 1)\n",
        "        bars.set_stroke(WHITE, 0.5, 0.5)\n",
        "\n",
        "        chart = VGroup(axes, bars)\n",
        "        chart.axes = axes\n",
        "        chart.bars = bars\n",
        "        return chart\n",
        "\n",
        "\n",
        "class ProbabilityQuestion(InteractiveScene):\n",
        "    N = 6\n",
        "\n",
        "    def construct(self):\n",
        "        # Number lines and trackers\n",
        "        trackers = Group(ValueTracker(np.random.uniform(-1, 1)) for x in range(self.N))\n",
        "        lines = VGroup(\n",
        "            self.get_uniform_random_indicator(tracker, n)\n",
        "            for n, tracker in enumerate(trackers, start=1)\n",
        "        )\n",
        "        lines.arrange(DOWN, buff=0.35)\n",
        "        lines.to_corner(DL)\n",
        "\n",
        "        self.add(lines)\n",
        "\n",
        "        # Add x_i distribution label\n",
        "        dist_label = TexText(\"$x_i$ uniform in [-1, 1]\")\n",
        "        dist_label.match_x(lines).to_edge(UP)\n",
        "\n",
        "        self.add(dist_label)\n",
        "\n",
        "        # Add question label\n",
        "        # lhs = Tex(R\"P\\left(\\sum_{i=0}^7 x_i^2 \\le 1 \\right) = \")\n",
        "        lhs = Tex(R\"P\\left(x_1^2 + x_2^2 + x_3^2 + x_4^2 + x_5^2 + x_6^2 \\le 1 \\right)\")\n",
        "        rhs = Tex(R\"\\frac{\\pi^3}{6} \\cdot \\frac{1}{2^6}\")\n",
        "        eq = VGroup(lhs, Tex(\"=\").rotate(PI / 2), rhs)\n",
        "        eq.arrange(DOWN)\n",
        "        eq.center().to_edge(RIGHT)\n",
        "\n",
        "        self.add(eq)\n",
        "\n",
        "        # Add brace\n",
        "        def get_sum():\n",
        "            return sum(t.get_value()**2 for t in trackers)\n",
        "\n",
        "        brace = Brace(lhs[R\"x_1^2 + x_2^2 + x_3^2 + x_4^2 + x_5^2 + x_6^2\"], UP)\n",
        "        brace.set_color(BLUE_D)\n",
        "        sum_value = DecimalNumber()\n",
        "        sum_value.set_color(BLUE_D)\n",
        "        sum_value.next_to(brace, UP)\n",
        "        sum_value.f_always.set_value(get_sum)\n",
        "\n",
        "        symbols = VGroup(Checkmark().set_color(GREEN), Exmark().set_color(RED))\n",
        "        symbols.set_height(0.5)\n",
        "        symbols.match_x(lhs[\"1\"][-1]).align_to(sum_value, UP)\n",
        "\n",
        "        def update_symbols(syms):\n",
        "            if get_sum() < 1:\n",
        "                syms[0].set_opacity(1)\n",
        "                syms[1].set_opacity(0)\n",
        "            else:\n",
        "                syms[1].set_opacity(1)\n",
        "                syms[0].set_opacity(0)\n",
        "\n",
        "        symbols.add_updater(update_symbols)\n",
        "\n",
        "        self.add(brace, sum_value, symbols)\n",
        "\n",
        "        # Animate in 6D label\n",
        "        rect = SurroundingRectangle(rhs[R\"\\frac{\\pi^3}{6}\"])\n",
        "        rect.set_stroke(TEAL, 2)\n",
        "        label = Text(\"Volume of a \\n 6D unit ball\")\n",
        "        label.next_to(rect, DOWN)\n",
        "        label.set_color(TEAL)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "\n",
        "        # Go over many random values\n",
        "        time_per_state = 0.2\n",
        "        total_time = 25\n",
        "        for _ in range(int(total_time / time_per_state)):\n",
        "            for tracker in trackers:\n",
        "                tracker.set_value(np.random.uniform(-1, 1))\n",
        "            self.wait(time_per_state)\n",
        "\n",
        "\n",
        "    def get_uniform_random_indicator(self, value_tracker, n):\n",
        "        line = NumberLine((-1, 1, 0.1), width=4, big_tick_spacing=1, tick_size=0.05)\n",
        "        line.set_stroke(width=2)\n",
        "        line.add_numbers(\n",
        "            np.arange(-1, 1.5, 0.5),\n",
        "            font_size=12,\n",
        "            num_decimal_places=1,\n",
        "            buff=0.15\n",
        "        )\n",
        "\n",
        "        tip = ArrowTip(angle=-90 * DEGREES)\n",
        "        tip.set_height(0.15)\n",
        "        tip.set_fill(YELLOW, 1)\n",
        "        tip.add_updater(lambda m: m.move_to(line.n2p(value_tracker.get_value()), DOWN))\n",
        "        tip.add_updater(lambda m: m.set_fill(self.value_to_color(value_tracker.get_value())))\n",
        "\n",
        "        x_label = Tex(Rf\"x_{n}\", font_size=30)\n",
        "        x_label.always.next_to(tip, UP, buff=0.05)\n",
        "        x_label.always.match_color(tip)\n",
        "\n",
        "        return VGroup(line, tip, x_label)\n",
        "\n",
        "    def value_to_color(self, value):\n",
        "        return interpolate_color_by_hsl(\n",
        "            GREY_B,\n",
        "            BLUE if value > 0 else RED,\n",
        "            abs(value)\n",
        "        )\n",
        "\n",
        "\n",
        "class IntersectingCircles(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add circles\n",
        "        circles = Circle(radius=2).replicate(4)\n",
        "        circles.set_stroke(BLUE_B, 2)\n",
        "        circles[3].set_stroke(YELLOW, 3)\n",
        "        circles.tri_intersection = ORIGIN  # To change\n",
        "        circles.pair_intersections = np.zeros((3, 3))  # To change\n",
        "\n",
        "        vectors = [RIGHT, UL, DL]\n",
        "        vector_trackers = VGroup(VectorizedPoint(vect) for vect in vectors)\n",
        "\n",
        "        def update_circles(circles):\n",
        "            self.place_circles_by_vectors(\n",
        "                circles,\n",
        "                [vt.get_center() for vt in vector_trackers]\n",
        "            )\n",
        "\n",
        "        circles.add_updater(update_circles)\n",
        "\n",
        "        dots = GlowDots(circles.pair_intersections)\n",
        "        dots.set_color(WHITE)\n",
        "        dots.add_updater(lambda m: m.set_points(circles.pair_intersections))\n",
        "\n",
        "        circles[3].set_opacity(0)\n",
        "        self.play(LaggedStartMap(ShowCreation, circles, lag_ratio=0.7))\n",
        "        self.play(FadeIn(dots))\n",
        "        self.wait()\n",
        "        circles[3].set_stroke(opacity=1)\n",
        "        self.play(ShowCreation(circles[3]))\n",
        "        self.add(circles)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            vector_trackers[2].animate.move_to(LEFT + 0.5 * DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            vector_trackers[0].animate.move_to(RIGHT + 0.5 * DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            vector_trackers[0].animate.move_to(RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(circles[3].animate.set_opacity(0))\n",
        "        self.wait()\n",
        "\n",
        "        # Draw radial lines\n",
        "        centers = Dot(radius=0.05).replicate(3)\n",
        "        centers.set_color(WHITE)\n",
        "\n",
        "        def update_centers(centers):\n",
        "            for center, circle in zip(centers, circles):\n",
        "                center.move_to(circle)\n",
        "\n",
        "        centers.add_updater(update_centers)\n",
        "\n",
        "        radial_lines = self.get_radial_lines(circles, [vt.get_center() for vt in vector_trackers])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, circles[:3].copy(), lag_ratio=0.5, scale=0),\n",
        "            FadeIn(centers, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(radial_lines[:3], lag_ratio=0.75))\n",
        "        self.wait()\n",
        "        for i in range(3, 8, 2):\n",
        "            self.play(ShowCreation(radial_lines[i:i + 2], lag_ratio=0.5, run_time=1))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeTransform(radial_lines[i1].copy(), radial_lines[i2])\n",
        "                for i1, i2 in [(5, 9), (8, 10), (4, 11)]),\n",
        "                lag_ratio=0.75,\n",
        "                run_time=3\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Animate about\n",
        "        radial_lines.add_updater(lambda m: m.become(\n",
        "            self.get_radial_lines(circles, [vt.get_center() for vt in vector_trackers])\n",
        "        ))\n",
        "\n",
        "        self.add(circles, centers, radial_lines)\n",
        "        self.play(\n",
        "            vector_trackers[1].animate.move_to(UP),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            vector_trackers[1].animate.move_to(UL),\n",
        "            run_time=3\n",
        "        )\n",
        "        circles[3].set_stroke(opacity=1)\n",
        "        self.play(ShowCreation(circles[3]))\n",
        "        self.wait()\n",
        "\n",
        "    def place_circles_by_vectors(self, circles, vectors):\n",
        "        radius = circles[0].get_radius()\n",
        "        radial_vectors = np.array([radius * normalize(vect) for vect in vectors])\n",
        "        for circle, radial_vector in zip(circles, radial_vectors):\n",
        "            circle.move_to(radial_vector)\n",
        "        circles[3].move_to(sum(radial_vectors)),\n",
        "\n",
        "        circles.tri_intersection = ORIGIN\n",
        "        circles.pair_intersections = np.array([\n",
        "            sum(pair) for pair in it.combinations(list(radial_vectors[:3]), 2)\n",
        "        ])\n",
        "\n",
        "        return circles\n",
        "\n",
        "    def get_radial_lines(self, circles, vectors):\n",
        "        radius = circles[0].get_radius()\n",
        "        radial_vectors = np.array([radius * normalize(vect) for vect in vectors])\n",
        "\n",
        "        result = VGroup()\n",
        "        for vect in radial_vectors:\n",
        "            result.add(Line(ORIGIN, vect))\n",
        "        for v1 in radial_vectors:\n",
        "            for v2 in radial_vectors:\n",
        "                if np.all(v1 == v2):\n",
        "                    continue\n",
        "                result.add(Line(v1, v1 + v2))\n",
        "        total_sum = sum(radial_vectors)\n",
        "        for vect in radial_vectors:\n",
        "            result.add(DashedLine(total_sum - vect, total_sum))\n",
        "\n",
        "        result.set_stroke(WHITE, 2)\n",
        "        result[-3:].set_stroke(RED, 2)\n",
        "        return result\n",
        "\n",
        "\n",
        "class TriPod(MongesTheorem):\n",
        "    def construct(self):\n",
        "        # Initialize frame\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        axes = ThreeDAxes()\n",
        "        axes.set_stroke(width=1)\n",
        "\n",
        "        # Triangles\n",
        "        proj_point = 3 * UP\n",
        "        vects = [DOWN + 0.35 * LEFT + 0.5 * OUT, DOWN + 0.35 * RIGHT + 0.5 * OUT, DOWN + 0.5 * IN]\n",
        "        factors1 = [2.0, 1.0, 2.0]\n",
        "        factors2 = [4.5, 4.25, 4.0]\n",
        "        tri1, tri2 = tris = VGroup(\n",
        "            Polygon(*(proj_point + f * v for f, v in zip(factors, vects)))\n",
        "            for factors in [factors1, factors2]\n",
        "        )\n",
        "        tri1.set_stroke(BLUE, 3)\n",
        "        tri1.set_fill(BLUE, 0.5)\n",
        "        tri2.set_stroke(RED, 3)\n",
        "        tri2.set_fill(RED, 0.5)\n",
        "\n",
        "        self.add(tris)\n",
        "\n",
        "        # Labels\n",
        "        tri1_labels = VGroup(map(Tex, \"ABC\"))\n",
        "        tri2_labels = VGroup(map(Tex, [\"A'\", \"B'\", \"C'\"]))\n",
        "        tri_labels = VGroup(tri1_labels, tri2_labels)\n",
        "        tri_labels.scale(0.75)\n",
        "        for tri, labels in zip(tris, tri_labels):\n",
        "            center = tri.get_center()\n",
        "            for label, vert in zip(labels, tri.get_vertices()):\n",
        "                buff = normalize(vert - center)\n",
        "                label.move_to(vert + 0.45 * buff)\n",
        "        tri1_labels[2].scale(1.25).shift(0.15 * DR)\n",
        "        tri2_labels[2].scale(1.25).shift(0.2 * UR)\n",
        "\n",
        "        for labels in tri_labels:\n",
        "            self.play(LaggedStartMap(Write, labels, lag_ratio=0.5, run_time=2))\n",
        "            self.wait()\n",
        "\n",
        "        # Tripod legs\n",
        "        tripod_legs = VGroup(\n",
        "            Line(vert, proj_point)\n",
        "            for vert in tri2.get_vertices()\n",
        "        )\n",
        "        tripod_legs.set_stroke(WHITE, 1)\n",
        "        for line in tripod_legs:\n",
        "            line.scale(4)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, tripod_legs, lag_ratio=0.75, run_time=4),\n",
        "            VGroup(g[2] for g in tri_labels).animate.shift(0.1 * RIGHT).set_anim_args(time_span=(3, 4))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Intersections\n",
        "        v1 = tri1.get_vertices()\n",
        "        v2 = tri2.get_vertices()\n",
        "        side_pairs = VGroup(\n",
        "            VGroup(\n",
        "                Line(v1[i], v1[j]),\n",
        "                Line(v2[i], v2[j]),\n",
        "            )\n",
        "            for (i, j) in [(1, 0), (0, 2), (1, 2)]\n",
        "        )\n",
        "        for pair, color in zip(side_pairs, [PINK, YELLOW, TEAL]):\n",
        "            pair.set_stroke(color, 2)\n",
        "            for line in pair:\n",
        "                line.scale(20, about_point=line.get_start())\n",
        "\n",
        "        side_pairs[1].set_stroke(width=(2, 20))\n",
        "\n",
        "        int_dots = Group()\n",
        "        for pair in side_pairs:\n",
        "            point = self.get_intersection(*pair)\n",
        "            dot = GlowDot(point)\n",
        "            int_dots.add(dot)\n",
        "            self.play(\n",
        "                ShowCreation(pair, lag_ratio=0),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Add planes\n",
        "        planes = Group()\n",
        "        meshes = VGroup()\n",
        "        for tri in tris:\n",
        "            a, b, c = tri.get_vertices()\n",
        "            mat = np.array([\n",
        "                normalize(b - a),\n",
        "                normalize(c - a),\n",
        "                normalize(cross(b - a, c - a))\n",
        "            ]).T\n",
        "            plane = Square3D(side_length=50)\n",
        "            plane.apply_matrix(mat)\n",
        "            plane.shift(a)\n",
        "            plane.set_color(GREY_C, 0.25)\n",
        "            plane.set_shading(1, 0.5, 0.5)\n",
        "            planes.add(plane)\n",
        "\n",
        "            mesh = SurfaceMesh(plane, resolution=(101, 101))\n",
        "            meshes.add(mesh)\n",
        "\n",
        "        meshes.add(meshes[0].copy().shift(0.03 * DR))\n",
        "        meshes.set_stroke(WHITE, 0.5, 0.25)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(planes),\n",
        "            FadeIn(meshes)\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(math.sin(self.time / 10) * dt * 2 * DEGREES))\n",
        "        self.wait(10)\n"
    ]
}