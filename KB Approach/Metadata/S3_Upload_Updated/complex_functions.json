{
    "topic": "demonstrates the concept of complex numbers and their relationship with real numbers.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class GeneralizeToComplexFunctions(Scene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 10,\n",
        "            \"x_axis_config\": {\n",
        "                \"stroke_width\": 2,\n",
        "            },\n",
        "            \"y_min\": -2.5,\n",
        "            \"y_max\": 2.5,\n",
        "            \"y_axis_config\": {\n",
        "                \"tick_frequency\": 0.25,\n",
        "                \"unit_size\": 1.5,\n",
        "                \"include_tip\": False,\n",
        "                \"stroke_width\": 2,\n",
        "            },\n",
        "        },\n",
        "        \"complex_plane_config\": {\n",
        "            \"axis_config\": {\n",
        "                \"unit_size\": 2\n",
        "            }\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_cosine_wave()\n",
        "        self.transition_to_complex_plane()\n",
        "        self.add_rotating_vectors_making_cos()\n",
        "\n",
        "    def show_cosine_wave(self):\n",
        "        axes = Axes(**self.axes_config)\n",
        "        axes.shift(2 * LEFT - axes.c2p(0, 0))\n",
        "        y_axis = axes.y_axis\n",
        "        y_labels = y_axis.get_number_mobjects(\n",
        "            *range(-2, 3),\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        t_tracker.add_updater(lambda t, dt: t.increment_value(dt))\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def func(x):\n",
        "            return 2 * np.cos(x)\n",
        "\n",
        "        cos_x_max = 20\n",
        "        cos_wave = axes.get_graph(func, x_max=cos_x_max)\n",
        "        cos_wave.set_color(YELLOW)\n",
        "        shown_cos_wave = cos_wave.copy()\n",
        "        shown_cos_wave.add_updater(\n",
        "            lambda m: m.pointwise_become_partial(\n",
        "                cos_wave, 0,\n",
        "                np.clip(get_t() / cos_x_max, 0, 1),\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.set_color(PINK)\n",
        "        dot.add_updater(lambda d: d.move_to(\n",
        "            y_axis.n2p(func(get_t())),\n",
        "        ))\n",
        "\n",
        "        h_line = always_redraw(lambda: Line(\n",
        "            dot.get_right(),\n",
        "            shown_cos_wave.get_end(),\n",
        "            stroke_width=1,\n",
        "        ))\n",
        "\n",
        "        real_words = OldTexText(\n",
        "            \"Real number\\\\\\\\output\"\n",
        "        )\n",
        "        real_words.to_edge(LEFT)\n",
        "        real_words.shift(2 * UP)\n",
        "        real_arrow = Arrow()\n",
        "        real_arrow.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                real_words.get_corner(DR),\n",
        "                dot.get_center(),\n",
        "            ).scale(0.9),\n",
        "        )\n",
        "\n",
        "        self.add(t_tracker)\n",
        "        self.add(axes)\n",
        "        self.add(y_labels)\n",
        "        self.add(shown_cos_wave)\n",
        "        self.add(dot)\n",
        "        self.add(h_line)\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(real_words, RIGHT),\n",
        "            FadeIn(real_arrow),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        y_axis.generate_target()\n",
        "        y_axis.target.rotate(-90 * DEGREES)\n",
        "        y_axis.target.center()\n",
        "        y_axis.target.scale(2 / 1.5)\n",
        "        y_labels.generate_target()\n",
        "        for label in y_labels.target:\n",
        "            label.next_to(\n",
        "                y_axis.target.n2p(label.get_value()),\n",
        "                DOWN, MED_SMALL_BUFF,\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(shown_cos_wave),\n",
        "            FadeOut(axes.x_axis),\n",
        "            FadeOut(h_line),\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(y_axis),\n",
        "            MoveToTarget(y_labels),\n",
        "            real_words.shift, 2 * RIGHT + UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.y_axis = y_axis\n",
        "        self.y_labels = y_labels\n",
        "        self.real_words = real_words\n",
        "        self.real_arrow = real_arrow\n",
        "        self.dot = dot\n",
        "        self.t_tracker = t_tracker\n",
        "\n",
        "    def transition_to_complex_plane(self):\n",
        "        y_axis = self.y_axis\n",
        "        y_labels = self.y_labels\n",
        "\n",
        "        plane = self.get_complex_plane()\n",
        "        plane_words = plane.label\n",
        "\n",
        "        self.add(plane, *self.get_mobjects())\n",
        "        self.play(\n",
        "            FadeOut(y_labels),\n",
        "            FadeOut(y_axis),\n",
        "            ShowCreation(plane),\n",
        "        )\n",
        "        self.play(Write(plane_words))\n",
        "        self.wait()\n",
        "\n",
        "        self.plane = plane\n",
        "        self.plane_words = plane_words\n",
        "\n",
        "    def add_rotating_vectors_making_cos(self):\n",
        "        plane = self.plane\n",
        "        real_words = self.real_words\n",
        "        real_arrow = self.real_arrow\n",
        "        t_tracker = self.t_tracker\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        v1 = Vector(2 * RIGHT)\n",
        "        v2 = Vector(2 * RIGHT)\n",
        "        v1.set_color(BLUE)\n",
        "        v2.set_color(interpolate_color(GREY_BROWN, WHITE, 0.5))\n",
        "        v1.add_updater(\n",
        "            lambda v: v.set_angle(get_t())\n",
        "        )\n",
        "        v2.add_updater(\n",
        "            lambda v: v.set_angle(-get_t())\n",
        "        )\n",
        "        v1.add_updater(\n",
        "            lambda v: v.shift(plane.n2p(0) - v.get_start())\n",
        "        )\n",
        "        # Change?\n",
        "        v2.add_updater(\n",
        "            lambda v: v.shift(plane.n2p(0) - v.get_start())\n",
        "        )\n",
        "\n",
        "        ghost_v1 = v1.copy()\n",
        "        ghost_v1.set_opacity(0.5)\n",
        "        ghost_v1.add_updater(\n",
        "            lambda v: v.shift(\n",
        "                v2.get_end() - v.get_start()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        ghost_v2 = v2.copy()\n",
        "        ghost_v2.set_opacity(0.5)\n",
        "        ghost_v2.add_updater(\n",
        "            lambda v: v.shift(\n",
        "                v1.get_end() - v.get_start()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        circle = Circle(color=GREY_BROWN)\n",
        "        circle.set_stroke(width=1)\n",
        "        circle.set_width(2 * v1.get_length())\n",
        "        circle.move_to(plane.n2p(0))\n",
        "\n",
        "        formula = OldTex(\n",
        "            # \"\\\\cos(x) =\"\n",
        "            # \"{1 \\\\over 2}e^{ix} +\"\n",
        "            # \"{1 \\\\over 2}e^{-ix}\",\n",
        "            \"2\\\\cos(x) =\",\n",
        "            \"e^{ix}\", \"+\", \"e^{-ix}\",\n",
        "            tex_to_color_map={\n",
        "                \"e^{ix}\": v1.get_color(),\n",
        "                \"e^{-ix}\": v2.get_color(),\n",
        "            }\n",
        "        )\n",
        "        formula.next_to(ORIGIN, UP, buff=0.75)\n",
        "        # formula.add_background_rectangle()\n",
        "        formula.set_stroke(BLACK, 3, background=True)\n",
        "        formula.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        formula_brace = Brace(formula[1:], UP)\n",
        "        formula_words = formula_brace.get_text(\n",
        "            \"Sum of\\\\\\\\rotations\"\n",
        "        )\n",
        "        formula_words.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DL)\n",
        "        randy.look_at(formula)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(real_words),\n",
        "            FadeOut(real_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(v1),\n",
        "            FadeIn(v2),\n",
        "            FadeIn(circle),\n",
        "            FadeIn(ghost_v1),\n",
        "            FadeIn(ghost_v2),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(FadeInFromDown(formula))\n",
        "        self.play(\n",
        "            GrowFromCenter(formula_brace),\n",
        "            FadeIn(formula_words),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"pleading\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "        self.wait(20)\n",
        "\n",
        "    #\n",
        "    def get_complex_plane(self):\n",
        "        plane = ComplexPlane(**self.complex_plane_config)\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        plane.label = OldTexText(\"Complex plane\")\n",
        "        plane.label.scale(1.5)\n",
        "        plane.label.to_corner(UR, buff=MED_SMALL_BUFF)\n",
        "        return plane\n",
        "\n",
        "\n",
        "class ClarifyInputAndOutput(GeneralizeToComplexFunctions):\n",
        "    CONFIG = {\n",
        "        \"input_space_rect_config\": {\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 1,\n",
        "            \"fill_color\": GREY_E,\n",
        "            \"fill_opacity\": 1,\n",
        "            \"width\": 6,\n",
        "            \"height\": 2,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "\n",
        "        self.describe_input()\n",
        "        self.describe_output()\n",
        "\n",
        "    def setup_plane(self):\n",
        "        plane = self.get_complex_plane()\n",
        "        plane.sublabel = OldTexText(\"(Output space)\")\n",
        "        plane.sublabel.add_background_rectangle()\n",
        "        plane.sublabel.next_to(plane.label, DOWN)\n",
        "        self.add(plane, plane.label)\n",
        "        self.plane = plane\n",
        "\n",
        "    def setup_input_space(self):\n",
        "        rect = Rectangle(**self.input_space_rect_config)\n",
        "        rect.to_corner(UL, buff=SMALL_BUFF)\n",
        "\n",
        "        input_line = self.get_input_line(rect)\n",
        "        input_words = OldTexText(\"Input space\")\n",
        "        input_words.next_to(\n",
        "            rect.get_bottom(), UP,\n",
        "            SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.add(rect)\n",
        "        self.add(input_line)\n",
        "\n",
        "        self.input_rect = rect\n",
        "        self.input_line = input_line\n",
        "        self.input_words = input_words\n",
        "\n",
        "    def setup_input_trackers(self):\n",
        "        plane = self.plane\n",
        "        input_line = self.input_line\n",
        "        input_tracker = ValueTracker(0)\n",
        "        get_input = input_tracker.get_value\n",
        "\n",
        "        input_dot = Dot()\n",
        "        input_dot.set_color(PINK)\n",
        "        f_always(\n",
        "            input_dot.move_to,\n",
        "            lambda: input_line.n2p(get_input())\n",
        "        )\n",
        "\n",
        "        input_decimal = DecimalNumber()\n",
        "        input_decimal.scale(0.7)\n",
        "        always(input_decimal.next_to, input_dot, UP)\n",
        "        f_always(input_decimal.set_value, get_input)\n",
        "\n",
        "        path = self.get_path()\n",
        "\n",
        "        def get_output_point():\n",
        "            return path.point_from_proportion(\n",
        "                get_input()\n",
        "            )\n",
        "\n",
        "        output_dot = Dot()\n",
        "        output_dot.match_style(input_dot)\n",
        "        f_always(output_dot.move_to, get_output_point)\n",
        "\n",
        "        output_vector = Vector()\n",
        "        output_vector.set_color(WHITE)\n",
        "        output_vector.add_updater(\n",
        "            lambda v: v.put_start_and_end_on(\n",
        "                plane.n2p(0),\n",
        "                get_output_point()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        output_decimal = DecimalNumber()\n",
        "        output_decimal.scale(0.7)\n",
        "        always(output_decimal.next_to, output_dot, UR, SMALL_BUFF)\n",
        "        f_always(\n",
        "            output_decimal.set_value,\n",
        "            lambda: plane.p2n(get_output_point()),\n",
        "        )\n",
        "\n",
        "        self.input_tracker = input_tracker\n",
        "        self.input_dot = input_dot\n",
        "        self.input_decimal = input_decimal\n",
        "        self.path = path\n",
        "        self.output_dot = output_dot\n",
        "        self.output_vector = output_vector\n",
        "        self.output_decimal = output_decimal\n",
        "\n",
        "    def describe_input(self):\n",
        "        input_tracker = self.input_tracker\n",
        "\n",
        "        self.play(FadeIn(self.input_words, UP))\n",
        "        self.play(\n",
        "            FadeInFromLarge(self.input_dot),\n",
        "            FadeIn(self.input_decimal),\n",
        "        )\n",
        "        for value in 1, 0:\n",
        "            self.play(\n",
        "                input_tracker.set_value, value,\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def describe_output(self):\n",
        "        path = self.path\n",
        "        output_dot = self.output_dot\n",
        "        output_decimal = self.output_decimal\n",
        "        input_dot = self.input_dot\n",
        "        input_tracker = self.input_tracker\n",
        "        plane = self.plane\n",
        "        real_line = plane.x_axis.copy()\n",
        "        real_line.set_stroke(RED, 4)\n",
        "        real_words = OldTexText(\"Real number line\")\n",
        "        real_words.next_to(ORIGIN, UP)\n",
        "        real_words.to_edge(RIGHT)\n",
        "\n",
        "        traced_path = TracedPath(output_dot.get_center)\n",
        "        traced_path.match_style(path)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(real_line),\n",
        "            FadeIn(real_words, DOWN)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(real_line),\n",
        "            FadeOut(real_words),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(plane.sublabel, UP)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(output_decimal),\n",
        "            TransformFromCopy(input_dot, output_dot),\n",
        "        )\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 10,\n",
        "            \"rate_func\": lambda t: smooth(t, 1),\n",
        "        }\n",
        "        self.play(\n",
        "            ApplyMethod(input_tracker.set_value, 1, **kw),\n",
        "            ShowCreation(path.copy(), remover=True, **kw),\n",
        "        )\n",
        "        self.add(path)\n",
        "        self.add(output_dot)\n",
        "        self.wait()\n",
        "\n",
        "        # Flatten to 1d\n",
        "        real_function_word = OldTexText(\n",
        "            \"Real-valued function\"\n",
        "        )\n",
        "        real_function_word.next_to(ORIGIN, DOWN, MED_LARGE_BUFF)\n",
        "        path.generate_target()\n",
        "        path.target.stretch(0, 1)\n",
        "        path.target.move_to(plane.n2p(0))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(real_function_word),\n",
        "            MoveToTarget(path),\n",
        "        )\n",
        "        input_tracker.set_value(0)\n",
        "        self.play(\n",
        "            input_tracker.set_value, 1,\n",
        "            **kw\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_input_line(self, input_rect):\n",
        "        input_line = UnitInterval()\n",
        "        input_line.move_to(input_rect)\n",
        "        input_line.shift(0.25 * UP)\n",
        "        input_line.set_width(\n",
        "            input_rect.get_width() - 1\n",
        "        )\n",
        "        input_line.add_numbers(0, 0.5, 1)\n",
        "        return input_line\n",
        "\n",
        "    def get_path(self):\n",
        "        # mob = SVGMobject(\"BatmanLogo\")\n",
        "        mob = OldTex(\"\\\\pi\")\n",
        "        path = mob.family_members_with_points()[0]\n",
        "        path.set_height(3.5)\n",
        "        path.move_to(2 * DOWN, DOWN)\n",
        "        path.set_stroke(YELLOW, 2)\n",
        "        path.set_fill(opacity=0)\n",
        "        return path\n",
        "\n",
        "\n",
        "class GraphForFlattenedPi(ClarifyInputAndOutput):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_color\": GREY_E},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        plane = self.plane\n",
        "        self.remove(plane, plane.label)\n",
        "\n",
        "        path = self.get_path()\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=1,\n",
        "            x_axis_config={\n",
        "                \"unit_size\": 7,\n",
        "                \"include_tip\": False,\n",
        "                \"tick_frequency\": 0.1,\n",
        "            },\n",
        "            y_min=-1.5,\n",
        "            y_max=1.5,\n",
        "            y_axis_config={\n",
        "                \"include_tip\": False,\n",
        "                \"unit_size\": 2.5,\n",
        "                \"tick_frequency\": 0.5,\n",
        "            },\n",
        "        )\n",
        "        axes.set_width(FRAME_WIDTH - 1)\n",
        "        axes.set_height(FRAME_HEIGHT - 1, stretch=True)\n",
        "        axes.center()\n",
        "\n",
        "        axes.x_axis.add_numbers(\n",
        "            0.5, 1.0,\n",
        "            num_decimal_places=1,\n",
        "        )\n",
        "        axes.y_axis.add_numbers(\n",
        "            -1.0, 1.0,\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "\n",
        "        def func(t):\n",
        "            return plane.x_axis.p2n(\n",
        "                path.point_from_proportion(t)\n",
        "            )\n",
        "\n",
        "        graph = axes.get_graph(func)\n",
        "        graph.set_color(PINK)\n",
        "\n",
        "        v_line = always_redraw(lambda: Line(\n",
        "            axes.x_axis.n2p(axes.x_axis.p2n(graph.get_end())),\n",
        "            graph.get_end(),\n",
        "            stroke_width=1,\n",
        "        ))\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(v_line)\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 10,\n",
        "            \"rate_func\": lambda t: smooth(t, 1),\n",
        "        }\n",
        "        self.play(ShowCreation(graph, **kw))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleComplexExponentExample(ClarifyInputAndOutput):\n",
        "    CONFIG = {\n",
        "        \"input_space_rect_config\": {\n",
        "            \"width\": 14,\n",
        "            \"height\": 1.5,\n",
        "        },\n",
        "        \"input_line_config\": {\n",
        "            \"unit_size\": 0.5,\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 25,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"input_numbers\": range(0, 30, 5),\n",
        "        \"input_tex_args\": [\"t\", \"=\"],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "        self.setup_output_trackers()\n",
        "\n",
        "        # Testing\n",
        "        time = self.input_line.x_max\n",
        "        self.play(\n",
        "            self.input_tracker.set_value, time,\n",
        "            run_time=time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    def setup_plane(self):\n",
        "        plane = ComplexPlane()\n",
        "        plane.scale(2)\n",
        "        plane.add_coordinates()\n",
        "        plane.shift(DOWN)\n",
        "        self.plane = plane\n",
        "        self.add(plane)\n",
        "\n",
        "    def setup_input_trackers(self):\n",
        "        input_line = self.input_line\n",
        "        input_tracker = ValueTracker(0)\n",
        "        get_input = input_tracker.get_value\n",
        "\n",
        "        input_tip = ArrowTip(start_angle=-TAU / 4)\n",
        "        input_tip.scale(0.5)\n",
        "        input_tip.set_color(PINK)\n",
        "        f_always(\n",
        "            input_tip.move_to,\n",
        "            lambda: input_line.n2p(get_input()),\n",
        "            lambda: DOWN,\n",
        "        )\n",
        "\n",
        "        input_label = VGroup(\n",
        "            OldTex(*self.input_tex_args),\n",
        "            DecimalNumber(),\n",
        "        )\n",
        "        input_label[0].set_color_by_tex(\"t\", PINK)\n",
        "        input_label.scale(0.7)\n",
        "        input_label.add_updater(\n",
        "            lambda m: m.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        )\n",
        "        input_label.add_updater(\n",
        "            lambda m: m[1].set_value(get_input())\n",
        "        )\n",
        "        input_label.add_updater(\n",
        "            lambda m: m.next_to(input_tip, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.input_tracker = input_tracker\n",
        "        self.input_tip = input_tip\n",
        "        self.input_label = input_label\n",
        "\n",
        "        self.add(input_tip, input_label)\n",
        "\n",
        "    def setup_output_trackers(self):\n",
        "        plane = self.plane\n",
        "        get_input = self.input_tracker.get_value\n",
        "\n",
        "        def get_output():\n",
        "            return np.exp(complex(0, get_input()))\n",
        "\n",
        "        def get_output_point():\n",
        "            return plane.n2p(get_output())\n",
        "\n",
        "        output_label, static_output_label = [\n",
        "            OldTex(\n",
        "                \"e^{i t}\" + s,\n",
        "                tex_to_color_map={\"t\": PINK},\n",
        "                background_stroke_width=3,\n",
        "            )\n",
        "            for s in [\"\", \"\\\\approx\"]\n",
        "        ]\n",
        "        output_label.scale(1.2)\n",
        "        output_label.add_updater(\n",
        "            lambda m: m.shift(\n",
        "                -m.get_bottom() +\n",
        "                get_output_point() +\n",
        "                rotate_vector(\n",
        "                    0.35 * RIGHT,\n",
        "                    get_input(),\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "\n",
        "        output_vector = Vector()\n",
        "        output_vector.set_opacity(0.75)\n",
        "        output_vector.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                plane.n2p(0), get_output_point(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        t_max = 40\n",
        "        full_output_path = ParametricCurve(\n",
        "            lambda t: plane.n2p(np.exp(complex(0, t))),\n",
        "            t_min=0,\n",
        "            t_max=t_max\n",
        "        )\n",
        "        output_path = VMobject()\n",
        "        output_path.set_stroke(YELLOW, 2)\n",
        "        output_path.add_updater(\n",
        "            lambda m: m.pointwise_become_partial(\n",
        "                full_output_path,\n",
        "                0, get_input() / t_max,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        static_output_label.next_to(plane.c2p(1, 1), UR)\n",
        "        output_decimal = DecimalNumber(\n",
        "            include_sign=True,\n",
        "        )\n",
        "        output_decimal.scale(0.8)\n",
        "        output_decimal.set_stroke(BLACK, 3, background=True)\n",
        "        output_decimal.add_updater(\n",
        "            lambda m: m.set_value(get_output())\n",
        "        )\n",
        "        output_decimal.add_updater(\n",
        "            lambda m: m.next_to(\n",
        "                static_output_label,\n",
        "                RIGHT, 2 * SMALL_BUFF,\n",
        "                aligned_edge=DOWN,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(output_path)\n",
        "        self.add(output_vector)\n",
        "        self.add(output_label)\n",
        "        self.add(static_output_label)\n",
        "        self.add(BackgroundRectangle(output_decimal))\n",
        "        self.add(output_decimal)\n",
        "\n",
        "    #\n",
        "    def get_input_line(self, input_rect):\n",
        "        input_line = NumberLine(**self.input_line_config)\n",
        "        input_line.move_to(input_rect)\n",
        "        input_line.set_width(\n",
        "            input_rect.get_width() - 1.5,\n",
        "            stretch=True,\n",
        "        )\n",
        "        input_line.add_numbers(*self.input_numbers)\n",
        "        return input_line\n",
        "\n",
        "\n",
        "class TRangingFrom0To1(SimpleComplexExponentExample):\n",
        "    CONFIG = {\n",
        "        \"input_space_rect_config\": {\n",
        "            \"width\": 6,\n",
        "            \"height\": 2,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "\n",
        "        self.play(\n",
        "            self.input_tracker.set_value, 1,\n",
        "            run_time=10,\n",
        "            rate_func=linear\n",
        "        )\n",
        "\n",
        "    def get_input_line(self, rect):\n",
        "        result = ClarifyInputAndOutput.get_input_line(self, rect)\n",
        "        result.stretch(0.9, 0)\n",
        "        result.set_stroke(width=2)\n",
        "        for sm in result.get_family():\n",
        "            if isinstance(sm, DecimalNumber):\n",
        "                sm.stretch(1 / 0.9, 0)\n",
        "                sm.set_stroke(width=0)\n",
        "        return result\n"
    ]
}