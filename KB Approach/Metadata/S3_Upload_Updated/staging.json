{
    "topic": "The mathematical concept being demonstrated is the vector field of a pendulum, specifically the vector",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part1.shared_constructs import *\n",
        "from _2019.diffyq.part1.pendulum import Pendulum\n",
        "from _2019.diffyq.part1.pendulum import ThetaVsTAxes\n",
        "from _2019.diffyq.part1.phase_space import IntroduceVectorField\n",
        "from _2018.div_curl import PhaseSpaceOfPopulationModel\n",
        "from _2018.div_curl import ShowTwoPopulations\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class VectorFieldTest(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane(\n",
        "            # axis_config={\"unit_size\": 2}\n",
        "        )\n",
        "        mu_tracker = ValueTracker(1)\n",
        "        field = VectorField(\n",
        "            lambda p: pendulum_vector_field_func(\n",
        "                plane.point_to_coords(p),\n",
        "                mu=mu_tracker.get_value()\n",
        "            ),\n",
        "            delta_x=0.5,\n",
        "            delta_y=0.5,\n",
        "            max_magnitude=6,\n",
        "            opacity=0.5,\n",
        "            # length_func=lambda norm: norm,\n",
        "        )\n",
        "        field.set_opacity(1)\n",
        "\n",
        "        self.add(plane, field)\n",
        "        return\n",
        "\n",
        "        stream_lines = StreamLines(\n",
        "            field.func,\n",
        "            delta_x=0.5,\n",
        "            delta_y=0.5,\n",
        "        )\n",
        "        animated_stream_lines = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            line_anim_class=ShowPassingFlashWithThinningStrokeWidth,\n",
        "        )\n",
        "\n",
        "        self.add(plane, field, animated_stream_lines)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ShowRect(Scene):\n",
        "    CONFIG = {\n",
        "        \"height\": 1,\n",
        "        \"width\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        rect = Rectangle(\n",
        "            height=self.height,\n",
        "            width=self.width,\n",
        "        )\n",
        "        rect.set_stroke(YELLOW)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class ShowSquare(ShowRect):\n",
        "    CONFIG = {\n",
        "        \"height\": 3,\n",
        "        \"width\": 3,\n",
        "    }\n",
        "\n",
        "\n",
        "class WhenChangeIsEasier(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class AirResistanceBrace(Scene):\n",
        "    def construct(self):\n",
        "        brace = Brace(Line(ORIGIN, RIGHT), DOWN)\n",
        "        word = OldTexText(\"Air resistance\")\n",
        "        word.next_to(brace, DOWN)\n",
        "        self.play(GrowFromCenter(brace), FadeIn(word, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PeriodFormula(Scene):\n",
        "    def construct(self):\n",
        "        formula = get_period_formula()\n",
        "        formula.scale(2)\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.scale(3)\n",
        "        q_mark.next_to(formula, RIGHT)\n",
        "        self.add(formula, q_mark)\n",
        "\n",
        "\n",
        "class TourOfDifferentialEquations(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"screen_rect_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"fill_opacity\": 1,\n",
        "            \"fill_color\": BLACK,\n",
        "        },\n",
        "        \"camera_config\": {\"background_color\": GREY_E},\n",
        "        \"zoomed_thumbnail_index\": 0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_thumbnails()\n",
        "        self.zoom_in_to_one_thumbnail()\n",
        "        # self.show_words()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            \"A Tourist's Guide \\\\\\\\to Differential\\\\\\\\Equations\"\n",
        "        )\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UR)\n",
        "        self.add(title)\n",
        "\n",
        "    def show_thumbnails(self):\n",
        "        thumbnails = self.thumbnails = Group(\n",
        "            Group(ScreenRectangle(**self.screen_rect_style)),\n",
        "            Group(ScreenRectangle(**self.screen_rect_style)),\n",
        "            Group(ScreenRectangle(**self.screen_rect_style)),\n",
        "            Group(ScreenRectangle(**self.screen_rect_style)),\n",
        "            Group(ScreenRectangle(**self.screen_rect_style)),\n",
        "        )\n",
        "        n = len(thumbnails)\n",
        "        thumbnails.set_height(1.5)\n",
        "\n",
        "        line = self.line = CubicBezier(\n",
        "            [-5, 3, 0],\n",
        "            [3, 3, 0],\n",
        "            [-3, -3, 0],\n",
        "            [5, -3, 0],\n",
        "        )\n",
        "        line.shift(MED_SMALL_BUFF * LEFT)\n",
        "        for thumbnail, a in zip(thumbnails, np.linspace(0, 1, n)):\n",
        "            thumbnail.move_to(line.point_from_proportion(a))\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        dots.next_to(thumbnails[-1], RIGHT)\n",
        "\n",
        "        self.add_phase_space_preview(thumbnails[0])\n",
        "        self.add_heat_preview(thumbnails[1])\n",
        "        self.add_fourier_series(thumbnails[2])\n",
        "        self.add_matrix_exponent(thumbnails[3])\n",
        "        self.add_laplace_symbol(thumbnails[4])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                line,\n",
        "                rate_func=lambda t: np.clip(t * (n + 1) / n, 0, 1)\n",
        "            ),\n",
        "            LaggedStart(*[\n",
        "                GrowFromCenter(\n",
        "                    thumbnail,\n",
        "                    rate_func=squish_rate_func(\n",
        "                        smooth,\n",
        "                        0, 0.7,\n",
        "                    )\n",
        "                )\n",
        "                for thumbnail in thumbnails\n",
        "            ], lag_ratio=1),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(Write(dots))\n",
        "        self.wait()\n",
        "\n",
        "        self.thumbnails = thumbnails\n",
        "\n",
        "    def zoom_in_to_one_thumbnail(self):\n",
        "        self.play(\n",
        "            self.camera_frame.replace,\n",
        "            self.thumbnails[self.zoomed_thumbnail_index],\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_words(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Generalize\"),\n",
        "            OldTexText(\"Put in context\"),\n",
        "            OldTexText(\"Modify\"),\n",
        "        )\n",
        "        # words.arrange(DOWN, aligned_edge=LEFT, buff=LARGE_BUFF)\n",
        "        words.scale(1.5)\n",
        "        words.to_corner(UR)\n",
        "        words.add_to_back(VectorizedPoint(words.get_center()))\n",
        "        words.add(VectorizedPoint(words.get_center()))\n",
        "\n",
        "        diffEq = OldTexText(\"Differential\\\\\\\\equations\")\n",
        "        diffEq.scale(1.5)\n",
        "        diffEq.to_corner(DL, buff=LARGE_BUFF)\n",
        "\n",
        "        for word1, word2 in zip(words, words[1:]):\n",
        "            self.play(\n",
        "                FadeInFromDown(word2),\n",
        "                FadeOut(word1, UP),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(self.thumbnails).copy().fade(1),\n",
        "                diffEq,\n",
        "                lag_ratio=0.01,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def add_phase_space_preview(self, thumbnail):\n",
        "        image = ImageMobject(\"LovePhaseSpace\")\n",
        "        image.replace(thumbnail)\n",
        "        thumbnail.add(image)\n",
        "\n",
        "    def add_heat_preview(self, thumbnail):\n",
        "        image = ImageMobject(\"HeatSurfaceExample\")\n",
        "        image.replace(thumbnail)\n",
        "        thumbnail.add(image)\n",
        "\n",
        "    def add_matrix_exponent(self, thumbnail):\n",
        "        matrix = IntegerMatrix(\n",
        "            [[3, 1], [4, 1]],\n",
        "            v_buff=MED_LARGE_BUFF,\n",
        "            h_buff=MED_LARGE_BUFF,\n",
        "            bracket_h_buff=SMALL_BUFF,\n",
        "            bracket_v_buff=SMALL_BUFF,\n",
        "        )\n",
        "        e = OldTex(\"e\")\n",
        "        t = OldTex(\"t\")\n",
        "        t.scale(1.5)\n",
        "        t.next_to(matrix, RIGHT, SMALL_BUFF)\n",
        "        e.scale(2)\n",
        "        e.move_to(matrix.get_corner(DL), UR)\n",
        "        group = VGroup(e, matrix, t)\n",
        "        group.set_height(0.7 * thumbnail.get_height())\n",
        "        randy = Randolph(mode=\"confused\", height=0.75)\n",
        "        randy.next_to(group, LEFT, aligned_edge=DOWN)\n",
        "        randy.look_at(matrix)\n",
        "        group.add(randy)\n",
        "        group.move_to(thumbnail)\n",
        "        thumbnail.add(group)\n",
        "\n",
        "    def add_fourier_series(self, thumbnail):\n",
        "        colors = [BLUE, GREEN, YELLOW, RED, RED_E, PINK]\n",
        "\n",
        "        waves = VGroup(*[\n",
        "            self.get_square_wave_approx(N, color)\n",
        "            for N, color in enumerate(colors)\n",
        "        ])\n",
        "        waves.set_stroke(width=1.5)\n",
        "        waves.replace(thumbnail, stretch=True)\n",
        "        waves.scale(0.8)\n",
        "        waves.move_to(thumbnail)\n",
        "        thumbnail.add(waves)\n",
        "\n",
        "    def get_square_wave_approx(self, N, color):\n",
        "        return FunctionGraph(\n",
        "            lambda x: sum([\n",
        "                (1 / n) * np.sin(n * PI * x)\n",
        "                for n in range(1, 2 * N + 3, 2)\n",
        "            ]),\n",
        "            x_min=0,\n",
        "            x_max=2,\n",
        "            color=color\n",
        "        )\n",
        "\n",
        "    def add_laplace_symbol(self, thumbnail):\n",
        "        mob = OldTex(\n",
        "            \"\\\\mathcal{L}\\\\left\\\\{f(t)\\\\right\\\\}\"\n",
        "        )\n",
        "        mob.set_width(0.8 * thumbnail.get_width())\n",
        "        mob.move_to(thumbnail)\n",
        "        thumbnail.add(mob)\n",
        "\n",
        "\n",
        "class HeatEquationPreview(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowHorizontalDashedLine(Scene):\n",
        "    def construct(self):\n",
        "        line = DashedLine(LEFT_SIDE, RIGHT_SIDE)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RabbitFoxPopulations(ShowTwoPopulations):\n",
        "    pass\n",
        "\n",
        "\n",
        "class RabbitFoxEquation(PhaseSpaceOfPopulationModel):\n",
        "    def construct(self):\n",
        "        equations = self.get_equations()\n",
        "        self.add(equations)\n",
        "\n",
        "\n",
        "class ShowGravityAcceleration(Scene):\n",
        "    CONFIG = {\n",
        "        \"flash\": True,\n",
        "        \"add_ball_copies\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_gravity_field()\n",
        "        self.add_title()\n",
        "        self.pulse_gravity_down()\n",
        "        self.show_g_value()\n",
        "        self.show_trajectory()\n",
        "        self.combine_v_vects()\n",
        "        self.show_g_symbol()\n",
        "\n",
        "    def add_gravity_field(self):\n",
        "        gravity_field = self.gravity_field = VectorField(\n",
        "            lambda p: DOWN,\n",
        "            # delta_x=2,\n",
        "            # delta_y=2,\n",
        "        )\n",
        "        gravity_field.set_opacity(0.5)\n",
        "        gravity_field.sort(\n",
        "            lambda p: -p[1],\n",
        "        )\n",
        "        self.add(gravity_field)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"Gravitational acceleration\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.add_background_rectangle(\n",
        "            buff=0.05,\n",
        "            opacity=1,\n",
        "        )\n",
        "        self.play(FadeInFromDown(title))\n",
        "\n",
        "    def pulse_gravity_down(self):\n",
        "        field = self.gravity_field\n",
        "        self.play(LaggedStart(*[\n",
        "            ApplyFunction(\n",
        "                lambda v: v.set_opacity(1).scale(1.2),\n",
        "                vector,\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "            for vector in field\n",
        "        ]), run_time=2, lag_ratio=0.001)\n",
        "        self.add(self.title)\n",
        "\n",
        "    def show_g_value(self):\n",
        "        title = self.title\n",
        "        g_eq = self.g_eq = OldTex(\n",
        "            \"-9.8\", \"{\\\\text{m/s}\", \"\\\\over\", \"\\\\text{s}}\",\n",
        "            **Lg_formula_config\n",
        "        )\n",
        "        g_eq.add_background_rectangle_to_submobjects()\n",
        "        g_eq.scale(2)\n",
        "        g_eq.center()\n",
        "        num, ms, per, s = g_eq\n",
        "\n",
        "        self.add(num)\n",
        "        self.wait(0.75)\n",
        "        self.play(\n",
        "            FadeIn(ms, 0.25 * DOWN, run_time=0.5)\n",
        "        )\n",
        "        self.wait(0.25)\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromPoint(per, per.get_left()),\n",
        "            FadeIn(s, 0.5 * UP),\n",
        "            lag_ratio=0.7,\n",
        "            run_time=0.75\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            g_eq.scale, 0.5,\n",
        "            g_eq.next_to, title, DOWN,\n",
        "        )\n",
        "\n",
        "    def show_trajectory(self):\n",
        "        total_time = 6\n",
        "\n",
        "        ball = self.get_ball()\n",
        "\n",
        "        p0 = 3 * DOWN + 5 * LEFT\n",
        "        v0 = 2.8 * UP + 1.5 * RIGHT\n",
        "        g = 0.9 * DOWN\n",
        "        graph = ParametricCurve(\n",
        "            lambda t: p0 + v0 * t + 0.5 * g * t**2,\n",
        "            t_min=0,\n",
        "            t_max=total_time,\n",
        "        )\n",
        "        # graph.center().to_edge(DOWN)\n",
        "        dashed_graph = DashedVMobject(graph, num_dashes=60)\n",
        "        dashed_graph.set_stroke(WHITE, 1)\n",
        "\n",
        "        ball.move_to(graph.get_start())\n",
        "        randy.add_updater(\n",
        "            lambda m, dt: m.rotate(dt).move_to(ball)\n",
        "        )\n",
        "        times = np.arange(0, total_time + 1)\n",
        "\n",
        "        velocity_graph = ParametricCurve(\n",
        "            lambda t: v0 + g * t,\n",
        "            t_min=0, t_max=total_time,\n",
        "        )\n",
        "        v_point = VectorizedPoint()\n",
        "        v_point.move_to(velocity_graph.get_start())\n",
        "\n",
        "        def get_v_vect():\n",
        "            result = Vector(\n",
        "                v_point.get_location(),\n",
        "                color=RED,\n",
        "                tip_length=0.2,\n",
        "            )\n",
        "            result.scale(0.5, about_point=result.get_start())\n",
        "            result.shift(ball.get_center())\n",
        "            result.set_stroke(width=2, family=False)\n",
        "            return result\n",
        "        v_vect = always_redraw(get_v_vect)\n",
        "        self.add(v_vect)\n",
        "\n",
        "        flash_rect = FullScreenRectangle(\n",
        "            stroke_width=0,\n",
        "            fill_color=WHITE,\n",
        "            fill_opacity=0.2,\n",
        "        )\n",
        "        flash = FadeOut(\n",
        "            flash_rect,\n",
        "            rate_func=squish_rate_func(smooth, 0, 0.1)\n",
        "        )\n",
        "\n",
        "        time_label = OldTexText(\"Time = \")\n",
        "        time_label.shift(MED_SMALL_BUFF * LEFT)\n",
        "        time_tracker = ValueTracker(0)\n",
        "        time = DecimalNumber(0)\n",
        "        time.next_to(time_label, RIGHT)\n",
        "        time.add_updater(lambda d, dt: d.set_value(\n",
        "            time_tracker.get_value()\n",
        "        ))\n",
        "        time_group = VGroup(time_label, time)\n",
        "        time_group.center().to_edge(DOWN)\n",
        "        self.add(time_group)\n",
        "\n",
        "        ball_copies = VGroup()\n",
        "        v_vect_copies = VGroup()\n",
        "        self.add(dashed_graph, ball)\n",
        "        for t1, t2 in zip(times, times[1:]):\n",
        "            v_vect_copy = v_vect.copy()\n",
        "            v_vect_copies.add(v_vect_copy)\n",
        "            ball_copy = ball.copy()\n",
        "            ball_copy.clear_updaters()\n",
        "            ball_copies.add(ball_copy)\n",
        "\n",
        "            if self.add_ball_copies:\n",
        "                self.add(v_vect_copy)\n",
        "                self.add(ball_copy, ball)\n",
        "\n",
        "            dashed_graph.save_state()\n",
        "            kw = {\n",
        "                \"rate_func\": lambda alpha: interpolate(\n",
        "                    t1 / total_time,\n",
        "                    t2 / total_time,\n",
        "                    alpha\n",
        "                )\n",
        "            }\n",
        "            anims = [\n",
        "                ShowCreation(dashed_graph, **kw),\n",
        "                MoveAlongPath(ball, graph, **kw),\n",
        "                MoveAlongPath(v_point, velocity_graph, **kw),\n",
        "                ApplyMethod(\n",
        "                    time_tracker.increment_value, 1,\n",
        "                    rate_func=linear\n",
        "                ),\n",
        "            ]\n",
        "            if self.flash:\n",
        "                anims.append(flash)\n",
        "            self.play(*anims, run_time=1)\n",
        "            dashed_graph.restore()\n",
        "        randy.clear_updaters()\n",
        "        self.play(FadeOut(time_group))\n",
        "        self.wait()\n",
        "\n",
        "        self.v_vects = v_vect_copies\n",
        "\n",
        "    def combine_v_vects(self):\n",
        "        v_vects = self.v_vects.copy()\n",
        "        v_vects.generate_target()\n",
        "        new_center = 2 * DOWN + 2 * LEFT\n",
        "        for vect in v_vects.target:\n",
        "            vect.scale(1.5)\n",
        "            vect.set_stroke(width=2)\n",
        "            vect.shift(new_center - vect.get_start())\n",
        "\n",
        "        self.play(MoveToTarget(v_vects))\n",
        "\n",
        "        delta_vects = VGroup(*[\n",
        "            Arrow(\n",
        "                v1.get_end(),\n",
        "                v2.get_end(),\n",
        "                buff=0.01,\n",
        "                color=YELLOW,\n",
        "            ).set_opacity(0.5)\n",
        "            for v1, v2 in zip(v_vects, v_vects[1:])\n",
        "        ])\n",
        "        brace = Brace(Line(ORIGIN, UP), RIGHT)\n",
        "        braces = VGroup(*[\n",
        "            brace.copy().match_height(arrow).next_to(\n",
        "                arrow, RIGHT, buff=0.2 * SMALL_BUFF\n",
        "            )\n",
        "            for arrow in delta_vects\n",
        "        ])\n",
        "        amounts = VGroup(*[\n",
        "            OldTexText(\"9.8 m/s\").scale(0.5).next_to(\n",
        "                brace, RIGHT, SMALL_BUFF\n",
        "            )\n",
        "            for brace in braces\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.gravity_field),\n",
        "            FadeIn(delta_vects, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces),\n",
        "            LaggedStartMap(FadeInFrom, amounts, lambda m: (m, LEFT)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_g_symbol(self):\n",
        "        g = OldTex(\"g\")\n",
        "        brace = Brace(self.g_eq[0][2:], UP, buff=SMALL_BUFF)\n",
        "        g.scale(1.5)\n",
        "        g.next_to(brace, UP)\n",
        "        g.set_color(YELLOW)\n",
        "        self.play(\n",
        "            FadeOut(self.title),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(g, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_ball(self):\n",
        "        ball = Circle(\n",
        "            stroke_width=1,\n",
        "            stroke_color=WHITE,\n",
        "            fill_color=GREY,\n",
        "            fill_opacity=1,\n",
        "            sheen_factor=1,\n",
        "            sheen_direction=UL,\n",
        "            radius=0.25,\n",
        "        )\n",
        "        randy = Randolph(mode=\"pondering\")\n",
        "        randy.eyes.set_stroke(BLACK, 0.5)\n",
        "        randy.match_height(ball)\n",
        "        randy.scale(0.75)\n",
        "        randy.move_to(ball)\n",
        "        ball.add(randy)\n",
        "        return ball\n",
        "\n",
        "\n",
        "class ShowSimpleTrajectory(ShowGravityAcceleration):\n",
        "    CONFIG = {\n",
        "        \"flash\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_trajectory()\n",
        "\n",
        "\n",
        "class SimpleProjectileEquation(ShowGravityAcceleration):\n",
        "    CONFIG = {\n",
        "        \"y0\": 0,\n",
        "        \"g\": 9.8,\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 6,\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 1.5,\n",
        "                \"tip_width\": 0.15,\n",
        "            },\n",
        "            \"y_min\": -30,\n",
        "            \"y_max\": 35,\n",
        "            \"y_axis_config\": {\n",
        "                \"unit_size\": 0.1,\n",
        "                \"big_tick_numbers\": range(\n",
        "                    -30, 35, 10\n",
        "                ),\n",
        "                \"tick_size\": 0.05,\n",
        "                \"numbers_to_show\": range(-30, 31, 10),\n",
        "                \"tip_width\": 0.15,\n",
        "            },\n",
        "            \"center_point\": 2 * LEFT,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.setup_trajectory()\n",
        "\n",
        "        self.show_trajectory()\n",
        "        self.show_equation()\n",
        "        self.solve_for_velocity()\n",
        "        self.solve_for_position()\n",
        "\n",
        "    def add_axes(self):\n",
        "        axes = self.axes = Axes(**self.axes_config)\n",
        "        axes.set_stroke(width=2)\n",
        "        axes.add_coordinates()\n",
        "\n",
        "        t_label = OldTex(\"t\")\n",
        "        t_label.next_to(axes.x_axis.get_right(), UL)\n",
        "        axes.add(t_label)\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "    def setup_trajectory(self):\n",
        "        axes = self.axes\n",
        "        total_time = self.total_time = 5\n",
        "\n",
        "        ball = self.get_ball()\n",
        "        offset_vector = 3 * LEFT\n",
        "\n",
        "        g = self.g\n",
        "        y0 = self.y0\n",
        "        v0 = 0.5 * g * total_time\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        # Position\n",
        "        def y_func(t):\n",
        "            return -0.5 * g * t**2 + v0 * t + y0\n",
        "\n",
        "        graph_template = axes.get_graph(y_func, x_max=total_time)\n",
        "        graph_template.set_stroke(width=2)\n",
        "        traj_template = graph_template.copy()\n",
        "        traj_template.stretch(0, 0)\n",
        "        traj_template.move_to(\n",
        "            axes.coords_to_point(0, 0), DOWN\n",
        "        )\n",
        "        traj_template.shift(offset_vector)\n",
        "        traj_template.set_stroke(width=0.5)\n",
        "\n",
        "        graph = VMobject()\n",
        "        graph.set_stroke(BLUE, 2)\n",
        "        traj = VMobject()\n",
        "        traj.set_stroke(WHITE, 0.5)\n",
        "        graph.add_updater(lambda g: g.pointwise_become_partial(\n",
        "            graph_template, 0, get_t() / total_time\n",
        "        ))\n",
        "        traj.add_updater(lambda t: t.pointwise_become_partial(\n",
        "            traj_template, 0, get_t() / total_time\n",
        "        ))\n",
        "\n",
        "        def get_ball_point():\n",
        "            return axes.coords_to_point(\n",
        "                0, y_func(get_t())\n",
        "            ) + offset_vector\n",
        "\n",
        "        f_always(ball.move_to, get_ball_point)\n",
        "\n",
        "        h_line = always_redraw(lambda: DashedLine(\n",
        "            get_ball_point(),\n",
        "            axes.input_to_graph_point(get_t(), graph_template),\n",
        "            stroke_width=1,\n",
        "        ))\n",
        "\n",
        "        y_label = OldTex(\"y\", \"(t)\")\n",
        "        y_label.set_color_by_tex(\"y\", BLUE)\n",
        "        y_label.add_updater(\n",
        "            lambda m: m.next_to(\n",
        "                graph.get_last_point(),\n",
        "                UR, SMALL_BUFF,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Velocity\n",
        "        def v_func(t):\n",
        "            return -g * t + v0\n",
        "\n",
        "        def get_v_vect():\n",
        "            return Vector(\n",
        "                axes.y_axis.unit_size * v_func(get_t()) * UP,\n",
        "                color=RED,\n",
        "            )\n",
        "        v_vect = always_redraw(\n",
        "            lambda: get_v_vect().shift(get_ball_point())\n",
        "        )\n",
        "        v_brace = always_redraw(lambda: Brace(v_vect, LEFT))\n",
        "        dy_dt_label = OldTex(\n",
        "            \"{d\", \"y\", \"\\\\over dt}\", \"(t)\",\n",
        "        )\n",
        "        dy_dt_label.scale(0.8)\n",
        "        dy_dt_label.set_color_by_tex(\"y\", BLUE)\n",
        "        y_dot_label = OldTex(\"\\\\dot y\", \"(t)\")\n",
        "        y_dot_label.set_color_by_tex(\"\\\\dot y\", RED)\n",
        "        for label in dy_dt_label, y_dot_label:\n",
        "            label.add_updater(lambda m: m.next_to(\n",
        "                v_brace, LEFT, SMALL_BUFF,\n",
        "            ))\n",
        "\n",
        "        graphed_v_vect = always_redraw(\n",
        "            lambda: get_v_vect().shift(\n",
        "                axes.coords_to_point(get_t(), 0)\n",
        "            )\n",
        "        )\n",
        "        v_graph_template = axes.get_graph(\n",
        "            v_func, x_max=total_time,\n",
        "        )\n",
        "        v_graph = VMobject()\n",
        "        v_graph.set_stroke(RED, 2)\n",
        "        v_graph.add_updater(lambda m: m.pointwise_become_partial(\n",
        "            v_graph_template,\n",
        "            0, get_t() / total_time,\n",
        "        ))\n",
        "\n",
        "        # Acceleration\n",
        "        def get_a_vect():\n",
        "            return Vector(\n",
        "                axes.y_axis.unit_size * g * DOWN\n",
        "            )\n",
        "\n",
        "        a_vect = get_a_vect()\n",
        "        a_vect.add_updater(lambda a: a.move_to(\n",
        "            get_ball_point(), UP,\n",
        "        ))\n",
        "        a_brace = Brace(a_vect, RIGHT)\n",
        "        always(a_brace.next_to, a_vect, RIGHT, SMALL_BUFF)\n",
        "        d2y_dt2_label = OldTex(\n",
        "            \"d^2\", \"{y}\", \"\\\\over dt}\", \"(t)\"\n",
        "        )\n",
        "        d2y_dt2_label.scale(0.8)\n",
        "        d2y_dt2_label.set_color_by_tex(\n",
        "            \"y\", BLUE,\n",
        "        )\n",
        "        y_ddot_label = OldTex(\"\\\\ddot y\", \"(t)\")\n",
        "        y_ddot_label.set_color_by_tex(\"\\\\ddot y\", YELLOW)\n",
        "        for label in d2y_dt2_label, y_ddot_label:\n",
        "            label.add_updater(lambda m: m.next_to(\n",
        "                a_brace, RIGHT, SMALL_BUFF\n",
        "            ))\n",
        "        a_graph = axes.get_graph(\n",
        "            lambda t: -g, x_max=total_time,\n",
        "        )\n",
        "        a_graph.set_stroke(YELLOW, 2)\n",
        "\n",
        "        graphed_a_vect = get_a_vect()\n",
        "        graphed_a_vect.add_updater(lambda a: a.move_to(\n",
        "            axes.coords_to_point(get_t(), 0), UP,\n",
        "        ))\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            t_tracker,\n",
        "            graph,\n",
        "            y_label,\n",
        "            traj,\n",
        "            h_line,\n",
        "            v_vect,\n",
        "            v_brace,\n",
        "            dy_dt_label,\n",
        "            y_dot_label,\n",
        "            ball,\n",
        "            graphed_v_vect,\n",
        "            v_graph,\n",
        "            a_vect,\n",
        "            a_brace,\n",
        "            d2y_dt2_label,\n",
        "            y_ddot_label,\n",
        "            a_graph,\n",
        "            graphed_a_vect,\n",
        "        )\n",
        "\n",
        "    def show_trajectory(self):\n",
        "        self.add(\n",
        "            self.h_line,\n",
        "            self.traj,\n",
        "            self.ball,\n",
        "            self.graph,\n",
        "            self.y_label,\n",
        "        )\n",
        "        self.play_trajectory()\n",
        "        self.wait()\n",
        "\n",
        "        self.add(\n",
        "            self.v_vect,\n",
        "            self.v_brace,\n",
        "            self.dy_dt_label,\n",
        "            self.ball,\n",
        "            self.graphed_v_vect,\n",
        "            self.v_graph,\n",
        "        )\n",
        "        self.play_trajectory()\n",
        "        self.wait()\n",
        "\n",
        "        self.add(\n",
        "            self.a_vect,\n",
        "            self.ball,\n",
        "            self.a_brace,\n",
        "            self.d2y_dt2_label,\n",
        "            self.a_graph,\n",
        "            self.graphed_a_vect,\n",
        "        )\n",
        "        self.play_trajectory()\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.dy_dt_label,\n",
        "                self.y_dot_label,\n",
        "            ),\n",
        "            ShowCreationThenFadeAround(\n",
        "                self.y_dot_label,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.d2y_dt2_label,\n",
        "                self.y_ddot_label,\n",
        "            ),\n",
        "            ShowCreationThenFadeAround(\n",
        "                self.y_ddot_label,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def show_equation(self):\n",
        "        y_ddot = self.y_ddot_label\n",
        "        new_y_ddot = y_ddot.deepcopy()\n",
        "        new_y_ddot.clear_updaters()\n",
        "\n",
        "        equation = VGroup(\n",
        "            new_y_ddot,\n",
        "            *Tex(\n",
        "                \"=\", \"-g\",\n",
        "                tex_to_color_map={\"-g\": YELLOW},\n",
        "            ),\n",
        "        )\n",
        "        new_y_ddot.next_to(equation[1], LEFT, SMALL_BUFF)\n",
        "        equation.move_to(self.axes)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(y_ddot, new_y_ddot),\n",
        "            Write(equation[1:]),\n",
        "            FadeOut(self.graph),\n",
        "            FadeOut(self.y_label),\n",
        "            FadeOut(self.h_line),\n",
        "            FadeOut(self.v_graph),\n",
        "            FadeOut(self.graphed_v_vect),\n",
        "            FadeOut(self.graphed_a_vect),\n",
        "        )\n",
        "\n",
        "        self.equation = equation\n",
        "\n",
        "    def solve_for_velocity(self):\n",
        "        axes = self.axes\n",
        "        equation = self.equation\n",
        "        v_graph = self.v_graph.deepcopy()\n",
        "        v_graph.clear_updaters()\n",
        "        v_start_point = v_graph.get_start()\n",
        "        origin = axes.coords_to_point(0, 0)\n",
        "        offset = v_start_point - origin\n",
        "        v_graph.shift(-offset)\n",
        "\n",
        "        tex_question, answer1, answer2 = derivs = [\n",
        "            OldTex(\n",
        "                \"{d\", \"(\", *term, \")\", \"\\\\over\", \"dt}\", \"(t)\",\n",
        "                \"=\", \"-g\",\n",
        "                tex_to_color_map={\n",
        "                    \"-g\": YELLOW,\n",
        "                    \"v_0\": RED,\n",
        "                    \"?\": RED,\n",
        "                }\n",
        "            )\n",
        "            for term in [\n",
        "                (\"?\", \"?\", \"?\", \"?\"),\n",
        "                (\"-g\", \"t\"),\n",
        "                (\"-g\", \"t\", \"+\", \"v_0\",),\n",
        "            ]\n",
        "        ]\n",
        "        for x in range(2):\n",
        "            answer1.submobjects.insert(\n",
        "                4, VectorizedPoint(answer1[4].get_left())\n",
        "            )\n",
        "        for deriv in derivs:\n",
        "            deriv.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"What function has slope $-g$?\",\n",
        "            tex_to_color_map={\"$-g$\": YELLOW},\n",
        "        )\n",
        "        question.next_to(tex_question, DOWN)\n",
        "        question.set_stroke(BLACK, 5, background=True)\n",
        "        question.add_background_rectangle()\n",
        "\n",
        "        v0_dot = Dot(v_start_point, color=PINK)\n",
        "        v0_label = OldTex(\"v_0\")\n",
        "        v0_label.set_color(RED)\n",
        "        v0_label.next_to(v0_dot, UR, buff=0)\n",
        "\n",
        "        y_dot_equation = OldTex(\n",
        "            \"{\\\\dot y}\", \"(t)\", \"=\",\n",
        "            \"-g\", \"t\", \"+\", \"v_0\",\n",
        "            tex_to_color_map={\n",
        "                \"{\\\\dot y}\": RED,\n",
        "                \"-g\": YELLOW,\n",
        "                \"v_0\": RED,\n",
        "            }\n",
        "        )\n",
        "        y_dot_equation.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(tex_question, DOWN),\n",
        "            FadeIn(question, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(v_graph, question)\n",
        "        self.play(\n",
        "            ReplacementTransform(tex_question, answer1),\n",
        "            ShowCreation(v_graph),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(answer1, answer2),\n",
        "            v_graph.shift, offset,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromLarge(v0_dot),\n",
        "            FadeInFromDown(v0_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                answer2[2:6], y_dot_equation[3:],\n",
        "            ),\n",
        "            Write(y_dot_equation[:3]),\n",
        "            equation.shift, LEFT,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(question),\n",
        "            FadeOut(answer2),\n",
        "        )\n",
        "\n",
        "        self.remove(v_graph)\n",
        "        self.add(self.v_graph)\n",
        "        self.y_dot_equation = y_dot_equation\n",
        "\n",
        "    def solve_for_position(self):\n",
        "        # Largely copied from above...not great\n",
        "        equation = self.equation\n",
        "        y_dot_equation = self.y_dot_equation\n",
        "        graph = self.graph\n",
        "\n",
        "        all_terms = [\n",
        "            (\"?\", \"?\", \"?\", \"?\"),\n",
        "            (\"-\", \"(1/2)\", \"g\", \"t^2\", \"+\", \"v_0\", \"t\"),\n",
        "            (\"-\", \"(1/2)\", \"g\", \"t^2\", \"+\", \"v_0\", \"t\", \"+\", \"y_0\"),\n",
        "        ]\n",
        "        tex_question, answer1, answer2 = derivs = [\n",
        "            OldTex(\n",
        "                \"{d\", \"(\", *term, \")\", \"\\\\over\", \"dt}\", \"(t)\",\n",
        "                \"=\",\n",
        "                \"-g\", \"t\", \"+\", \"v_0\",\n",
        "                tex_to_color_map={\n",
        "                    \"g\": YELLOW,\n",
        "                    \"v_0\": RED,\n",
        "                    \"?\": BLUE,\n",
        "                    \"y_0\": BLUE,\n",
        "                }\n",
        "            )\n",
        "            for term in all_terms\n",
        "        ]\n",
        "        answer1.scale(0.8)\n",
        "        answer2.scale(0.8)\n",
        "        for deriv, terms in zip(derivs, all_terms):\n",
        "            for x in range(len(all_terms[-1]) - len(terms)):\n",
        "                n = 2 + len(terms)\n",
        "                deriv.submobjects.insert(\n",
        "                    n, VectorizedPoint(deriv[n].get_left())\n",
        "                )\n",
        "            deriv.next_to(\n",
        "                VGroup(equation, y_dot_equation),\n",
        "                DOWN, MED_LARGE_BUFF + SMALL_BUFF\n",
        "            )\n",
        "            deriv.shift_onto_screen()\n",
        "            deriv.add_background_rectangle_to_submobjects()\n",
        "\n",
        "        y_equation = OldTex(\n",
        "            \"y\", \"(t)\", \"=\",\n",
        "            \"-\", \"(1/2)\", \"g\", \"t^2\",\n",
        "            \"+\", \"v_0\", \"t\",\n",
        "            \"+\", \"y_0\",\n",
        "            tex_to_color_map={\n",
        "                \"y\": BLUE,\n",
        "                \"g\": YELLOW,\n",
        "                \"v_0\": RED,\n",
        "            }\n",
        "        )\n",
        "        y_equation.next_to(\n",
        "            VGroup(equation, y_dot_equation),\n",
        "            DOWN, MED_LARGE_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(tex_question, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(graph, tex_question)\n",
        "        self.play(\n",
        "            ReplacementTransform(tex_question, answer1),\n",
        "            ShowCreation(graph),\n",
        "        )\n",
        "        self.add(graph, answer1)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(answer1, answer2))\n",
        "        self.add(graph, answer2)\n",
        "        g_updaters = graph.updaters\n",
        "        graph.clear_updaters()\n",
        "        self.play(\n",
        "            graph.shift, 2 * DOWN,\n",
        "            rate_func=there_and_back,\n",
        "            run_time=2,\n",
        "        )\n",
        "        graph.add_updater(g_updaters[0])\n",
        "        self.wait()\n",
        "        br = BackgroundRectangle(y_equation)\n",
        "        self.play(\n",
        "            FadeIn(br),\n",
        "            ReplacementTransform(\n",
        "                answer2[2:11],\n",
        "                y_equation[3:]\n",
        "            ),\n",
        "            FadeIn(y_equation[:3]),\n",
        "            FadeOut(answer2[:2]),\n",
        "            FadeOut(answer2[11:]),\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(y_equation))\n",
        "        self.play_trajectory()\n",
        "\n",
        "    #\n",
        "    def play_trajectory(self, *added_anims, **kwargs):\n",
        "        self.t_tracker.set_value(0)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.t_tracker.set_value, 5,\n",
        "                rate_func=linear,\n",
        "                run_time=self.total_time,\n",
        "            ),\n",
        "            *added_anims,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleProjectileEquationVGraphFreedom(SimpleProjectileEquation):\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.setup_trajectory()\n",
        "        self.clear()\n",
        "        v_graph = self.v_graph\n",
        "        self.t_tracker.set_value(5)\n",
        "        v_graph.update()\n",
        "        v_graph.clear_updaters()\n",
        "        self.add(v_graph)\n",
        "        self.play(v_graph.shift, 5 * DOWN, run_time=2)\n",
        "        self.play(v_graph.shift, 5 * UP, run_time=2)\n",
        "\n",
        "\n",
        "class UniversalGravityLawSymbols(Scene):\n",
        "    def construct(self):\n",
        "        x1_tex = \"\\\\vec{\\\\textbf{x}}_1\"\n",
        "        x2_tex = \"\\\\vec{\\\\textbf{x}}_2\"\n",
        "        a1_tex = \"\\\\vec{\\\\textbf{a}}_1\"\n",
        "        new_brown = interpolate_color(GREY_B, LIGHT_BROWN, 0.5)\n",
        "        law = OldTex(\n",
        "            \"F_1\", \"=\", \"m_1\", a1_tex, \"=\",\n",
        "            \"G\", \"m_1\", \"m_2\",\n",
        "            \"\\\\left({\", x2_tex, \"-\", x1_tex, \"\\\\over\",\n",
        "            \"||\", x2_tex, \"-\", x1_tex, \"||\", \"}\\\\right)\",\n",
        "            \"\\\\left({\", \"1\", \"\\\\over\",\n",
        "            \"||\", x2_tex, \"-\", x1_tex, \"||^2\", \"}\\\\right)\",\n",
        "            tex_to_color_map={\n",
        "                x1_tex: BLUE_C,\n",
        "                \"m_1\": BLUE_C,\n",
        "                x2_tex: new_brown,\n",
        "                \"m_2\": new_brown,\n",
        "                a1_tex: YELLOW,\n",
        "            }\n",
        "        )\n",
        "        law.to_edge(UP)\n",
        "\n",
        "        force = law[:4]\n",
        "        constants = law[4:8]\n",
        "        unit_vect = law[8:19]\n",
        "        inverse_square = law[19:]\n",
        "        parts = VGroup(\n",
        "            force, unit_vect, inverse_square\n",
        "        )\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Force on\\\\\\\\mass 1\"),\n",
        "            OldTexText(\"Unit vector\\\\\\\\towards mass 2\"),\n",
        "            OldTexText(\"Inverse square\\\\\\\\law\"),\n",
        "        )\n",
        "\n",
        "        self.add(law)\n",
        "\n",
        "        braces = VGroup()\n",
        "        rects = VGroup()\n",
        "        for part, word in zip(parts, words):\n",
        "            brace = Brace(part, DOWN)\n",
        "            word.scale(0.8)\n",
        "            word.next_to(brace, DOWN)\n",
        "            rect = SurroundingRectangle(part)\n",
        "            rect.set_stroke(YELLOW, 1)\n",
        "            braces.add(brace)\n",
        "            rects.add(rect)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(rects[0]),\n",
        "            GrowFromCenter(braces[0]),\n",
        "            FadeIn(words[0], UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(rects[1]),\n",
        "            GrowFromCenter(braces[1]),\n",
        "            FadeIn(words[1], UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(rects[2]),\n",
        "            TransformFromCopy(*braces[1:3]),\n",
        "            FadeIn(words[2], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Position derivative\n",
        "        v1_tex = \"\\\\vec{\\\\textbf{v}}_1\"\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                x1_tex: BLUE_C,\n",
        "                v1_tex: RED,\n",
        "            }\n",
        "        }\n",
        "        x_deriv = OldTex(\n",
        "            \"{d\", x1_tex, \"\\\\over\", \"dt}\", \"=\", v1_tex, **kw\n",
        "        )\n",
        "        x_deriv.to_corner(UL)\n",
        "        v_deriv = OldTex(\n",
        "            \"{d\", v1_tex, \"\\\\over\", \"dt}\", \"=\", **kw\n",
        "        )\n",
        "\n",
        "        # Make way\n",
        "        law.generate_target()\n",
        "        lt = law.target\n",
        "        lt.to_edge(RIGHT)\n",
        "        lt[6].fade(1)\n",
        "        lt[:6].align_to(lt[6], RIGHT)\n",
        "        lt[:3].fade(1)\n",
        "        v_deriv.next_to(lt[3], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(x_deriv),\n",
        "            MoveToTarget(law),\n",
        "            braces[1:].align_to, lt, RIGHT,\n",
        "            MaintainPositionRelativeTo(words[1:], braces[1:]),\n",
        "            FadeOut(words[0]),\n",
        "            FadeOut(braces[0]),\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(x_deriv))\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                x_deriv.get_part_by_tex(v1_tex),\n",
        "                v_deriv.get_part_by_tex(v1_tex),\n",
        "            ),\n",
        "            Write(VGroup(*filter(\n",
        "                lambda m: m is not v_deriv.get_part_by_tex(v1_tex),\n",
        "                v_deriv,\n",
        "            )))\n",
        "        )\n",
        "\n",
        "        x_parts = law.get_parts_by_tex(x1_tex)\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                x_deriv.get_parts_by_tex(x1_tex),\n",
        "                x_parts.copy(),\n",
        "                remover=True,\n",
        "                path_arc=30 * DEGREES,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeAround,\n",
        "                x_parts\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExampleTypicalODE(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        examples = VGroup(\n",
        "            OldTex(\n",
        "                \"{\\\\dot x}(t) = k{x}(t)\",\n",
        "                tex_to_color_map={\n",
        "                    \"{\\\\dot x}\": BLUE,\n",
        "                    \"{x}\": BLUE,\n",
        "                },\n",
        "            ),\n",
        "            get_ode(),\n",
        "            OldTex(\n",
        "                \"{\\\\partial T\", \"\\\\over\", \"\\\\partial t} = \",\n",
        "                \"{\\\\partial^2 T\", \"\\\\over\", \"\\\\partial x^2}\", \"+\",\n",
        "                \"{\\\\partial^2 T\", \"\\\\over\", \"\\\\partial y^2}\", \"+\",\n",
        "                \"{\\\\partial^2 T\", \"\\\\over\", \"\\\\partial z^2}\",\n",
        "                tex_to_color_map={\n",
        "                    \"T\": RED,\n",
        "                }\n",
        "            ),\n",
        "        )\n",
        "        examples[1].get_parts_by_tex(\"theta\").set_color(GREEN)\n",
        "        examples.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        examples.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(examples[0], UP),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(examples[1], UP),\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=examples,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(examples[2], UP)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ShowDerivativeVideo(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Essence of\", \"Calculus\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        title2 = OldTexText(\"Essence of\", \"Linear Algebra\")\n",
        "        title2.scale(1.5)\n",
        "        title2.move_to(title, DOWN)\n",
        "\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect = rect.copy()\n",
        "        rect.set_style(\n",
        "            fill_opacity=1,\n",
        "            fill_color=BLACK,\n",
        "            stroke_width=0,\n",
        "        )\n",
        "        rect.next_to(title, DOWN)\n",
        "        animated_rect = AnimatedBoundary(rect)\n",
        "\n",
        "        self.add(title, rect)\n",
        "        self.add(animated_rect)\n",
        "        self.wait(5)\n",
        "        self.play(ReplacementTransform(title, title2))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SubtleAirCurrents(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class DefineODE(Scene):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"length\": 2,\n",
        "            \"top_point\": 5 * RIGHT + 2 * UP,\n",
        "            \"initial_theta\": 150 * DEGREES,\n",
        "            \"mu\": 0.3,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_axis_config\": {\"unit_size\": 0.75},\n",
        "            \"y_max\": PI,\n",
        "            \"y_min\": -PI,\n",
        "            \"x_max\": 10,\n",
        "            \"x_axis_config\": {\n",
        "                \"numbers_to_show\": range(2, 10, 2),\n",
        "                \"unit_size\": 1,\n",
        "            }\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.write_differential_equation()\n",
        "        self.dont_know_the_value()\n",
        "        self.show_value_slope_curvature()\n",
        "        self.write_ode()\n",
        "        self.show_second_order()\n",
        "        self.show_higher_order_examples()\n",
        "        self.show_changing_curvature_group()\n",
        "\n",
        "    def add_graph(self):\n",
        "        pendulum = Pendulum(**self.pendulum_config)\n",
        "        axes = ThetaVsTAxes(**self.axes_config)\n",
        "\n",
        "        axes.center()\n",
        "        axes.to_corner(DL)\n",
        "        graph = axes.get_live_drawn_graph(pendulum)\n",
        "\n",
        "        pendulum.start_swinging()\n",
        "        self.add(axes, pendulum, graph)\n",
        "\n",
        "        self.pendulum = pendulum\n",
        "        self.axes = axes\n",
        "        self.graph = graph\n",
        "\n",
        "    def write_differential_equation(self):\n",
        "        de_word = OldTexText(\"Differential\", \"Equation\")\n",
        "        de_word.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        equation = get_ode()\n",
        "        equation.next_to(de_word, DOWN)\n",
        "        thetas = equation.get_parts_by_tex(\"\\\\theta\")\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(v, 1.2 * v)\n",
        "            for v in compass_directions(25)\n",
        "        ])\n",
        "        lines.replace(equation, stretch=True)\n",
        "        lines.scale(1.5)\n",
        "        lines.set_stroke(YELLOW)\n",
        "        lines.shuffle()\n",
        "\n",
        "        self.add(equation)\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            ShowPassingFlashWithThinningStrokeWidth(\n",
        "                lines,\n",
        "                lag_ratio=0.002,\n",
        "                run_time=1.5,\n",
        "                time_width=0.9,\n",
        "                n_segments=5,\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeInFromDown(de_word))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, thetas,\n",
        "                lambda m: (m.shift, 0.25 * DOWN),\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.de_word = de_word\n",
        "        self.equation = equation\n",
        "\n",
        "    def dont_know_the_value(self):\n",
        "        graph = self.graph\n",
        "        pendulum = self.pendulum\n",
        "\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"?\").move_to(graph.point_from_proportion(a))\n",
        "            for a in np.linspace(0, 1, 20)\n",
        "        ])\n",
        "        q_marks.set_stroke(width=0, background=True)\n",
        "        self.play(\n",
        "            VFadeOut(graph),\n",
        "            FadeOut(pendulum),\n",
        "            LaggedStart(*[\n",
        "                UpdateFromAlphaFunc(\n",
        "                    q_mark,\n",
        "                    lambda m, a: m.set_height(0.5 * (1 + a)).set_fill(\n",
        "                        opacity=there_and_back(a)\n",
        "                    ),\n",
        "                )\n",
        "                for q_mark in q_marks\n",
        "            ], lag_ratio=0.01, run_time=2)\n",
        "        )\n",
        "        self.remove(q_marks)\n",
        "\n",
        "    def show_value_slope_curvature(self):\n",
        "        axes = self.axes\n",
        "        p = self.pendulum\n",
        "        graph = axes.get_graph(\n",
        "            lambda t: p.initial_theta * np.cos(\n",
        "                np.sqrt(p.gravity / p.length) * t\n",
        "            ) * np.exp(-p.mu * t / 2)\n",
        "        )\n",
        "\n",
        "        tex_config = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{\\\\theta}\": BLUE,\n",
        "                \"{\\\\dot\\\\theta}\": RED,\n",
        "                \"{\\\\ddot\\\\theta}\": YELLOW,\n",
        "            },\n",
        "            \"height\": 0.5,\n",
        "        }\n",
        "        theta, d_theta, dd_theta = [\n",
        "            OldTex(\n",
        "                \"{\" + s + \"\\\\theta}(t)\",\n",
        "                **tex_config\n",
        "            )\n",
        "            for s in (\"\", \"\\\\dot\", \"\\\\ddot\")\n",
        "        ]\n",
        "\n",
        "        t_tracker = ValueTracker(2.5)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def get_point(t):\n",
        "            return graph.point_from_proportion(t / axes.x_max)\n",
        "\n",
        "        def get_dot():\n",
        "            return Dot(get_point(get_t())).scale(0.5)\n",
        "\n",
        "        def get_v_line():\n",
        "            point = get_point(get_t())\n",
        "            x_point = axes.x_axis.number_to_point(\n",
        "                axes.x_axis.point_to_number(point)\n",
        "            )\n",
        "            return DashedLine(\n",
        "                x_point, point,\n",
        "                dash_length=0.025,\n",
        "                stroke_color=BLUE,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "\n",
        "        def get_tangent_line(curve, alpha):\n",
        "            line = Line(\n",
        "                ORIGIN, 1.5 * RIGHT,\n",
        "                color=RED,\n",
        "                stroke_width=1.5,\n",
        "            )\n",
        "            da = 0.0001\n",
        "            p0 = curve.point_from_proportion(alpha)\n",
        "            p1 = curve.point_from_proportion(alpha - da)\n",
        "            p2 = curve.point_from_proportion(alpha + da)\n",
        "            angle = angle_of_vector(p2 - p1)\n",
        "            line.rotate(angle)\n",
        "            line.move_to(p0)\n",
        "            return line\n",
        "\n",
        "        def get_slope_line():\n",
        "            return get_tangent_line(\n",
        "                graph, get_t() / axes.x_max\n",
        "            )\n",
        "\n",
        "        def get_curve():\n",
        "            curve = VMobject()\n",
        "            t = get_t()\n",
        "            curve.set_points_smoothly([\n",
        "                get_point(t + a)\n",
        "                for a in np.linspace(-0.5, 0.5, 11)\n",
        "            ])\n",
        "            curve.set_stroke(YELLOW, 1)\n",
        "            return curve\n",
        "\n",
        "        v_line = always_redraw(get_v_line)\n",
        "        dot = always_redraw(get_dot)\n",
        "        slope_line = always_redraw(get_slope_line)\n",
        "        curve = always_redraw(get_curve)\n",
        "\n",
        "        theta.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "        d_theta.next_to(slope_line.get_end(), UP, SMALL_BUFF)\n",
        "        dd_theta.next_to(curve.get_end(), RIGHT, SMALL_BUFF)\n",
        "        thetas = VGroup(theta, d_theta, dd_theta)\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"= Height\").set_color(BLUE),\n",
        "            OldTexText(\"= Slope\").set_color(RED),\n",
        "            OldTexText(\"= ``Curvature''\").set_color(YELLOW),\n",
        "        )\n",
        "        words.scale(0.75)\n",
        "        for word, sym in zip(words, thetas):\n",
        "            word.next_to(sym, RIGHT, buff=2 * SMALL_BUFF)\n",
        "            sym.word = word\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            FadeInFromPoint(dot, v_line.get_start()),\n",
        "            FadeIn(theta, DOWN),\n",
        "            FadeIn(theta.word, DOWN),\n",
        "        )\n",
        "        self.add(slope_line, dot)\n",
        "        self.play(\n",
        "            ShowCreation(slope_line),\n",
        "            FadeIn(d_theta, LEFT),\n",
        "            FadeIn(d_theta.word, LEFT),\n",
        "        )\n",
        "\n",
        "        a_tracker = ValueTracker(0)\n",
        "        curve_copy = curve.copy()\n",
        "        changing_slope = always_redraw(\n",
        "            lambda: get_tangent_line(\n",
        "                curve_copy,\n",
        "                a_tracker.get_value(),\n",
        "            ).set_stroke(\n",
        "                opacity=there_and_back(a_tracker.get_value())\n",
        "            )\n",
        "        )\n",
        "        self.add(curve, dot)\n",
        "        self.play(\n",
        "            ShowCreation(curve),\n",
        "            FadeIn(dd_theta, LEFT),\n",
        "            FadeIn(dd_theta.word, LEFT),\n",
        "        )\n",
        "        self.add(changing_slope)\n",
        "        self.play(\n",
        "            a_tracker.set_value, 1,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(changing_slope, a_tracker)\n",
        "\n",
        "        self.t_tracker = t_tracker\n",
        "        self.curvature_group = VGroup(\n",
        "            v_line, slope_line, curve, dot\n",
        "        )\n",
        "        self.curvature_group_labels = VGroup(thetas, words)\n",
        "        self.fake_graph = graph\n",
        "\n",
        "    def write_ode(self):\n",
        "        equation = self.equation\n",
        "        axes = self.axes\n",
        "        de_word = self.de_word\n",
        "\n",
        "        ts = equation.get_parts_by_tex(\"{t}\")\n",
        "        t_rects = VGroup(*map(SurroundingRectangle, ts))  # Rawr\n",
        "        x_axis = axes.x_axis\n",
        "        x_axis_line = Line(\n",
        "            x_axis.get_start(), x_axis.get_end(),\n",
        "            stroke_color=YELLOW,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "\n",
        "        ordinary = OldTexText(\"Ordinary\")\n",
        "        de_word.generate_target()\n",
        "        group = VGroup(ordinary, de_word.target)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP)\n",
        "        ordinary_underline = Line(LEFT, RIGHT)\n",
        "        ordinary_underline.replace(ordinary, dim_to_match=0)\n",
        "        ordinary_underline.next_to(ordinary, DOWN, SMALL_BUFF)\n",
        "        ordinary_underline.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(\n",
        "                t_rects,\n",
        "                lag_ratio=0.8\n",
        "            ),\n",
        "            ShowCreationThenFadeOut(x_axis_line)\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(de_word),\n",
        "            FadeIn(ordinary, RIGHT),\n",
        "            GrowFromCenter(ordinary_underline)\n",
        "        )\n",
        "        self.play(FadeOut(ordinary_underline))\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(ordinary, de_word)\n",
        "        ode_word = self.ode_word = VGroup(*ordinary, *de_word)\n",
        "        ode_initials = VGroup(*[word[0] for word in ode_word])\n",
        "        ode_initials.generate_target()\n",
        "        ode_initials.target.scale(1.2)\n",
        "        ode_initials.target.set_color(PINK)\n",
        "        ode_initials.target.arrange(\n",
        "            RIGHT, buff=0.5 * SMALL_BUFF, aligned_edge=DOWN\n",
        "        )\n",
        "        ode_initials.target.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        ode_remaining_letters = VGroup(*it.chain(*[\n",
        "            word[1:] for word in ode_word\n",
        "        ]))\n",
        "        ode_remaining_letters.generate_target()\n",
        "        for mob in ode_remaining_letters.target:\n",
        "            mob.shift(0.2 * UP)\n",
        "            mob.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(ode_initials),\n",
        "            MoveToTarget(ode_remaining_letters, lag_ratio=0.05),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ode_initials = ode_initials\n",
        "\n",
        "    def show_second_order(self):\n",
        "        so = OldTexText(\"Second order\")\n",
        "        so.scale(1.4)\n",
        "        ode = self.ode_initials\n",
        "        ode.generate_target()\n",
        "        group = VGroup(so, ode.target)\n",
        "        group.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        second_deriv = self.equation[:5]\n",
        "\n",
        "        self.play(\n",
        "            Write(so),\n",
        "            MoveToTarget(ode),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FocusOn(second_deriv))\n",
        "        self.play(\n",
        "            Indicate(second_deriv, color=YELLOW),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.second_order_word = so\n",
        "\n",
        "    def show_higher_order_examples(self):\n",
        "        main_example = self.get_main_example()\n",
        "        tex_config = {\"tex_to_color_map\": {\"{x}\": BLUE}}\n",
        "        example3 = VGroup(\n",
        "            OldTexText(\"Third order ODE\"),\n",
        "            OldTex(\n",
        "                \"\\\\dddot {x}(t) + \\\\dot {x}(t)^2 = 0\",\n",
        "                **tex_config,\n",
        "            )\n",
        "        )\n",
        "        example4 = VGroup(\n",
        "            OldTexText(\"Fourth order ODE\"),\n",
        "            OldTex(\n",
        "                \"\\\\ddddot {x}(t) +\",\n",
        "                \"a\\\\dddot {x}(t) \\\\dot {x}(t) + \",\n",
        "                \"b \\\\ddot {x}(t) {x}(t)\",\n",
        "                \"= 1\",\n",
        "                **tex_config,\n",
        "            )\n",
        "        )\n",
        "        for example in [example3, example4]:\n",
        "            example[0].scale(1.2)\n",
        "            example.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "            example.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(main_example),\n",
        "            FadeIn(example3),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(example3),\n",
        "            FadeIn(example4),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(example4),\n",
        "            FadeIn(main_example),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_main_example(self):\n",
        "        return VGroup(\n",
        "            self.second_order_word,\n",
        "            self.ode_initials,\n",
        "            self.equation\n",
        "        )\n",
        "\n",
        "    def show_changing_curvature_group(self):\n",
        "        t_tracker = self.t_tracker\n",
        "        curvature_group = self.curvature_group\n",
        "        labels = self.curvature_group_labels\n",
        "        graph = VMobject()\n",
        "        graph.pointwise_become_partial(\n",
        "            self.fake_graph,\n",
        "            t_tracker.get_value() / self.axes.x_max,\n",
        "            1,\n",
        "        )\n",
        "        dashed_graph = DashedVMobject(graph, num_dashes=100)\n",
        "        dashed_graph.set_stroke(GREEN, 1)\n",
        "\n",
        "        self.play(FadeOut(labels))\n",
        "        self.add(dashed_graph, curvature_group)\n",
        "        self.play(\n",
        "            t_tracker.set_value, 10,\n",
        "            ShowCreation(dashed_graph),\n",
        "            run_time=15,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Largely a copy of DefineODE, which is not great.\n",
        "# But what can you do?\n",
        "class SecondOrderEquationExample(DefineODE):\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.write_differential_equation()\n",
        "        self.show_value_slope_curvature()\n",
        "        self.show_higher_order_examples()\n",
        "        self.show_changing_curvature_group()\n",
        "\n",
        "    def add_graph(self):\n",
        "        axes = self.axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=10.5,\n",
        "            y_min=-2.5,\n",
        "            y_max=2.5,\n",
        "        )\n",
        "        axes.center()\n",
        "        axes.to_edge(DOWN)\n",
        "        x_t = OldTex(\"x\", \"(t)\")\n",
        "        x_t.set_color_by_tex(\"x\", BLUE)\n",
        "        t = OldTex(\"t\")\n",
        "        t.next_to(axes.x_axis.get_right(), UP)\n",
        "        x_t.next_to(axes.y_axis.get_top(), UP)\n",
        "\n",
        "        axes.add(t, x_t)\n",
        "        axes.add_coordinates()\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "    def write_differential_equation(self):\n",
        "        de_word = OldTexText(\"Differential\", \"Equation\")\n",
        "        de_word.scale(1.25)\n",
        "        de_word.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        so_word = OldTexText(\"Second Order\")\n",
        "        so_word.scale(1.25)\n",
        "        de_word.generate_target()\n",
        "        group = VGroup(so_word, de_word.target)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        so_word.align_to(de_word.target[0], DOWN)\n",
        "        so_line = Line(LEFT, RIGHT, color=YELLOW)\n",
        "        so_line.match_width(so_word)\n",
        "        so_line.next_to(so_word, DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"{\\\\ddot x}(t)\", \"=\",\n",
        "            \"-\\\\mu\", \"{\\\\dot x}(t)\",\n",
        "            \"-\", \"\\\\omega\", \"{x}(t)\",\n",
        "            tex_to_color_map={\n",
        "                \"{x}\": BLUE,\n",
        "                \"{\\\\dot x}\": RED,\n",
        "                \"{\\\\ddot x}\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        equation.next_to(de_word, DOWN)\n",
        "\n",
        "        dd_x_part = equation[:2]\n",
        "        dd_x_rect = SurroundingRectangle(dd_x_part)\n",
        "\n",
        "        self.add(de_word, equation)\n",
        "        self.play(\n",
        "            MoveToTarget(de_word),\n",
        "            FadeIn(so_word, RIGHT),\n",
        "            GrowFromCenter(so_line),\n",
        "        )\n",
        "        self.play(ReplacementTransform(so_line, dd_x_rect))\n",
        "        self.play(FadeOut(dd_x_rect))\n",
        "\n",
        "        self.equation = equation\n",
        "        self.title = VGroup(*so_word, *de_word)\n",
        "\n",
        "    def show_value_slope_curvature(self):\n",
        "        axes = self.axes\n",
        "        graph = axes.get_graph(\n",
        "            lambda t: -2.5 * np.cos(2 * t) * np.exp(-0.2 * t)\n",
        "        )\n",
        "\n",
        "        tex_config = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{x}\": BLUE,\n",
        "                \"{\\\\dot x}\": RED,\n",
        "                \"{\\\\ddot x}\": YELLOW,\n",
        "            },\n",
        "            \"height\": 0.5,\n",
        "        }\n",
        "        x, d_x, dd_x = [\n",
        "            OldTex(\n",
        "                \"{\" + s + \"x}(t)\",\n",
        "                **tex_config\n",
        "            )\n",
        "            for s in (\"\", \"\\\\dot \", \"\\\\ddot \")\n",
        "        ]\n",
        "\n",
        "        t_tracker = ValueTracker(1.25)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def get_point(t):\n",
        "            return graph.point_from_proportion(t / axes.x_max)\n",
        "\n",
        "        def get_dot():\n",
        "            return Dot(get_point(get_t())).scale(0.5)\n",
        "\n",
        "        def get_v_line():\n",
        "            point = get_point(get_t())\n",
        "            x_point = axes.x_axis.number_to_point(\n",
        "                axes.x_axis.point_to_number(point)\n",
        "            )\n",
        "            return DashedLine(\n",
        "                x_point, point,\n",
        "                dash_length=0.025,\n",
        "                stroke_color=BLUE,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "\n",
        "        def get_tangent_line(curve, alpha):\n",
        "            line = Line(\n",
        "                ORIGIN, 1.5 * RIGHT,\n",
        "                color=RED,\n",
        "                stroke_width=1.5,\n",
        "            )\n",
        "            da = 0.0001\n",
        "            p0 = curve.point_from_proportion(alpha)\n",
        "            p1 = curve.point_from_proportion(alpha - da)\n",
        "            p2 = curve.point_from_proportion(alpha + da)\n",
        "            angle = angle_of_vector(p2 - p1)\n",
        "            line.rotate(angle)\n",
        "            line.move_to(p0)\n",
        "            return line\n",
        "\n",
        "        def get_slope_line():\n",
        "            return get_tangent_line(\n",
        "                graph, get_t() / axes.x_max\n",
        "            )\n",
        "\n",
        "        def get_curve():\n",
        "            curve = VMobject()\n",
        "            t = get_t()\n",
        "            curve.set_points_smoothly([\n",
        "                get_point(t + a)\n",
        "                for a in np.linspace(-0.5, 0.5, 11)\n",
        "            ])\n",
        "            curve.set_stroke(YELLOW, 1)\n",
        "            return curve\n",
        "\n",
        "        v_line = always_redraw(get_v_line)\n",
        "        dot = always_redraw(get_dot)\n",
        "        slope_line = always_redraw(get_slope_line)\n",
        "        curve = always_redraw(get_curve)\n",
        "\n",
        "        x.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "        d_x.next_to(slope_line.get_end(), UP, SMALL_BUFF)\n",
        "        dd_x.next_to(curve.get_end(), RIGHT, SMALL_BUFF)\n",
        "        xs = VGroup(x, d_x, dd_x)\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"= Height\").set_color(BLUE),\n",
        "            OldTexText(\"= Slope\").set_color(RED),\n",
        "            OldTexText(\"= ``Curvature''\").set_color(YELLOW),\n",
        "        )\n",
        "        words.scale(0.75)\n",
        "        for word, sym in zip(words, xs):\n",
        "            word.next_to(sym, RIGHT, buff=2 * SMALL_BUFF)\n",
        "            sym.word = word\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            FadeInFromPoint(dot, v_line.get_start()),\n",
        "            FadeIn(x, DOWN),\n",
        "            FadeIn(x.word, DOWN),\n",
        "        )\n",
        "        self.add(slope_line, dot)\n",
        "        self.play(\n",
        "            ShowCreation(slope_line),\n",
        "            FadeIn(d_x, LEFT),\n",
        "            FadeIn(d_x.word, LEFT),\n",
        "        )\n",
        "\n",
        "        a_tracker = ValueTracker(0)\n",
        "        curve_copy = curve.copy()\n",
        "        changing_slope = always_redraw(\n",
        "            lambda: get_tangent_line(\n",
        "                curve_copy,\n",
        "                a_tracker.get_value(),\n",
        "            ).set_stroke(\n",
        "                opacity=there_and_back(a_tracker.get_value())\n",
        "            )\n",
        "        )\n",
        "        self.add(curve, dot)\n",
        "        self.play(\n",
        "            ShowCreation(curve),\n",
        "            FadeIn(dd_x, LEFT),\n",
        "            FadeIn(dd_x.word, LEFT),\n",
        "        )\n",
        "        self.add(changing_slope)\n",
        "        self.play(\n",
        "            a_tracker.set_value, 1,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(changing_slope, a_tracker)\n",
        "\n",
        "        self.t_tracker = t_tracker\n",
        "        self.curvature_group = VGroup(\n",
        "            v_line, slope_line, curve, dot\n",
        "        )\n",
        "        self.curvature_group_labels = VGroup(xs, words)\n",
        "        self.fake_graph = graph\n",
        "\n",
        "    def get_main_example(self):\n",
        "        return VGroup(\n",
        "            self.equation,\n",
        "            self.title,\n",
        "        )\n",
        "\n",
        "# class VisualizeHeightSlopeCurvature(DefineODE):\n",
        "#     CONFIG = {\n",
        "#         \"pendulum_config\": {\n",
        "#             \"length\": 2,\n",
        "#             \"top_point\": 5 * RIGHT + 2 * UP,\n",
        "#             \"initial_theta\": 175 * DEGREES,\n",
        "#             \"mu\": 0.3,\n",
        "#         },\n",
        "#     }\n",
        "\n",
        "#     def construct(self):\n",
        "#         self.add_graph()\n",
        "#         self.show_value_slope_curvature()\n",
        "#         self.show_changing_curvature_group()\n",
        "\n",
        "\n",
        "class ODEvsPDEinFrames(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_color\": GREY_E}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        frames = VGroup(*[\n",
        "            ScreenRectangle(\n",
        "                height=3.5,\n",
        "                fill_opacity=1,\n",
        "                fill_color=BLACK,\n",
        "                stroke_width=0,\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        frames.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        frames.shift(0.5 * DOWN)\n",
        "\n",
        "        animated_frames = VGroup(*[\n",
        "            AnimatedBoundary(\n",
        "                frame,\n",
        "                cycle_rate=0.2,\n",
        "                max_stroke_width=1,\n",
        "            )\n",
        "            for frame in frames\n",
        "        ])\n",
        "\n",
        "        titles = VGroup(\n",
        "            # OldTexText(\"ODEs\"),\n",
        "            # OldTexText(\"PDEs\"),\n",
        "            OldTexText(\"Ordinary\", \"Differential\", \"Equations\"),\n",
        "            OldTexText(\"Partial\", \"Differential\", \"Equations\"),\n",
        "        )\n",
        "        for title, frame in zip(titles, frames):\n",
        "            title.arrange(\n",
        "                DOWN,\n",
        "                buff=MED_SMALL_BUFF,\n",
        "                aligned_edge=LEFT\n",
        "            )\n",
        "            title.next_to(frame, UP, MED_LARGE_BUFF)\n",
        "            title.initials = VGroup(*[\n",
        "                part[0] for part in title\n",
        "            ])\n",
        "        titles[0][1].shift(0.05 * UP)\n",
        "\n",
        "        # ODE content\n",
        "        ode = get_ode()\n",
        "        ode.set_width(frames[0].get_width() - MED_LARGE_BUFF)\n",
        "        ode.next_to(frames[0].get_top(), DOWN)\n",
        "        ts = ode.get_parts_by_tex(\"{t}\")\n",
        "        one_input = OldTexText(\"One input\")\n",
        "        one_input.next_to(frames[0].get_bottom(), UP)\n",
        "        o_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                one_input.get_top(),\n",
        "                t.get_bottom(),\n",
        "                buff=0.2,\n",
        "                color=WHITE,\n",
        "                max_tip_length_to_length_ratio=0.075,\n",
        "                path_arc=pa\n",
        "            )\n",
        "            for t, pa in zip(ts, [-0.7, 0, 0.7])\n",
        "        ])\n",
        "        o_arrows.set_stroke(width=3)\n",
        "        frames[0].add(ode, one_input, o_arrows)\n",
        "\n",
        "        # PDE content\n",
        "        pde = OldTex(\n",
        "            \"\"\"\n",
        "            \\\\frac{\\\\partial T}{\\\\partial t}\n",
        "            {(x, y, t)} =\n",
        "            \\\\frac{\\\\partial^2 T}{\\\\partial x^2}\n",
        "            {(x, y, t)} +\n",
        "            \\\\frac{\\\\partial^2 T}{\\\\partial y^2}\n",
        "            {(x, y, t)}\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\"{(x, y, t)}\": WHITE}\n",
        "        )\n",
        "        pde.set_width(frames[1].get_width() - MED_LARGE_BUFF)\n",
        "        pde.next_to(frames[1].get_top(), DOWN)\n",
        "        inputs = pde.get_parts_by_tex(\"{(x, y, t)}\")\n",
        "        multi_input = OldTexText(\"Multiple inputs\")\n",
        "        multi_input.next_to(frames[1].get_bottom(), UP)\n",
        "        p_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                multi_input.get_top(),\n",
        "                mob.get_bottom(),\n",
        "                buff=0.2,\n",
        "                color=WHITE,\n",
        "                max_tip_length_to_length_ratio=0.075,\n",
        "                path_arc=pa\n",
        "            )\n",
        "            for mob, pa in zip(inputs, [-0.7, 0, 0.7])\n",
        "        ])\n",
        "        p_arrows.set_stroke(width=3)\n",
        "        frames[1].add(pde, multi_input, p_arrows)\n",
        "\n",
        "        self.add(\n",
        "            frames[0],\n",
        "            animated_frames[0],\n",
        "            titles[0]\n",
        "        )\n",
        "        self.play(\n",
        "            Write(one_input),\n",
        "            ShowCreation(o_arrows, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(titles[0].initials.set_color, BLUE)\n",
        "        self.wait(7)\n",
        "\n",
        "        # Transition\n",
        "        self.play(\n",
        "            TransformFromCopy(*titles),\n",
        "            TransformFromCopy(*frames),\n",
        "        )\n",
        "        self.play(VFadeIn(animated_frames[1]))\n",
        "        self.wait()\n",
        "        self.play(titles[1].initials.set_color, YELLOW)\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class ReferencePiCollisionStateSpaces(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_color\": GREY_E}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"The block collision puzzle\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        frames = VGroup(*[\n",
        "            ScreenRectangle(\n",
        "                height=3.5,\n",
        "                fill_opacity=1,\n",
        "                fill_color=BLACK,\n",
        "                stroke_width=0,\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        frames.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        boundary = AnimatedBoundary(frames)\n",
        "        self.add(frames, boundary)\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class XComponentArrows(Scene):\n",
        "    def construct(self):\n",
        "        field = VectorField(\n",
        "            lambda p: np.array([p[1], 0, 0])\n",
        "        )\n",
        "        field.set_opacity(0.75)\n",
        "        for u in (1, -1):\n",
        "            field.sort(lambda p: u * p[0])\n",
        "            self.play(LaggedStartMap(\n",
        "                GrowArrow, field,\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1\n",
        "            ))\n",
        "            self.play(FadeOut(field))\n",
        "\n",
        "\n",
        "class BreakingSecondOrderIntoTwoFirstOrder(IntroduceVectorField):\n",
        "    def construct(self):\n",
        "        ode = OldTex(\n",
        "            \"{\\\\ddot\\\\theta}\", \"(t)\", \"=\",\n",
        "            \"-\\\\mu\", \"{\\\\dot\\\\theta}\", \"(t)\"\n",
        "            \"-(g / L)\\\\sin\\\\big(\", \"{\\\\theta}\", \"(t)\\\\big)\",\n",
        "            tex_to_color_map={\n",
        "                \"{\\\\ddot\\\\theta}\": RED,\n",
        "                \"{\\\\dot\\\\theta}\": YELLOW,\n",
        "                \"{\\\\theta}\": BLUE,\n",
        "                # \"{t}\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        so_word = OldTexText(\"Second order ODE\")\n",
        "        sys_word = OldTexText(\"System of two first order ODEs\")\n",
        "\n",
        "        system1 = self.get_system(\"{\\\\theta}\", \"{\\\\dot\\\\theta}\")\n",
        "        system2 = self.get_system(\"{\\\\theta}\", \"{\\\\omega}\")\n",
        "\n",
        "        so_word.to_edge(UP)\n",
        "        ode.next_to(so_word, DOWN)\n",
        "        sys_word.move_to(ORIGIN)\n",
        "        system1.next_to(sys_word, DOWN)\n",
        "        system2.move_to(system1)\n",
        "\n",
        "        theta_dots = VGroup(*filter(\n",
        "            lambda m: (\n",
        "                isinstance(m, SingleStringTex) and\n",
        "                \"{\\\\dot\\\\theta}\" == m.get_tex()\n",
        "            ),\n",
        "            system1.get_family(),\n",
        "        ))\n",
        "\n",
        "        self.add(ode)\n",
        "        self.play(FadeIn(so_word, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                ode[3:], system1[3].get_entries()[1],\n",
        "            ),\n",
        "            TransformFromCopy(ode[2], system1[2]),\n",
        "            TransformFromCopy(\n",
        "                ode[:2], VGroup(\n",
        "                    system1[0],\n",
        "                    system1[1].get_entries()[1],\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(system1[1].get_brackets()),\n",
        "            FadeIn(system1[1].get_entries()[0]),\n",
        "            FadeIn(system1[3].get_brackets()),\n",
        "            FadeIn(system1[3].get_entries()[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(sys_word)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeAround,\n",
        "            theta_dots,\n",
        "            surrounding_rectangle_config={\n",
        "                \"color\": PINK,\n",
        "            }\n",
        "        ))\n",
        "\n",
        "        self.play(ReplacementTransform(system1, system2))\n",
        "        self.wait()\n",
        "\n",
        "    def get_system(self, tex1, tex2):\n",
        "        system = VGroup(\n",
        "            OldTex(\"d \\\\over dt\"),\n",
        "            self.get_vector_symbol(\n",
        "                tex1 + \"(t)\",\n",
        "                tex2 + \"(t)\",\n",
        "            ),\n",
        "            OldTex(\"=\"),\n",
        "            self.get_vector_symbol(\n",
        "                tex2 + \"(t)\",\n",
        "                \"\".join([\n",
        "                    \"-\\\\mu\", tex2, \"(t)\",\n",
        "                    \"-(g / L) \\\\sin\\\\big(\",\n",
        "                    tex1, \"(t)\", \"\\\\big)\",\n",
        "                ])\n",
        "            )\n",
        "        )\n",
        "        system.arrange(RIGHT)\n",
        "        return system\n",
        "\n",
        "\n",
        "class FromODEToVectorField(Scene):\n",
        "    def construct(self):\n",
        "        matrix_config = {\n",
        "            \"bracket_v_buff\": 2 * SMALL_BUFF,\n",
        "            \"element_to_mobject_config\": {\n",
        "                \"tex_to_color_map\": {\n",
        "                    \"x\": GREEN,\n",
        "                    \"y\": RED,\n",
        "                    \"z\": BLUE,\n",
        "                },\n",
        "            }\n",
        "        }\n",
        "        vect = get_vector_symbol(\n",
        "            \"x(t)\", \"y(t)\", \"z(t)\",\n",
        "            **matrix_config,\n",
        "        )\n",
        "        d_vect = get_vector_symbol(\n",
        "            \"\\\\sigma\\\\big(y(t) - x(t)\\\\big)\",\n",
        "            \"x(t)\\\\big(\\\\rho - z(t)\\\\big) - y(t)\",\n",
        "            \"x(t)y(t) - \\\\beta z(t)\",\n",
        "            **matrix_config\n",
        "        )\n",
        "        equation = VGroup(\n",
        "            OldTex(\"d \\\\over dt\").scale(1.5),\n",
        "            vect,\n",
        "            OldTex(\"=\"),\n",
        "            d_vect\n",
        "        )\n",
        "        equation.scale(0.8)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        arrow = Vector(DOWN, color=YELLOW)\n",
        "        arrow.next_to(equation, DOWN)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LorenzVectorField(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ThreeBodiesInSpace(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"masses\": [1, 6, 3],\n",
        "        \"colors\": [RED_E, GREEN_E, BLUE_E],\n",
        "        \"G\": 0.5,\n",
        "        \"play_time\": 60,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_bodies()\n",
        "        self.add_trajectories()\n",
        "        self.let_play()\n",
        "\n",
        "    def add_axes(self):\n",
        "        axes = self.axes = self.get_axes()\n",
        "        axes.set_stroke(width=0.5)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Orient\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-110 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "    def add_bodies(self):\n",
        "        masses = self.masses\n",
        "        colors = self.colors\n",
        "\n",
        "        bodies = self.bodies = VGroup()\n",
        "        velocity_vectors = VGroup()\n",
        "\n",
        "        centers = self.get_initial_positions()\n",
        "\n",
        "        for mass, color, center in zip(masses, colors, centers):\n",
        "            body = self.get_sphere(\n",
        "                checkerboard_colors=[\n",
        "                    color, color\n",
        "                ],\n",
        "                color=color,\n",
        "                stroke_width=0.1,\n",
        "            )\n",
        "            body.set_opacity(0.75)\n",
        "            body.mass = mass\n",
        "            body.radius = 0.08 * np.sqrt(mass)\n",
        "            body.set_width(2 * body.radius)\n",
        "\n",
        "            body.point = center\n",
        "            body.move_to(center)\n",
        "\n",
        "            body.velocity = self.get_initial_velocity(\n",
        "                center, centers, mass\n",
        "            )\n",
        "\n",
        "            vect = self.get_velocity_vector_mob(body)\n",
        "\n",
        "            bodies.add(body)\n",
        "            velocity_vectors.add(vect)\n",
        "\n",
        "        total_mass = np.sum([body.mass for body in bodies])\n",
        "        center_of_mass = reduce(op.add, [\n",
        "            body.mass * body.get_center() / total_mass\n",
        "            for body in bodies\n",
        "        ])\n",
        "        average_momentum = reduce(op.add, [\n",
        "            body.mass * body.velocity / total_mass\n",
        "            for body in bodies\n",
        "        ])\n",
        "        for body in bodies:\n",
        "            body.shift(-center_of_mass)\n",
        "            body.velocity -= average_momentum\n",
        "\n",
        "    def get_initial_positions(self):\n",
        "        return [\n",
        "            np.dot(\n",
        "                4 * (np.random.random(3) - 0.5),\n",
        "                [RIGHT, UP, OUT]\n",
        "            )\n",
        "            for x in range(len(self.masses))\n",
        "        ]\n",
        "\n",
        "    def get_initial_velocity(self, center, centers, mass):\n",
        "        to_others = [\n",
        "            center - center2\n",
        "            for center2 in centers\n",
        "        ]\n",
        "        velocity = 0.2 * mass * normalize(np.cross(*filter(\n",
        "            lambda diff: get_norm(diff) > 0,\n",
        "            to_others\n",
        "        )))\n",
        "        return velocity\n",
        "\n",
        "    def add_trajectories(self):\n",
        "        def update_trajectory(traj, dt):\n",
        "            new_point = traj.body.point\n",
        "            if get_norm(new_point - traj.get_points()[-1]) > 0.01:\n",
        "                traj.add_smooth_curve_to(new_point)\n",
        "\n",
        "        for body in self.bodies:\n",
        "            traj = VMobject()\n",
        "            traj.body = body\n",
        "            traj.start_new_path(body.point)\n",
        "            traj.set_stroke(body.color, 1, opacity=0.75)\n",
        "            traj.add_updater(update_trajectory)\n",
        "            self.add(traj, body)\n",
        "\n",
        "    def let_play(self):\n",
        "        bodies = self.bodies\n",
        "        bodies.add_updater(self.update_bodies)\n",
        "        # Break it up to see partial files as\n",
        "        # it's rendered\n",
        "        self.add(bodies)\n",
        "        for x in range(int(self.play_time)):\n",
        "            self.wait()\n",
        "\n",
        "    #\n",
        "    def get_velocity_vector_mob(self, body):\n",
        "        def draw_vector():\n",
        "            center = body.get_center()\n",
        "            vect = Arrow(\n",
        "                center,\n",
        "                center + body.velocity,\n",
        "                buff=0,\n",
        "                color=RED,\n",
        "            )\n",
        "            vect.set_shade_in_3d(True)\n",
        "            return vect\n",
        "            # length = vect.get_length()\n",
        "            # if length > 2:\n",
        "            #     vect.scale(\n",
        "            #         2 / length,\n",
        "            #         about_point=vect.get_start(),\n",
        "            #     )\n",
        "        return always_redraw(draw_vector)\n",
        "\n",
        "    def update_bodies(self, bodies, dt):\n",
        "        G = self.G\n",
        "\n",
        "        num_mid_steps = 1000\n",
        "        for x in range(num_mid_steps):\n",
        "            for body in bodies:\n",
        "                acceleration = np.zeros(3)\n",
        "                for body2 in bodies:\n",
        "                    if body2 is body:\n",
        "                        continue\n",
        "                    diff = body2.point - body.point\n",
        "                    m2 = body2.mass\n",
        "                    R = get_norm(diff)\n",
        "                    acceleration += G * m2 * diff / (R**3)\n",
        "                body.point += body.velocity * dt / num_mid_steps\n",
        "                body.velocity += acceleration * dt / num_mid_steps\n",
        "        for body in bodies:\n",
        "            body.move_to(body.point)\n",
        "        return bodies\n",
        "\n",
        "\n",
        "class AltThreeBodiesInSpace(ThreeBodiesInSpace):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 6,\n",
        "        \"masses\": [1, 2, 6],\n",
        "    }\n",
        "\n",
        "\n",
        "class TwoBodiesInSpace(ThreeBodiesInSpace):\n",
        "    CONFIG = {\n",
        "        \"colors\": [GREY, BLUE],\n",
        "        \"masses\": [6, 36],\n",
        "        \"play_time\": 60,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_bodies()\n",
        "        self.add_trajectories()\n",
        "        self.add_velocity_vectors()\n",
        "        self.add_force_vectors()\n",
        "        self.let_play()\n",
        "\n",
        "    def add_bodies(self):\n",
        "        super().add_bodies()\n",
        "        for body in self.bodies:\n",
        "            body.point = 3 * normalize(body.get_center())\n",
        "            # body.point += 2 * IN\n",
        "            # body.velocity += (4 / 60) * OUT\n",
        "            body.move_to(body.point)\n",
        "\n",
        "    def get_initial_positions(self):\n",
        "        return [\n",
        "            np.dot(\n",
        "                6 * (np.random.random(3) - 0.5),\n",
        "                [RIGHT, UP, ORIGIN]\n",
        "            )\n",
        "            for x in range(len(self.masses))\n",
        "        ]\n",
        "\n",
        "    def get_initial_velocity(self, center, centers, mass):\n",
        "        return 0.75 * normalize(np.cross(center, OUT))\n",
        "\n",
        "    def add_velocity_vectors(self):\n",
        "        vectors = VGroup(*[\n",
        "            self.get_velocity_vector(body)\n",
        "            for body in self.bodies\n",
        "        ])\n",
        "        self.velocity_vectors = vectors\n",
        "        self.add(vectors)\n",
        "\n",
        "    def get_velocity_vector(self, body):\n",
        "        def create_vector(b):\n",
        "            v = Vector(\n",
        "                b.velocity,\n",
        "                color=RED,\n",
        "                max_stroke_width_to_length_ratio=3,\n",
        "            )\n",
        "            v.set_stroke(width=3)\n",
        "            v.shift(\n",
        "                b.point + b.radius * normalize(b.velocity) -\n",
        "                v.get_start(),\n",
        "            )\n",
        "            v.set_shade_in_3d(True)\n",
        "            return v\n",
        "        return always_redraw(lambda: create_vector(body))\n",
        "\n",
        "    def add_force_vectors(self):\n",
        "        vectors = VGroup(*[\n",
        "            self.get_force_vector(b1, b2)\n",
        "            for (b1, b2) in (self.bodies, self.bodies[::-1])\n",
        "        ])\n",
        "        self.force_vectors = vectors\n",
        "        self.add(vectors)\n",
        "\n",
        "    def get_force_vector(self, body1, body2):\n",
        "        def create_vector(b1, b2):\n",
        "            r = b2.point - b1.point\n",
        "            F = r / (get_norm(r)**3)\n",
        "            v = Vector(\n",
        "                4 * F,\n",
        "                color=YELLOW,\n",
        "                max_stroke_width_to_length_ratio=3,\n",
        "            )\n",
        "            v.set_stroke(width=3)\n",
        "            v.shift(\n",
        "                b1.point + b1.radius * normalize(F) -\n",
        "                v.get_start(),\n",
        "            )\n",
        "            v.set_shade_in_3d(True)\n",
        "            return v\n",
        "        return always_redraw(lambda: create_vector(body1, body2))\n",
        "\n",
        "\n",
        "class TwoBodiesWithZPart(TwoBodiesInSpace):\n",
        "    def add_bodies(self):\n",
        "        super().add_bodies()\n",
        "        for body in self.bodies:\n",
        "            body.point += 3 * IN\n",
        "            body.velocity += (6 / 60) * OUT\n",
        "\n",
        "\n",
        "class LoveExample(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.show_hearts()\n",
        "        self.add_love_trackers()\n",
        "        self.break_down_your_rule()\n",
        "        self.break_down_their_rule()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        you = You()\n",
        "        you.shift(FRAME_WIDTH * LEFT / 4)\n",
        "        you.to_edge(DOWN)\n",
        "\n",
        "        tau = TauCreature(color=GREEN)\n",
        "        tau.flip()\n",
        "        tau.shift(FRAME_WIDTH * RIGHT / 4)\n",
        "        tau.to_edge(DOWN)\n",
        "\n",
        "        self.you = you\n",
        "        self.tau = tau\n",
        "        return (you, tau)\n",
        "\n",
        "    def show_hearts(self):\n",
        "        you, tau = self.you, self.tau\n",
        "        hearts = VGroup()\n",
        "        n_hearts = 20\n",
        "        for x in range(n_hearts):\n",
        "            heart = SuitSymbol(\"hearts\")\n",
        "            heart.scale(0.5 + 2 * np.random.random())\n",
        "            heart.shift(np.random.random() * 4 * RIGHT)\n",
        "            heart.shift(np.random.random() * 4 * UP)\n",
        "            hearts.add(heart)\n",
        "        hearts.move_to(2 * DOWN)\n",
        "        hearts.add_updater(lambda m, dt: m.shift(2 * dt * UP))\n",
        "\n",
        "        self.add(hearts)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                UpdateFromAlphaFunc, hearts,\n",
        "                lambda heart: (\n",
        "                    heart,\n",
        "                    lambda h, a: h.set_opacity(\n",
        "                        there_and_back(a)\n",
        "                    ).shift(0.02 * UP)\n",
        "                ),\n",
        "                lag_ratio=0.01,\n",
        "                run_time=3,\n",
        "                suspend_mobject_updating=False,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                you.change, 'hooray', tau.eyes,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                tau.change, 'hooray', you.eyes,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "        )\n",
        "        self.remove(hearts)\n",
        "        self.wait()\n",
        "\n",
        "    def add_love_trackers(self):\n",
        "        self.init_ps_point()\n",
        "        self.add_love_decimals()\n",
        "        self.add_love_number_lines()\n",
        "        self.tie_creature_state_to_ps_point()\n",
        "\n",
        "        self.play(Rotating(\n",
        "            self.ps_point,\n",
        "            radians=-7 * TAU / 8,\n",
        "            about_point=ORIGIN,\n",
        "            run_time=10,\n",
        "            rate_func=linear,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def break_down_your_rule(self):\n",
        "        label1 = self.love_1_label\n",
        "        label2 = self.love_2_label\n",
        "        ps_point = self.ps_point\n",
        "\n",
        "        up_arrow = Vector(UP, color=GREEN)\n",
        "        down_arrow = Vector(DOWN, color=RED)\n",
        "        for arrow in (up_arrow, down_arrow):\n",
        "            arrow.next_to(label1, RIGHT)\n",
        "\n",
        "        self.play(GrowArrow(up_arrow))\n",
        "        self.play(\n",
        "            self.tau.love_eyes.scale, 1.25,\n",
        "            self.tau.love_eyes.set_color, BLUE_C,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.play(\n",
        "            ps_point.shift, 6 * RIGHT,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        ps_point.shift(13 * DOWN)\n",
        "        self.play(\n",
        "            FadeOut(up_arrow),\n",
        "            GrowArrow(down_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            ps_point.shift, 11 * LEFT,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Derivative\n",
        "        equation = get_love_equation1()\n",
        "        equation.shift(0.5 * UP)\n",
        "        deriv, equals, a, h2 = equation\n",
        "\n",
        "        self.play(\n",
        "            Write(deriv[:-1]),\n",
        "            Write(equals),\n",
        "            Write(a),\n",
        "            TransformFromCopy(label1[0], deriv.heart),\n",
        "            TransformFromCopy(label2[0], h2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            equation.scale, 0.5,\n",
        "            equation.to_corner, UL,\n",
        "            FadeOut(down_arrow)\n",
        "        )\n",
        "\n",
        "    def break_down_their_rule(self):\n",
        "        label1 = self.love_1_label\n",
        "        label2 = self.love_2_label\n",
        "        ps_point = self.ps_point\n",
        "\n",
        "        up_arrow = Vector(UP, color=GREEN)\n",
        "        down_arrow = Vector(DOWN, color=RED)\n",
        "        for arrow in (up_arrow, down_arrow):\n",
        "            arrow.next_to(label2, RIGHT)\n",
        "\n",
        "        # Derivative\n",
        "        equation = get_love_equation2()\n",
        "        equation.shift(0.5 * UP)\n",
        "        deriv, equals, mb, h1 = equation\n",
        "\n",
        "        self.play(\n",
        "            Write(deriv[:-1]),\n",
        "            Write(equals),\n",
        "            Write(mb),\n",
        "            TransformFromCopy(label1[0], h1),\n",
        "            TransformFromCopy(label2[0], deriv.heart),\n",
        "        )\n",
        "\n",
        "        self.play(GrowArrow(up_arrow))\n",
        "        self.play(\n",
        "            ps_point.shift, 13 * UP,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ps_point.shift, 11 * RIGHT,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(up_arrow),\n",
        "            GrowArrow(down_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            ps_point.shift, 13 * DOWN,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def init_ps_point(self):\n",
        "        self.ps_point = VectorizedPoint(np.array([5.0, 5.0, 0]))\n",
        "\n",
        "    def get_love1(self):\n",
        "        return self.ps_point.get_location()[0]\n",
        "\n",
        "    def get_love2(self):\n",
        "        return self.ps_point.get_location()[1]\n",
        "\n",
        "    def set_loves(self, love1=None, love2=None):\n",
        "        if love1 is not None:\n",
        "            self.ps_point.set_x(love1)\n",
        "        if love2 is not None:\n",
        "            self.ps_point.set_x(love2)\n",
        "\n",
        "    def add_love_decimals(self):\n",
        "        self.love_1_label = self.add_love_decimal(\n",
        "            1, self.get_love1, self.you.get_color(), -3,\n",
        "        )\n",
        "        self.love_2_label = self.add_love_decimal(\n",
        "            2, self.get_love2, self.tau.get_color(), 3,\n",
        "        )\n",
        "\n",
        "    def add_love_decimal(self, index, value_func, color, x_coord):\n",
        "        d = DecimalNumber(include_sign=True)\n",
        "        d.add_updater(lambda d: d.set_value(value_func()))\n",
        "\n",
        "        label = get_heart_var(index)\n",
        "        label.move_to(x_coord * RIGHT)\n",
        "        label.to_edge(UP)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(label, RIGHT, SMALL_BUFF)\n",
        "        eq.shift(SMALL_BUFF * UP)\n",
        "        d.next_to(eq, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(label, eq, d)\n",
        "        return VGroup(label, eq, d)\n",
        "\n",
        "    def add_love_number_lines(self):\n",
        "        nl1 = NumberLine(\n",
        "            x_min=-8,\n",
        "            x_max=8,\n",
        "            unit_size=0.25,\n",
        "            tick_frequency=2,\n",
        "            number_scale_val=0.25,\n",
        "        )\n",
        "        nl1.set_stroke(width=1)\n",
        "        nl1.next_to(self.love_1_label, DOWN)\n",
        "        nl1.add_numbers(*range(-6, 8, 2))\n",
        "\n",
        "        nl2 = nl1.copy()\n",
        "        nl2.next_to(self.love_2_label, DOWN)\n",
        "\n",
        "        dot1 = Dot(color=self.you.get_color())\n",
        "        dot1.add_updater(lambda d: d.move_to(\n",
        "            nl1.number_to_point(self.get_love1())\n",
        "        ))\n",
        "        dot2 = Dot(color=self.tau.get_color())\n",
        "        dot2.add_updater(lambda d: d.move_to(\n",
        "            nl2.number_to_point(self.get_love2())\n",
        "        ))\n",
        "\n",
        "        self.add(nl1, nl2, dot1, dot2)\n",
        "\n",
        "    def get_love_eyes(self, eyes):\n",
        "        hearts = VGroup()\n",
        "        for eye in eyes:\n",
        "            heart = SuitSymbol(\"hearts\")\n",
        "            heart.match_width(eye)\n",
        "            heart.move_to(eye)\n",
        "            heart.scale(1.25)\n",
        "            heart.set_stroke(BLACK, 1)\n",
        "            hearts.add(heart)\n",
        "        hearts.add_updater(\n",
        "            lambda m: m.move_to(eyes)\n",
        "        )\n",
        "        return hearts\n",
        "\n",
        "    def tie_creature_state_to_ps_point(self):\n",
        "        # Quite a mess, but I'm coding in a rush here...\n",
        "        you = self.you\n",
        "        you_copy = you.copy()\n",
        "        tau = self.tau\n",
        "        tau_copy = tau.copy()\n",
        "\n",
        "        you.love_eyes = self.get_love_eyes(you.eyes)\n",
        "        tau.love_eyes = self.get_love_eyes(tau.eyes)\n",
        "\n",
        "        self.add(you.love_eyes)\n",
        "        self.add(tau.love_eyes)\n",
        "\n",
        "        you_height = you.get_height()\n",
        "        tau_height = tau.get_height()\n",
        "\n",
        "        you_bottom = you.get_bottom()\n",
        "        tau_bottom = tau.get_bottom()\n",
        "\n",
        "        def update_you(y):\n",
        "            love = self.get_love1()\n",
        "\n",
        "            cutoff_values = [\n",
        "                -5, -3, -1, 1, 3, 5\n",
        "            ]\n",
        "            modes = [\n",
        "                \"angry\", \"sassy\", \"hesitant\",\n",
        "                \"plain\",\n",
        "                \"happy\", \"hooray\", \"surprised\",\n",
        "            ]\n",
        "\n",
        "            if love < cutoff_values[0]:\n",
        "                y.change(modes[0])\n",
        "            elif love >= cutoff_values[-1]:\n",
        "                y.change(modes[-1])\n",
        "            else:\n",
        "                i = 0\n",
        "                while cutoff_values[i] < love:\n",
        "                    i += 1\n",
        "                m1 = modes[i - 1]\n",
        "                m2 = modes[i]\n",
        "                y.change(m1)\n",
        "                you_copy.change(m2)\n",
        "                for mob in y, you_copy:\n",
        "                    mob.set_height(you_height)\n",
        "                    mob.move_to(you_bottom, DOWN)\n",
        "\n",
        "                alpha = inverse_interpolate(\n",
        "                    cutoff_values[i - 1],\n",
        "                    cutoff_values[i],\n",
        "                    love,\n",
        "                )\n",
        "                s_alpha = squish_rate_func(smooth, 0.25, 1)(alpha)\n",
        "                if s_alpha > 0:\n",
        "                    y.align_data_and_family(you_copy)\n",
        "                    f1 = y.family_members_with_points()\n",
        "                    f2 = you_copy.family_members_with_points()\n",
        "                    for sm1, sm2 in zip(f1, f2):\n",
        "                        sm1.interpolate(sm1, sm2, s_alpha)\n",
        "            y.look_at(tau.eyes)\n",
        "            if love < -4:\n",
        "                y.look_at(LEFT_SIDE)\n",
        "            # y.move_to(\n",
        "            #     you_bottom + 0.025 * love * RIGHT, DOWN,\n",
        "            # )\n",
        "\n",
        "            l_alpha = np.clip(\n",
        "                inverse_interpolate(5, 5.5, love),\n",
        "                0, 1\n",
        "            )\n",
        "            y.eyes.set_opacity(1 - l_alpha)\n",
        "            y.love_eyes.set_opacity(l_alpha)\n",
        "\n",
        "            return y\n",
        "\n",
        "        def update_tau(t):\n",
        "            love = self.get_love2()\n",
        "\n",
        "            cutoff_values = [\n",
        "                -5, -1.7, 1.7, 5\n",
        "            ]\n",
        "            modes = [\n",
        "                \"angry\", \"confused\", \"plain\",\n",
        "                \"hooray\", \"hooray\"\n",
        "            ]\n",
        "\n",
        "            if love < cutoff_values[0]:\n",
        "                t.change(modes[0])\n",
        "            elif love >= cutoff_values[-1]:\n",
        "                t.change(modes[-1])\n",
        "            else:\n",
        "                i = 0\n",
        "                while cutoff_values[i] < love:\n",
        "                    i += 1\n",
        "                m1 = modes[i - 1]\n",
        "                m2 = modes[i]\n",
        "                t.change(m1)\n",
        "                tau_copy.change(m2)\n",
        "                for mob in t, tau_copy:\n",
        "                    mob.set_height(tau_height)\n",
        "                    mob.move_to(tau_bottom, DOWN)\n",
        "\n",
        "                alpha = inverse_interpolate(\n",
        "                    cutoff_values[i - 1],\n",
        "                    cutoff_values[i],\n",
        "                    love,\n",
        "                )\n",
        "                s_alpha = squish_rate_func(smooth, 0.25, 1)(alpha)\n",
        "                if s_alpha > 0:\n",
        "                    t.align_data_and_family(tau_copy)\n",
        "                    f1 = t.family_members_with_points()\n",
        "                    f2 = tau_copy.family_members_with_points()\n",
        "                    for sm1, sm2 in zip(f1, f2):\n",
        "                        sm1.interpolate(sm1, sm2, s_alpha)\n",
        "            # t.move_to(\n",
        "            #     tau_bottom + 0.025 * love * LEFT, DOWN,\n",
        "            # )\n",
        "            t.look_at(you.eyes)\n",
        "            if love < -4:\n",
        "                t.look_at(RIGHT_SIDE)\n",
        "\n",
        "            l_alpha = np.clip(\n",
        "                inverse_interpolate(5, 5.5, love),\n",
        "                0, 1\n",
        "            )\n",
        "            t.eyes.set_opacity(1 - l_alpha)\n",
        "            t.love_eyes.set_opacity(l_alpha)\n",
        "\n",
        "        you.add_updater(update_you)\n",
        "        tau.add_updater(update_tau)\n",
        "\n",
        "        self.pi_creatures = VGroup()\n",
        "\n",
        "\n",
        "class ComparePhysicsToLove(Scene):\n",
        "    def construct(self):\n",
        "        ode = get_ode()\n",
        "        ode.to_edge(UP)\n",
        "        thetas = ode.get_parts_by_tex(\"theta\")\n",
        "\n",
        "        love = VGroup(\n",
        "            get_love_equation1(),\n",
        "            get_love_equation2(),\n",
        "        )\n",
        "        love.scale(0.5)\n",
        "        love.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        love.move_to(DOWN)\n",
        "        hearts = VGroup(*filter(\n",
        "            lambda sm: isinstance(sm, SuitSymbol),\n",
        "            love.get_family()\n",
        "        ))\n",
        "\n",
        "        arrow = DoubleArrow(love.get_top(), ode.get_bottom())\n",
        "\n",
        "        self.play(FadeIn(ode, DOWN))\n",
        "        self.play(FadeIn(love, UP))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeAround,\n",
        "            thetas,\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeAround,\n",
        "            hearts,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FramesComparingPhysicsToLove(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_color\": GREY_E}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ode = get_ode()\n",
        "        ode.to_edge(UP)\n",
        "\n",
        "        love = VGroup(\n",
        "            get_love_equation1(),\n",
        "            get_love_equation2(),\n",
        "        )\n",
        "        love.scale(0.5)\n",
        "        love.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        frames = VGroup(*[\n",
        "            ScreenRectangle(\n",
        "                height=3.5,\n",
        "                fill_color=BLACK,\n",
        "                fill_opacity=1,\n",
        "                stroke_width=0,\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        frames.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        frames.shift(DOWN)\n",
        "\n",
        "        animated_frames = AnimatedBoundary(frames)\n",
        "\n",
        "        ode.next_to(frames[0], UP)\n",
        "        love.next_to(frames[1], UP)\n",
        "\n",
        "        self.add(frames, animated_frames)\n",
        "        self.add(ode, love)\n",
        "\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class PassageOfTime(Scene):\n",
        "    def construct(self):\n",
        "        clock = Clock()\n",
        "        clock[0].set_color(BLUE)\n",
        "        clock.set_stroke(width=1)\n",
        "        clock.scale(0.8)\n",
        "        clock.to_corner(UL)\n",
        "        passage = ClockPassesTime(\n",
        "            clock,\n",
        "            hours_passed=48,\n",
        "        )\n",
        "        self.play(passage, run_time=10)\n",
        "\n",
        "\n",
        "class WriteODESolvingCode(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class InaccurateComputation(Scene):\n",
        "    def construct(self):\n",
        "        h_line = DashedLine(LEFT_SIDE, RIGHT_SIDE)\n",
        "        h_line.to_edge(UP, buff=1.5)\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Real number\"),\n",
        "            OldTexText(\"IEEE 754\\\\\\\\representation\"),\n",
        "            OldTexText(\"Error\"),\n",
        "        )\n",
        "        for i, word in zip([-1, 0, 1], words):\n",
        "            word.next_to(h_line, UP)\n",
        "            word.shift(i * FRAME_WIDTH * RIGHT / 3)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            DashedLine(TOP, BOTTOM)\n",
        "            for x in range(4)\n",
        "        ])\n",
        "        lines.arrange(RIGHT)\n",
        "        lines.stretch_to_fit_width(FRAME_WIDTH)\n",
        "\n",
        "        self.add(h_line, lines[1:-1], words)\n",
        "\n",
        "        numbers = VGroup(\n",
        "            OldTex(\"\\\\pi\").scale(2),\n",
        "            OldTex(\"e^{\\\\sqrt{163}\\\\pi}\").scale(1.5),\n",
        "        )\n",
        "        numbers.set_color(YELLOW)\n",
        "        numbers.set_stroke(width=0, background=True)\n",
        "\n",
        "        bit_strings = VGroup(\n",
        "            OldTex(\n",
        "                \"01000000\",\n",
        "                \"01001001\",\n",
        "                \"00001111\",\n",
        "                \"11011011\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"01011100\",\n",
        "                \"01101001\",\n",
        "                \"00101110\",\n",
        "                \"00011001\",\n",
        "            )\n",
        "        )\n",
        "        for mob in bit_strings:\n",
        "            mob.arrange(DOWN, buff=SMALL_BUFF)\n",
        "            for word in mob:\n",
        "                for submob, bit in zip(word, word.get_tex()):\n",
        "                    if bit == \"0\":\n",
        "                        submob.set_color(GREY_B)\n",
        "        errors = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\approx 8.7422 \\\\times 10^{-8}\"\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"\\\\approx 5{,}289{,}803{,}032.00\",\n",
        "            ),\n",
        "        )\n",
        "        errors.set_color(RED)\n",
        "\n",
        "        content = VGroup(numbers, bit_strings, errors)\n",
        "\n",
        "        for group, word in zip(content, words):\n",
        "            group[1].shift(3 * DOWN)\n",
        "            group.move_to(DOWN)\n",
        "            group.match_x(word)\n",
        "\n",
        "        self.play(*map(Write, numbers))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(numbers, bit_strings),\n",
        "            lag_ratio=0.01,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(errors, 3 * LEFT))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NewSceneName(Scene):\n",
        "    def construct(self):\n",
        "        pass\n"
    ]
}