{
    "topic": "demonstrates the concept of Bayes' theorem, which is a mathematical formula used to",
    "code": [
        "from manim_imports_ext import *\n",
        "       \n",
        "\n",
        "class IllustrateAreaModelBayes(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        color_A = YELLOW\n",
        "        color_not_A = YELLOW_E\n",
        "        color_B = MAROON\n",
        "        color_not_B = MAROON_E\n",
        "        opacity_B = 0.7\n",
        "\n",
        "\n",
        "        # show independent events\n",
        "\n",
        "        sample_space_width = sample_space_height = 3\n",
        "        p_of_A = 0.7\n",
        "        p_of_not_A = 1 - p_of_A\n",
        "        p_of_B = 0.8\n",
        "        p_of_not_B = 1 - p_of_B\n",
        "\n",
        "\n",
        "        rect_A = Rectangle(\n",
        "            width = p_of_A * sample_space_width,\n",
        "            height = 1 * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_A,\n",
        "            fill_opacity = 1.0\n",
        "        ).move_to(3 * RIGHT + 1.5 * UP)\n",
        "\n",
        "        rect_not_A = Rectangle(\n",
        "            width = p_of_not_A * sample_space_width,\n",
        "            height = 1 * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_not_A,\n",
        "            fill_opacity = 1.0\n",
        "        ).next_to(rect_A, RIGHT, buff = 0)\n",
        "\n",
        "        brace_A = Brace(rect_A, DOWN)\n",
        "        label_A = OldTex(\"P(A)\").next_to(brace_A, DOWN).scale(0.7)\n",
        "        brace_not_A = Brace(rect_not_A, DOWN)\n",
        "        label_not_A = OldTex(\"P(\\\\text{not }A)\").next_to(brace_not_A, DOWN).scale(0.7)\n",
        "\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(FadeIn, VGroup(rect_A, rect_not_A))\n",
        "        # )\n",
        "        # self.play(\n",
        "        #     ShowCreation(brace_A),\n",
        "        #     Write(label_A),\n",
        "        # )\n",
        "\n",
        "\n",
        "\n",
        "        rect_B = Rectangle(\n",
        "            width = 1 * sample_space_width,\n",
        "            height = p_of_B * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_B,\n",
        "            fill_opacity = opacity_B\n",
        "        )\n",
        "        rect_not_B = Rectangle(\n",
        "            width = 1 * sample_space_width,\n",
        "            height = p_of_not_B * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_not_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).next_to(rect_B, UP, buff = 0)\n",
        "\n",
        "        VGroup(rect_B, rect_not_B).move_to(VGroup(rect_A, rect_not_A))\n",
        "\n",
        "        brace_B = Brace(rect_B, LEFT)\n",
        "        label_B = OldTex(\"P(B)\").next_to(brace_B, LEFT).scale(0.7)\n",
        "        brace_not_B = Brace(rect_not_B, LEFT)\n",
        "        label_not_B = OldTex(\"P(\\\\text{not }B)\").next_to(brace_not_B, LEFT).scale(0.7)\n",
        "\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(FadeIn, VGroup(rect_B, rect_not_B))\n",
        "        # )\n",
        "        # self.play(\n",
        "        #     ShowCreation(brace_B),\n",
        "        #     Write(label_B),\n",
        "        # )\n",
        "\n",
        "        rect_A_and_B = Rectangle(\n",
        "            width = p_of_A * sample_space_width,\n",
        "            height = p_of_B * sample_space_height,\n",
        "            stroke_width = 3,\n",
        "            fill_opacity = 0.0\n",
        "        ).align_to(rect_A, DOWN).align_to(rect_A,LEFT)\n",
        "        label_A_and_B = OldTex(\"P(A\\\\text{ and }B)\").scale(0.7)\n",
        "        label_A_and_B.move_to(rect_A_and_B)\n",
        "\n",
        "        # self.play(\n",
        "        #     ShowCreation(rect_A_and_B)\n",
        "        # )\n",
        "\n",
        "        indep_formula = OldTex(\"P(A\\\\text{ and }B)\", \"=\", \"P(A)\", \"\\cdot\", \"P(B)\")\n",
        "        indep_formula = indep_formula.scale(0.7)\n",
        "        label_p_of_b = indep_formula.get_part_by_tex(\"P(B)\")\n",
        "\n",
        "        label_A_and_B_copy = label_A_and_B.copy()\n",
        "        label_A_copy = label_A.copy()\n",
        "        label_B_copy = label_B.copy()\n",
        "        # self.add(label_A_and_B_copy, label_A_copy, label_B_copy)\n",
        "\n",
        "        # self.play(Transform(label_A_and_B_copy, indep_formula[0]))\n",
        "        # self.play(FadeIn(indep_formula[1]))\n",
        "        # self.play(Transform(label_A_copy, indep_formula[2]))\n",
        "        # self.play(FadeIn(indep_formula[3]))\n",
        "        # self.play(Transform(label_B_copy, indep_formula[4]))\n",
        "\n",
        "        #self.wait()\n",
        "\n",
        "        label_A_and_B_copy = indep_formula[0]\n",
        "        label_A_copy = indep_formula[2]\n",
        "        label_B_copy = indep_formula[4]\n",
        "\n",
        "        # show conditional prob\n",
        "\n",
        "        rect_A_and_B.set_fill(color = RED, opacity = 0.5)\n",
        "        rect_A_and_not_B = Rectangle(\n",
        "            width = p_of_A * sample_space_width,\n",
        "            height = p_of_not_B * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_not_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).next_to(rect_A_and_B, UP, buff = 0)\n",
        "        \n",
        "        rect_not_A_and_B = Rectangle(\n",
        "            width = p_of_not_A * sample_space_width,\n",
        "            height = p_of_B * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).next_to(rect_A_and_B, RIGHT, buff = 0)\n",
        "\n",
        "        rect_not_A_and_not_B = Rectangle(\n",
        "            width = p_of_not_A * sample_space_width,\n",
        "            height = p_of_not_B * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_not_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).next_to(rect_not_A_and_B, UP, buff = 0)\n",
        "\n",
        "\n",
        "        indep_formula.next_to(rect_not_A, LEFT, buff = 5)\n",
        "        #indep_formula.shift(UP)\n",
        "\n",
        "        self.play(Write(indep_formula))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(VGroup(\n",
        "                rect_A, rect_not_A, brace_A, label_A, brace_B, label_B,\n",
        "                rect_A_and_not_B, rect_not_A_and_B, rect_not_A_and_not_B,\n",
        "                rect_A_and_B,\n",
        "                label_A_and_B,\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        p_of_B_knowing_A = 0.6\n",
        "        rect_A_and_B.target = Rectangle(\n",
        "            width = p_of_A * sample_space_width,\n",
        "            height = p_of_B_knowing_A * sample_space_height,\n",
        "            stroke_width = 3,\n",
        "            fill_color = color_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).align_to(rect_A_and_B, DOWN).align_to(rect_A_and_B, LEFT)\n",
        "\n",
        "        rect_A_and_not_B.target = Rectangle(\n",
        "            width = p_of_A * sample_space_width,\n",
        "            height = (1 - p_of_B_knowing_A) * sample_space_height,\n",
        "            stroke_width = 0,\n",
        "            fill_color = color_not_B,\n",
        "            fill_opacity = opacity_B\n",
        "        ).next_to(rect_A_and_B.target, UP, buff = 0)\n",
        "\n",
        "        brace_B.target = Brace(rect_A_and_B.target, LEFT)\n",
        "        label_B.target = OldTex(\"P(B\\mid A)\").scale(0.7).next_to(brace_B.target, LEFT)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rect_A_and_B),\n",
        "            MoveToTarget(rect_A_and_not_B),\n",
        "            MoveToTarget(brace_B),\n",
        "            MoveToTarget(label_B),\n",
        "            label_A_and_B.move_to,rect_A_and_B.target\n",
        "        )\n",
        "        label_B_knowing_A = label_B\n",
        "\n",
        "        #self.play(FadeOut(label_B_copy))\n",
        "        self.remove(indep_formula.get_part_by_tex(\"P(B)\"))\n",
        "        indep_formula.remove(indep_formula.get_part_by_tex(\"P(B)\"))\n",
        "        label_B_knowing_A_copy = label_B_knowing_A.copy()\n",
        "        self.add(label_B_knowing_A_copy)\n",
        "\n",
        "        self.play(\n",
        "            label_B_knowing_A_copy.next_to, indep_formula.get_part_by_tex(\"\\cdot\"), RIGHT,\n",
        "        )\n",
        "\n",
        "        # solve formula for P(B|A)\n",
        "\n",
        "        rearranged_formula = OldTex(\"P(B\\mid A)\", \"=\", \"{P(A\\\\text{ and }B) \\over P(A)}\")\n",
        "        rearranged_formula.move_to(indep_formula)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            # in some places get_part_by_tex does not find the correct part\n",
        "            # so I picked out fitting indices\n",
        "            label_B_knowing_A_copy.move_to, rearranged_formula.get_part_by_tex(\"P(B\\mid A)\"),\n",
        "            label_A_copy.move_to, rearranged_formula[-1][10],\n",
        "            label_A_and_B_copy.move_to, rearranged_formula[-1][3],\n",
        "            indep_formula.get_part_by_tex(\"=\").move_to, rearranged_formula.get_part_by_tex(\"=\"),\n",
        "            Transform(indep_formula.get_part_by_tex(\"\\cdot\"), rearranged_formula[2][8]),\n",
        "        )\n",
        "\n",
        "        rect = SurroundingRectangle(rearranged_formula, buff = 0.5 * MED_LARGE_BUFF)\n",
        "        self.play(ShowCreation(rect))\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n"
    ]
}