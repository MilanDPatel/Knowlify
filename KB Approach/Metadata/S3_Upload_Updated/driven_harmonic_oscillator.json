{
    "topic": "demonstrates the concept of a harmonic oscillator, which is a mathematical model for an",
    "code": [
        "from _2023.optics_puzzles.objects import TimeVaryingVectorField\n",
        "from _2023.optics_puzzles.objects import Calcite\n",
        "from _2023.optics_puzzles.objects import Sucrose\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class HarmonicOscillator(TrueDot):\n",
        "    def __init__(\n",
        "        self,\n",
        "        center=np.zeros(3),\n",
        "        initial_velocity=np.zeros(3),\n",
        "        k=20.0,\n",
        "        damping=0.1,\n",
        "        mass=1.0,\n",
        "        radius=0.5,\n",
        "        color=BLUE,\n",
        "        three_d=True,\n",
        "        **kwargs\n",
        "    ):\n",
        "        self.k = k\n",
        "        self.mass = mass\n",
        "        self.damping = damping\n",
        "        self.velocity = initial_velocity\n",
        "        self.center_of_attraction = center\n",
        "        self.external_forces = []\n",
        "\n",
        "        super().__init__(\n",
        "            radius=radius,\n",
        "            color=color,\n",
        "            **kwargs\n",
        "        )\n",
        "        if three_d:\n",
        "            self.make_3d()\n",
        "        self.move_to(center)\n",
        "        self.add_updater(lambda m, dt: self.update_position(dt))\n",
        "\n",
        "    def update_position(self, dt):\n",
        "        time_step = 1 / 300\n",
        "        n_divisions = max(int(dt / time_step), 1)\n",
        "        true_step = dt / n_divisions\n",
        "        for _ in range(n_divisions):\n",
        "            self.velocity += self.get_acceleration() * true_step\n",
        "            self.shift(self.velocity * true_step)\n",
        "\n",
        "    def get_displacement(self):\n",
        "        return self.get_center() - self.center_of_attraction\n",
        "\n",
        "    def get_acceleration(self):\n",
        "        disp = self.get_displacement()\n",
        "        result = -self.k * disp / self.mass - self.damping * self.velocity\n",
        "        for force in self.external_forces:\n",
        "            result += force() / self.mass\n",
        "        return result\n",
        "\n",
        "    def reset_velocity(self):\n",
        "        self.velocity = 0\n",
        "\n",
        "    def set_damping(self, damping):\n",
        "        self.damping = damping\n",
        "\n",
        "    def set_k(self, k):\n",
        "        self.k = k\n",
        "        return self\n",
        "\n",
        "    def suspend_updating(self):\n",
        "        super().suspend_updating()\n",
        "        self.reset_velocity()\n",
        "\n",
        "    def set_external_forces(self, funcs):\n",
        "        self.external_forces = list(funcs)\n",
        "        return self\n",
        "\n",
        "    def add_external_force(self, func):\n",
        "        self.external_forces.append(func)\n",
        "        return self\n",
        "\n",
        "\n",
        "class Spring(VMobject):\n",
        "    def __init__(\n",
        "        self, mobject, base_point,\n",
        "        edge=ORIGIN,\n",
        "        stroke_color=GREY,\n",
        "        stroke_width=2,\n",
        "        twist_rate=8.0,\n",
        "        n_twists=8,\n",
        "        radius=0.1,\n",
        "        lead_length=0.25,\n",
        "        **kwargs\n",
        "    ):\n",
        "        super().__init__(**kwargs)\n",
        "\n",
        "        helix = ParametricCurve(\n",
        "            lambda t: [\n",
        "                radius * math.cos(TAU * t),\n",
        "                radius * math.sin(TAU * t),\n",
        "                t / twist_rate\n",
        "            ],\n",
        "            t_range=(0, n_twists, 0.01)\n",
        "        )\n",
        "        helix.rotate(PI / 2, UP)\n",
        "        # helix.make_jagged()\n",
        "\n",
        "        self.start_new_path(helix.get_start() + lead_length * LEFT)\n",
        "        self.add_line_to(helix.get_start())\n",
        "        self.append_vectorized_mobject(helix)\n",
        "        self.add_line_to(helix.get_end() + lead_length * RIGHT)\n",
        "\n",
        "        self.set_stroke(color=stroke_color, width=stroke_width)\n",
        "        self.set_flat_stroke(False)\n",
        "\n",
        "        reference_points = self.get_points().copy()\n",
        "        width = self.get_width()\n",
        "        self.add_updater(lambda m: m.set_points(reference_points))\n",
        "        self.add_updater(lambda m: m.stretch(\n",
        "            get_norm(base_point - mobject.get_edge_center(edge)) / width, 0\n",
        "        ))\n",
        "        self.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            base_point, mobject.get_edge_center(edge)\n",
        "        ))\n",
        "\n",
        "    def get_length(self):\n",
        "        return get_norm(self.get_end() - self.get_start())\n",
        "\n",
        "\n",
        "class DynamicPlot(VMobject):\n",
        "    def __init__(\n",
        "        self,\n",
        "        axes,\n",
        "        func,\n",
        "        stroke_color=RED,\n",
        "        stroke_width=3,\n",
        "\n",
        "    ):\n",
        "        self.axes = axes\n",
        "        self.func = func\n",
        "        self.time = 0\n",
        "        super().__init__(\n",
        "            stroke_color=stroke_color,\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "        self.reset()\n",
        "        self.add_updater(lambda m, dt: m.add_point(dt))\n",
        "\n",
        "    def add_point(self, dt):\n",
        "        self.time += dt\n",
        "        if self.time < self.axes.x_axis.x_max:\n",
        "            self.add_line_to(self.axes.c2p(self.time, self.func()))\n",
        "        return self\n",
        "\n",
        "    def reset(self):\n",
        "        self.clear_points()\n",
        "        self.time = 0\n",
        "        self.start_new_path(self.axes.c2p(0, self.func()))\n",
        "        return self\n",
        "\n",
        "\n",
        "class DrivenHarmonicOscillator(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Zoom in on a plane of charges\n",
        "        frame = self.frame\n",
        "        frame.reorient(-90, 80, 90)\n",
        "\n",
        "        zoom_out_radius = 0.035\n",
        "        radius = 0.2\n",
        "        charges = DotCloud(color=BLUE_D, radius=zoom_out_radius)\n",
        "        charges.to_grid(31, 31)\n",
        "        charges.set_height(3)\n",
        "        charges.set_radius(zoom_out_radius)\n",
        "        charges.make_3d()\n",
        "\n",
        "        self.add(charges)\n",
        "        in_shift = 0.01 * IN\n",
        "        charges_target_height = 59\n",
        "        self.play(\n",
        "            frame.animate.reorient(-90, 0, 90).center().set_focal_distance(100).set_anim_args(time_span=(0, 4)),\n",
        "            charges.animate.center().set_height(charges_target_height).set_radius(radius).shift(in_shift),\n",
        "            run_time=6,\n",
        "        )\n",
        "        frame.reorient(0, 0, 0)\n",
        "\n",
        "        # Add springs\n",
        "        sho = HarmonicOscillator(\n",
        "            center=charges.get_center() - in_shift,\n",
        "            radius=radius,\n",
        "            color=charges.get_color(),\n",
        "        )\n",
        "        cover = BackgroundRectangle(sho, buff=0.1)\n",
        "        cover.set_fill(BLACK, 1)\n",
        "        spacing = get_norm(charges.get_points()[1] - charges.get_points()[0])\n",
        "        small_radius = 0.35 * radius\n",
        "        springs = VGroup(*(\n",
        "            Spring(sho, sho.get_center() + (spacing - small_radius) * vect)\n",
        "            for vect in compass_directions(4)\n",
        "        ))\n",
        "        sho.add_updater(lambda m: springs.update())\n",
        "\n",
        "        self.add(cover, springs, sho)\n",
        "        self.play(\n",
        "            charges.animate.set_opacity(0.5).set_radius(small_radius),\n",
        "            FadeIn(springs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show example oscillating\n",
        "        self.play(sho.animate.shift(0.5 * UL))\n",
        "        sho.suspend_updating()\n",
        "        self.wait()\n",
        "        sho.resume_updating()\n",
        "        sho.set_damping(0.25)\n",
        "        self.wait(8)\n",
        "\n",
        "        sho.move_to(sho.center_of_attraction)\n",
        "        sho.reset_velocity()\n",
        "\n",
        "        # Add coordiante plane\n",
        "        axes = Axes(axis_config=dict(tick_size=0.05))\n",
        "        axes.set_stroke(width=1, opacity=1)\n",
        "        axes.set_flat_stroke(False)\n",
        "        axes.scale(spacing)\n",
        "        self.add(axes, springs, sho)\n",
        "        self.play(FadeIn(axes))\n",
        "        sho.suspend_updating()\n",
        "        self.play(sho.animate.move_to(0.75 * UP + 0.5 * LEFT))\n",
        "\n",
        "        # Set up Hooke's law\n",
        "        t2c = {\n",
        "            R\"\\vec{\\textbf{x}}(t)\": RED,\n",
        "            R\"\\vec{\\textbf{v}}(t)\": PINK,\n",
        "            R\"\\vec{\\textbf{F}}(t)\": YELLOW,\n",
        "            R\"\\vec{\\textbf{a}}(t)\": YELLOW,\n",
        "            R\"\\frac{d^2 \\vec{\\textbf{x}}}{dt^2}(t) \": YELLOW,\n",
        "            R\"\\omega_r\": PINK,\n",
        "            R\"\\omega_l\": TEAL,\n",
        "        }\n",
        "\n",
        "        x_vect = always_redraw(lambda: Arrow(\n",
        "            axes.c2p(0, 0), sho.get_center(),\n",
        "            stroke_width=5, stroke_color=RED, buff=0\n",
        "        ))\n",
        "\n",
        "        equation = Tex(R\"\\vec{\\textbf{F}}(t) = -k \\vec{\\textbf{x}}(t)\", t2c=t2c)\n",
        "        equation.move_to(axes.c2p(0.5, 0.5), LEFT)\n",
        "\n",
        "        x_label = equation[R\"\\vec{\\textbf{x}}(t)\"]\n",
        "        x_label.set_backstroke(BLACK, 5)\n",
        "        x_label.save_state()\n",
        "        x_label.next_to(x_vect, RIGHT, 0.05, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(x_vect),\n",
        "            springs.animate.set_stroke(opacity=0.35)\n",
        "        )\n",
        "        self.play(Write(x_label))\n",
        "        self.wait()\n",
        "        self.play(sho.animate.move_to(DR), rate_func=there_and_back, run_time=3)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equation[R\"\\vec{\\textbf{F}}(t) = -k \"]),\n",
        "            Restore(x_label),\n",
        "        )\n",
        "        self.add(equation)\n",
        "\n",
        "        # Show force vector\n",
        "        sho.set_damping(0.005)\n",
        "        F_vect = Vector(stroke_color=YELLOW)\n",
        "\n",
        "        def update_F_vect(F_vect, vect_scale=0.04):\n",
        "            center = sho.get_center()\n",
        "            acc = sho.get_acceleration()\n",
        "            F_vect.put_start_and_end_on(center, center + vect_scale * acc)\n",
        "\n",
        "        F_vect.add_updater(update_F_vect)\n",
        "\n",
        "        initial_position = 0.75 * UL\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(equation[R\"\\vec{\\textbf{F}}\"]),\n",
        "            ReplacementTransform(x_vect, F_vect, path_arc=PI),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(sho.animate.move_to(0.25 * UL))\n",
        "        self.wait()\n",
        "        self.play(sho.animate.move_to(initial_position))\n",
        "        self.wait()\n",
        "        sho.resume_updating()\n",
        "        self.wait(6)\n",
        "\n",
        "        # Show graphical solution\n",
        "        up_shift = 1.5 * UP\n",
        "        plot_rect, plot_axes, plot = self.get_plot_group(\n",
        "            lambda: np.sign(sho.get_center()[1]) * get_norm(sho.get_center()),\n",
        "        )\n",
        "        plot_group1 = VGroup(plot_rect, plot_axes, plot)\n",
        "        plot_group1.to_corner(UR, buff=0.1)\n",
        "        plot_group1.shift(up_shift)\n",
        "\n",
        "        sho.move_to(initial_position)\n",
        "        sho.reset_velocity()\n",
        "        plot.reset()\n",
        "        self.add(*plot_group1)\n",
        "        self.play(\n",
        "            frame.animate.shift(up_shift),\n",
        "            equation.animate.to_corner(UL).match_y(plot_rect),\n",
        "            FadeIn(plot_rect),\n",
        "            FadeIn(plot_axes),\n",
        "            FadeOut(charges),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(15)\n",
        "        plot.suspend_updating()\n",
        "        sho.suspend_updating()\n",
        "        self.play(sho.animate.center(), run_time=2)\n",
        "\n",
        "        # Show the equation for the solution\n",
        "        tex_kw = dict(t2c=t2c)\n",
        "        equations = VGroup(equation)\n",
        "        equations.add(\n",
        "            Tex(R\"m \\vec{\\textbf{a}}(t) = -k \\vec{\\textbf{x}}(t)\", **tex_kw),\n",
        "            Tex(R\"\\frac{d^2 \\vec{\\textbf{x}}}{dt^2}(t) = -{k \\over m} \\vec{\\textbf{x}}(t)\", **tex_kw),\n",
        "            Tex(R\"\\vec{\\textbf{x}}(t) = \\vec{\\textbf{x}}_0 \\cos( \\sqrt{k \\over m} \\cdot t)\", **tex_kw),\n",
        "            Tex(R\"\\vec{\\textbf{x}}(t) = \\vec{\\textbf{x}}_0 \\cos(\\omega_r t)\", **tex_kw),\n",
        "        )\n",
        "        eq1, eq2, eq3, eq4, eq5 = equations\n",
        "\n",
        "        eq2.next_to(eq1, DOWN, LARGE_BUFF)\n",
        "        eq3.next_to(eq2, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        eq4.next_to(eq2, DOWN, buff=0.75, aligned_edge=LEFT)\n",
        "        eq5.move_to(eq4, LEFT)\n",
        "\n",
        "        implies = Tex(R\"\\Downarrow\").replicate(2)\n",
        "        implies[0].move_to(VGroup(eq1, eq2))\n",
        "        implies[1].move_to(VGroup(eq2, eq3))\n",
        "        implies[1].match_x(implies[0])\n",
        "\n",
        "        eq1_copy = eq1.copy()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                eq1_copy, eq2,\n",
        "                matched_pairs=[\n",
        "                    (eq1_copy[R\"\\vec{\\textbf{F}}(t)\"], eq2[R\"\\vec{\\textbf{a}}(t)\"]),\n",
        "                    (eq1_copy[R\"= -k \\vec{\\textbf{x}}(t)\"], eq2[R\"= -k \\vec{\\textbf{x}}(t)\"]),\n",
        "                ],\n",
        "                run_time=1\n",
        "            ),\n",
        "            FadeIn(implies[0], 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        eq2_copy = eq2.copy()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                eq2_copy, eq3,\n",
        "                matched_pairs=[\n",
        "                    (eq2_copy[R\"\\vec{\\textbf{a}}(t)\"], eq3[R\"\\frac{d^2 \\vec{\\textbf{x}}}{dt^2}(t)\"]),\n",
        "                    (eq2_copy[R\"k\"], eq3[\"k\"]),\n",
        "                ],\n",
        "                path_arc=PI / 4,\n",
        "            ),\n",
        "            FadeIn(implies[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            eq3.animate.move_to(eq2).align_to(eq1, LEFT),\n",
        "            FadeOut(eq2),\n",
        "            FadeOut(implies[1]),\n",
        "        )\n",
        "\n",
        "        # Show solution for a given initial condition\n",
        "        initial_position = 0.5 * UR\n",
        "        x0 = eq4[R\"\\vec{\\textbf{x}}_0\"]\n",
        "        cos_part = eq4[R\"\\cos( \\sqrt{k \\over m} \\cdot t)\"]\n",
        "        x0_copy = x0.copy()\n",
        "        x0_copy.next_to(0.5 * initial_position, UL, buff=0.05)\n",
        "        x0_copy.set_color(RED)\n",
        "        x0_copy.set_backstroke(BLACK, 4)\n",
        "        ic_label = Text(\"Initial condition\")\n",
        "        ic_label.next_to(initial_position, UR, MED_LARGE_BUFF)\n",
        "\n",
        "        x0_rect = SurroundingRectangle(x0, buff=0.05)\n",
        "        x0_rect.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.remove(F_vect)\n",
        "        self.add(x_vect)\n",
        "        self.play(\n",
        "            FadeIn(ic_label),\n",
        "            sho.animate.move_to(initial_position)\n",
        "        )\n",
        "        self.play(FadeIn(x0_copy, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(x0_copy, x0),\n",
        "            Write(implies[1]),\n",
        "            *(\n",
        "                TransformFromCopy(eq3[tex], eq4[tex])\n",
        "                for tex in [\"=\", R\"\\vec{\\textbf{x}}(t)\"]\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(cos_part, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            FlashAround(cos_part, color=RED, run_time=3, time_width=1.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(ic_label, x0_rect)\n",
        "        )\n",
        "        self.play(\n",
        "            plot.animate.stretch(0.5, 1),\n",
        "            sho.animate.move_to(0.5 * initial_position),\n",
        "            x0_copy.animate.next_to(0.25 * initial_position, UL, SMALL_BUFF),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=6,\n",
        "        )\n",
        "\n",
        "        # Reset\n",
        "        self.play(\n",
        "            FadeOut(plot),\n",
        "            FadeOut(x0_copy),\n",
        "            FadeOut(x_vect),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sho.resume_updating()\n",
        "        plot.reset()\n",
        "        plot.resume_updating()\n",
        "        self.add(plot)\n",
        "\n",
        "        # Describe frequency terms\n",
        "        sqrt_km = eq4[R\"\\sqrt{k \\over m}\"]\n",
        "        sqrt_km_rect = SurroundingRectangle(sqrt_km, buff=0.05)\n",
        "        k_rect = SurroundingRectangle(eq4[\"k\"])\n",
        "        m_rect = SurroundingRectangle(eq4[\"m\"])\n",
        "        VGroup(sqrt_km_rect, k_rect, m_rect).set_stroke(TEAL, 2)\n",
        "\n",
        "        for rect in k_rect, m_rect:\n",
        "            rect.arrow = Vector(0.5 * UP)\n",
        "            rect.arrow.match_color(rect)\n",
        "            rect.arrow.next_to(rect, RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(ReplacementTransform(x0_rect, sqrt_km_rect))\n",
        "        self.wait(10)\n",
        "        plot.reset()\n",
        "        original_k = sho.k\n",
        "        sho.set_k(4 * original_k)\n",
        "        sho.move_to(initial_position)\n",
        "        sho.reset_velocity()\n",
        "        self.play(\n",
        "            ReplacementTransform(sqrt_km_rect, k_rect),\n",
        "            GrowArrow(k_rect.arrow)\n",
        "        )\n",
        "        initial_position = sho.get_center()\n",
        "        self.wait(5)\n",
        "        self.wait_until(lambda: get_norm(sho.get_center() - initial_position) < 0.05)\n",
        "        sho.set_k(0.5 * original_k)\n",
        "        sho.move_to(initial_position)\n",
        "        sho.reset_velocity()\n",
        "        self.play(\n",
        "            ReplacementTransform(k_rect, m_rect),\n",
        "            FadeOut(k_rect.arrow),\n",
        "            GrowArrow(m_rect.arrow),\n",
        "        )\n",
        "        self.wait(8)\n",
        "        sho.set_k(original_k)\n",
        "\n",
        "        # Define omega_0\n",
        "        omega0_eq = Tex(R\"\\omega_r = \\sqrt{k / m}\")\n",
        "        omega0_eq[R\"\\omega_r\"].set_color(PINK)\n",
        "        omega0_eq.next_to(eq5, DOWN, buff=1.25)\n",
        "        omega0_name = TexText(\"``Resonant frequency''\", font_size=36)\n",
        "        omega0_name.next_to(omega0_eq, DOWN)\n",
        "\n",
        "        plot.reset()\n",
        "        self.play(\n",
        "            FadeOut(m_rect),\n",
        "            FadeOut(m_rect.arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(sqrt_km, omega0_eq[R\"\\sqrt{k / m}\"]),\n",
        "            Write(omega0_eq[R\"\\omega_r = \"]),\n",
        "            TransformMatchingTex(eq4, eq5),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(omega0_name))\n",
        "        self.wait(12)\n",
        "\n",
        "        # Clean up solution\n",
        "        corner_box = Rectangle(width=3, height=plot_rect.get_height())\n",
        "        corner_box.set_fill(interpolate_color(BLUE_E, BLACK, 0.75), 1.0)\n",
        "        corner_box.set_stroke(WHITE, 1)\n",
        "        corner_box.match_y(plot_rect)\n",
        "        corner_box.to_edge(LEFT, buff=SMALL_BUFF)\n",
        "\n",
        "        free_solution = VGroup(eq1, implies[0], eq5, omega0_eq)\n",
        "        free_solution.target = free_solution.generate_target()\n",
        "        free_solution.target.arrange(DOWN)\n",
        "        free_solution.target.set_height(0.8 * corner_box.get_height())\n",
        "        free_solution.target.move_to(corner_box)\n",
        "\n",
        "        sho.suspend_updating()\n",
        "        self.play(\n",
        "            FadeIn(corner_box),\n",
        "            MoveToTarget(free_solution),\n",
        "            *map(FadeOut, [eq3, implies[1], omega0_name]),\n",
        "            sho.animate.center(),\n",
        "        )\n",
        "        corner_box.push_self_into_submobjects()\n",
        "        corner_box.add(free_solution)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(plot_group1),\n",
        "            frame.animate.shift(-up_shift),\n",
        "            corner_box.animate.shift(-up_shift),\n",
        "            run_time=2\n",
        "        )\n",
        "        corner_box.fix_in_frame()\n",
        "\n",
        "        # Write new equation with driving force\n",
        "        free_label = Text(\"No external\\nforces\", font_size=36)\n",
        "        free_label.next_to(corner_box, DOWN)\n",
        "        t2c[R\"\\vec{\\textbf{E}}_0\"] = BLUE_D\n",
        "\n",
        "        driven_eq = Tex(\n",
        "            R\"\"\"\n",
        "                \\vec{\\textbf{F}}(t) =\n",
        "                - k \\vec{\\textbf{x}}(t)\n",
        "                + \\vec{\\textbf{E}}_0 q \\cos(\\omega_l t)\n",
        "            \"\"\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        driven_eq.to_edge(UP)\n",
        "        driven_eq.set_x(FRAME_WIDTH / 4)\n",
        "\n",
        "        external_force = driven_eq[R\"\\vec{\\textbf{E}}_0 q \\cos(\\omega_l t)\"]\n",
        "        external_force_rect = SurroundingRectangle(external_force, buff=SMALL_BUFF)\n",
        "        external_force_rect.set_stroke(TEAL, 2)\n",
        "        external_force_label = Text(\"Force from a\\nlight wave\", font_size=36)\n",
        "        external_force_label.next_to(external_force_rect, DOWN)\n",
        "        external_force_label.set_backstroke(BLACK, 7)\n",
        "\n",
        "        self.play(FadeIn(free_label, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(eq1.copy(), driven_eq))\n",
        "\n",
        "        driven_eq_group = VGroup(\n",
        "            BackgroundRectangle(driven_eq, buff=0.5).set_fill(BLACK, 0.9),\n",
        "            BackgroundRectangle(external_force_label, buff=0.5).set_fill(BLACK, 0.9),\n",
        "            driven_eq, external_force_rect,\n",
        "            external_force_label\n",
        "        )\n",
        "        driven_eq_group.fix_in_frame()\n",
        "        self.add(driven_eq_group)\n",
        "\n",
        "        # Add a oscillating E field\n",
        "        omega_tracker = ValueTracker(2.0)\n",
        "        F_max = 0.5\n",
        "        wave_number = 2.0\n",
        "        axes.set_flat_stroke(False)\n",
        "\n",
        "        def time_func(points, time):\n",
        "            omega = omega_tracker.get_value()\n",
        "            result = np.zeros(points.shape)\n",
        "            result[:, 1] = F_max * np.cos(wave_number * points[:, 2] - omega * time)\n",
        "            return result\n",
        "\n",
        "        field_config = dict(\n",
        "            stroke_color=TEAL,\n",
        "            stroke_width=3,\n",
        "            stroke_opacity=0.5,\n",
        "            max_vect_len=1.0,\n",
        "            x_density=1.0,\n",
        "            y_density=1.0,\n",
        "        )\n",
        "        planar_field = TimeVaryingVectorField(\n",
        "            time_func,\n",
        "            **field_config\n",
        "        )\n",
        "        z_axis_field = TimeVaryingVectorField(\n",
        "            time_func,\n",
        "            height=0, width=0, depth=16,\n",
        "            z_density=5,\n",
        "            **field_config\n",
        "        )\n",
        "        full_field = TimeVaryingVectorField(\n",
        "            time_func,\n",
        "            depth=16,\n",
        "            z_density=5,\n",
        "            height=5,\n",
        "            width=5,\n",
        "            norm_to_opacity_func=lambda n: n,\n",
        "            **field_config,\n",
        "        )\n",
        "\n",
        "        z_axis_field.set_stroke(opacity=1)\n",
        "        full_field_opacity_mult = ValueTracker(0)\n",
        "\n",
        "        def udpate_full_field_opacity(ff):\n",
        "            ff.data[\"stroke_rgba\"][:, 3] *= full_field_opacity_mult.get_value()\n",
        "\n",
        "        full_field.add_updater(udpate_full_field_opacity)\n",
        "\n",
        "        sho.set_k(8)\n",
        "        sho.set_damping(1)\n",
        "        sho.set_external_forces([\n",
        "            lambda: 3 * planar_field.func(np.array([ORIGIN]))[0]\n",
        "        ])\n",
        "        sho.center()\n",
        "        sho.reset_velocity()\n",
        "        sho.resume_updating()\n",
        "        self.add(planar_field, corner_box, driven_eq_group)\n",
        "        self.play(\n",
        "            VFadeIn(planar_field),\n",
        "            FadeOut(corner_box, time_span=(0, 1)),\n",
        "            FadeOut(free_label, time_span=(0, 1)),\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "        # Gather clean oscillations for B roll later\n",
        "        self.remove(driven_eq_group)\n",
        "        self.wait(30)\n",
        "        self.add(driven_eq_group)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-100, 100, 90),\n",
        "            run_time=6\n",
        "        )\n",
        "        z_axis_field.time = full_field.time\n",
        "        self.play(\n",
        "            full_field_opacity_mult.animate.set_value(0),\n",
        "            VFadeIn(z_axis_field),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.remove(full_field)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-100, 80, 90),\n",
        "            run_time=6\n",
        "        )\n",
        "        planar_field.set_stroke(opacity=0.5)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-90, 0, 90).set_focal_distance(100).set_height(8),\n",
        "            VFadeOut(z_axis_field),\n",
        "            VFadeIn(planar_field),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Change perspective a bunch\n",
        "        full_field.time = planar_field.time\n",
        "        frame.set_focal_distance(10)\n",
        "        self.add(full_field)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-100, 80, 90).set_height(10),\n",
        "            full_field_opacity_mult.animate.set_value(1).set_anim_args(time_span=(2, 4)),\n",
        "            VFadeOut(planar_field, time_span=(2, 4), remover=False),\n",
        "            run_time=4,\n",
        "        )\n",
        "        planar_field.set_stroke(opacity=0)\n",
        "\n",
        "        self.remove(driven_eq_group)\n",
        "        full_field_opacity_mult.set_value(0)\n",
        "        frame.to_default_state().reorient(-90, 0, 90)\n",
        "        self.play(\n",
        "            full_field_opacity_mult.animate.set_value(1).set_anim_args(time_span=(1, 4)),\n",
        "            frame.animate.reorient(-95, 60, 90).set_height(10),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-100, 110, 90),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-120, 80, 95),\n",
        "            run_time=10\n",
        "        )\n",
        "        planar_field.time = full_field.time\n",
        "        planar_field.set_stroke(opacity=1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-90, 0, 90).set_height(8),\n",
        "            full_field_opacity_mult.animate.set_value(0).set_anim_args(time_span=(8, 10)),\n",
        "            VFadeIn(planar_field, time_span=(8, 10)),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.add(driven_eq_group)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show graphical solution\n",
        "        up_shift = UP\n",
        "        driven_eq_group.unfix_from_frame()\n",
        "        plot_rect, plot_axes, plot = self.get_plot_group(\n",
        "            lambda: 2 * sho.get_y(),\n",
        "            width=FRAME_WIDTH - 1,\n",
        "            max_t=20\n",
        "        )\n",
        "        plot_group2 = VGroup(plot_rect, plot_axes, plot)\n",
        "        plot_group2.to_edge(UP, buff=SMALL_BUFF).shift(up_shift)\n",
        "\n",
        "        plot_box1, plot_box2 = plot_boxes = Rectangle().replicate(2)\n",
        "        plot_boxes.match_height(plot_rect)\n",
        "        plot_boxes.set_stroke(width=0)\n",
        "        plot_boxes.set_fill(opacity=0.25)\n",
        "        plot_boxes.set_submobject_colors_by_gradient(GREY_BROWN, TEAL)\n",
        "        for box, width, x in zip(plot_boxes, (5, 15.5), (0, 5)):\n",
        "            box.set_width(width * plot_axes.x_axis.get_unit_size(), stretch=True)\n",
        "            box.move_to(plot_axes.c2p(x, 0), LEFT)\n",
        "\n",
        "        sho.suspend_updating()\n",
        "        self.play(\n",
        "            frame.animate.shift(up_shift),\n",
        "            FadeIn(plot_rect),\n",
        "            FadeIn(plot_axes),\n",
        "            driven_eq_group.animate.shift(1.0 * DOWN),\n",
        "            sho.animate.center(),\n",
        "            VFadeOut(planar_field, time_span=(0, 1)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        planar_field.time = 0\n",
        "        sho.resume_updating()\n",
        "        plot.reset()\n",
        "        self.add(planar_field, driven_eq_group, plot_rect, plot_axes, plot)\n",
        "        self.play(VFadeIn(planar_field))\n",
        "        self.wait(5)\n",
        "        self.play(FadeIn(plot_box1))\n",
        "        self.wait(4)\n",
        "        self.play(FadeIn(plot_box2))\n",
        "        self.wait(9)\n",
        "        plot.suspend_updating()\n",
        "        self.wait(3)\n",
        "\n",
        "        # Compare with the previous plot\n",
        "        self.play(\n",
        "            VFadeOut(axes),\n",
        "            VFadeOut(planar_field),\n",
        "            FadeOut(sho),\n",
        "            VFadeOut(springs),\n",
        "        )\n",
        "\n",
        "        down_shift = 2.5 * DOWN\n",
        "        plot_group2.add(*plot_boxes)\n",
        "        plot_group1.next_to(plot_group2, UP, aligned_edge=LEFT).shift(down_shift)\n",
        "        top_axes = plot_group1[1]\n",
        "        VGroup(top_axes.x_axis, plot_group1[2]).stretch(\n",
        "            plot_axes.x_axis.get_unit_size() / top_axes.x_axis.get_unit_size(),\n",
        "            0, about_edge=LEFT\n",
        "        )\n",
        "        top_axes[-2].match_x(top_axes.x_axis.get_right())\n",
        "\n",
        "        corner_box.unfix_from_frame()\n",
        "        corner_box.next_to(plot_group1, RIGHT)\n",
        "        self.remove(*driven_eq_group[:2])\n",
        "        self.play(\n",
        "            FadeIn(plot_group1),\n",
        "            FadeIn(corner_box),\n",
        "            plot_group2.animate.shift(down_shift),\n",
        "            driven_eq.animate.shift(down_shift),\n",
        "            FadeOut(driven_eq_group[-2:], down_shift),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize different frequencies\n",
        "        omega0_eq_copy = omega0_eq.copy()\n",
        "        omega_copy = driven_eq[R\"\\omega_l\"].copy()\n",
        "\n",
        "        self.play(\n",
        "            omega0_eq_copy.animate.set_height(0.4).move_to(plot_group1, UR).shift(SMALL_BUFF * DL)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            omega_copy.animate.move_to(plot_axes.c2p(14, 0.8))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show equation for the solution\n",
        "        driven_eq.target = driven_eq.generate_target()\n",
        "        driven_eq.target.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        driven_eq.target.shift(0.5 * DOWN)\n",
        "        implies = Tex(R\"\\Rightarrow\", font_size=72)\n",
        "        implies.next_to(driven_eq.target, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        solution = Tex(\n",
        "            R\"\"\"\n",
        "                \\vec{\\textbf{x}}(t) = \n",
        "                \\frac{q \\vec{\\textbf{E}}_0}{m\\left(\\omega_r^2-\\omega_l^2\\right)}\n",
        "                \\cos(\\omega_l t)\n",
        "            \"\"\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        solution.next_to(implies, RIGHT, MED_LARGE_BUFF)\n",
        "        implies.match_y(solution)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(driven_eq),\n",
        "            FadeIn(implies, LEFT),\n",
        "            FadeIn(solution, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on the equation\n",
        "        full_rect = SurroundingRectangle(solution)\n",
        "        amp_rect = SurroundingRectangle(solution[R\"\\frac{q \\vec{\\textbf{E}}_0}{m\\left(\\omega_r^2-\\omega_l^2\\right)}\"])\n",
        "        E_rect = SurroundingRectangle(solution[R\"\\vec{\\textbf{E}}_0\"])\n",
        "        q_rect = SurroundingRectangle(solution[6])\n",
        "        freq_diff_rect = SurroundingRectangle(\n",
        "            solution[R\"\\omega_r^2-\\omega_l^2\"],\n",
        "            buff=0.05\n",
        "        )\n",
        "        lil_rects = VGroup(amp_rect, E_rect, q_rect, freq_diff_rect)\n",
        "        steady_state_rect = plot_box2.copy().set_fill(opacity=0)\n",
        "        VGroup(\n",
        "            full_rect, amp_rect, E_rect,\n",
        "            freq_diff_rect, steady_state_rect\n",
        "        ).set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(full_rect))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(full_rect, steady_state_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(full_rect, amp_rect),\n",
        "            FadeOut(steady_state_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        for r1, r2 in zip(lil_rects, lil_rects[1:]):\n",
        "            self.play(ReplacementTransform(r1, r2))\n",
        "            self.wait()\n",
        "\n",
        "        # Reintroduce oscillator\n",
        "        plot_group2.add(omega_copy)\n",
        "        plot_group2.target = plot_group2.generate_target()\n",
        "        plot_group2.target.shift(1.75 * UP)\n",
        "\n",
        "        top_rect = plot_rect.copy()\n",
        "        top_rect.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "        top_rect.next_to(plot_group2.target, UP, buff=0)\n",
        "\n",
        "        to_fade = VGroup(\n",
        "            plot_group1, omega0_eq_copy, corner_box,\n",
        "            driven_eq, implies,\n",
        "        )\n",
        "\n",
        "        self.add(planar_field, springs, top_rect, plot_group2, solution, freq_diff_rect)\n",
        "        self.add(to_fade)\n",
        "        planar_field.set_stroke(opacity=0)\n",
        "        planar_field.suspend_updating()\n",
        "        sho.center()\n",
        "        sho.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.shift(UP),\n",
        "            solution.animate.move_to(top_rect),\n",
        "            MaintainPositionRelativeTo(freq_diff_rect, solution),\n",
        "            MoveToTarget(plot_group2),\n",
        "            FadeOut(to_fade, UP),\n",
        "            FadeIn(sho),\n",
        "            VFadeIn(springs),\n",
        "            VFadeIn(planar_field),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show strong resonance\n",
        "        close_freq_words = Tex(R\"\\text{If } \\omega_l \\approx \\omega_r\", t2c=t2c)\n",
        "        close_freq_words.next_to(plot_rect, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(*plot_group2)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(plot_boxes),\n",
        "            FadeOut(plot),\n",
        "            FadeOut(omega_copy),\n",
        "            FadeIn(close_freq_words),\n",
        "            Transform(\n",
        "                freq_diff_rect,\n",
        "                SurroundingRectangle(close_freq_words).set_stroke(width=0),\n",
        "                remover=True\n",
        "            ),\n",
        "            *(\n",
        "                TransformFromCopy(solution[tex][0], close_freq_words[tex][0])\n",
        "                for tex in [R\"\\omega_r\", R\"\\omega_l\"]\n",
        "            )\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            plot_axes.y_axis.animate.stretch(0.75, 1),\n",
        "            plot_axes[-1].animate.shift(0.1 * DOWN + 0.4 * LEFT)\n",
        "        )\n",
        "\n",
        "        sho.set_k(16)\n",
        "        sho.set_damping(0.25)\n",
        "        sho.center()\n",
        "        sho.reset_velocity()\n",
        "        omega_tracker.set_value(4)\n",
        "        planar_field.set_stroke(opacity=1)\n",
        "        plot.reset()\n",
        "        plot.resume_updating()\n",
        "        sho.resume_updating()\n",
        "        planar_field.resume_updating()\n",
        "        self.add(plot)\n",
        "        self.play(VFadeIn(planar_field))\n",
        "        self.wait(30)\n",
        "\n",
        "        # Out of sync frequencies\n",
        "        half = Tex(R\"0.5\")\n",
        "        omega_r = close_freq_words[R\"\\omega_r\"][0]\n",
        "        half.move_to(omega_r, LEFT)\n",
        "        half.align_to(omega_r[0], DOWN)\n",
        "\n",
        "        sho.suspend_updating()\n",
        "        plot.suspend_updating()\n",
        "        self.play(\n",
        "            sho.animate.center(),\n",
        "            planar_field.animate.set_opacity(0),\n",
        "            FadeOut(plot),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(half),\n",
        "            omega_r.animate.shift((half.get_width() + 0.05) * RIGHT)\n",
        "        )\n",
        "        close_freq_words.add(half)\n",
        "        self.add(BackgroundRectangle(close_freq_words).set_fill(BLACK, 1), close_freq_words)\n",
        "        self.play(FlashAround(VGroup(close_freq_words, half)))\n",
        "        self.wait()\n",
        "\n",
        "        plot.reset()\n",
        "        plot.resume_updating()\n",
        "        omega_tracker.set_value(2)\n",
        "        sho.set_damping(0.25)\n",
        "        sho.resume_updating()\n",
        "        planar_field.set_stroke(opacity=1)\n",
        "        self.add(plot)\n",
        "        self.play(VFadeIn(planar_field))\n",
        "        self.wait(19)\n",
        "        plot.reset()\n",
        "        self.wait(20)\n",
        "\n",
        "    def scrap(self):\n",
        "        ## Line 281, used for thumbnail ##\n",
        "        self.remove(axes)\n",
        "        self.remove(equation)\n",
        "        self.add(sho)\n",
        "        springs.set_stroke(GREY_B, 4, 1) \n",
        "        sho.shift(0.5 * LEFT)\n",
        "        F_vect.set_stroke(width=10)\n",
        "        self.frame.set_height(5)\n",
        "        ############\n",
        "\n",
        "        # For clean driven_eq\n",
        "        self.clear()\n",
        "        self.add(driven_eq)\n",
        "        self.play(\n",
        "            ShowCreation(external_force_rect),\n",
        "            FadeIn(external_force_label, lag_ratio=0.1),\n",
        "        )\n",
        "        ###\n",
        "\n",
        "        # Show damping (Right after show force vector)\n",
        "        damp_term = Tex(R\"- \\mu \\vec{\\textbf{v}}(t)\", t2c=t2c)\n",
        "        damp_term.next_to(equation, RIGHT, SMALL_BUFF)\n",
        "        damp_rect = SurroundingRectangle(damp_term)\n",
        "        damp_rect.set_stroke(PINK, 2)\n",
        "        damp_arrow = Vector(DOWN).next_to(damp_rect, UP)\n",
        "        damp_arrow.match_color(damp_rect)\n",
        "\n",
        "        up_shift = 1.5 * UP\n",
        "        plot_rect, plot_axes, plot = self.get_plot_group(\n",
        "            lambda: np.sign(sho.get_center()[1]) * get_norm(sho.get_center()),\n",
        "            width=14,\n",
        "            max_t=20,\n",
        "        )\n",
        "        plot_group1 = VGroup(plot_rect, plot_axes, plot)\n",
        "        plot_group1.to_corner(UR, buff=0.1)\n",
        "        plot_group1.shift(up_shift)\n",
        "\n",
        "        sho.move_to(initial_position)\n",
        "        sho.reset_velocity()\n",
        "        plot.reset()\n",
        "        self.add(*plot_group1)\n",
        "        frame.shift(up_shift)\n",
        "        self.add(\n",
        "            plot_rect, plot_axes, plot\n",
        "        )\n",
        "\n",
        "        self.wait(3)\n",
        "        sho.set_damping(0.5)\n",
        "        self.play(Write(damp_term))\n",
        "        self.play(ShowCreation(damp_rect), GrowArrow(damp_arrow))\n",
        "        self.wait(17)\n",
        "        ###\n",
        "\n",
        "    def get_plot_group(\n",
        "        self,\n",
        "        func,\n",
        "        width=10.0,\n",
        "        height=2.0,\n",
        "        max_t=12.0,\n",
        "    ):\n",
        "        plot_rect = Rectangle(width, height)\n",
        "        plot_rect.set_fill(GREY_E, 1)\n",
        "        plot_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        plot_axes = Axes((0, max_t), (-1, 1), width=width - 1, height=height - 0.25)\n",
        "        plot_axes.move_to(plot_rect)\n",
        "        y_axis_label = Tex(R\"x(t)\", font_size=20)\n",
        "        y_axis_label.set_color(RED)\n",
        "        y_axis_label.next_to(plot_axes.y_axis.get_top(), RIGHT)\n",
        "        t_axis_label = Tex(\"t\", font_size=24)\n",
        "        t_axis_label.next_to(plot_axes.x_axis.get_right(), DOWN)\n",
        "\n",
        "        plot_axes.add(t_axis_label, y_axis_label)\n",
        "        plot = DynamicPlot(plot_axes, func)\n",
        "\n",
        "        return plot_rect, plot_axes, plot\n",
        "\n",
        "\n",
        "class JigglesInCalcite(InteractiveScene):\n",
        "    polarization_direction = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up crystal\n",
        "        calcite = Calcite(height=8)\n",
        "        calcite.center()\n",
        "\n",
        "        index = 118\n",
        "        calcium_center = calcite.balls.get_points()[index]\n",
        "        radii = calcite.balls.get_radii()\n",
        "        radii[index] = 0\n",
        "        calcite.balls.set_radii(radii)\n",
        "\n",
        "        calcium = HarmonicOscillator(center=calcium_center)\n",
        "        calcium.set_radius(np.max(radii))\n",
        "        calcium.set_color(GREEN)\n",
        "        calcium.set_glow_factor(calcite.balls.get_glow_factor())\n",
        "        calcium.move_to(calcium_center)\n",
        "\n",
        "        self.add(calcite, calcium)\n",
        "\n",
        "        # Initial panning\n",
        "        frame = self.frame\n",
        "        frame.reorient(12, 64, 0).move_to([0.21, -0.18, -0.77]).set_height(9)\n",
        "        self.play(\n",
        "            frame.animate.reorient(1, 84, 0).move_to([-0.08, -0.16, -0.53]).set_height(9),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add springs\n",
        "        spring_length = 2.5\n",
        "        springs = VGroup(\n",
        "            *(\n",
        "                Spring(\n",
        "                    calcium,\n",
        "                    calcium.get_center() + spring_length * (v_vect + 0.2 * h_vect),\n",
        "                    edge=v_vect\n",
        "                )\n",
        "                for v_vect in [UP, DOWN]\n",
        "                for h_vect in [LEFT, ORIGIN, RIGHT]\n",
        "            ),\n",
        "            *(\n",
        "                Spring(\n",
        "                    calcium,\n",
        "                    calcium.get_center() + spring_length * h_vect,\n",
        "                    edge=h_vect\n",
        "                )\n",
        "                for h_vect in [LEFT, RIGHT]\n",
        "            )\n",
        "        )\n",
        "        springs.set_stroke(opacity=0.7)\n",
        "        self.play(\n",
        "            VFadeIn(springs),\n",
        "            calcium.animate.shift(RIGHT),\n",
        "            calcite.balls.animate.set_opacity(0.1),\n",
        "            frame.animate.reorient(-2, 25, 0).move_to(calcium).set_height(6),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show two resonant frequencies\n",
        "        def wait_until_centered():\n",
        "            disp = calcium.get_displacement()\n",
        "            self.wait_until(lambda: np.dot(calcium.get_displacement(), disp) <= 0)\n",
        "            calcium.move_to(calcium_center)\n",
        "            calcium.reset_velocity()\n",
        "\n",
        "        for vect, k in [(RIGHT, 5), (UP, 30)]:\n",
        "            self.play(calcium.animate.move_to(calcium_center + vect), run_time=0.5)\n",
        "            calcium.reset_velocity()\n",
        "            calcium.set_k(k)\n",
        "            self.wait(6)\n",
        "            wait_until_centered()\n",
        "\n",
        "        # Shine in light\n",
        "        omega = -4.0\n",
        "        F_max = 1.0\n",
        "        wave_number = 2.0\n",
        "\n",
        "        def time_func(points, time):\n",
        "            result = np.zeros(points.shape)\n",
        "            result[:, self.polarization_direction] = F_max * np.cos(wave_number * points[:, 2] - omega * time)\n",
        "            return result\n",
        "\n",
        "        field_config = dict(\n",
        "            stroke_color=TEAL,\n",
        "            stroke_width=3,\n",
        "            stroke_opacity=0.5,\n",
        "            max_vect_len=1.0,\n",
        "            x_density=1.0,\n",
        "            y_density=1.0,\n",
        "            center=calcium_center,\n",
        "        )\n",
        "        z_axis_field = TimeVaryingVectorField(\n",
        "            time_func,\n",
        "            height=0, width=0, depth=16,\n",
        "            z_density=5,\n",
        "            **field_config\n",
        "        )\n",
        "\n",
        "        z_axis_field.set_stroke(opacity=0.5)\n",
        "\n",
        "        calcium.set_k([5, 30][self.polarization_direction])\n",
        "        calcium.set_damping(1)\n",
        "        calcium.set_external_forces([\n",
        "            lambda: 3 * z_axis_field.func(np.array([calcium_center]))[0]\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(z_axis_field),\n",
        "            frame.animate.reorient(108, 46, -102).move_to(calcium).set_height(12),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(25)\n",
        "\n",
        "\n",
        "class JigglesInCalciteY(JigglesInCalcite):\n",
        "    polarization_direction = 0\n",
        "\n",
        "\n",
        "class SpiralPaths(InteractiveScene):\n",
        "    default_frame_orientation = (-30, 70)\n",
        "    color = RED\n",
        "    sign = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Sucrose\n",
        "        sucrose = Sucrose()\n",
        "        sucrose.rotate(PI / 2)\n",
        "        sucrose.set_height(7)\n",
        "        sucrose.set_opacity(0.2)\n",
        "        self.add(sucrose)\n",
        "\n",
        "        # Frame motion\n",
        "        frame = self.frame\n",
        "        frame.add_updater(lambda t: t.reorient(-30 * math.sin(0.1 * self.time)))\n",
        "\n",
        "        # Spiral\n",
        "        helix = ParametricCurve(\n",
        "            lambda t: [\n",
        "                math.cos(self.sign * t),\n",
        "                math.sin(self.sign * t),\n",
        "                0.25 * t\n",
        "            ],\n",
        "            t_range=(-TAU, TAU, 0.01)\n",
        "        )\n",
        "        line = Line(helix.get_end(), helix.get_start())\n",
        "        spiral = VGroup(helix, line)\n",
        "        spiral.rotate(PI / 2, LEFT, about_point=ORIGIN)\n",
        "        spiral.set_height(5, stretch=True)\n",
        "        spiral.center()\n",
        "        spiral.set_stroke(self.color, 1)\n",
        "        spiral.set_flat_stroke(False)\n",
        "\n",
        "        self.add(spiral)\n",
        "\n",
        "        charge = Group(\n",
        "            GlowDot(color=self.color),\n",
        "            TrueDot(color=self.color, radius=0.15),\n",
        "        )\n",
        "        self.add(charge)\n",
        "        for _ in range(5):\n",
        "            self.play(MoveAlongPath(charge, helix, run_time=3))\n",
        "            self.play(MoveAlongPath(charge, line, run_time=2))\n",
        "\n",
        "\n",
        "class SpiralPathsLeftHanded(SpiralPaths):\n",
        "    sign = -1\n",
        "    color = YELLOW\n"
    ]
}