{
    "topic": "demonstrates the concept of visualizing a scalar field by changing the opacity of dots",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.optics_puzzles.objects import *\n",
        "\n",
        "\n",
        "class WaveIntoMedium(TimeVaryingVectorField):\n",
        "    def __init__(\n",
        "        self,\n",
        "        interface_origin=ORIGIN,\n",
        "        interface_normal=DR,\n",
        "        prop_direction=RIGHT,\n",
        "        index=1.5,\n",
        "        c=2.0,\n",
        "        frequency=0.25,\n",
        "        amplitude=1.0,\n",
        "        x_density=5.0,\n",
        "        y_density=5.0,\n",
        "        width=15.0,\n",
        "        height=15.0,\n",
        "        norm_to_opacity_func=lambda n: np.tanh(n),\n",
        "        **kwargs\n",
        "    ):\n",
        "        def time_func(points, time):\n",
        "            k = frequency / c\n",
        "            phase = TAU * (k * np.dot(points, prop_direction.T) - frequency * time)\n",
        "            kickback = np.dot(points - interface_origin, interface_normal.T)\n",
        "            kickback[kickback < 0] = 0\n",
        "            phase += kickback * index * c\n",
        "            return amplitude * np.outer(np.cos(phase), OUT)\n",
        "\n",
        "        super().__init__(\n",
        "            time_func,\n",
        "            x_density=x_density,\n",
        "            y_density=y_density,\n",
        "            width=width,\n",
        "            height=height,\n",
        "            norm_to_opacity_func=norm_to_opacity_func,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "class ScalarFieldByOpacity(DotCloud):\n",
        "    def __init__(\n",
        "        self,\n",
        "        # Takes (n, 3) array of points to n-array of values between 0 and 1\n",
        "        opacity_func,\n",
        "        width=15,\n",
        "        height=8,\n",
        "        density=10,\n",
        "        color=WHITE,\n",
        "    ):\n",
        "        step = 1.0 / density\n",
        "        radius = step / 2.0\n",
        "        points = np.array([\n",
        "            [x, y, 0]\n",
        "            for x in np.arange(-width / 2, width / 2 + step, step)\n",
        "            for y in np.arange(-height / 2, height / 2 + step, step)\n",
        "        ])\n",
        "\n",
        "        super().__init__(points, color=color, radius=radius)\n",
        "        self.opacity_func = opacity_func\n",
        "\n",
        "        def update_opacity(dots):\n",
        "            dots.set_opacity(opacity_func(dots.get_points()))\n",
        "\n",
        "        self.add_updater(update_opacity)\n",
        "\n",
        "\n",
        "class WavesByOpacity(ScalarFieldByOpacity):\n",
        "    def __init__(\n",
        "        self,\n",
        "        wave: VectorField,\n",
        "        vects_to_opacities=lambda v: np.tanh(v[:, 2]),\n",
        "        **kwargs\n",
        "    ):\n",
        "        super().__init__(\n",
        "            opacity_func=lambda p: vects_to_opacities(wave.func(p)),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class SnellsLaw(InteractiveScene):\n",
        "    # index = 1.5\n",
        "    index = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup key objects\n",
        "        medium = FullScreenRectangle()\n",
        "        medium.set_fill(BLUE, 0.3).set_stroke(width=0)\n",
        "        medium.stretch(0.5, 1, about_edge=DOWN)\n",
        "\n",
        "        hit_point = medium.get_top()\n",
        "        angle_tracker = ValueTracker(40 * DEGREES)\n",
        "        beam = self.get_beam(angle_tracker, hit_point)\n",
        "\n",
        "        glow = GlowDot(color=YELLOW)\n",
        "\n",
        "        self.add(medium)\n",
        "\n",
        "        # Shine in\n",
        "        anim_kw = dict(run_time=3, rate_func=linear)\n",
        "        self.play(\n",
        "            ShowCreation(beam, **anim_kw),\n",
        "            UpdateFromFunc(glow, lambda m: m.move_to(beam.get_end()))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add angle labels\n",
        "        normal_line = Line(2 * UP, 2 * DOWN)\n",
        "        normal_line.move_to(hit_point)\n",
        "        normal_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        def get_theta1():\n",
        "            return angle_tracker.get_value()\n",
        "\n",
        "        def get_theta2():\n",
        "            return np.arcsin(np.sin(get_theta1()) / self.index)\n",
        "\n",
        "        arc_kw = dict(radius=0.8, stroke_width=1)\n",
        "        arc1 = always_redraw(lambda: Arc(90 * DEGREES, get_theta1(), **arc_kw))\n",
        "        arc2 = always_redraw(lambda: Arc(-90 * DEGREES, get_theta2(), **arc_kw))\n",
        "        theta1_label = Tex(R\"\\theta_1\")\n",
        "        theta1_label.arc = arc1\n",
        "        theta2_label = Tex(R\"\\theta_2\")\n",
        "        theta2_label.arc = arc2\n",
        "\n",
        "        def update_theta_label(label):\n",
        "            point = label.arc.pfp(0.2)\n",
        "            vect = normalize(point - hit_point)\n",
        "            label.set_height(min(0.4, max(1.0 * label.arc.get_width(), 1e-2)))\n",
        "            label.next_to(point, vect, buff=SMALL_BUFF)\n",
        "\n",
        "        theta1_label.add_updater(update_theta_label)\n",
        "        theta2_label.add_updater(update_theta_label)\n",
        "\n",
        "        ineq = Tex(R\"\\theta_1 > \\theta_2\")\n",
        "        ineq.move_to(FRAME_WIDTH * RIGHT / 4 + 3 * UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                ShowCreation(normal_line),\n",
        "                ShowCreation(arc1),\n",
        "                ShowCreation(arc2),\n",
        "                Write(theta1_label),\n",
        "                Write(theta2_label),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1\n",
        "            ),\n",
        "            FadeIn(ineq, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        angle_labels = VGroup(normal_line, arc1, arc2, theta1_label, theta2_label)\n",
        "\n",
        "        # Vary the angle for a bit\n",
        "        self.remove(arc2, theta2_label, ineq)\n",
        "\n",
        "        beam.set_stroke(opacity=1, width=2)\n",
        "        for width in np.linspace(2, 10.0, 40):\n",
        "            beam_copy = beam.copy()\n",
        "            beam_copy.set_stroke(width=width, opacity=0.2 / (width)**1.4)\n",
        "            self.add(beam_copy)\n",
        "\n",
        "        for angle in [70 * DEGREES, -50 * DEGREES, 40 * DEGREES]:\n",
        "            self.play(angle_tracker.animate.set_value(angle), run_time=5)\n",
        "\n",
        "        # Tank analogy\n",
        "        tank = SVGMobject(\"tank\")\n",
        "        tank.set_fill(WHITE)\n",
        "        tank.rotate(-16 * DEGREES)\n",
        "        tank.set_height(1)\n",
        "        tank.move_to(beam.pfp(0.25))\n",
        "\n",
        "        self.play(FadeOut(angle_labels))\n",
        "        self.frame.set_height(4)\n",
        "        self.play(\n",
        "            tank.animate.move_to(beam.pfp(0.49)).set_anim_args(rate_func=linear, run_time=6),\n",
        "            VFadeIn(tank),\n",
        "            self.frame.animate.set_height(4).set_anim_args(time_span=(4, 6))\n",
        "        )\n",
        "        self.play(\n",
        "            tank.animate.rotate(get_theta2() - get_theta1()).move_to(hit_point + 0.3 * UP + 0.1 * LEFT),\n",
        "            rate_func=linear,\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.play(\n",
        "            tank.animate.move_to(beam.pfp(0.65)).set_anim_args(rate_func=linear, run_time=8),\n",
        "            VFadeOut(tank, time_span=(7, 8)),\n",
        "            self.frame.animate.set_height(8).set_anim_args(time_span=(6, 8))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write Snell's law\n",
        "        law = Tex(R\"{\\sin(\\theta_1) \\over v_1} = {\\sin(\\theta_2) \\over v_2}\", font_size=52)\n",
        "        title = TexText(\"Snell's Law\", font_size=60)\n",
        "        group = VGroup(title, law)\n",
        "        group.arrange(DOWN, buff=0.75)\n",
        "        group.to_corner(UR)\n",
        "\n",
        "        self.play(FadeIn(angle_labels))\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            FlashUnder(title, run_time=2),\n",
        "            FadeOut(ineq[\">\"]),\n",
        "            Transform(ineq[R\"\\theta_1\"], law[R\"\\theta_1\"]),\n",
        "            Transform(ineq[R\"\\theta_2\"], law[R\"\\theta_2\"]),\n",
        "        )\n",
        "        self.play(FadeIn(law))\n",
        "        self.wait()\n",
        "        tl1_copy = theta1_label.copy()\n",
        "        tl2_copy = theta2_label.copy()\n",
        "        self.play(LaggedStart(\n",
        "            Transform(tl1_copy, law[R\"\\theta_1\"]),\n",
        "            Transform(tl2_copy, law[R\"\\theta_2\"]),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(FadeIn(law, lag_ratio=0.1, run_time=2))\n",
        "        self.remove(tl1_copy, tl2_copy)\n",
        "        self.wait()\n",
        "\n",
        "        # Vary the angle again\n",
        "        for angle in [70 * DEGREES, 20 * DEGREES, 40 * DEGREES]:\n",
        "            self.play(angle_tracker.animate.set_value(angle), run_time=3)\n",
        "\n",
        "        # Show speeds\n",
        "        in_beam = Line(beam.get_start(), hit_point)\n",
        "        out_beam = Line(hit_point, beam.get_end())\n",
        "        in_beam.set_length(8, about_point=hit_point)\n",
        "\n",
        "        def get_dot_anim():\n",
        "            dot = GlowDot()\n",
        "            return Succession(\n",
        "                MoveAlongPath(dot, in_beam, rate_func=linear, run_time=3),\n",
        "                MoveAlongPath(dot, out_beam, rate_func=linear, run_time=3),\n",
        "                remover=True,\n",
        "            )\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *(\n",
        "                get_dot_anim()\n",
        "                for x in range(50)\n",
        "            ),\n",
        "            lag_ratio=0.02,\n",
        "            run_time=20,\n",
        "        ))\n",
        "\n",
        "    def get_beam(self, angle_tracker, hit_point, stroke_color=YELLOW, stroke_width=3):\n",
        "        result = Line()\n",
        "        result.set_stroke(stroke_color, stroke_width)\n",
        "\n",
        "        def update_beam(beam):\n",
        "            theta1 = angle_tracker.get_value()\n",
        "            theta2 = np.arcsin(np.sin(theta1) / self.index)\n",
        "            beam.set_points_as_corners([\n",
        "                hit_point + 0.6 * FRAME_HEIGHT * rotate_vector(UP, theta1) / math.cos(theta1),\n",
        "                hit_point,\n",
        "                hit_point + 0.6 * FRAME_HEIGHT * rotate_vector(DOWN, theta2) / math.cos(theta2),\n",
        "            ])\n",
        "\n",
        "        result.add_updater(update_beam)\n",
        "        return result\n",
        "\n",
        "\n",
        "class WavesIntoAngledMedium(InteractiveScene):\n",
        "    default_frame_orientation = (0, 0)\n",
        "    interface_origin = ORIGIN\n",
        "    interface_normal = DR\n",
        "    prop_direction = RIGHT\n",
        "    frequency = 0.5\n",
        "    c = 1.0\n",
        "    index = 2.0\n",
        "    amplitude = 0.5\n",
        "\n",
        "    def get_medium(\n",
        "        self,\n",
        "        width=10,\n",
        "        height=30,\n",
        "        depth=5,\n",
        "        color=BLUE,\n",
        "        opacity=0.2,\n",
        "    ):\n",
        "        medium = VCube(side_length=1.0)\n",
        "        medium.set_shape(width, height, depth)\n",
        "        medium.set_fill(color, opacity)\n",
        "        medium.move_to(self.interface_origin, LEFT)\n",
        "        medium.rotate(\n",
        "            angle_of_vector(self.interface_normal),\n",
        "            about_point=self.interface_origin\n",
        "        )\n",
        "        return medium\n",
        "\n",
        "    def get_wave(self, **kwargs):\n",
        "        config = dict(\n",
        "            interface_origin=self.interface_origin,\n",
        "            interface_normal=self.interface_normal,\n",
        "            prop_direction=self.prop_direction,\n",
        "            frequency=self.frequency,\n",
        "            c=self.c,\n",
        "            index=self.index,\n",
        "            max_vect_len=np.inf,\n",
        "            amplitude=self.amplitude,\n",
        "            norm_to_opacity_func=lambda n: sigmoid(n),\n",
        "        )\n",
        "        config.update(kwargs)\n",
        "        return WaveIntoMedium(**config)\n",
        "\n",
        "    def get_wave_dots(self, wave, density=20, offset=0.2, color=WHITE, max_opacity=1.0, **kwargs):\n",
        "        return WavesByOpacity(\n",
        "            wave,\n",
        "            density=density,\n",
        "            vects_to_opacities=lambda v: max_opacity * np.tanh(v[:, 2] - offset * self.amplitude),\n",
        "            color=color,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "class TransitionToOverheadView(WavesIntoAngledMedium):\n",
        "    interface_normal = RIGHT\n",
        "    index = 2.0\n",
        "    amplitude = 0.5\n",
        "\n",
        "    def construct(self):\n",
        "        # 1D case\n",
        "        frame = self.frame\n",
        "        medium = self.get_medium(opacity=0.3, height=8.0, depth=2.0)\n",
        "        medium.remove(medium[-1])\n",
        "        medium.sort(lambda p: -p[1] - p[2])\n",
        "        medium.set_stroke(WHITE, 0.5, 0.5)\n",
        "        medium.set_flat_stroke(False)\n",
        "        wave_1d = self.get_wave(x_density=10, height=0.0)\n",
        "        wave_1d.set_stroke(YELLOW)\n",
        "        plane = NumberPlane(\n",
        "            background_line_style=dict(\n",
        "                stroke_color=BLUE_D,\n",
        "                stroke_width=1,\n",
        "                stroke_opacity=1,\n",
        "            ),\n",
        "        )\n",
        "        plane.axes.set_stroke(width=1)\n",
        "        plane.fade(0.5)\n",
        "\n",
        "        self.add(plane, medium, wave_1d)\n",
        "        frame.reorient(-37, 61, 0)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 90).set_height(6),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "        # Highlight wave length\n",
        "        past_time = wave_1d.time\n",
        "        wave_1d.suspend_updating()\n",
        "        wave_len = 1.0\n",
        "        mult = 2.0\n",
        "        brace1 = Brace(Line(ORIGIN, mult * wave_len * RIGHT), UP)\n",
        "        brace1.add(brace1.get_tex(Rf\"\\lambda = {wave_len}\"))\n",
        "        brace2 = Brace(Line(ORIGIN, 0.6 * mult * wave_len * RIGHT), UP)\n",
        "        brace2.add(brace2.get_tex(Rf\"\\lambda = {0.6 * wave_len}\"))\n",
        "\n",
        "        for brace in [brace1, brace2]:\n",
        "            brace.rotate(90 * DEGREES, RIGHT)\n",
        "            brace.set_fill(border_width=0)\n",
        "\n",
        "        brace1.next_to(3 * LEFT + 0.35 * OUT, OUT)\n",
        "        brace2.next_to(1.85 * RIGHT + 0.35 * OUT, OUT)\n",
        "\n",
        "        self.play(FadeIn(brace1, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(brace1.copy(), brace2))\n",
        "        self.wait()\n",
        "        wave_1d.time = past_time\n",
        "        wave_1d.resume_updating()\n",
        "        self.play(\n",
        "            FadeOut(brace1, RIGHT),\n",
        "            FadeOut(brace2, 0.6 * RIGHT),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Transition to 2d\n",
        "        wave_2d = self.get_wave(\n",
        "            width=20.0, height=8.0,\n",
        "            norm_to_opacity_func=lambda n: 0.5 * sigmoid(2 * n),\n",
        "        )\n",
        "        wave_2d.set_stroke(YELLOW)\n",
        "        invisible_wave_2d = self.get_wave(\n",
        "            width=20.0, height=12.0,\n",
        "            norm_to_opacity_func=None,\n",
        "            stroke_opacity=0,\n",
        "        )\n",
        "        wave_dots = self.get_wave_dots(\n",
        "            invisible_wave_2d,\n",
        "        )\n",
        "\n",
        "        self.remove(wave_1d)\n",
        "        wave_2d.time = wave_1d.time\n",
        "        self.add(wave_2d)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-10, 45).set_height(8).set_anim_args(\n",
        "                run_time=7,\n",
        "                time_span=(1, 7),\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.wait(8)\n",
        "\n",
        "        self.remove(wave_2d)\n",
        "        invisible_wave_2d.time = wave_2d.time\n",
        "        self.add(invisible_wave_2d, wave_dots)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0),\n",
        "            plane.animate.fade(0.5),\n",
        "            medium.animate.set_opacity(0.2),\n",
        "            run_time=4,\n",
        "\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show wave lengths again\n",
        "        invisible_wave_2d.suspend_updating()\n",
        "        VGroup(brace1, brace2).rotate(90 * DEGREES, LEFT)\n",
        "        VGroup(brace1, brace2).set_backstroke(BLACK, 3)\n",
        "        brace1.next_to(4 * LEFT, UP)\n",
        "        brace2.next_to(2.45 * RIGHT, UP)\n",
        "        braces = VGroup(brace1, brace2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(braces),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pan back down to 1d wave\n",
        "        wave_1d.time = invisible_wave_2d.time\n",
        "        wave_1d.update()\n",
        "        wave_1d.clear_updaters()\n",
        "        self.play(\n",
        "            # FadeOut(wave_dots),\n",
        "            FadeIn(wave_1d),\n",
        "            frame.animate.reorient(0, 70),\n",
        "            braces.animate.rotate(90 * DEGREES, RIGHT, about_point=ORIGIN).shift(0.3 * OUT),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AngledMedium(WavesIntoAngledMedium):\n",
        "    amplitude = 1.2\n",
        "    frequency = 2.0 / 3.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Add setup\n",
        "        plane = NumberPlane()\n",
        "        plane.fade(0.75)\n",
        "        medium = self.get_medium()\n",
        "        self.add(plane)\n",
        "        self.add(medium)\n",
        "\n",
        "        # Wave\n",
        "        wave = self.get_wave()\n",
        "        wave.set_opacity(0)\n",
        "        wave_dots = self.get_wave_dots(wave, offset=0.5)\n",
        "        self.add(wave, wave_dots)\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class AngledMediumSingleFront(AngledMedium):\n",
        "    def get_wave_dots(self, wave, density=20, offset=0.2, color=RED, max_opacity=1.0, **kwargs):\n",
        "        return super().get_wave_dots(wave, density, offset, color, max_opacity, **kwargs)\n",
        "\n",
        "\n",
        "class AngledMediumAnnotations(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up the lane\n",
        "        h_lines = Line(LEFT, RIGHT).replicate(3)\n",
        "        h_lines.set_width(0.7 * FRAME_WIDTH)\n",
        "        h_lines.arrange(DOWN, buff=0.5)\n",
        "        h_lines.move_to(ORIGIN, RIGHT)\n",
        "\n",
        "        index = WavesIntoAngledMedium.index\n",
        "        angle = math.asin(math.sin(45 * DEGREES) / index)\n",
        "        diag_lines = h_lines.copy()\n",
        "        for line1, line2 in zip(h_lines, diag_lines):\n",
        "            line2.move_to(line1.get_end(), LEFT)\n",
        "            line2.rotate(-angle, about_point=line1.get_end())\n",
        "\n",
        "        lane_points = [\n",
        "            h_lines[0].get_left(),\n",
        "            h_lines[0].get_right(),\n",
        "            diag_lines[0].get_end(),\n",
        "            diag_lines[2].get_end(),\n",
        "            h_lines[2].get_right(),\n",
        "            h_lines[2].get_left(),\n",
        "        ]\n",
        "\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        fade_rect.scale(1.5)\n",
        "        fade_rect.start_new_path(lane_points[-1])\n",
        "        for point in lane_points:\n",
        "            fade_rect.add_line_to(point)\n",
        "\n",
        "        fade_rect.set_fill(BLACK, 0.8)\n",
        "\n",
        "        beam = h_lines[1].copy()\n",
        "        beam.add_line_to(diag_lines[1].get_end())\n",
        "        beam.set_stroke(YELLOW, 1.5)\n",
        "        beam.insert_n_curves(100)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(beam, run_time=3),\n",
        "            VShowPassingFlash(beam.copy().set_stroke(width=5), run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LineGame(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add line and medium\n",
        "        interface = Line(6 * DL, 6 * UR)\n",
        "        medium = Square().set_fill(BLUE, 0.2).set_stroke(width=0)\n",
        "        medium.move_to(ORIGIN, LEFT)\n",
        "        medium.rotate(-45 * DEGREES, about_point=ORIGIN)\n",
        "        medium.scale(20, about_point=ORIGIN)\n",
        "        self.add(medium, interface)\n",
        "\n",
        "        # Prepare lines, with control\n",
        "        large_spacing = 1.5\n",
        "        small_spacing = 0.6 * large_spacing\n",
        "\n",
        "        circ = Circle(radius=0.5)\n",
        "        circ.set_fill(interpolate_color(BLUE_E, BLACK, 0.5), 1)\n",
        "        circ.set_stroke(WHITE, 2)\n",
        "        circ.next_to(ORIGIN, RIGHT, buff=1.0)\n",
        "        dial = Vector(0.8 * RIGHT)\n",
        "        dial.move_to(circ)\n",
        "\n",
        "        top_lines = self.get_line_group(interface, UP, large_spacing)\n",
        "        low_lines = always_redraw(lambda: self.get_line_group(\n",
        "            interface, rotate_vector(dial.get_vector(), -PI / 2), small_spacing,\n",
        "            line_color=GREEN,\n",
        "            dot_color=YELLOW\n",
        "        ))\n",
        "\n",
        "        top_spacing_label = self.get_spacing_label(top_lines[1], R\"\\lambda_1\")\n",
        "        low_spacing_label = self.get_spacing_label(low_lines[1], R\"\\lambda_2\")\n",
        "        low_spacing_label.shift(UP)\n",
        "\n",
        "        # Add top lines, then lower lines\n",
        "        self.play(FadeIn(top_lines, lag_ratio=0.1))\n",
        "        self.play(Write(top_spacing_label))\n",
        "        self.wait()\n",
        "        self.highlight_intersection_points(top_lines, PINK, LEFT)\n",
        "        self.wait()\n",
        "\n",
        "        # Reposition lower lines\n",
        "        key_angle = -19.9 * DEGREES\n",
        "        dial.rotate(key_angle)\n",
        "        low_lines.update()\n",
        "        low_spacing_label.rotate(key_angle, about_point=ORIGIN)\n",
        "        top_lines.save_state()\n",
        "        self.play(\n",
        "            top_lines.animate.fade(0.8),\n",
        "            FadeIn(low_lines, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(Write(low_spacing_label))\n",
        "        self.wait()\n",
        "        dial.set_stroke(opacity=0)\n",
        "        self.play(\n",
        "            Rotate(dial, -key_angle, run_time=2, remover=True),\n",
        "            Rotate(low_spacing_label, -key_angle, run_time=2, about_point=ORIGIN),\n",
        "        )\n",
        "        dial.set_stroke(opacity=1)\n",
        "        self.wait()\n",
        "        self.highlight_intersection_points(low_lines, YELLOW, RIGHT)\n",
        "        self.play(Restore(top_lines))\n",
        "\n",
        "        # Rotate lower lines\n",
        "        self.add(low_lines)\n",
        "        self.play(\n",
        "            FadeIn(circ),\n",
        "            FadeIn(dial)\n",
        "        )\n",
        "        low_lines.resume_updating()\n",
        "        for angle in [-15, -15, 10.1]:\n",
        "            self.play(\n",
        "                Rotate(dial, angle * DEGREES),\n",
        "                Rotate(low_spacing_label, angle * DEGREES, about_point=ORIGIN),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "        low_lines.suspend_updating()\n",
        "        self.highlight_intersection_points(low_lines, YELLOW)\n",
        "\n",
        "        # Ask about angles\n",
        "        theta1 = top_lines[1][0].get_angle() - interface.get_angle()\n",
        "        theta2 = low_lines[1][0].get_angle() + TAU - (interface.get_angle() + PI)\n",
        "        radius = 0.75\n",
        "        arc1 = Arc(interface.get_angle(), theta1, radius=radius)\n",
        "        arc2 = Arc(interface.get_angle() + PI, theta2, radius=radius)\n",
        "        theta1_label = Tex(R\"\\theta_1\", font_size=36)\n",
        "        theta2_label = Tex(R\"\\theta_2\", font_size=36)\n",
        "        theta1_label.next_to(arc1.pfp(0.5), UP, SMALL_BUFF)\n",
        "        theta2_label.next_to(arc2.pfp(0.75), DL, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc1),\n",
        "            Write(theta1_label),\n",
        "            self.frame.animate.set_height(6.5).set_anim_args(run_time=2),\n",
        "            FadeOut(circ),\n",
        "            FadeOut(dial),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arc2),\n",
        "            Write(theta2_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_line_group(\n",
        "        self,\n",
        "        interface,\n",
        "        line_direction=UP,\n",
        "        spacing=1.0,\n",
        "        n_lines=17,\n",
        "        length=30,\n",
        "        line_color=WHITE,\n",
        "        line_stroke_width=2,\n",
        "        dot_radius=0.05,\n",
        "        dot_color=RED,\n",
        "        dot_opacity=1,\n",
        "    ):\n",
        "        # Calculate dot spacing\n",
        "        interface_vect = normalize(interface.get_vector())\n",
        "        line_vect = normalize(line_direction)\n",
        "        interface_center = interface.get_center()\n",
        "        angle = angle_between_vectors(interface_vect, line_vect)\n",
        "        dot_spacing = spacing / math.sin(angle)\n",
        "\n",
        "        points = [\n",
        "            interface_center + i * dot_spacing * interface_vect\n",
        "            for i in range(-n_lines // 2, n_lines // 2 + 1)\n",
        "        ]\n",
        "        dots = VGroup(*(\n",
        "            Dot(point, radius=dot_radius).set_fill(dot_color, dot_opacity)\n",
        "            for point in points\n",
        "        ))\n",
        "        lines = VGroup(*(\n",
        "            Line(\n",
        "                point,\n",
        "                point + length * line_vect,\n",
        "                stroke_color=line_color,\n",
        "                stroke_width=line_stroke_width,\n",
        "            )\n",
        "            for point in points\n",
        "        ))\n",
        "        result = VGroup(dots, lines)\n",
        "        result.set_stroke(background=True)\n",
        "        return result\n",
        "\n",
        "    def get_spacing_label(self, lines, label_tex):\n",
        "        n = len(lines)\n",
        "        line1, line2 = lines[n // 2: (n // 2) + 2]\n",
        "        x1 = line1.get_x()\n",
        "        x2 = line2.get_x()\n",
        "        dist = x2 - x1\n",
        "        arrows = VGroup(\n",
        "            Arrow(dist * LEFT / 4, dist * RIGHT / 2, buff=SMALL_BUFF),\n",
        "            Arrow(dist * RIGHT / 4, dist * LEFT / 2, buff=SMALL_BUFF),\n",
        "        )\n",
        "        label = Tex(label_tex)\n",
        "        label.set_max_width(0.9 * arrows.get_width())\n",
        "        label.next_to(arrows, UP, MED_SMALL_BUFF)\n",
        "        result = VGroup(arrows, label)\n",
        "        result.move_to(VGroup(line1, line2))\n",
        "        result.shift_onto_screen(buff=LARGE_BUFF)\n",
        "        label.set_fill(border_width=0.5)\n",
        "        return result\n",
        "\n",
        "    def highlight_intersection_points(self, line_group, color, arrow_direction=LEFT):\n",
        "        points = VGroup(*(p for p in line_group[0] if -4 < p.get_y() < 4))\n",
        "        arrows = VGroup(*(\n",
        "            Vector(arrow_direction).next_to(point, -arrow_direction, SMALL_BUFF)\n",
        "            for point in points\n",
        "        ))\n",
        "        arrows.set_color(color)\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows, lag_ratio=0.25))\n",
        "        self.play(\n",
        "            LaggedStartMap(Indicate, line_group[0], scale_factor=2, color=color, lag_ratio=0.2),\n",
        "            LaggedStartMap(FlashAround, line_group[0], buff=0.2, color=color, lag_ratio=0.2),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(FadeOut(arrows))\n",
        "\n",
        "\n",
        "class Prism(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add flat\n",
        "        flat_prism = Triangle()\n",
        "        flat_prism.set_height(4)\n",
        "        flat_prism.set_stroke(WHITE, 1)\n",
        "        flat_prism.set_fill(BLUE, 0.2)\n",
        "\n",
        "        prism = Prismify(flat_prism, depth=5)\n",
        "        prism.set_fill(BLUE_D, 0.25, border_width=0)\n",
        "        prism.set_stroke(WHITE, 0)\n",
        "        prism.sort(lambda p: -p[2])\n",
        "        prism.apply_depth_test()\n",
        "        prism.deactivate_depth_test()\n",
        "        prism.set_shading(0.5, 0.5, 0)\n",
        "\n",
        "        verts = flat_prism.get_vertices()\n",
        "        in_edge = Line(verts[0], verts[1])\n",
        "        out_edge = Line(verts[0], verts[2])\n",
        "\n",
        "        self.add(flat_prism)\n",
        "\n",
        "        # Beams of light\n",
        "        frame = self.frame\n",
        "        self.camera.light_source.move_to((-10, -10, 10))\n",
        "\n",
        "        left_side = 10 * LEFT\n",
        "        in_beam = Line(left_side, in_edge.get_center())\n",
        "        in_beam.set_stroke(WHITE, 3)\n",
        "\n",
        "        def get_beams(light_in):\n",
        "            return self.get_beams(\n",
        "                min_index=1.3,\n",
        "                # max_index=1.4,\n",
        "                max_index=1.45,\n",
        "                n_beams=200,\n",
        "                in_beam=light_in,\n",
        "                in_edge=in_edge,\n",
        "                out_edge=out_edge,\n",
        "            )\n",
        "\n",
        "        beams = always_redraw(lambda: get_beams(in_beam))\n",
        "        self.play(\n",
        "            ShowCreation(beams, time_span=(0.5, 1.5), lag_ratio=0),\n",
        "            ShowCreation(in_beam, time_span=(0, 1.0)),\n",
        "            rate_func=linear\n",
        "        )\n",
        "\n",
        "        # Show x-ray\n",
        "        x_ray = self.get_beams(0.8, 0.8, 1, in_beam, in_edge, out_edge)\n",
        "        x_ray.set_stroke(\"#FF00D5\", 8)\n",
        "\n",
        "        self.add(x_ray, in_beam)\n",
        "        self.play(ShowCreation(x_ray, run_time=2))\n",
        "        self.wait()\n",
        "        self.remove(x_ray)\n",
        "\n",
        "        # Transition to 3d\n",
        "        self.play(\n",
        "            FadeOut(flat_prism),\n",
        "            FadeIn(prism),\n",
        "            frame.animate.reorient(-90, 35, 90).set_height(15).move_to(RIGHT + 4 * DOWN),\n",
        "            run_time=4,\n",
        "        )\n",
        "        turn_animation_into_updater(\n",
        "            ApplyMethod(frame.reorient, -90, 10, 90, run_time=15)\n",
        "        )\n",
        "\n",
        "        # for vect, alpha in zip([DOWN, 2 * UP, ORIGIN], [0.3, 0.3, 0.5]):\n",
        "        for vect, alpha in zip([5 * DOWN, 3 * DOWN, 4 * DOWN], [0.3, 0.3, 0.5]):\n",
        "            self.play(\n",
        "                in_beam.animate.put_start_and_end_on(left_side + vect, in_edge.pfp(alpha)),\n",
        "                # run_time=5\n",
        "            )\n",
        "\n",
        "        # Back to 2d\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0).set_height(8),\n",
        "            in_beam.animate.put_start_and_end_on(left_side + 2 * DOWN, in_edge.get_center()),\n",
        "            FadeOut(prism, time_span=(1, 2)),\n",
        "            FadeIn(flat_prism, time_span=(1, 2)),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def get_beams(self, min_index, max_index, n_beams, in_beam, in_edge: Line, out_edge: Line):\n",
        "        alphas = np.linspace(0, 1, n_beams)**1.5\n",
        "        indices = interpolate(min_index, max_index, alphas)\n",
        "\n",
        "        normal1 = rotate_vector(normalize(in_edge.get_vector()), PI / 2)\n",
        "        normal2 = rotate_vector(normalize(out_edge.get_vector()), PI / 2)\n",
        "        in_point = in_beam.get_end()\n",
        "        vect1 = normalize(in_beam.get_vector())\n",
        "\n",
        "        theta1 = angle_between_vectors(normal1, vect1)\n",
        "        theta2s = np.arcsin(np.sin(theta1) / indices)\n",
        "        vect2s = np.array([\n",
        "            rotate_vector(normal1, theta2)\n",
        "            for theta2 in theta2s\n",
        "        ])\n",
        "        out_points = np.array([\n",
        "            find_intersection(in_point, vect2, out_edge.get_start(), out_edge.get_vector())\n",
        "            for vect2 in vect2s\n",
        "        ])\n",
        "        theta3s = np.array([\n",
        "            angle_between_vectors(normal2, vect2)\n",
        "            for vect2 in vect2s\n",
        "        ])\n",
        "        theta4s = np.arcsin(np.sin(theta3s) * indices)\n",
        "        vect3s = np.array([\n",
        "            rotate_vector(normal2, -theta4)\n",
        "            for theta4 in theta4s\n",
        "        ])\n",
        "\n",
        "        beams = VGroup(*(\n",
        "            VMobject().set_points_as_corners([\n",
        "                in_point - 1.0 * FRAME_WIDTH * vect1,\n",
        "                in_point,\n",
        "                out_point,\n",
        "                out_point + 3.0 * FRAME_WIDTH * vect3\n",
        "            ])\n",
        "            for out_point, vect3 in zip(out_points, vect3s)\n",
        "        ))\n",
        "\n",
        "        for alpha, beam in zip(np.linspace(0, 1, n_beams), beams):\n",
        "            beam.set_stroke(get_spectral_color(alpha), 1, opacity=0.8)\n",
        "\n",
        "        return beams\n"
    ]
}