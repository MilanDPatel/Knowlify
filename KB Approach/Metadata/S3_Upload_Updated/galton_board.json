{
    "topic": "The mathematical concept being demonstrated is the Galton board problem, which involves dropping balls into bu",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.clt.main import *\n",
        "\n",
        "\n",
        "# Galton board\n",
        "\n",
        "class GaltonBoard(InteractiveScene):\n",
        "    random_seed = 1\n",
        "    pegs_per_row = 15\n",
        "    n_rows = 5\n",
        "    spacing = 1.0\n",
        "    top_buff = 1.0\n",
        "    peg_radius = 0.1\n",
        "    ball_radius = 0.1\n",
        "    bucket_floor_buff = 1.0\n",
        "    bucket_style = dict(\n",
        "        fill_color=GREY_D,\n",
        "        fill_opacity=1.0,\n",
        "    )\n",
        "    stack_ratio = 1.0\n",
        "    fall_factor = 0.6\n",
        "    # clink_sound = \"click.wav\"\n",
        "    clink_sound = \"plate.wav\"\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.ball_template = Sphere(\n",
        "            radius=self.ball_radius,\n",
        "            color=YELLOW,\n",
        "            resolution=(51, 26),\n",
        "        )\n",
        "        self.ball_template.rotate(90 * DEGREES, RIGHT)\n",
        "        self.ball_template.set_shading(0.25, 0.5, 0.5)\n",
        "        # ball = TrueDot(radius=self.ball_radius, color=color)\n",
        "        # ball.make_3d()\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, buckets),\n",
        "            LaggedStartMap(Write, pegs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Initial flurry\n",
        "        balls = self.drop_n_balls(25, pegs, buckets, sound=True)\n",
        "        self.wait()\n",
        "        balls.reverse_submobjects()\n",
        "        self.play(FadeOut(balls, lag_ratio=0.05))\n",
        "        for bucket in buckets:\n",
        "            bucket.balls.clear()\n",
        "            bucket.bottom.match_y(bucket[0].get_bottom())\n",
        "\n",
        "        # Single ball bouncing, step-by-step\n",
        "        ball = self.get_ball()\n",
        "        bits = np.random.randint(0, 2, self.n_rows)\n",
        "        full_trajectory, pieces = self.random_trajectory(ball, pegs, buckets, bits)\n",
        "\n",
        "        all_arrows = VGroup()\n",
        "        for piece, bit in zip(pieces, bits):\n",
        "            ball.move_to(piece.get_end())\n",
        "            pm_arrows = self.get_pm_arrows(ball)\n",
        "            self.play(self.falling_anim(ball, piece))\n",
        "            self.add_single_clink_sound()\n",
        "            self.play(FadeIn(pm_arrows, lag_ratio=0.1))\n",
        "            all_arrows.add(pm_arrows)\n",
        "            self.wait()\n",
        "            self.play(pm_arrows[1 - bit].animate.set_opacity(0.25))\n",
        "        for piece in pieces[-2:]:\n",
        "            self.play(self.falling_anim(ball, piece))\n",
        "        self.wait()\n",
        "\n",
        "        # Add up arrows\n",
        "        corner_sum_anim, corner_sum_fade = self.show_corner_sum(all_arrows, bits)\n",
        "        self.play(corner_sum_anim)\n",
        "        self.wait()\n",
        "\n",
        "        # Show buckets as sums\n",
        "        sums = range(-self.pegs_per_row + 2, self.pegs_per_row, 2)\n",
        "        sum_labels = VGroup(*(\n",
        "            Integer(s, font_size=24, include_sign=True) for s in sums\n",
        "        ))\n",
        "        for bucket, label in zip(buckets, sum_labels):\n",
        "            label.next_to(bucket, DOWN, SMALL_BUFF)\n",
        "\n",
        "        sum_labels.set_stroke(WHITE, 1)\n",
        "        self.play(Write(sum_labels))\n",
        "        self.wait()\n",
        "\n",
        "        for bucket, label in zip(buckets, sum_labels):\n",
        "            bucket.add(label)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(all_arrows, lag_ratio=0.025),\n",
        "            corner_sum_fade\n",
        "        )\n",
        "\n",
        "        # Show a few more trajectories with cumulative sum\n",
        "        for x in range(3):\n",
        "            ball = self.get_ball()\n",
        "            bits = np.random.randint(0, 2, self.n_rows)\n",
        "            full_trajectory, pieces = self.random_trajectory(ball, pegs, buckets, bits)\n",
        "\n",
        "            all_arrows = VGroup()\n",
        "\n",
        "            self.add(all_arrows)\n",
        "            for piece, bit in zip(pieces, bits):\n",
        "                ball.move_to(piece.get_end())\n",
        "                arrows = self.get_pm_arrows(ball)\n",
        "                all_arrows.add(arrows)\n",
        "                self.play(self.falling_anim(ball, piece))\n",
        "                self.add_single_clink_sound()\n",
        "                arrows[1 - bit].set_opacity(0.25)\n",
        "\n",
        "            corner_sum_anim, corner_sum_fade = self.show_corner_sum(all_arrows, bits)\n",
        "            self.play(self.falling_anim(ball, pieces[-2]))\n",
        "            self.add_single_clink_sound()\n",
        "            self.play(\n",
        "                self.falling_anim(ball, pieces[-1]),\n",
        "                corner_sum_anim,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(all_arrows, lag_ratio=0.025),\n",
        "                corner_sum_fade\n",
        "            )\n",
        "\n",
        "        # Show a flurry\n",
        "        self.drop_n_balls(25, pegs, buckets)\n",
        "\n",
        "        # Fade out irrelevant parts\n",
        "        n = self.pegs_per_row // 2\n",
        "        to_fade = VGroup()\n",
        "        peg_triangle = VGroup()\n",
        "        for row in range(self.n_rows):\n",
        "            r2 = row // 2\n",
        "            low = n - r2\n",
        "            high = n + 1 + r2 + (row % 2)\n",
        "            to_fade.add(pegs[row][:low])\n",
        "            to_fade.add(pegs[row][high:])\n",
        "            peg_triangle.add(pegs[row][low:high])\n",
        "\n",
        "        to_fade.add(buckets[:n - 3])\n",
        "        to_fade.add(buckets[n + 3:])\n",
        "\n",
        "        self.play(to_fade.animate.set_opacity(0.25), lag_ratio=0.01)\n",
        "\n",
        "        # Show relevant probabilities\n",
        "        point = peg_triangle[0][0].get_top() + MED_SMALL_BUFF * UP\n",
        "        v1 = peg_triangle[1][0].get_center() - peg_triangle[0][0].get_center()\n",
        "        v2 = peg_triangle[1][1].get_center() - peg_triangle[1][0].get_center()\n",
        "\n",
        "        def get_peg_label(n, k, split=False):\n",
        "            kw = dict(font_size=16)\n",
        "            if n == 0:\n",
        "                label = Tex(\"1\", font_size=24)\n",
        "            elif split and 0 < k < n:\n",
        "                label = VGroup(\n",
        "                    Tex(f\"{choose(n - 1, k - 1)} \\\\over {2**n}\", **kw),\n",
        "                    Tex(f\" + {{{choose(n - 1, k)} \\\\over {2**n}}}\", **kw),\n",
        "                )\n",
        "                label.arrange(RIGHT, buff=0.75 * label[0].get_width())\n",
        "            else:\n",
        "                label = VGroup(Tex(f\"{choose(n, k)} \\\\over {2**n}\", **kw))\n",
        "            label.move_to(point + n * v1 + k * v2)\n",
        "            return label\n",
        "\n",
        "        last_labels = VGroup(get_peg_label(0, 0))\n",
        "        self.play(FadeIn(last_labels))\n",
        "        for n in range(1, self.n_rows + 1):\n",
        "            split_labels = VGroup(*(get_peg_label(n, k, split=True) for k in range(n + 1)))\n",
        "            unsplit_labels = VGroup(*(get_peg_label(n, k, split=False) for k in range(n + 1)))\n",
        "            anims = [\n",
        "                TransformFromCopy(last_labels[0], split_labels[0]),\n",
        "                TransformFromCopy(last_labels[-1], split_labels[-1])\n",
        "            ]\n",
        "            for k in range(1, n):\n",
        "                anims.append(TransformFromCopy(last_labels[k - 1], split_labels[k][0]))\n",
        "                anims.append(TransformFromCopy(last_labels[k], split_labels[k][1]))\n",
        "\n",
        "            self.play(*anims)\n",
        "            self.play(*(\n",
        "                FadeTransformPieces(sl1, sl2)\n",
        "                for sl1, sl2 in zip(split_labels, unsplit_labels)\n",
        "            ))\n",
        "\n",
        "            last_labels = unsplit_labels\n",
        "\n",
        "        # Larger flurry\n",
        "        all_balls = Group()\n",
        "        for bucket in buckets:\n",
        "            bucket.bottom.match_y(bucket[0].get_bottom())\n",
        "            all_balls.add(*bucket.balls)\n",
        "            bucket.balls.clear()\n",
        "        self.play(LaggedStartMap(FadeOut, all_balls, run_time=1))\n",
        "\n",
        "        self.stack_ratio = 0.125\n",
        "        np.random.seed(0)\n",
        "        self.drop_n_balls(250, pegs, buckets, lr_factor=2)\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_pegs(self):\n",
        "        row = VGroup(*(\n",
        "            Dot(radius=self.peg_radius).shift(x * self.spacing * RIGHT)\n",
        "            for x in range(self.pegs_per_row)\n",
        "        ))\n",
        "        rows = VGroup(*(\n",
        "            row.copy().shift(y * self.spacing * DOWN * math.sqrt(3) / 2)\n",
        "            for y in range(self.n_rows)\n",
        "        ))\n",
        "        rows[1::2].shift(0.5 * self.spacing * LEFT)\n",
        "\n",
        "        rows.set_fill(GREY_C, 1)\n",
        "        rows.set_shading(0.5, 0.5)\n",
        "        rows.center()\n",
        "        rows.to_edge(UP, buff=self.top_buff)\n",
        "\n",
        "        return rows\n",
        "\n",
        "    def get_buckets(self, pegs):\n",
        "        # Buckets\n",
        "        points = [dot.get_center() for dot in pegs[-1]]\n",
        "        height = 0.5 * FRAME_HEIGHT + pegs[-1].get_y() - self.bucket_floor_buff\n",
        "\n",
        "        buckets = VGroup()\n",
        "        for point in points:\n",
        "            # Fully construct bucket here\n",
        "            width = 0.5 * self.spacing - self.ball_radius\n",
        "            buff = 0.7\n",
        "            p0 = point + 0.5 * self.spacing * DOWN + buff * width * RIGHT\n",
        "            p1 = p0 + height * DOWN\n",
        "            p2 = p1 + (1 - buff) * width * RIGHT\n",
        "            y = point[1] - 0.5 * self.spacing * math.sqrt(3) + self.ball_radius\n",
        "            p3 = p2[0] * RIGHT + y * UP\n",
        "            side1 = VMobject().set_points_as_corners([p0, p1, p2, p3, p0])\n",
        "            side1.set_stroke(WHITE, 0)\n",
        "            side1.set_style(**self.bucket_style)\n",
        "\n",
        "            side2 = side1.copy()\n",
        "            side2.flip(about_point=point)\n",
        "            side2.reverse_points()\n",
        "            side2.shift(self.spacing * RIGHT)\n",
        "\n",
        "            floor = Line(side1.get_corner(DR), side2.get_corner(DL))\n",
        "            floor.set_stroke(GREY_D, 1)\n",
        "            bucket = VGroup(side1, side2, floor)\n",
        "            bucket.set_shading(0.25, 0.25)\n",
        "\n",
        "            # Add  bottom reference\n",
        "            bucket.bottom = VectorizedPoint(floor.get_center())\n",
        "            bucket.add(bucket.bottom)\n",
        "\n",
        "            # Keep track of balls\n",
        "            bucket.balls = Group()\n",
        "\n",
        "            buckets.add(bucket)\n",
        "\n",
        "        self.add(buckets)\n",
        "\n",
        "        return buckets\n",
        "\n",
        "    def get_ball_arrows(self, ball, labels, sub_labels=[], colors=[RED, BLUE]):\n",
        "        arrows = VGroup()\n",
        "        for vect, color, label in zip([LEFT, RIGHT], colors, labels):\n",
        "            arrow = Vector(\n",
        "                0.5 * self.spacing * vect,\n",
        "                tip_width_ratio=3,\n",
        "                stroke_color=color\n",
        "            )\n",
        "            arrow.next_to(ball, vect, buff=0.1)\n",
        "            arrows.add(arrow)\n",
        "            text = TexText(label, font_size=28)\n",
        "            text.next_to(arrow, UP, SMALL_BUFF)\n",
        "            arrow.add(text)\n",
        "        # Possibly add smaller labels\n",
        "        for arrow, label in zip(arrows, sub_labels):\n",
        "            text = Text(label, font_size=16)\n",
        "            text.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "            arrow.add(text)\n",
        "        return arrows\n",
        "\n",
        "    def get_fifty_fifty_arrows(self, ball):\n",
        "        return self.get_ball_arrows(ball, [\"50%\", \"50%\"])\n",
        "\n",
        "    def get_pm_arrows(self, ball, show_prob=True):\n",
        "        return self.get_ball_arrows(\n",
        "            ball, [\"$-1$\", \"$+1$\"],\n",
        "            sub_labels=([\"50%\", \"50%\"] if show_prob else [])\n",
        "        )\n",
        "\n",
        "    def show_corner_sum(self, pm_arrows, bits, font_size=48):\n",
        "        # Test\n",
        "        parts = VGroup(*(\n",
        "            arrow[bit][0].copy()\n",
        "            for arrow, bit in zip(pm_arrows, bits)\n",
        "        ))\n",
        "        parts.target = parts.generate_target()\n",
        "        parts.target.arrange(RIGHT, buff=0.1)\n",
        "        parts.target.scale(font_size / 28)\n",
        "        parts.target.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        parts.target.to_edge(LEFT)\n",
        "\n",
        "        anim1 = MoveToTarget(parts, lag_ratio=0.01)\n",
        "\n",
        "        sum_term = Tex(f\"= {2 * sum(bits) - len(bits)}\", font_size=font_size)\n",
        "        sum_term.next_to(parts.target, RIGHT, buff=0.1, aligned_edge=UP)\n",
        "\n",
        "        anim2 = LaggedStart(*(\n",
        "            ReplacementTransform(\n",
        "                part.copy().set_opacity(0),\n",
        "                sum_term,\n",
        "                path_arc=-30 * DEGREES\n",
        "            )\n",
        "            for part in parts.target\n",
        "        ))\n",
        "\n",
        "        return Succession(anim1, anim2), FadeOut(VGroup(parts, sum_term))\n",
        "\n",
        "    def get_ball(self, color=YELLOW_E):\n",
        "        ball = TrueDot(radius=self.ball_radius, color=color)\n",
        "        ball.make_3d()\n",
        "        ball.set_shading(0.5, 0.5, 0.2)\n",
        "        return ball\n",
        "\n",
        "    def single_bounce_trajectory(self, ball, peg, direction):\n",
        "        sgn = np.sign(direction[0])\n",
        "        trajectory = FunctionGraph(\n",
        "            lambda x: -x * (x - 1),\n",
        "            x_range=(0, 2, 0.2),\n",
        "        )\n",
        "        p1 = peg.get_top()\n",
        "        p2 = p1 + self.spacing * np.array([sgn * 0.5, -0.5 * math.sqrt(3), 0])\n",
        "        vect = trajectory.get_end() - trajectory.get_start()\n",
        "        for i in (0, 1):\n",
        "            trajectory.stretch((p2 - p1)[i] / vect[i], i)\n",
        "        trajectory.shift(p1 - trajectory.get_start() + 0.5 * ball.get_height() * UP)\n",
        "\n",
        "        return trajectory\n",
        "\n",
        "    def random_trajectory(self, ball, pegs, buckets, bits=None):\n",
        "        index = len(pegs[0]) // 2\n",
        "        radius = ball.get_height() / 2\n",
        "        peg = pegs[0][index]\n",
        "\n",
        "        top_line = ParametricCurve(lambda t: t**2 * DOWN)\n",
        "        top_line.move_to(peg.get_top() + radius * UP, DOWN)\n",
        "\n",
        "        bounces = []\n",
        "        if bits is None:\n",
        "            bits = np.random.randint(0, 2, self.n_rows)\n",
        "        for row, bit in enumerate(bits):\n",
        "            peg = pegs[row][index]\n",
        "            bounces.append(self.single_bounce_trajectory(ball, peg, [LEFT, RIGHT][bit]))\n",
        "            index += bit\n",
        "            if row % 2 == 1:\n",
        "                index -= 1\n",
        "        bucket = buckets[index + (0 if self.n_rows % 2 == 0 else -1)]\n",
        "        final_line = Line(\n",
        "            bounces[-1].get_end(),\n",
        "            bucket.bottom.get_center() + self.ball_radius * UP\n",
        "        )\n",
        "        final_line.insert_n_curves(int(8 * final_line.get_length()))\n",
        "        bucket.bottom.shift(2 * self.ball_radius * self.stack_ratio * UP)\n",
        "        bucket.balls.add(ball)\n",
        "\n",
        "        result = VMobject()\n",
        "        pieces = VGroup(top_line, *bounces, final_line)\n",
        "        for vmob in pieces:\n",
        "            if result.get_num_points() > 0:\n",
        "                vmob.shift(result.get_end() - vmob.get_start())\n",
        "            result.append_vectorized_mobject(vmob)\n",
        "\n",
        "        return result, pieces\n",
        "\n",
        "    def falling_anim(self, ball, trajectory):\n",
        "        return MoveAlongPath(\n",
        "            ball, trajectory,\n",
        "            rate_func=linear,\n",
        "            run_time=self.fall_factor * trajectory.get_arc_length()\n",
        "        )\n",
        "\n",
        "    def add_single_clink_sound(self, time_offset=0, gain=-20):\n",
        "        self.add_sound(\n",
        "            sound_file=self.clink_sound.replace(\"click\", \"click\" + str(random.randint(1, 12))),\n",
        "            time_offset=time_offset,\n",
        "            gain=gain,\n",
        "        )\n",
        "\n",
        "    def add_falling_clink_sounds(self, trajectory_pieces, time_offset=0, gain=-20):\n",
        "        total_len = trajectory_pieces[0].get_arc_length()\n",
        "        for piece in trajectory_pieces[1:-1]:\n",
        "            self.add_single_clink_sound(time_offset + self.fall_factor * total_len, gain)\n",
        "            total_len += piece.get_arc_length()\n",
        "\n",
        "    def drop_n_balls(self, n, pegs, buckets, lr_factor=1, sound=False):\n",
        "        # Test\n",
        "        balls = Group(*(self.get_ball() for x in range(n)))\n",
        "        trajs = [\n",
        "            self.random_trajectory(ball, pegs, buckets)\n",
        "            for ball in balls\n",
        "        ]\n",
        "        anims = (\n",
        "            self.falling_anim(ball, traj[0])\n",
        "            for ball, traj in zip(balls, trajs)\n",
        "        )\n",
        "        full_anim = LaggedStart(*anims, lag_ratio=lr_factor / n)\n",
        "\n",
        "        # Add sounds\n",
        "        if sound:\n",
        "            start_times = [tup[1] for tup in full_anim.anims_with_timings]\n",
        "            for time, traj in zip(start_times, trajs):\n",
        "                self.add_falling_clink_sounds(traj[1], time + 0.00 * random.random(), gain=-30)\n",
        "\n",
        "        self.play(full_anim)\n",
        "\n",
        "        return balls\n",
        "\n",
        "\n",
        "class EmphasizeMultipleSums(GaltonBoard):\n",
        "    def construct(self):\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "        self.add(pegs, buckets)\n",
        "\n",
        "        # Show a trajectories with cumulative sum\n",
        "        for x in range(20):\n",
        "            ball = self.get_ball()\n",
        "            bits = np.random.randint(0, 2, self.n_rows)\n",
        "            full_trajectory, pieces = self.random_trajectory(ball, pegs, buckets, bits)\n",
        "\n",
        "            all_arrows = VGroup()\n",
        "\n",
        "            self.add(all_arrows)\n",
        "            for piece, bit in zip(pieces, bits):\n",
        "                ball.move_to(piece.get_end())\n",
        "                arrows = self.get_pm_arrows(ball)\n",
        "                all_arrows.add(arrows)\n",
        "                self.play(self.falling_anim(ball, piece))\n",
        "                self.add_single_clink_sound()\n",
        "                arrows[1 - bit].set_opacity(0.25)\n",
        "\n",
        "            self.play(self.falling_anim(ball, pieces[-2]))\n",
        "            self.add_single_clink_sound()\n",
        "            self.play(\n",
        "                self.falling_anim(ball, pieces[-1]),\n",
        "                FadeOut(all_arrows)\n",
        "            )\n",
        "\n",
        "\n",
        "class GaltonTrickle(GaltonBoard):\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "        self.add(pegs, buckets)\n",
        "\n",
        "        ball = self.get_ball()\n",
        "        peg = pegs[0][len(pegs[0]) // 2]\n",
        "        ball.move_to(peg.get_top(), DOWN)\n",
        "        arrows = self.get_pm_arrows(ball)\n",
        "\n",
        "        frame.set_height(3, about_edge=UP)\n",
        "\n",
        "        # Drops\n",
        "        n = 25\n",
        "\n",
        "        balls = Group(*(self.get_ball() for x in range(n)))\n",
        "        all_bits = [np.random.randint(0, 2, self.n_rows) for x in range(n)]\n",
        "        trajs = [\n",
        "            self.random_trajectory(ball, pegs, buckets, bits)\n",
        "            for ball, bits in zip(balls, all_bits)\n",
        "        ]\n",
        "        falling_anims = (\n",
        "            self.falling_anim(ball, traj[0])\n",
        "            for ball, traj in zip(balls, trajs)\n",
        "        )\n",
        "\n",
        "        arrow_copies = VGroup()\n",
        "        for bits in all_bits:\n",
        "            ac = arrows.copy()\n",
        "            ac[1 - bits[0]].set_opacity(0.2)\n",
        "            arrow_copies.add(ac)\n",
        "\n",
        "        rt = 60\n",
        "        arrows.set_opacity(1)\n",
        "        self.add(arrows)\n",
        "        self.play(\n",
        "            LaggedStart(*falling_anims, lag_ratio=0.4, run_time=rt),\n",
        "            # ShowSubmobjectsOneByOne(arrow_copies, run_time=1.0 * rt),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BiggerGaltonBoard(GaltonBoard):\n",
        "    random_seed = 0\n",
        "    pegs_per_row = 30\n",
        "    n_rows = 13\n",
        "    spacing = 0.5\n",
        "    top_buff = 0.5\n",
        "    peg_radius = 0.025\n",
        "    ball_radius = 0.05\n",
        "    bucket_floor_buff = 0.5\n",
        "    stack_ratio = 0.1\n",
        "    n_balls = 800\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "        self.add(pegs, buckets)\n",
        "\n",
        "        # Drop!\n",
        "        self.drop_n_balls(self.n_balls, pegs, buckets, lr_factor=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Show low bell cuve\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "        full_rect.set_fill(BLACK, 0.5)\n",
        "        balls = self.mobjects[-1]\n",
        "        curve = FunctionGraph(lambda x: gauss_func(x, 0, 1))\n",
        "        curve.set_stroke(YELLOW)\n",
        "        curve.move_to(balls, DOWN)\n",
        "        curve.match_height(balls, stretch=True, about_edge=DOWN)\n",
        "        formula = Tex(R\"{1 \\over \\sqrt{2\\pi}} e^{-x^2 / 2}\", font_size=60)\n",
        "        formula.move_to(balls, LEFT)\n",
        "        formula.shift(1.25 * LEFT)\n",
        "        formula.set_backstroke(width=8)\n",
        "\n",
        "        self.add(full_rect, balls)\n",
        "        self.play(\n",
        "            FadeIn(full_rect),\n",
        "            ShowCreation(curve, run_time=2),\n",
        "            Write(formula)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SingleDropBigGaltonBoard(BiggerGaltonBoard):\n",
        "    spacing = 0.55\n",
        "    ball_radius = 0.075\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "        self.add(pegs, buckets)\n",
        "\n",
        "        # Single ball bouncing, step-by-step\n",
        "        ball = self.get_ball()\n",
        "        full_trajectory, pieces = self.random_trajectory(ball, pegs, buckets)\n",
        "        self.add_falling_clink_sounds(pieces)\n",
        "        self.play(self.falling_anim(ball, full_trajectory))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NotIdenticallyDistributed(GaltonBoard):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        pegs = self.get_pegs()\n",
        "        buckets = self.get_buckets(pegs)\n",
        "        self.add(pegs, buckets)\n",
        "\n",
        "        # Arrows to show distributions\n",
        "        max_arrow_len = 0.5\n",
        "\n",
        "        def get_peg_arrow(peg, angle, length, color=RED_E):\n",
        "            vect = np.array([-math.sin(angle), math.cos(angle), 0])\n",
        "            arrow = FillArrow(\n",
        "                ORIGIN, length * vect,\n",
        "                buff=0,\n",
        "                fill_color=color,\n",
        "                tip_width_ratio=3,\n",
        "                thickness=0.025,\n",
        "            )\n",
        "            arrow.shift(peg.get_center() + vect * peg.get_radius())\n",
        "            arrow.set_fill(opacity=0.8 * length / max_arrow_len)\n",
        "            return arrow\n",
        "\n",
        "        def get_bounce_distribution(peg, sigma=30 * DEGREES):\n",
        "            ds = sigma / 2\n",
        "            angles = np.arange(-2 * sigma, 2 * sigma + ds, ds)\n",
        "            denom = math.sqrt(2 * PI) * sigma\n",
        "            arrows = VGroup(*(\n",
        "                get_peg_arrow(peg, angle, denom * gauss_func(angle, 0, sigma) * max_arrow_len)\n",
        "                for angle in angles\n",
        "            ))\n",
        "            return arrows\n",
        "\n",
        "        # Show many distributions\n",
        "        all_dists = VGroup(*(\n",
        "            get_bounce_distribution(peg)\n",
        "            for row in pegs\n",
        "            for peg in row\n",
        "        ))\n",
        "\n",
        "        all_dists.set_fill(RED_E, 0.8)\n",
        "        self.play(LaggedStart(*(\n",
        "            LaggedStartMap(GrowArrow, dist)\n",
        "            for dist in all_dists\n",
        "        )))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in to top one\n",
        "        ball = self.get_ball()\n",
        "        peg1 = pegs[0][len(pegs[0]) // 2]\n",
        "        peg2 = pegs[1][len(pegs[1]) // 2]\n",
        "        frame = self.frame\n",
        "        peg1_dist = get_bounce_distribution(peg1)\n",
        "        peg2_dist = get_bounce_distribution(peg2)\n",
        "        peg1_dist.rotate(30 * DEGREES, about_point=peg1.get_center())\n",
        "        peg2_dist.rotate(-30 * DEGREES, about_point=peg2.get_center())\n",
        "\n",
        "        full_trajectory, pieces = self.random_trajectory(ball, pegs, buckets, [0, 1, 0, 0, 0])\n",
        "        pieces[0].move_to(peg1.pfp(3 / 8) + ball.get_radius() * UP, DOWN)\n",
        "        pieces[1].stretch(0.7, 0)\n",
        "        pieces[1].shift(pieces[0].get_end() - pieces[1].get_start())\n",
        "        pieces[2].stretch(0.9, 0)\n",
        "        pieces[2].stretch(0.97, 1)\n",
        "        pieces[2].shift(pieces[1].get_end() - pieces[2].get_start())\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(3, about_edge=UP),\n",
        "            FadeOut(all_dists, lag_ratio=0.01),\n",
        "            self.falling_anim(ball, pieces[0]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.add(peg1_dist, ball)\n",
        "        self.play(LaggedStartMap(FadeIn, peg1_dist))\n",
        "        self.wait()\n",
        "        self.play(self.falling_anim(ball, pieces[1]), run_time=1)\n",
        "        self.play(LaggedStartMap(FadeIn, peg2_dist))\n",
        "        self.wait()\n",
        "        self.play(self.falling_anim(ball, pieces[2]), run_time=1)\n",
        "        self.wait(2)\n",
        "\n"
    ]
}