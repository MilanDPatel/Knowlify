{
    "topic": "is demonstrating the concept of splitting a stack of tally symbols into two separate stacks",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.eop.reusable_imports import *\n",
        "\n",
        "\n",
        "class BrickRowScene(PiCreatureScene):\n",
        "\n",
        "\n",
        "    def split_tallies(self, row, direction = DOWN):\n",
        "        # Split all tally symbols at once and move the copies\n",
        "        # either horizontally on top of the brick row\n",
        "        # or diagonally into the bricks\n",
        "\n",
        "        self.tallies_copy = self.tallies.copy()\n",
        "        self.add_foreground_mobject(self.tallies_copy)\n",
        "\n",
        "        tally_targets_left = [\n",
        "            rect.get_center() + 0.25 * rect.get_width() * LEFT \n",
        "            for rect in row.rects\n",
        "        ]\n",
        "\n",
        "        tally_targets_right = [\n",
        "            rect.get_center() + 0.25 * rect.get_width() * RIGHT \n",
        "            for rect in row.rects\n",
        "        ]\n",
        "\n",
        "        if np.all(direction == LEFT) or np.all(direction == RIGHT):\n",
        "\n",
        "            tally_y_pos = self.tallies[0].anchor[1]\n",
        "            for target in tally_targets_left:\n",
        "                target[1] = tally_y_pos\n",
        "            for target in tally_targets_right:\n",
        "                target[1] = tally_y_pos\n",
        "\n",
        "        for (i, tally) in enumerate(self.tallies):\n",
        "\n",
        "            target_left = tally_targets_left[i]\n",
        "            new_tally_left = TallyStack(tally.nb_heads + 1, tally.nb_tails)\n",
        "            new_tally_left.move_anchor_to(target_left)\n",
        "            v = target_left - tally.anchor\n",
        "            \n",
        "            self.play(\n",
        "                tally.move_anchor_to, target_left,\n",
        "            )\n",
        "            tally.anchor = target_left\n",
        "            self.play(Transform(tally, new_tally_left))\n",
        "            \n",
        "            tally_copy = self.tallies_copy[i]\n",
        "\n",
        "            target_right = tally_targets_right[i]\n",
        "            new_tally_right = TallyStack(tally.nb_heads, tally.nb_tails + 1)\n",
        "            new_tally_right.move_anchor_to(target_right)\n",
        "            v = target_right - tally_copy.anchor\n",
        "            \n",
        "            self.play(tally_copy.move_anchor_to, target_right)\n",
        "            tally_copy.anchor = target_right\n",
        "            self.play(Transform(tally_copy, new_tally_right))\n",
        "\n",
        "            tally_copy.nb_heads = new_tally_right.nb_heads\n",
        "            tally_copy.nb_tails = new_tally_right.nb_tails\n",
        "            tally.nb_heads = new_tally_left.nb_heads\n",
        "            tally.nb_tails = new_tally_left.nb_tails\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def tally_split_animations(self, row, direction = DOWN):\n",
        "        # Just creates the animations and returns them\n",
        "        # Execution can be timed afterwards\n",
        "        # Returns two lists: first all those going left, then those to the right\n",
        "\n",
        "        self.tallies_copy = self.tallies.copy()\n",
        "        self.add_foreground_mobject(self.tallies_copy)\n",
        "\n",
        "        tally_targets_left = [\n",
        "            rect.get_center() + 0.25 * rect.get_width() * LEFT \n",
        "            for rect in row.rects\n",
        "        ]\n",
        "\n",
        "        tally_targets_right = [\n",
        "            rect.get_center() + 0.25 * rect.get_width() * RIGHT \n",
        "            for rect in row.rects\n",
        "        ]\n",
        "\n",
        "        if np.all(direction == LEFT) or np.all(direction == RIGHT):\n",
        "\n",
        "            tally_y_pos = self.tallies[0].anchor[1]\n",
        "            for target in tally_targets_left:\n",
        "                target[1] = tally_y_pos\n",
        "            for target in tally_targets_right:\n",
        "                target[1] = tally_y_pos\n",
        "\n",
        "\n",
        "        anims1 = []\n",
        "\n",
        "        for (i, tally) in enumerate(self.tallies):\n",
        "\n",
        "            new_tally_left = TallyStack(tally.nb_heads + 1, tally.nb_tails)\n",
        "            target_left = tally_targets_left[i]\n",
        "            new_tally_left.move_to(target_left)\n",
        "\n",
        "            anims1.append(Transform(tally, new_tally_left))\n",
        "            \n",
        "            tally.anchor = target_left\n",
        "            tally.nb_heads = new_tally_left.nb_heads\n",
        "            tally.nb_tails = new_tally_left.nb_tails\n",
        "            \n",
        "\n",
        "        anims2 = []\n",
        "\n",
        "        for (i, tally) in enumerate(self.tallies_copy):\n",
        "\n",
        "            new_tally_right = TallyStack(tally.nb_heads, tally.nb_tails + 1)\n",
        "            target_right = tally_targets_right[i]\n",
        "            new_tally_right.move_to(target_right)\n",
        "            \n",
        "            anims2.append(Transform(tally, new_tally_right))\n",
        "\n",
        "            tally.anchor = target_right\n",
        "            tally.nb_heads = new_tally_right.nb_heads\n",
        "            tally.nb_tails = new_tally_right.nb_tails\n",
        "\n",
        "        return anims1, anims2\n",
        "\n",
        "\n",
        "\n",
        "    def split_tallies_at_once(self, row, direction = DOWN):\n",
        "        anims1, anims2 = self.tally_split_animations(row, direction = direction)\n",
        "        self.play(*(anims1 + anims2))\n",
        "\n",
        "    def split_tallies_in_two_steps(self, row, direction = DOWN):\n",
        "        # First all those to the left, then those to the right\n",
        "        anims1, anims2 = self.tally_split_animations(row, direction = direction)\n",
        "        self.play(*anims1)\n",
        "        self.wait(0.3)\n",
        "        self.play(*anims2)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def merge_rects_by_subdiv(self, row):\n",
        "\n",
        "        half_merged_row = row.copy()\n",
        "        half_merged_row.subdiv_level += 1\n",
        "        half_merged_row.init_points()\n",
        "        half_merged_row.move_to(row)\n",
        "\n",
        "        self.play(FadeIn(half_merged_row))\n",
        "        self.remove(row)\n",
        "        return half_merged_row\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def merge_tallies(self, row, target_pos = UP):\n",
        "        \n",
        "        r = row.subdiv_level\n",
        "        \n",
        "        if np.all(target_pos == DOWN):\n",
        "            tally_targets = [\n",
        "                rect.get_center()\n",
        "                for rect in row.get_rects_for_level(r)\n",
        "            ]\n",
        "        elif np.all(target_pos == UP):\n",
        "            y_pos = row.get_center()[1] + 1.2 * 0.5 * row.get_height()\n",
        "            for target in tally_targets:\n",
        "                target[1] = y_pos\n",
        "        else:\n",
        "            raise Exception(\"Invalid target position (either UP or DOWN)\")\n",
        "\n",
        "        anims = []\n",
        "        for (tally, target) in zip(self.tallies[1:], tally_targets[1:-1]):\n",
        "            anims.append(tally.move_anchor_to)\n",
        "            anims.append(target)\n",
        "\n",
        "        for (tally, target) in zip(self.tallies_copy[:-1], tally_targets[1:-1]):\n",
        "            anims.append(tally.move_anchor_to)\n",
        "            anims.append(target)\n",
        "\n",
        "        self.play(*anims)\n",
        "        # update anchors\n",
        "        for (tally, target) in zip(self.tallies[1:], tally_targets[1:-1]):\n",
        "            tally.anchor = target\n",
        "        for (tally, target) in zip(self.tallies_copy[:-1], tally_targets[1:-1]):\n",
        "            tally.anchor = target\n",
        "\n",
        "        self.remove(self.tallies_copy)\n",
        "        self.tallies.add(self.tallies_copy[-1])\n",
        "\n",
        "\n",
        "    def merge_rects_by_coloring(self, row):\n",
        "\n",
        "        merged_row = row.copy()\n",
        "        merged_row.coloring_level += 1\n",
        "        merged_row.init_points()\n",
        "        merged_row.move_to(row)\n",
        "\n",
        "        self.play(FadeIn(merged_row))\n",
        "        self.remove(row)\n",
        "        return merged_row\n",
        "\n",
        "\n",
        "\n",
        "    def move_tallies_on_top(self, row):\n",
        "        self.play(\n",
        "            self.tallies.shift, 1.2 * 0.5 * row.height * UP\n",
        "        )\n",
        "        for tally in self.tallies:\n",
        "            tally.anchor += 1.2 * 0.5 * row.height * UP\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = CoinFlippingPiCreature(color = MAROON_E)\n",
        "        return randy\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        \n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        \n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy = randy.scale(0.5).move_to(3*DOWN + 6*LEFT)\n",
        "        #self.add(randy)\n",
        "        self.row = BrickRow(0, height = 2, width = 10)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(self.row))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # move in all kinds of sequences\n",
        "        coin_seqs = VGroup()\n",
        "        for i in range(20):\n",
        "            n = np.random.randint(1,10)\n",
        "            seq = [np.random.choice([\"H\", \"T\"]) for j in range(n)]\n",
        "            coin_seq = CoinSequence(seq).scale(1.5)\n",
        "            loc = np.random.uniform(low = -10, high = 10) * RIGHT\n",
        "            loc += np.random.uniform(low = -6, high = 6) * UP\n",
        "            coin_seq.move_to(loc)\n",
        "            \n",
        "            coin_seq.target = coin_seq.copy().scale(0.3).move_to(0.4 * loc)\n",
        "            coin_seq.target.fade(1)\n",
        "            coin_seqs.add(coin_seq)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Succession, coin_seqs, lambda m: (FadeIn(m, run_time = 0.1), MoveToTarget(m)),\n",
        "                run_time = 5,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "        )\n",
        "        \n",
        "        # # # # # # # #\n",
        "        # FIRST  FLIP #\n",
        "        # # # # # # # #\n",
        "\n",
        "\n",
        "        self.play(FlipCoin(randy))\n",
        "\n",
        "        self.play(SplitRectsInBrickWall(self.row))\n",
        "        self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        self.row = self.merge_rects_by_coloring(self.row)\n",
        "        #\n",
        "        # put tallies on top\n",
        "\n",
        "        single_flip_labels = VGroup(UprightHeads(), UprightTails())\n",
        "        for (label, rect) in zip(single_flip_labels, self.row.rects):\n",
        "            label.next_to(rect, UP)\n",
        "            self.play(FadeIn(label))\n",
        "            self.wait()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # # # # # # # #\n",
        "        # SECOND FLIP #\n",
        "        # # # # # # # #\n",
        "\n",
        "        self.play(FlipCoin(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            SplitRectsInBrickWall(self.row)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # split sequences\n",
        "        single_flip_labels_copy = single_flip_labels.copy()\n",
        "        self.add(single_flip_labels_copy)\n",
        "\n",
        "        \n",
        "        v = self.row.get_outcome_centers_for_level(2)[0] - single_flip_labels[0].get_center()\n",
        "        self.play(\n",
        "            single_flip_labels.shift, v\n",
        "        )\n",
        "        new_heads = VGroup(UprightHeads(), UprightHeads())\n",
        "        for i in range(2):\n",
        "            new_heads[i].move_to(single_flip_labels[i])\n",
        "            new_heads[i].shift(COIN_SEQUENCE_SPACING * DOWN)\n",
        "        self.play(FadeIn(new_heads))\n",
        "\n",
        "        v = self.row.get_outcome_centers_for_level(2)[-1] - single_flip_labels_copy[-1].get_center()\n",
        "        self.play(\n",
        "            single_flip_labels_copy.shift, v\n",
        "        )\n",
        "        new_tails = VGroup(UprightTails(), UprightTails())\n",
        "        for i in range(2):\n",
        "            new_tails[i].move_to(single_flip_labels_copy[i])\n",
        "            new_tails[i].shift(COIN_SEQUENCE_SPACING * DOWN)\n",
        "        self.play(FadeIn(new_tails))\n",
        "\n",
        "        self.add_foreground_mobject(single_flip_labels)\n",
        "        self.add_foreground_mobject(new_heads)\n",
        "        self.add_foreground_mobject(single_flip_labels_copy)\n",
        "        self.add_foreground_mobject(new_tails)\n",
        "\n",
        "        # get individual outcomes\n",
        "        outcomes = self.row.get_outcome_rects_for_level(2, with_labels = False,\n",
        "            inset = True)\n",
        "        grouped_outcomes = VGroup(outcomes[0], outcomes[1:3], outcomes[3])\n",
        "\n",
        "        decimal_tallies = VGroup()\n",
        "        # introduce notion of tallies\n",
        "        rects = self.row.get_rects_for_level(2)\n",
        "\n",
        "        rect = rects[0]\n",
        "        tally = DecimalTally(2,0)\n",
        "        tally.next_to(rect, UP)\n",
        "        decimal_tallies.add(tally)\n",
        "        self.play(\n",
        "            FadeIn(tally),\n",
        "            FadeIn(grouped_outcomes[0])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = rects[1]\n",
        "        tally = DecimalTally(1,1)\n",
        "        tally.next_to(rect, UP)\n",
        "        decimal_tallies.add(tally)\n",
        "        self.play(\n",
        "            FadeIn(tally),\n",
        "            FadeOut(grouped_outcomes[0]),\n",
        "            FadeIn(grouped_outcomes[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = rects[2]\n",
        "        tally = DecimalTally(0,2)\n",
        "        tally.next_to(rect, UP)\n",
        "        decimal_tallies.add(tally)\n",
        "        self.play(\n",
        "            FadeIn(tally),\n",
        "            FadeOut(grouped_outcomes[1]),\n",
        "            FadeIn(grouped_outcomes[2])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(grouped_outcomes[2])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(single_flip_labels),\n",
        "            FadeOut(new_heads),\n",
        "            FadeOut(single_flip_labels_copy),\n",
        "            FadeOut(new_tails)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.tallies = VGroup()\n",
        "        for (i, rect) in enumerate(self.row.get_rects_for_level(2)):\n",
        "            tally = TallyStack(2-i, i, show_decimals = False)\n",
        "            tally.move_to(rect)\n",
        "            self.tallies.add(tally)\n",
        "\n",
        "\n",
        "        self.play(FadeIn(self.tallies))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        anims = []\n",
        "        for (decimal_tally, tally_stack) in zip(decimal_tallies, self.tallies):\n",
        "            anims.append(ApplyFunction(\n",
        "                tally_stack.position_decimal_tally, decimal_tally\n",
        "            ))\n",
        "        \n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # replace the original decimal tallies with\n",
        "        # the ones that belong to the TallyStacks\n",
        "        for (decimal_tally, tally_stack) in zip(decimal_tallies, self.tallies):\n",
        "            self.remove(decimal_tally)\n",
        "            tally_stack.position_decimal_tally(tally_stack.decimal_tally)\n",
        "            tally_stack.add(tally_stack.decimal_tally)\n",
        "        \n",
        "        self.add_foreground_mobject(self.tallies)\n",
        "        self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        self.wait()\n",
        "        self.row = self.merge_rects_by_coloring(self.row)\n",
        "        self.wait()\n",
        "        \n",
        "\n",
        "        # # # # # # # # # # # # #\n",
        "        # CALLBACK TO SEQUENCES #\n",
        "        # # # # # # # # # # # # #\n",
        "\n",
        "        outcomes = self.row.get_outcome_rects_for_level(2, with_labels = True,\n",
        "            inset = True)\n",
        "        subdivs = self.row.get_sequence_subdivs_for_level(2)\n",
        "        self.play(\n",
        "            FadeIn(outcomes),\n",
        "            FadeIn(subdivs),\n",
        "            FadeOut(self.tallies)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        rect_to_dice = self.row.get_outcome_rects_for_level(2, with_labels = False,\n",
        "            inset = False)[1]\n",
        "        N = 10\n",
        "        dice_width = rect_to_dice.get_width()/N\n",
        "        dice_height = rect_to_dice.get_height()/N\n",
        "        prototype_dice = Rectangle(\n",
        "            width = dice_width,\n",
        "            height = dice_height,\n",
        "            stroke_width = 2,\n",
        "            stroke_color = WHITE,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 0\n",
        "        )\n",
        "        prototype_dice.align_to(rect_to_dice, direction = UP)\n",
        "        prototype_dice.align_to(rect_to_dice, direction = LEFT)\n",
        "        all_dice = VGroup()\n",
        "        for i in range(N):\n",
        "            for j in range(N):\n",
        "                dice_copy = prototype_dice.copy()\n",
        "                dice_copy.shift(j * dice_width * RIGHT + i * dice_height * DOWN)\n",
        "                all_dice.add(dice_copy)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, all_dice),\n",
        "            FadeOut(outcomes[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        table = Ellipse(width = 1.5, height = 1)\n",
        "        table.set_fill(color = GREEN_E, opacity = 1)\n",
        "        table.next_to(rect_to_dice, UP)\n",
        "        self.add(table)\n",
        "        coin1 = UprightHeads(radius = 0.1)\n",
        "        coin2 = UprightTails(radius = 0.1)\n",
        "\n",
        "        def get_random_point_in_ellipse(ellipse):\n",
        "            width = ellipse.get_width()\n",
        "            height = ellipse.get_height()\n",
        "            x = y = 1\n",
        "            while x**2 + y**2 > 0.9:\n",
        "                x = np.random.uniform(-1,1)\n",
        "                y = np.random.uniform(-1,1)            \n",
        "            x *= width/2\n",
        "            y *= height/2\n",
        "            return ellipse.get_center() + x * RIGHT + y * UP\n",
        "\n",
        "\n",
        "        for dice in all_dice:\n",
        "            p1 = get_random_point_in_ellipse(table)\n",
        "            p2 = get_random_point_in_ellipse(table)\n",
        "            coin1.move_to(p1)\n",
        "            coin2.move_to(p2)\n",
        "            self.add(coin1, coin2)\n",
        "            self.play(\n",
        "                ApplyMethod(dice.set_fill, {\"opacity\" : 0.5},\n",
        "                    rate_func = there_and_back,\n",
        "                    run_time = 0.05)\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(outcomes),\n",
        "            FadeOut(subdivs),\n",
        "            FadeOut(all_dice),\n",
        "            FadeOut(table),\n",
        "            FadeOut(coin1),\n",
        "            FadeOut(coin2),\n",
        "            FadeIn(self.tallies)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # # # # # # # #\n",
        "        # THIRD  FLIP #\n",
        "        # # # # # # # #\n",
        "\n",
        "        # move row up, leave a copy without tallies below\n",
        "        new_row = self.row.copy()\n",
        "        self.clear()\n",
        "        self.add(randy, self.row, self.tallies)\n",
        "        self.bring_to_back(new_row)\n",
        "        self.play(\n",
        "            self.row.shift, 2.5 * UP,\n",
        "            self.tallies.shift, 2.5 * UP,\n",
        "        )\n",
        "\n",
        "        old_row = self.row\n",
        "        self.row = new_row\n",
        "\n",
        "        self.play(FlipCoin(randy))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            SplitRectsInBrickWall(self.row)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.split_tallies_in_two_steps(self.row)\n",
        "        self.wait()\n",
        "\n",
        "        self.add_foreground_mobject(self.tallies)\n",
        "        self.add_foreground_mobject(self.tallies_copy)\n",
        "\n",
        "\n",
        "        \n",
        "\n",
        "        self.remove(new_row)\n",
        "        new_row = self.row\n",
        "\n",
        "\n",
        "\n",
        "        self.clear()\n",
        "        self.add(randy, self.row, old_row)\n",
        "        self.add_foreground_mobject(self.tallies)\n",
        "        self.add_foreground_mobject(self.tallies_copy)\n",
        "        \n",
        "\n",
        "        self.play(\n",
        "            self.row.fade, 0.7,\n",
        "            old_row.fade, 0.7,\n",
        "            FadeOut(self.tallies),\n",
        "            FadeOut(self.tallies_copy),\n",
        "        )\n",
        "\n",
        "        \n",
        "        # # # # # # # # # # # # # # # # #\n",
        "        # SHOW SPLITTING  WITH OUTCOMES #\n",
        "        # # # # # # # # # # # # # # # # #\n",
        "\n",
        "        # # show individual outcomes\n",
        "        # old_outcomes = old_row.get_outcome_rects_for_level(2, with_labels = True)\n",
        "        # old_outcomes_copy = old_outcomes.copy()\n",
        "        # new_outcomes = self.row.get_outcome_rects_for_level(3, with_labels = True)\n",
        "        \n",
        "        # self.play(\n",
        "        #     FadeIn(old_outcomes[0]),\n",
        "        #     FadeIn(old_outcomes_copy[0]),\n",
        "        # )\n",
        "\n",
        "        # self.wait()\n",
        "\n",
        "        # self.play(\n",
        "        #     Transform(old_outcomes_copy[0], new_outcomes[1])\n",
        "        # )\n",
        "\n",
        "        # self.wait()\n",
        "\n",
        "        # self.play(\n",
        "        #     FadeIn(old_outcomes[1:3]),\n",
        "        #     FadeIn(old_outcomes_copy[1:3]),\n",
        "        # )\n",
        "\n",
        "        # self.wait()\n",
        "\n",
        "        # self.play(\n",
        "        #     Transform(old_outcomes_copy[1:3], new_outcomes[2:4])\n",
        "        # )\n",
        "\n",
        "        # self.wait()\n",
        "\n",
        "        # self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        # self.wait()\n",
        "\n",
        "        # self.play(\n",
        "        #     FadeOut(old_row),\n",
        "        #     FadeOut(old_outcomes[0:3]),\n",
        "        #     FadeOut(new_outcomes[1:4]),\n",
        "        #     self.row.fade,0,\n",
        "        #     FadeIn(self.tallies[1]),\n",
        "        #     FadeIn(self.tallies_copy[0]),\n",
        "        # )\n",
        "\n",
        "        # # rest of the new row\n",
        "        # self.play(\n",
        "        #     FadeIn(self.tallies[:1]),\n",
        "        #     FadeIn(self.tallies[2:]),\n",
        "        #     FadeIn(self.tallies_copy[1:])\n",
        "        # )\n",
        "\n",
        "        # self.wait()\n",
        "\n",
        "        # self.merge_tallies(self.row, target_pos = DOWN)\n",
        "        # self.add_foreground_mobject(self.tallies)\n",
        "        # self.row = self.merge_rects_by_coloring(self.row)\n",
        "        # self.wait()\n",
        "\n",
        "\n",
        "        # # # # # # # # # # # # # # # #\n",
        "        # SHOW SPLITTING WITH TALLIES #\n",
        "        # # # # # # # # # # # # # # # #\n",
        "\n",
        "        tally_left = TallyStack(2,0)\n",
        "        tally_left.move_to(old_row.rects[0])\n",
        "        tally_right = TallyStack(1,1)\n",
        "        tally_right.move_to(old_row.rects[1])\n",
        "\n",
        "        rect_left = old_row.rects[0].copy()\n",
        "        rect_right = old_row.rects[1].copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect_left),\n",
        "            FadeIn(rect_right),\n",
        "            FadeIn(tally_left),\n",
        "            FadeIn(tally_right)\n",
        "        )\n",
        "\n",
        "        rect_left.target = rect_left.copy()\n",
        "        rect_left.target.stretch(0.5,0)\n",
        "        left_target_pos = self.row.get_outcome_centers_for_level(3)[1]\n",
        "        left_v = left_target_pos - rect_left.get_center()\n",
        "        rect_left.target.move_to(left_target_pos)\n",
        "\n",
        "        rect_right.target = rect_right.copy()\n",
        "        rect_right.target.stretch(0.5,0)\n",
        "        right_target_pos = 0.5 * (self.row.get_outcome_centers_for_level(3)[2] + self.row.get_outcome_centers_for_level(3)[3])\n",
        "        right_v = right_target_pos - rect_right.get_center()\n",
        "        rect_right.target.move_to(right_target_pos)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rect_left),\n",
        "            tally_left.move_to, left_target_pos\n",
        "        )\n",
        "        #tally_left.anchor += left_v\n",
        "        \n",
        "        self.wait()\n",
        "\n",
        "        new_tally_left = TallyStack(2,1)\n",
        "        #new_tally_left.move_anchor_to(tally_left.anchor)\n",
        "        new_tally_left.move_to(tally_left)\n",
        "        \n",
        "        self.play(\n",
        "            Transform(tally_left, new_tally_left)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rect_right),\n",
        "            tally_right.move_to, right_target_pos\n",
        "        )\n",
        "        #tally_right.anchor += right_v\n",
        "        \n",
        "        self.wait()\n",
        "        new_tally_right = TallyStack(2,1)\n",
        "        #new_tally_right.move_anchor_to(tally_right.anchor)\n",
        "        new_tally_right.move_to(tally_right)\n",
        "\n",
        "        self.play(\n",
        "            Transform(tally_right, new_tally_right)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(old_row),\n",
        "            self.row.fade,0,\n",
        "            FadeOut(new_tally_left),\n",
        "            FadeOut(new_tally_right),\n",
        "            FadeIn(self.tallies[1]),\n",
        "            FadeIn(self.tallies_copy[0]),\n",
        "        )\n",
        "\n",
        "        # rest of the new row\n",
        "        self.play(\n",
        "            FadeIn(self.tallies[:1]),\n",
        "            FadeIn(self.tallies[2:]),\n",
        "            FadeIn(self.tallies_copy[1:])\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.merge_tallies(self.row, target_pos = DOWN)\n",
        "        self.add_foreground_mobject(self.tallies)\n",
        "        self.row = self.merge_rects_by_coloring(self.row)\n",
        "        self.wait()\n",
        "\n",
        "        \n",
        "        # show the 8 individual outcomes\n",
        "        outcomes = self.row.get_outcome_rects_for_level(3,\n",
        "            with_labels = True,\n",
        "            inset = True)\n",
        "        self.play(FadeOut(self.tallies))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, outcomes,\n",
        "            #rate_func = there_and_back_with_pause,\n",
        "            run_time = 5))\n",
        "        self.wait()\n",
        "\n",
        "        braces = VGroup(*[Brace(rect, UP) for rect in self.row.rects])\n",
        "        counts = [choose(3, i) for i in range(4)]\n",
        "        probs = VGroup(*[Tex(\"{\" + str(k) + \"\\over 8}\") for k in counts])\n",
        "        for (brace, prob) in zip(braces, probs):\n",
        "            prob.next_to(brace, UP)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, braces),\n",
        "            LaggedStartMap(Write, probs)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, outcomes,\n",
        "            #rate_func = there_and_back_with_pause,\n",
        "            run_time = 5),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(self.tallies)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(braces),\n",
        "            FadeOut(probs)\n",
        "        )\n",
        "        self.wait()\n",
        " \n",
        "\n",
        "        # put visuals for other probability distribtuions here\n",
        "\n",
        "        # back to three coin flips, show all 8 outcomes\n",
        "        run_time = 5\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, outcomes,\n",
        "                #rate_func = there_and_back_with_pause,\n",
        "                run_time = run_time),\n",
        "            FadeOut(self.tallies,\n",
        "                run_time = run_time)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, outcomes,\n",
        "                #rate_func = there_and_back_with_pause,\n",
        "                run_time = 5),\n",
        "            FadeIn(self.tallies,\n",
        "                run_time = run_time)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        # # # # # # # #\n",
        "        # FOURTH FLIP #\n",
        "        # # # # # # # #\n",
        "\n",
        "\n",
        "\n",
        "        \n",
        "        previous_row = self.row.copy()\n",
        "        self.add(previous_row)\n",
        "\n",
        "        v = 1.25 * self.row.height * UP\n",
        "        self.play(\n",
        "            previous_row.shift, v,\n",
        "            self.tallies.shift, v,\n",
        "        )\n",
        "        self.add_foreground_mobject(self.tallies)\n",
        "\n",
        "        self.play(\n",
        "            SplitRectsInBrickWall(self.row)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        \n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        n = 3 # level to split\n",
        "        k = 1 # tally to split\n",
        "\n",
        "        # show individual outcomes\n",
        "        outcomes = previous_row.get_outcome_rects_for_level(n,\n",
        "            with_labels = False,\n",
        "            inset = True\n",
        "        )\n",
        "        grouped_outcomes = VGroup()\n",
        "        index = 0\n",
        "        for i in range(n + 1):\n",
        "            size = choose(n,i)\n",
        "            grouped_outcomes.add(VGroup(outcomes[index:index + size]))\n",
        "            index += size\n",
        "\n",
        "\n",
        "        grouped_outcomes_copy = grouped_outcomes.copy()\n",
        "\n",
        "        original_grouped_outcomes = grouped_outcomes.copy()\n",
        "        # for later reference\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, grouped_outcomes),\n",
        "            LaggedStartMap(FadeIn, grouped_outcomes_copy),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # show how the outcomes in one tally split into two copies\n",
        "        # going into the neighboring tallies\n",
        "\n",
        "        #self.revert_to_original_skipping_status()\n",
        "\n",
        "        target_outcomes = self.row.get_outcome_rects_for_level(n + 1,\n",
        "            with_labels = False,\n",
        "            inset = True\n",
        "        )\n",
        "        grouped_target_outcomes = VGroup()\n",
        "        index = 0\n",
        "        old_tally_sizes = [choose(n,i) for i in range(n + 1)]\n",
        "        new_tally_sizes = [choose(n + 1,i) for i in range(n + 2)]\n",
        "                \n",
        "        for i in range(n + 2):\n",
        "            size = new_tally_sizes[i]\n",
        "            grouped_target_outcomes.add(VGroup(target_outcomes[index:index + size]))\n",
        "            index += size\n",
        "\n",
        "        old_tally_sizes.append(0) # makes the edge cases work properly\n",
        "        \n",
        "        # split all tallies\n",
        "        for i in range(n + 1):\n",
        "            self.play(\n",
        "                Transform(grouped_outcomes[i][0],\n",
        "                    grouped_target_outcomes[i][0][old_tally_sizes[i - 1]:]\n",
        "                ),\n",
        "                Transform(grouped_outcomes_copy[i][0],\n",
        "                    grouped_target_outcomes[i + 1][0][:old_tally_sizes[i]]\n",
        "                )\n",
        "            )\n",
        "        return\n",
        "        \n",
        "        self.wait()\n",
        "\n",
        "        # fade in new tallies\n",
        "        new_rects = self.row.get_rects_for_level(4)\n",
        "        new_tallies = VGroup(*[\n",
        "            TallyStack(n + 1 - i, i).move_to(rect) for (i, rect) in enumerate(new_rects)\n",
        "        ])\n",
        "        self.play(FadeIn(new_tallies))\n",
        "        self.add_foreground_mobject(new_tallies[1])\n",
        "        # remove outcomes and sizes except for one tally\n",
        "        anims = []\n",
        "        for i in range(n + 1):\n",
        "            if i != k - 1:\n",
        "                anims.append(FadeOut(grouped_outcomes_copy[i]))\n",
        "            if i != k:\n",
        "                anims.append(FadeOut(grouped_outcomes[i]))\n",
        "                anims.append(FadeOut(new_tallies[i]))\n",
        "\n",
        "        #anims.append(FadeOut(self.tallies[0]))\n",
        "        #anims.append(FadeOut(self.tallies[2:]))\n",
        "        anims.append(FadeOut(new_tallies[-1]))\n",
        "\n",
        "        self.play(*anims)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Transform(grouped_outcomes_copy[k - 1], original_grouped_outcomes[k - 1])\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(grouped_outcomes[k], original_grouped_outcomes[k])\n",
        "        )\n",
        "\n",
        "        new_rects = self.row.get_rects_for_level(n + 1)\n",
        "\n",
        "        self.play(\n",
        "            Transform(grouped_outcomes[k][0],grouped_target_outcomes[k][0][old_tally_sizes[k - 1]:]),\n",
        "            Transform(grouped_outcomes_copy[k - 1][0],grouped_target_outcomes[k][0][:old_tally_sizes[k - 1]]),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(previous_row),\n",
        "            FadeOut(self.tallies),\n",
        "        )\n",
        "\n",
        "        self.row = self.merge_rects_by_coloring(self.row)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(new_tallies[0]),\n",
        "            FadeIn(new_tallies[2:]),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        # # # # # # # # # #\n",
        "        # EVEN MORE FLIPS #\n",
        "        # # # # # # # # # #\n",
        "\n",
        "        self.play(FadeOut(new_tallies))\n",
        "        self.clear()\n",
        "        self.row = BrickRow(3)\n",
        "        self.add(randy, self.row)       \n",
        "        \n",
        "\n",
        "        for i in range(3):\n",
        "\n",
        "            self.play(FlipCoin(randy))\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            previous_row = self.row.copy()\n",
        "\n",
        "            self.play(previous_row.shift, 1.25 * self.row.height * UP)\n",
        "\n",
        "            self.play(\n",
        "                SplitRectsInBrickWall(self.row)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.row = self.merge_rects_by_subdiv(self.row)\n",
        "            self.wait()\n",
        "            self.row = self.merge_rects_by_coloring(self.row)\n",
        "            self.wait()\n",
        "\n",
        "            self.play(FadeOut(previous_row))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ShowProbsInBrickRow3(BrickRowScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy = randy.scale(0.5).move_to(3*DOWN + 6*LEFT)\n",
        "        #self.add(randy)\n",
        "        self.row = BrickRow(3, height = 2, width = 10)\n",
        "        self.wait()\n",
        "\n",
        "        self.add(self.row)\n",
        "\n",
        "        tallies = VGroup()\n",
        "        for (i, rect) in enumerate(self.row.get_rects_for_level(3)):\n",
        "            tally = TallyStack(3-i, i, show_decimals = False)\n",
        "            tally.move_to(rect)\n",
        "            tallies.add(tally)\n",
        "\n",
        "        self.add(tallies)\n",
        "        self.wait(6)\n",
        "\n",
        "        braces = VGroup(*[Brace(rect, UP) for rect in self.row.rects])\n",
        "        counts = [choose(3, i) for i in range(4)]\n",
        "        probs = VGroup(*[Tex(\"{\" + str(k) + \"\\over 8}\") for k in counts])\n",
        "        for (brace, prob) in zip(braces, probs):\n",
        "            prob.next_to(brace, UP)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, braces, run_time = 3),\n",
        "            LaggedStartMap(Write, probs, run_time = 3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(braces),FadeOut(probs))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ShowOutcomesInBrickRow4(BrickRowScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy = randy.scale(0.5).move_to(3*DOWN + 6*LEFT)\n",
        "        #self.add(randy)\n",
        "        self.row = BrickRow(3, height = 2, width = 10)\n",
        "        \n",
        "        previous_row = self.row.copy()\n",
        "        v = 1.25 * self.row.height * UP\n",
        "        self.play(\n",
        "            previous_row.shift, v,\n",
        "        )\n",
        "\n",
        "        self.add(self.row)\n",
        "        self.add(previous_row)\n",
        "\n",
        "                \n",
        "\n",
        "\n",
        "        self.wait()\n",
        "        previous_outcomes = previous_row.get_outcome_rects_for_level(3,\n",
        "            with_labels = True, inset = True)\n",
        "\n",
        "        previous_outcomes_copy = previous_outcomes.copy()\n",
        "\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, previous_outcomes),\n",
        "            LaggedStartMap(FadeIn, previous_outcomes_copy),\n",
        "        )\n",
        "        \n",
        "        self.wait()\n",
        "\n",
        "        new_outcomes = self.row.get_outcome_rects_for_level(4,\n",
        "            with_labels = True, inset = True)\n",
        "        # remove each last coin\n",
        "\n",
        "\n",
        "        new_outcomes_left = VGroup(\n",
        "            new_outcomes[0],\n",
        "            new_outcomes[2],\n",
        "            new_outcomes[3],\n",
        "            new_outcomes[4],\n",
        "            new_outcomes[8],\n",
        "            new_outcomes[9],\n",
        "            new_outcomes[10],\n",
        "            new_outcomes[14]\n",
        "        )\n",
        "        new_outcomes_right = VGroup(\n",
        "            new_outcomes[1],\n",
        "            new_outcomes[5],\n",
        "            new_outcomes[6],\n",
        "            new_outcomes[7],\n",
        "            new_outcomes[11],\n",
        "            new_outcomes[12],\n",
        "            new_outcomes[13],\n",
        "            new_outcomes[15]\n",
        "        )\n",
        "        heads_labels = VGroup(*[outcome.label[-1] for outcome in new_outcomes_left])\n",
        "        tails_labels = VGroup(*[outcome.label[-1] for outcome in new_outcomes_right])\n",
        "        heads_labels.save_state()\n",
        "        tails_labels.save_state()\n",
        "        for outcome in new_outcomes:\n",
        "            outcome.label[-1].fade(1)\n",
        "\n",
        "        run_time = 0.5\n",
        "        self.play(Transform(previous_outcomes[0], new_outcomes_left[0], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes[1:4], new_outcomes_left[1:4], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes[4:7], new_outcomes_left[4:7], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes[7], new_outcomes_left[7], run_time = run_time))\n",
        "\n",
        "\n",
        "        self.play(heads_labels.restore)\n",
        "\n",
        "\n",
        "        self.play(Transform(previous_outcomes_copy[0], new_outcomes_right[0], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes_copy[1:4], new_outcomes_right[1:4], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes_copy[4:7], new_outcomes_right[4:7], run_time = run_time))\n",
        "        self.play(Transform(previous_outcomes_copy[7], new_outcomes_right[7], run_time = run_time))\n",
        "\n",
        "\n",
        "        self.play(tails_labels.restore)\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        anims = [FadeOut(previous_outcomes),FadeOut(previous_outcomes_copy)]\n",
        "\n",
        "        for outcome in new_outcomes_left:\n",
        "            anims.append(FadeOut(outcome.label[-1]))\n",
        "        for outcome in new_outcomes_right:\n",
        "            anims.append(FadeOut(outcome.label[-1]))\n",
        "\n",
        "        self.play(*anims)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class SplitTalliesIntoBrickRow4(BrickRowScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy = randy.scale(0.5).move_to(3*DOWN + 6*LEFT)\n",
        "        #self.add(randy)\n",
        "        self.row = BrickRow(3, height = 2, width = 10)\n",
        "        \n",
        "        previous_row = self.row.copy()\n",
        "        v = 1.25 * self.row.height * UP\n",
        "        self.play(\n",
        "            previous_row.shift, v,\n",
        "        )\n",
        "\n",
        "        tallies = VGroup()\n",
        "        for (i, rect) in enumerate(previous_row.get_rects_for_level(3)):\n",
        "            tally = TallyStack(3-i, i, show_decimals = True)\n",
        "            tally.move_to(rect)\n",
        "            tallies.add(tally)\n",
        "\n",
        "        moving_tallies_left = tallies.copy()\n",
        "        moving_tallies_right = tallies.copy()\n",
        "\n",
        "        self.add(self.row, previous_row)\n",
        "        self.add_foreground_mobject(tallies)\n",
        "        self.add_foreground_mobject(moving_tallies_left)\n",
        "        self.add_foreground_mobject(moving_tallies_right)\n",
        "\n",
        "\n",
        "        self.play(SplitRectsInBrickWall(self.row))\n",
        "\n",
        "        anims = []\n",
        "        for (tally, rect) in zip(moving_tallies_left, previous_row.rects):\n",
        "            anims.append(tally.move_to)\n",
        "            anims.append(rect.get_center() + rect.get_width() * 0.25 * LEFT)\n",
        "\n",
        "        self.play(*anims)\n",
        "\n",
        "        new_tallies_left = VGroup()\n",
        "        for (i, tally) in enumerate(moving_tallies_left):\n",
        "            new_tally = TallyStack(4-i,i, with_labels = True)\n",
        "            new_tally.move_to(tally)\n",
        "            new_tallies_left.add(new_tally)\n",
        "\n",
        "        self.play(Transform(moving_tallies_left, new_tallies_left))\n",
        "\n",
        "        anims = []\n",
        "        for (tally, rect) in zip(moving_tallies_right, previous_row.rects):\n",
        "            anims.append(tally.move_to)\n",
        "            anims.append(rect.get_center() + rect.get_width() * 0.25 * RIGHT)\n",
        "\n",
        "        self.play(*anims)\n",
        "\n",
        "        new_tallies_right = VGroup()\n",
        "        for (i, tally) in enumerate(moving_tallies_right):\n",
        "            new_tally = TallyStack(3-i,i+1, with_labels = True)\n",
        "            new_tally.move_to(tally)\n",
        "            new_tallies_right.add(new_tally)\n",
        "\n",
        "        self.play(Transform(moving_tallies_right, new_tallies_right))\n",
        "\n",
        "\n",
        "        hypothetical_new_row = BrickRow(4, height = 2, width = 10)\n",
        "        anims = []\n",
        "        for (tally, rect) in zip(moving_tallies_left[1:], hypothetical_new_row.rects[1:-1]):\n",
        "            anims.append(tally.move_to)\n",
        "            anims.append(rect)\n",
        "        for (tally, rect) in zip(moving_tallies_right[:-1], hypothetical_new_row.rects[1:-1]):\n",
        "            anims.append(tally.move_to)\n",
        "            anims.append(rect)\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "        self.row = self.merge_rects_by_subdiv(self.row)\n",
        "        self.wait()\n",
        "        self.row = self.merge_rects_by_coloring(self.row)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}