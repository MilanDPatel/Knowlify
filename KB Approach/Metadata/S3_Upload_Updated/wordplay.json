{
    "topic": "demonstrates the concept of sorting a set of points by their distance from a reference point.",
    "code": [
        "import numpy as np\n",
        "import itertools as it\n",
        "import os\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from from_3b1b.old.brachistochrone.drawing_images import sort_by_color\n",
        "\n",
        "class Intro(Scene):\n",
        "    def construct(self):\n",
        "        logo = ImageMobject(\"LogoGeneration\", invert = False)\n",
        "        name_mob = OldTexText(\"3Blue1Brown\").center()\n",
        "        name_mob.set_color(\"grey\")\n",
        "        name_mob.shift(2*DOWN)\n",
        "        self.add(name_mob, logo)\n",
        "\n",
        "        new_text = OldTexText([\"with \", \"Steven Strogatz\"])\n",
        "        new_text.next_to(name_mob, DOWN)\n",
        "        self.play(*[\n",
        "            ShimmerIn(part)\n",
        "            for part in new_text.split()\n",
        "        ])\n",
        "        self.wait()\n",
        "        with_word, steve = new_text.split()\n",
        "        steve_copy = steve.copy().center().to_edge(UP)\n",
        "        # logo.sort_points(lambda p : -get_norm(p))\n",
        "        sort_by_color(logo)\n",
        "        self.play(\n",
        "            Transform(steve, steve_copy),\n",
        "            DelayByOrder(Transform(logo, Point())),\n",
        "            FadeOut(with_word),\n",
        "            FadeOut(name_mob),\n",
        "            run_time = 3\n",
        "        )\n",
        "\n",
        "\n",
        "class IntroduceSteve(Scene):\n",
        "    def construct(self):\n",
        "        name = OldTexText(\"Steven Strogatz\")\n",
        "        name.to_edge(UP)\n",
        "        contributions = OldTexText(\"Frequent Contributions\")\n",
        "        contributions.scale(0.5).to_edge(RIGHT).shift(2*UP)\n",
        "        books_word = OldTexText(\"Books\")\n",
        "        books_word.scale(0.5).to_edge(LEFT).shift(2*UP)\n",
        "        radio_lab, sci_fri, cornell, book2, book3, book4 = [\n",
        "            ImageMobject(filename, invert = False, filter_color = WHITE)\n",
        "            for filename in [\n",
        "                \"radio_lab\",\n",
        "                \"science_friday\",\n",
        "                \"cornell\",\n",
        "                \"strogatz_book2\",\n",
        "                \"strogatz_book3\",\n",
        "                \"strogatz_book4\",\n",
        "            ]\n",
        "        ]\n",
        "        book1 = ImageMobject(\"strogatz_book1\", invert = False)\n",
        "        nyt = ImageMobject(\"new_york_times\")\n",
        "        logos = [radio_lab, nyt, sci_fri]\n",
        "        books = [book1, book2, book3, book4]\n",
        "\n",
        "        sample_size = Square(side_length = 2)\n",
        "        last = contributions        \n",
        "        for image in logos:\n",
        "            image.replace(sample_size)\n",
        "            image.next_to(last, DOWN)\n",
        "            last = image\n",
        "        sci_fri.scale(0.9)\n",
        "        shift_val = 0\n",
        "        sample_size.scale(0.75)\n",
        "        for book in books:\n",
        "            book.replace(sample_size)\n",
        "            book.next_to(books_word, DOWN)\n",
        "            book.shift(shift_val*(RIGHT+DOWN))\n",
        "            shift_val += 0.5\n",
        "        sample_size.scale(2)\n",
        "        cornell.replace(sample_size)\n",
        "        cornell.next_to(name, DOWN)\n",
        "\n",
        "        self.add(name)\n",
        "        self.play(FadeIn(cornell))\n",
        "        self.play(ShimmerIn(books_word))\n",
        "        for book in books:\n",
        "            book.shift(5*LEFT)\n",
        "            self.play(ApplyMethod(book.shift, 5*RIGHT))\n",
        "        self.play(ShimmerIn(contributions))\n",
        "        for logo in logos:\n",
        "            self.play(FadeIn(logo))\n",
        "        self.wait()\n",
        "\n",
        "class ShowTweets(Scene):\n",
        "    def construct(self):\n",
        "        tweets = [\n",
        "            ImageMobject(\"tweet%d\"%x, invert = False)\n",
        "            for x in range(1, 4)\n",
        "        ]\n",
        "        for tweet in tweets:\n",
        "            tweet.scale(0.4)\n",
        "        tweets[0].to_corner(UP+LEFT)\n",
        "        tweets[1].next_to(tweets[0], RIGHT, aligned_edge = UP)\n",
        "        tweets[2].next_to(tweets[1], DOWN)\n",
        "\n",
        "        self.play(GrowFromCenter(tweets[0]))\n",
        "        for x in 1, 2:\n",
        "            self.play(\n",
        "                Transform(Point(tweets[x-1].get_center()), tweets[x]),\n",
        "                Animation(tweets[x-1])\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class LetsBeHonest(Scene):\n",
        "    def construct(self):\n",
        "        self.play(ShimmerIn(OldTexText(\"\"\"\n",
        "            Let's be honest about who benefits \n",
        "            from this collaboration...\n",
        "        \"\"\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhatIsTheBrachistochrone(Scene):\n",
        "    def construct(self):\n",
        "        self.play(ShimmerIn(OldTexText(\"\"\"\n",
        "            So \\\\dots what is the Brachistochrone?\n",
        "        \"\"\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DisectBrachistochroneWord(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText([\"Bra\", \"chis\", \"to\", \"chrone\"])\n",
        "        original_word = word.copy()\n",
        "        dots = []\n",
        "        for part in word.split():\n",
        "            if dots:\n",
        "                part.next_to(dots[-1], buff = 0.06)\n",
        "            dot = OldTex(\"\\\\cdot\")\n",
        "            dot.next_to(part, buff = 0.06)\n",
        "            dots.append(dot)\n",
        "        dots = Mobject(*dots[:-1])\n",
        "        dots.shift(0.1*DOWN)\n",
        "        Mobject(word, dots).center()\n",
        "        overbrace1 = Brace(Mobject(*word.split()[:-1]), UP)\n",
        "        overbrace2 = Brace(word.split()[-1], UP)\n",
        "        shortest = OldTexText(\"Shortest\")\n",
        "        shortest.next_to(overbrace1, UP)\n",
        "        shortest.set_color(YELLOW)\n",
        "        time = OldTexText(\"Time\")\n",
        "        time.next_to(overbrace2, UP)\n",
        "        time.set_color(YELLOW)\n",
        "        chrono_example = OldTexText(\"\"\"\n",
        "            As in ``Chronological'' \\\\\\\\\n",
        "            or ``Synchronize''\n",
        "        \"\"\")\n",
        "        chrono_example.scale(0.5)\n",
        "        chrono_example.to_edge(RIGHT)\n",
        "        chrono_example.shift(2*UP)\n",
        "        chrono_example.set_color(BLUE_D)\n",
        "        chrono_arrow = Arrow(\n",
        "            word.get_right(), \n",
        "            chrono_example.get_bottom(), \n",
        "            color = BLUE_D\n",
        "        )\n",
        "        brachy_example = OldTexText(\"As in . . . brachydactyly?\")\n",
        "        brachy_example.scale(0.5)\n",
        "        brachy_example.to_edge(LEFT)\n",
        "        brachy_example.shift(2*DOWN)\n",
        "        brachy_example.set_color(GREEN)\n",
        "        brachy_arrow = Arrow(\n",
        "            word.get_left(),\n",
        "            brachy_example.get_top(), \n",
        "            color = GREEN\n",
        "        )\n",
        "\n",
        "        pronunciation = OldTexText([\"/br\", \"e\", \"kist\",\"e\",\"kr$\\\\bar{o}$n/\"])\n",
        "        pronunciation.split()[1].rotate(np.pi)\n",
        "        pronunciation.split()[3].rotate(np.pi) \n",
        "        pronunciation.scale(0.7)\n",
        "        pronunciation.shift(DOWN)\n",
        "\n",
        "        latin = OldTexText(list(\"Latin\"))\n",
        "        greek = OldTexText(list(\"Greek\"))\n",
        "        for mob in latin, greek:\n",
        "            mob.to_edge(LEFT)\n",
        "        question_mark = OldTexText(\"?\").next_to(greek, buff = 0.1)\n",
        "        stars = Stars().set_color(BLACK)\n",
        "        stars.scale(0.5).shift(question_mark.get_center())\n",
        "\n",
        "        self.play(Transform(original_word, word), ShowCreation(dots))\n",
        "        self.play(ShimmerIn(pronunciation))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(overbrace1),\n",
        "            GrowFromCenter(overbrace2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(latin))\n",
        "        self.play(FadeIn(question_mark))\n",
        "        self.play(Transform(\n",
        "            latin, greek,\n",
        "            path_func = counterclockwise_path()\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Transform(question_mark, stars))\n",
        "        self.remove(stars)\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(shortest))\n",
        "        self.play(ShimmerIn(time))\n",
        "        for ex, ar in [(chrono_example, chrono_arrow), (brachy_example, brachy_arrow)]:\n",
        "            self.play(\n",
        "                ShowCreation(ar),\n",
        "                ShimmerIn(ex)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class OneSolutionTwoInsights(Scene):\n",
        "    def construct(self):\n",
        "        one_solution = OldTexText([\"One \", \"solution\"])\n",
        "        two_insights = OldTexText([\"Two \", \" insights\"])\n",
        "        two, insights = two_insights.split()        \n",
        "        johann = ImageMobject(\"Johann_Bernoulli2\", invert = False)\n",
        "        mark = ImageMobject(\"Mark_Levi\", invert = False)\n",
        "        for mob in johann, mark:\n",
        "            mob.scale(0.4)\n",
        "        johann.next_to(insights, LEFT)\n",
        "        mark.next_to(johann, RIGHT)\n",
        "        name = OldTexText(\"Mark Levi\").to_edge(UP)\n",
        "\n",
        "        self.play(*list(map(ShimmerIn, one_solution.split())))\n",
        "        self.wait()\n",
        "        for pair in zip(one_solution.split(), two_insights.split()):\n",
        "            self.play(Transform(*pair, path_func = path_along_arc(np.pi)))\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(two, insights)\n",
        "        for word, man in [(two, johann), (insights, mark)]:\n",
        "            self.play(\n",
        "                Transform(word, Point(word.get_left())),                \n",
        "                GrowFromCenter(man)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.clear()\n",
        "        self.play(ApplyMethod(mark.center))\n",
        "        self.play(ShimmerIn(name))\n",
        "        self.wait()\n",
        "\n",
        "class CircleOfIdeas(Scene):\n",
        "    def construct(self):\n",
        "        words = list(map(TexText, [\n",
        "            \"optics\", \"calculus\", \"mechanics\", \"geometry\", \"history\"\n",
        "        ]))\n",
        "        words[0].set_color(YELLOW)\n",
        "        words[1].set_color(BLUE_D)\n",
        "        words[2].set_color(GREY)\n",
        "        words[3].set_color(GREEN)\n",
        "        words[4].set_color(MAROON)\n",
        "        brachistochrone = OldTexText(\"Brachistochrone\")\n",
        "        displayed_words = []\n",
        "        for word in words:\n",
        "            anims = self.get_spinning_anims(displayed_words)\n",
        "            word.shift(3*RIGHT)\n",
        "            point = Point()\n",
        "            anims.append(Transform(point, word))\n",
        "            self.play(*anims)\n",
        "            self.remove(point)\n",
        "            self.add(word)\n",
        "            displayed_words.append(word)\n",
        "        self.play(*self.get_spinning_anims(displayed_words))\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                word, word.copy().set_color(BLACK).center().scale(0.1),\n",
        "                path_func = path_along_arc(np.pi),\n",
        "                rate_func=linear,\n",
        "                run_time = 2\n",
        "            )\n",
        "            for word in displayed_words\n",
        "        ]+[\n",
        "            GrowFromCenter(brachistochrone)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def get_spinning_anims(self, words, angle = np.pi/6):\n",
        "        anims = []\n",
        "        for word in words:\n",
        "            old_center = word.get_center()\n",
        "            new_center = rotate_vector(old_center, angle)\n",
        "            vect = new_center-old_center\n",
        "            anims.append(ApplyMethod(\n",
        "                word.shift, vect,\n",
        "                path_func = path_along_arc(angle), \n",
        "                rate_func=linear\n",
        "            ))\n",
        "        return anims\n",
        "\n",
        "\n",
        "class FermatsPrincipleStatement(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText([\n",
        "            \"Fermat's principle:\",\n",
        "            \"\"\"\n",
        "            If a beam of light travels\n",
        "            from point $A$ to $B$, it does so along the \n",
        "            fastest path possible.\n",
        "            \"\"\"\n",
        "        ])\n",
        "        words.split()[0].set_color(BLUE)\n",
        "        everything = MobjectFromRegion(Region())\n",
        "        everything.scale(0.9)\n",
        "        angles = np.apply_along_axis(\n",
        "            angle_of_vector, 1, everything.points\n",
        "        )\n",
        "        norms = np.apply_along_axis(\n",
        "            get_norm, 1, everything.points\n",
        "        )\n",
        "        norms -= np.min(norms)\n",
        "        norms /= np.max(norms)\n",
        "        alphas = 0.25 + 0.75 * norms * (1 + np.sin(12*angles))/2\n",
        "        everything.rgbas = alphas.repeat(3).reshape((len(alphas), 3))\n",
        "\n",
        "        Mobject(everything, words).show()\n",
        "\n",
        "        everything.sort_points(get_norm)        \n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            DelayByOrder(FadeIn(everything, run_time = 3)),\n",
        "            Animation(words)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(everything.set_color, WHITE),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class VideoProgression(Scene):\n",
        "    def construct(self):\n",
        "        spacing = 2*UP\n",
        "        brachy, optics, light_in_two, snells, multi = words = [\n",
        "            OldTexText(text)\n",
        "            for text in [\n",
        "                \"Brachistochrone\", \n",
        "                \"Optics\",\n",
        "                \"Light in two media\",\n",
        "                \"Snell's Law\",\n",
        "                \"Multilayered glass\",\n",
        "            ]\n",
        "        ]\n",
        "        for mob in light_in_two, snells:\n",
        "            mob.shift(-spacing)\n",
        "        arrow1 = Arrow(brachy, optics)\n",
        "        arrow2 = Arrow(optics, snells)\n",
        "        point = Point(DOWN)\n",
        "\n",
        "        self.play(ShimmerIn(brachy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(brachy.shift, spacing),\n",
        "            Transform(point, optics)\n",
        "        )\n",
        "        optics = point\n",
        "        arrow1 = Arrow(optics, brachy)\n",
        "        self.play(ShowCreation(arrow1))\n",
        "        self.wait()\n",
        "        arrow2 = Arrow(light_in_two, optics)        \n",
        "        self.play(\n",
        "            ShowCreation(arrow2),\n",
        "            ShimmerIn(light_in_two)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(light_in_two),\n",
        "            GrowFromCenter(snells),\n",
        "            DelayByOrder(\n",
        "                ApplyMethod(arrow2.set_color, BLUE_D)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(optics),\n",
        "            GrowFromCenter(multi),\n",
        "            DelayByOrder(\n",
        "                ApplyMethod(arrow1.set_color, BLUE_D)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class BalanceCompetingFactors(Scene):\n",
        "    args_list = [\n",
        "        (\"Short\", \"Steep\"),\n",
        "        (\"Minimal time \\\\\\\\ in water\", \"Short path\")\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(*words):\n",
        "        return \"\".join([word.split(\" \")[0] for word in words])\n",
        "        \n",
        "    def construct(self, *words):\n",
        "        factor1, factor2 = [\n",
        "            OldTexText(\"Factor %d\"%x).set_color(c)\n",
        "            for x, c in [\n",
        "                (1, RED_D),\n",
        "                (2, BLUE_D)\n",
        "            ]\n",
        "        ]\n",
        "        real_factor1, real_factor2 = list(map(TexText, words))  \n",
        "        for word in factor1, factor2, real_factor1, real_factor2:\n",
        "            word.shift(0.2*UP-word.get_bottom())\n",
        "        for f1 in factor1, real_factor1:\n",
        "            f1.set_color(RED_D)\n",
        "            f1.shift(2*LEFT)\n",
        "        for f2 in factor2, real_factor2:\n",
        "            f2.set_color(BLUE_D)\n",
        "            f2.shift(2*RIGHT)      \n",
        "        line = Line(\n",
        "            factor1.get_left(),\n",
        "            factor2.get_right()\n",
        "        )\n",
        "        line.center()\n",
        "        self.balancers = Mobject(factor1, factor2, line)\n",
        "        self.hidden_balancers = Mobject(real_factor1, real_factor2)\n",
        "\n",
        "        triangle = Polygon(RIGHT, np.sqrt(3)*UP, LEFT)\n",
        "        triangle.next_to(line, DOWN, buff = 0)\n",
        "\n",
        "        self.add(triangle, self.balancers)\n",
        "        self.rotate(1)\n",
        "        self.rotate(-2)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            factor1, real_factor1, \n",
        "            path_func = path_along_arc(np.pi/4)\n",
        "        ))\n",
        "        self.rotate(2)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            factor2, real_factor2,\n",
        "            path_func = path_along_arc(np.pi/4)\n",
        "        ))\n",
        "        self.rotate(-2)\n",
        "        self.wait()\n",
        "        self.rotate(1)\n",
        "\n",
        "    def rotate(self, factor):\n",
        "        angle = np.pi/11\n",
        "        self.play(Rotate(\n",
        "            self.balancers, \n",
        "            factor*angle,\n",
        "            run_time = abs(factor)\n",
        "        ))\n",
        "        self.hidden_balancers.rotate(factor*angle)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class Challenge(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\"\"\n",
        "            Can you find a new solution to the \n",
        "            Brachistochrone problem by finding \n",
        "            an intuitive reason that time-minimizing\n",
        "            curves look like straight lines in \n",
        "            $t$-$\\\\theta$ space?\n",
        "        \"\"\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class Section1(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Section 1: Johann Bernoulli's insight\"))\n",
        "        self.wait()\n",
        "\n",
        "class Section2(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\n",
        "            \"Section 2: Mark Levi's insight, and a challenge\",\n",
        "            size = \"\\\\large\"\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class NarratorInterjection(Scene):\n",
        "    def construct(self):\n",
        "        words1 = OldTex(\"<\\\\text{Narrator interjection}>\")\n",
        "        words2 = OldTex(\"<\\\\!/\\\\text{Narrator interjection}>\")\n",
        "        self.add(words1)\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(words2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThisCouldBeTheEnd(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText([\n",
        "            \"This could be the end\\\\dots\",\n",
        "            \"but\\\\dots\"\n",
        "        ])\n",
        "        for part in words.split():\n",
        "            self.play(ShimmerIn(part))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MyOwnChallenge(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"My own challenge:\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WarmupChallenge(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\\\\large Warm-up challenge: Confirm this for yourself\"))\n",
        "        self.wait()\n",
        "\n",
        "class FindAnotherSolution(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Find another brachistochrone solution\\\\dots\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ProofOfSnellsLaw(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Proof of Snell's law:\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CondensedVersion(Scene):\n",
        "    def construct(self):\n",
        "        snells = OldTexText(\"Snell's\")\n",
        "        snells.shift(-snells.get_left())\n",
        "        snells.to_edge(UP)\n",
        "        for vect in [RIGHT, RIGHT, LEFT, DOWN, DOWN, DOWN]:\n",
        "            snells.add(snells.copy().next_to(snells, vect))\n",
        "        snells.ingest_submobjects()\n",
        "        snells.show()\n",
        "        condensed = OldTexText(\"condensed\")\n",
        "\n",
        "        self.add(snells)\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(\n",
        "            Transform(snells, condensed, run_time = 2)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}