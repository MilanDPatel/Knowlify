{
    "topic": "demonstrates the concept of an oscillating wave in a plane with a variable amplitude and w",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.optics_puzzles.objects import *\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class SimpleLightBeam(InteractiveScene):\n",
        "    default_frame_orientation = (-33, 85)\n",
        "    axes_config = dict()\n",
        "    z_amplitude = 0.5\n",
        "    wave_len = 2.0\n",
        "    speed = 1.0\n",
        "    color = YELLOW\n",
        "    oscillating_field_config = dict(\n",
        "        stroke_opacity=0.5,\n",
        "        stroke_width=2,\n",
        "        tip_width_ratio=1\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        axes, plane = get_axes_and_plane(**self.axes_config)\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        # Introduce wave\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            z_amplitude=self.z_amplitude,\n",
        "            wave_len=self.wave_len,\n",
        "            speed=self.speed,\n",
        "            color=self.color\n",
        "        )\n",
        "        vect_wave = OscillatingFieldWave(axes, wave, **self.oscillating_field_config)\n",
        "\n",
        "        def update_wave(wave):\n",
        "            st = self.time * self.speed  # Suppressor threshold\n",
        "            points = wave.get_points().copy()\n",
        "            xs = axes.x_axis.p2n(points)\n",
        "            suppressors = np.clip(smooth(st - xs), 0, 1)\n",
        "            points[:, 1] *= suppressors\n",
        "            points[:, 2] *= suppressors\n",
        "            wave.set_points(points)\n",
        "            return wave\n",
        "\n",
        "        wave.add_updater(update_wave)\n",
        "        vect_wave.add_updater(update_wave)\n",
        "\n",
        "        self.add(wave)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-98, 77, 0).move_to([-0.87, 0.9, -0.43]),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.add(vect_wave, wave)\n",
        "        self.play(\n",
        "            VFadeIn(vect_wave),\n",
        "            self.frame.animate.reorient(-10, 77, 0).move_to([-0.87, 0.9, -0.43]),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Label directions\n",
        "        z_label = Tex(\"z\")\n",
        "        z_label.rotate(PI / 2, RIGHT)\n",
        "        z_label.next_to(axes.z_axis, OUT)\n",
        "\n",
        "        y_label = Tex(\"y\")\n",
        "        y_label.rotate(PI / 2, RIGHT)\n",
        "        y_label.next_to(axes.y_axis, UP + OUT)\n",
        "\n",
        "        x_label = VGroup(\n",
        "            TexText(\"$x$-direction\"),\n",
        "            Vector(RIGHT, stroke_color=WHITE),\n",
        "        )\n",
        "        x_label.arrange(RIGHT)\n",
        "        x_label.set_flat_stroke(False)\n",
        "        x_label.rotate(PI / 2, RIGHT)\n",
        "        x_label.next_to(z_label, RIGHT, buff=2.0)\n",
        "        x_label.match_z(axes.c2p(0, 0, 0.75))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(z_label, 0.5 * OUT),\n",
        "            FadeIn(y_label, 0.5 * UP),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Write(x_label[0]),\n",
        "            GrowArrow(x_label[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-41, 77, 0).move_to([-0.87, 0.9, -0.43]),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class TwistingLightBeam(SimpleLightBeam):\n",
        "    z_amplitude = 0.5\n",
        "    wave_len = 2.0\n",
        "    twist_rate = 1 / 72\n",
        "    speed = 1.0\n",
        "    color = YELLOW\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes, plane = get_axes_and_plane(**self.axes_config)\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        # Add wave\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            z_amplitude=self.z_amplitude,\n",
        "            wave_len=self.wave_len,\n",
        "            speed=self.speed,\n",
        "            color=self.color\n",
        "        )\n",
        "        vect_wave = OscillatingFieldWave(axes, wave, **self.oscillating_field_config)\n",
        "\n",
        "        twist_rate_tracker = ValueTracker(0)\n",
        "\n",
        "        def update_twist_rate(wave):\n",
        "            wave.twist_rate = twist_rate_tracker.get_value()\n",
        "            return wave\n",
        "\n",
        "        wave.add_updater(update_twist_rate)\n",
        "\n",
        "        cylinder = SugarCylinder(axes, self.camera, radius=self.z_amplitude)\n",
        "\n",
        "        self.add(vect_wave, wave)\n",
        "        self.frame.reorient(-41, 77, 0).move_to([-0.87, 0.9, -0.43])\n",
        "        self.wait(4)\n",
        "        cylinder.save_state()\n",
        "        cylinder.stretch(0, 0, about_edge=RIGHT)\n",
        "        self.play(\n",
        "            Restore(cylinder, time_span=(0, 3)),\n",
        "            twist_rate_tracker.animate.set_value(self.twist_rate).set_anim_args(time_span=(0, 3)),\n",
        "            self.frame.animate.reorient(-47, 80, 0).move_to([0.06, -0.05, 0.05]).set_height(8.84),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-130, 77, 0).move_to([0.35, -0.36, 0.05]),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-57, 77, 0).move_to([0.35, -0.36, 0.05]),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "        # Add rod with oscillating ball\n",
        "        x_tracker, plane, rod, ball, x_label = self.get_slice_group(axes, wave)\n",
        "        plane.save_state()\n",
        "        plane.stretch(0, 2, about_edge=OUT)\n",
        "\n",
        "        frame_anim = self.frame.animate.reorient(-45, 79, 0)\n",
        "        frame_anim.move_to([0.63, 0.47, -0.25])\n",
        "        frame_anim.set_height(10.51)\n",
        "        frame_anim.set_anim_args(run_time=3)\n",
        "\n",
        "        self.add(rod, ball, plane, cylinder)\n",
        "        self.play(\n",
        "            frame_anim,\n",
        "            FadeIn(rod),\n",
        "            Restore(plane),\n",
        "            FadeIn(x_label),\n",
        "            UpdateFromAlphaFunc(wave,\n",
        "                lambda m, a: m.set_stroke(\n",
        "                    width=interpolate(2, 1, a),\n",
        "                    opacity=interpolate(1, 0.5, a),\n",
        "                ),\n",
        "                run_time=3,\n",
        "                time_span=(0, 2),\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(ball, lambda m, a: m.set_opacity(a)),\n",
        "        )\n",
        "        self.wait(9)\n",
        "\n",
        "        # Show twist down the line of the cylinder\n",
        "        x_tracker.set_value(0)\n",
        "        x_tracker.clear_updaters()\n",
        "        x_tracker.add_updater(lambda m, dt: m.increment_value(0.5 * dt))\n",
        "        self.add(x_tracker)\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-87, 88, 0).move_to([0.63, 0.47, -0.25]).set_height(10.51),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-43, 78, 0).move_to([0.63, 0.47, -0.25]).set_height(10.51),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-34, 80, 0).move_to([1.61, -0.05, 0.3]).set_height(10.30),\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_slice_group(self, axes, wave):\n",
        "        x_tracker = ValueTracker(0)\n",
        "        get_x = x_tracker.get_value\n",
        "\n",
        "        rod = self.get_polarization_rod(axes, wave, get_x)\n",
        "        ball = self.get_wave_ball(wave, get_x)\n",
        "        plane = self.get_slice_plane(axes, get_x)\n",
        "        x_label = self.get_plane_label(axes, plane)\n",
        "\n",
        "        return Group(x_tracker, plane, rod, ball, x_label)\n",
        "\n",
        "    def get_polarization_rod(self, axes, wave, get_x, stroke_color=None, length_mult=2.0, stroke_width=3):\n",
        "        rod = Line(IN, OUT)\n",
        "        rod.set_stroke(\n",
        "            color=stroke_color or wave.get_stroke_color(),\n",
        "            width=stroke_width,\n",
        "        )\n",
        "        rod.set_flat_stroke(False)\n",
        "        wave_z = axes.z_axis.p2n(wave.get_center())\n",
        "        wave_y = axes.y_axis.p2n(wave.get_center())\n",
        "\n",
        "        def update_rod(rod):\n",
        "            x = get_x()\n",
        "            rod.put_start_and_end_on(\n",
        "                axes.c2p(x, wave_y, wave_z - length_mult * wave.z_amplitude),\n",
        "                axes.c2p(x, wave_y, wave_z + length_mult * wave.z_amplitude),\n",
        "            )\n",
        "            rod.rotate(TAU * wave.twist_rate * x, RIGHT)\n",
        "            return rod\n",
        "\n",
        "        rod.add_updater(update_rod)\n",
        "        return rod\n",
        "\n",
        "    def get_wave_ball(self, wave, get_x, radius=0.075):\n",
        "        ball = TrueDot(radius=radius)\n",
        "        ball.make_3d()\n",
        "        ball.set_color(wave.get_color())\n",
        "\n",
        "        def update_ball(ball):\n",
        "            ball.move_to(wave.offset + wave.xt_to_point(get_x(), wave.time))\n",
        "            return ball\n",
        "\n",
        "        ball.add_updater(update_ball)\n",
        "        return ball\n",
        "\n",
        "    def get_slice_plane(self, axes, get_x):\n",
        "        plane = Square(side_length=axes.z_axis.get_length())\n",
        "        plane.set_fill(BLUE, 0.25)\n",
        "        plane.set_stroke(width=0)\n",
        "        circle = Circle(\n",
        "            radius=axes.z_axis.get_unit_size() * self.z_amplitude,\n",
        "            n_components=100,\n",
        "        )\n",
        "        circle.set_flat_stroke(False)\n",
        "        circle.set_stroke(BLACK, 1)\n",
        "        plane.add(circle)\n",
        "        plane.rotate(PI / 2, UP)\n",
        "        plane.add_updater(lambda m: m.move_to(axes.c2p(get_x(), 0, 0)))\n",
        "        return plane\n",
        "\n",
        "    def get_plane_label(self, axes, plane, font_size=24, color=GREY_B):\n",
        "        x_label = Tex(\"x = 0.00\", font_size=font_size)\n",
        "        x_label.set_fill(color)\n",
        "        x_label.value_mob = x_label.make_number_changeable(\"0.00\")\n",
        "        x_label.rotate(PI / 2, RIGHT)\n",
        "        x_label.rotate(PI / 2, IN)\n",
        "\n",
        "        def update_x_label(x_label):\n",
        "            x_value = x_label.value_mob\n",
        "            x_value.set_value(axes.x_axis.p2n(plane.get_center()))\n",
        "            x_value.rotate(PI / 2, RIGHT)\n",
        "            x_value.rotate(PI / 2, IN)\n",
        "            x_value.next_to(x_label[1], DOWN, SMALL_BUFF)\n",
        "            x_label.next_to(plane, OUT)\n",
        "            return x_label\n",
        "\n",
        "        x_label.add_updater(update_x_label)\n",
        "        return x_label\n",
        "\n",
        "\n",
        "class TwistingBlueLightBeam(TwistingLightBeam):\n",
        "    wave_len = 1.0\n",
        "    twist_rate = 1 / 48\n",
        "    color = PURPLE\n",
        "\n",
        "\n",
        "class TwistingRedLightBeam(TwistingLightBeam):\n",
        "    wave_len = 3.0\n",
        "    twist_rate = 1 / 96\n",
        "    color = RED\n",
        "\n",
        "\n",
        "class TwistingWithinCylinder(InteractiveScene):\n",
        "    default_frame_orientation = (-40, 80)\n",
        "    n_lines = 11\n",
        "    pause_down_the_tube = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Reference objects\n",
        "        frame = self.frame\n",
        "        axes, plane = get_axes_and_plane(\n",
        "            x_range=(0, 8),\n",
        "            y_range=(-2, 2),\n",
        "            z_range=(-2, 2),\n",
        "            y_unit=1,\n",
        "            z_unit=1,\n",
        "            origin_point=3 * LEFT\n",
        "        )\n",
        "        cylinder = SugarCylinder(axes, self.camera, radius=0.5)\n",
        "\n",
        "        self.add(plane, axes)\n",
        "        self.add(cylinder)\n",
        "\n",
        "        # Light lines\n",
        "        lines = VGroup()\n",
        "        colors = get_spectral_colors(self.n_lines)\n",
        "        for color in colors:\n",
        "            line = Line(ORIGIN, 0.95 * OUT)\n",
        "            line.set_flat_stroke(False)\n",
        "            line.set_stroke(color, 2)\n",
        "            lines.add(line)\n",
        "\n",
        "        lines.arrange(DOWN, buff=0.1)\n",
        "        lines.move_to(cylinder.get_left())\n",
        "\n",
        "        # Add polarizer to the start\n",
        "        light = GlowDot(color=WHITE, radius=3)\n",
        "        light.move_to(axes.c2p(-3, 0, 0))\n",
        "        polarizer = Polarizer(axes, radius=0.6)\n",
        "        polarizer.move_to(axes.c2p(-1, 0, 0))\n",
        "        polarizer_label = Text(\"Linear polarizer\", font_size=36)\n",
        "        polarizer_label.rotate(PI / 2, RIGHT)\n",
        "        polarizer_label.rotate(PI / 2, IN)\n",
        "        polarizer_label.next_to(polarizer, OUT)\n",
        "        frame.reorient(-153, 79, 0)\n",
        "        frame.shift(1.0 * IN)\n",
        "\n",
        "        self.play(GrowFromCenter(light))\n",
        "        self.play(\n",
        "            Write(polarizer_label),\n",
        "            FadeIn(polarizer, IN),\n",
        "            light.animate.shift(LEFT).set_anim_args(time_span=(1, 3)),\n",
        "            self.frame.animate.reorient(-104, 77, 0).center().set_anim_args(run_time=3),\n",
        "        )\n",
        "\n",
        "        # Many waves\n",
        "        waves = VGroup(*(\n",
        "            OscillatingWave(\n",
        "                axes,\n",
        "                z_amplitude=0.3,\n",
        "                wave_len=wave_len,\n",
        "                color=line.get_color(),\n",
        "                offset=LEFT + line.get_y() * UP\n",
        "            )\n",
        "            for line, wave_len in zip(\n",
        "                lines,\n",
        "                np.linspace(2.0, 0.5, len(lines))\n",
        "            )\n",
        "        ))\n",
        "        waves.set_stroke(width=1)\n",
        "        superposition = MeanWave(waves)\n",
        "        superposition.set_stroke(WHITE, 2)\n",
        "        superposition.add_updater(lambda m: m.stretch(4, 2, about_point=ORIGIN))\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(superposition),\n",
        "            FadeOut(cylinder),\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-66, 76, 0),\n",
        "            light.animate.scale(0.25),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.remove(superposition)\n",
        "        superposition.suspend_updating()\n",
        "        self.play(*(\n",
        "            TransformFromCopy(superposition, wave, run_time=2)\n",
        "            for wave in waves\n",
        "        ))\n",
        "\n",
        "        # Go through individual waves\n",
        "        self.add(waves)\n",
        "        for wave1 in waves:\n",
        "            anims = []\n",
        "            for wave2 in waves:\n",
        "                wave2.current_opacity = wave2.get_stroke_opacity()\n",
        "                if wave1 is wave2:\n",
        "                    wave2.target_opacity = 1\n",
        "                else:\n",
        "                    wave2.target_opacity = 0.1\n",
        "                anims.append(UpdateFromAlphaFunc(wave2, lambda m, a: m.set_stroke(\n",
        "                    opacity=interpolate(m.current_opacity, m.target_opacity, a)\n",
        "                )))\n",
        "            self.play(*anims, run_time=0.5)\n",
        "            self.wait()\n",
        "\n",
        "        for wave in waves:\n",
        "            wave.current_opacity = wave.get_stroke_opacity()\n",
        "            wave.target_opacity = 1\n",
        "\n",
        "        self.play(\n",
        "            *(\n",
        "                UpdateFromAlphaFunc(wave, lambda m, a: m.set_stroke(\n",
        "                    opacity=interpolate(m.current_opacity, m.target_opacity, a)\n",
        "                ))\n",
        "                for wave in waves\n",
        "            ),\n",
        "            frame.animate.reorient(-55, 76, 0).move_to([-0.09, 0.13, -0.17]).set_height(7.5),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Introduce lines\n",
        "        white_lines = lines.copy()\n",
        "        white_lines.set_stroke(WHITE)\n",
        "        white_lines.arrange(UP, buff=0)\n",
        "        white_lines.move_to(axes.get_origin())\n",
        "\n",
        "        plane = Square(side_length=2 * axes.z_axis.get_unit_size())\n",
        "        plane.set_fill(WHITE, 0.25)\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.add(\n",
        "            Circle(radius=0.5 * cylinder.get_depth(), n_components=100).set_stroke(BLACK, 1)\n",
        "        )\n",
        "        plane.rotate(PI / 2, UP)\n",
        "        plane.move_to(axes.get_origin())\n",
        "        plane.save_state()\n",
        "        plane.stretch(0, 2, about_edge=UP)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(waves, lines, lag_ratio=0.1, run_time=3),\n",
        "            frame.animate.reorient(-61, 83, 0).move_to([0.03, -0.16, -0.28]).set_height(7).set_anim_args(run_time=2),\n",
        "            Restore(plane),\n",
        "            FadeIn(cylinder),\n",
        "        )\n",
        "        self.add(axes, lines)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lines.animate.arrange(UP, buff=0).move_to(axes.get_origin()),\n",
        "            FadeIn(white_lines),\n",
        "            FadeOut(polarizer),\n",
        "            FadeOut(polarizer_label),\n",
        "            FadeOut(light),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Enable lines to twist through the tube\n",
        "        line_start, line_end = white_lines[0].get_start_and_end()\n",
        "\n",
        "        distance_tracker = ValueTracker(0)\n",
        "\n",
        "        wave_lengths = np.linspace(700, 400, self.n_lines)  # Is this right?\n",
        "        for line, wave_length in zip(lines, wave_lengths):\n",
        "            line.wave_length = wave_length\n",
        "\n",
        "        def update_lines(lines):\n",
        "            dist = distance_tracker.get_value()\n",
        "            for line in lines:\n",
        "                line.set_points_as_corners([line_start, line_end])\n",
        "                line.rotate(get_twist(line.wave_length, dist), RIGHT)\n",
        "                line.move_to(axes.c2p(dist, 0, 0))\n",
        "                line.set_gloss(3 * np.exp(-3 * dist))\n",
        "\n",
        "        lines.add_updater(update_lines)\n",
        "\n",
        "        # Add wave trails\n",
        "        trails = VGroup(*(\n",
        "            self.get_wave_trail(line)\n",
        "            for line in lines\n",
        "        ))\n",
        "        continuous_trails = Group(*(\n",
        "            self.get_continuous_wave_trail(axes, line)\n",
        "            for line in lines\n",
        "        ))\n",
        "        for trail in continuous_trails:\n",
        "            x_unit = axes.x_axis.get_unit_size()\n",
        "            x0 = axes.get_origin()[0]\n",
        "            trail.add_updater(\n",
        "                lambda t: t.set_clip_plane(LEFT, distance_tracker.get_value() + x0)\n",
        "            )\n",
        "        self.add(trails, lines, white_lines)\n",
        "\n",
        "        # Move light beams down the pole\n",
        "        self.add(distance_tracker)\n",
        "        distance_tracker.set_value(0)\n",
        "        plane.add_updater(lambda m: m.match_x(lines))\n",
        "        self.remove(white_lines)\n",
        "\n",
        "        if self.pause_down_the_tube:\n",
        "            # Test\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(-42, 76, 0).move_to([0.03, -0.16, -0.28]).set_height(7.00),\n",
        "                distance_tracker.animate.set_value(4),\n",
        "                run_time=6,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            trails.suspend_updating()\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(67, 77, 0).move_to([-0.31, 0.48, -0.33]).set_height(4.05),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait(2)\n",
        "            trails.resume_updating()\n",
        "            self.play(\n",
        "                distance_tracker.animate.set_value(axes.x_axis.x_max),\n",
        "                self.frame.animate.reorient(-36, 79, 0).move_to([-0.07, 0.06, 0.06]).set_height(7.42),\n",
        "                run_time=6,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            trails.clear_updaters()\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(-10, 77, 0).move_to([0.42, -0.16, -0.03]).set_height(5.20),\n",
        "                trails.animate.set_stroke(width=3, opacity=0.25).set_anim_args(time_span=(0, 3)),\n",
        "                run_time=10,\n",
        "            )\n",
        "        else:\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(-63, 84, 0).move_to([1.04, -1.86, 0.55]).set_height(1.39),\n",
        "                distance_tracker.animate.set_value(axes.x_axis.x_max),\n",
        "                run_time=15,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            trails.clear_updaters()\n",
        "            lines.clear_updaters()\n",
        "\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(64, 81, 0).move_to([3.15, 0.46, -0.03]).set_height(5),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Add polarizer at the end\n",
        "        end_polarizer = Polarizer(axes, radius=0.6)\n",
        "        end_polarizer.next_to(lines, RIGHT, buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(end_polarizer, OUT),\n",
        "            FadeOut(plane),\n",
        "            self.frame.animate.reorient(54, 78, 0).move_to([3.15, 0.46, -0.03]).set_height(5.00).set_anim_args(run_time=4)\n",
        "        )\n",
        "        end_polarizer.save_state()\n",
        "        self.play(end_polarizer.animate.fade(0.8))\n",
        "\n",
        "        # Show a few different frequencies\n",
        "        vertical_components = VGroup()\n",
        "        for index in range(len(lines)):\n",
        "            lines.generate_target()\n",
        "            trails.generate_target()\n",
        "            lines.target.set_opacity(0)\n",
        "            trails.target.set_opacity(0)\n",
        "            lines.target[index].set_opacity(1)\n",
        "            trails.target[index].set_opacity(0.2)\n",
        "\n",
        "            line = lines[index]\n",
        "            x = float(axes.x_axis.p2n(cylinder.get_right()))\n",
        "            vcomp = line.copy().set_opacity(1)\n",
        "            vcomp.stretch(0, 1)\n",
        "            vcomp.move_to(axes.c2p(x, -2 + index / len(lines), 0))\n",
        "            z = float(axes.z_axis.p2n(vcomp.get_zenith()))\n",
        "            y_min, y_max = axes.y_range[:2]\n",
        "            dashed_lines = VGroup(*(\n",
        "                DashedLine(axes.c2p(x, y_min, u * z), axes.c2p(x, y_max, u * z), dash_length=0.02)\n",
        "                for u in [1, -1]\n",
        "            ))\n",
        "            dashed_lines.set_stroke(WHITE, 0.5)\n",
        "            dashed_lines.set_flat_stroke(False)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(lines),\n",
        "                MoveToTarget(trails),\n",
        "                FadeIn(dashed_lines),\n",
        "                FadeIn(vcomp),\n",
        "                self.frame.animate.reorient(77, 87, 0).move_to([3.1, 0.4, 0]).set_height(5),\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(dashed_lines),\n",
        "            )\n",
        "\n",
        "            vertical_components.add(vcomp)\n",
        "\n",
        "        self.play(\n",
        "            lines.animate.set_opacity(1),\n",
        "            trails.animate.set_opacity(0.05),\n",
        "        )\n",
        "\n",
        "        # Final color\n",
        "        def get_final_color():\n",
        "            rgbs = np.array([\n",
        "                line.data[\"stroke_rgba\"][0, :3]\n",
        "                for line in lines\n",
        "            ])\n",
        "            depths = np.array([v_line.get_depth() for v_line in vertical_components])\n",
        "            alphas = depths / depths.sum()\n",
        "            rgb = ((rgbs**0.5) * alphas[:, np.newaxis]).sum(0)**2.0\n",
        "            return rgb_to_color(rgb)\n",
        "\n",
        "        new_color = get_final_color()\n",
        "        new_lines = vertical_components.copy()\n",
        "        for line in new_lines:\n",
        "            line.set_depth(cylinder.get_depth())\n",
        "            line.set_stroke(new_color, 4)\n",
        "            line.next_to(end_polarizer, RIGHT, buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            Restore(end_polarizer),\n",
        "            TransformFromCopy(vertical_components, new_lines),\n",
        "            self.frame.animate.reorient(43, 73, 0).move_to([3.3, 0.66, -0.38]).set_height(5.68),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(45, 72, 0).move_to([3.17, 0.4, -0.56]),\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "        # Twist the tube\n",
        "        result_line = new_lines[0]\n",
        "        self.remove(new_lines)\n",
        "        self.add(result_line)\n",
        "        result_line.add_updater(lambda l: l.set_stroke(get_final_color()))\n",
        "\n",
        "        line_group = VGroup(trails, lines)\n",
        "\n",
        "        p1, p2 = axes.c2p(0, 1, 0), axes.c2p(0, -1, 0)\n",
        "        twist_arrows = VGroup(\n",
        "            Arrow(p1, p2, path_arc=PI),\n",
        "            Arrow(p2, p1, path_arc=PI),\n",
        "        )\n",
        "        twist_arrows.rotate(PI / 2, UP, about_point=axes.get_origin())\n",
        "        twist_arrows.apply_depth_test()\n",
        "        self.add(twist_arrows, cylinder, line_group, vertical_components)\n",
        "\n",
        "        for v_comp, line in zip(vertical_components, lines):\n",
        "            v_comp.line = line\n",
        "            v_comp.add_updater(lambda m: m.match_depth(m.line))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(twist_arrows, lag_ratio=0),\n",
        "            Rotate(line_group, PI, axis=RIGHT, run_time=12, rate_func=linear)\n",
        "        )\n",
        "\n",
        "    def get_wave_trail(self, line, spacing=0.05, opacity=0.05):\n",
        "        trail = VGroup()\n",
        "        trail.time = 1\n",
        "\n",
        "        def update_trail(trail, dt):\n",
        "            trail.time += dt\n",
        "            if trail.time > spacing:\n",
        "                trail.time = 0\n",
        "                trail.add(line.copy().set_opacity(opacity).set_shading(0, 0, 0))\n",
        "\n",
        "        trail.add_updater(update_trail)\n",
        "        return trail\n",
        "\n",
        "    def get_continuous_wave_trail(self, axes, line, opacity=0.4):\n",
        "        return TwistedRibbon(\n",
        "            axes,\n",
        "            amplitude=0.5 * line.get_length(),\n",
        "            twist_rate=get_twist(line.wave_length, TAU),\n",
        "            color=line.get_color(),\n",
        "            opacity=opacity,\n",
        "        )\n",
        "\n",
        "\n",
        "class InducedWiggleInCylinder(TwistingLightBeam):\n",
        "    random_seed = 3\n",
        "    cylinder_radius = 0.5\n",
        "    wave_config = dict(\n",
        "        z_amplitude=0.15,\n",
        "        wave_len=0.5,\n",
        "        color=get_spectral_color(0.1),\n",
        "        speed=1.0,\n",
        "        twist_rate=-1 / 24\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        frame.reorient(-51, 80, 0).move_to(0.5 * IN).set_height(9)\n",
        "\n",
        "        axes, plane = get_axes_and_plane(**self.axes_config)\n",
        "        cylinder = SugarCylinder(axes, self.camera, radius=self.cylinder_radius)\n",
        "        wave = OscillatingWave(axes, **self.wave_config)\n",
        "        x_tracker, plane, rod, ball, x_label = slice_group = self.get_slice_group(axes, wave)\n",
        "        rod = self.get_polarization_rod(axes, wave, x_tracker.get_value, length_mult=5.0)\n",
        "\n",
        "        axes_labels = Tex(\"yz\", font_size=30)\n",
        "        axes_labels.rotate(89 * DEGREES, RIGHT)\n",
        "        axes_labels[0].next_to(axes.y_axis.get_top(), OUT, SMALL_BUFF)\n",
        "        axes_labels[1].next_to(axes.z_axis.get_zenith(), OUT, SMALL_BUFF)\n",
        "        axes.add(axes_labels)\n",
        "\n",
        "        light = GlowDot(radius=4, color=RED)\n",
        "        light.move_to(axes.c2p(-3, 0, 0))\n",
        "\n",
        "        polarizer = Polarizer(axes, radius=0.5)\n",
        "        polarizer.move_to(axes.c2p(-1, 0, 0))\n",
        "\n",
        "        self.add(axes, cylinder, polarizer, light)\n",
        "\n",
        "        # Bounces of various points\n",
        "        randy = self.get_observer(axes.c2p(8, -3, -0.5))\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-86, 70, 0).move_to([1.01, -2.98, -0.79]).set_height(11.33),\n",
        "            FadeIn(randy, time_span=(0, 1)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        max_y = 0.5 * self.cylinder_radius\n",
        "        line = VMobject()\n",
        "        line.set_stroke(RED, 2)\n",
        "        line.set_flat_stroke(False)\n",
        "        dot = TrueDot(radius=0.05)\n",
        "        dot.make_3d()\n",
        "        for x in range(10):\n",
        "            point = axes.c2p(\n",
        "                random.uniform(axes.x_axis.x_min, axes.x_axis.x_max),\n",
        "                random.uniform(-max_y, -max_y),\n",
        "                random.uniform(-max_y, -max_y),\n",
        "            )\n",
        "            line_points = [light.get_center(), point, randy.eyes.get_top()]\n",
        "            self.add(dot, cylinder)\n",
        "            if x == 0:\n",
        "                dot.move_to(point)\n",
        "                line.set_points_as_corners(line_points)\n",
        "                self.play(ShowCreation(line))\n",
        "            else:\n",
        "                self.play(\n",
        "                    line.animate.set_points_as_corners(line_points),\n",
        "                    dot.animate.move_to(point),\n",
        "                )\n",
        "                self.wait()\n",
        "        self.play(\n",
        "            FadeOut(line),\n",
        "            FadeOut(dot),\n",
        "        )\n",
        "\n",
        "        # Show slice such that wiggling is in z direction\n",
        "        x_tracker.set_value(0)\n",
        "        self.add(wave, cylinder)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-73, 78, 0).move_to([0.8, -2.22, -0.83]).set_height(10.64),\n",
        "            light.animate.scale(0.5),\n",
        "            polarizer.animate.fade(0.5),\n",
        "            VFadeIn(wave),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.add(wave, cylinder)\n",
        "        self.play(\n",
        "            FadeIn(plane),\n",
        "            FadeIn(x_label),\n",
        "            FadeIn(rod),\n",
        "        )\n",
        "        self.play(\n",
        "            x_tracker.animate.set_value(12),\n",
        "            run_time=12,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.add(rod, ball, wave, cylinder)\n",
        "\n",
        "        # Show observer\n",
        "        line_of_sight = DashedLine(randy.eyes.get_top(), rod.get_center())\n",
        "        line_of_sight.set_stroke(WHITE, 2)\n",
        "        line_of_sight.set_flat_stroke(False)\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-60, 79, 0).move_to([0.73, -0.59, -0.39]).set_height(9.63),\n",
        "            Write(line_of_sight, time_span=(3, 4), lag_ratio=0),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show propagating rings\n",
        "        self.show_propagation(rod)\n",
        "\n",
        "        # Move to a less favorable spot\n",
        "        new_line_of_sight = DashedLine(randy.eyes.get_top(), axes.c2p(6, 0, 0))\n",
        "        new_line_of_sight.match_style(line_of_sight)\n",
        "        new_line_of_sight.set_flat_stroke(False)\n",
        "\n",
        "        self.remove(ball)\n",
        "        self.play(\n",
        "            x_tracker.animate.set_value(6),\n",
        "            FadeOut(line_of_sight, time_span=(0, 0.5)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.add(ball, wave, cylinder, plane)\n",
        "        self.play(ShowCreation(new_line_of_sight))\n",
        "        self.wait(4)\n",
        "\n",
        "        # New propagations\n",
        "        self.show_propagation(rod)\n",
        "\n",
        "        # Show ribbon\n",
        "        ribbon = TwistedRibbon(\n",
        "            axes,\n",
        "            amplitude=wave.z_amplitude,\n",
        "            twist_rate=wave.twist_rate,\n",
        "            color=wave.get_color(),\n",
        "        )\n",
        "\n",
        "        self.add(ribbon, cylinder)\n",
        "        self.play(ShowCreation(ribbon, run_time=5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(8, 77, 0).move_to([2.01, -0.91, -0.58]).set_height(5.55),\n",
        "            FadeOut(randy),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-25, 76, 0).move_to([4.22, -1.19, -0.5]),\n",
        "            x_tracker.animate.set_value(12),\n",
        "            FadeOut(new_line_of_sight, time_span=(0, 0.5)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-61, 78, 0).move_to([0.7, 0.05, -0.69]).set_height(9.68),\n",
        "            FadeIn(randy),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                line_of_sight, plane, rod, ball, x_label\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        # Show multiple waves\n",
        "        n_waves = 11\n",
        "        amp = 0.03\n",
        "        zs = np.linspace(0.5 - amp, -0.5 + amp, n_waves)\n",
        "        small_wave_config = dict(self.wave_config)\n",
        "        small_wave_config[\"z_amplitude\"] = amp\n",
        "\n",
        "        waves = VGroup(*(\n",
        "            OscillatingWave(\n",
        "                axes,\n",
        "                offset=axes.c2p(0, 0, z)[2] * OUT,\n",
        "                **small_wave_config\n",
        "            )\n",
        "            for z in zs\n",
        "        ))\n",
        "\n",
        "        self.remove(ribbon)\n",
        "        self.play(\n",
        "            FadeOut(wave),\n",
        "            VFadeIn(waves),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Focus on various x_slices\n",
        "        x_tracker.set_value(0)\n",
        "        rods = VGroup(*(\n",
        "            self.get_polarization_rod(\n",
        "                axes, lil_wave, x_tracker.get_value,\n",
        "                length_mult=1,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "            for lil_wave in waves\n",
        "        ))\n",
        "        balls = Group(*(\n",
        "            self.get_wave_ball(lil_wave, x_tracker.get_value, radius=0.025)\n",
        "            for lil_wave in waves\n",
        "        ))\n",
        "        sf = 1.2 * axes.z_axis.get_unit_size() / plane.get_height()\n",
        "        plane.scale(sf)\n",
        "        plane[0].scale(1.0 / sf)\n",
        "\n",
        "        plane.update()\n",
        "        x_label.update()\n",
        "        self.add(plane, rods, balls, cylinder, x_label)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-90, 83, 0).move_to([0.17, -0.37, -0.63]).set_height(7.35).set_anim_args(run_time=3),\n",
        "            FadeOut(light),\n",
        "            FadeOut(polarizer),\n",
        "            FadeIn(plane),\n",
        "            FadeIn(rods),\n",
        "            FadeIn(x_label),\n",
        "            waves.animate.set_stroke(width=0.5, opacity=0.5).set_anim_args(time_span=(1, 2), suspend_mobject_updating=False),\n",
        "            cylinder.animate.set_opacity(0.05).set_anim_args(time_span=(1, 2))\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-91, 90, 0).move_to([-0.01, -1.39, 0.21]).set_height(3.70),\n",
        "            x_tracker.animate.set_value(5).set_anim_args(rate_func=linear),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show lines of sight\n",
        "        lines_of_sight = VGroup(*(\n",
        "            self.get_line_of_sign(rod, randy, stroke_width=0.5)\n",
        "            for rod in rods\n",
        "        ))\n",
        "\n",
        "        self.play(ShowCreation(lines_of_sight[0]))\n",
        "        self.show_propagation(rods[0])\n",
        "        for line1, line2 in zip(lines_of_sight, lines_of_sight[1:]):\n",
        "            self.play(FadeOut(line1), FadeIn(line2), run_time=0.25)\n",
        "            self.wait(0.25)\n",
        "        self.wait(4)\n",
        "        self.play(FadeIn(lines_of_sight[:-1]))\n",
        "        self.add(lines_of_sight)\n",
        "\n",
        "        # Move closer and farther\n",
        "        self.play(\n",
        "            randy.animate.shift(3.5 * UP + 0.5 * IN),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(8)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-91, 89, 0).move_to([-0.05, -3.75, 0.07]).set_height(8.92),\n",
        "            randy.animate.shift(10 * DOWN),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "    def show_propagation(self, rod, run_time=10):\n",
        "        rings = ProbagatingRings(rod, start_width=5)\n",
        "        self.add(rings)\n",
        "        self.wait(run_time)\n",
        "        self.play(VFadeOut(rings))\n",
        "\n",
        "    def get_observer(self, location=ORIGIN):\n",
        "        randy = Randolph(mode=\"pondering\")\n",
        "        randy.look(RIGHT)\n",
        "        randy.rotate(PI / 2, RIGHT)\n",
        "        randy.rotate(PI / 2, OUT)\n",
        "        randy.move_to(location)\n",
        "        return randy\n",
        "\n",
        "    def get_line_of_sign(self, rod, observer, stroke_color=WHITE, stroke_width=1):\n",
        "        line = Line(ORIGIN, 5 * RIGHT)\n",
        "        line.set_stroke(stroke_color, stroke_width)\n",
        "        line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            observer.eyes.get_top(), rod.get_center()\n",
        "        ))\n",
        "        line.set_flat_stroke(False)\n",
        "        return line\n",
        "\n",
        "\n",
        "class VectorFieldWigglingNew(InteractiveScene):\n",
        "    default_frame_orientation = (-33, 85)\n",
        "\n",
        "    def construct(self):\n",
        "        # Waves\n",
        "        axes, plane = get_axes_and_plane()\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            wave_len=3.0,\n",
        "            speed=1.5,\n",
        "            color=BLUE,\n",
        "            z_amplitude=0.5,\n",
        "        )\n",
        "        vector_wave = OscillatingFieldWave(axes, wave)\n",
        "        wave_opacity_tracker = ValueTracker(0)\n",
        "        vector_opacity_tracker = ValueTracker(1)\n",
        "        wave.add_updater(lambda m: m.set_stroke(opacity=wave_opacity_tracker.get_value()))\n",
        "        vector_wave.add_updater(lambda m: m.set_stroke(opacity=vector_opacity_tracker.get_value()))\n",
        "\n",
        "        self.add(wave, vector_wave)\n",
        "\n",
        "        # Charges\n",
        "        charges = DotCloud(color=RED)\n",
        "        charges.to_grid(50, 50)\n",
        "        charges.set_radius(0.04)\n",
        "        charges.set_height(2 * axes.z_axis.get_length())\n",
        "        charges.rotate(PI / 2, RIGHT).rotate(PI / 2, IN)\n",
        "        charges.move_to(axes.c2p(-10, 0, 0))\n",
        "        charges.make_3d()\n",
        "\n",
        "        charge_opacity_tracker = ValueTracker(1)\n",
        "        charges.add_updater(lambda m: m.set_opacity(charge_opacity_tracker.get_value()))\n",
        "        charges.add_updater(lambda m: m.set_z(0.3 * wave.xt_to_point(0, self.time)[2]))\n",
        "\n",
        "        self.add(charges, wave, vector_wave)\n",
        "\n",
        "        # Pan camera\n",
        "        self.frame.reorient(47, 69, 0).move_to([-8.68, -7.06, 2.29]).set_height(5.44)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-33, 83, 0).move_to([-0.75, -1.84, 0.38]).set_height(8.00),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-27, 80, 0).move_to([-0.09, -0.42, -0.1]).set_height(9.03),\n",
        "            wave_opacity_tracker.animate.set_value(1).set_anim_args(time_span=(1, 2)),\n",
        "            vector_opacity_tracker.animate.set_value(0.5).set_anim_args(time_span=(1, 2)),\n",
        "            run_time=4,\n",
        "        )\n",
        "\n",
        "        # Highlight x_axis\n",
        "        x_line = Line(*axes.x_axis.get_start_and_end())\n",
        "        x_line.set_stroke(BLUE, 10)\n",
        "\n",
        "        self.play(\n",
        "            wave_opacity_tracker.animate.set_value(0.25),\n",
        "            vector_opacity_tracker.animate.set_value(0.25),\n",
        "            charge_opacity_tracker.animate.set_value(0.25),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(x_line, run_time=2),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show 3d wave\n",
        "        wave_3d = VGroup()\n",
        "        origin = axes.get_origin()\n",
        "        for y in np.linspace(-1, 1, 5):\n",
        "            for z in np.linspace(-1, 1, 5):\n",
        "                vects = OscillatingFieldWave(\n",
        "                    axes, wave,\n",
        "                    max_vect_len=0.5,\n",
        "                    norm_to_opacity_func=lambda n: 0.75 * np.arctan(n),\n",
        "                )\n",
        "                vects.y = y\n",
        "                vects.z = z\n",
        "                vects.add_updater(lambda m: m.shift(axes.c2p(0, m.y, m.z) - origin))\n",
        "                wave_3d.add(vects)\n",
        "\n",
        "        self.wait(2)\n",
        "        wave_opacity_tracker.set_value(0)\n",
        "        self.remove(vector_wave)\n",
        "        self.remove(x_line)\n",
        "        self.add(wave_3d)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(22, 69, 0).move_to([0.41, -0.67, -0.1]).set_height(10.31),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-48, 68, 0).move_to([0.41, -0.67, -0.1]),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "\n",
        "class ClockwiseCircularLight(InteractiveScene):\n",
        "    clockwise = True\n",
        "    default_frame_orientation = (-20, 70)\n",
        "    color = YELLOW\n",
        "    x_range = (0, 24)\n",
        "    amplitude = 0.5\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        # Axes\n",
        "        axes, plane = get_axes_and_plane(x_range=self.x_range)\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        # Wave\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            wave_len=3,\n",
        "            speed=0.5,\n",
        "            z_amplitude=self.amplitude,\n",
        "            y_amplitude=self.amplitude,\n",
        "            y_phase=-PI / 2 if self.clockwise else PI / 2,\n",
        "            color=self.color,\n",
        "        )\n",
        "        vect_wave = OscillatingFieldWave(axes, wave)\n",
        "        vect_wave.set_stroke(opacity=0.7)\n",
        "\n",
        "        self.add(wave, vect_wave)\n",
        "\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(73, 82, 0),\n",
        "            run_time=5\n",
        "        )\n",
        "        for pair in [(100, 70), (59, 72), (110, 65), (60, 80)]:\n",
        "            self.play(\n",
        "                self.frame.animate.reorient(*pair),\n",
        "                run_time=12,\n",
        "            )\n",
        "\n",
        "\n",
        "class CounterclockwiseCircularLight(ClockwiseCircularLight):\n",
        "    clockwise = False\n",
        "    color = RED\n",
        "\n",
        "\n",
        "class AltClockwiseCircularLight(ClockwiseCircularLight):\n",
        "    x_range = (0, 8)\n",
        "    amplitude = 0.4\n",
        "\n",
        "    def construct(self):\n",
        "        self.frame.reorient(69, 81, 0)\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class AltCounterclockwiseCircularLight(CounterclockwiseCircularLight):\n",
        "    x_range = (0, 8)\n",
        "    amplitude = 0.4\n",
        "\n",
        "    def construct(self):\n",
        "        self.frame.reorient(69, 81, 0)\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class TransitionTo2D(InteractiveScene):\n",
        "    default_frame_orientation = (-20, 70)\n",
        "    wave_config = dict(\n",
        "        color=BLUE,\n",
        "        wave_len=3,\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes, plane = get_axes_and_plane(x_range=(0, 8.01))\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        # Waves\n",
        "        wave = OscillatingWave(axes, **self.wave_config)\n",
        "        vect_wave = OscillatingFieldWave(axes, wave)\n",
        "        wave_opacity_tracker = ValueTracker(1)\n",
        "        wave.add_updater(lambda m: m.set_stroke(opacity=wave_opacity_tracker.get_value()))\n",
        "        vect_wave.add_updater(lambda m: m.set_stroke(opacity=wave_opacity_tracker.get_value()))\n",
        "\n",
        "        single_vect = Vector(OUT, stroke_color=wave.get_color(), stroke_width=4)\n",
        "        single_vect.set_flat_stroke(False)\n",
        "\n",
        "        def update_vect(vect):\n",
        "            x_max = axes.x_axis.x_max\n",
        "            base = axes.c2p(x_max, 0, 0)\n",
        "            vect.put_start_and_end_on(base, base + wave.xt_to_point(x_max, wave.time) * [0, 1, 1])\n",
        "\n",
        "        single_vect.add_updater(update_vect)\n",
        "\n",
        "        self.add(wave, vect_wave)\n",
        "\n",
        "        # Shift perspective\n",
        "        self.frame.reorient(69, 81, 0)\n",
        "        wave_opacity_tracker.set_value(0.8)\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(73, 84, 0),\n",
        "            VFadeIn(single_vect, time_span=(2, 3)),\n",
        "            wave_opacity_tracker.animate.set_value(0.35).set_anim_args(time_span=(2, 3)),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(90, 90, 0),\n",
        "            wave_opacity_tracker.animate.set_value(0),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TransitionTo2DRightHanded(TransitionTo2D):\n",
        "    wave_config = dict(\n",
        "        wave_len=3,\n",
        "        y_amplitude=0.5,\n",
        "        z_amplitude=0.5,\n",
        "        y_phase=PI / 2,\n",
        "        color=RED,\n",
        "    )\n",
        "\n",
        "\n",
        "class TransitionTo2DLeftHanded(TransitionTo2D):\n",
        "    wave_config = dict(\n",
        "        wave_len=3,\n",
        "        y_amplitude=0.5,\n",
        "        z_amplitude=0.5,\n",
        "        y_phase=-PI / 2,\n",
        "        color=YELLOW,\n",
        "    )\n",
        "\n",
        "\n",
        "class LinearAsASuperpositionOfCircular(InteractiveScene):\n",
        "    rotation_rate = 0.25\n",
        "    amplitude = 2.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up planes\n",
        "        plane_config = dict(\n",
        "            background_line_style=dict(stroke_color=GREY, stroke_width=1),\n",
        "            faded_line_style=dict(stroke_color=GREY, stroke_width=0.5, stroke_opacity=0.5),\n",
        "        )\n",
        "        planes = VGroup(\n",
        "            ComplexPlane((-1, 1), (-1, 1), **plane_config),\n",
        "            ComplexPlane((-1, 1), (-1, 1), **plane_config),\n",
        "            ComplexPlane((-2, 2), (-2, 2), **plane_config),\n",
        "        )\n",
        "        planes[:2].arrange(DOWN, buff=2.0).set_height(FRAME_HEIGHT - 1.5).next_to(ORIGIN, LEFT, 1.0)\n",
        "        planes[2].set_height(6).next_to(ORIGIN, RIGHT, 1.0)\n",
        "        # planes.arrange(RIGHT, buff=1.5)\n",
        "        self.add(planes)\n",
        "\n",
        "        # Set up trackers\n",
        "        phase_trackers = ValueTracker(0).replicate(2)\n",
        "        phase1_tracker, phase2_tracker = phase_trackers\n",
        "\n",
        "        def update_phase(m, dt):\n",
        "            m.increment_value(TAU * self.rotation_rate * dt)\n",
        "\n",
        "        def slow_changer(m, dt):\n",
        "            m.increment_value(-0.5 * TAU * self.rotation_rate * dt)\n",
        "\n",
        "        for tracker in phase_trackers:\n",
        "            tracker.add_updater(update_phase)\n",
        "\n",
        "        self.add(*phase_trackers)\n",
        "\n",
        "        def get_z1():\n",
        "            return 0.5 * self.amplitude * np.exp((PI / 2 + phase1_tracker.get_value()) * 1j)\n",
        "\n",
        "        def get_z2():\n",
        "            return 0.5 * self.amplitude * np.exp((PI / 2 - phase2_tracker.get_value()) * 1j)\n",
        "\n",
        "        def get_sum():\n",
        "            return get_z1() + get_z2()\n",
        "\n",
        "        # Vectors\n",
        "        vects = VGroup(\n",
        "            self.get_vector(planes[0], get_z1, color=RED),\n",
        "            self.get_vector(planes[1], get_z2, color=YELLOW),\n",
        "            self.get_vector(planes[2], get_sum, color=BLUE),\n",
        "            self.get_vector(planes[2], get_z1, color=RED),\n",
        "            self.get_vector(planes[2], get_sum, get_base=get_z1, color=YELLOW),\n",
        "        )\n",
        "\n",
        "        self.add(*vects)\n",
        "\n",
        "        # Polarization line\n",
        "        pol_line = Line(UP, DOWN)\n",
        "        pol_line.set_stroke(YELLOW, 1)\n",
        "        pol_line.match_height(planes[2])\n",
        "        pol_line.move_to(planes[2])\n",
        "\n",
        "        def update_pol_line(line):\n",
        "            if abs(vects[2].get_length()) > 1e-3:\n",
        "                line.set_angle(vects[2].get_angle())\n",
        "                line.move_to(planes[2].n2p(0))\n",
        "            return line\n",
        "\n",
        "        pol_line.add_updater(update_pol_line)\n",
        "\n",
        "        self.add(pol_line, *planes, *vects)\n",
        "\n",
        "        # Write it as an equation\n",
        "        plus = Tex(\"+\", font_size=72)\n",
        "        equals = Tex(\"=\", font_size=72)\n",
        "        plus.move_to(planes[0:2])\n",
        "        # equals.move_to(planes[1:3])\n",
        "        equals.move_to(ORIGIN)\n",
        "\n",
        "        self.add(plus, equals)\n",
        "\n",
        "        # Slow down annotation\n",
        "        arcs = VGroup(\n",
        "            Arrow(LEFT, RIGHT, path_arc=-PI, stroke_width=2),\n",
        "            Arrow(RIGHT, LEFT, path_arc=-PI, stroke_width=2),\n",
        "        )\n",
        "        arcs.move_to(planes[0])\n",
        "        slow_word = Text(\"Slow down!\")\n",
        "        slow_word.next_to(planes[0], DOWN)\n",
        "        sucrose = Sucrose(height=1)\n",
        "        sucrose.balls.scale_radii(0.25)\n",
        "        sucrose.fade(0.5)\n",
        "        sucrose.move_to(planes[0])\n",
        "        slow_group = Group(slow_word, arcs, sucrose)\n",
        "\n",
        "        def slow_down():\n",
        "            self.play(FadeIn(slow_group, run_time=0.25))\n",
        "            phase1_tracker.add_updater(slow_changer)\n",
        "            self.wait(0.75)\n",
        "            phase1_tracker.remove_updater(slow_changer)\n",
        "            self.play(FadeOut(slow_group))\n",
        "\n",
        "        # Highlight constituent parts\n",
        "        back_rects = VGroup(*(BackgroundRectangle(plane) for plane in planes))\n",
        "        back_rects.set_fill(opacity=0.5)\n",
        "\n",
        "        self.wait(8)\n",
        "\n",
        "        self.add(back_rects[1])\n",
        "        VGroup(vects[1], vects[2], vects[4]).set_stroke(opacity=0.25)\n",
        "        self.wait(8)\n",
        "        self.remove(back_rects[1])\n",
        "\n",
        "        self.add(back_rects[0])\n",
        "        vects.set_stroke(opacity=1)\n",
        "        VGroup(vects[0], vects[2]).set_stroke(opacity=0.25)\n",
        "        self.wait(8)\n",
        "        vects.set_stroke(opacity=1)\n",
        "        self.remove(back_rects)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Rotation labels\n",
        "        for tracker in phase_trackers:\n",
        "            tracker.set_value(0)\n",
        "\n",
        "        rot_labels = VGroup(*(\n",
        "            TexText(\"Total rotation: 0.00\")\n",
        "            for _ in range(2)\n",
        "        ))\n",
        "        for rot_label, plane, tracker in zip(rot_labels, planes, phase_trackers):\n",
        "            rot_label.set_height(0.2)\n",
        "            rot_label.set_color(GREY_B)\n",
        "            rot_label.next_to(plane, UP)\n",
        "            dec = rot_label.make_number_changeable(\"0.00\", edge_to_fix=LEFT)\n",
        "            dec.phase_tracker = tracker\n",
        "            dec.add_updater(lambda m: m.set_value(m.phase_tracker.get_value() / TAU))\n",
        "\n",
        "        self.add(rot_labels)\n",
        "\n",
        "        # Let it play, occasionally kink\n",
        "        self.wait(9)\n",
        "        for _ in range(20):\n",
        "            slow_down()\n",
        "            self.wait(3 * random.random())\n",
        "\n",
        "    def get_vector(self, plane, get_z, get_base=lambda: 0, color=BLUE):\n",
        "        vect = Vector(UP, stroke_color=color)\n",
        "        vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.n2p(get_base()),\n",
        "            plane.n2p(get_z())\n",
        "        ))\n",
        "        return vect\n"
    ]
}