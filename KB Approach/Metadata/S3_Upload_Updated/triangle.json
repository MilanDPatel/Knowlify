{
    "topic": "The mathematical concept being demonstrated is the inverse of various mathematical operations, such as square roots, log",
    "code": [
        "import numbers\n",
        "from manim_imports_ext import *\n",
        "from functools import reduce\n",
        "\n",
        "OPERATION_COLORS = [YELLOW, GREEN, BLUE_B]\n",
        "\n",
        "def get_equation(index, x = 2, y = 3, z = 8, expression_only = False):\n",
        "    assert(index in [0, 1, 2])\n",
        "    if index == 0:\n",
        "        tex1 = \"\\\\sqrt[%d]{%d}\"%(y, z), \n",
        "        tex2 = \" = %d\"%x\n",
        "    elif index == 1:\n",
        "        tex1 = \"\\\\log_%d(%d)\"%(x, z), \n",
        "        tex2 = \" = %d\"%y\n",
        "    elif index == 2:\n",
        "        tex1 = \"%d^%d\"%(x, y), \n",
        "        tex2 = \" = %d\"%z\n",
        "    if expression_only:\n",
        "        tex = tex1\n",
        "    else:\n",
        "        tex = tex1+tex2\n",
        "    return OldTex(tex).set_color(OPERATION_COLORS[index])\n",
        "\n",
        "def get_inverse_rules():\n",
        "    return list(map(Tex, [\n",
        "        \"x^{\\\\log_x(z)} = z\",\n",
        "        \"\\\\log_x\\\\left(x^y \\\\right) = y\",\n",
        "        \"\\\\sqrt[y]{x^y} = x\",\n",
        "        \"\\\\left(\\\\sqrt[y]{z}\\\\right)^y = z\",\n",
        "        \"\\\\sqrt[\\\\log_x(z)]{z} = x\",\n",
        "        \"\\\\log_{\\\\sqrt[y]{z}}(z) = y\",\n",
        "    ]))\n",
        "\n",
        "def get_top_inverse_rules():\n",
        "    result = []\n",
        "    pairs = [#Careful of order here!\n",
        "        (0, 2),\n",
        "        (0, 1),\n",
        "        (1, 0),\n",
        "        (1, 2),\n",
        "        (2, 0),\n",
        "        (2, 1),\n",
        "    ]\n",
        "    for i, j in pairs:\n",
        "        top = get_top_inverse(i, j)\n",
        "        char = [\"x\", \"y\", \"z\"][j]\n",
        "        eq = OldTex(\"= %s\"%char)\n",
        "        eq.scale(2)\n",
        "        eq.next_to(top, RIGHT)\n",
        "        diff = eq.get_center() - top.triangle.get_center()\n",
        "        eq.shift(diff[1]*UP)\n",
        "        result.append(VMobject(top, eq))\n",
        "    return result\n",
        "\n",
        "def get_top_inverse(i, j):\n",
        "    args = [None]*3\n",
        "    k = set([0, 1, 2]).difference([i, j]).pop()\n",
        "    args[i] = [\"x\", \"y\", \"z\"][i]\n",
        "    big_top = TOP(*args)\n",
        "    args[j] = [\"x\", \"y\", \"z\"][j]\n",
        "    lil_top = TOP(*args, triangle_height_to_number_height = 1.5)\n",
        "    big_top.set_value(k, lil_top)\n",
        "    return big_top\n",
        "\n",
        "class TOP(VMobject):\n",
        "    CONFIG = {\n",
        "        \"triangle_height_to_number_height\" : 3,\n",
        "        \"offset_multiple\" : 1.5,\n",
        "        \"radius\" : 1.5,\n",
        "    }\n",
        "    def __init__(self, x = None, y = None, z = None, **kwargs):\n",
        "        digest_config(self, kwargs, locals())\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "\n",
        "    def init_points(self):\n",
        "        vertices = [\n",
        "            self.radius*rotate_vector(RIGHT, 7*np.pi/6 - i*2*np.pi/3)\n",
        "            for i in range(3)\n",
        "        ]\n",
        "        self.triangle = Polygon(\n",
        "            *vertices, \n",
        "            color = WHITE,\n",
        "            stroke_width = 5\n",
        "        )\n",
        "        self.values = [VMobject()]*3\n",
        "        self.set_values(self.x, self.y, self.z)\n",
        "\n",
        "    def set_values(self, x, y, z):\n",
        "        for i, mob in enumerate([x, y, z]):\n",
        "            self.set_value(i, mob)\n",
        "\n",
        "    def set_value(self, index, value):\n",
        "        self.values[index] = self.put_on_vertex(index, value)\n",
        "        self.reset_submobjects()\n",
        "\n",
        "    def put_on_vertex(self, index, value):\n",
        "        assert(index in [0, 1, 2])\n",
        "        if value is None:\n",
        "            value = VectorizedPoint()\n",
        "        if isinstance(value, numbers.Number):\n",
        "            value = str(value)\n",
        "        if isinstance(value, str):\n",
        "            value = OldTex(value)\n",
        "        if isinstance(value, TOP):\n",
        "            return self.put_top_on_vertix(index, value)\n",
        "        self.rescale_corner_mobject(value)\n",
        "        value.center()\n",
        "        if index == 0:\n",
        "            offset = -value.get_corner(UP+RIGHT)\n",
        "        elif index == 1:\n",
        "            offset = -value.get_bottom()\n",
        "        elif index == 2:\n",
        "            offset = -value.get_corner(UP+LEFT)\n",
        "        value.shift(self.offset_multiple*offset)\n",
        "        anchors = self.triangle.get_anchors_and_handles()[0]\n",
        "        value.shift(anchors[index])\n",
        "        return value\n",
        "\n",
        "    def put_top_on_vertix(self, index, top):\n",
        "        top.set_height(2*self.get_value_height())\n",
        "        vertices = np.array(top.get_vertices())\n",
        "        vertices[index] = 0\n",
        "        start = reduce(op.add, vertices)/2\n",
        "        end = self.triangle.get_anchors_and_handles()[0][index]\n",
        "        top.shift(end-start)\n",
        "        return top\n",
        "\n",
        "    def put_in_vertex(self, index, mobject):\n",
        "        self.rescale_corner_mobject(mobject)\n",
        "        mobject.center()\n",
        "        mobject.shift(interpolate(\n",
        "            self.get_center(),\n",
        "            self.get_vertices()[index],\n",
        "            0.7\n",
        "        ))\n",
        "        return mobject\n",
        "\n",
        "\n",
        "    def get_surrounding_circle(self, color = YELLOW):\n",
        "        return Circle(\n",
        "            radius = 1.7*self.radius,\n",
        "            color = color\n",
        "        ).shift(\n",
        "            self.triangle.get_center(),\n",
        "            (self.triangle.get_height()/6)*DOWN\n",
        "        )\n",
        "\n",
        "    def rescale_corner_mobject(self, mobject):\n",
        "        mobject.set_height(self.get_value_height())\n",
        "        return self\n",
        "\n",
        "    def get_value_height(self):\n",
        "        return self.triangle.get_height()/self.triangle_height_to_number_height\n",
        "\n",
        "    def get_center(self):\n",
        "        return center_of_mass(self.get_vertices())\n",
        "\n",
        "    def get_vertices(self):\n",
        "        return self.triangle.get_anchors_and_handles()[0][:3]\n",
        "\n",
        "    def reset_submobjects(self):\n",
        "        self.submobjects = [self.triangle] + self.values\n",
        "        return self\n",
        "\n",
        "\n",
        "class IntroduceNotation(Scene):\n",
        "    def construct(self):\n",
        "        top = TOP()\n",
        "        equation = OldTex(\"2^3 = 8\")\n",
        "        equation.to_corner(UP+LEFT)\n",
        "        two, three, eight = [\n",
        "            top.put_on_vertex(i, num)\n",
        "            for i, num in enumerate([2, 3, 8])\n",
        "        ]\n",
        "\n",
        "        self.play(FadeIn(equation))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(top))\n",
        "        for num in two, three, eight:\n",
        "            self.play(ShowCreation(num), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "class ShowRule(Scene):\n",
        "    args_list = [(0,), (1,), (2,)]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(index):\n",
        "        return str(index)\n",
        "        \n",
        "    @staticmethod\n",
        "    def string_to_args(index_string):\n",
        "        result =  int(index_string)\n",
        "        assert(result in [0, 1, 2])\n",
        "        return result\n",
        "\n",
        "    def construct(self, index):\n",
        "        equation = get_equation(index)\n",
        "        equation.to_corner(UP+LEFT)\n",
        "        top = TOP(2, 3, 8)\n",
        "        new_top = top.copy()\n",
        "        equals = OldTex(\"=\").scale(1.5)\n",
        "        new_top.next_to(equals, LEFT, buff = 1)\n",
        "        new_top.values[index].next_to(equals, RIGHT, buff = 1)\n",
        "        circle = Circle(\n",
        "            radius = 1.7*top.radius, \n",
        "            color = OPERATION_COLORS[index]\n",
        "        )\n",
        "        \n",
        "\n",
        "        self.add(equation, top)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(top, new_top),\n",
        "            ShowCreation(equals)\n",
        "        )\n",
        "\n",
        "        circle.shift(new_top.triangle.get_center_of_mass())\n",
        "        new_circle = circle.copy()\n",
        "        new_top.put_on_vertex(index, new_circle)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(circle, new_circle),\n",
        "            ApplyMethod(new_top.values[index].set_color, circle.color)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AllThree(Scene):\n",
        "    def construct(self):\n",
        "        tops = []\n",
        "        equations = []\n",
        "        args = (2, 3, 8)\n",
        "        for i in 2, 1, 0:\n",
        "            new_args = list(args)\n",
        "            new_args[i] = None\n",
        "            top = TOP(*new_args, triangle_height_to_number_height = 2)\n",
        "            # top.set_color(OPERATION_COLORS[i])\n",
        "            top.shift(i*4.5*LEFT)\n",
        "            equation = get_equation(i, expression_only = True)\n",
        "            equation.scale(3)\n",
        "            equation.next_to(top, DOWN, buff = 0.7)\n",
        "            tops.append(top)\n",
        "            equations.append(equation)\n",
        "        VMobject(*tops+equations).center()\n",
        "        # name = OldTexText(\"Triangle of Power\")\n",
        "        # name.to_edge(UP)\n",
        "\n",
        "        for top, eq in zip(tops, equations):\n",
        "            self.play(FadeIn(top), FadeIn(eq))\n",
        "        self.wait(3)\n",
        "        # self.play(Write(name))\n",
        "        self.wait()\n",
        "\n",
        "class SixDifferentInverses(Scene):\n",
        "    def construct(self):\n",
        "        rules = get_inverse_rules()\n",
        "        vects = it.starmap(op.add, it.product(\n",
        "            [3*UP, 0.5*UP, 2*DOWN], [2*LEFT, 2*RIGHT]\n",
        "        ))\n",
        "        for rule, vect in zip(rules, vects):\n",
        "            rule.shift(vect)\n",
        "        general_idea = OldTex(\"f(f^{-1}(a)) = a\")\n",
        "\n",
        "        self.play(Write(VMobject(*rules)))\n",
        "        self.wait()\n",
        "        for s, color in (rules[:4], GREEN), (rules[4:], RED):\n",
        "            mob = VMobject(*s)\n",
        "            self.play(ApplyMethod(mob.set_color, color))\n",
        "            self.wait()\n",
        "            self.play(ApplyMethod(mob.set_color, WHITE))\n",
        "        self.play(\n",
        "            ApplyMethod(VMobject(*rules[::2]).to_edge, LEFT),\n",
        "            ApplyMethod(VMobject(*rules[1::2]).to_edge, RIGHT),\n",
        "            GrowFromCenter(general_idea)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        top_rules = get_top_inverse_rules()\n",
        "        for rule, top_rule in zip(rules, top_rules):\n",
        "            top_rule.set_height(1.5)\n",
        "            top_rule.center()\n",
        "            top_rule.shift(rule.get_center())\n",
        "        self.play(*list(map(FadeOut, rules)))\n",
        "        self.remove(*rules)\n",
        "        self.play(*list(map(GrowFromCenter, top_rules)))\n",
        "        self.wait()\n",
        "        self.remove(general_idea)\n",
        "        rules = get_inverse_rules()\n",
        "        original = None\n",
        "        for i, (top_rule, rule) in enumerate(zip(top_rules, rules)):\n",
        "            rule.center().to_edge(UP)\n",
        "            rule.set_color(GREEN if i < 4 else RED)\n",
        "            self.add(rule)\n",
        "            new_top_rule = top_rule.copy().center().scale(1.5)\n",
        "            anims = [Transform(top_rule, new_top_rule)]\n",
        "            if original is not None:\n",
        "                anims.append(FadeIn(original))\n",
        "            original = top_rule.copy()\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            self.animate_top_rule(top_rule)\n",
        "            self.remove(rule)\n",
        "\n",
        "    def animate_top_rule(self, top_rule):\n",
        "        lil_top, lil_symbol, symbol_index = None, None, None\n",
        "        big_top = top_rule.submobjects[0]\n",
        "        equals, right_symbol = top_rule.submobjects[1].split()\n",
        "        for i, value in enumerate(big_top.values):\n",
        "            if isinstance(value, TOP):\n",
        "                lil_top = value\n",
        "            elif isinstance(value, Tex):\n",
        "                symbol_index = i\n",
        "            else: \n",
        "                lil_symbol_index = i\n",
        "        lil_symbol = lil_top.values[lil_symbol_index]\n",
        "                \n",
        "        assert(lil_top is not None and lil_symbol is not None)\n",
        "        cancel_parts = [\n",
        "            VMobject(top.triangle, top.values[symbol_index])\n",
        "            for top in (lil_top, big_top)\n",
        "        ]\n",
        "        new_symbol = lil_symbol.copy()\n",
        "        new_symbol.replace(right_symbol)\n",
        "        vect = equals.get_center() - right_symbol.get_center()\n",
        "        new_symbol.shift(2*vect[0]*RIGHT)\n",
        "        self.play(\n",
        "            Transform(*cancel_parts, rate_func = rush_into)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(VMobject(*cancel_parts)),\n",
        "            Transform(lil_symbol, new_symbol, rate_func = rush_from)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(lil_symbol, top_rule, VMobject(*cancel_parts))\n",
        "\n",
        "\n",
        "class SixSixSix(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(mode = \"pondering\").to_corner()\n",
        "        bubble = ThoughtBubble().pin_to(randy)\n",
        "        rules = get_inverse_rules()\n",
        "        sixes = OldTex([\"6\", \"6\", \"6\"], next_to_buff = 1)\n",
        "        sixes.to_corner(UP+RIGHT)\n",
        "        sixes = sixes.split()\n",
        "        speech_bubble = SpeechBubble()\n",
        "        speech_bubble.pin_to(randy)\n",
        "        speech_bubble.write(\"I'll just study art!\")\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(ShowCreation(bubble))\n",
        "        bubble.add_content(VectorizedPoint())\n",
        "        for i, rule in enumerate(rules):\n",
        "            if i%2 == 0:\n",
        "                anim = ShowCreation(sixes[i/2])\n",
        "            else:\n",
        "                anim = Blink(randy)\n",
        "            self.play(\n",
        "                ApplyMethod(bubble.add_content, rule),\n",
        "                anim\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        words = speech_bubble.content\n",
        "        equation = bubble.content\n",
        "        speech_bubble.clear()\n",
        "        bubble.clear()\n",
        "        self.play(\n",
        "            ApplyMethod(randy.change_mode, \"angry\"),\n",
        "            Transform(bubble, speech_bubble),\n",
        "            Transform(equation, words),\n",
        "            FadeOut(VMobject(*sixes))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AdditiveProperty(Scene):\n",
        "    def construct(self):\n",
        "        exp_rule, log_rule = self.write_old_style_rules()\n",
        "        t_exp_rule, t_log_rule = self.get_new_style_rules()\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(exp_rule.to_edge, UP),\n",
        "            ApplyMethod(log_rule.to_edge, DOWN, 1.5)\n",
        "        )\n",
        "        t_exp_rule.next_to(exp_rule, DOWN)\n",
        "        t_exp_rule.set_color(GREEN)\n",
        "        t_log_rule.next_to(log_rule, UP)\n",
        "        t_log_rule.set_color(RED)\n",
        "        self.play(\n",
        "            FadeIn(t_exp_rule),\n",
        "            FadeIn(t_log_rule),\n",
        "            ApplyMethod(exp_rule.set_color, GREEN),\n",
        "            ApplyMethod(log_rule.set_color, RED),\n",
        "        )\n",
        "        self.wait()\n",
        "        all_tops = [m for m in t_exp_rule.split()+t_log_rule.split() if isinstance(m, TOP)]\n",
        "        self.put_in_circles(all_tops)\n",
        "        self.set_color_appropriate_parts(t_exp_rule, t_log_rule)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def write_old_style_rules(self):\n",
        "        start = OldTex(\"a^x a^y = a^{x+y}\")\n",
        "        end = OldTex(\"\\\\log_a(xy) = \\\\log_a(x) + \\\\log_a(y)\")\n",
        "        start.shift(UP)\n",
        "        end.shift(DOWN)\n",
        "        a1, x1, a2, y1, eq1, a3, p1, x2, y2 = start.split()\n",
        "        a4, x3, y3, eq2, a5, x4, p2, a6, y4 = np.array(end.split())[\n",
        "            [3, 5, 6, 8, 12, 14, 16, 20, 22]\n",
        "        ]\n",
        "        start_copy = start.copy()\n",
        "        self.play(Write(start_copy))\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            VMobject(a1, x1, a2, y1, eq1, a3, p1, x2, a3.copy(), y2),\n",
        "            VMobject(a4, x3, a4.copy(), y3, eq2, a5, p2, x4, a6, y4)\n",
        "        ))\n",
        "        self.play(Write(end))\n",
        "        self.clear()\n",
        "        self.add(start_copy, end)\n",
        "        self.wait()\n",
        "        return start_copy, end\n",
        "\n",
        "    def get_new_style_rules(self):\n",
        "        upper_mobs = [\n",
        "            TOP(\"a\", \"x\", \"R\"), Dot(), \n",
        "            TOP(\"a\", \"y\", \"R\"), OldTex(\"=\"), \n",
        "            TOP(\"a\", \"x+y\")\n",
        "        ]\n",
        "        lower_mobs = [\n",
        "            TOP(\"a\", None, \"xy\"), OldTex(\"=\"),\n",
        "            TOP(\"a\", None, \"x\"), OldTex(\"+\"),\n",
        "            TOP(\"a\", None, \"y\"),\n",
        "        ]\n",
        "        for mob in upper_mobs + lower_mobs:\n",
        "            if isinstance(mob, TOP):\n",
        "                mob.scale(0.5)\n",
        "        for group in upper_mobs, lower_mobs:\n",
        "            for m1, m2 in zip(group, group[1:]):\n",
        "                m2.next_to(m1)\n",
        "        for top in upper_mobs[0], upper_mobs[2]:\n",
        "            top.set_value(2, None)\n",
        "        upper_mobs = VMobject(*upper_mobs).center().shift(2*UP)\n",
        "        lower_mobs = VMobject(*lower_mobs).center().shift(2*DOWN)\n",
        "        return upper_mobs, lower_mobs\n",
        "\n",
        "    def put_in_circles(self, tops):\n",
        "        anims = []\n",
        "        for top in tops:\n",
        "            for i, value in enumerate(top.values):\n",
        "                if isinstance(value, VectorizedPoint):\n",
        "                    index = i\n",
        "            circle = top.put_on_vertex(index, Circle(color = WHITE))\n",
        "            anims.append(\n",
        "                Transform(top.copy().set_color(YELLOW), circle)\n",
        "            )\n",
        "        self.add(*[anim.mobject for anim in anims])\n",
        "        self.wait()\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def set_color_appropriate_parts(self, t_exp_rule, t_log_rule):\n",
        "        #Horribly hacky\n",
        "        circle1 = t_exp_rule.split()[0].put_on_vertex(\n",
        "            2, Circle()\n",
        "        )\n",
        "        top_dot = t_exp_rule.split()[1]\n",
        "        circle2 = t_exp_rule.split()[2].put_on_vertex(\n",
        "            2, Circle()\n",
        "        )\n",
        "        top_plus = t_exp_rule.split()[4].values[1]\n",
        "\n",
        "        bottom_times = t_log_rule.split()[0].values[2]\n",
        "        circle3 = t_log_rule.split()[2].put_on_vertex(\n",
        "            1, Circle()\n",
        "        )\n",
        "        bottom_plus = t_log_rule.split()[3]\n",
        "        circle4 = t_log_rule.split()[4].put_on_vertex(\n",
        "            1, Circle()\n",
        "        )\n",
        "\n",
        "        mob_lists = [\n",
        "            [circle1, top_dot, circle2],\n",
        "            [top_plus],\n",
        "            [bottom_times],\n",
        "            [circle3, bottom_plus, circle4]\n",
        "        ]\n",
        "        for mobs in mob_lists:\n",
        "            copies = VMobject(*mobs).copy()\n",
        "            self.play(ApplyMethod(\n",
        "                copies.set_color, YELLOW, \n",
        "                run_time = 0.5\n",
        "            ))\n",
        "            self.play(ApplyMethod(\n",
        "                copies.scale, 1.2,\n",
        "                rate_func = there_and_back\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.remove(copies)\n",
        "\n",
        "\n",
        "class DrawInsideTriangle(Scene):\n",
        "    def construct(self):\n",
        "        top = TOP()\n",
        "        top.scale(2)\n",
        "        dot = top.put_in_vertex(0, Dot())\n",
        "        plus = top.put_in_vertex(1, OldTex(\"+\"))\n",
        "        times = top.put_in_vertex(2, OldTex(\"\\\\times\"))\n",
        "        plus.set_color(GREEN)\n",
        "        times.set_color(YELLOW)\n",
        "\n",
        "        self.add(top)\n",
        "        self.wait()\n",
        "        for mob in dot, plus, times:\n",
        "            self.play(Write(mob, run_time = 1))\n",
        "            self.wait()\n",
        "\n",
        "class ConstantOnTop(Scene):\n",
        "    def construct(self):\n",
        "        top = TOP()\n",
        "        dot = top.put_in_vertex(1, Dot())\n",
        "        times1 = top.put_in_vertex(0, OldTex(\"\\\\times\"))\n",
        "        times2 = top.put_in_vertex(2, OldTex(\"\\\\times\"))\n",
        "        times1.set_color(YELLOW)\n",
        "        times2.set_color(YELLOW)\n",
        "        three = top.put_on_vertex(1, \"3\")\n",
        "        lower_left_x = top.put_on_vertex(0, \"x\")\n",
        "        lower_right_x = top.put_on_vertex(2, \"x\")\n",
        "        x_cubed = OldTex(\"x^3\").to_edge(UP)\n",
        "        x_cubed.submobjects.reverse() #To align better        \n",
        "        cube_root_x = OldTex(\"\\\\sqrt[3]{x}\").to_edge(UP)\n",
        "\n",
        "        self.add(top)\n",
        "        self.play(ShowCreation(three))\n",
        "        self.play(\n",
        "            FadeIn(lower_left_x),\n",
        "            Write(x_cubed),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair, path_arc = np.pi)\n",
        "            for pair in [\n",
        "                (lower_left_x, lower_right_x),\n",
        "                (x_cubed, cube_root_x),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        for mob in dot, times1, times2:\n",
        "            self.play(ShowCreation(mob))\n",
        "            self.wait()\n",
        "\n",
        "def get_const_top_TOP(*args):\n",
        "        top = TOP(*args)\n",
        "        dot = top.put_in_vertex(1, Dot())\n",
        "        times1 = top.put_in_vertex(0, OldTex(\"\\\\times\"))\n",
        "        times2 = top.put_in_vertex(2, OldTex(\"\\\\times\"))\n",
        "        times1.set_color(YELLOW)\n",
        "        times2.set_color(YELLOW)\n",
        "        top.add(dot, times1, times2)\n",
        "        return top\n",
        "\n",
        "\n",
        "class MultiplyWithConstantTop(Scene):\n",
        "    def construct(self):\n",
        "        top1 = get_const_top_TOP(\"x\", \"3\")\n",
        "        top2 = get_const_top_TOP(\"y\", \"3\")\n",
        "        top3 = get_const_top_TOP(\"xy\", \"3\")\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        equals = OldTex(\"=\")\n",
        "        top_exp_equation = VMobject(\n",
        "            top1, times, top2, equals, top3\n",
        "        )\n",
        "        top_exp_equation.arrange()\n",
        "        old_style_exp = OldTex(\"(x^3)(y^3) = (xy)^3\")\n",
        "        old_style_exp.to_edge(UP)\n",
        "        old_style_exp.set_color(GREEN)\n",
        "        old_style_rad = OldTex(\"\\\\sqrt[3]{x} \\\\sqrt[3]{y} = \\\\sqrt[3]{xy}\")\n",
        "        old_style_rad.to_edge(UP)\n",
        "        old_style_rad.set_color(RED)\n",
        "\n",
        "        self.add(top_exp_equation, old_style_exp)\n",
        "        self.wait(3)\n",
        "\n",
        "        old_tops = [top1, top2, top3]\n",
        "        new_tops = []\n",
        "        for top in old_tops:\n",
        "            new_top = top.copy()\n",
        "            new_top.put_on_vertex(2, new_top.values[0])\n",
        "            new_top.shift(0.5*LEFT)\n",
        "            new_tops.append(new_top)\n",
        "        self.play(\n",
        "            Transform(old_style_exp, old_style_rad),\n",
        "            Transform(\n",
        "                VMobject(*old_tops),\n",
        "                VMobject(*new_tops),\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class RightStaysConstantQ(Scene):\n",
        "    def construct(self):\n",
        "        top1, top2, top3 = old_tops = [\n",
        "            TOP(None, s, \"8\")\n",
        "            for s in (\"x\", \"y\", OldTex(\"x?y\"))\n",
        "        ]\n",
        "        q_mark = OldTex(\"?\").scale(2)\n",
        "        equation = VMobject(\n",
        "            top1, q_mark, top2, OldTex(\"=\"), top3\n",
        "        )\n",
        "        equation.arrange(buff = 0.7)\n",
        "        symbols_at_top = VMobject(*[\n",
        "            top.values[1]\n",
        "            for top in (top1, top2, top3)\n",
        "        ])\n",
        "        symbols_at_lower_right = VMobject(*[\n",
        "            top.put_on_vertex(0, top.values[1].copy())\n",
        "            for top in (top1, top2, top3)\n",
        "        ])\n",
        "        old_style_eq1 = OldTex(\"\\\\sqrt[x]{8} ? \\\\sqrt[y]{8} = \\\\sqrt[x?y]{8}\")\n",
        "        old_style_eq1.set_color(BLUE)\n",
        "        old_style_eq2 = OldTex(\"\\\\log_x(8) ? \\\\log_y(8) = \\\\log_{x?y}(8)\")\n",
        "        old_style_eq2.set_color(YELLOW)\n",
        "        for eq in old_style_eq1, old_style_eq2:\n",
        "            eq.to_edge(UP)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner()\n",
        "        bubble = ThoughtBubble().pin_to(randy)\n",
        "        bubble.add_content(TOP(None, None, \"8\"))\n",
        "\n",
        "        self.add(randy, bubble)\n",
        "        self.play(ApplyMethod(randy.change_mode, \"pondering\"))\n",
        "        self.wait(3)\n",
        "        triangle = bubble.content.triangle\n",
        "        eight = bubble.content.values[2]\n",
        "        bubble.clear()\n",
        "        self.play(\n",
        "            Transform(triangle, equation),\n",
        "            FadeOut(eight),\n",
        "            ApplyPointwiseFunction(\n",
        "                lambda p : (p+2*DOWN)*15/get_norm(p+2*DOWN),\n",
        "                bubble\n",
        "            ),\n",
        "            FadeIn(old_style_eq1),\n",
        "            ApplyMethod(randy.shift, 3*DOWN + 3*LEFT),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.remove(triangle)\n",
        "        self.add(equation)\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                symbols_at_top, symbols_at_lower_right, \n",
        "                path_arc = np.pi/2\n",
        "            ),\n",
        "            Transform(old_style_eq1, old_style_eq2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class AOplusB(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTex(\n",
        "            \"a \\\\oplus b = \\\\dfrac{1}{\\\\frac{1}{a} + \\\\frac{1}{b}}\"\n",
        "        ).scale(2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ConstantLowerRight(Scene):\n",
        "    def construct(self):\n",
        "        top = TOP()\n",
        "        times = top.put_in_vertex(0, OldTex(\"\\\\times\"))\n",
        "        times.set_color(YELLOW)\n",
        "        oplus = top.put_in_vertex(1, OldTex(\"\\\\oplus\"))\n",
        "        oplus.set_color(BLUE)\n",
        "        dot = top.put_in_vertex(2, Dot())\n",
        "        eight = top.put_on_vertex(2, OldTex(\"8\"))\n",
        "\n",
        "        self.add(top)\n",
        "        self.play(ShowCreation(eight))\n",
        "        for mob in dot, oplus, times:\n",
        "            self.play(ShowCreation(mob))\n",
        "            self.wait()\n",
        "\n",
        "        top.add(eight)\n",
        "        top.add(times, oplus, dot)\n",
        "        top1, top2, top3 = tops = [\n",
        "            top.copy() for i in range(3)\n",
        "        ]\n",
        "        big_oplus = OldTex(\"\\\\oplus\").scale(2).set_color(BLUE)\n",
        "        equals = OldTex(\"=\")\n",
        "        equation = VMobject(\n",
        "            top1, big_oplus, top2, equals, top3\n",
        "        )\n",
        "        equation.arrange()\n",
        "        top3.shift(0.5*RIGHT)\n",
        "        x, y, xy = [\n",
        "            t.put_on_vertex(0, s)\n",
        "            for t, s in zip(tops, [\"x\", \"y\", \"xy\"])\n",
        "        ]\n",
        "        old_style_eq = OldTex(\n",
        "            \"\\\\dfrac{1}{\\\\frac{1}{\\\\log_x(8)} + \\\\frac{1}{\\\\log_y(8)}} = \\\\log_{xy}(8)\"\n",
        "        )\n",
        "        old_style_eq.to_edge(UP).set_color(RED)\n",
        "\n",
        "        triple_top_copy = VMobject(*[\n",
        "            top.copy() for i in range(3)\n",
        "        ])\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            Transform(triple_top_copy, VMobject(*tops)),\n",
        "            FadeIn(VMobject(x, y, xy, big_oplus, equals))\n",
        "        )\n",
        "        self.remove(triple_top_copy)\n",
        "        self.add(*tops)\n",
        "        self.play(Write(old_style_eq))\n",
        "        self.wait(3)\n",
        "\n",
        "        syms = VMobject(x, y, xy)\n",
        "        new_syms = VMobject(*[\n",
        "            t.put_on_vertex(1, s)\n",
        "            for t, s in zip(tops, [\"x\", \"y\", \"x \\\\oplus y\"])\n",
        "        ])\n",
        "        new_old_style_eq = OldTex(\n",
        "            \"\\\\sqrt[x]{8} \\\\sqrt[y]{8} = \\\\sqrt[X]{8}\"\n",
        "        )\n",
        "        X = new_old_style_eq.split()[-4]\n",
        "        frac = OldTex(\"\\\\frac{1}{\\\\frac{1}{x} + \\\\frac{1}{y}}\")\n",
        "        frac.replace(X)\n",
        "        frac_lower_right = frac.get_corner(DOWN+RIGHT)\n",
        "        frac.scale(2)\n",
        "        frac.shift(frac_lower_right - frac.get_corner(DOWN+RIGHT))\n",
        "        new_old_style_eq.submobjects[-4] = frac\n",
        "        new_old_style_eq.to_edge(UP)\n",
        "        new_old_style_eq.set_color(RED)\n",
        "        big_times = OldTex(\"\\\\times\").set_color(YELLOW)\n",
        "        big_times.shift(big_oplus.get_center())\n",
        "        self.play(\n",
        "            Transform(old_style_eq, new_old_style_eq),\n",
        "            Transform(syms, new_syms, path_arc = np.pi/2),\n",
        "            Transform(big_oplus, big_times)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TowerExponentFrame(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Consider an expression like $3^{3^3}$.  It's \n",
        "            ambiguous whether this means $27^3$ or $3^{27}$,\n",
        "            which is the difference between $19{,}683$ and\n",
        "            $7{,}625{,}597{,}484{,}987$.  But with the triangle\n",
        "            of power, the difference is crystal clear:\n",
        "        \"\"\")\n",
        "        words.set_width(FRAME_WIDTH-1)\n",
        "        words.to_edge(UP)\n",
        "        top1 = TOP(TOP(3, 3), 3)\n",
        "        top2 = TOP(3, (TOP(3, 3)))\n",
        "        for top in top1, top2:\n",
        "            top.next_to(words, DOWN)\n",
        "        top1.shift(3*LEFT)\n",
        "        top2.shift(3*RIGHT)\n",
        "\n",
        "        self.add(words, top1, top2)\n",
        "        self.wait()        \n",
        "\n",
        "\n",
        "class ExponentialGrowth(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Let's say you are studying a certain growth rate, \n",
        "            and you come across an expression like $T^a$.  It\n",
        "            matters a lot whether you consider $T$ or $a$\n",
        "            to be the variable, since exponential growth and \n",
        "            polynomial growth have very different flavors.  The \n",
        "            nice thing about having a triangle that you can write \n",
        "            inside is that you can clarify this kind of ambiguity\n",
        "            by writing a little dot next to the constant and \n",
        "            a ``$\\\\sim$'' next to the variable.\n",
        "        \"\"\")\n",
        "        words.scale(0.75)\n",
        "        words.to_edge(UP)\n",
        "        top = TOP(\"T\", \"a\")\n",
        "        top.next_to(words, DOWN)\n",
        "        dot = top.put_in_vertex(0, OldTex(\"\\\\cdot\"))\n",
        "        sim = top.put_in_vertex(1, OldTex(\"\\\\sim\"))\n",
        "\n",
        "        self.add(words, top, dot, sim)\n",
        "        self.show_frame()\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class GoExplore(Scene):\n",
        "    def construct(self):\n",
        "        explore = OldTexText(\"Go explore!\")\n",
        "        by_the_way = OldTexText(\"by the way \\\\dots\")\n",
        "        by_the_way.shift(20*RIGHT)\n",
        "\n",
        "        self.play(Write(explore))\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VMobject(explore, by_the_way).shift,\n",
        "                20*LEFT\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}