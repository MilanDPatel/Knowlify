{
    "topic": "is demonstrating the concept of rotating a mobject around an axis, specifically in this",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "ADDER_COLOR = GREEN\n",
        "MULTIPLIER_COLOR = YELLOW\n",
        "\n",
        "def normalize(vect):\n",
        "    norm = get_norm(vect)\n",
        "    if norm == 0:\n",
        "        return OUT\n",
        "    else:\n",
        "        return vect/norm\n",
        "\n",
        "def get_composite_rotation_angle_and_axis(angles, axes):\n",
        "    angle1, axis1 = 0, OUT\n",
        "    for angle2, axis2 in zip(angles, axes):\n",
        "        ## Figure out what (angle3, axis3) is the same \n",
        "        ## as first applying (angle1, axis1), then (angle2, axis2)\n",
        "        axis2 = normalize(axis2)\n",
        "        dot = np.dot(axis2, axis1)\n",
        "        cross = np.cross(axis2, axis1)\n",
        "        angle3 = 2*np.arccos(\n",
        "            np.cos(angle2/2)*np.cos(angle1/2) - \\\n",
        "            np.sin(angle2/2)*np.sin(angle1/2)*dot\n",
        "        )\n",
        "        axis3 = (\n",
        "            np.sin(angle2/2)*np.cos(angle1/2)*axis2 + \\\n",
        "            np.cos(angle2/2)*np.sin(angle1/2)*axis1 + \\\n",
        "            np.sin(angle2/2)*np.sin(angle1/2)*cross\n",
        "        )\n",
        "        axis3 = normalize(axis3)\n",
        "        angle1, axis1 = angle3, axis3\n",
        "\n",
        "    if angle1 > np.pi:\n",
        "        angle1 -= 2*np.pi\n",
        "    return angle1, axis1\n",
        "\n",
        "class ConfettiSpiril(Animation):\n",
        "    CONFIG = {\n",
        "        \"x_start\" : 0,\n",
        "        \"spiril_radius\" : 0.5,\n",
        "        \"num_spirils\" : 4,\n",
        "        \"run_time\" : 10,\n",
        "        \"rate_func\" : None,\n",
        "    }\n",
        "    def __init__(self, mobject, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        mobject.next_to(self.x_start*RIGHT + FRAME_Y_RADIUS*UP, UP)\n",
        "        self.total_vert_shift = \\\n",
        "            FRAME_HEIGHT + mobject.get_height() + 2*MED_SMALL_BUFF\n",
        "        \n",
        "        Animation.__init__(self, mobject, **kwargs)\n",
        "\n",
        "    def interpolate_submobject(self, submobject, starting_submobject, alpha):\n",
        "        submobject.set_points(starting_submobject.get_points())\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        Animation.interpolate_mobject(self, alpha)\n",
        "        angle = alpha*self.num_spirils*2*np.pi\n",
        "        vert_shift = alpha*self.total_vert_shift\n",
        "\n",
        "        start_center = self.mobject.get_center()\n",
        "        self.mobject.shift(self.spiril_radius*OUT)\n",
        "        self.mobject.rotate(angle, axis = UP, about_point = start_center)\n",
        "        self.mobject.shift(vert_shift*DOWN)\n",
        "\n",
        "def get_confetti_animations(num_confetti_squares):\n",
        "    colors = [RED, YELLOW, GREEN, BLUE, PURPLE, RED]\n",
        "    confetti_squares = [\n",
        "        Square(\n",
        "            side_length = 0.2,\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = 0.75,\n",
        "            fill_color = random.choice(colors),\n",
        "        )\n",
        "        for x in range(num_confetti_squares)\n",
        "    ]\n",
        "    confetti_spirils = [\n",
        "        ConfettiSpiril(\n",
        "            square,\n",
        "            x_start = 2*random.random()*FRAME_X_RADIUS - FRAME_X_RADIUS,\n",
        "            rate_func = squish_rate_func(rush_from, a, a+0.5)\n",
        "        )\n",
        "        for a, square in zip(\n",
        "            np.linspace(0, 0.5, num_confetti_squares),\n",
        "            confetti_squares\n",
        "        )\n",
        "    ]\n",
        "    return confetti_spirils\n",
        "\n",
        "class Anniversary(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"num_confetti_squares\" : 50,\n",
        "        \"message\": \"2 year Anniversary!\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.celebrate()\n",
        "        self.complain()\n",
        "\n",
        "    def celebrate(self):\n",
        "        title = OldTexText(self.message)\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        first_video = Rectangle(\n",
        "            height = 2, width = 2*(16.0/9),\n",
        "            stroke_color = WHITE,\n",
        "            fill_color = \"#111111\",\n",
        "            fill_opacity = 0.75,\n",
        "        )\n",
        "        first_video.next_to(self.get_teacher(), UP+LEFT)\n",
        "        first_video.shift(RIGHT)\n",
        "        formula = OldTex(\"e^{\\\\pi i} = -1\")\n",
        "        formula.move_to(first_video)\n",
        "        first_video.add(formula)\n",
        "        first_video.fade(1)\n",
        "\n",
        "        hats = self.get_party_hats()\n",
        "        confetti_spirils = get_confetti_animations(\n",
        "            self.num_confetti_squares\n",
        "        )\n",
        "        self.play(\n",
        "            Write(title, run_time = 2),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"hooray\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            DrawBorderThenFill(\n",
        "                hats,\n",
        "                lag_ratio = 0.5,\n",
        "                rate_func=linear,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            *confetti_spirils + [\n",
        "                Succession(\n",
        "                    Animation(pi, run_time = 2),\n",
        "                    ApplyMethod(pi.look, UP+LEFT),\n",
        "                    ApplyMethod(pi.look, UP+RIGHT),\n",
        "                    Animation(pi),\n",
        "                    ApplyMethod(pi.look_at, first_video),\n",
        "                    rate_func=linear\n",
        "                )\n",
        "                for pi in self.get_students()\n",
        "            ] + [\n",
        "                Succession(\n",
        "                    Animation(self.get_teacher(), run_time = 2),\n",
        "                    Blink(self.get_teacher()),\n",
        "                    Animation(self.get_teacher(), run_time = 2),\n",
        "                    ApplyMethod(self.get_teacher().change_mode, \"raise_right_hand\"),\n",
        "                    rate_func=linear\n",
        "                ),\n",
        "                DrawBorderThenFill(\n",
        "                    first_video, \n",
        "                    run_time = 10,\n",
        "                    rate_func = squish_rate_func(smooth, 0.5, 0.7)\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "\n",
        "    def complain(self):\n",
        "        self.student_says(\n",
        "            \"Why were you \\\\\\\\ talking so fast?\",\n",
        "            index = 0,\n",
        "            target_mode = \"sassy\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"sassy\"]*3)\n",
        "        self.play(self.get_teacher().change_mode, \"shruggie\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_party_hats(self):\n",
        "        hats = VGroup(*[\n",
        "            PartyHat(\n",
        "                pi_creature = pi,\n",
        "                height = 0.5*pi.get_height()\n",
        "            )\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        max_angle = np.pi/6\n",
        "        for hat in hats:\n",
        "            hat.rotate(\n",
        "                random.random()*2*max_angle - max_angle,\n",
        "                about_point = hat.get_bottom()\n",
        "            )\n",
        "        return hats\n",
        "\n",
        "class HomomophismPreview(Scene):\n",
        "    def construct(self):\n",
        "        raise Exception(\"Meant as a place holder, not to be excecuted\")\n",
        "\n",
        "class WatchingScreen(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"screen_height\" : 5.5\n",
        "    }\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph().to_corner(DOWN+LEFT)\n",
        "        return VGroup(randy)\n",
        "\n",
        "    def construct(self):\n",
        "        screen = Rectangle(height = 9, width = 16)\n",
        "        screen.set_height(self.screen_height)\n",
        "        screen.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.add(screen)\n",
        "        for mode in \"erm\", \"pondering\", \"confused\":\n",
        "            self.wait()\n",
        "            self.change_mode(mode)\n",
        "            self.play(Animation(screen))\n",
        "            self.wait()\n",
        "\n",
        "class LetsStudyTheBasics(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Let's learn some \\\\\\\\ group theory!\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class JustGiveMeAQuickExplanation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"I ain't got \\\\\\\\ time for this!\",\n",
        "            target_mode = \"angry\",\n",
        "        )\n",
        "        self.play(*it.chain(*[\n",
        "            [\n",
        "                pi.change_mode, \"hesitant\", \n",
        "                pi.look_at, self.get_students()[1].eyes\n",
        "            ]\n",
        "            for pi in self.get_students()[::2]\n",
        "        ]))\n",
        "        self.wait(2)\n",
        "\n",
        "class ComplexTransformationScene(Scene):\n",
        "    pass\n",
        "\n",
        "class QuickExplanation(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"plane_config\" : {\n",
        "            \"x_line_frequency\" : 1,\n",
        "            \"y_line_frequency\" : 1,\n",
        "            \"secondary_line_ratio\" : 1,\n",
        "            \"space_unit_to_x_unit\" : 1.5,\n",
        "            \"space_unit_to_y_unit\" : 1.5,\n",
        "        },\n",
        "        \"background_fade_factor\" : 0.2,\n",
        "        \"background_label_scale_val\" : 0.7,\n",
        "        \"velocity_color\" : RED,\n",
        "        \"position_color\" : YELLOW,\n",
        "    }\n",
        "    def construct(self):\n",
        "        # self.add_transformable_plane()\n",
        "        self.add_equation()\n",
        "        self.add_explanation()\n",
        "        self.add_vectors()\n",
        "\n",
        "    def add_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"\\\\frac{d(e^{it})}{dt}\",\n",
        "            \"=\",\n",
        "            \"i\", \"e^{it}\"\n",
        "        )\n",
        "        equation[0].set_color(self.velocity_color)\n",
        "        equation[-1].set_color(self.position_color)\n",
        "        equation.add_background_rectangle()        \n",
        "        brace = Brace(equation, UP)\n",
        "        equation.add(brace)\n",
        "        brace_text = OldTexText(\n",
        "            \"Velocity vector\", \"is a\", \n",
        "            \"$90^\\\\circ$ \\\\\\\\ rotation\", \n",
        "            \"of\", \"position vector\"\n",
        "        )\n",
        "        brace_text[0].set_color(self.velocity_color)\n",
        "        brace_text[-1].set_color(self.position_color)\n",
        "        brace_text.add_background_rectangle()\n",
        "        brace_text.scale(0.8)\n",
        "        brace_text.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        equation.next_to(brace_text, DOWN)\n",
        "\n",
        "        self.add_foreground_mobjects(brace_text, equation)\n",
        "        self.brace_text = brace_text\n",
        "\n",
        "    def add_explanation(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Only a walk around the unit\n",
        "            circle at rate 1 satisfies both\n",
        "            this property and e^0 = 1.\n",
        "        \"\"\")\n",
        "        words.scale(0.8)\n",
        "        words.add_background_rectangle()\n",
        "        words.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n",
        "        arrow = Arrow(RIGHT, 1.5*LEFT, color = WHITE)\n",
        "        arrow.to_edge(UP)\n",
        "\n",
        "        self.add(words, arrow)\n",
        "\n",
        "    def add_vectors(self):\n",
        "        right = self.z_to_point(1)\n",
        "        s_vector = Arrow(\n",
        "            ORIGIN, right,\n",
        "            tip_length = 0.2,\n",
        "            buff = 0,            \n",
        "            color = self.position_color,\n",
        "        )\n",
        "\n",
        "        v_vector = s_vector.copy().rotate(np.pi/2)\n",
        "        v_vector.set_color(self.velocity_color)\n",
        "        circle = Circle(\n",
        "            radius = self.z_to_point(1)[0],\n",
        "            color = self.position_color\n",
        "        )\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(s_vector))\n",
        "        self.play(ReplacementTransform(\n",
        "            s_vector.copy(), v_vector, path_arc = np.pi/2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(v_vector.shift, right)\n",
        "        self.wait()\n",
        "        self.vectors = VGroup(s_vector, v_vector)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"run_time\" : 5,\n",
        "        }\n",
        "        rotation = Rotating(self.vectors, about_point = ORIGIN, **kwargs)\n",
        "        self.play(\n",
        "            ShowCreation(circle, **kwargs),\n",
        "            rotation            \n",
        "        )\n",
        "        self.play(rotation)\n",
        "        self.play(rotation)\n",
        "\n",
        "class SymmetriesOfSquare(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"square_config\" : {\n",
        "            \"side_length\" : 2,\n",
        "            \"stroke_width\" : 0,\n",
        "            \"fill_color\" : BLUE,\n",
        "            \"fill_opacity\" : 0.75,\n",
        "        },\n",
        "        \"dashed_line_config\" : {},\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.ask_about_square_symmetry()\n",
        "        self.talk_through_90_degree_rotation()\n",
        "        self.talk_through_vertical_flip()\n",
        "        self.confused_by_lack_of_labels()\n",
        "        self.add_labels()\n",
        "        self.show_full_group()\n",
        "        self.show_top_actions()\n",
        "        self.show_bottom_actions()\n",
        "        self.name_dihedral_group()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Groups\", \"$\\\\leftrightarrow$\", \"Symmetry\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        for index in 0, 2:\n",
        "            self.play(Write(title[index], run_time = 1))\n",
        "        self.play(GrowFromCenter(title[1]))\n",
        "        self.wait()\n",
        "\n",
        "        self.title = title\n",
        "\n",
        "    def ask_about_square_symmetry(self):\n",
        "        brace = Brace(self.title[-1])\n",
        "        q_marks = brace.get_text(\"???\")\n",
        "\n",
        "        self.square = Square(**self.square_config)\n",
        "\n",
        "        self.play(DrawBorderThenFill(self.square))\n",
        "        self.play(GrowFromCenter(brace), Write(q_marks))\n",
        "        self.rotate_square()\n",
        "        self.wait()\n",
        "        for axis in UP, UP+RIGHT:\n",
        "            self.flip_square(axis)\n",
        "            self.wait()\n",
        "        self.rotate_square(-np.pi)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, q_marks])))\n",
        "\n",
        "    def talk_through_90_degree_rotation(self):\n",
        "        arcs = self.get_rotation_arcs(self.square, np.pi/2)\n",
        "\n",
        "        self.play(*list(map(ShowCreation, arcs)))\n",
        "        self.wait()\n",
        "        self.rotate_square(np.pi/2, run_time = 2)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arcs))\n",
        "        self.wait()\n",
        "\n",
        "    def talk_through_vertical_flip(self):\n",
        "        self.flip_square(UP, run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "    def confused_by_lack_of_labels(self):\n",
        "        randy = Randolph(mode = \"confused\")\n",
        "        randy.next_to(self.square, LEFT, buff = LARGE_BUFF)\n",
        "        randy.to_edge(DOWN)\n",
        "        self.play(FadeIn(randy))\n",
        "        for axis in OUT, RIGHT, UP:\n",
        "            self.rotate_square(\n",
        "                angle = np.pi, axis = axis,\n",
        "                added_anims = [randy.look_at, self.square.get_points()[0]]\n",
        "            )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.randy = randy\n",
        "\n",
        "    def add_labels(self):\n",
        "        self.add_randy_to_square(self.square)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(self.square.randy),\n",
        "            self.randy.change_mode, \"happy\",\n",
        "            self.randy.look_at, self.square.randy.eyes\n",
        "        )\n",
        "        self.play(Blink(self.randy))\n",
        "        self.play(FadeOut(self.randy))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def show_full_group(self):\n",
        "        new_title = OldTexText(\"Group\", \"of\", \"symmetries\")\n",
        "        new_title.move_to(self.title)\n",
        "\n",
        "        all_squares = VGroup(*[\n",
        "            self.square.copy().scale(0.5)\n",
        "            for x in range(8)\n",
        "        ])\n",
        "        all_squares.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        top_squares = VGroup(*all_squares[:4])\n",
        "        bottom_squares = VGroup(*all_squares[4:])\n",
        "        bottom_squares.next_to(top_squares, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        all_squares.set_width(FRAME_WIDTH-2*LARGE_BUFF)\n",
        "        all_squares.center()\n",
        "        all_squares.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(ReplacementTransform(self.square, all_squares[0]))\n",
        "        self.play(ReplacementTransform(self.title, new_title))\n",
        "        self.title = new_title\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.set_color, GREY)\n",
        "            for mob in self.title[1:]\n",
        "        ])\n",
        "\n",
        "        for square, angle in zip(all_squares[1:4], [np.pi/2, np.pi, -np.pi/2]):\n",
        "            arcs = self.get_rotation_arcs(square, angle, MED_SMALL_BUFF)\n",
        "            self.play(*list(map(FadeIn, [square, arcs])))\n",
        "            square.rotation_kwargs = {\"angle\" : angle}\n",
        "            self.rotate_square(square = square, **square.rotation_kwargs)\n",
        "            square.add(arcs)\n",
        "\n",
        "        for square, axis in zip(bottom_squares, [RIGHT, RIGHT+UP, UP, UP+LEFT]):\n",
        "            axis_line = self.get_axis_line(square, axis)\n",
        "            self.play(FadeIn(square))\n",
        "            self.play(ShowCreation(axis_line))\n",
        "            square.rotation_kwargs = {\"angle\" : np.pi, \"axis\" : axis}\n",
        "            self.rotate_square(square = square, **square.rotation_kwargs)\n",
        "            square.add(axis_line)\n",
        "        self.wait()\n",
        "\n",
        "        self.all_squares = all_squares\n",
        "\n",
        "    def show_top_actions(self):\n",
        "        all_squares = self.all_squares\n",
        "\n",
        "        self.play(Indicate(all_squares[0]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*[\n",
        "            Rotate(\n",
        "                square,\n",
        "                rate_func = lambda t : -there_and_back(t),\n",
        "                run_time = 3,\n",
        "                about_point = square.get_center(),\n",
        "                **square.rotation_kwargs\n",
        "            )\n",
        "            for square in all_squares[1:4]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def show_bottom_actions(self):\n",
        "        for square in self.all_squares[4:]:\n",
        "            self.rotate_square(\n",
        "                square = square,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 2,\n",
        "                **square.rotation_kwargs\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def name_dihedral_group(self):\n",
        "        new_title = OldTexText(\n",
        "            \"``Dihedral group'' of order 8\"\n",
        "        )\n",
        "        new_title.to_edge(UP)\n",
        "\n",
        "        self.play(FadeOut(self.title))\n",
        "        self.play(FadeIn(new_title))\n",
        "        self.wait()\n",
        "\n",
        "    ##########\n",
        "\n",
        "    def rotate_square(\n",
        "        self, \n",
        "        angle = np.pi/2, \n",
        "        axis = OUT, \n",
        "        square = None, \n",
        "        show_axis = False,\n",
        "        added_anims = None,\n",
        "        **kwargs\n",
        "        ):\n",
        "        if square is None:\n",
        "            assert hasattr(self, \"square\")\n",
        "            square = self.square\n",
        "        added_anims = added_anims or []\n",
        "        rotation = Rotate(\n",
        "            square, \n",
        "            angle = angle, \n",
        "            axis = axis, \n",
        "            about_point = square.get_center(),\n",
        "            **kwargs\n",
        "        )\n",
        "        if hasattr(square, \"labels\"):\n",
        "            for label in rotation.target_mobject.labels:\n",
        "                label.rotate(-angle, axis)\n",
        "\n",
        "        if show_axis:\n",
        "            axis_line = self.get_axis_line(square, axis)\n",
        "            self.play(\n",
        "                ShowCreation(axis_line),\n",
        "                Animation(square)\n",
        "            )\n",
        "        self.play(rotation, *added_anims)\n",
        "        if show_axis:\n",
        "            self.play(\n",
        "                FadeOut(axis_line),\n",
        "                Animation(square)\n",
        "            )\n",
        "\n",
        "    def flip_square(self, axis = UP, **kwargs):\n",
        "        self.rotate_square(\n",
        "            angle = np.pi, \n",
        "            axis = axis,\n",
        "            show_axis = True,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_rotation_arcs(self, square, angle, angle_buff = SMALL_BUFF):\n",
        "        square_radius = get_norm(\n",
        "            square.get_points()[0] - square.get_center()\n",
        "        )\n",
        "        arc = Arc(\n",
        "            radius = square_radius + SMALL_BUFF,\n",
        "            start_angle = np.pi/4 + np.sign(angle)*angle_buff,\n",
        "            angle = angle - np.sign(angle)*2*angle_buff,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        arc.add_tip()\n",
        "        if abs(angle) < 3*np.pi/4:\n",
        "            angle_multiple_range = list(range(1, 4))\n",
        "        else:\n",
        "            angle_multiple_range = [2]\n",
        "        arcs = VGroup(arc, *[\n",
        "            arc.copy().rotate(i*np.pi/2)\n",
        "            for i in angle_multiple_range\n",
        "        ])\n",
        "        arcs.move_to(square[0])\n",
        "\n",
        "        return arcs\n",
        "\n",
        "    def get_axis_line(self, square, axis):\n",
        "        axis_line = DashedLine(2*axis, -2*axis, **self.dashed_line_config)\n",
        "        axis_line.replace(square, dim_to_match = np.argmax(np.abs(axis)))\n",
        "        axis_line.scale(1.2)\n",
        "        return axis_line\n",
        "\n",
        "    def add_labels_and_dots(self, square):\n",
        "        labels = VGroup()\n",
        "        dots = VGroup()\n",
        "        for tex, vertex in zip(\"ABCD\", square.get_anchors()):\n",
        "            label = OldTex(tex)\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(vertex, vertex-square.get_center(), SMALL_BUFF)\n",
        "            labels.add(label)\n",
        "            dot = Dot(vertex, color = WHITE)\n",
        "            dots.add(dot)\n",
        "        square.add(labels, dots)\n",
        "        square.labels = labels\n",
        "        square.dots = dots\n",
        "\n",
        "    def add_randy_to_square(self, square, mode = \"pondering\"):\n",
        "        randy = Randolph(mode = mode)\n",
        "        randy.set_height(0.75*square.get_height())\n",
        "        randy.move_to(square)\n",
        "        square.add(randy)\n",
        "        square.randy = randy\n",
        "\n",
        "class ManyGroupsAreInfinite(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Many groups are infinite\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class CircleSymmetries(Scene):\n",
        "    CONFIG = {\n",
        "        \"circle_radius\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_circle_and_title()        \n",
        "        self.show_range_of_angles()\n",
        "        self.associate_rotations_with_points()\n",
        "\n",
        "    def add_circle_and_title(self):\n",
        "        title = OldTexText(\"Group of rotations\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        circle = self.get_circle()\n",
        "\n",
        "        self.play(Write(title), ShowCreation(circle, run_time = 2))\n",
        "        self.wait()\n",
        "        angles = [\n",
        "            np.pi/2, -np.pi/3, 5*np.pi/6, \n",
        "            3*np.pi/2 + 0.1\n",
        "        ]\n",
        "        angles.append(-sum(angles))\n",
        "        for angle in angles:\n",
        "            self.play(Rotate(circle, angle = angle))\n",
        "            self.wait()\n",
        "\n",
        "        self.circle = circle\n",
        "\n",
        "    def show_range_of_angles(self):\n",
        "        self.add_radial_line()\n",
        "        arc_circle = self.get_arc_circle()\n",
        "\n",
        "        theta = OldTex(\"\\\\theta = \")\n",
        "        theta_value = DecimalNumber(0.00)\n",
        "        theta_value.next_to(theta, RIGHT)\n",
        "        theta_group = VGroup(theta, theta_value)\n",
        "        theta_group.next_to(arc_circle, UP)\n",
        "        def theta_value_update(theta_value, alpha):\n",
        "            new_theta_value = DecimalNumber(alpha*2*np.pi)\n",
        "            new_theta_value.set_height(theta.get_height())\n",
        "            new_theta_value.next_to(theta, RIGHT)\n",
        "            Transform(theta_value, new_theta_value).update(1)\n",
        "            return new_theta_value\n",
        "\n",
        "\n",
        "        self.play(FadeIn(theta_group))\n",
        "        for rate_func in smooth, lambda t : smooth(1-t):\n",
        "            self.play(\n",
        "                Rotate(self.circle, 2*np.pi-0.001),\n",
        "                ShowCreation(arc_circle),\n",
        "                UpdateFromAlphaFunc(theta_value, theta_value_update),\n",
        "                run_time = 7,\n",
        "                rate_func = rate_func\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(theta_group))\n",
        "        self.wait()\n",
        "\n",
        "    def associate_rotations_with_points(self):\n",
        "        zero_dot = Dot(self.circle.point_from_proportion(0))\n",
        "        zero_dot.set_color(RED)\n",
        "        zero_arrow = Arrow(UP+RIGHT, ORIGIN)\n",
        "        zero_arrow.set_color(zero_dot.get_color())\n",
        "        zero_arrow.next_to(zero_dot, UP+RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(zero_arrow),\n",
        "            DrawBorderThenFill(zero_dot)\n",
        "        )\n",
        "        self.circle.add(zero_dot)\n",
        "        self.wait()\n",
        "\n",
        "        for alpha in 0.2, 0.6, 0.4, 0.8:\n",
        "            point = self.circle.point_from_proportion(alpha)\n",
        "            dot = Dot(point, color = YELLOW)\n",
        "            vect = np.sign(point)\n",
        "            arrow = Arrow(vect, ORIGIN)\n",
        "            arrow.next_to(dot, vect, buff = SMALL_BUFF)\n",
        "            arrow.set_color(dot.get_color())\n",
        "            angle = alpha*2*np.pi\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                DrawBorderThenFill(dot)\n",
        "            )\n",
        "            self.play(\n",
        "                Rotate(self.circle, angle, run_time = 2),\n",
        "                Animation(dot)\n",
        "            )\n",
        "            self.wait()            \n",
        "            self.play(\n",
        "                Rotate(self.circle, -angle, run_time = 2),\n",
        "                FadeOut(dot),\n",
        "                FadeOut(arrow),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_circle(self):\n",
        "        circle = Circle(color = MAROON_B, radius = self.circle_radius)\n",
        "        circle.ticks = VGroup()\n",
        "        for alpha in np.arange(0, 1, 1./8):\n",
        "            point = circle.point_from_proportion(alpha)\n",
        "            tick = Line((1 - 0.05)*point, (1 + 0.05)*point)\n",
        "            circle.ticks.add(tick)\n",
        "        circle.add(circle.ticks)\n",
        "        return circle\n",
        "\n",
        "    def add_radial_line(self):\n",
        "        radius = Line(\n",
        "            self.circle.get_center(), \n",
        "            self.circle.point_from_proportion(0)\n",
        "        )\n",
        "        static_radius = radius.copy().set_color(GREY)\n",
        "\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.add(static_radius, radius)\n",
        "        self.circle.radius = radius\n",
        "        self.circle.static_radius = static_radius\n",
        "        self.circle.add(radius)\n",
        "\n",
        "    def get_arc_circle(self):\n",
        "        arc_radius = self.circle_radius/5.0\n",
        "        arc_circle = Circle(\n",
        "            radius = arc_radius,\n",
        "            color = WHITE\n",
        "        )\n",
        "        return arc_circle\n",
        "\n",
        "class GroupOfCubeSymmetries(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"cube_opacity\" : 0.5,\n",
        "        \"cube_colors\" : [BLUE],\n",
        "        \"put_randy_on_cube\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Group of cube symmetries\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        cube = self.get_cube()\n",
        "\n",
        "        face_centers = [face.get_center() for face in cube[0:7:2]]\n",
        "        angle_axis_pairs = list(zip(3*[np.pi/2], face_centers))\n",
        "        for i in range(3):\n",
        "            ones = np.ones(3)\n",
        "            ones[i] = -1\n",
        "            axis = np.dot(ones, face_centers)\n",
        "            angle_axis_pairs.append((2*np.pi/3, axis))\n",
        "\n",
        "        for angle, axis in angle_axis_pairs:\n",
        "            self.play(Rotate(\n",
        "                cube, angle = angle, axis = axis,\n",
        "                run_time = 2\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "    def get_cube(self):\n",
        "        cube = Cube(fill_opacity = self.cube_opacity)\n",
        "        cube.set_color_by_gradient(*self.cube_colors)\n",
        "        if self.put_randy_on_cube:\n",
        "            randy = Randolph(mode = \"pondering\")\n",
        "            # randy.pupils.shift(0.01*OUT)\n",
        "            # randy.add(randy.pupils.copy().shift(0.02*IN))\n",
        "            # for submob in randy.get_family():\n",
        "            #     submob.part_of_three_d_mobject = True\n",
        "            randy.scale(0.5)\n",
        "            face = cube[1]\n",
        "            randy.move_to(face)\n",
        "            face.add(randy)\n",
        "        pose_matrix = self.get_pose_matrix()\n",
        "        cube.apply_function(\n",
        "            lambda p : np.dot(p, pose_matrix.T),\n",
        "            maintain_smoothness = False\n",
        "        )\n",
        "        return cube\n",
        "\n",
        "    def get_pose_matrix(self):\n",
        "        return np.dot(\n",
        "            rotation_matrix(np.pi/8, UP),\n",
        "            rotation_matrix(np.pi/24, RIGHT)\n",
        "        )\n",
        "\n",
        "class HowDoSymmetriesPlayWithEachOther(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"How do symmetries \\\\\\\\ play with each other?\",\n",
        "            target_mode = \"hesitant\",\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"maybe\", \"confused\")\n",
        "        self.wait(2)\n",
        "\n",
        "class AddSquareSymmetries(SymmetriesOfSquare):\n",
        "    def construct(self):\n",
        "        square = Square(**self.square_config)\n",
        "        square.flip(RIGHT)\n",
        "        square.shift(DOWN)\n",
        "        self.add_randy_to_square(square, mode = \"shruggie\")\n",
        "        alt_square = square.copy()\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.move_to(square)\n",
        "\n",
        "        equation_square = Square(**self.square_config)\n",
        "        equation = VGroup(\n",
        "            equation_square, OldTex(\"+\"), \n",
        "            equation_square.copy(), OldTex(\"=\"),\n",
        "            equation_square.copy(),\n",
        "        )\n",
        "        equation[0].add(self.get_rotation_arcs(\n",
        "            equation[0], np.pi/2,\n",
        "        ))\n",
        "        equation[2].add(self.get_axis_line(equation[4], UP))\n",
        "        equation[4].add(self.get_axis_line(equation[4], UP+RIGHT))\n",
        "        for mob in equation[::2]:\n",
        "            mob.scale(0.5)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        arcs = self.get_rotation_arcs(square, np.pi/2)\n",
        "\n",
        "        self.add(square)\n",
        "        self.play(FadeIn(arcs))\n",
        "        self.rotate_square(\n",
        "            square = square, angle = np.pi/2,\n",
        "            added_anims = list(map(FadeIn, equation[:2]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arcs))\n",
        "        self.flip_square(\n",
        "            square = square, axis = UP,\n",
        "            added_anims = list(map(FadeIn, equation[2:4]))\n",
        "        )\n",
        "        self.wait()\n",
        "        alt_square.next_to(equals, RIGHT, buff = LARGE_BUFF)\n",
        "        alt_square.save_state()\n",
        "        alt_square.move_to(square)\n",
        "        alt_square.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            square.next_to, equals, LEFT, LARGE_BUFF,\n",
        "            alt_square.restore,\n",
        "            Write(equals)\n",
        "        )\n",
        "        self.flip_square(\n",
        "            square = alt_square, axis = UP+RIGHT,\n",
        "            added_anims = list(map(FadeIn, equation[4:])),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        ## Reiterate composition\n",
        "        self.rotate_square(square = square, angle = np.pi/2)\n",
        "        self.flip_square(square = square, axis = UP)\n",
        "        self.wait()\n",
        "        self.flip_square(square = alt_square, axis = UP+RIGHT)\n",
        "        self.wait()\n",
        "\n",
        "class AddCircleSymmetries(CircleSymmetries):\n",
        "    def construct(self):\n",
        "        circle = self.circle = self.get_circle()\n",
        "        arc_circle = self.get_arc_circle()\n",
        "        angles = [3*np.pi/2, 2*np.pi/3, np.pi/6]\n",
        "        arcs = [\n",
        "            arc_circle.copy().scale(scalar)\n",
        "            for scalar in [1, 1.2, 1.4]\n",
        "        ]\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"270^\\\\circ\", \"+\", \"120^\\\\circ\", \"=\", \"30^\\\\circ\",\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        colors = [BLUE, YELLOW, GREEN]\n",
        "        for color, arc, term in zip(colors, arcs, equation[::2]):\n",
        "            arc.set_color(color)\n",
        "            term.set_color(color)\n",
        "\n",
        "        self.play(FadeIn(circle))\n",
        "        self.add_radial_line()\n",
        "        alt_radius = circle.radius.copy()\n",
        "        alt_radius.set_color(GREY)\n",
        "        alt_circle = circle.copy()\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.move_to(circle)\n",
        "\n",
        "        def rotate(circle, angle, arc, terms):\n",
        "            self.play(\n",
        "                Rotate(circle, angle, in_place = True),\n",
        "                ShowCreation(\n",
        "                    arc,\n",
        "                    rate_func = lambda t : (angle/(2*np.pi))*smooth(t)\n",
        "                ),\n",
        "                Write(VGroup(*terms)),\n",
        "                run_time = 2,\n",
        "            )\n",
        "\n",
        "        rotate(circle, angles[0], arcs[0], equation[:2])\n",
        "        self.wait()\n",
        "        circle.add(alt_radius)\n",
        "        rotate(circle, angles[1], arcs[1], equation[2:4])\n",
        "        self.play(FadeOut(alt_radius))\n",
        "        circle.remove(alt_radius)\n",
        "        self.wait()\n",
        "\n",
        "        circle.add(circle.static_radius)\n",
        "        circle.add(*arcs[:2])\n",
        "\n",
        "        alt_static_radius = circle.static_radius.copy()\n",
        "        alt_circle.add(alt_static_radius)\n",
        "        alt_circle.next_to(equals, RIGHT, buff = LARGE_BUFF)\n",
        "        alt_circle.save_state()\n",
        "        alt_circle.move_to(circle)\n",
        "        alt_circle.set_stroke(width = 0)\n",
        "        self.play(\n",
        "            circle.next_to, equals, LEFT, LARGE_BUFF,\n",
        "            alt_circle.restore,\n",
        "            Write(equals)\n",
        "        )\n",
        "        arcs[2].shift(alt_circle.get_center())\n",
        "        alt_circle.remove(alt_static_radius)\n",
        "        self.wait()\n",
        "        rotate(alt_circle, angles[2], arcs[2], equation[4:])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(arcs[1], angles[0], about_point = circle.get_center())\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for term, arc in zip(equation[::2], arcs):\n",
        "            self.play(*[\n",
        "                ApplyMethod(mob.scale, 1.2, rate_func = there_and_back)\n",
        "                for mob in (term, arc)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "class AddCubeSymmetries(GroupOfCubeSymmetries):\n",
        "    CONFIG = {\n",
        "        \"angle_axis_pairs\" : [\n",
        "            (np.pi/2, RIGHT),\n",
        "            (np.pi/2, UP),\n",
        "        ],\n",
        "        \"cube_opacity\" : 0.5,\n",
        "        \"cube_colors\" : [BLUE],\n",
        "    }\n",
        "    def construct(self):\n",
        "        angle_axis_pairs = list(self.angle_axis_pairs)\n",
        "        angle_axis_pairs.append(\n",
        "            self.get_composition_angle_and_axis()\n",
        "        )\n",
        "        self.pose_matrix = self.get_pose_matrix()\n",
        "        cube = self.get_cube()\n",
        "\n",
        "        equation = cube1, plus, cube2, equals, cube3 = VGroup(\n",
        "            cube, OldTex(\"+\"), \n",
        "            cube.copy(), OldTex(\"=\"),\n",
        "            cube.copy()\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        equation.center()\n",
        "\n",
        "        self.add(cube1)\n",
        "        self.rotate_cube(cube1, *angle_axis_pairs[0])\n",
        "        cube_copy = cube1.copy()\n",
        "        cube_copy.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            cube_copy.move_to, cube2,\n",
        "            cube_copy.set_fill, None, self.cube_opacity,\n",
        "            Write(plus)\n",
        "        )\n",
        "        self.rotate_cube(cube_copy, *angle_axis_pairs[1])\n",
        "        self.play(Write(equals))\n",
        "        self.play(DrawBorderThenFill(cube3, run_time = 1))\n",
        "        self.rotate_cube(cube3, *angle_axis_pairs[2])\n",
        "        self.wait(2)\n",
        "\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        times.scale(1.5)\n",
        "        times.move_to(plus)\n",
        "        times.set_color(RED)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(plus, times))\n",
        "        self.play(Indicate(times))\n",
        "        self.wait()\n",
        "        for cube, (angle, axis) in zip([cube1, cube_copy, cube3], angle_axis_pairs):\n",
        "            self.rotate_cube(\n",
        "                cube, -angle, axis, add_arrows = False,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def rotate_cube(self, cube, angle, axis, add_arrows = True, **kwargs):\n",
        "        axis = np.dot(axis, self.pose_matrix.T)\n",
        "        anims = []\n",
        "        if add_arrows:\n",
        "            arrows = VGroup(*[\n",
        "                Arc(\n",
        "                    start_angle = np.pi/12+a, angle = 5*np.pi/6,\n",
        "                    color = YELLOW\n",
        "                ).add_tip()\n",
        "                for a in (0, np.pi)\n",
        "            ])\n",
        "            arrows.set_height(1.5*cube.get_height())\n",
        "            z_to_axis = z_to_vector(axis)\n",
        "            arrows.apply_function(\n",
        "                lambda p : np.dot(p, z_to_axis.T),\n",
        "                maintain_smoothness = False\n",
        "            )\n",
        "            arrows.move_to(cube)\n",
        "            arrows.shift(-axis*cube.get_height()/2/get_norm(axis))\n",
        "            anims += list(map(ShowCreation, arrows))\n",
        "        anims.append(\n",
        "            Rotate(\n",
        "                cube, axis = axis, angle = angle, in_place = True,\n",
        "                **kwargs\n",
        "            )\n",
        "        )\n",
        "        self.play(*anims, run_time = 1.5)\n",
        "\n",
        "    def get_composition_angle_and_axis(self):\n",
        "        return get_composite_rotation_angle_and_axis(\n",
        "            *list(zip(*self.angle_axis_pairs))\n",
        "        )\n",
        "\n",
        "class DihedralGroupStructure(SymmetriesOfSquare):\n",
        "    CONFIG = {\n",
        "        \"dashed_line_config\" : {\n",
        "            \"dash_length\" : 0.1\n",
        "        },\n",
        "        \"filed_sum_scale_factor\" : 0.4,\n",
        "        \"num_rows\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        angle_axis_pairs = [\n",
        "            (np.pi/2, OUT),\n",
        "            (np.pi, OUT),\n",
        "            (-np.pi/2, OUT),\n",
        "            # (np.pi, RIGHT),\n",
        "            # (np.pi, UP+RIGHT),\n",
        "            (np.pi, UP),\n",
        "            (np.pi, UP+LEFT),\n",
        "        ]\n",
        "        pair_pairs = list(it.product(*[angle_axis_pairs]*2))\n",
        "        random.shuffle(pair_pairs)\n",
        "        for pair_pair in pair_pairs[:4]:\n",
        "            sum_expression = self.demonstrate_sum(pair_pair)\n",
        "            self.file_away_sum(sum_expression)\n",
        "        for pair_pair in pair_pairs[4:]:\n",
        "            should_skip_animations = self.skip_animations\n",
        "            self.skip_animations = True\n",
        "            sum_expression = self.demonstrate_sum(pair_pair)\n",
        "            self.file_away_sum(sum_expression)\n",
        "            self.skip_animations = should_skip_animations\n",
        "            self.play(FadeIn(sum_expression))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    def demonstrate_sum(self, angle_axis_pairs):\n",
        "        angle_axis_pairs = list(angle_axis_pairs) + [\n",
        "            get_composite_rotation_angle_and_axis(\n",
        "                *list(zip(*angle_axis_pairs))\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        prototype_square = Square(**self.square_config)\n",
        "        prototype_square.flip(RIGHT)\n",
        "        self.add_randy_to_square(prototype_square)\n",
        "\n",
        "        # self.add_labels_and_dots(prototype_square)\n",
        "        prototype_square.scale(0.7)\n",
        "        expression = s1, plus, s2, equals, s3 = VGroup(\n",
        "            prototype_square, OldTex(\"+\").scale(2), \n",
        "            prototype_square.copy(), OldTex(\"=\").scale(2),\n",
        "            prototype_square.copy()\n",
        "        )\n",
        "\n",
        "        final_expression = VGroup()\n",
        "        for square, (angle, axis) in zip([s1, s2, s3], angle_axis_pairs):\n",
        "            if np.cos(angle) > 0.5:\n",
        "                square.action_illustration = VectorizedPoint()\n",
        "            elif np.argmax(np.abs(axis)) == 2: ##Axis is in z direction\n",
        "                square.action_illustration = self.get_rotation_arcs(\n",
        "                    square, angle\n",
        "                )\n",
        "            else:\n",
        "                square.action_illustration = self.get_axis_line(\n",
        "                    square, axis\n",
        "                )\n",
        "            square.add(square.action_illustration)\n",
        "            final_expression.add(square.action_illustration)\n",
        "            square.rotation_kwargs = {\n",
        "                \"square\" : square,\n",
        "                \"angle\" : angle,\n",
        "                \"axis\" : axis,\n",
        "            }\n",
        "        expression.arrange()\n",
        "        expression.set_width(FRAME_X_RADIUS+1)\n",
        "        expression.to_edge(RIGHT, buff = SMALL_BUFF)\n",
        "        for square in s1, s2, s3:\n",
        "            square.remove(square.action_illustration)\n",
        "\n",
        "        self.play(FadeIn(s1))\n",
        "        self.play(*list(map(ShowCreation, s1.action_illustration)))\n",
        "        self.rotate_square(**s1.rotation_kwargs)\n",
        "\n",
        "        s1_copy = s1.copy()\n",
        "        self.play(\n",
        "            # FadeIn(s2),\n",
        "            s1_copy.move_to, s2,\n",
        "            Write(plus)\n",
        "        )\n",
        "        Transform(s2, s1_copy).update(1)\n",
        "        self.remove(s1_copy)\n",
        "        self.add(s2)\n",
        "        self.play(*list(map(ShowCreation, s2.action_illustration)))\n",
        "        self.rotate_square(**s2.rotation_kwargs)\n",
        "\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            FadeIn(s3)\n",
        "        )\n",
        "        self.play(*list(map(ShowCreation, s3.action_illustration)))\n",
        "        self.rotate_square(**s3.rotation_kwargs)\n",
        "        self.wait()\n",
        "        final_expression.add(*expression)\n",
        "\n",
        "        return final_expression\n",
        "\n",
        "    def file_away_sum(self, sum_expression):\n",
        "        if not hasattr(self, \"num_sum_expressions\"):\n",
        "            self.num_sum_expressions = 0\n",
        "        target = sum_expression.copy()\n",
        "        target.scale(self.filed_sum_scale_factor)\n",
        "        y_index = self.num_sum_expressions%self.num_rows\n",
        "        y_prop = float(y_index)/(self.num_rows-1)\n",
        "        y = interpolate(FRAME_Y_RADIUS-LARGE_BUFF, -FRAME_Y_RADIUS+LARGE_BUFF, y_prop)\n",
        "        x_index = self.num_sum_expressions//self.num_rows\n",
        "        x_spacing = FRAME_WIDTH/3\n",
        "        x = (x_index-1)*x_spacing\n",
        "\n",
        "        target.move_to(x*RIGHT + y*UP)\n",
        "\n",
        "        self.play(Transform(sum_expression, target))\n",
        "        self.wait()\n",
        "\n",
        "        self.num_sum_expressions += 1\n",
        "        self.last_sum_expression = sum_expression\n",
        "\n",
        "class ThisIsAVeryGeneralIdea(Scene):\n",
        "    def construct(self):\n",
        "        groups = OldTexText(\"Groups\")\n",
        "        groups.to_edge(UP)\n",
        "        groups.set_color(BLUE)\n",
        "\n",
        "        examples = VGroup(*list(map(TexText, [\n",
        "            \"Square matrices \\\\\\\\ \\\\small (Where $\\\\det(M) \\\\ne 0$)\",\n",
        "            \"Molecular \\\\\\\\ symmetry\",\n",
        "            \"Cryptography\",\n",
        "            \"Numbers\",\n",
        "        ])))\n",
        "        numbers = examples[-1]\n",
        "        examples.arrange(buff = LARGE_BUFF)\n",
        "        examples.set_width(FRAME_WIDTH-1)\n",
        "        examples.move_to(UP)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(groups.get_bottom(), ex.get_top(), buff = MED_SMALL_BUFF)\n",
        "            for ex in examples\n",
        "        ])\n",
        "        lines.set_color(groups.get_color())\n",
        "\n",
        "        self.add(groups)\n",
        "\n",
        "        for example, line in zip(examples, lines):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Write(example, run_time = 2)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(*examples[:-1]).fade, 0.7,\n",
        "            VGroup(*lines[:-1]).fade, 0.7,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            numbers.scale, 1.2, numbers.get_corner(UP+RIGHT),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        sub_categories = VGroup(*list(map(TexText, [\n",
        "            \"Numbers \\\\\\\\ (Additive)\",\n",
        "            \"Numbers \\\\\\\\ (Multiplicative)\",\n",
        "        ])))\n",
        "        sub_categories.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        sub_categories.next_to(numbers, DOWN, 1.5*LARGE_BUFF)\n",
        "        sub_categories.to_edge(RIGHT)\n",
        "        sub_categories[0].set_color(ADDER_COLOR)\n",
        "        sub_categories[1].set_color(MULTIPLIER_COLOR)\n",
        "\n",
        "        sub_lines = VGroup(*[\n",
        "            Line(numbers.get_bottom(), sc.get_top(), buff = MED_SMALL_BUFF)\n",
        "            for sc in sub_categories\n",
        "        ])\n",
        "        sub_lines.set_color(numbers.get_color())\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(ShowCreation, sub_lines)),\n",
        "            list(map(Write, sub_categories))\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class NumbersAsActionsQ(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Numbers are actions?\",\n",
        "            target_mode = \"confused\",\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "class AdditiveGroupOfReals(Scene):\n",
        "    CONFIG = {\n",
        "        \"number_line_center\" : UP,\n",
        "        \"shadow_line_center\" : DOWN,\n",
        "        \"zero_color\" : GREEN_B,\n",
        "        \"x_min\" : -FRAME_WIDTH,\n",
        "        \"x_max\" : FRAME_WIDTH,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_number_line()\n",
        "        self.show_example_slides(3, -7)\n",
        "        self.write_group_of_slides()\n",
        "        self.show_example_slides(2, 6, -1, -3)\n",
        "        self.mark_zero()\n",
        "        self.show_example_slides_labeled(3, -2)\n",
        "        self.comment_on_zero_as_identity()\n",
        "        self.show_example_slides_labeled(\n",
        "            5.5, added_anims = [self.get_write_name_of_group_anim()]\n",
        "        )\n",
        "        self.show_example_additions((3, 2), (2, -5), (-4, 4))\n",
        "\n",
        "    def add_number_line(self):\n",
        "        number_line = NumberLine(\n",
        "            x_min = self.x_min,\n",
        "            x_max = self.x_max,\n",
        "        )\n",
        "\n",
        "        number_line.shift(self.number_line_center)\n",
        "        shadow_line = NumberLine(color = GREY, stroke_width = 2)\n",
        "        shadow_line.shift(self.shadow_line_center)\n",
        "        for line in number_line, shadow_line:\n",
        "            line.add_numbers()\n",
        "        shadow_line.numbers.fade(0.25)\n",
        "        shadow_line.save_state()\n",
        "        shadow_line.set_color(BLACK)\n",
        "        shadow_line.move_to(number_line)\n",
        "\n",
        "\n",
        "        self.play(*list(map(Write, number_line)), run_time = 1)\n",
        "        self.play(shadow_line.restore, Animation(number_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.number_line = number_line\n",
        "        self.shadow_line = shadow_line\n",
        "\n",
        "    def show_example_slides(self, *nums):\n",
        "        for num in nums:\n",
        "            zero_point = self.number_line.number_to_point(0)            \n",
        "            num_point = self.number_line.number_to_point(num)\n",
        "            arrow = Arrow(zero_point, num_point, buff = 0)\n",
        "            arrow.set_color(ADDER_COLOR)\n",
        "            arrow.shift(MED_LARGE_BUFF*UP)\n",
        "\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.play(\n",
        "                self.number_line.shift,\n",
        "                num_point - zero_point,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.play(FadeOut(arrow))\n",
        "\n",
        "    def write_group_of_slides(self):\n",
        "        title = OldTexText(\"Group of line symmetries\")\n",
        "        title.to_edge(UP)\n",
        "        self.play(Write(title))\n",
        "        self.title = title\n",
        "\n",
        "    def mark_zero(self):\n",
        "        dot = Dot(\n",
        "            self.number_line.number_to_point(0),\n",
        "            color = self.zero_color\n",
        "        )\n",
        "        arrow = Arrow(dot, color = self.zero_color)\n",
        "        words = OldTexText(\"Follow zero\")\n",
        "        words.next_to(arrow.get_start(), UP)\n",
        "        words.set_color(self.zero_color)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            DrawBorderThenFill(dot),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [arrow, words])))\n",
        "\n",
        "        self.number_line.add(dot)\n",
        "\n",
        "    def show_example_slides_labeled(self, *nums, **kwargs):\n",
        "        for num in nums:\n",
        "            line = DashedLine(\n",
        "                self.number_line.number_to_point(num)+MED_LARGE_BUFF*UP,\n",
        "                self.shadow_line.number_to_point(num)+MED_LARGE_BUFF*DOWN,\n",
        "            )\n",
        "            vect = self.number_line.number_to_point(num) - \\\n",
        "                   self.number_line.number_to_point(0)\n",
        "            self.play(ShowCreation(line))\n",
        "            self.wait()\n",
        "            self.play(self.number_line.shift, vect, run_time = 2)\n",
        "            self.wait()\n",
        "            if \"added_anims\" in kwargs:\n",
        "                self.play(*kwargs[\"added_anims\"])\n",
        "                self.wait()\n",
        "            self.play(\n",
        "                self.number_line.shift, -vect,\n",
        "                FadeOut(line)\n",
        "            )\n",
        "\n",
        "    def comment_on_zero_as_identity(self):\n",
        "        line = DashedLine(\n",
        "            self.number_line.number_to_point(0)+MED_LARGE_BUFF*UP,\n",
        "            self.shadow_line.number_to_point(0)+MED_LARGE_BUFF*DOWN,\n",
        "        )\n",
        "        words = OldTex(\"0 \\\\leftrightarrow \\\\text{Do nothing}\")\n",
        "        words.shift(line.get_top()+MED_SMALL_BUFF*UP - words[0].get_bottom())\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [line, words])))\n",
        "\n",
        "    def get_write_name_of_group_anim(self):\n",
        "        new_title = OldTexText(\"Additive group of real numbers\")\n",
        "        VGroup(*new_title[-len(\"realnumbers\"):]).set_color(BLUE)\n",
        "        VGroup(*new_title[:len(\"Additive\")]).set_color(ADDER_COLOR)\n",
        "        new_title.to_edge(UP)\n",
        "        return Transform(self.title, new_title)\n",
        "\n",
        "    def show_example_additions(self, *num_pairs):\n",
        "        for num_pair in num_pairs:\n",
        "            num_mobs = VGroup()\n",
        "            arrows = VGroup()\n",
        "            self.number_line.save_state()\n",
        "            for num in num_pair:\n",
        "                zero_point, num_point, arrow, num_mob = \\\n",
        "                    self.get_adder_mobs(num)\n",
        "                if len(num_mobs) > 0:\n",
        "                    last_num_mob = num_mobs[0]\n",
        "                    x = num_mob.get_center()[0]\n",
        "                    if x < last_num_mob.get_right()[0] and x > last_num_mob.get_left()[0]:\n",
        "                        num_mob.next_to(last_num_mob, RIGHT)\n",
        "                num_mobs.add(num_mob)\n",
        "                arrows.add(arrow)\n",
        "\n",
        "                self.play(\n",
        "                    ShowCreation(arrow),\n",
        "                    Write(num_mob, run_time = 1)\n",
        "                )\n",
        "                self.play(\n",
        "                    self.number_line.shift, \n",
        "                    num_point - zero_point\n",
        "                )\n",
        "                self.wait()\n",
        "            #Reset\n",
        "            self.play(\n",
        "                FadeOut(num_mobs),\n",
        "                FadeOut(self.number_line)\n",
        "            )\n",
        "            ApplyMethod(self.number_line.restore).update(1)\n",
        "            self.play(FadeIn(self.number_line))\n",
        "\n",
        "            #Sum arrow\n",
        "            num = sum(num_pair)\n",
        "            zero_point, sum_point, arrow, sum_mob = \\\n",
        "                self.get_adder_mobs(sum(num_pair))\n",
        "            VGroup(arrow, sum_mob).shift(MED_LARGE_BUFF*UP)\n",
        "            arrows.add(arrow)\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                Write(sum_mob, run_time = 1)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                self.number_line.shift, \n",
        "                num_point - zero_point,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                self.number_line.restore,\n",
        "                *list(map(FadeOut, [arrows, sum_mob]))\n",
        "            )\n",
        "\n",
        "    def get_adder_mobs(self, num):\n",
        "        zero_point = self.number_line.number_to_point(0)            \n",
        "        num_point = self.number_line.number_to_point(num)\n",
        "        arrow = Arrow(zero_point, num_point, buff = 0)\n",
        "        arrow.set_color(ADDER_COLOR)\n",
        "        arrow.shift(MED_SMALL_BUFF*UP)\n",
        "        if num == 0:\n",
        "            arrow = DashedLine(UP, ORIGIN)\n",
        "            arrow.move_to(zero_point)\n",
        "        elif num < 0:\n",
        "            arrow.set_color(RED)\n",
        "            arrow.shift(SMALL_BUFF*UP)\n",
        "        sign = \"+\" if num >= 0 else \"\"\n",
        "        num_mob = OldTex(sign + str(num))\n",
        "        num_mob.next_to(arrow, UP)\n",
        "        num_mob.set_color(arrow.get_color())\n",
        "        return zero_point, num_point, arrow, num_mob\n",
        "\n",
        "class AdditiveGroupOfComplexNumbers(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -2*int(FRAME_X_RADIUS),\n",
        "        \"x_max\" : 2*int(FRAME_X_RADIUS),\n",
        "        \"y_min\" : -FRAME_HEIGHT,\n",
        "        \"y_max\" : FRAME_HEIGHT,\n",
        "        \"example_points\" : [\n",
        "            complex(3, 2),\n",
        "            complex(1, -3),\n",
        "        ]\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.show_preview_example_slides()\n",
        "        self.show_vertical_slide()\n",
        "        self.show_example_point()\n",
        "        self.show_example_addition()\n",
        "        self.write_group_name()\n",
        "        self.show_some_random_slides()\n",
        "\n",
        "    def add_plane(self):\n",
        "        self.add_transformable_plane(animate = True)\n",
        "        zero_dot = Dot(\n",
        "            self.z_to_point(0),\n",
        "            color = ADDER_COLOR\n",
        "        )\n",
        "        self.play(ShowCreation(zero_dot))\n",
        "        self.plane.add(zero_dot)\n",
        "        self.plane.zero_dot = zero_dot\n",
        "        self.wait()\n",
        "\n",
        "    def show_preview_example_slides(self):\n",
        "        example_vect = 2*UP+RIGHT\n",
        "        for vect in example_vect, -example_vect:\n",
        "            self.play(self.plane.shift, vect, run_time = 2)\n",
        "            self.wait()\n",
        "\n",
        "    def show_vertical_slide(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot(self.z_to_point(complex(0, i)))\n",
        "            for i in range(1, 4)\n",
        "        ])\n",
        "        dots.set_color(YELLOW)\n",
        "        labels = VGroup(*self.imag_labels[-3:])\n",
        "\n",
        "        arrow = Arrow(ORIGIN, dots[-1].get_center(), buff = 0)\n",
        "        arrow.set_color(ADDER_COLOR)\n",
        "\n",
        "        self.plane.save_state()\n",
        "        for dot, label in zip(dots, labels):\n",
        "            self.play(\n",
        "                Indicate(label),\n",
        "                ShowCreation(dot)\n",
        "            )\n",
        "        self.add_foreground_mobjects(dots)\n",
        "        self.wait()\n",
        "        Scene.play(self, ShowCreation(arrow))\n",
        "        self.add_foreground_mobjects(arrow)\n",
        "        self.play(\n",
        "            self.plane.shift, dots[-1].get_center(),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrow))\n",
        "        self.foreground_mobjects.remove(arrow)\n",
        "        self.play(\n",
        "            self.plane.shift, 6*DOWN,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.plane.restore, run_time = 2)\n",
        "        self.foreground_mobjects.remove(dots)\n",
        "        self.play(FadeOut(dots))\n",
        "\n",
        "    def show_example_point(self):\n",
        "        z = self.example_points[0]\n",
        "        point = self.z_to_point(z)\n",
        "        dot = Dot(point, color = YELLOW)\n",
        "        arrow = Vector(point, buff = dot.radius)\n",
        "        arrow.set_color(dot.get_color())\n",
        "        label = OldTex(\"%d + %di\"%(z.real, z.imag))\n",
        "        label.next_to(point, UP)\n",
        "        label.set_color(dot.get_color())\n",
        "        label.add_background_rectangle()\n",
        "\n",
        "        real_arrow = Vector(self.z_to_point(z.real))\n",
        "        imag_arrow = Vector(self.z_to_point(z - z.real))\n",
        "        VGroup(real_arrow, imag_arrow).set_color(ADDER_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.add_foreground_mobjects(label, dot, arrow)\n",
        "        self.wait()\n",
        "        self.slide(z)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.plane))\n",
        "        self.plane.restore()\n",
        "        self.plane.set_stroke(width = 0)\n",
        "        self.play(self.plane.restore)\n",
        "        self.play(ShowCreation(real_arrow))\n",
        "        self.add_foreground_mobjects(real_arrow)\n",
        "        self.slide(z.real)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(imag_arrow))\n",
        "        self.wait()\n",
        "        self.play(imag_arrow.shift, self.z_to_point(z.real))\n",
        "        self.add_foreground_mobjects(imag_arrow)\n",
        "        self.slide(z - z.real)\n",
        "        self.wait()\n",
        "\n",
        "        self.foreground_mobjects.remove(real_arrow)\n",
        "        self.foreground_mobjects.remove(imag_arrow)\n",
        "        self.play(*list(map(FadeOut, [real_arrow, imag_arrow, self.plane])))\n",
        "        self.plane.restore()\n",
        "        self.plane.set_stroke(width = 0)\n",
        "        self.play(self.plane.restore)\n",
        "\n",
        "        self.z1 = z\n",
        "        self.arrow1 = arrow\n",
        "        self.dot1 = dot\n",
        "        self.label1 = label\n",
        "\n",
        "    def show_example_addition(self):\n",
        "        z1 = self.z1\n",
        "        arrow1 = self.arrow1\n",
        "        dot1 = self.dot1\n",
        "        label1 = self.label1\n",
        "\n",
        "        z2 = self.example_points[1]\n",
        "        point2 = self.z_to_point(z2)\n",
        "        dot2 = Dot(point2, color = TEAL)\n",
        "        arrow2 = Vector(\n",
        "            point2, \n",
        "            buff = dot2.radius,\n",
        "            color = dot2.get_color()\n",
        "        )\n",
        "        label2 = OldTex(\n",
        "            \"%d %di\"%(z2.real, z2.imag)\n",
        "        )\n",
        "        label2.next_to(point2, UP+RIGHT)\n",
        "        label2.set_color(dot2.get_color())\n",
        "        label2.add_background_rectangle()\n",
        "\n",
        "        self.play(ShowCreation(arrow2))\n",
        "        self.play(\n",
        "            DrawBorderThenFill(dot2),\n",
        "            Write(label2)\n",
        "        )\n",
        "        self.add_foreground_mobjects(arrow2, dot2, label2)\n",
        "        self.wait()\n",
        "\n",
        "        self.slide(z1)\n",
        "        arrow2_copy = arrow2.copy()\n",
        "        self.play(arrow2_copy.shift, self.z_to_point(z1))\n",
        "        self.add_foreground_mobjects(arrow2_copy)\n",
        "        self.slide(z2)\n",
        "        self.play(FadeOut(arrow2_copy))\n",
        "        self.foreground_mobjects.remove(arrow2_copy)\n",
        "        self.wait()\n",
        "\n",
        "        ##Break into components\n",
        "        real_arrow, imag_arrow = component_arrows = [\n",
        "            Vector(\n",
        "                self.z_to_point(z),\n",
        "                color = ADDER_COLOR\n",
        "            )\n",
        "            for z in [\n",
        "                z1.real+z2.real,\n",
        "                complex(0, z1.imag+z2.imag),\n",
        "            ]\n",
        "        ]\n",
        "        imag_arrow.shift(real_arrow.get_end())\n",
        "        plus = OldTex(\"+\").next_to(\n",
        "            real_arrow.get_center(), UP+RIGHT\n",
        "        )\n",
        "        plus.add_background_rectangle()\n",
        "\n",
        "        rp1, rp2, ip1, ip2 = label_parts = [\n",
        "            VGroup(label1[1][0].copy()),\n",
        "            VGroup(label2[1][0].copy()),\n",
        "            VGroup(*label1[1][2:]).copy(),\n",
        "            VGroup(*label2[1][1:]).copy(),\n",
        "        ]\n",
        "        for part in label_parts:\n",
        "            part.generate_target()\n",
        "\n",
        "        rp1.target.next_to(plus, LEFT)\n",
        "        rp2.target.next_to(plus, RIGHT)\n",
        "        ip1.target.next_to(imag_arrow.get_center(), RIGHT)\n",
        "        ip1.target.shift(SMALL_BUFF*DOWN)\n",
        "        ip2.target.next_to(ip1.target, RIGHT)\n",
        "\n",
        "        real_background_rect = BackgroundRectangle(\n",
        "            VGroup(rp1.target, rp2.target)\n",
        "        )\n",
        "        imag_background_rect = BackgroundRectangle(\n",
        "            VGroup(ip1.target, ip2.target)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(real_arrow),\n",
        "            ShowCreation(\n",
        "                real_background_rect,\n",
        "                rate_func = squish_rate_func(smooth, 0.75, 1),\n",
        "            ),\n",
        "            Write(plus),\n",
        "            *list(map(MoveToTarget, [rp1, rp2]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(imag_arrow),\n",
        "            ShowCreation(\n",
        "                imag_background_rect,\n",
        "                rate_func = squish_rate_func(smooth, 0.75, 1),\n",
        "            ),\n",
        "            *list(map(MoveToTarget, [ip1, ip2]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        to_remove = [\n",
        "            arrow1, dot1, label1,\n",
        "            arrow2, dot2, label2,\n",
        "            real_background_rect,\n",
        "            imag_background_rect,\n",
        "            plus,\n",
        "        ] + label_parts + component_arrows\n",
        "        for mob in to_remove:\n",
        "            if mob in self.foreground_mobjects:\n",
        "                self.foreground_mobjects.remove(mob)\n",
        "        self.play(*list(map(FadeOut, to_remove)))\n",
        "        self.play(self.plane.restore, run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "    def write_group_name(self):\n",
        "        title = OldTexText(\n",
        "            \"Additive\", \"group of\", \"complex numbers\"\n",
        "        )\n",
        "        title[0].set_color(ADDER_COLOR)\n",
        "        title[2].set_color(BLUE)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.add_foreground_mobjects(title)\n",
        "        self.wait()\n",
        "\n",
        "    def show_some_random_slides(self):\n",
        "        example_slides = [\n",
        "            complex(3),\n",
        "            complex(0, 2),\n",
        "            complex(-4, -1),\n",
        "            complex(-2, -1),\n",
        "            complex(4, 2),\n",
        "        ]\n",
        "        for z in example_slides:\n",
        "            self.slide(z)\n",
        "            self.wait()\n",
        "\n",
        "    #########\n",
        "\n",
        "    def slide(self, z, *added_anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.plane.shift, self.z_to_point(z),\n",
        "                **kwargs\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "class SchizophrenicNumbers(Scene):\n",
        "    def construct(self):\n",
        "        v_line = DashedLine(\n",
        "            FRAME_Y_RADIUS*UP,\n",
        "            FRAME_Y_RADIUS*DOWN\n",
        "        )\n",
        "        left_title = OldTexText(\"Additive group\")\n",
        "        left_title.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        right_title = OldTexText(\"Multiplicative group\")\n",
        "        right_title.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        VGroup(left_title, right_title).to_edge(UP)\n",
        "        self.add(v_line, left_title, right_title)\n",
        "\n",
        "        numbers = VGroup(\n",
        "            Randolph(mode = \"happy\").scale(0.2),\n",
        "            OldTex(\"3\").shift(UP+LEFT),\n",
        "            OldTex(\"5.83\").shift(UP+RIGHT),\n",
        "            OldTex(\"\\\\sqrt{2}\").shift(DOWN+LEFT),\n",
        "            OldTex(\"2-i\").shift(DOWN+RIGHT),\n",
        "        )\n",
        "        for number in numbers:\n",
        "            number.set_color(ADDER_COLOR)\n",
        "            number.scale(1.5)            \n",
        "            if isinstance(number, PiCreature):\n",
        "                continue\n",
        "            number.eyes = Eyes(number[0], height = 0.1)\n",
        "            number.add(number.eyes)\n",
        "        numbers[3].eyes.next_to(numbers[3][1], UP, buff = 0)\n",
        "        numbers.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "\n",
        "        self.play(FadeIn(numbers))\n",
        "        self.blink_numbers(numbers)\n",
        "        self.wait()\n",
        "        self.add(numbers.copy())\n",
        "        for number in numbers:\n",
        "            number.generate_target()\n",
        "            number.target.shift(FRAME_X_RADIUS*RIGHT)\n",
        "            number.target.eyes.save_state()\n",
        "            number.target.set_color(MULTIPLIER_COLOR)\n",
        "            number.target.eyes.restore()\n",
        "        self.play(*[\n",
        "            MoveToTarget(\n",
        "                number, \n",
        "                rate_func = squish_rate_func(\n",
        "                    smooth, alpha, alpha+0.5\n",
        "                ),\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for number, alpha in zip(numbers, np.linspace(0, 0.5, len(numbers)))\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.blink_numbers(numbers)\n",
        "        self.wait()\n",
        "\n",
        "    def blink_numbers(self, numbers):\n",
        "        self.play(*[\n",
        "            num.eyes.blink_anim(\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back, alpha, alpha+0.2\n",
        "                )\n",
        "            )\n",
        "            for num, alpha in zip(\n",
        "                numbers[1:], 0.8*np.random.random(len(numbers))\n",
        "            )\n",
        "        ])\n",
        "\n",
        "class MultiplicativeGroupOfReals(AdditiveGroupOfReals):\n",
        "    CONFIG = {\n",
        "        \"number_line_center\" : 0.5*UP,\n",
        "        \"shadow_line_center\" : 1.5*DOWN,\n",
        "        \"x_min\" : -3*FRAME_X_RADIUS,\n",
        "        \"x_max\" : 3*FRAME_X_RADIUS,\n",
        "        \"positive_reals_color\" : MAROON_B,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.foreground_mobjects = VGroup()\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_number_line()\n",
        "        self.introduce_stretch_and_squish()\n",
        "        self.show_zero_fixed_in_place()\n",
        "        self.follow_one()\n",
        "        self.every_positive_number_association()\n",
        "        self.compose_actions(3, 2)\n",
        "        self.compose_actions(4, 0.5)\n",
        "        self.write_group_name()\n",
        "        self.compose_actions(1.5, 1.5)\n",
        "\n",
        "    def add_title(self):\n",
        "        self.title = OldTexText(\"Group of stretching/squishing actions\")\n",
        "        self.title.to_edge(UP)\n",
        "        self.add(self.title)\n",
        "\n",
        "    def add_number_line(self):\n",
        "        AdditiveGroupOfReals.add_number_line(self)\n",
        "        self.zero_point = self.number_line.number_to_point(0)\n",
        "        self.one = [m for m in self.number_line.numbers if m.get_tex() is \"1\"][0]\n",
        "        self.one.add_background_rectangle()\n",
        "        self.one.background_rectangle.scale(1.3)\n",
        "        self.number_line.save_state()        \n",
        "\n",
        "    def introduce_stretch_and_squish(self):\n",
        "        for num in [3, 0.25]:\n",
        "            self.stretch(num)\n",
        "            self.wait()\n",
        "        self.play(self.number_line.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def show_zero_fixed_in_place(self):\n",
        "        arrow = Arrow(self.zero_point + UP, self.zero_point, buff = 0)\n",
        "        arrow.set_color(ADDER_COLOR)\n",
        "        words = OldTexText(\"Fix zero\")\n",
        "        words.set_color(ADDER_COLOR)\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.foreground_mobjects.add(arrow)\n",
        "        self.stretch(4)\n",
        "        self.stretch(0.1)\n",
        "        self.wait()\n",
        "        self.play(self.number_line.restore)\n",
        "        self.play(FadeOut(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.zero_arrow = arrow\n",
        "\n",
        "    def follow_one(self):\n",
        "        dot = Dot(self.number_line.number_to_point(1))\n",
        "        arrow = Arrow(dot.get_center()+UP+RIGHT, dot)\n",
        "        words = OldTexText(\"Follow one\")\n",
        "        words.next_to(arrow.get_start(), UP)\n",
        "        for mob in dot, arrow, words:\n",
        "            mob.set_color(MULTIPLIER_COLOR)\n",
        "\n",
        "        three_line, half_line = [\n",
        "            DashedLine(\n",
        "                self.number_line.number_to_point(num),\n",
        "                self.shadow_line.number_to_point(num)\n",
        "            )\n",
        "            for num in (3, 0.5)\n",
        "        ]\n",
        "        three_mob = [m for m in self.shadow_line.numbers if m.get_tex() == \"3\"][0]\n",
        "        half_point = self.shadow_line.number_to_point(0.5)\n",
        "        half_arrow = Arrow(\n",
        "            half_point+UP+LEFT, half_point, buff = SMALL_BUFF,\n",
        "            tip_length = 0.15,\n",
        "        )\n",
        "        half_label = OldTex(\"1/2\")\n",
        "        half_label.scale(0.7)\n",
        "        half_label.set_color(MULTIPLIER_COLOR)\n",
        "        half_label.next_to(half_arrow.get_start(), LEFT, buff = SMALL_BUFF)\n",
        "        \n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            DrawBorderThenFill(dot),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.number_line.add(dot)\n",
        "        self.number_line.numbers.add(dot)\n",
        "        self.number_line.save_state()\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [arrow, words])))\n",
        "\n",
        "        self.stretch(3)\n",
        "        self.play(\n",
        "            ShowCreation(three_line),\n",
        "            Animation(self.one)\n",
        "        )\n",
        "        dot_copy = dot.copy()\n",
        "        self.play(\n",
        "            dot_copy.move_to, three_line.get_bottom()\n",
        "        )\n",
        "        self.play(Indicate(three_mob, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.number_line.restore,\n",
        "            *list(map(FadeOut, [three_line, dot_copy]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.stretch(0.5)\n",
        "        self.play(\n",
        "            ShowCreation(half_line),\n",
        "            Animation(self.one)\n",
        "        )\n",
        "        dot_copy = dot.copy()\n",
        "        self.play(\n",
        "            dot_copy.move_to, half_line.get_bottom()\n",
        "        )\n",
        "        self.play(\n",
        "            Write(half_label),\n",
        "            ShowCreation(half_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.number_line.restore,\n",
        "            *list(map(FadeOut, [\n",
        "                half_label, half_arrow, \n",
        "                half_line, dot_copy\n",
        "            ]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.one_dot = dot\n",
        "\n",
        "    def every_positive_number_association(self):\n",
        "        positive_reals_line = Line(\n",
        "            self.shadow_line.number_to_point(0),\n",
        "            self.shadow_line.number_to_point(FRAME_X_RADIUS),\n",
        "            color = self.positive_reals_color\n",
        "        )\n",
        "        positive_reals_words = OldTexText(\"All positive reals\")\n",
        "        positive_reals_words.set_color(self.positive_reals_color)\n",
        "        positive_reals_words.next_to(positive_reals_line, UP)\n",
        "        positive_reals_words.add_background_rectangle()\n",
        "\n",
        "        third_line, one_line = [\n",
        "            DashedLine(\n",
        "                self.number_line.number_to_point(num),\n",
        "                self.shadow_line.number_to_point(num)\n",
        "            )\n",
        "            for num in (0.33, 1)\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            self.zero_arrow.shift, 0.5*UP,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.one_dot.shift, 0.25*UP,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.stretch(3)\n",
        "        self.stretch(0.33/3, run_time = 3)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(third_line), Animation(self.one))\n",
        "        self.play(\n",
        "            ShowCreation(positive_reals_line),\n",
        "            Write(positive_reals_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(third_line, one_line),\n",
        "            self.number_line.restore,\n",
        "            Animation(positive_reals_words),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.number_line.add_to_back(one_line)\n",
        "        self.number_line.save_state()\n",
        "        self.stretch(\n",
        "            7, run_time = 10, rate_func = there_and_back,\n",
        "            added_anims = [Animation(positive_reals_words)]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def compose_actions(self, num1, num2):\n",
        "        words = VGroup(*[\n",
        "            OldTexText(\"(%s by %s)\"%(word, str(num)))\n",
        "            for num in (num1, num2, num1*num2)\n",
        "            for word in [\"Stretch\" if num > 1 else \"Squish\"]\n",
        "        ])\n",
        "        words.submobjects.insert(2, OldTex(\"=\"))\n",
        "        words.arrange(RIGHT)\n",
        "        top_words = VGroup(*words[:2])\n",
        "        top_words.set_color(MULTIPLIER_COLOR)\n",
        "        bottom_words = VGroup(*words[2:])\n",
        "        bottom_words.next_to(top_words, DOWN)\n",
        "        words.scale(0.8)\n",
        "        words.next_to(self.number_line, UP)\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        for num, word in zip([num1, num2], top_words):\n",
        "            self.stretch(\n",
        "                num, \n",
        "                added_anims = [FadeIn(word)],\n",
        "                run_time = 3\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Write(bottom_words, run_time = 2))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ApplyMethod(self.number_line.restore, run_time = 2),\n",
        "            FadeOut(words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_group_name(self):\n",
        "        new_title = OldTexText(\n",
        "            \"Multiplicative group of positive real numbers\"\n",
        "        )\n",
        "        new_title.to_edge(UP)\n",
        "        VGroup(\n",
        "            *new_title[:len(\"Multiplicative\")]\n",
        "        ).set_color(MULTIPLIER_COLOR)\n",
        "        VGroup(\n",
        "            *new_title[-len(\"positiverealnumbers\"):]\n",
        "        ).set_color(self.positive_reals_color)\n",
        "\n",
        "        self.play(Transform(self.title, new_title))\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def stretch(self, factor, run_time = 2, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        target = self.number_line.copy()\n",
        "        target.stretch_about_point(factor, 0, self.zero_point)\n",
        "        total_factor = (target.number_to_point(1)-self.zero_point)[0]\n",
        "        for number in target.numbers:\n",
        "            number.stretch_in_place(1./factor, dim = 0)\n",
        "            if total_factor < 0.7:\n",
        "                number.stretch_in_place(total_factor, dim = 0)\n",
        "        self.play(\n",
        "            Transform(self.number_line, target, **kwargs),\n",
        "            *kwargs.get(\"added_anims\", [])\n",
        "        )\n",
        "\n",
        "    def play(self, *anims, **kwargs):\n",
        "        anims = list(anims) + [Animation(self.foreground_mobjects)]\n",
        "        Scene.play(self, *anims, **kwargs)\n",
        "\n",
        "class MultiplicativeGroupOfComplexNumbers(AdditiveGroupOfComplexNumbers):\n",
        "    CONFIG = {\n",
        "        \"dot_radius\" : Dot.CONFIG[\"radius\"],\n",
        "        \"y_min\" : -3*FRAME_Y_RADIUS,\n",
        "        \"y_max\" : 3*FRAME_Y_RADIUS,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.fix_zero_and_move_one()\n",
        "        self.show_example_actions()\n",
        "        self.show_action_at_i()\n",
        "        self.show_action_at_i_again()\n",
        "        self.show_i_squared_is_negative_one()\n",
        "        self.talk_through_specific_example()\n",
        "        self.show_break_down()\n",
        "        self.example_actions_broken_down()\n",
        "\n",
        "    def add_plane(self):\n",
        "        AdditiveGroupOfComplexNumbers.add_plane(self)\n",
        "        one_dot = Dot(\n",
        "            self.z_to_point(1), \n",
        "            color = MULTIPLIER_COLOR,\n",
        "            radius = self.dot_radius,\n",
        "        )\n",
        "        self.plane.add(one_dot)\n",
        "        self.plane.one_dot = one_dot\n",
        "        self.plane.save_state()\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            \"Multiplicative\", \"group of\", \n",
        "            \"complex numbers\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        title[0].set_color(MULTIPLIER_COLOR)\n",
        "        title[2].set_color(BLUE)\n",
        "        title.add_background_rectangle()\n",
        "\n",
        "        self.play(Write(title, run_time = 2))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def fix_zero_and_move_one(self):\n",
        "        zero_arrow = Arrow(\n",
        "            UP+1.25*LEFT, ORIGIN, \n",
        "            buff = 2*self.dot_radius\n",
        "        )\n",
        "        zero_arrow.set_color(ADDER_COLOR)\n",
        "        zero_words = OldTexText(\"Fix zero\")\n",
        "        zero_words.set_color(ADDER_COLOR)\n",
        "        zero_words.add_background_rectangle()\n",
        "        zero_words.next_to(zero_arrow.get_start(), UP)\n",
        "\n",
        "        one_point = self.z_to_point(1)\n",
        "        one_arrow = Arrow(\n",
        "            one_point+UP+1.25*RIGHT, one_point, \n",
        "            buff = 2*self.dot_radius,\n",
        "            color = MULTIPLIER_COLOR,\n",
        "        )\n",
        "        one_words = OldTexText(\"Drag one\")\n",
        "        one_words.set_color(MULTIPLIER_COLOR)\n",
        "        one_words.add_background_rectangle()\n",
        "        one_words.next_to(one_arrow.get_start(), UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(zero_words, run_time = 2),\n",
        "            ShowCreation(zero_arrow),\n",
        "            Indicate(self.plane.zero_dot, color = RED),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(one_words, run_time = 2),\n",
        "            ShowCreation(one_arrow),\n",
        "            Indicate(self.plane.one_dot, color = RED),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            zero_words, zero_arrow,\n",
        "            one_words, one_arrow,\n",
        "        ])))\n",
        "\n",
        "    def show_example_actions(self):\n",
        "        z_list = [\n",
        "            complex(2),\n",
        "            complex(0.5),\n",
        "            complex(2, 1),\n",
        "            complex(-2, 2),\n",
        "        ]\n",
        "        for last_z, z in zip([1] + z_list, z_list):\n",
        "            self.multiply_by_z(z/last_z)\n",
        "            self.wait()\n",
        "        self.reset_plane()\n",
        "        self.wait()\n",
        "\n",
        "    def show_action_at_i(self):\n",
        "        i_point = self.z_to_point(complex(0, 1))\n",
        "        i_dot = Dot(i_point)\n",
        "        i_dot.set_color(RED)\n",
        "        i_arrow = Arrow(i_point+UP+LEFT, i_point)\n",
        "        i_arrow.set_color(i_dot.get_color())\n",
        "\n",
        "        arc = Arc(\n",
        "            start_angle = np.pi/24,\n",
        "            angle = 10*np.pi/24,\n",
        "            radius = self.z_to_point(1)[0],\n",
        "            num_anchors = 20,\n",
        "        )\n",
        "        arc.add_tip(tip_length = 0.15)\n",
        "        arc.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(i_arrow),\n",
        "            DrawBorderThenFill(i_dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(i_arrow),\n",
        "            ShowCreation(arc)\n",
        "        )\n",
        "        self.add_foreground_mobjects(arc)\n",
        "        self.wait(2)\n",
        "        self.multiply_by_z(complex(0, 1), run_time = 3)\n",
        "        self.remove(i_dot)\n",
        "        self.wait()\n",
        "\n",
        "        self.turn_arrow = arc\n",
        "\n",
        "    def show_action_at_i_again(self):\n",
        "        neg_one_label = [m for m in self.real_labels if m.get_tex() == \"-1\"][0]\n",
        "        half_turn_arc = Arc(\n",
        "            start_angle = np.pi/12,\n",
        "            angle = 10*np.pi/12,\n",
        "            color = self.turn_arrow.get_color()\n",
        "        )\n",
        "        half_turn_arc.add_tip(tip_length = 0.15)\n",
        "\n",
        "        self.multiply_by_z(complex(0, 1), run_time = 3)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            self.turn_arrow, half_turn_arc,\n",
        "            path_arc = np.pi/2\n",
        "        ))\n",
        "        self.wait()        \n",
        "        self.play(Indicate(neg_one_label, run_time = 2))\n",
        "        self.wait()\n",
        "        self.foreground_mobjects.remove(self.turn_arrow)\n",
        "        self.reset_plane(FadeOut(self.turn_arrow))\n",
        "\n",
        "    def show_i_squared_is_negative_one(self):\n",
        "        equation = OldTex(\"i\", \"\\\\cdot\", \"i\", \"=\", \"-1\")\n",
        "        terms = equation[::2]\n",
        "        equation.add_background_rectangle()\n",
        "        equation.next_to(ORIGIN, RIGHT)\n",
        "        equation.shift(1.5*UP)\n",
        "        equation.set_color(MULTIPLIER_COLOR)\n",
        "\n",
        "        self.play(Write(equation, run_time = 2))\n",
        "        self.wait()\n",
        "        for term in terms[:2]:\n",
        "            self.multiply_by_z(\n",
        "                complex(0, 1),\n",
        "                added_anims = [\n",
        "                    Animation(equation),\n",
        "                    Indicate(term, color = RED, run_time = 2)\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Indicate(terms[-1], color = RED, run_time = 2))\n",
        "        self.wait()\n",
        "        self.reset_plane(FadeOut(equation))\n",
        "\n",
        "    def talk_through_specific_example(self):\n",
        "        z = complex(2, 1)\n",
        "        angle = np.angle(z)\n",
        "        point = self.z_to_point(z)\n",
        "        dot = Dot(point, color = WHITE)\n",
        "        label = OldTex(\"%d + %di\"%(z.real, z.imag))\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, UP+RIGHT, buff = 0)\n",
        "\n",
        "        brace = Brace(\n",
        "            Line(ORIGIN, self.z_to_point(np.sqrt(5))),\n",
        "            UP\n",
        "        )\n",
        "        brace_text = brace.get_text(\"$\\\\sqrt{5}$\")\n",
        "        brace_text.add_background_rectangle()\n",
        "        brace_text.scale(0.7, about_point = brace.get_top())\n",
        "        brace.rotate(angle)\n",
        "        brace_text.rotate(angle).rotate(-angle)\n",
        "        VGroup(brace, brace_text).set_color(MAROON_B)\n",
        "        arc = Arc(angle, color = WHITE, radius = 0.5)\n",
        "        angle_label = OldTex(\"30^\\\\circ\")\n",
        "        angle_label.scale(0.7)\n",
        "        angle_label.next_to(\n",
        "            arc, RIGHT, \n",
        "            buff = SMALL_BUFF, aligned_edge = DOWN\n",
        "        )\n",
        "        angle_label.set_color(MULTIPLIER_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.add_foreground_mobjects(label, dot)\n",
        "        self.wait()\n",
        "        self.multiply_by_z(z, run_time = 3)\n",
        "        self.wait()\n",
        "        self.reset_plane()\n",
        "        self.multiply_by_z(\n",
        "            np.exp(complex(0, 1)*angle),\n",
        "            added_anims = [\n",
        "                ShowCreation(arc, run_time = 2),\n",
        "                Write(angle_label)\n",
        "            ]\n",
        "        )\n",
        "        self.add_foreground_mobjects(arc, angle_label)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.add_foreground_mobjects(brace, brace_text)\n",
        "        self.multiply_by_z(np.sqrt(5), run_time = 3)\n",
        "        self.wait(2)\n",
        "        to_remove = [\n",
        "            label, dot,\n",
        "            brace, brace_text, \n",
        "            arc, angle_label,\n",
        "        ]\n",
        "        for mob in to_remove:\n",
        "            self.foreground_mobjects.remove(mob)\n",
        "        self.reset_plane(*list(map(FadeOut, to_remove)))\n",
        "        self.wait()\n",
        "\n",
        "    def show_break_down(self):\n",
        "        positive_reals = Line(ORIGIN, FRAME_X_RADIUS*RIGHT)\n",
        "        positive_reals.set_color(MAROON_B)\n",
        "        circle = Circle(\n",
        "            radius = self.z_to_point(1)[0],\n",
        "            color = MULTIPLIER_COLOR\n",
        "        )\n",
        "        real_actions = [3, 0.5, 1]\n",
        "        rotation_actions = [\n",
        "            np.exp(complex(0, angle))\n",
        "            for angle in np.linspace(0, 2*np.pi, 4)[1:]\n",
        "        ]\n",
        "\n",
        "        self.play(ShowCreation(positive_reals))\n",
        "        self.add_foreground_mobjects(positive_reals)\n",
        "        for last_z, z in zip([1]+real_actions, real_actions):\n",
        "            self.multiply_by_z(z/last_z)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.add_foreground_mobjects(circle)\n",
        "        for last_z, z in zip([1]+rotation_actions, rotation_actions):\n",
        "            self.multiply_by_z(z/last_z, run_time = 3)\n",
        "        self.wait()\n",
        "\n",
        "    def example_actions_broken_down(self):\n",
        "        z_list = [\n",
        "            complex(2, -1),\n",
        "            complex(-2, -3),\n",
        "            complex(0.5, 0.5),\n",
        "        ]\n",
        "        for z in z_list:\n",
        "            dot = Dot(self.z_to_point(z))\n",
        "            dot.set_color(WHITE)\n",
        "            dot.save_state()\n",
        "            dot.move_to(self.plane.one_dot)\n",
        "            dot.set_fill(opacity = 1)\n",
        "\n",
        "            norm = np.abs(z)\n",
        "            angle = np.angle(z)\n",
        "            rot_z = np.exp(complex(0, angle))\n",
        "\n",
        "            self.play(dot.restore)\n",
        "            self.multiply_by_z(norm)\n",
        "            self.wait()\n",
        "            self.multiply_by_z(rot_z)\n",
        "            self.wait()\n",
        "            self.reset_plane(FadeOut(dot))\n",
        "\n",
        "    ##\n",
        "\n",
        "    def multiply_by_z(self, z, run_time = 2, **kwargs):\n",
        "        target = self.plane.copy()\n",
        "        target.apply_complex_function(lambda w : z*w)\n",
        "        for dot in target.zero_dot, target.one_dot:\n",
        "            dot.set_width(2*self.dot_radius)\n",
        "        angle = np.angle(z)\n",
        "        kwargs[\"path_arc\"] = kwargs.get(\"path_arc\", angle)\n",
        "        self.play(\n",
        "            Transform(self.plane, target, run_time = run_time, **kwargs),\n",
        "            *kwargs.get(\"added_anims\", [])\n",
        "        )\n",
        "\n",
        "    def reset_plane(self, *added_anims):\n",
        "        self.play(FadeOut(self.plane), *added_anims)\n",
        "        self.plane.restore()\n",
        "        self.play(FadeIn(self.plane))\n",
        "\n",
        "class ExponentsAsRepeatedMultiplication(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.show_repeated_multiplication()\n",
        "        self.show_non_counting_exponents()\n",
        "\n",
        "    def show_repeated_multiplication(self):\n",
        "        three_twos = OldTex(\"2 \\\\cdot 2 \\\\cdot 2\")\n",
        "        five_twos = OldTex(\"2 \\\\cdot \"*4 + \"2\")\n",
        "        exponents = []\n",
        "        teacher_corner = self.get_teacher().get_corner(UP+LEFT)\n",
        "        for twos in three_twos, five_twos:\n",
        "            twos.next_to(teacher_corner, UP)\n",
        "            twos.generate_target()\n",
        "            d = sum(np.array(list(twos.get_tex())) == \"2\")\n",
        "            exponents.append(d)\n",
        "            twos.brace = Brace(twos, UP)\n",
        "            twos.exp = twos.brace.get_text(\"$2^%d$\"%d)\n",
        "            twos.generate_target()\n",
        "            twos.brace_anim = MaintainPositionRelativeTo(\n",
        "                VGroup(twos.brace, twos.exp), twos\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(three_twos.brace),\n",
        "            Write(three_twos.exp),\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        for mob in three_twos:\n",
        "            self.play(Write(mob, run_time = 1))\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(five_twos.brace),\n",
        "            FadeIn(five_twos.exp),\n",
        "            three_twos.center,\n",
        "            three_twos.to_edge, UP, 2*LARGE_BUFF,\n",
        "            three_twos.brace_anim,\n",
        "        )\n",
        "        self.play(FadeIn(\n",
        "            five_twos, \n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        cdot = OldTex(\"\\\\cdot\")\n",
        "        lhs = OldTex(\"2^{%d + %d} = \"%tuple(exponents))\n",
        "        rule = VGroup(\n",
        "            lhs, three_twos.target, cdot, five_twos.target\n",
        "        )\n",
        "        rule.arrange()\n",
        "        lhs.next_to(three_twos.target, LEFT, aligned_edge = DOWN)\n",
        "        rule.next_to(self.get_pi_creatures(), UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(three_twos),\n",
        "            three_twos.brace_anim,\n",
        "            MoveToTarget(five_twos),\n",
        "            five_twos.brace_anim,\n",
        "            Write(cdot),\n",
        "            self.get_teacher().change_mode, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(lhs))\n",
        "        self.wait()\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "        general_equation = OldTex(\"2^{x+y}=\", \"2^x\", \"2^y\")\n",
        "        general_equation.to_edge(UP, buff = MED_LARGE_BUFF)\n",
        "        general_equation[0].set_color(GREEN_B)\n",
        "        VGroup(*general_equation[1:]).set_color(MULTIPLIER_COLOR)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mob.copy(), term, run_time = 2\n",
        "            )\n",
        "            for term, mob in zip(general_equation, [\n",
        "                lhs, three_twos.exp, five_twos.exp\n",
        "            ])\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        self.exponential_rule = general_equation\n",
        "        self.expanded_exponential_rule = VGroup(\n",
        "            lhs, three_twos, three_twos.brace, three_twos.exp,\n",
        "            cdot, five_twos, five_twos.brace, five_twos.exp,\n",
        "        )\n",
        "\n",
        "    def show_non_counting_exponents(self):\n",
        "        self.play(\n",
        "            self.expanded_exponential_rule.scale, 0.5,\n",
        "            self.expanded_exponential_rule.to_corner, UP+LEFT\n",
        "        )\n",
        "        half_power, neg_power, imag_power = alt_powers = VGroup(\n",
        "            OldTex(\"2^{1/2}\"),\n",
        "            OldTex(\"2^{-1}\"),\n",
        "            OldTex(\"2^{i}\"),\n",
        "        )\n",
        "        alt_powers.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        alt_powers.next_to(self.get_students(), UP, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(half_power, run_time = 2),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"pondering\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        for mob in alt_powers[1:]:\n",
        "            self.play(Write(mob, run_time = 1))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, \"confused\", pi.look_at, half_power]\n",
        "            for pi in self.get_students()\n",
        "        ]))\n",
        "        for power in alt_powers[:2]:\n",
        "            self.play(Indicate(power))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.teacher_says(\"Extend the \\\\\\\\ definition\")\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.wait()\n",
        "\n",
        "        half_expression = OldTex(\n",
        "            \"\\\\big(\", \"2^{1/2}\", \"\\\\big)\", \n",
        "            \"\\\\big(2^{1/2}\\\\big) = 2^{1}\"\n",
        "        )\n",
        "        neg_one_expression = OldTex(\n",
        "            \"\\\\big(\", \"2^{-1}\", \"\\\\big)\", \n",
        "            \"\\\\big( 2^{1} \\\\big) = 2^{0}\"\n",
        "        )\n",
        "        expressions = VGroup(half_expression, neg_one_expression)\n",
        "        expressions.arrange(\n",
        "            DOWN, aligned_edge = LEFT, buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        expressions.next_to(self.get_students(), UP, buff = LARGE_BUFF)\n",
        "        expressions.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Transform(half_power, half_expression[1]),\n",
        "            Write(half_expression),            \n",
        "            RemovePiCreatureBubble(self.get_teacher()),            \n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(neg_power, neg_one_expression[1]),\n",
        "            Write(neg_one_expression)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.exponential_rule.next_to,\n",
        "            self.get_teacher().get_corner(UP+LEFT), UP, MED_LARGE_BUFF,\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            imag_power.move_to, UP,\n",
        "            imag_power.scale, 1.5,\n",
        "            imag_power.set_color, BLUE,\n",
        "            self.exponential_rule.to_edge, RIGHT,\n",
        "            self.get_teacher().change_mode, \"speaking\"\n",
        "        )\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, \"pondering\", pi.look_at, imag_power]\n",
        "            for pi in self.get_students()\n",
        "        ]))\n",
        "        self.wait()\n",
        "\n",
        "        group_theory_words = OldTexText(\"Group theory?\")\n",
        "        group_theory_words.next_to(\n",
        "            self.exponential_rule, UP, buff = LARGE_BUFF\n",
        "        )\n",
        "        arrow = Arrow(\n",
        "            group_theory_words,\n",
        "            self.exponential_rule,\n",
        "            color = WHITE,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        group_theory_words.shift_onto_screen()\n",
        "        self.play(\n",
        "            Write(group_theory_words), \n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ExponentsAsHomomorphism(Scene):\n",
        "    CONFIG = {\n",
        "        \"top_line_center\" : 2.5*UP,\n",
        "        \"top_line_config\" : {\n",
        "            \"x_min\" : -16,\n",
        "            \"x_max\" : 16,\n",
        "        },\n",
        "        \"bottom_line_center\" : 2.5*DOWN,\n",
        "        \"bottom_line_config\" : {\n",
        "            \"x_min\" : -FRAME_WIDTH,\n",
        "            \"x_max\" : FRAME_WIDTH,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.comment_on_equation()\n",
        "        self.show_adders()\n",
        "        self.show_multipliers()\n",
        "        self.confused_at_mapping()\n",
        "        self.talk_through_composition()\n",
        "        self.add_quote()\n",
        "\n",
        "    def comment_on_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"2\", \"^{x\", \"+\", \"y}\", \"=\", \"2^x\", \"2^y\"\n",
        "        )\n",
        "        lhs = VGroup(*equation[:4])\n",
        "        rhs = VGroup(*equation[5:])\n",
        "        lhs_brace = Brace(lhs, UP)\n",
        "        lhs_text = lhs_brace.get_text(\"Add inputs\")\n",
        "        lhs_text.set_color(GREEN_B)\n",
        "        rhs_brace = Brace(rhs, DOWN)\n",
        "        rhs_text = rhs_brace.get_text(\"Multiply outputs\")\n",
        "        rhs_text.set_color(MULTIPLIER_COLOR)\n",
        "\n",
        "        self.add(equation)\n",
        "        for brace, text in (lhs_brace, lhs_text), (rhs_brace, rhs_text):\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "        self.lhs_brace_group = VGroup(lhs_brace, lhs_text)\n",
        "        self.rhs_brace_group = VGroup(rhs_brace, rhs_text)\n",
        "\n",
        "    def show_adders(self):\n",
        "        equation = self.equation\n",
        "        adders = VGroup(equation[1], equation[3]).copy()\n",
        "        top_line = NumberLine(**self.top_line_config)\n",
        "        top_line.add_numbers()\n",
        "        top_line.shift(self.top_line_center)\n",
        "\n",
        "        self.play(\n",
        "            adders.scale, 1.5,\n",
        "            adders.center,\n",
        "            adders.space_out_submobjects, 2,\n",
        "            adders.to_edge, UP,\n",
        "            adders.set_color, GREEN_B,\n",
        "            FadeOut(self.lhs_brace_group),\n",
        "            Write(top_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in 3, 5, -8:\n",
        "            self.play(top_line.shift, x*RIGHT, run_time = 2)\n",
        "            self.wait()\n",
        "\n",
        "        self.top_line = top_line\n",
        "        self.adders = adders\n",
        "\n",
        "    def show_multipliers(self):\n",
        "        equation = self.equation\n",
        "        multipliers = VGroup(*self.equation[-2:]).copy()\n",
        "\n",
        "        bottom_line = NumberLine(**self.bottom_line_config)\n",
        "        bottom_line.add_numbers()\n",
        "        bottom_line.shift(self.bottom_line_center)\n",
        "\n",
        "        self.play(\n",
        "            multipliers.space_out_submobjects, 4,\n",
        "            multipliers.next_to, self.bottom_line_center, \n",
        "                UP, MED_LARGE_BUFF,\n",
        "            multipliers.set_color, YELLOW,\n",
        "            FadeOut(self.rhs_brace_group),\n",
        "            Write(bottom_line),\n",
        "        )\n",
        "        stretch_kwargs = {\n",
        "        }\n",
        "        for x in 3, 1./5, 5./3:\n",
        "            self.play(\n",
        "                self.get_stretch_anim(bottom_line, x),\n",
        "                run_time = 3\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.bottom_line = bottom_line\n",
        "        self.multipliers = multipliers\n",
        "\n",
        "    def confused_at_mapping(self):\n",
        "        arrow = Arrow(\n",
        "            self.top_line.get_bottom()[1]*UP,\n",
        "            self.bottom_line.get_top()[1]*UP,\n",
        "            color = WHITE\n",
        "        )\n",
        "        randy = Randolph(mode = \"confused\")\n",
        "        randy.scale(0.75)\n",
        "        randy.flip()\n",
        "        randy.next_to(arrow, RIGHT, LARGE_BUFF)\n",
        "        randy.look_at(arrow.get_top())\n",
        "\n",
        "        self.play(self.equation.to_edge, LEFT)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(randy.look_at, arrow.get_bottom())\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        for x in 1, -2, 3, 1, -3:\n",
        "            self.play(\n",
        "                self.get_stretch_anim(self.bottom_line, 2**x),\n",
        "                self.top_line.shift, x*RIGHT,\n",
        "                randy.look_at, self.top_line,\n",
        "                run_time = 2\n",
        "            )\n",
        "            if random.random() < 0.3:\n",
        "                self.play(Blink(randy))\n",
        "            else:\n",
        "                self.wait()\n",
        "\n",
        "        self.randy = randy\n",
        "\n",
        "    def talk_through_composition(self):\n",
        "        randy = self.randy\n",
        "        terms = list(self.adders) + list(self.multipliers)\n",
        "        inputs = [-1, 2]\n",
        "        target_texs = list(map(str, inputs))\n",
        "        target_texs += [\"2^{%d}\"%x for x in inputs]\n",
        "        for mob, target_tex in zip(terms, target_texs):\n",
        "            target = OldTex(target_tex)\n",
        "            target.set_color(mob[0].get_color())\n",
        "            target.move_to(mob, DOWN)\n",
        "            if mob in self.adders:\n",
        "                target.to_edge(UP)\n",
        "            mob.target = target\n",
        "\n",
        "        self.play(\n",
        "            self.equation.next_to, ORIGIN, LEFT, MED_LARGE_BUFF,\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, self.equation\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(randy.look_at, self.top_line)\n",
        "        self.show_composition(\n",
        "            *inputs,\n",
        "            parallel_anims = list(map(MoveToTarget, self.adders))\n",
        "        )\n",
        "        self.play(\n",
        "            FocusOn(self.bottom_line_center),\n",
        "            randy.look_at, self.bottom_line_center,\n",
        "        )\n",
        "        self.show_composition(\n",
        "            *inputs,\n",
        "            parallel_anims = list(map(MoveToTarget, self.multipliers))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_quote(self):\n",
        "        brace = Brace(self.equation, UP)\n",
        "        quote = OldTexText(\"``Preserves the group structure''\")\n",
        "        quote.add_background_rectangle()\n",
        "        quote.next_to(brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(quote),\n",
        "            self.randy.look_at, quote,\n",
        "        )\n",
        "        self.play(self.randy.change_mode, \"thinking\")\n",
        "        self.play(Blink(self.randy))\n",
        "        self.wait()\n",
        "        self.show_composition(-1, 2)\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def show_composition(self, *inputs, **kwargs):\n",
        "        parallel_anims = kwargs.get(\"parallel_anims\", [])\n",
        "        for x in range(len(inputs) - len(parallel_anims)):\n",
        "            parallel_anims.append(Animation(Mobject()))\n",
        "\n",
        "        for line in self.top_line, self.bottom_line:\n",
        "            line.save_state()\n",
        "\n",
        "        for x, parallel_anim in zip(inputs, parallel_anims):\n",
        "            anims = [\n",
        "                ApplyMethod(self.top_line.shift, x*RIGHT),\n",
        "                self.get_stretch_anim(self.bottom_line, 2**x),\n",
        "            ]\n",
        "            for anim in anims:\n",
        "                anim.set_run_time(2)\n",
        "            self.play(parallel_anim)\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "        self.play(*[\n",
        "            line.restore \n",
        "            for line in (self.top_line, self.bottom_line)\n",
        "        ])\n",
        "\n",
        "    def get_stretch_anim(self, bottom_line, x):\n",
        "        target = bottom_line.copy()\n",
        "        target.stretch_about_point(\n",
        "            x, 0, self.bottom_line_center,\n",
        "        )\n",
        "        for number in target.numbers:\n",
        "            number.stretch_in_place(1./x, dim = 0)\n",
        "        return Transform(bottom_line, target)\n",
        "\n",
        "class DihedralCubeHomomorphism(GroupOfCubeSymmetries, SymmetriesOfSquare):\n",
        "    def construct(self):\n",
        "        angle_axis_pairs = [\n",
        "            (np.pi/2, OUT),\n",
        "            (np.pi, RIGHT),\n",
        "            (np.pi, OUT),\n",
        "            (np.pi, UP+RIGHT),\n",
        "            (-np.pi/2, OUT),\n",
        "            (np.pi, UP+LEFT),\n",
        "        ]\n",
        "        angle_axis_pairs *= 3\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"``\", \"Homo\", \"morph\", \"ism\", \"''\", \n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        homo_brace = Brace(title[1], UP, buff = SMALL_BUFF)\n",
        "        homo_def = homo_brace.get_text(\"same\")\n",
        "        morph_brace = Brace(title[2], UP, buff = SMALL_BUFF)\n",
        "        morph_def = morph_brace.get_text(\"shape\", buff = SMALL_BUFF)\n",
        "        def_group = VGroup(\n",
        "            homo_brace, homo_def, \n",
        "            morph_brace, morph_def\n",
        "        )\n",
        "        VGroup(title, def_group).to_edge(UP)\n",
        "        homo_group = VGroup(title[1], homo_brace, homo_def)\n",
        "        morph_group = VGroup(title[2], morph_brace, morph_def)\n",
        "\n",
        "        equation = OldTex(\"f(X \\\\circ Y) = f(X) \\\\circ f(Y)\")\n",
        "        equation.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title, equation)\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        cube = self.get_cube()\n",
        "        cube.next_to(arrow, RIGHT)\n",
        "        pose_matrix = self.get_pose_matrix()\n",
        "\n",
        "        square = self.square = Square(**self.square_config)\n",
        "        self.add_randy_to_square(square)\n",
        "        square.next_to(arrow, LEFT)\n",
        "\n",
        "        VGroup(square, arrow, cube).next_to(\n",
        "            equation, DOWN, buff = MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        self.add(square, cube)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        for i, (angle, raw_axis) in enumerate(angle_axis_pairs):\n",
        "            posed_axis = np.dot(raw_axis, pose_matrix.T)\n",
        "            self.play(*[\n",
        "                Rotate(\n",
        "                    mob, angle = angle, axis = axis, \n",
        "                    in_place = True,\n",
        "                    run_time = abs(angle/(np.pi/2))\n",
        "                )\n",
        "                for mob, axis in [(square, raw_axis), (cube, posed_axis)]\n",
        "            ])\n",
        "            self.wait()\n",
        "            if i == 2:\n",
        "                for group, color in (homo_group, YELLOW), (morph_group, BLUE):\n",
        "                    part, remainder = group[0], VGroup(*group[1:])\n",
        "                    remainder.set_color(color)\n",
        "                    self.play(\n",
        "                        part.set_color, color,\n",
        "                        FadeIn(remainder)\n",
        "                    )\n",
        "\n",
        "class ComplexExponentiationAbstract():\n",
        "    CONFIG = {\n",
        "        \"start_base\" : 2,\n",
        "        \"new_base\" : 5,\n",
        "        \"group_type\" : None,\n",
        "        \"color\" : None,\n",
        "        \"vect\" : None,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.base = self.start_base\n",
        "        example_inputs = [2, -3, 1]\n",
        "        self.add_vertical_line()\n",
        "        self.add_plane_unanimated()\n",
        "        self.add_title()\n",
        "        self.add_arrow()\n",
        "        self.show_example(complex(1, 1))\n",
        "        self.draw_real_line()\n",
        "        self.show_real_actions(*example_inputs)\n",
        "        self.show_pure_imaginary_actions(*example_inputs)\n",
        "        self.set_color_vertical_line()\n",
        "        self.set_color_unit_circle()\n",
        "        self.show_pure_imaginary_actions(*example_inputs)\n",
        "        self.walk_input_up_vertical()\n",
        "        self.change_base(self.new_base, str(self.new_base))\n",
        "        self.walk_input_up_vertical()\n",
        "        self.change_base(np.exp(1), \"e\")\n",
        "        self.take_steps_for_e()\n",
        "        self.write_eulers_formula()\n",
        "        self.show_pure_imaginary_actions(-np.pi, np.pi)\n",
        "        self.wait()\n",
        "\n",
        "    def add_vertical_line(self):\n",
        "        line = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        line.set_stroke(color = self.color, width = 10)\n",
        "        line.shift(-FRAME_X_RADIUS*self.vect/2)\n",
        "        self.add(line)\n",
        "        self.add_foreground_mobjects(line)\n",
        "\n",
        "    def add_plane_unanimated(self):\n",
        "        should_skip_animations = self.skip_animations\n",
        "        self.skip_animations = True\n",
        "        self.add_plane()\n",
        "        self.skip_animations = should_skip_animations\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(self.group_type, \"group\")\n",
        "        title.scale(0.8)\n",
        "        title[0].set_color(self.color)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def add_arrow(self):\n",
        "        arrow = Arrow(LEFT, RIGHT, color = WHITE)\n",
        "        arrow.move_to(-FRAME_X_RADIUS*self.vect/2 + 2*UP)\n",
        "        arrow.set_stroke(width = 6),\n",
        "        func_mob = OldTex(\"2^x\")    \n",
        "        func_mob.next_to(arrow, UP, aligned_edge = LEFT)\n",
        "        func_mob.add_background_rectangle()\n",
        "\n",
        "        self.add_foreground_mobjects(arrow, func_mob)\n",
        "        self.wait()\n",
        "        self.func_mob = func_mob\n",
        "\n",
        "    def show_example(self, z):\n",
        "        self.apply_action(\n",
        "            z,\n",
        "            run_time = 5,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "\n",
        "    def draw_real_line(self):\n",
        "        line = VGroup(Line(ORIGIN, FRAME_X_RADIUS*RIGHT))\n",
        "        if self.vect[0] < 0:\n",
        "            line.add(Line(ORIGIN, FRAME_X_RADIUS*LEFT))\n",
        "        line.set_color(RED)\n",
        "\n",
        "        self.play(*list(map(ShowCreation, line)), run_time = 3)\n",
        "        self.add_foreground_mobjects(line)\n",
        "\n",
        "        self.real_line = line\n",
        "\n",
        "    def show_real_actions(self, *example_inputs):\n",
        "        for x in example_inputs:\n",
        "            self.apply_action(x)\n",
        "            self.wait()\n",
        "\n",
        "    def show_pure_imaginary_actions(self, *example_input_imag_parts):\n",
        "        for y in example_input_imag_parts:\n",
        "            self.apply_action(complex(0, y), run_time = 3)\n",
        "            self.wait()\n",
        "\n",
        "    def change_base(self, new_base, new_base_tex):\n",
        "        new_func_mob = OldTex(new_base_tex + \"^x\")\n",
        "        new_func_mob.add_background_rectangle()\n",
        "        new_func_mob.move_to(self.func_mob)\n",
        "\n",
        "        self.play(FocusOn(self.func_mob))\n",
        "        self.play(Transform(self.func_mob, new_func_mob))\n",
        "        self.wait()\n",
        "        self.base = new_base\n",
        "\n",
        "    def write_eulers_formula(self):\n",
        "        formula = OldTex(\"e^\", \"{\\\\pi\", \"i}\", \"=\", \"-1\")\n",
        "        VGroup(*formula[1:3]).set_color(ADDER_COLOR)\n",
        "        formula[-1].set_color(MULTIPLIER_COLOR)\n",
        "        formula.scale(1.5)\n",
        "        formula.next_to(ORIGIN, UP)\n",
        "        formula.shift(-FRAME_X_RADIUS*self.vect/2)\n",
        "        for part in formula:\n",
        "            part.add_to_back(BackgroundRectangle(part))\n",
        "\n",
        "        Scene.play(self, Write(formula))\n",
        "        self.add_foreground_mobjects(formula)\n",
        "        self.wait(2)\n",
        "\n",
        "class ComplexExponentiationAdderHalf(\n",
        "    ComplexExponentiationAbstract, \n",
        "    AdditiveGroupOfComplexNumbers\n",
        "    ):\n",
        "    CONFIG = {\n",
        "        \"group_type\" : \"Additive\",\n",
        "        \"color\" : GREEN_B,\n",
        "        \"vect\" : LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        ComplexExponentiationAbstract.construct(self)\n",
        "\n",
        "    def apply_action(self, z, run_time = 2, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.plane.shift, self.z_to_point(z),\n",
        "                **kwargs\n",
        "            ),\n",
        "            *kwargs.get(\"added_anims\", [])\n",
        "        )\n",
        "\n",
        "    def set_color_vertical_line(self):\n",
        "        line = VGroup(\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*UP),\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*DOWN),\n",
        "        )\n",
        "        line.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.real_line),\n",
        "            *list(map(ShowCreation, line))\n",
        "        )\n",
        "        self.foreground_mobjects.remove(self.real_line)\n",
        "        self.play(\n",
        "            line.rotate, np.pi/24,\n",
        "            rate_func = wiggle,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.foreground_mobjects = [line] + self.foreground_mobjects\n",
        "        self.vertical_line = line\n",
        "\n",
        "    def set_color_unit_circle(self):\n",
        "        line = VGroup(\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*UP),\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*DOWN),\n",
        "        )\n",
        "        line.set_color(YELLOW)\n",
        "        for submob in line:\n",
        "            submob.insert_n_curves(10)\n",
        "            submob.make_smooth()\n",
        "        circle = VGroup(\n",
        "            Circle(),\n",
        "            Circle().flip(RIGHT),\n",
        "        )\n",
        "        circle.set_color(YELLOW)\n",
        "        circle.shift(FRAME_X_RADIUS*RIGHT)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            line, circle, run_time = 3\n",
        "        ))\n",
        "        self.remove(circle)\n",
        "        self.wait()\n",
        "\n",
        "    def walk_input_up_vertical(self):\n",
        "        arrow = Arrow(ORIGIN, UP, buff = 0, tip_length = 0.15)\n",
        "        arrow.set_color(GREEN)\n",
        "        brace = Brace(arrow, RIGHT, buff = SMALL_BUFF)\n",
        "        brace_text = brace.get_text(\"1 unit\")\n",
        "        brace_text.add_background_rectangle()\n",
        "\n",
        "        Scene.play(self, ShowCreation(arrow))\n",
        "        self.add_foreground_mobjects(arrow)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text, run_time = 1)\n",
        "        )\n",
        "        self.add_foreground_mobjects(brace, brace_text)        \n",
        "        self.wait()\n",
        "        self.apply_action(complex(0, 1))\n",
        "        self.wait(7)##Line up with MultiplierHalf\n",
        "\n",
        "        to_remove = arrow, brace, brace_text\n",
        "        for mob in to_remove:\n",
        "            self.foreground_mobjects.remove(mob)\n",
        "        self.play(*list(map(FadeOut, to_remove)))\n",
        "        self.apply_action(complex(0, -1))\n",
        "\n",
        "    def take_steps_for_e(self):\n",
        "        slide_values = [1, 1, 1, np.pi-3]\n",
        "        braces = [\n",
        "            Brace(Line(ORIGIN, x*UP), RIGHT, buff = SMALL_BUFF)\n",
        "            for x in np.cumsum(slide_values)\n",
        "        ]\n",
        "        labels = list(map(TexText, [\n",
        "            \"1 unit\",\n",
        "            \"2 units\",\n",
        "            \"3 units\",\n",
        "            \"$\\\\pi$ units\",\n",
        "        ]))\n",
        "        for label, brace in zip(labels, braces):\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(brace, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        curr_brace = None\n",
        "        curr_label = None\n",
        "        for slide_value, label, brace in zip(slide_values, labels, braces):\n",
        "            self.apply_action(complex(0, slide_value))\n",
        "            if curr_brace is None:\n",
        "                curr_brace = brace\n",
        "                curr_label = label\n",
        "                self.play(\n",
        "                    GrowFromCenter(curr_brace),\n",
        "                    Write(curr_label)\n",
        "                )\n",
        "                self.add_foreground_mobjects(brace, label)\n",
        "            else:\n",
        "                self.play(\n",
        "                    Transform(curr_brace, brace),\n",
        "                    Transform(curr_label, label),\n",
        "                )\n",
        "            self.wait()\n",
        "            self.wait(4) ##Line up with multiplier half\n",
        "\n",
        "class ComplexExponentiationMultiplierHalf(\n",
        "    ComplexExponentiationAbstract, \n",
        "    MultiplicativeGroupOfComplexNumbers\n",
        "    ):\n",
        "    CONFIG = {\n",
        "        \"group_type\" : \"Multiplicative\",\n",
        "        \"color\" : MULTIPLIER_COLOR,\n",
        "        \"vect\" : RIGHT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ComplexExponentiationAbstract.construct(self)\n",
        "\n",
        "    def apply_action(self, z, run_time = 2, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        self.multiply_by_z(self.base**z, **kwargs)\n",
        "\n",
        "    def set_color_vertical_line(self):\n",
        "        self.play(FadeOut(self.real_line))\n",
        "        self.foreground_mobjects.remove(self.real_line)\n",
        "        self.wait(2)\n",
        "\n",
        "    def set_color_unit_circle(self):\n",
        "        line = VGroup(\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*UP),\n",
        "            Line(ORIGIN, FRAME_Y_RADIUS*DOWN),\n",
        "        )\n",
        "        line.set_color(YELLOW)\n",
        "        line.shift(FRAME_X_RADIUS*LEFT)\n",
        "        for submob in line:\n",
        "            submob.insert_n_curves(10)\n",
        "            submob.make_smooth()\n",
        "        circle = VGroup(\n",
        "            Circle(),\n",
        "            Circle().flip(RIGHT),\n",
        "        )\n",
        "        circle.set_color(YELLOW)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            line, circle, run_time = 3\n",
        "        ))\n",
        "        self.add_foreground_mobjects(circle)\n",
        "        self.wait()\n",
        "\n",
        "    def walk_input_up_vertical(self):\n",
        "        output_z = self.base**complex(0, 1)\n",
        "        angle = np.angle(output_z)\n",
        "\n",
        "        arc, brace, curved_brace, radians_label = \\\n",
        "            self.get_arc_braces_and_label(angle)\n",
        "\n",
        "        self.wait(3)\n",
        "        self.apply_action(complex(0, 1))\n",
        "\n",
        "        Scene.play(self, ShowCreation(arc))\n",
        "        self.add_foreground_mobjects(arc)\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Transform(brace, curved_brace))\n",
        "        self.play(Write(radians_label, run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.foreground_mobjects.remove(arc)\n",
        "        self.play(*list(map(FadeOut, [arc, brace, radians_label])))\n",
        "        self.apply_action(complex(0, -1))\n",
        "\n",
        "    def get_arc_braces_and_label(self, angle):\n",
        "        arc = Arc(angle)\n",
        "        arc.set_stroke(GREEN, width = 6)\n",
        "        arc_line = Line(RIGHT, RIGHT+angle*UP)\n",
        "        brace = Brace(arc_line, RIGHT, buff = 0)\n",
        "        for submob in brace.family_members_with_points():\n",
        "            submob.insert_n_curves(10)\n",
        "        curved_brace = brace.copy()\n",
        "        curved_brace.shift(LEFT)\n",
        "        curved_brace.apply_complex_function(\n",
        "            np.exp, maintain_smoothness = False\n",
        "        )\n",
        "\n",
        "        half_point = arc.point_from_proportion(0.5)\n",
        "        radians_label = OldTex(\"%.3f\"%angle)\n",
        "        radians_label.add_background_rectangle()\n",
        "        radians_label.next_to(\n",
        "            1.5*half_point, np.round(half_point), buff = 0\n",
        "        )\n",
        "\n",
        "        return arc, brace, curved_brace, radians_label\n",
        "\n",
        "    def take_steps_for_e(self):\n",
        "        angles = [1, 2, 3, np.pi]\n",
        "\n",
        "        curr_brace = None\n",
        "        curr_label = None\n",
        "        curr_arc = None\n",
        "        for last_angle, angle in zip([0]+angles, angles):\n",
        "            arc, brace, curved_brace, label = self.get_arc_braces_and_label(angle)\n",
        "            if angle == np.pi:\n",
        "                label = OldTex(\"%.5f\\\\dots\"%np.pi)\n",
        "                label.add_background_rectangle(opacity = 1)\n",
        "                label.next_to(curved_brace, UP, buff = SMALL_BUFF)\n",
        "\n",
        "            self.apply_action(complex(0, angle-last_angle))\n",
        "            self.wait(2)#Line up with Adder half\n",
        "            if curr_brace is None:\n",
        "                curr_brace = curved_brace\n",
        "                curr_label = label\n",
        "                curr_arc = arc\n",
        "                brace.set_fill(opacity = 0)\n",
        "                Scene.play(self, ShowCreation(curr_arc))\n",
        "                self.add_foreground_mobjects(curr_arc)\n",
        "                self.play(\n",
        "                    ReplacementTransform(brace, curr_brace),\n",
        "                    Write(curr_label)\n",
        "                )\n",
        "                self.add_foreground_mobjects(curr_brace, curr_label)\n",
        "            else:\n",
        "                Scene.play(self, ShowCreation(arc))\n",
        "                self.add_foreground_mobjects(arc)\n",
        "                self.foreground_mobjects.remove(curr_arc)\n",
        "                self.remove(curr_arc)\n",
        "                curr_arc = arc\n",
        "                self.play(\n",
        "                    Transform(curr_brace, curved_brace),\n",
        "                    Transform(curr_label, label),\n",
        "                )\n",
        "            self.wait()\n",
        "            self.wait()\n",
        "\n",
        "class ExpComplexHomomorphismPreviewAbstract(ComplexExponentiationAbstract):\n",
        "    def construct(self):\n",
        "        self.base = self.start_base\n",
        "\n",
        "        self.add_vertical_line()\n",
        "        self.add_plane_unanimated()\n",
        "        self.add_title()\n",
        "        self.add_arrow()\n",
        "        self.change_base(np.exp(1), \"e\")\n",
        "        self.write_eulers_formula()\n",
        "        self.show_pure_imaginary_actions(np.pi, 0, -np.pi)\n",
        "        self.wait()\n",
        "\n",
        "class ExpComplexHomomorphismPreviewAdderHalf(\n",
        "    ExpComplexHomomorphismPreviewAbstract,\n",
        "    ComplexExponentiationAdderHalf\n",
        "    ):\n",
        "    def construct(self):\n",
        "        ExpComplexHomomorphismPreviewAbstract.construct(self)\n",
        "\n",
        "class ExpComplexHomomorphismPreviewMultiplierHalf(\n",
        "    ExpComplexHomomorphismPreviewAbstract,\n",
        "    ComplexExponentiationMultiplierHalf\n",
        "    ):\n",
        "    def construct(self):\n",
        "        ExpComplexHomomorphismPreviewAbstract.construct(self)\n",
        "\n",
        "class WhyE(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Why e?\")\n",
        "        self.play(self.get_teacher().change_mode, \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class ReadFormula(Scene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\"e^\", \"{\\\\pi i}\", \"=\", \"-1\")\n",
        "        formula[1].set_color(GREEN_B)\n",
        "        formula[3].set_color(MULTIPLIER_COLOR)\n",
        "        formula.scale(2)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.shift(2*LEFT)\n",
        "        formula.next_to(randy, RIGHT, aligned_edge = UP)\n",
        "        randy.look_at(formula)\n",
        "\n",
        "        self.add(randy, formula)\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"thinking\")\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(3)\n",
        "\n",
        "class EfvgtPatreonThanks(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Justin Helps\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Nils Schneider\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class EmeraldLogo(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"emerald_logo\",\n",
        "        \"stroke_width\" : 0,\n",
        "        \"fill_opacity\" : 1,\n",
        "        # \"helix_color\" : \"#439271\",\n",
        "        \"helix_color\" : GREEN_E,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.set_height(1)\n",
        "        for submob in self.split()[18:]:\n",
        "            submob.set_color(self.helix_color)\n",
        "\n",
        "class ECLPromo(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        logo = EmeraldLogo()\n",
        "        logo.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        logo_part1 = VGroup(*logo[:15])\n",
        "        logo_part2 = VGroup(*logo[15:])\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5)\n",
        "        rect.next_to(logo, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"hooray\",\n",
        "            ShowCreation(rect)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(FadeIn(\n",
        "            logo_part1, run_time = 3, \n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        logo_part2.save_state()\n",
        "        logo_part2.scale(2)\n",
        "        logo_part2.next_to(self.pi_creature.get_corner(UP+LEFT), UP)\n",
        "        logo_part2.shift(MED_SMALL_BUFF*RIGHT)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "        )        \n",
        "        self.play(DrawBorderThenFill(logo_part2))\n",
        "        self.play(\n",
        "            logo_part2.scale, 0.5,\n",
        "            logo_part2.to_edge, UP\n",
        "        )\n",
        "        self.play(\n",
        "            logo_part2.restore,\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.play(self.pi_creature.look_at, rect)\n",
        "        self.wait(10)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look, DOWN\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "class ExpTransformation(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\": ThreeDCamera,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.camera.camera_distance = 10,\n",
        "        self.add_transformable_plane()\n",
        "        self.prepare_for_transformation(self.plane)\n",
        "        final_plane = self.plane.copy().apply_complex_function(np.exp)\n",
        "        cylinder = self.plane.copy().apply_function(\n",
        "            lambda x_y_z : np.array([x_y_z[0], np.sin(x_y_z[1]), -np.cos(x_y_z[1])])\n",
        "        )\n",
        "        title = OldTex(\"x \\\\to e^x\")\n",
        "        title.add_background_rectangle()\n",
        "        title.scale(1.5)\n",
        "        title.next_to(ORIGIN, RIGHT)\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "        self.play(Transform(\n",
        "            self.plane, cylinder, \n",
        "            run_time = 3,\n",
        "            path_arc_axis = RIGHT,\n",
        "            path_arc = np.pi,\n",
        "        ))\n",
        "        self.play(Rotate(\n",
        "            self.plane, -np.pi/3, UP, \n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.play(Transform(self.plane, final_plane, run_time = 3))\n",
        "        self.wait(3)\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\"e^\", \"{\\\\pi i}\", \"=\", \"-1\")\n",
        "        formula[1].set_color(GREEN_B)\n",
        "        formula[3].set_color(YELLOW)\n",
        "        formula.scale(4)\n",
        "        formula.to_edge(UP, buff = LARGE_BUFF)\n",
        "        self.add(formula)\n",
        "\n",
        "        via = OldTexText(\"via\")\n",
        "        via.scale(2)\n",
        "        groups = OldTexText(\"Group theory\")\n",
        "        groups.scale(3)\n",
        "        groups.to_edge(DOWN)\n",
        "        via.move_to(VGroup(formula, groups))\n",
        "        self.add(via, groups)\n",
        "\n"
    ]
}