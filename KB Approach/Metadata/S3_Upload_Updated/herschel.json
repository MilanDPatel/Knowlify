{
    "topic": "The mathematical concept being demonstrated is the probability density function of a two-dimensional Gaussian distribution. The code",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.clt.main import *\n",
        "\n",
        "\n",
        "class TwoDGaussianAsADistribution(InteractiveScene):\n",
        "    n_points = 2000\n",
        "    n_dots_per_moment = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        plane = self.get_plane()\n",
        "        plane.set_flat_stroke(False)\n",
        "        self.add(plane)\n",
        "\n",
        "        dartboard = self.get_dartboard(plane)\n",
        "        dartboard.save_state()\n",
        "        dartboard.set_opacity(0)\n",
        "        self.add(dartboard)\n",
        "\n",
        "        self.add_random_points_anim(plane)\n",
        "        self.wait(10)\n",
        "        self.play(Restore(dartboard))\n",
        "        self.wait(10)\n",
        "\n",
        "        # Graph\n",
        "        def func(u, v, sigma=1):\n",
        "            return np.exp(-(u**2 + v**2) / sigma**2) / sigma\n",
        "\n",
        "        graphs = []\n",
        "        for sigma in [0.8, 1.0, 0.6]:\n",
        "            graph = ParametricSurface(lambda u, v: [u, v, func(u, v, sigma)], u_range=(-2, 2), v_range=(-2, 2))\n",
        "            graph.match_width(plane.axes)\n",
        "            graph.set_color(BLUE_E, 0.5)\n",
        "            graph.move_to(plane.axes, IN)\n",
        "            graph.always_sort_to_camera(self.camera)\n",
        "\n",
        "            mesh = VGroup(*plane.background_lines.copy(), plane.faded_lines.copy())\n",
        "            mesh.insert_n_curves(50)\n",
        "            mesh.start = mesh.copy().set_opacity(0)\n",
        "            mesh.save_state()\n",
        "            mesh.saved_state.set_opacity(0)\n",
        "            unit_size = plane.x_axis.get_unit_size()\n",
        "            for submob in mesh.family_members_with_points():\n",
        "                submob.set_points([\n",
        "                    p + unit_size * func(*plane.p2c(p), sigma) * OUT\n",
        "                    for p in submob.get_points()\n",
        "                ])\n",
        "                submob.set_stroke(\n",
        "                    WHITE,\n",
        "                    width=0.5 * submob.get_stroke_width(),\n",
        "                    opacity=0.5 * submob.get_stroke_opacity()\n",
        "                )\n",
        "            mesh.shift(0.01 * OUT)\n",
        "            graphs.append(Group(graph, mesh))\n",
        "\n",
        "        graph1, graph2, graph3 = graphs\n",
        "\n",
        "        # Test\n",
        "        self.add(graph1)\n",
        "        graph1[0].set_opacity(0)\n",
        "        self.play(\n",
        "            frame.animate.reorient(20, 70),\n",
        "            graph1[0].animate.set_opacity(0.5),\n",
        "            TransformFromCopy(graph1[1].start, graph1[1]),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-20),\n",
        "            run_time=7,\n",
        "        )\n",
        "        graph1.save_state()\n",
        "        self.play(Transform(graph1, graph2), run_time=2)\n",
        "        self.play(Transform(graph1, graph3), run_time=2)\n",
        "        self.play(Restore(graph1), run_time=2)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(graph1[0]),\n",
        "            Restore(graph1[1]),\n",
        "            frame.animate.reorient(0, 0),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Radial symmetry\n",
        "        blob = Circle(radius=0.2)\n",
        "        blob.set_stroke(TEAL, 2)\n",
        "        blob.set_fill(TEAL, 0.5)\n",
        "        blob.move_to(plane.c2p(0.5, 0.5))\n",
        "\n",
        "        arrow = FillArrow(ORIGIN, DL)\n",
        "        arrow.next_to(blob, UR, buff=0)\n",
        "        arrow.set_fill(RED, 1)\n",
        "        arrow.set_backstroke(width=2)\n",
        "\n",
        "        radial_line = DashedLine(plane.c2p(0, 0), blob.get_center(), dash_length=0.025)\n",
        "        radial_line.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.play(\n",
        "            dartboard.animate.set_opacity(0.2),\n",
        "            DrawBorderThenFill(blob),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(\n",
        "            Rotate(blob, TAU, about_point=plane.get_origin(), run_time=6),\n",
        "            Rotate(radial_line, TAU, about_point=plane.get_origin(), run_time=6),\n",
        "            MaintainPositionRelativeTo(arrow, blob),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(blob, arrow, radial_line)),\n",
        "            dartboard.animate.set_opacity(0.75)\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.set_gamma(-0.75 * PI),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ambient randomness\n",
        "        self.wait(0.1 * self.n_points)\n",
        "\n",
        "    def get_plane(self):\n",
        "        plane = NumberPlane(\n",
        "            (-2, 2), (-2, 2),\n",
        "            background_line_style=dict(stroke_color=GREY, stroke_width=1, stroke_opacity=1)\n",
        "        )\n",
        "        plane.set_height(7)\n",
        "        plane.to_edge(DOWN, buff=0.25)\n",
        "        plane.add(Tex(\"x\").next_to(plane.x_axis.get_right(), RIGHT, SMALL_BUFF))\n",
        "        plane.add(Tex(\"y\").next_to(plane.y_axis.get_top(), UP, SMALL_BUFF))\n",
        "        return plane\n",
        "\n",
        "    def get_dartboard(self, plane):\n",
        "        dartboard = Dartboard()\n",
        "        dartboard.match_height(plane.axes)\n",
        "        dartboard.move_to(plane.axes)\n",
        "        dartboard.set_opacity(0.75)\n",
        "        return dartboard\n",
        "\n",
        "    def add_random_points_anim(self, plane):\n",
        "        coords = np.random.normal(0, 0.5, (self.n_points, 2))\n",
        "        dots = Group(*(\n",
        "            GlowDot(plane.c2p(x, y), glow_factor=4.0, radius=0.3)\n",
        "            for x, y in coords\n",
        "        ))\n",
        "\n",
        "        anim = LaggedStart(*(\n",
        "            FadeIn(dot, rate_func=there_and_back)\n",
        "            for dot in dots\n",
        "        ), lag_ratio=1 / self.n_dots_per_moment, run_time=self.n_points / self.n_dots_per_moment)\n",
        "\n",
        "        anim_mob = turn_animation_into_updater(anim)\n",
        "        self.add(anim_mob)\n",
        "\n",
        "\n",
        "class FaintDartboard(TwoDGaussianAsADistribution):\n",
        "    n_points = 1000\n",
        "    n_dots_per_moment = 5\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        plane = self.get_plane()\n",
        "        plane.set_flat_stroke(False)\n",
        "        self.add(plane)\n",
        "\n",
        "        dartboard = self.get_dartboard(plane)\n",
        "        dartboard.set_opacity(0.15)\n",
        "        self.add(dartboard)\n",
        "\n",
        "        self.add_random_points_anim(plane)\n",
        "        self.wait(0.1 * self.n_points)\n",
        "\n",
        "\n",
        "class ShowXYCoordinate(TwoDGaussianAsADistribution):\n",
        "    def construct(self):\n",
        "        plane = self.get_plane()\n",
        "        # self.add(plane)  # Remove\n",
        "\n",
        "        # Test\n",
        "        x, y = (-1.5, 0.5)\n",
        "        dot = Dot(plane.c2p(x, y))\n",
        "        dot.set_color(TEAL)\n",
        "\n",
        "        r_line = Line(plane.get_origin(), dot.get_center())\n",
        "        r_line.set_stroke(RED, 3)\n",
        "        x_line = Line(plane.get_origin(), plane.c2p(x, 0))\n",
        "        x_line.set_stroke(BLUE, 5)\n",
        "        y_line = Line(plane.c2p(x, 0), plane.c2p(x, y))\n",
        "        y_line.set_stroke(YELLOW, 5)\n",
        "\n",
        "        x_label = Tex(\"x\", color=BLUE).next_to(x_line, DOWN, SMALL_BUFF)\n",
        "        y_label = Tex(\"y\", color=YELLOW).next_to(y_line, LEFT, SMALL_BUFF)\n",
        "        r_label = Tex(\"r\", color=RED).next_to(r_line.get_center(), UR, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dot),\n",
        "            ShowCreation(x_line),\n",
        "            FadeIn(x_label, 0.5 * LEFT),\n",
        "        )\n",
        "        self.add(y_line, dot)\n",
        "        self.play(\n",
        "            ShowCreation(y_line),\n",
        "            FadeIn(y_label, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(r_line, dot)\n",
        "        self.play(\n",
        "            ShowCreation(r_line),\n",
        "            FadeIn(r_label, shift=0.5 * normalize(r_line.get_vector()))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IndependentCoordinates(TwoDGaussianAsADistribution):\n",
        "    n_iterations = 20\n",
        "    random_seed = 1\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        plane = self.get_plane()\n",
        "        dartboard = self.get_dartboard(plane)\n",
        "        dartboard.set_opacity(0.15)\n",
        "        self.add(plane, dartboard)\n",
        "\n",
        "        x_tip = ArrowTip(angle=90 * DEGREES).scale(0.5).set_color(BLUE)\n",
        "        y_tip = ArrowTip(angle=0).scale(0.5).set_color(YELLOW)\n",
        "        x_tip.move_to(plane.get_origin(), UP)\n",
        "        y_tip.move_to(plane.get_origin(), RIGHT)\n",
        "        for tip in x_tip, y_tip:\n",
        "            tip.set_opacity(0)\n",
        "            tip.save_state()\n",
        "\n",
        "        for n in range(self.n_iterations):\n",
        "            # Test\n",
        "            x_tip.restore()\n",
        "            y_tip.restore()\n",
        "\n",
        "            # xs = np.random.normal(0, 1, 10)\n",
        "            # ys = np.random.normal(0, 1, 10)\n",
        "            # x = xs[-2]\n",
        "            # y = ys[-2]\n",
        "            x = np.random.normal(0, 0.5)\n",
        "            y = np.random.normal(0, 0.5)\n",
        "\n",
        "            if y < 0:\n",
        "                x_tip.flip(RIGHT, about_point=plane.get_origin())\n",
        "            if x < 0:\n",
        "                y_tip.flip(UP, about_point=plane.get_origin())\n",
        "\n",
        "            lines = VGroup(\n",
        "                DashedLine(plane.c2p(x, 0), plane.c2p(x, y), dash_length=0.05),\n",
        "                DashedLine(plane.c2p(0, y), plane.c2p(x, y), dash_length=0.05),\n",
        "            )\n",
        "            lines.set_stroke(WHITE, 2)\n",
        "\n",
        "            dot = GlowDot().move_to(plane.c2p(x, y))\n",
        "\n",
        "            self.play(LaggedStart(\n",
        "                x_tip.animate.match_x(dot).set_opacity(1),\n",
        "                y_tip.animate.match_y(dot).set_opacity(1),\n",
        "                lag_ratio=0.5,\n",
        "            ))\n",
        "            self.play(\n",
        "                *map(ShowCreation, lines),\n",
        "                FadeIn(dot),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            # self.play(UpdateFromAlphaFunc(x_tip, lambda m, a: m.match_x(\n",
        "            #     plane.c2p(xs[integer_interpolate(0, len(xs) - 1, a)[0]], 0)\n",
        "            # )))\n",
        "            # self.play(UpdateFromAlphaFunc(y_tip, lambda m, a: m.match_y(\n",
        "            #     plane.c2p(0, ys[integer_interpolate(0, len(ys) - 1, a)[0]])\n",
        "            # )))\n",
        "            # self.add(lines, dot)\n",
        "            # self.wait()\n",
        "            self.play(LaggedStartMap(FadeOut, Group(\n",
        "                x_tip, y_tip, lines, dot\n",
        "            )), run_time=1)\n",
        "\n",
        "\n",
        "class ShowPointR0(TwoDGaussianAsADistribution):\n",
        "    def construct(self):\n",
        "        plane = self.get_plane()\n",
        "        plane.axes.set_stroke(width=1)\n",
        "        dartboard = self.get_dartboard(plane)\n",
        "        dartboard.set_opacity(0.15)\n",
        "        self.add(plane, dartboard)\n",
        "\n",
        "        # Show point\n",
        "        x, y = (0.7, 0.5)\n",
        "        r = get_norm([x, y])\n",
        "        dot = Dot(plane.c2p(x, y), radius=0.05)\n",
        "        r_line = Line(plane.get_origin(), dot.get_center())\n",
        "        r_line.set_stroke(RED, 3)\n",
        "        coord_label = Tex(\"(x, y)\", t2c={\"x\": BLUE, \"y\": YELLOW})\n",
        "        coord_label.next_to(dot, UR, buff=SMALL_BUFF)\n",
        "        coord_label.set_backstroke()\n",
        "        new_coord_label = Tex(\"(r, 0)\", t2c={\"r\": RED, \"0\": YELLOW})\n",
        "        new_coord_label.next_to(plane.c2p(r, 0), UR, SMALL_BUFF)\n",
        "\n",
        "        angle = math.atan2(y, x)\n",
        "\n",
        "        self.add(r_line, dot, coord_label)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(r_line, -angle, about_point=plane.get_origin()),\n",
        "            Rotate(dot, -angle, about_point=plane.get_origin()),\n",
        "            ReplacementTransform(coord_label, new_coord_label, path_arc=-angle, time_span=(1, 2)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RescaleG(InteractiveScene):\n",
        "    def construct(self):\n",
        "        def g(x):\n",
        "            return 0.5 * math.exp(-x**4 + x**2)\n",
        "\n",
        "        # Setup\n",
        "        axes = Axes((-2, 2), (0, 1, 0.25), width=6, height=3)\n",
        "        axes.x_axis.add_numbers()\n",
        "        axes.y_axis.add_numbers(num_decimal_places=2, excluding=[0], font_size=16)\n",
        "        self.add(axes)\n",
        "\n",
        "        curve = axes.get_graph(g)\n",
        "        curve.make_smooth()\n",
        "        curve.set_stroke(BLUE, 3)\n",
        "        curve.save_state()\n",
        "        curve.generate_target()\n",
        "        curve.target.stretch(1 / g(0), 1, about_edge=DOWN)\n",
        "\n",
        "        label1 = TexText(R\"$g(0) \\ne 1$\", font_size=36)\n",
        "        label2 = TexText(R\"$g(0) = 1$\", font_size=36)\n",
        "        label3 = TexText(R\"Later we \\\\ re-scale anyway\", font_size=36)\n",
        "        labels = [label1, label2, label3]\n",
        "        curves = [curve, curve.target, curve]\n",
        "        for label, crv in zip(labels, curves):\n",
        "            label.next_to(crv.get_top(), UR)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(curve),\n",
        "            FadeIn(label1, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(curve),\n",
        "            FadeTransform(label1, label2),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Restore(curve),\n",
        "            FadeTransform(label2, label3),\n",
        "        )\n",
        "        self.play(curve.animate.set_fill(BLUE, 0.5))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ManyDifferentFs(InteractiveScene):\n",
        "    def construct(self):\n",
        "        axes = Axes((0, 4), (0, 1, 0.25), width=6, height=3)\n",
        "        axes.x_axis.add_numbers()\n",
        "        axes.y_axis.add_numbers(num_decimal_places=2, excluding=[0], font_size=16)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Many curves\n",
        "        curves = VGroup(\n",
        "            axes.get_graph(lambda x: math.exp(-x**2)),\n",
        "            axes.get_graph(lambda x: 1 / (1 + x**2)),\n",
        "            axes.get_graph(lambda x: math.exp(-x)),\n",
        "            axes.get_graph(lambda x: 0.5 * math.exp(-x**4 + x**2)),\n",
        "            axes.get_graph(lambda x: math.cos(x)**2 / (x + 1)),\n",
        "            axes.get_graph(lambda x: (1 / 2) * (x**2) * np.exp(-x)),\n",
        "        )\n",
        "        curves.set_stroke(RED, 3)\n",
        "        func_names = VGroup(\n",
        "            Tex(\"e^{-x^2}\"),\n",
        "            Tex(R\"1 \\over (1 + x^2)\"),\n",
        "            Tex(\"e^{-x}\"),\n",
        "            Tex(R\"\\frac{1}{2} e^{-x^4 + x^2}\"),\n",
        "            Tex(R\"\\cos^2(x) \\over (x + 1)\"),\n",
        "            Tex(R\"\\frac{1}{2} x^2 e^{-x}\"),\n",
        "        )\n",
        "        func_names.move_to(axes.get_top())\n",
        "\n",
        "        curve = curves[0]\n",
        "        name = func_names[0]\n",
        "        self.play(\n",
        "            ShowCreation(curve),\n",
        "            FadeIn(name, 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_curve, new_name in zip(curves[1:], func_names[1:]):\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                TransformMatchingTex(name, new_name, run_time=1)\n",
        "            )\n",
        "            name = new_name\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class VariableInputs(InteractiveScene):\n",
        "    def construct(self):\n",
        "        equation = Tex(R\"f(\\sqrt{(1.00)^2 + (0.00)^2}) = f(1.00)f(0.00)\")\n",
        "        xs = equation.make_number_changeable(\"1.00\", replace_all=True)\n",
        "        ys = equation.make_number_changeable(\"0.00\", replace_all=True)\n",
        "\n",
        "        xs.set_color(BLUE)\n",
        "        ys.set_color(YELLOW)\n",
        "\n",
        "        x_tracker = ValueTracker(1.0)\n",
        "        y_tracker = ValueTracker(1.0)\n",
        "\n",
        "        for mob in xs:\n",
        "            mob.add_updater(lambda m: m.set_value(x_tracker.get_value()))\n",
        "\n",
        "        for mob in ys:\n",
        "            mob.add_updater(lambda m: m.set_value(y_tracker.get_value()))\n",
        "\n",
        "        self.add(equation)\n",
        "        for n in range(30):\n",
        "            self.play(x_tracker.animate.set_value(random.random() * 10))\n",
        "            self.play(y_tracker.animate.set_value(random.random() * 10))\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class RationalNumbers(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Interval\n",
        "        interval = UnitInterval((0, 1, 1))\n",
        "        interval.center()\n",
        "        interval.add_numbers(font_size=36, num_decimal_places=0)\n",
        "        self.add(interval)\n",
        "\n",
        "        # Add rational points\n",
        "        pairs = []\n",
        "        max_n = 100\n",
        "        for n in range(2, max_n):\n",
        "            for k in range(1, n):\n",
        "                if math.gcd(n, k) == 1:\n",
        "                    pairs.append((k, n))\n",
        "\n",
        "        lines = VGroup()\n",
        "        line_groups = VGroup(*(VGroup() for n in range(max_n - 2)))\n",
        "        labels = VGroup()\n",
        "        frac_template = Tex(R\"1 \\over 2\")\n",
        "        frac_template.make_number_changeable(\"1\")\n",
        "        frac_template.make_number_changeable(\"2\")\n",
        "\n",
        "        for pair in pairs:\n",
        "            k, n = pair\n",
        "            line = Line(DOWN, UP)\n",
        "            line.set_height(2.0 / n)\n",
        "            line.set_stroke(TEAL, width=4.0 / math.sqrt(n))\n",
        "            line.move_to(interval.n2p(k / n))\n",
        "            lines.add(line)\n",
        "            line_groups[n - 2].add(line)\n",
        "\n",
        "            if n < 15:\n",
        "                frac = frac_template.copy()\n",
        "                frac[0].set_value(k)\n",
        "                frac[2].set_value(n)\n",
        "                frac[1].match_width(frac[2])\n",
        "                frac.set_height(1.5 / n)\n",
        "                frac.next_to(line, UP, SMALL_BUFF)\n",
        "                labels.add(frac)\n",
        "\n",
        "        line_groups.set_submobject_colors_by_gradient(BLUE, TEAL)\n",
        "\n",
        "        for i, j in [(0, 9), (9, 27), (27, len(labels))]:\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeIn, lines[i:j], lag_ratio=0.75),\n",
        "                LaggedStartMap(FadeIn, labels[i:j], lag_ratio=0.75),\n",
        "                rate_func=linear,\n",
        "                run_time=3,\n",
        "            )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, lines[27:], lag_ratio=0.75),\n",
        "            run_time=10,\n",
        "            rate_func=rush_into,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to real\n",
        "        real_line = Line(interval.n2p(0), interval.n2p(1))\n",
        "        real_line.insert_n_curves(50)\n",
        "        real_line.set_stroke([TEAL, BLUE, TEAL], width=[0, 3, 3, 0])\n",
        "        self.play(\n",
        "            LaggedStart(*(Rotate(line, -90 * DEGREES) for line in lines), lag_ratio=1 / len(lines), run_time=3),\n",
        "            FadeOut(labels, lag_ratio=0.1, run_time=1),\n",
        "            ShowCreation(real_line, time_span=(2, 3)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwoProperties(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Name properties\n",
        "        properties = VGroup(\n",
        "            VGroup(\n",
        "                Text(\"Property 1\"),\n",
        "                TexText(R\"\"\"\n",
        "                    The probability (density) depends \\\\\n",
        "                    only on the distance from the origin\n",
        "                \"\"\", alignment=\"\", font_size=36, color=GREY_A),\n",
        "            ),\n",
        "            VGroup(\n",
        "                Text(\"Property 2\"),\n",
        "                TexText(R\"\"\"\n",
        "                    The $x$ and $y$ coordinates are \\\\\n",
        "                    independent from each other.\n",
        "                \"\"\", alignment=\"\", font_size=36, color=GREY_A),\n",
        "            ),\n",
        "        )\n",
        "        for prop in properties:\n",
        "            prop.arrange(DOWN, aligned_edge=LEFT)\n",
        "        properties.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        properties.to_corner(UL)\n",
        "\n",
        "        prop_boxes = VGroup(*(\n",
        "            SurroundingRectangle(prop[1]).set_fill(GREY_E, 1).set_stroke(RED, 1, 0.5)\n",
        "            for prop in properties\n",
        "        ))\n",
        "\n",
        "        for prop, box in zip(properties, prop_boxes):\n",
        "            self.play(FadeIn(prop[0], lag_ratio=0.1), FadeIn(box))\n",
        "\n",
        "        # Formula\n",
        "        implies = Tex(R\"\\Downarrow\", font_size=72)\n",
        "        implies.next_to(properties, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        kw = dict(\n",
        "            t2c={\"x\": BLUE, \"y\": YELLOW, R\"\\sigma\": RED, \"{r}\": RED}\n",
        "        )\n",
        "        form1, form2, form3 = forms = VGroup(\n",
        "            Tex(R\"f_2(x, y) = e^{-(x^2 + y^2)}\", **kw),\n",
        "            Tex(R\"f_2(x, y) = e^{-(x^2 + y^2) / 2 \\sigma^2}\", **kw),\n",
        "            Tex(R\"f_2(x, y) = {1 \\over 4 \\sigma^2 \\pi} e^{-(x^2 + y^2) / 2 \\sigma^2}\", **kw),\n",
        "        )\n",
        "        forms.next_to(implies, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        form1.save_state()\n",
        "        self.play(\n",
        "            Write(implies),\n",
        "            FadeIn(form1, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(form1, form2, run_time=1, lag_ratio=0.05))\n",
        "        self.wait(2)\n",
        "        self.play(TransformMatchingTex(form2, form3, run_time=1, lag_ratio=0.05))\n",
        "        self.wait(2)\n",
        "        form1.restore()\n",
        "        self.play(TransformMatchingTex(form3, form1, run_time=2, lag_ratio=0.05))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Property 1\n",
        "        lhs = form1[\"f_2(x, y)\"][0]\n",
        "\n",
        "        self.add(properties[0][1], prop_boxes[0])\n",
        "        self.play(\n",
        "            prop_boxes[0].animate.stretch(0, 0, about_edge=RIGHT).set_opacity(0),\n",
        "            FadeOut(implies),\n",
        "            FadeOut(form1[\"= e^{-(x^2 + y^2)}\"]),\n",
        "        )\n",
        "        self.remove(prop_boxes[0])\n",
        "        self.add(lhs)\n",
        "        self.wait()\n",
        "        phrase = properties[0][1][\"only on the distance\"]\n",
        "        self.play(\n",
        "            FlashUnder(phrase, color=TEAL, buff=0),\n",
        "            phrase.animate.set_color(TEAL),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Function of radius\n",
        "        lhs.generate_target()\n",
        "        lhs.target.to_edge(LEFT)\n",
        "        radial_rhs = Tex(R\"= f({r})\", **kw)\n",
        "        full_radial_rhs = Tex(R\"= f(\\sqrt{x^2 + y^2})\", **kw)\n",
        "        radial_rhs.next_to(lhs.target, RIGHT, SMALL_BUFF)\n",
        "        full_radial_rhs.next_to(radial_rhs, RIGHT, MED_SMALL_BUFF)\n",
        "        full_radial_rhs.shift((radial_rhs[\"=\"].get_y() - full_radial_rhs[\"=\"].get_y()) * UP)\n",
        "\n",
        "        lhs_rect = SurroundingRectangle(lhs)\n",
        "        f_rect = SurroundingRectangle(radial_rhs[\"f\"], buff=0.05)\n",
        "        f_rect.set_stroke(BLUE, 2)\n",
        "        f_words = Text(\"Some single-variable function\", font_size=36)\n",
        "        f_words.next_to(f_rect, UP, SMALL_BUFF, aligned_edge=LEFT)\n",
        "        f_words.match_color(f_rect)\n",
        "\n",
        "        self.play(ShowCreation(lhs_rect))\n",
        "        self.wait()\n",
        "        self.play(lhs_rect.animate.replace(lhs[1], stretch=True).set_stroke(width=1).scale(1.1))\n",
        "        self.play(FadeOut(lhs_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(lhs),\n",
        "            Write(radial_rhs),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(f_rect),\n",
        "            FadeIn(f_words, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(f_words), FadeOut(f_rect))\n",
        "        self.play(TransformMatchingTex(radial_rhs.copy(), full_radial_rhs))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Property 2\n",
        "        self.add(properties[1][1], prop_boxes[1])\n",
        "        self.play(\n",
        "            prop_boxes[1].animate.stretch(0, 0, about_edge=RIGHT).set_opacity(0),\n",
        "        )\n",
        "        self.remove(prop_boxes[0])\n",
        "        self.wait()\n",
        "\n",
        "        phrase = properties[1][1][\"independent\"]\n",
        "        self.play(\n",
        "            FlashUnder(phrase, color=TEAL, buff=0),\n",
        "            phrase.animate.set_color(TEAL)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Factored expression\n",
        "        lhs.generate_target()\n",
        "        lhs.target.next_to(properties, DOWN, buff=0.7, aligned_edge=LEFT)\n",
        "        radial_rhss = VGroup(radial_rhs, full_radial_rhs)\n",
        "\n",
        "        factored_rhs = Tex(R\"= g(x) h(y)\", **kw)\n",
        "        simpler_rhs = Tex(R\"= g(x) g(y)\", **kw)\n",
        "        for rhs in factored_rhs, simpler_rhs:\n",
        "            rhs.next_to(lhs.target, RIGHT)\n",
        "\n",
        "        g_box = SurroundingRectangle(factored_rhs[\"g(x)\"], buff=0.05).set_stroke(BLUE, 2)\n",
        "        h_box = SurroundingRectangle(factored_rhs[\"h(y)\"], buff=0.05).set_stroke(YELLOW, 2)\n",
        "        g_words = TexText(\"Distribution of $x$\", font_size=30).next_to(g_box, DOWN, 0.2)\n",
        "        h_words = TexText(\"Distribution of $y$\", font_size=30).next_to(h_box, DOWN, 0.2)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(lhs),\n",
        "            radial_rhss.animate.to_edge(LEFT).shift(0.5 * DOWN).set_opacity(0.35),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingShapes(lhs.copy(), factored_rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(g_box),\n",
        "            FadeIn(g_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(g_box, h_box),\n",
        "            ReplacementTransform(g_words, h_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(h_box), FadeOut(h_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(factored_rhs[\"h(y)\"], 0.5 * UP),\n",
        "            FadeIn(simpler_rhs[\"g(y)\"], 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(factored_rhs)\n",
        "        self.add(simpler_rhs)\n",
        "\n",
        "        # Show proportionality\n",
        "        arrow = Arrow(simpler_rhs, radial_rhs)\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            radial_rhs.animate.set_opacity(1),\n",
        "            FadeOut(full_radial_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "        radial_rhs.generate_target()\n",
        "        radial_rhs.target.next_to(lhs, RIGHT),\n",
        "        self.play(\n",
        "            MoveToTarget(radial_rhs),\n",
        "            simpler_rhs.animate.next_to(radial_rhs.target, RIGHT),\n",
        "            Uncreate(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        xs = VGroup(lhs[3], simpler_rhs[\"x\"][0][0])\n",
        "        ys = VGroup(lhs[5], simpler_rhs[\"y\"][0][0])\n",
        "        rs = Tex(\"{r}\", **kw).replicate(2)\n",
        "        zeros = Tex(\"0\", **kw).replicate(2)\n",
        "        zeros.set_color(YELLOW)\n",
        "        for x, r in zip(xs, rs):\n",
        "            r.move_to(x, DOWN)\n",
        "        for x, y, zero in zip(xs, ys, zeros):\n",
        "            zero.move_to(y)\n",
        "            zero.align_to(x, DOWN)\n",
        "\n",
        "        const_rect = SurroundingRectangle(simpler_rhs[\"g(y)\"], buff=0.05)\n",
        "        const_rect.set_stroke(YELLOW, 1)\n",
        "        const_words = Text(\"Some constant\", font_size=36)\n",
        "        const_words.match_color(const_rect)\n",
        "        const_words.next_to(const_rect, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(*xs, *ys), shift=0.5 * UP),\n",
        "            LaggedStartMap(FadeIn, VGroup(*rs, *zeros), shift=0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(const_rect),\n",
        "            FadeIn(const_words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Assume this constant is 1\n",
        "        assumption = TexText(\"Assume this is 1\", font_size=36)\n",
        "        assumption.move_to(const_words)\n",
        "        assumption.match_color(const_words)\n",
        "\n",
        "        f_eq_g = Tex(\"f = g\", **kw)\n",
        "        f_eq_g.next_to(radial_rhs, DOWN, LARGE_BUFF)\n",
        "\n",
        "        f_rhs = Tex(R\"= f(x)f(y)\", **kw)\n",
        "        f_rhs.move_to(simpler_rhs, LEFT)\n",
        "        gs = simpler_rhs[\"g\"]\n",
        "        fs = f_rhs[\"f\"]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(assumption, 0.5 * DOWN),\n",
        "            FadeOut(const_words, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                VGroup(radial_rhs[1], *simpler_rhs[:2]),\n",
        "                f_eq_g\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, VGroup(*xs, *ys), shift=0.5 * DOWN),\n",
        "            LaggedStartMap(FadeOut, VGroup(*rs, *zeros), shift=0.5 * DOWN),\n",
        "            FadeOut(const_rect),\n",
        "            FadeOut(assumption),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(f_eq_g[0].copy(), fs),\n",
        "            ReplacementTransform(simpler_rhs, f_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight key equation\n",
        "        key_equation = VGroup(*radial_rhs[1:], *f_rhs)\n",
        "\n",
        "        self.play(\n",
        "            key_equation.animate.set_x(0.25 * FRAME_WIDTH).to_edge(UP),\n",
        "            FadeOut(f_eq_g),\n",
        "            FadeOut(lhs),\n",
        "            FadeOut(radial_rhs[0]),\n",
        "        )\n",
        "        self.play(FlashAround(key_equation, time_width=1, run_time=2))\n",
        "\n",
        "        full_radial_rhs.set_opacity(1)\n",
        "        full_radial_rhs.move_to(key_equation).shift(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(full_radial_rhs, lag_ratio=0.02),\n",
        "            radial_rhs[1:].animate.next_to(full_radial_rhs, LEFT, aligned_edge=DOWN),\n",
        "            key_equation[4:].animate.next_to(full_radial_rhs, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name as a functional equation\n",
        "        func_eq_name = Text(\"Functional\\nequation\")\n",
        "        func_eq_name.to_corner(UL)\n",
        "        func_eq_name.match_y(key_equation)\n",
        "        arrow = Arrow(func_eq_name, radial_rhs[1].get_left(), buff=0.25)\n",
        "        func_eq_name.to_edge(UP)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, properties, shift=LEFT, lag_ratio=0.2))\n",
        "        self.play(\n",
        "            Write(func_eq_name),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Example\n",
        "        example_box = Rectangle(4, 3)\n",
        "        example_box.set_stroke(TEAL, 2)\n",
        "        example_box.set_fill(TEAL, 0.35)\n",
        "        example_box.to_corner(DL, buff=0)\n",
        "        example_word = Text(\"For example\", font_size=30)\n",
        "        example_word.next_to(example_box.get_top(), DOWN, SMALL_BUFF)\n",
        "        example_f = Tex(R\"f({r}) = e^{-{r}^2}\", **kw)\n",
        "        example_f.scale(0.75)\n",
        "        example_f.next_to(example_word, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(example_box),\n",
        "            FadeIn(example_word, 0.5 * DOWN)\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(key_equation[:4], example_f[:4]),\n",
        "            GrowFromPoint(example_f[4:], key_equation.get_left()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Define h\n",
        "        let = Text(\"Let\")\n",
        "        h_def = Tex(R\"h({x}) = f(\\sqrt{{x}})\", **kw)\n",
        "        h_def.next_to(key_equation, DOWN, LARGE_BUFF)\n",
        "        let.next_to(h_def, LEFT, MED_LARGE_BUFF)\n",
        "        h_def2 = Tex(R\"h({x}^2) = f({x})\", **kw)\n",
        "        h_def2.next_to(h_def[\"h\"], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        h_eq = Tex(R\"h(x^2 + y^2) = h(x^2) h(y^2)\", **kw)\n",
        "        h_eq.to_corner(UR)\n",
        "        h_eq.to_edge(RIGHT, buff=1.25)\n",
        "\n",
        "        example_h = Tex(R\"h({r}) = e^{-{r}}\", **kw)\n",
        "        example_h.scale(0.75)\n",
        "        example_h.next_to(example_f, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(h_def, DOWN), Write(let))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(\n",
        "            h_def.copy(), h_def2,\n",
        "            key_map={R\"\\sqrt\": \"^2\"},\n",
        "            run_time=1\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(h_def, example_h)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            VGroup(key_equation, full_radial_rhs).animate.scale(0.8).to_edge(LEFT),\n",
        "            VGroup(let, h_def, h_def2).animate.scale(0.8).to_edge(LEFT),\n",
        "            FadeOut(func_eq_name, LEFT),\n",
        "            Uncreate(arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(*full_radial_rhs[1:], *f_rhs).copy(),\n",
        "                h_eq\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Exponential property\n",
        "        sum_box = SurroundingRectangle(h_eq[\"x^2 + y^2\"])\n",
        "        prod_box = SurroundingRectangle(h_eq[\"h(x^2) h(y^2)\"])\n",
        "        sum_words = Text(\"Adding inputs\", font_size=30)\n",
        "        sum_words.next_to(sum_box, DOWN)\n",
        "        prod_words = Text(\"Multiplying outputs\", font_size=30)\n",
        "        prod_words.next_to(prod_box, DOWN)\n",
        "\n",
        "        VGroup(sum_box, prod_box).set_stroke(TEAL, 2)\n",
        "        VGroup(sum_words, prod_words).set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sum_box),\n",
        "            FadeIn(sum_words, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(sum_box, prod_box),\n",
        "            FadeTransform(sum_words, prod_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(prod_box), FadeOut(prod_words))\n",
        "        self.wait()\n",
        "\n",
        "        # Multi-input property\n",
        "        implies = Tex(R\"\\Downarrow\", font_size=72)\n",
        "        implies.next_to(h_eq, DOWN)\n",
        "        full_h_eq = Tex(R\"h(x_1 + x_2 + \\cdots + x_n) = h(x_1)h(x_2) \\cdots h(x_n)\")\n",
        "        for s, color in zip([\"1\", \"2\", \"n\"], color_gradient([BLUE, YELLOW], 3)):\n",
        "            full_h_eq[f\"x_{s}\"].set_color(color)\n",
        "        full_h_eq.scale(0.75)\n",
        "        full_h_eq.next_to(implies, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(implies),\n",
        "            FadeIn(full_h_eq, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Whole numbers\n",
        "        implies2 = implies.copy()\n",
        "        implies2.next_to(full_h_eq, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        five_eq = Tex(R\"h(5) &= h(1 + 1 + 1 + 1 + 1) \\\\ &= h(1)h(1)h(1)h(1)h(1) = h(1)^5\")\n",
        "        five_eq.next_to(implies2, DOWN)\n",
        "        five_eq.to_edge(RIGHT)\n",
        "\n",
        "        n_eq = Tex(R\"h(n) = h(1 + \\cdots + 1) = h(1) \\cdots h(1) = h(1)^n\")\n",
        "        n_eq.scale(0.75)\n",
        "        n_eq.next_to(implies2, DOWN, MED_LARGE_BUFF)\n",
        "        sum_brace = Brace(n_eq[R\"1 + \\cdots + 1\"], UP, SMALL_BUFF)\n",
        "        sum_tex = sum_brace.get_tex(R\"n \\text{ times}\", buff=SMALL_BUFF).scale(0.5, about_edge=DOWN)\n",
        "        prod_brace = Brace(n_eq[R\"h(1) \\cdots h(1)\"], UP, SMALL_BUFF)\n",
        "        prod_tex = prod_brace.get_tex(R\"n \\text{ times}\", buff=SMALL_BUFF).scale(0.5, about_edge=DOWN)\n",
        "\n",
        "        for tex in n_eq, sum_tex, prod_tex:\n",
        "            tex[\"n\"].set_color(BLUE)\n",
        "\n",
        "        self.play(Write(five_eq[\"h(5)\"]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(five_eq[\"h(\"][0], five_eq[\"h(\"][1]),\n",
        "            TransformFromCopy(five_eq[\")\"][0], five_eq[\")\"][1]),\n",
        "            Write(five_eq[\"=\"][0]),\n",
        "        )\n",
        "        self.play(ShowIncreasingSubsets(five_eq[\"1 + 1 + 1 + 1 + 1\"][0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(\n",
        "                five_eq[\"= h(1 + 1 + 1 + 1 + 1)\"].copy(),\n",
        "                five_eq[\"= h(1)h(1)h(1)h(1)h(1)\"],\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(five_eq[\"= h(1)^5\"]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(five_eq), FadeIn(n_eq), FadeIn(implies2))\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromCenter(sum_brace),\n",
        "            FadeIn(sum_tex, 0.25 * DOWN),\n",
        "            GrowFromCenter(prod_brace),\n",
        "            FadeIn(prod_tex, 0.25 * DOWN),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Exponential equation\n",
        "        exp_eq1 = Tex(R\"h(n) = h(1)^n\")\n",
        "        exp_eq2 = Tex(R\"h(n) = b^n\")\n",
        "        for eq in exp_eq1, exp_eq2:\n",
        "            eq[\"n\"].set_color(BLUE)\n",
        "        exp_eq1.next_to(n_eq, DOWN, MED_LARGE_BUFF)\n",
        "        exp_eq2.move_to(exp_eq1, LEFT)\n",
        "        h1_rect = SurroundingRectangle(exp_eq1[\"h(1)\"], buff=0.05)\n",
        "        h1_rect.set_stroke(YELLOW, 1)\n",
        "        h1_words = Text(\"Some number\", font_size=30)\n",
        "        h1_words.match_color(h1_rect)\n",
        "        h1_words.next_to(h1_rect, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(n_eq[\"h(n)\"], exp_eq1[\"h(n)\"]),\n",
        "            TransformFromCopy(n_eq[\"= h(1)^n\"], exp_eq1[\"= h(1)^n\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(h1_rect), FadeIn(h1_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(exp_eq1, exp_eq2),\n",
        "            FadeOut(h1_rect, scale=0.5),\n",
        "            FadeOut(h1_words, scale=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show exercises\n",
        "        self.play(\n",
        "            exp_eq2.animate.next_to(implies2, DOWN),\n",
        "            FadeOut(VGroup(n_eq, sum_brace, sum_tex, prod_brace, prod_tex), UP),\n",
        "        )\n",
        "        rational_eq = Tex(R\"h(p / q) = b^{\\,p / q}\")\n",
        "        rational_eq[\"p / q\"].set_color(RED)\n",
        "        rational_eq.move_to(exp_eq2)\n",
        "\n",
        "        exercise = TexText(R\"Exercise: Show this is also true for rational inputs, $p / q$\")\n",
        "        exercise[\"p / q\"].set_color(RED)\n",
        "        hint = TexText(R\"Hint, think about $h\\left(\\frac{p}{q} + \\cdots + \\frac{p}{q} \\right)$\")\n",
        "\n",
        "        exercise.next_to(rational_eq, DOWN, LARGE_BUFF)\n",
        "        exercise.to_edge(RIGHT)\n",
        "        hint.scale(0.7)\n",
        "        hint.set_fill(GREY_A)\n",
        "        hint.next_to(exercise, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(exercise),\n",
        "            FadeOut(VGroup(example_box, example_word, example_f, example_h), shift=DL),\n",
        "        )\n",
        "        self.wait()\n",
        "        pq_target = rational_eq[\"p / q\"].copy()\n",
        "        self.play(\n",
        "            TransformMatchingTex(exp_eq2, rational_eq),\n",
        "            TransformMatchingShapes(exercise[\"p / q\"].copy(), pq_target),\n",
        "        )\n",
        "        self.remove(pq_target)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(hint, DOWN))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(exercise, 0.5 * DOWN),\n",
        "            FadeOut(hint, 0.5 * DOWN),\n",
        "            lag_ratio=0.25,\n",
        "        ))\n",
        "\n",
        "        # Continuity\n",
        "        assumption = TexText(R\"Assuming $f$ (and hence also $h$) \\\\ is continuous...\", font_size=36)\n",
        "        assumption.next_to(rational_eq, LEFT, buff=2.0, aligned_edge=UP)\n",
        "        assumption.shift(0.5 * DOWN)\n",
        "\n",
        "        hx_eq = Tex(\"h(x) = b^x\", **kw)\n",
        "        hx_eq.move_to(rational_eq)\n",
        "        range1 = TexText(R\"For all $x \\in \\mathds{R}$\", **kw)\n",
        "        range2 = TexText(R\"For all $x \\in \\mathds{R}^+$\", **kw)\n",
        "        for ran in range1, range2:\n",
        "            ran.scale(0.75)\n",
        "            ran.next_to(hx_eq, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        arrow = Arrow(assumption, hx_eq)\n",
        "\n",
        "        self.play(FadeIn(assumption, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            TransformMatchingTex(rational_eq, hx_eq)\n",
        "        )\n",
        "        self.play(FadeIn(range1, DOWN))\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(range1, range2))\n",
        "        self.wait()\n",
        "\n",
        "        # Swap out for e\n",
        "        hx_eq2 = Tex(R\"h(x) = e^{{c} x}\", **kw)\n",
        "        hx_eq2.move_to(hx_eq)\n",
        "        hx_eq2[\"c\"].set_color(RED)\n",
        "\n",
        "        b_rect = SurroundingRectangle(hx_eq[\"b\"], buff=0.05)\n",
        "        b_rect.set_stroke(PINK, 2)\n",
        "        b_words = Text(\"Some constant\", font_size=30)\n",
        "        b_words.next_to(b_rect, DOWN, SMALL_BUFF, LEFT)\n",
        "        b_words.match_color(b_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(assumption, LEFT),\n",
        "            Uncreate(arrow),\n",
        "            FadeOut(range2, LEFT),\n",
        "            ShowCreation(b_rect),\n",
        "            Write(b_words, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        c = hx_eq2[\"{c}\"][0][0]\n",
        "        c_copy = c.copy()\n",
        "        c.set_opacity(0)\n",
        "        self.play(\n",
        "            ReplacementTransform(b_rect, c_copy),\n",
        "            TransformMatchingTex(hx_eq, hx_eq2, key_map={\"b\": \"e\"}),\n",
        "            FadeOut(b_words, 0.2 * DOWN),\n",
        "        )\n",
        "        self.remove(c_copy)\n",
        "        c.set_opacity(1)\n",
        "        self.add(hx_eq2)\n",
        "        self.wait()\n",
        "\n",
        "        # Write final form for f\n",
        "        implies3 = implies2.copy()\n",
        "        implies3.rotate(-90 * DEGREES)\n",
        "        implies3.next_to(hx_eq2, LEFT)\n",
        "        f_form = Tex(R\"f(x) = e^{cx^2}\", **kw)\n",
        "        f_form[\"c\"].set_color(RED)\n",
        "        f_form.next_to(implies3, LEFT)\n",
        "        f_form.align_to(hx_eq2, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(implies3),\n",
        "            TransformMatchingTex(hx_eq2.copy(), f_form, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        f_form.generate_target()\n",
        "        f_form.target.scale(1.5, about_edge=RIGHT)\n",
        "        rect = SurroundingRectangle(f_form.target)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        self.play(\n",
        "            MoveToTarget(f_form),\n",
        "            FlashAround(f_form.target, time_width=1, run_time=2, stroke_width=5),\n",
        "            ShowCreation(rect, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VariableC(InteractiveScene):\n",
        "    c_values = [1.0, 0.5, -1.0, -0.7, -0.5, 0.25, -0.2, -0.4, -0.9, -0.1, 0.5, 0.3, 0.1]\n",
        "\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        curve = axes.get_graph(lambda x: self.func(x, 1))\n",
        "        curve.set_stroke(RED, 3)\n",
        "        self.add(curve)\n",
        "\n",
        "        label = self.get_label(axes)\n",
        "        self.add(label)\n",
        "\n",
        "        c_tracker, c_interval, c_tip, c_label = self.get_c_group()\n",
        "        get_c = c_tracker.get_value\n",
        "\n",
        "        c_interval.move_to(axes, UR)\n",
        "        c_interval.shift(0.5 * DOWN)\n",
        "        self.add(c_interval, c_tip, c_label)\n",
        "\n",
        "        axes.bind_graph_to_func(curve, lambda x: self.func(x, get_c()))\n",
        "\n",
        "        # Animate\n",
        "        for c in self.c_values:\n",
        "            self.play(c_tracker.animate.set_value(c), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "    def get_c_group(self):\n",
        "        c_tracker = ValueTracker(1)\n",
        "        get_c = c_tracker.get_value\n",
        "\n",
        "        c_interval = NumberLine(\n",
        "            (-1, 1, 0.25), width=3, tick_size=0.05, big_tick_numbers=[-1, 0, 1],\n",
        "        )\n",
        "        c_interval.set_stroke(WHITE, 1)\n",
        "        c_interval.add_numbers([-1, 0, 1], num_decimal_places=1, font_size=16)\n",
        "        c_tip = ArrowTip(angle=-90 * DEGREES)\n",
        "        c_tip.scale(0.5)\n",
        "        c_tip.set_fill(RED)\n",
        "        c_tip.add_updater(lambda m: m.move_to(c_interval.n2p(get_c()), DOWN))\n",
        "\n",
        "        c_label = Tex(\"c = 1.00\", t2c={\"c\": RED}, font_size=36)\n",
        "        c_label.make_number_changeable(\"1.00\")\n",
        "        c_label[-1].scale(0.8, about_edge=LEFT)\n",
        "        c_label.add_updater(lambda m: m[-1].set_value(get_c()))\n",
        "        c_label.add_updater(lambda m: m.next_to(c_tip, UP, aligned_edge=LEFT))\n",
        "\n",
        "        return [c_tracker, c_interval, c_tip, c_label]\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = Axes(\n",
        "            (-1, 5), (0, 4),\n",
        "            width=6, height=4,\n",
        "        )\n",
        "        return axes\n",
        "\n",
        "    def func(self, x, c):\n",
        "        return np.exp(c * x)\n",
        "\n",
        "    def get_label(self, axes):\n",
        "        label = Tex(\"e^{cx}\", t2c={\"c\": RED})\n",
        "        label.next_to(axes.c2p(0, 2.7), RIGHT)\n",
        "        return label\n",
        "\n",
        "\n",
        "class VariableCWithF(VariableC):\n",
        "    def get_axes(self):\n",
        "        axes = Axes(\n",
        "            (-4, 4), (0, 2),\n",
        "            width=8, height=3,\n",
        "        )\n",
        "        axes.add(VectorizedPoint(axes.c2p(0, 3)))\n",
        "        axes.center()\n",
        "        return axes\n",
        "\n",
        "    def func(self, x, c):\n",
        "        return np.exp(c * x * x)\n",
        "\n",
        "    def get_label(self, axes):\n",
        "        label = Tex(\"e^{cx^2}\", t2c={\"c\": RED})\n",
        "        label.next_to(axes.c2p(0, 2), LEFT)\n",
        "        return label\n",
        "\n",
        "\n",
        "class TalkAboutSignOfConstant3D(VariableCWithF):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        frame.add_updater(lambda m: m.reorient(20 * math.cos(0.1 * self.time), 75))\n",
        "\n",
        "        axes = ThreeDAxes((-4, 4), (-4, 4), (0, 1), depth=2)\n",
        "        axes.set_width(10)\n",
        "        axes.set_depth(2, stretch=True)\n",
        "        axes.center()\n",
        "        self.add(axes)\n",
        "\n",
        "        label = Tex(\"f(r) = e^{cr^2}\", t2c={\"c\": RED}, font_size=72)\n",
        "        label.next_to(ORIGIN, LEFT)\n",
        "        label.to_edge(UP)\n",
        "        label.fix_in_frame()\n",
        "\n",
        "        c_tracker, c_interval, c_tip, c_label = self.get_c_group()\n",
        "        get_c = c_tracker.get_value\n",
        "        c_interval.next_to(label, RIGHT, LARGE_BUFF)\n",
        "        c_interval.shift(0.5 * DOWN)\n",
        "        c_tracker.set_value(-1)\n",
        "\n",
        "        c_group = VGroup(c_interval, c_tip, c_label)\n",
        "        c_group.fix_in_frame()\n",
        "\n",
        "        # Graph\n",
        "        def get_graph(c):\n",
        "            surface = axes.get_graph(lambda x, y: np.exp(c * (x**2 + y**2)))\n",
        "            surface.always_sort_to_camera(self.camera)\n",
        "            surface.set_color(BLUE_E, 0.5)\n",
        "            mesh = SurfaceMesh(surface, (31, 31))\n",
        "            mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "            mesh.shift(0.001 * OUT)\n",
        "            x_slice = ParametricCurve(\n",
        "                lambda t: axes.c2p(t, 0, np.exp(c * t**2)),\n",
        "                t_range=(-4, 4, 0.1)\n",
        "            )\n",
        "            x_slice.set_stroke(RED, 2)\n",
        "            x_slice.set_flat_stroke(False)\n",
        "            return Group(mesh, surface, x_slice)\n",
        "\n",
        "        graph = get_graph(-1)\n",
        "\n",
        "        self.add(graph)\n",
        "        self.add(c_group)\n",
        "        self.add(label)\n",
        "\n",
        "        # Animations\n",
        "        for value in [-0.5, -0.8, -0.3, -1.0, -0.3, 0.05, 0.1, -0.3, -1.0, -0.7, -1.0]:\n",
        "            new_graph = get_graph(value)\n",
        "            self.play(\n",
        "                c_tracker.animate.set_value(value),\n",
        "                Transform(graph, new_graph),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class OldTalkAboutSignOfConstantScraps(InteractiveScene):\n",
        "    def construct(self):\n",
        "        plane.bind_graph_to_func(graph, lambda x: self.func(x, get_c()))\n",
        "        # Area\n",
        "        area = VMobject()\n",
        "        area.set_fill(RED, 0.5)\n",
        "        area.set_stroke(width=0)\n",
        "\n",
        "        def update_area(area):\n",
        "            area.set_points_as_corners([\n",
        "                plane.c2p(-4, 0),\n",
        "                *graph.get_anchors(),\n",
        "                plane.c2p(4, 0)\n",
        "            ])\n",
        "\n",
        "        area.add_updater(update_area)\n",
        "\n",
        "class OldTwoKeyProperties(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup equations\n",
        "        kw = dict(\n",
        "            t2c={\"x\": BLUE, \"y\": YELLOW, \"{r}\": RED, \"{c}\": PINK}\n",
        "        )\n",
        "        one_var = Tex(\"f_1(x) = e^{-x^2}\", **kw)\n",
        "        two_var = Tex(\"f_2(x, y) = e^{-(x^2 + y^2)}\", **kw)\n",
        "        factored = Tex(\"= f_1(x)f_1(y)\", **kw)\n",
        "        factored_exp = Tex(\"= e^{-x^2} e^{-y^2}\", **kw)\n",
        "        radial_exp = Tex(R\"= e^{-{r}^2}\", **kw)\n",
        "        radial = Tex(R\"= f_1({r})\", **kw)\n",
        "        radial_full = Tex(R\"= f_1(\\sqrt{x^2 + y^2})\", **kw)\n",
        "\n",
        "        expressions = VGroup(\n",
        "            one_var,\n",
        "            two_var,\n",
        "            factored_exp,\n",
        "            factored,\n",
        "            radial_exp,\n",
        "            radial,\n",
        "            radial_full,\n",
        "        )\n",
        "\n",
        "        expressions.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        expressions.to_corner(UL)\n",
        "        expressions.set_backstroke()\n",
        "\n",
        "        rhs1 = VGroup(factored_exp, factored)\n",
        "        rhs2 = VGroup(radial_exp, radial, radial_full)\n",
        "        for rhs in [rhs1, rhs2]:\n",
        "            rhs.arrange(RIGHT)\n",
        "            rhs.next_to(two_var, RIGHT)\n",
        "\n",
        "        for mob in expressions[2:]:\n",
        "            mob.shift((two_var[\"=\"].get_y() - mob[\"=\"].get_y()) * UP)\n",
        "\n",
        "        # From one to two\n",
        "        self.add(one_var, two_var)\n",
        "        self.wait()\n",
        "\n",
        "        rects = VGroup(SurroundingRectangle(one_var), SurroundingRectangle(two_var))\n",
        "        rects.set_stroke(TEAL, 2)\n",
        "        rect_words = VGroup(Text(\"1 variable\"), Text(\"2 variable\"))\n",
        "        for rect, words in zip(rects, rect_words):\n",
        "            words.next_to(rect, RIGHT)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            one_var.get_right(),\n",
        "            two_var.get_corner(UR) + 0.5 * LEFT,\n",
        "            path_arc=-PI,\n",
        "        )\n",
        "        words = Text(\"Two interpretations\")\n",
        "        words.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rects[0]),\n",
        "            FadeIn(rect_words[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(*rects),\n",
        "            FadeTransform(*rect_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        two_var_copy = two_var.copy()\n",
        "        self.play(\n",
        "            FadeOut(rects[1]),\n",
        "            FadeOut(rect_words[1]),\n",
        "            ShowCreation(arrow),\n",
        "            TransformMatchingTex(one_var.copy(), two_var_copy, run_time=1),\n",
        "            Write(words, run_time=1)\n",
        "        )\n",
        "        self.remove(two_var_copy)\n",
        "        self.wait()\n",
        "\n",
        "        # Factored\n",
        "        self.play(LaggedStart(\n",
        "            Write(factored_exp[\"=\"]),\n",
        "            TransformFromCopy(one_var[\"e^{-x^2}\"], factored_exp[\"e^{-x^2}\"]),\n",
        "            TransformFromCopy(one_var[\"e^{-x^2}\"], factored_exp[\"e^{-y^2}\"]),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.4,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            Write(factored[\"=\"]),\n",
        "            TransformFromCopy(one_var[\"f_1(x)\"], factored[\"f_1(x)\"], path_arc=PI / 4),\n",
        "            TransformFromCopy(one_var[\"f_1(x)\"], factored[\"f_1(y)\"], path_arc=PI / 4),\n",
        "            run_time=3,\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Rearrange\n",
        "        rhs1.generate_target()\n",
        "        rhs1.target.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        rhs1.target.next_to(two_var[\"=\"], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        rhs1.target.set_fill(opacity=0.5)\n",
        "        self.play(MoveToTarget(rhs1, path_arc=-PI / 2))\n",
        "\n",
        "        # Radial\n",
        "        self.play(\n",
        "            Write(radial_exp[\"=\"]),\n",
        "            TransformFromCopy(one_var[\"e^{-x^2}\"], radial_exp[\"e^{-{r}^2}\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(radial[\"=\"]),\n",
        "            TransformFromCopy(one_var[\"f_1(x)\"], radial[\"f_1({r})\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(radial_full, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Consolidate\n",
        "        prop = VGroup(factored, radial)\n",
        "        prop.generate_target()\n",
        "        prop.target.arrange(RIGHT)\n",
        "        prop.target.center().move_to(UP)\n",
        "        prop.target.set_opacity(1)\n",
        "        prop.target.scale(1.5)\n",
        "        prop.target[0][\"=\"].set_opacity(0).scale(0, about_edge=RIGHT)\n",
        "        prop.target.shift(0.5 * LEFT)\n",
        "\n",
        "        f2_eq = VGroup(two_var, radial_exp, factored_exp)\n",
        "        f2_eq.generate_target()\n",
        "        f2_eq.target.set_fill(opacity=0.5)\n",
        "        f2_eq.target[-1].next_to(f2_eq.target[-2], RIGHT)\n",
        "        f2_eq.target.to_corner(UR)\n",
        "\n",
        "        one_var.generate_target()\n",
        "        one_var.target.scale(1.5, about_edge=UL)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(words),\n",
        "            MoveToTarget(prop),\n",
        "            MoveToTarget(f2_eq),\n",
        "            FadeOut(radial_full),\n",
        "            lag_ratio=0.15,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlashAround(one_var.target, time_width=1.0, run_time=2),\n",
        "            MoveToTarget(one_var),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashUnder(factored[1:]))\n",
        "        self.wait()\n",
        "        self.play(FlashUnder(radial))\n",
        "        self.wait()\n",
        "\n",
        "        radial_full.set_opacity(1)\n",
        "        radial_full.scale(1.5)\n",
        "        radial_full.move_to(radial, LEFT)\n",
        "        radial_full.shift(0.1 * UP)\n",
        "        left_shift = 2.0 * LEFT\n",
        "        radial_full.shift(left_shift)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(radial_full),\n",
        "            radial.animate.next_to(radial_full, RIGHT),\n",
        "            factored.animate.shift(left_shift)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Flip the question\n",
        "        prop = VGroup(factored, radial_full, radial)\n",
        "        prop.generate_target()\n",
        "        prop.target.scale(1 / 1.5).to_edge(UP).shift(1.5 * RIGHT)\n",
        "\n",
        "        question = Text(\"What are all the functions \\n with this property?\")\n",
        "        question.next_to(prop.target, DOWN, buff=1.5)\n",
        "        question.to_edge(LEFT)\n",
        "        arrow = Arrow(question, prop.target[0], buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            one_var.animate.scale(1 / 1.5).to_corner(DL).set_opacity(0.5),\n",
        "            FadeOut(f2_eq, UP),\n",
        "            MoveToTarget(prop),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(question, lag_ratio=0.1),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Substitute h\n",
        "        h_eq = Tex(R\"h(x^2) h(y^2) = h(x^2 + y^2)\", **kw)\n",
        "        h_eq.next_to(prop, DOWN, buff=MED_LARGE_BUFF)\n",
        "        h_eq.shift((prop[1][\"=\"].get_x() - h_eq[\"=\"].get_x()) * RIGHT)\n",
        "        h_def = Tex(R\"h(x) = f_1(\\sqrt{x})\", **kw)\n",
        "        h_def.to_edge(LEFT).match_y(h_eq)\n",
        "        h_def2 = Tex(R\"h(x^2) = f_1(x)\", **kw)\n",
        "        h_def2.next_to(h_def, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        example_box = Rectangle(4, 4)\n",
        "        example_box.set_stroke(TEAL, 2)\n",
        "        example_box.set_fill(TEAL, 0.2)\n",
        "        example_box.to_corner(DL, buff=0)\n",
        "        example_word = Text(\"For example\", font_size=30)\n",
        "        example_word.next_to(example_box.get_top(), DOWN, SMALL_BUFF)\n",
        "        one_var.generate_target()\n",
        "        one_var.target.set_opacity(1)\n",
        "        one_var.target.next_to(example_word, DOWN, MED_LARGE_BUFF)\n",
        "        one_var.target.to_edge(LEFT)\n",
        "        h_example = Tex(R\"h(x) = e^{-x}\", **kw)\n",
        "        h_example.next_to(one_var.target, DOWN, MED_LARGE_BUFF)\n",
        "        h_example.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question, DOWN),\n",
        "            FadeOut(arrow, DOWN),\n",
        "            Write(h_def)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(h_def.copy(), h_def2))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(example_box, one_var)\n",
        "        self.play(\n",
        "            FadeIn(example_box),\n",
        "            FadeIn(example_word),\n",
        "            MoveToTarget(one_var),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(h_example, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FlashAround(prop[:2], time_width=1, run_time=2))\n",
        "        self.play(\n",
        "            TransformFromCopy(factored, h_eq[\"h(x^2) h(y^2)\"][0]),\n",
        "            TransformFromCopy(radial_full, h_eq[\"= h(x^2 + y^2)\"][0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Exponential property\n",
        "        h_box = SurroundingRectangle(h_eq)\n",
        "        exp_words = Text(\"Exponential property!\")\n",
        "        exp_words.next_to(h_box, DOWN)\n",
        "\n",
        "        sum_box = SurroundingRectangle(h_eq[\"x^2 + y^2\"])\n",
        "        prod_box = SurroundingRectangle(h_eq[\"h(x^2) h(y^2)\"])\n",
        "        sum_words = Text(\"Adding inputs\", font_size=30)\n",
        "        sum_words.next_to(sum_box, DOWN)\n",
        "        prod_words = Text(\"Multiplying outputs\", font_size=30)\n",
        "        prod_words.next_to(prod_box, DOWN)\n",
        "\n",
        "        VGroup(h_box, sum_box, prod_box).set_stroke(TEAL, 2)\n",
        "        VGroup(exp_words, sum_words, prod_words).set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sum_box),\n",
        "            FadeIn(sum_words, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(sum_box, prod_box),\n",
        "            FadeTransform(sum_words, prod_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(prod_box, h_box),\n",
        "            FadeTransform(prod_words, exp_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Exponent\n",
        "        implies = Tex(R\"\\Downarrow\", font_size=72)\n",
        "        implies.next_to(h_eq, DOWN)\n",
        "        implies.rotate(PI)\n",
        "        h_exp = Tex(R\"h(x) = a \\cdot b^x\", **kw)\n",
        "        h_exp.next_to(implies, DOWN)\n",
        "        h_exp2 = Tex(R\"h(x) = a \\cdot e^{{c}x}\", **kw)\n",
        "        h_exp2.move_to(h_exp)\n",
        "        h_exp0 = Tex(R\"h(x) = b^x\", **kw)\n",
        "        h_exp0.move_to(h_exp)\n",
        "        assumption = TexText(\"Assuming $h$ is continuous\", font_size=24)\n",
        "        assumption.next_to(implies, RIGHT)\n",
        "\n",
        "        b_rect = SurroundingRectangle(h_exp[\"b\"], buff=SMALL_BUFF)\n",
        "        b_rect.set_stroke(PINK, 2)\n",
        "        b_words = Text(\"Some constant\", font_size=30)\n",
        "        b_words.next_to(b_rect, DOWN, SMALL_BUFF, LEFT)\n",
        "        b_words.match_color(b_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(h_box, implies),\n",
        "            FadeTransform(exp_words, h_exp0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(h_exp0, h_exp, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(implies, PI),\n",
        "            FadeIn(assumption, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(b_rect),\n",
        "            Write(b_words, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        c = h_exp2[\"{c}\"][0][0]\n",
        "        c_copy = c.copy()\n",
        "        c.set_opacity(0)\n",
        "        self.play(\n",
        "            ReplacementTransform(b_rect, c_copy),\n",
        "            TransformMatchingTex(h_exp, h_exp2),\n",
        "            FadeOut(b_words, 0.2 * DOWN),\n",
        "        )\n",
        "        self.remove(c_copy)\n",
        "        c.set_opacity(1)\n",
        "        self.add(h_exp2)\n",
        "        self.wait()\n",
        "\n",
        "        # Final form\n",
        "        implies2 = implies.copy()\n",
        "        implies2.next_to(h_exp2, DOWN, MED_LARGE_BUFF)\n",
        "        f_eq = Tex(R\"f_1(x) = a \\cdot e^{{c}x^2}\", **kw)\n",
        "        f_eq.next_to(implies2, DOWN)\n",
        "        rect = SurroundingRectangle(f_eq)\n",
        "        rect.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(h_exp2.copy(), f_eq),\n",
        "            Write(implies2, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(rect, run_time=2),\n",
        "            FlashAround(f_eq, time_width=1, run_time=2, stroke_width=5),\n",
        "        )\n",
        "        self.wait()\n"
    ]
}