{
    "topic": "demonstrates the concept of sliding blocks on a frictionless surface. The blocks are",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "OUTPUT_DIRECTORY = \"clacks/question\"\n",
        "\n",
        "\n",
        "class Block(Square):\n",
        "    CONFIG = {\n",
        "        \"mass\": 1,\n",
        "        \"velocity\": 0,\n",
        "        \"width\": None,\n",
        "        \"label_text\": None,\n",
        "        \"label_scale_value\": 0.8,\n",
        "        \"fill_opacity\": 1,\n",
        "        \"stroke_width\": 3,\n",
        "        \"stroke_color\": WHITE,\n",
        "        \"fill_color\": None,\n",
        "        \"sheen_direction\": UL,\n",
        "        \"sheen_factor\": 0.5,\n",
        "        \"sheen_direction\": UL,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        if self.width is None:\n",
        "            self.width = self.mass_to_width(self.mass)\n",
        "        if self.fill_color is None:\n",
        "            self.fill_color = self.mass_to_color(self.mass)\n",
        "        if self.label_text is None:\n",
        "            self.label_text = self.mass_to_label_text(self.mass)\n",
        "        if \"width\" in kwargs:\n",
        "            kwargs.pop(\"width\")\n",
        "        Square.__init__(self, side_length=self.width, **kwargs)\n",
        "        self.label = self.get_label()\n",
        "        self.add(self.label)\n",
        "\n",
        "    def get_label(self):\n",
        "        label = OldTexText(self.label_text)\n",
        "        label.scale(self.label_scale_value)\n",
        "        label.next_to(self, UP, SMALL_BUFF)\n",
        "        return label\n",
        "\n",
        "    def get_points_defining_boundary(self):\n",
        "        return self.get_points()\n",
        "\n",
        "    def mass_to_color(self, mass):\n",
        "        colors = [\n",
        "            GREY_B,\n",
        "            BLUE_D,\n",
        "            BLUE_D,\n",
        "            BLUE_E,\n",
        "            BLUE_E,\n",
        "            GREY_D,\n",
        "            GREY_D,\n",
        "            BLACK,\n",
        "        ]\n",
        "        index = min(int(np.log10(mass)), len(colors) - 1)\n",
        "        return colors[index]\n",
        "\n",
        "    def mass_to_width(self, mass):\n",
        "        return 1 + 0.25 * np.log10(mass)\n",
        "\n",
        "    def mass_to_label_text(self, mass):\n",
        "        return \"{:,}\\\\,kg\".format(int(mass))\n",
        "\n",
        "\n",
        "class SlidingBlocks(VGroup):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"distance\": 7,\n",
        "            \"mass\": 1e6,\n",
        "            \"velocity\": -2,\n",
        "        },\n",
        "        \"block2_config\": {\n",
        "            \"distance\": 3,\n",
        "            \"mass\": 1,\n",
        "            \"velocity\": 0,\n",
        "        },\n",
        "        \"collect_clack_data\": True,\n",
        "    }\n",
        "\n",
        "    def __init__(self, scene, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        self.scene = scene\n",
        "        self.floor = scene.floor\n",
        "        self.wall = scene.wall\n",
        "\n",
        "        self.block1 = self.get_block(**self.block1_config)\n",
        "        self.block2 = self.get_block(**self.block2_config)\n",
        "        self.mass_ratio = self.block2.mass / self.block1.mass\n",
        "        self.phase_space_point_tracker = self.get_phase_space_point_tracker()\n",
        "        self.add(\n",
        "            self.block1, self.block2,\n",
        "            self.phase_space_point_tracker,\n",
        "        )\n",
        "        self.add_updater(self.__class__.update_positions)\n",
        "\n",
        "        if self.collect_clack_data:\n",
        "            self.clack_data = self.get_clack_data()\n",
        "\n",
        "    def get_block(self, distance, **kwargs):\n",
        "        block = Block(**kwargs)\n",
        "        block.move_to(\n",
        "            self.floor.get_top()[1] * UP +\n",
        "            (self.wall.get_right()[0] + distance) * RIGHT,\n",
        "            DL,\n",
        "        )\n",
        "        return block\n",
        "\n",
        "    def get_phase_space_point_tracker(self):\n",
        "        block1, block2 = self.block1, self.block2\n",
        "        w2 = block2.get_width()\n",
        "        s1 = block1.get_left()[0] - self.wall.get_right()[0] - w2\n",
        "        s2 = block2.get_right()[0] - self.wall.get_right()[0] - w2\n",
        "        result = VectorizedPoint([\n",
        "            s1 * np.sqrt(block1.mass),\n",
        "            s2 * np.sqrt(block2.mass),\n",
        "            0\n",
        "        ])\n",
        "\n",
        "        result.velocity = np.array([\n",
        "            np.sqrt(block1.mass) * block1.velocity,\n",
        "            np.sqrt(block2.mass) * block2.velocity,\n",
        "            0\n",
        "        ])\n",
        "        return result\n",
        "\n",
        "    def update_positions(self, dt):\n",
        "        self.phase_space_point_tracker.shift(\n",
        "            self.phase_space_point_tracker.velocity * dt\n",
        "        )\n",
        "        self.update_blocks_from_phase_space_point_tracker()\n",
        "\n",
        "    def update_blocks_from_phase_space_point_tracker(self):\n",
        "        block1, block2 = self.block1, self.block2\n",
        "        ps_point = self.phase_space_point_tracker.get_location()\n",
        "\n",
        "        theta = np.arctan(np.sqrt(self.mass_ratio))\n",
        "        ps_point_angle = angle_of_vector(ps_point)\n",
        "        n_clacks = int(ps_point_angle / theta)\n",
        "        reflected_point = rotate_vector(\n",
        "            ps_point,\n",
        "            -2 * np.ceil(n_clacks / 2) * theta\n",
        "        )\n",
        "        reflected_point = np.abs(reflected_point)\n",
        "\n",
        "        shadow_wall_x = self.wall.get_right()[0] + block2.get_width()\n",
        "        floor_y = self.floor.get_top()[1]\n",
        "        s1 = reflected_point[0] / np.sqrt(block1.mass)\n",
        "        s2 = reflected_point[1] / np.sqrt(block2.mass)\n",
        "        block1.move_to(\n",
        "            (shadow_wall_x + s1) * RIGHT +\n",
        "            floor_y * UP,\n",
        "            DL,\n",
        "        )\n",
        "        block2.move_to(\n",
        "            (shadow_wall_x + s2) * RIGHT +\n",
        "            floor_y * UP,\n",
        "            DR,\n",
        "        )\n",
        "\n",
        "        self.scene.update_num_clacks(n_clacks)\n",
        "\n",
        "    def get_clack_data(self):\n",
        "        ps_point = self.phase_space_point_tracker.get_location()\n",
        "        ps_velocity = self.phase_space_point_tracker.velocity\n",
        "        if ps_velocity[1] != 0:\n",
        "            raise Exception(\n",
        "                \"Haven't implemented anything to gather clack \"\n",
        "                \"data from a start state with block2 moving\"\n",
        "            )\n",
        "        y = ps_point[1]\n",
        "        theta = np.arctan(np.sqrt(self.mass_ratio))\n",
        "\n",
        "        clack_data = []\n",
        "        for k in range(1, int(PI / theta) + 1):\n",
        "            clack_ps_point = np.array([\n",
        "                y / np.tan(k * theta),\n",
        "                y,\n",
        "                0\n",
        "            ])\n",
        "            time = get_norm(ps_point - clack_ps_point) / get_norm(ps_velocity)\n",
        "            reflected_point = rotate_vector(\n",
        "                clack_ps_point,\n",
        "                -2 * np.ceil((k - 1) / 2) * theta\n",
        "            )\n",
        "            block2 = self.block2\n",
        "            s2 = reflected_point[1] / np.sqrt(block2.mass)\n",
        "            location = np.array([\n",
        "                self.wall.get_right()[0] + s2,\n",
        "                block2.get_center()[1],\n",
        "                0\n",
        "            ])\n",
        "            if k % 2 == 1:\n",
        "                location += block2.get_width() * RIGHT\n",
        "            clack_data.append((location, time))\n",
        "        return clack_data\n",
        "\n",
        "\n",
        "# TODO, this is untested after turning it from a\n",
        "# ContinualAnimation into a VGroup\n",
        "class ClackFlashes(VGroup):\n",
        "    CONFIG = {\n",
        "        \"flash_config\": {\n",
        "            \"run_time\": 0.5,\n",
        "            \"line_length\": 0.1,\n",
        "            \"flash_radius\": 0.2,\n",
        "        },\n",
        "        \"start_up_time\": 0,\n",
        "        \"min_time_between_flashes\": 1 / 30,\n",
        "    }\n",
        "\n",
        "    def __init__(self, clack_data, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        self.flashes = []\n",
        "        last_time = 0\n",
        "        for location, time in clack_data:\n",
        "            if (time - last_time) < self.min_time_between_flashes:\n",
        "                continue\n",
        "            last_time = time\n",
        "            flash = Flash(location, **self.flash_config)\n",
        "            flash.begin()\n",
        "            for sm in flash.mobject.family_members_with_points():\n",
        "                if isinstance(sm, VMobject):\n",
        "                    sm.set_stroke(YELLOW, 3)\n",
        "                    sm.set_stroke(WHITE, 6, 0.5, background=True)\n",
        "            flash.start_time = time\n",
        "            flash.end_time = time + flash.run_time\n",
        "            self.flashes.append(flash)\n",
        "\n",
        "        self.time = 0\n",
        "        self.add_updater(lambda m: m.update(dt))\n",
        "\n",
        "    def update(self, dt):\n",
        "        time = self.time\n",
        "        self.time += dt\n",
        "        for flash in self.flashes:\n",
        "            if flash.start_time < time < flash.end_time:\n",
        "                if flash.mobject not in self.submobjects:\n",
        "                    self.add(flash.mobject)\n",
        "                flash.update(\n",
        "                    (time - flash.start_time) / flash.run_time\n",
        "                )\n",
        "            else:\n",
        "                if flash.mobject in self.submobjects:\n",
        "                    self.remove(flash.mobject)\n",
        "\n",
        "\n",
        "class Wall(Line):\n",
        "    CONFIG = {\n",
        "        \"tick_spacing\": 0.5,\n",
        "        \"tick_length\": 0.25,\n",
        "        \"tick_style\": {\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_color\": WHITE,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def __init__(self, height, **kwargs):\n",
        "        Line.__init__(self, ORIGIN, height * UP, **kwargs)\n",
        "        self.height = height\n",
        "        self.ticks = self.get_ticks()\n",
        "        self.add(self.ticks)\n",
        "\n",
        "    def get_ticks(self):\n",
        "        n_lines = int(self.height / self.tick_spacing)\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, self.tick_length * UR).shift(n * self.tick_spacing * UP)\n",
        "            for n in range(n_lines)\n",
        "        ])\n",
        "        lines.set_style(**self.tick_style)\n",
        "        lines.move_to(self, DR)\n",
        "        return lines\n",
        "\n",
        "\n",
        "class BlocksAndWallScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"include_sound\": True,\n",
        "        \"collision_sound\": \"clack.wav\",\n",
        "        \"count_clacks\": True,\n",
        "        \"counter_group_shift_vect\": LEFT,\n",
        "        \"sliding_blocks_config\": {},\n",
        "        \"floor_y\": -2,\n",
        "        \"wall_x\": -6,\n",
        "        \"n_wall_ticks\": 15,\n",
        "        \"counter_label\": \"\\\\# Collisions: \",\n",
        "        \"show_flash_animations\": True,\n",
        "        \"min_time_between_sounds\": 0.004,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.track_time()\n",
        "        self.add_floor_and_wall()\n",
        "        self.add_blocks()\n",
        "        if self.show_flash_animations:\n",
        "            self.add_flash_animations()\n",
        "\n",
        "        if self.count_clacks:\n",
        "            self.add_counter()\n",
        "\n",
        "    def add_floor_and_wall(self):\n",
        "        self.floor = self.get_floor()\n",
        "        self.wall = self.get_wall()\n",
        "        self.add(self.floor, self.wall)\n",
        "\n",
        "    def add_blocks(self):\n",
        "        self.blocks = SlidingBlocks(self, **self.sliding_blocks_config)\n",
        "        if hasattr(self.blocks, \"clack_data\"):\n",
        "            self.clack_data = self.blocks.clack_data\n",
        "        self.add(self.blocks)\n",
        "\n",
        "    def add_flash_animations(self):\n",
        "        self.clack_flashes = ClackFlashes(self.clack_data)\n",
        "        self.add(self.clack_flashes)\n",
        "\n",
        "    def track_time(self):\n",
        "        time_tracker = ValueTracker()\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.add(time_tracker)\n",
        "        self.get_time = time_tracker.get_value\n",
        "\n",
        "    def add_counter(self):\n",
        "        self.n_clacks = 0\n",
        "        counter_label = OldTexText(self.counter_label)\n",
        "        counter_mob = Integer(self.n_clacks)\n",
        "        counter_mob.next_to(\n",
        "            counter_label[-1], RIGHT,\n",
        "        )\n",
        "        counter_mob.align_to(counter_label[-1][-1], DOWN)\n",
        "        counter_group = VGroup(\n",
        "            counter_label,\n",
        "            counter_mob,\n",
        "        )\n",
        "        counter_group.to_corner(UR)\n",
        "        counter_group.shift(self.counter_group_shift_vect)\n",
        "        self.add(counter_group)\n",
        "\n",
        "        self.counter_mob = counter_mob\n",
        "\n",
        "    def get_wall(self):\n",
        "        height = (FRAME_HEIGHT / 2) - self.floor_y\n",
        "        wall = Wall(height=height)\n",
        "        wall.shift(self.wall_x * RIGHT)\n",
        "        wall.to_edge(UP, buff=0)\n",
        "        return wall\n",
        "\n",
        "    def get_floor(self):\n",
        "        floor = Line(self.wall_x * RIGHT, FRAME_WIDTH * RIGHT / 2)\n",
        "        floor.shift(self.floor_y * UP)\n",
        "        return floor\n",
        "\n",
        "    def update_num_clacks(self, n_clacks):\n",
        "        if hasattr(self, \"n_clacks\"):\n",
        "            if n_clacks == self.n_clacks:\n",
        "                return\n",
        "            self.counter_mob.set_value(n_clacks)\n",
        "\n",
        "    def add_clack_sounds(self, clack_data):\n",
        "        clack_file = self.collision_sound\n",
        "        total_time = self.get_time()\n",
        "        times = [\n",
        "            time\n",
        "            for location, time in clack_data\n",
        "            if time < total_time\n",
        "        ]\n",
        "        last_time = 0\n",
        "        for time in times:\n",
        "            d_time = time - last_time\n",
        "            if d_time < self.min_time_between_sounds:\n",
        "                continue\n",
        "            last_time = time\n",
        "            self.add_sound(\n",
        "                clack_file,\n",
        "                time_offset=(time - total_time),\n",
        "                gain=-20,\n",
        "            )\n",
        "        return self\n",
        "\n",
        "    def tear_down(self):\n",
        "        super().tear_down()\n",
        "        if self.include_sound:\n",
        "            self.add_clack_sounds(self.clack_data)\n",
        "\n",
        "# Animated scenes\n",
        "\n",
        "\n",
        "class NameIntro(Scene):\n",
        "    def construct(self):\n",
        "        name = OldTexText(\"3Blue\", \"1Brown\", arg_separator=\"\")\n",
        "        blue, brown = name\n",
        "        name.scale(2.5)\n",
        "        for part in name:\n",
        "            part.save_state()\n",
        "        brown.to_edge(RIGHT, buff=0)\n",
        "        flash_time = 0.75\n",
        "\n",
        "        self.add(blue, brown)\n",
        "        self.play(\n",
        "            VFadeIn(blue),\n",
        "            VFadeIn(brown),\n",
        "            Restore(brown, rate_func=linear),\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(blue.get_right(), run_time=flash_time),\n",
        "            ApplyMethod(\n",
        "                blue.to_edge, LEFT, {\"buff\": 0},\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(blue.get_left(), run_time=flash_time),\n",
        "            Restore(blue, rate_func=linear),\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(blue.get_right(), run_time=flash_time),\n",
        "            ApplyMethod(\n",
        "                brown.to_edge, RIGHT, {\"buff\": 0},\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(brown.get_right(), run_time=flash_time),\n",
        "            Restore(brown, rate_func=linear)\n",
        "        )\n",
        "\n",
        "\n",
        "class MathAndPhysicsConspiring(Scene):\n",
        "    def construct(self):\n",
        "        v_line = Line(DOWN, UP).scale(FRAME_HEIGHT)\n",
        "        v_line.save_state()\n",
        "        v_line.fade(1)\n",
        "        v_line.scale(0)\n",
        "        math_title = OldTexText(\"Math\")\n",
        "        math_title.set_color(BLUE)\n",
        "        physics_title = OldTexText(\"Physics\")\n",
        "        physics_title.set_color(YELLOW)\n",
        "        for title, vect in (math_title, LEFT), (physics_title, RIGHT):\n",
        "            title.scale(2)\n",
        "            title.shift(vect * FRAME_WIDTH / 4)\n",
        "            title.to_edge(UP)\n",
        "\n",
        "        math_stuffs = VGroup(\n",
        "            OldTex(\"\\\\pi = {:.16}\\\\dots\".format(PI)),\n",
        "            self.get_tangent_image(),\n",
        "        )\n",
        "        math_stuffs.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        math_stuffs.next_to(math_title, DOWN, LARGE_BUFF)\n",
        "        to_fade = VGroup(math_title, *math_stuffs, physics_title)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown, to_fade,\n",
        "                lag_ratio=0.7,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            Restore(v_line, run_time=2, path_arc=PI / 2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_tangent_image(self):\n",
        "        axes = Axes(\n",
        "            x_min=-1.5,\n",
        "            x_max=1.5,\n",
        "            y_min=-1.5,\n",
        "            y_max=1.5,\n",
        "        )\n",
        "        circle = Circle()\n",
        "        circle.set_color(WHITE)\n",
        "        theta = 30 * DEGREES\n",
        "        arc = Arc(angle=theta, radius=0.4)\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.scale(0.5)\n",
        "        theta_label.next_to(arc.get_center(), RIGHT, buff=SMALL_BUFF)\n",
        "        theta_label.shift(0.025 * UL)\n",
        "        line = Line(ORIGIN, rotate_vector(RIGHT, theta))\n",
        "        line.set_color(WHITE)\n",
        "        one = OldTex(\"1\").scale(0.5)\n",
        "        one.next_to(line.point_from_proportion(0.7), UL, 0.5 * SMALL_BUFF)\n",
        "        tan_line = Line(\n",
        "            line.get_end(),\n",
        "            (1.0 / np.cos(theta)) * RIGHT\n",
        "        )\n",
        "        tan_line.set_color(RED)\n",
        "        tan_text = OldTex(\"\\\\tan(\\\\theta)\")\n",
        "        tan_text.rotate(tan_line.get_angle())\n",
        "        tan_text.scale(0.5)\n",
        "        tan_text.move_to(tan_line)\n",
        "        tan_text.match_color(tan_line)\n",
        "        tan_text.shift(0.2 * normalize(line.get_vector()))\n",
        "\n",
        "        result = VGroup(\n",
        "            axes, circle,\n",
        "            line, one,\n",
        "            arc, theta_label,\n",
        "            tan_line, tan_text,\n",
        "        )\n",
        "        result.set_height(4)\n",
        "        return result\n",
        "\n",
        "\n",
        "class LightBouncing(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"theta\": np.arctan(0.15),\n",
        "        \"show_fanning\": False,\n",
        "        \"mirror_shift_vect\": 5 * LEFT,\n",
        "        \"mirror_length\": 10,\n",
        "        \"beam_start_x\": 12,\n",
        "        \"beam_height\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        theta = self.theta\n",
        "        h_line = Line(ORIGIN, self.mirror_length * RIGHT)\n",
        "        d_line = h_line.copy().rotate(theta, about_point=ORIGIN)\n",
        "        mirrors = VGroup(h_line, d_line)\n",
        "        self.add(mirrors)\n",
        "\n",
        "        beam_height = self.beam_height\n",
        "        start_point = self.beam_start_x * RIGHT + beam_height * UP\n",
        "        points = [start_point] + [\n",
        "            np.array([\n",
        "                (beam_height / np.tan(k * theta)),\n",
        "                beam_height,\n",
        "                0,\n",
        "            ])\n",
        "            for k in range(1, int(PI / theta))\n",
        "        ] + [rotate(start_point, PI, UP)]\n",
        "        reflected_points = []\n",
        "        for k, point in enumerate(points):\n",
        "            reflected_point = rotate_vector(point, -2 * (k // 2) * theta)\n",
        "            reflected_point[1] = abs(reflected_point[1])\n",
        "            reflected_points.append(reflected_point)\n",
        "        beam = VMobject()\n",
        "        beam.set_points_as_corners(reflected_points)\n",
        "        beam.set_stroke(YELLOW, 2)\n",
        "\n",
        "        anims = [self.get_beam_anim(beam)]\n",
        "\n",
        "        if self.show_fanning:\n",
        "            for k in range(2, int(PI / theta) + 1):\n",
        "                line = h_line.copy()\n",
        "                line.set_stroke(WHITE, 1)\n",
        "                line.rotate(k * theta, about_point=ORIGIN)\n",
        "                self.add(line)\n",
        "            straight_beam = VMobject()\n",
        "            straight_beam.set_points_as_corners(points)\n",
        "            straight_beam.set_stroke(YELLOW, 2)\n",
        "            anims.append(self.get_beam_anim(straight_beam))\n",
        "\n",
        "        self.camera_frame.shift(-self.mirror_shift_vect)\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def get_beam_anim(self, beam):\n",
        "        dot = Dot()\n",
        "        dot.scale(0.5)\n",
        "        dot.match_color(beam)\n",
        "        return AnimationGroup(\n",
        "            ShowPassingFlash(\n",
        "                beam,\n",
        "                run_time=5,\n",
        "                rate_func=lambda t: smooth(t, 5),\n",
        "                time_width=0.05,\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                dot,\n",
        "                lambda m: m.move_to(beam.get_points()[-1])\n",
        "            ),\n",
        "        )\n",
        "\n",
        "\n",
        "class BlocksAndWallExample(BlocksAndWallScene):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e0,\n",
        "                \"velocity\": -2,\n",
        "            }\n",
        "        },\n",
        "        \"wait_time\": 15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.wait(self.wait_time)\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e1(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e1,\n",
        "                \"velocity\": -1.5,\n",
        "            }\n",
        "        },\n",
        "        \"wait_time\": 20,\n",
        "    }\n",
        "\n",
        "\n",
        "class TwoBlocksLabel(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTexText(\"Two sliding \\\\\\\\ blocks\")\n",
        "        label.to_edge(UP)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(label.get_bottom(), point)\n",
        "            for point in [RIGHT, LEFT]\n",
        "        ])\n",
        "        arrows.set_color(RED)\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            LaggedStartMap(GrowArrow, arrows, lag_ratio=0.7),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WallLabel(Scene):\n",
        "    def construct(self):\n",
        "        wall = Line(TOP, 2 * DOWN)\n",
        "        wall.set_stroke(YELLOW, 10)\n",
        "        word = OldTexText(\"Wall\")\n",
        "        word.rotate(-90 * DEGREES)\n",
        "        word.next_to(wall, RIGHT, MED_SMALL_BUFF)\n",
        "        self.play(\n",
        "            Write(word),\n",
        "            ShowPassingFlash(wall)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CowToSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class NoFrictionLabel(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Frictionless\")\n",
        "        words.shift(2 * RIGHT)\n",
        "        words.add_updater(\n",
        "            lambda m, dt: m.shift(dt * LEFT)\n",
        "        )\n",
        "\n",
        "        self.play(VFadeIn(words))\n",
        "        self.wait(2)\n",
        "        self.play(VFadeOut(words))\n",
        "\n",
        "\n",
        "class Mass1e1WithElasticLabel(BlocksAndWallExampleMass1e1):\n",
        "    def add_flash_animations(self):\n",
        "        super().add_flash_animations()\n",
        "        flashes = self.clack_flashes\n",
        "        label = OldTexText(\n",
        "            \"Purely elastic collisions\\\\\\\\\"\n",
        "            \"(no energy lost)\"\n",
        "        )\n",
        "        label.set_color(YELLOW)\n",
        "        label.move_to(2 * LEFT + 2 * UP)\n",
        "        self.add(label)\n",
        "        self.add(*[\n",
        "            self.get_arrow(label, flashes, flash)\n",
        "            for flash in flashes.flashes\n",
        "        ])\n",
        "\n",
        "    def get_arrow(self, label, clack_flashes, flash):\n",
        "        arrow = Arrow(\n",
        "            label.get_bottom(),\n",
        "            flash.mobject.get_center() + 0.0 * UP,\n",
        "        )\n",
        "        arrow.set_fill(YELLOW)\n",
        "        arrow.set_stroke(BLACK, 1, background=True)\n",
        "        arrow.original_length = arrow.get_length()\n",
        "\n",
        "        def set_opacity(arrow):\n",
        "            time = self.get_time()\n",
        "            from_start = time - flash.start_time\n",
        "            if from_start < 0:\n",
        "                opacity = 0\n",
        "            else:\n",
        "                opacity = smooth(1 - 2 * from_start)\n",
        "            arrow.set_fill(opacity=opacity)\n",
        "            arrow.set_stroke(opacity=opacity, background=True)\n",
        "            # if opacity > 0:\n",
        "            #     arrow.scale(\n",
        "            #         opacity * arrow.original_length / arrow.get_length(),\n",
        "            #         about_point=arrow.get_end()\n",
        "            #     )\n",
        "\n",
        "        arrow.add_updater(set_opacity)\n",
        "        return arrow\n",
        "\n",
        "\n",
        "class AskAboutSoundlessness(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"No sound,\\\\\\\\right?\"\n",
        "        )\n",
        "        self.play(self.teacher.change, \"guilty\")\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"Focus on \\\\\\\\ collisions\",\n",
        "            target_mode=\"speaking\",\n",
        "            added_anims=[\n",
        "                self.change_students(\"pondering\", \"confused\", \"thinking\")\n",
        "            ]\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShowCreationRect(Scene):\n",
        "    def construct(self):\n",
        "        rect = SurroundingRectangle(OldTexText(\"\\\\# Collisions: 3\"))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleSameMass(BlocksAndWallExample):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowLeftArrow(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Vector(2 * LEFT, color=RED)\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrow))\n",
        "\n",
        "\n",
        "class AskWhatWillHappen(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.set_color(GREY_BROWN)\n",
        "\n",
        "        self.pi_creature_says(\n",
        "            \"What will\\\\\\\\\"\n",
        "            \"happen?\",\n",
        "            target_mode=\"maybe\",\n",
        "            look_at=4 * DR,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e2(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e2,\n",
        "                \"velocity\": -0.6,\n",
        "            }\n",
        "        },\n",
        "        \"wait_time\": 35,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMassSameSpeedAtEnd(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1 / np.tan(PI / 5)**2,\n",
        "                \"velocity\": -1,\n",
        "                \"label_text\": \"$\\\\frac{1}{\\\\tan(\\\\pi / 5)^2}$ kg\"\n",
        "            }\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e4(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e4,\n",
        "                \"velocity\": -1.5,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e4SlowMo(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e4,\n",
        "                \"velocity\": -0.1,\n",
        "                \"distance\": 4.1\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 50,\n",
        "        \"collision_sound\": \"slow_clack.wav\",\n",
        "    }\n",
        "\n",
        "\n",
        "class SlowMotionLabel(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Slow motion replay\")\n",
        "        words.scale(2).to_edge(UP)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e6(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e6,\n",
        "                \"velocity\": -1,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 20,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e6SlowMo(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e6,\n",
        "                \"velocity\": -0.1,\n",
        "                \"distance\": 4.1\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 60,\n",
        "        \"collision_sound\": \"slow_clack.wav\",\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e8(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e8,\n",
        "                \"velocity\": -1,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e10(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e10,\n",
        "                \"velocity\": -1,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class DigitsOfPi(Scene):\n",
        "    CONFIG = {\"n_digits\": 9}\n",
        "\n",
        "    def construct(self):\n",
        "        nd = self.n_digits\n",
        "        pow10 = int(10**nd)\n",
        "        rounded_pi = int(pow10 * PI) / pow10\n",
        "        equation = OldTex(\n",
        "            (\"\\\\pi = {:.\" + str(nd) + \"f}...\").format(rounded_pi)\n",
        "        )\n",
        "        equation.set_color(YELLOW)\n",
        "        pi_creature = Randolph(color=YELLOW)\n",
        "        pi_creature.match_width(equation[0])\n",
        "        pi_creature.scale(1.4)\n",
        "        pi_creature.move_to(equation[0], DOWN)\n",
        "        self.add(pi_creature, equation[1])\n",
        "        self.play(ShowIncreasingSubsets(\n",
        "            equation[2:],\n",
        "            rate_func=linear,\n",
        "            run_time=1,\n",
        "        ))\n",
        "        self.play(Blink(pi_creature))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GalperinPaperScroll(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class PiComputingAlgorithmsAxes(Scene):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_methods()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            y_min=0,\n",
        "            x_max=9,\n",
        "            y_max=5,\n",
        "            axis_config={\n",
        "                \"tick_frequency\": 100,\n",
        "                \"big_tick_numbers\": [],\n",
        "            }\n",
        "        )\n",
        "\n",
        "        y_label = OldTexText(\"Efficiency\")\n",
        "        y_label.rotate(90 * DEGREES)\n",
        "        y_label.next_to(axes.y_axis, LEFT, SMALL_BUFF)\n",
        "        x_label = OldTexText(\"Elegance\")\n",
        "        x_label.next_to(axes.x_axis, DOWN, SMALL_BUFF)\n",
        "        axes.add(y_label, x_label)\n",
        "        axes.center().to_edge(DOWN)\n",
        "        self.axes = axes\n",
        "\n",
        "        title = OldTexText(\"Algorithms for computing $\\\\pi$\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(title, axes)\n",
        "\n",
        "    def add_methods(self):\n",
        "        method_location_list = [\n",
        "            (self.get_machin_like_formula(), (1, 4.5)),\n",
        "            (self.get_viete(), (3, 3.5)),\n",
        "            (self.get_measuring_tape(), (0.5, 1)),\n",
        "            (self.get_monte_carlo(), (2, 0.2)),\n",
        "            (self.get_basel(), (6, 1)),\n",
        "            (self.get_blocks_image(), (8, 0.1)),\n",
        "        ]\n",
        "\n",
        "        algorithms = VGroup()\n",
        "        for method, location in method_location_list:\n",
        "            cross = OldTex(\"\\\\times\")\n",
        "            cross.set_color(RED)\n",
        "            cross.move_to(self.axes.coords_to_point(*location))\n",
        "            method.next_to(cross, UP, SMALL_BUFF)\n",
        "            method.align_to(cross, LEFT)\n",
        "            method.shift_onto_screen()\n",
        "            algorithms.add(VGroup(method, cross))\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, algorithms,\n",
        "            run_time=4,\n",
        "            lag_ratio=0.4,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(algorithms[-1][0]))\n",
        "\n",
        "    def get_machin_like_formula(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{\\\\pi}{4} = \"\n",
        "            \"12\\\\arctan\\\\left(\\\\frac{1}{49}\\\\right) + \"\n",
        "            \"32\\\\arctan\\\\left(\\\\frac{1}{57}\\\\right) - \"\n",
        "            \"5\\\\arctan\\\\left(\\\\frac{1}{239}\\\\right) + \"\n",
        "            \"12\\\\arctan\\\\left(\\\\frac{1}{110{,}443}\\\\right)\"\n",
        "        )\n",
        "        formula.scale(0.5)\n",
        "        return formula\n",
        "\n",
        "    def get_viete(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{2}{\\\\pi} = \"\n",
        "            \"\\\\frac{\\\\sqrt{2}}{2} \\\\cdot\"\n",
        "            \"\\\\frac{\\\\sqrt{2 + \\\\sqrt{2}}}{2} \\\\cdot\"\n",
        "            \"\\\\frac{\\\\sqrt{2 + \\\\sqrt{2 + \\\\sqrt{2}}}}{2} \\\\cdots\"\n",
        "        )\n",
        "        formula.scale(0.5)\n",
        "        return formula\n",
        "\n",
        "    def get_measuring_tape(self):\n",
        "        return OldTexText(\"Measuring tape\").scale(0.75)\n",
        "\n",
        "    def get_monte_carlo(self):\n",
        "        return OldTexText(\"Monte Carlo\").scale(0.75)\n",
        "\n",
        "    def get_basel(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{\\\\pi^2}{6} = \"\n",
        "            \"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^2}\"\n",
        "        )\n",
        "        formula.scale(0.5)\n",
        "        return formula\n",
        "\n",
        "    def get_blocks_image(self):\n",
        "        scene = BlocksAndWallScene(\n",
        "            write_to_movie=False,\n",
        "            skip_animations=True,\n",
        "            count_clacks=False,\n",
        "            floor_y=1,\n",
        "            wall_x=0,\n",
        "            n_wall_ticks=6,\n",
        "            sliding_blocks_config={\n",
        "                \"block1_config\": {\n",
        "                    \"mass\": 1e2,\n",
        "                    \"velocity\": -0.01,\n",
        "                    \"distance\": 3.5\n",
        "                },\n",
        "                \"block2_config\": {\n",
        "                    \"distance\": 1,\n",
        "                    \"velocity\": 0,\n",
        "                },\n",
        "            }\n",
        "        )\n",
        "        group = VGroup(\n",
        "            scene.wall, scene.floor,\n",
        "            scene.blocks.block1,\n",
        "            scene.blocks.block2,\n",
        "        )\n",
        "        group.set_width(3)\n",
        "        return group\n",
        "\n",
        "\n",
        "class StepsOfTheAlgorithm(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        steps = self.get_steps()\n",
        "        steps.arrange(\n",
        "            DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        steps.to_corner(UL)\n",
        "        steps.scale(0.8)\n",
        "\n",
        "        for step in steps:\n",
        "            self.play(\n",
        "                FadeInFromDown(step[0]),\n",
        "                self.teacher.change, \"raise_right_hand\"\n",
        "            )\n",
        "            self.play(\n",
        "                Write(step[1], run_time=2),\n",
        "                self.change_students(\n",
        "                    *[\"pondering\"] * 3,\n",
        "                    look_at=step,\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play_student_changes(\n",
        "            \"sassy\", \"erm\", \"confused\",\n",
        "            look_at=steps,\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_steps(self):\n",
        "        return VGroup(\n",
        "            OldTexText(\"Step 1:\", \"Implement a physics engine\"),\n",
        "            OldTexText(\n",
        "                \"Step 2:\",\n",
        "                \"Choose the number of digits, $d$,\\\\\\\\\"\n",
        "                \"of $\\\\pi$ that you want to compute\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"Step 3:\",\n",
        "                \"Set one mass to $100^{d - 1}$,\\\\\\\\\"\n",
        "                \"the other to $1$\"\n",
        "            ),\n",
        "            OldTexText(\"Step 4:\", \"Count collisions\"),\n",
        "        )\n",
        "\n",
        "\n",
        "class StepsOfTheAlgorithmJustTitles(StepsOfTheAlgorithm):\n",
        "    def construct(self):\n",
        "        self.remove(*self.pi_creatures)\n",
        "        titles = self.get_steps()\n",
        "        for title in titles:\n",
        "            title.scale(1.5)\n",
        "            title.to_edge(UP)\n",
        "\n",
        "        last_title = VectorizedPoint()\n",
        "        for title in titles:\n",
        "            self.play(\n",
        "                FadeInFromDown(title),\n",
        "                FadeOut(last_title, UP),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_title = title\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleToShowWithSteps(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e22,\n",
        "                \"velocity\": -1,\n",
        "                \"label_text\": \"$100^{(12 - 1)}$\\\\,kg\",\n",
        "                \"width\": 2,\n",
        "            },\n",
        "            \"collect_clack_data\": False,\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "        \"counter_group_shift_vect\": 5 * LEFT,\n",
        "        \"count_clacks\": True,\n",
        "        \"include_sound\": False,\n",
        "        \"show_flash_animations\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class CompareToGalacticMass(Scene):\n",
        "    def construct(self):\n",
        "        self.add_digits_of_pi()\n",
        "        self.show_mass()\n",
        "        self.show_galactic_black_holes()\n",
        "        self.show_total_count()\n",
        "\n",
        "    def add_digits_of_pi(self):\n",
        "        # 20 digits of pi\n",
        "        digits = OldTex(\"3.1415926535897932384...\")\n",
        "        digits.set_width(FRAME_WIDTH - 3)\n",
        "        digits.to_edge(UP)\n",
        "\n",
        "        highlighted_digits = VGroup(*[\n",
        "            d.copy().set_background_stroke(color=BLUE, width=5)\n",
        "            for d in [digits[0], *digits[2:-3]]\n",
        "        ])\n",
        "        counter = Integer(0)\n",
        "        counter.scale(1.5)\n",
        "        counter.set_color(BLUE)\n",
        "        brace = VMobject()\n",
        "        self.add(counter, brace)\n",
        "\n",
        "        for k in range(len(highlighted_digits)):\n",
        "            if k == 0:\n",
        "                self.add(digits[0])\n",
        "            else:\n",
        "                self.remove(highlighted_digits[k - 1])\n",
        "            self.add(digits[k + 1])\n",
        "            self.add(highlighted_digits[k])\n",
        "            counter.increment_value()\n",
        "            brace.become(Brace(highlighted_digits[:k + 1], DOWN))\n",
        "            counter.next_to(brace, DOWN)\n",
        "            self.wait(0.1)\n",
        "        self.add(digits)\n",
        "        self.remove(*highlighted_digits)\n",
        "\n",
        "        digits_word = OldTexText(\"digits\")\n",
        "        digits_word.scale(1.5)\n",
        "        digits_word.match_color(counter)\n",
        "        counter.generate_target()\n",
        "        group = VGroup(counter.target, digits_word)\n",
        "        group.arrange(\n",
        "            RIGHT,\n",
        "            index_of_submobject_to_align=0,\n",
        "            aligned_edge=DOWN,\n",
        "            buff=0.7,\n",
        "        )\n",
        "        group.next_to(brace, DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(counter),\n",
        "            FadeIn(digits_word, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.pi_digits_group = VGroup(\n",
        "            digits, brace, counter, digits_word\n",
        "        )\n",
        "\n",
        "    def show_mass(self):\n",
        "        bw_scene = BlocksAndWallExample(\n",
        "            write_to_movie=False,\n",
        "            skip_animations=True,\n",
        "            count_clacks=False,\n",
        "            show_flash_animations=False,\n",
        "            floor_y=0,\n",
        "            wall_x=-2,\n",
        "            n_wall_ticks=8,\n",
        "            sliding_blocks_config={\n",
        "                \"block1_config\": {\n",
        "                    \"mass\": 1e6,\n",
        "                    \"velocity\": -0.01,\n",
        "                    \"distance\": 4.5,\n",
        "                    \"label_text\": \"$100^{(20 - 1)}$ kg\",\n",
        "                    \"fill_color\": BLACK,\n",
        "                },\n",
        "                \"block2_config\": {\n",
        "                    \"distance\": 1,\n",
        "                    \"velocity\": 0,\n",
        "                },\n",
        "            }\n",
        "        )\n",
        "        block1 = bw_scene.blocks.block1\n",
        "        block2 = bw_scene.blocks.block2\n",
        "        group = VGroup(\n",
        "            bw_scene.wall, bw_scene.floor,\n",
        "            block1, block2\n",
        "        )\n",
        "        group.center()\n",
        "        group.to_edge(DOWN)\n",
        "\n",
        "        arrow = Vector(2 * LEFT, color=RED)\n",
        "        arrow.shift(block1.get_center())\n",
        "        group.add(arrow)\n",
        "\n",
        "        brace = Brace(block1.label[:-2], UP, buff=SMALL_BUFF)\n",
        "        number_words = OldTexText(\n",
        "            \"100\", *[\"billion\"] * 4,\n",
        "        )\n",
        "        number_words.next_to(brace, UP, buff=SMALL_BUFF)\n",
        "        VGroup(brace, number_words).set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(group))\n",
        "        self.wait()\n",
        "        last_word = number_words[0].copy()\n",
        "        last_word.next_to(brace, UP, SMALL_BUFF)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeInFromDown(last_word),\n",
        "        )\n",
        "        for k in range(1, len(number_words) + 1):\n",
        "            self.remove(last_word)\n",
        "            last_word = number_words[:k].copy()\n",
        "            last_word.next_to(brace, UP, SMALL_BUFF)\n",
        "            self.add(last_word)\n",
        "            self.wait(0.4)\n",
        "        self.wait()\n",
        "        self.remove(last_word)\n",
        "        self.add(number_words)\n",
        "        group.add(brace, number_words)\n",
        "        self.play(group.to_corner, DL)\n",
        "\n",
        "        self.block1 = block1\n",
        "        self.block2 = block2\n",
        "        self.block_setup_group = group\n",
        "\n",
        "    def show_galactic_black_holes(self):\n",
        "        black_hole = SVGMobject(file_name=\"black_hole\")\n",
        "        black_hole.set_color(BLACK)\n",
        "        black_hole.set_sheen(0.2, UL)\n",
        "        black_hole.set_height(1)\n",
        "        black_holes = VGroup(*[\n",
        "            black_hole.copy() for k in range(10)\n",
        "        ])\n",
        "        black_holes.arrange_in_grid(5, 2)\n",
        "        black_holes.to_corner(DR)\n",
        "        random.shuffle(black_holes.submobjects)\n",
        "        for bh in black_holes:\n",
        "            bh.save_state()\n",
        "            bh.scale(3)\n",
        "            bh.set_fill(GREY_D, 0)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.scale(2)\n",
        "        equals.next_to(self.block1, RIGHT)\n",
        "\n",
        "        words = OldTexText(\"10x Sgr A$^*$ \\\\\\\\ supermassive \\\\\\\\ black hole\")\n",
        "        words.next_to(equals, RIGHT)\n",
        "        self.add(words)\n",
        "\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(words),\n",
        "            LaggedStartMap(\n",
        "                Restore, black_holes,\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.black_hole_words = VGroup(equals, words)\n",
        "        self.black_holes = black_holes\n",
        "\n",
        "    def show_total_count(self):\n",
        "        digits = self.pi_digits_group[0]\n",
        "        to_fade = self.pi_digits_group[1:]\n",
        "        tex_string = \"{:,}\".format(31415926535897932384)\n",
        "        number = OldTex(tex_string)\n",
        "        number.scale(1.5)\n",
        "        number.to_edge(UP)\n",
        "\n",
        "        commas = VGroup(*[\n",
        "            mob\n",
        "            for c, mob in zip(tex_string, number)\n",
        "            if c is \",\"\n",
        "        ])\n",
        "        dots = VGroup(*[\n",
        "            mob\n",
        "            for c, mob in zip(digits.get_tex(), digits)\n",
        "            if c is \".\"\n",
        "        ])\n",
        "\n",
        "        self.play(FadeOut(to_fade))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*filter(lambda m: m not in dots, digits)),\n",
        "                VGroup(*filter(lambda m: m not in commas, number)),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                dots, commas,\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "\n",
        "        group0 = number[:2].copy()\n",
        "        group1 = number[3:3 + 9 + 2].copy()\n",
        "        group2 = number[-(9 + 2):].copy()\n",
        "        for group in group0, group1, group2:\n",
        "            group.set_background_stroke(color=BLUE, width=5)\n",
        "            self.add(group)\n",
        "            self.wait(0.5)\n",
        "            self.remove(group)\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleGalacticMass(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e10,\n",
        "                \"velocity\": -1,\n",
        "                \"label_text\": \"$100^{(20 - 1)}$\\\\,kg\",\n",
        "                \"width\": 2,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "        \"counter_group_shift_vect\": 5 * LEFT,\n",
        "        \"count_clacks\": False,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        words = OldTexText(\n",
        "            \"Burst of $10^{38}$ clacks per second\"\n",
        "        )\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class RealPhysicsVsThis(Scene):\n",
        "    def construct(self):\n",
        "        physics = OldTexText(\"Real physics\")\n",
        "        this = OldTexText(\"This process\")\n",
        "        this.set_color()\n",
        "        physics.to_edge(LEFT)\n",
        "        this.next_to(physics)\n",
        "        self.add(physics, this)\n",
        "        self.play(\n",
        "            this.shift, FRAME_WIDTH * RIGHT,\n",
        "            rate_func=rush_into,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CompareAlgorithmToPhysics(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        right_pic = ImageMobject(\n",
        "            self.get_image_file_path().replace(\n",
        "                str(self), \"PiComputingAlgorithmsAxes\"\n",
        "            )\n",
        "        )\n",
        "        right_rect = SurroundingRectangle(right_pic, buff=0, color=WHITE)\n",
        "        right_pic.add(right_rect)\n",
        "        right_pic.set_height(3)\n",
        "        right_pic.next_to(morty, UR)\n",
        "        right_pic.shift_onto_screen()\n",
        "\n",
        "        left_rect = right_rect.copy()\n",
        "        left_rect.next_to(morty, UL)\n",
        "        left_rect.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(right_pic),\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(left_rect),\n",
        "            morty.change, \"raise_left_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        digits = OldTex(\"3.141592653589793238462643383279502884197...\")\n",
        "        digits.set_width(FRAME_WIDTH - 1)\n",
        "        digits.to_edge(UP)\n",
        "        self.play(\n",
        "            FadeOut(right_pic, 5 * RIGHT),\n",
        "            # FadeOut(left_rect, 5 * LEFT),\n",
        "            FadeOut(left_rect),\n",
        "            PiCreatureBubbleIntroduction(\n",
        "                morty, \"This doesn't seem \\\\\\\\ like me...\",\n",
        "                bubble_type=ThoughtBubble,\n",
        "                bubble_config={\"direction\": LEFT},\n",
        "                target_mode=\"pondering\",\n",
        "                look_at=left_rect,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, digits,\n",
        "                lambda m: (m, LEFT),\n",
        "                run_time=5,\n",
        "                lag_ratio=0.2,\n",
        "            )\n",
        "        )\n",
        "        self.blink()\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"confused\", left_rect)\n",
        "        self.wait(5)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Mortimer().flip().to_edge(DOWN)\n",
        "\n",
        "\n",
        "class AskAboutWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius=2, color=YELLOW)\n",
        "        circle.next_to(self.teacher, UL)\n",
        "        ke_conservation = OldTex(\n",
        "            \"\\\\frac{1}{2}m_1 v_1^2 + \"\n",
        "            \"\\\\frac{1}{2}m_2 v_2^2 = \\\\text{const.}\"\n",
        "        )\n",
        "        ke_conservation.move_to(circle)\n",
        "\n",
        "        self.student_says(\"But why?\")\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"raise_left_hand\", \"sassy\",\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\", look_at=circle\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(ke_conservation),\n",
        "            circle.stretch, 1.5, 0,\n",
        "        )\n",
        "        self.play_all_student_changes(\"confused\")\n",
        "        self.look_at(circle)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class LightBouncingNoFanning(LightBouncing):\n",
        "    CONFIG = {\n",
        "        \"mirror_shift_vect\": 2 * DOWN,\n",
        "        \"mirror_length\": 6,\n",
        "        \"beam_start_x\": 8,\n",
        "        \"beam_height\": 0.5,\n",
        "    }\n",
        "\n",
        "\n",
        "class LightBouncingFanning(LightBouncingNoFanning):\n",
        "    CONFIG = {\n",
        "        \"show_fanning\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class NextVideo(Scene):\n",
        "    def construct(self):\n",
        "        videos = VGroup(*[VideoIcon() for x in range(2)])\n",
        "        videos.set_height(2)\n",
        "        for video in videos:\n",
        "            video.set_color(BLUE)\n",
        "            video.set_sheen(0.5, UL)\n",
        "        videos.arrange(RIGHT, buff=2)\n",
        "\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Here and now\"),\n",
        "            OldTexText(\"Solution\"),\n",
        "        )\n",
        "        for title, video in zip(titles, videos):\n",
        "            # title.scale(1.5)\n",
        "            title.next_to(video, UP)\n",
        "            video.add(title)\n",
        "\n",
        "        dots = OldTexText(\".....\")\n",
        "        dots.scale(2)\n",
        "        dots.move_to(videos)\n",
        "\n",
        "        mid_words = OldTexText(\n",
        "            \"Patient\\\\\\\\\", \"problem\\\\\\\\\", \"solving\"\n",
        "        )\n",
        "        mid_words.next_to(dots, DOWN)\n",
        "        randy = Randolph(height=1)\n",
        "        randy.next_to(dots, UP, SMALL_BUFF)\n",
        "        thought_bubble = ThoughtBubble(height=2, width=2, direction=LEFT)\n",
        "        thought_bubble.set_stroke(width=2)\n",
        "        thought_bubble.move_to(randy.get_corner(UR), DL)\n",
        "        speech_bubble = SpeechBubble(height=2, width=2)\n",
        "        speech_bubble.pin_to(randy)\n",
        "        speech_bubble.write(\"What do \\\\\\\\ you think?\")\n",
        "        friends = VGroup(\n",
        "            PiCreature(color=BLUE_E),\n",
        "            PiCreature(color=BLUE_C),\n",
        "            Mortimer()\n",
        "        )\n",
        "        friends.set_height(1)\n",
        "        friends.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        friends[:2].next_to(randy, LEFT)\n",
        "        friends[2].next_to(randy, RIGHT)\n",
        "\n",
        "        self.add(videos[0])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(*videos),\n",
        "        )\n",
        "        self.play(Write(dots))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, mid_words,\n",
        "                lambda m: (m, UP),\n",
        "                lag_ratio=0.8,\n",
        "            ),\n",
        "            randy.change, \"pondering\",\n",
        "            VFadeIn(randy),\n",
        "            videos.space_out_submobjects, 1.3,\n",
        "        )\n",
        "        self.play(ShowCreation(thought_bubble))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            Uncreate(thought_bubble),\n",
        "            ShowCreation(speech_bubble),\n",
        "            Write(speech_bubble.content),\n",
        "            randy.change, \"maybe\", friends[0].eyes,\n",
        "            LaggedStartMap(FadeInFromDown, friends),\n",
        "            videos.space_out_submobjects, 1.6,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, friends,\n",
        "                lambda m: (m.change, \"pondering\"),\n",
        "                run_time=1,\n",
        "                lag_ratio=0.7,\n",
        "            )\n",
        "        )\n",
        "        self.play(Blink(friends[2]))\n",
        "        self.play(friends[0].change, \"confused\")\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(Scene):\n",
        "    def construct(self):\n",
        "        width = (475 / 1280) * FRAME_WIDTH\n",
        "        height = width * (323 / 575)\n",
        "        video_rect = Rectangle(\n",
        "            width=width,\n",
        "            height=height,\n",
        "        )\n",
        "        video_rect.shift(UP)\n",
        "        video_rects = VGroup(*[\n",
        "            video_rect.copy().set_color(color)\n",
        "            for color in [BLUE_E, BLUE_C, BLUE_D, GREY_BROWN]\n",
        "        ])\n",
        "        for rect in video_rects[1::2]:\n",
        "            rect.reverse_points()\n",
        "        video_rect.set_fill(GREY_D, 0.5)\n",
        "        video_rect.set_stroke(GREY_BROWN, 0.5)\n",
        "        date = OldTexText(\n",
        "            \"Solution will be\\\\\\\\\"\n",
        "            \"posted\", \"1/20/19\",\n",
        "        )\n",
        "        date[1].set_color(YELLOW)\n",
        "        date.set_width(video_rect.get_width() - 2 * MED_SMALL_BUFF)\n",
        "        date.move_to(video_rect)\n",
        "\n",
        "        handle = OldTexText(\"@3blue1brown\")\n",
        "        handle.next_to(video_rect, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(video_rect, date, handle)\n",
        "        for n in range(10):\n",
        "            self.play(\n",
        "                FadeOut(video_rects[(n - 1) % 4]),\n",
        "                ShowCreation(video_rects[n % 4]),\n",
        "                run_time=2,\n",
        "            )\n",
        "\n",
        "\n",
        "class Thumbnail(BlocksAndWallExample, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e4,\n",
        "                \"velocity\": -1.5,\n",
        "            },\n",
        "            \"collect_clack_data\": False,\n",
        "        },\n",
        "        \"wait_time\": 0,\n",
        "        \"count_clacks\": False,\n",
        "        \"show_flash_animations\": False,\n",
        "        \"floor_y\": -3.0,\n",
        "        \"include_sound\": False,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        BlocksAndWallExample.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.camera_frame.shift(0.9 * UP)\n",
        "        # self.mobjects.insert(\n",
        "        #     0,\n",
        "        #     FullScreenFadeRectangle(\n",
        "        #         color=GREY_D,\n",
        "        #         opacity=0.5,\n",
        "        #         sheen_direction=UL,\n",
        "        #         sheen=0.5,\n",
        "        #     ),\n",
        "        # )\n",
        "        self.thicken_lines()\n",
        "        self.grow_labels()\n",
        "        self.add_vector()\n",
        "        self.add_text()\n",
        "\n",
        "    def thicken_lines(self):\n",
        "        self.floor.set_stroke(WHITE, 10)\n",
        "        self.wall.set_stroke(WHITE, 10)\n",
        "        self.wall[1:].set_stroke(WHITE, 4)\n",
        "\n",
        "    def grow_labels(self):\n",
        "        blocks = self.blocks\n",
        "        for block in blocks.block1, blocks.block2:\n",
        "            block.remove(block.label)\n",
        "            block.label.scale(2.5, about_point=block.get_top())\n",
        "            self.add(block.label)\n",
        "\n",
        "    def add_vector(self):\n",
        "        blocks = self.blocks\n",
        "        arrow = self.arrow = Vector(\n",
        "            2.5 * LEFT,\n",
        "            color=RED,\n",
        "            rectangular_stem_width=1.5,\n",
        "            tip_length=0.5\n",
        "        )\n",
        "        arrow.move_to(blocks.block1.get_center(), RIGHT)\n",
        "        arrow.add_to_back(\n",
        "            arrow.copy().set_stroke(GREY, 5)\n",
        "        )\n",
        "        self.add(arrow)\n",
        "\n",
        "    def add_text(self):\n",
        "        question = self.question = OldTexText(\n",
        "            \"How many\\\\\\\\collisions?\"\n",
        "        )\n",
        "        question.scale(2.5)\n",
        "        question.to_edge(UP)\n",
        "        question.set_color(YELLOW)\n",
        "        question.set_stroke(RED, 2, background=True)\n",
        "        self.add(question)\n"
    ]
}