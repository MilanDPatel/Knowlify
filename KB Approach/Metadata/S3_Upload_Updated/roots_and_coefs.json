{
    "topic": "The mathematical concept being demonstrated is the Optimal Transport (OT) algorithm for finding the shortest path",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "# Helpers\n",
        "\n",
        "\n",
        "def roots_to_coefficients(roots):\n",
        "    n = len(list(roots))\n",
        "    return [\n",
        "        ((-1)**(n - k)) * sum(\n",
        "            np.prod(tup)\n",
        "            for tup in it.combinations(roots, n - k)\n",
        "        )\n",
        "        for k in range(n)\n",
        "    ] + [1]\n",
        "\n",
        "\n",
        "def poly(x, coefs):\n",
        "    return sum(coefs[k] * x**k for k in range(len(coefs)))\n",
        "\n",
        "\n",
        "def dpoly(x, coefs):\n",
        "    return sum(k * coefs[k] * x**(k - 1) for k in range(1, len(coefs)))\n",
        "\n",
        "\n",
        "def find_root(func, dfunc, seed=complex(1, 1), tol=1e-8, max_steps=100):\n",
        "    # Use newton's method\n",
        "    last_seed = np.inf\n",
        "    for n in range(max_steps):\n",
        "        if abs(seed - last_seed) < tol:\n",
        "            break\n",
        "        last_seed = seed\n",
        "        seed = seed - func(seed) / dfunc(seed)\n",
        "    return seed\n",
        "\n",
        "\n",
        "def coefficients_to_roots(coefs):\n",
        "    if len(coefs) == 0:\n",
        "        return []\n",
        "    elif coefs[-1] == 0:\n",
        "        return coefficients_to_roots(coefs[:-1])\n",
        "    roots = []\n",
        "    # Find a root, divide out by (x - root), repeat\n",
        "    for i in range(len(coefs) - 1):\n",
        "        root = find_root(\n",
        "            lambda x: poly(x, coefs),\n",
        "            lambda x: dpoly(x, coefs),\n",
        "        )\n",
        "        roots.append(root)\n",
        "        new_reversed_coefs, rem = np.polydiv(coefs[::-1], [1, -root])\n",
        "        coefs = new_reversed_coefs[::-1]\n",
        "    return roots\n",
        "\n",
        "\n",
        "def get_nth_roots(z, n):\n",
        "    base_root = z**(1 / n)\n",
        "    return [\n",
        "        base_root * np.exp(complex(0, k * TAU / n))\n",
        "        for k in range(n)\n",
        "    ]\n",
        "\n",
        "\n",
        "def sort_to_minimize_distances(unordered_points, reference_points):\n",
        "    \"\"\"\n",
        "    Sort the initial list of points in R^n so that the sum\n",
        "    of the distances between corresponding points in both lists\n",
        "    is smallest\n",
        "    \"\"\"\n",
        "    ordered_points = []\n",
        "    unused_points = list(unordered_points)\n",
        "\n",
        "    for ref_point in reference_points:\n",
        "        distances = [get_norm(ref_point - up) for up in unused_points]\n",
        "        index = np.argmin(distances)\n",
        "        ordered_points.append(unused_points.pop(index))\n",
        "    return ordered_points\n",
        "\n",
        "\n",
        "def optimal_transport(dots, target_points):\n",
        "    \"\"\"\n",
        "    Move the dots to the target points such that each dot moves a minimal distance\n",
        "    \"\"\"\n",
        "    points = sort_to_minimize_distances(target_points, [d.get_center() for d in dots])\n",
        "    for dot, point in zip(dots, points):\n",
        "        dot.move_to(point)\n",
        "    return dots\n",
        "\n",
        "\n",
        "def x_power_tex(power, base=\"x\"):\n",
        "    if power == 0:\n",
        "        return \"\"\n",
        "    elif power == 1:\n",
        "        return base\n",
        "    else:\n",
        "        return f\"{base}^{{{power}}}\"\n",
        "\n",
        "\n",
        "def poly_tex(coefs, prefix=\"P(x) = \", coef_color=RED_B):\n",
        "    n = len(coefs) - 1\n",
        "    coefs = [f\"{{{coef}}}\" for coef in coefs]\n",
        "    terms = [prefix, x_power_tex(n)]\n",
        "    for k in range(n - 1, -1, -1):\n",
        "        coef = coefs[k]\n",
        "        if not coef[1] == \"-\":\n",
        "            terms.append(\"+\")\n",
        "        terms.append(str(coef))\n",
        "        terms.append(x_power_tex(k))\n",
        "    t2c = dict([(coef, coef_color) for coef in coefs])\n",
        "    return OldTex(*terms, tex_to_color_map=t2c)\n",
        "\n",
        "\n",
        "def factored_poly_tex(roots, prefix=\"P(x) = \", root_colors=[YELLOW, YELLOW]):\n",
        "    roots = list(roots)\n",
        "    root_colors = color_gradient(root_colors, len(roots))\n",
        "    root_texs = [str(r) for r in roots]\n",
        "    parts = []\n",
        "    if prefix:\n",
        "        parts.append(prefix)\n",
        "    for root_tex in root_texs:\n",
        "        parts.extend([\"(\", \"x\", \"-\", root_tex, \")\"])\n",
        "    t2c = dict((\n",
        "        (rt, root_color)\n",
        "        for rt, root_color in zip(root_texs, root_colors)\n",
        "    ))\n",
        "    return OldTex(*parts, tex_to_color_map=t2c)\n",
        "\n",
        "\n",
        "def sym_poly_tex_args(roots, k, abbreviate=False):\n",
        "    result = []\n",
        "    subsets = list(it.combinations(roots, k))\n",
        "    if k in [1, len(roots)]:\n",
        "        abbreviate = False\n",
        "    if abbreviate:\n",
        "        subsets = [*subsets[:2], subsets[-1]]\n",
        "    for subset in subsets:\n",
        "        if abbreviate and subset is subsets[-1]:\n",
        "            result.append(\" \\\\cdots \")\n",
        "            result.append(\"+\")\n",
        "        for r in subset:\n",
        "            result.append(str(r))\n",
        "            result.append(\" \\\\cdot \")\n",
        "        result.pop()\n",
        "        result.append(\"+\")\n",
        "    result.pop()\n",
        "    return result\n",
        "\n",
        "\n",
        "def expanded_poly_tex(roots, vertical=True, root_colors=[YELLOW, YELLOW], abbreviate=False):\n",
        "    roots = list(roots)\n",
        "    root_colors = color_gradient(root_colors, len(roots))\n",
        "    n = len(roots)\n",
        "    kw = dict(\n",
        "        tex_to_color_map=dict((\n",
        "            (str(r), root_color)\n",
        "            for r, root_color in zip(roots, root_colors)\n",
        "        )),\n",
        "        arg_separator=\" \"\n",
        "    )\n",
        "    result = VGroup()\n",
        "    result.add(OldTex(f\"x^{{{n}}}\"))\n",
        "    for k in range(1, n + 1):\n",
        "        sym_poly = sym_poly_tex_args(\n",
        "            roots, k,\n",
        "            abbreviate=abbreviate\n",
        "        )\n",
        "        line = OldTex(\n",
        "            \"+\" if k % 2 == 0 else \"-\",\n",
        "            \"\\\\big(\", *sym_poly, \"\\\\big)\",\n",
        "            x_power_tex(n - k),\n",
        "            **kw,\n",
        "        )\n",
        "        result.add(line)\n",
        "    for line in result:\n",
        "        line[-1].set_color(WHITE)\n",
        "    if vertical:\n",
        "        result.arrange(DOWN, aligned_edge=LEFT)\n",
        "    else:\n",
        "        result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        result[0].shift(result[0].get_height() * UP / 4)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_symmetric_system(lhss,\n",
        "                         roots=None,\n",
        "                         root_colors=[YELLOW, YELLOW],\n",
        "                         lhs_color=RED_B,\n",
        "                         abbreviate=False,\n",
        "                         signed=False,\n",
        "                         ):\n",
        "    lhss = [f\"{{{lhs}}}\" for lhs in lhss]\n",
        "    if roots is None:\n",
        "        roots = [f\"r_{{{i}}}\" for i in range(len(lhss))]\n",
        "    root_colors = color_gradient(root_colors, len(roots))\n",
        "    t2c = dict([\n",
        "        (root, root_color)\n",
        "        for root, root_color in zip(roots, root_colors)\n",
        "    ])\n",
        "    t2c.update(dict([\n",
        "        (str(lhs), lhs_color)\n",
        "        for lhs in lhss\n",
        "    ]))\n",
        "    kw = dict(tex_to_color_map=t2c)\n",
        "    equations = VGroup(*(\n",
        "        OldTex(\n",
        "            lhs, \"=\",\n",
        "            \"-(\" if neg else \"\",\n",
        "            *sym_poly_tex_args(roots, k, abbreviate=abbreviate),\n",
        "            \")\" if neg else \"\",\n",
        "            **kw\n",
        "        )\n",
        "        for k, lhs in zip(it.count(1), lhss)\n",
        "        for neg in [signed and k % 2 == 1]\n",
        "    ))\n",
        "    equations.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "    for eq in equations:\n",
        "        eq.shift((equations[0][1].get_x() - eq[1].get_x()) * RIGHT)\n",
        "    return equations\n",
        "\n",
        "\n",
        "def get_quadratic_formula(lhs=\"\", **tex_config):\n",
        "    return Tex(\n",
        "        lhs + \"{-{b} \\\\pm \\\\sqrt{ {b}^2 - 4{a}{c} } \\\\over 2{a} }\",\n",
        "        **tex_config\n",
        "    )\n",
        "\n",
        "\n",
        "def get_full_cubic_formula(lhs=\"\", **tex_config):\n",
        "    # Thanks to Mathologer and MathPix here...\n",
        "    return OldTex(lhs + \"\"\"\n",
        "        &\\\\sqrt[3]{\\\\left(-{ {b}^{3} \\\\over 27 {a}^{3}}+{ {b} {c} \\\\over 6 {a}^{2}}\n",
        "            -{ {d} \\\\over 2 {a} }\\\\right)-\\\\sqrt{\\\\left(-{ {b}^{3} \\\\over 27 {a}^{3}}\n",
        "            +{ {b} {c} \\\\over 6 {a}^{2}}-{ {d} \\\\over 2 {a}}\\\\right)^{2}\n",
        "            +\\\\left({ {c} \\\\over 3 {a} }-{ {b}^{2} \\\\over 9 {a}^{2}}\\\\right)^{3}}} \\\\\\\\\n",
        "        +&\\\\sqrt[3]{\\\\left(-{ {b}^{3} \\\\over 27 {a}^{3}}+{ {b} {c} \\\\over 6 {a}^{2}}\n",
        "            -{ {d} \\\\over 2 {a} }\\\\right)+\\\\sqrt{\\\\left(-{ {b}^{3} \\\\over 27 {a}^{3}}\n",
        "            +{ {b} {c} \\\\over 6 {a}^{2}}-{ {d} \\\\over 2 {a}}\\\\right)^{2}\n",
        "            +\\\\left({ {c} \\\\over 3 {a} }-{ {b}^{2} \\\\over 9 {a}^{2} }\\\\right)^{3}}} \\\\\\\\\n",
        "        -&{ {b} \\\\over 3 {a} }\n",
        "    \"\"\", **tex_config)\n",
        "\n",
        "\n",
        "def get_cubic_formula(lhs=\"\", **tex_config):\n",
        "    return Tex(\n",
        "        lhs + \"\"\"\n",
        "         \\\\sqrt[3]{-{q \\\\over 2}-\\\\sqrt{\\\\left({q \\\\over 2}\\\\right)^{2}+\\\\left({p \\\\over 3}\\\\right)^{3}}}\n",
        "        +\\\\sqrt[3]{-{q \\\\over 2}+\\\\sqrt{\\\\left({q \\\\over 2}\\\\right)^{2}+\\\\left({p \\\\over 3}\\\\right)^{3}}}\n",
        "        \"\"\",\n",
        "        **tex_config\n",
        "    )\n",
        "\n",
        "\n",
        "def get_quartic_formula(lhs=\"\", **tex_config):\n",
        "    pass\n",
        "\n",
        "\n",
        "# General scene types\n",
        "\n",
        "\n",
        "class RootCoefScene(Scene):\n",
        "    coefs = [3, 2, 1, 0, -1, 1]\n",
        "    root_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "        }\n",
        "    }\n",
        "    coef_plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-4, 4),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY,\n",
        "        }\n",
        "    }\n",
        "    plane_height = 5.5\n",
        "    plane_buff = 1.5\n",
        "    planes_center = ORIGIN\n",
        "    plane_arrangement = LEFT\n",
        "    cycle_run_time = 5\n",
        "\n",
        "    root_color = YELLOW\n",
        "    coef_color = RED_B\n",
        "\n",
        "    dot_style = {\n",
        "        \"radius\": 0.05,\n",
        "        \"stroke_color\": BLACK,\n",
        "        \"stroke_width\": 3,\n",
        "        \"stroke_behind\": True,\n",
        "    }\n",
        "    include_tracers = True\n",
        "    include_labels = True\n",
        "    label_font_size = 30\n",
        "    coord_label_font_size = 18\n",
        "    continuous_roots = True\n",
        "    show_equals = True\n",
        "\n",
        "    def setup(self):\n",
        "        self.lock_coef_imag = False\n",
        "        self.lock_coef_norm = False\n",
        "        self.add_planes()\n",
        "        self.add_dots()\n",
        "        self.active_dot_aura = Group()\n",
        "        self.add(self.active_dot_aura)\n",
        "        self.prepare_cycle_interaction()\n",
        "        if self.include_tracers:\n",
        "            self.add_all_tracers()\n",
        "        if self.include_labels:\n",
        "            self.add_r_labels()\n",
        "            self.add_c_labels()\n",
        "\n",
        "    def add_planes(self):\n",
        "        # Planes\n",
        "        planes = VGroup(\n",
        "            ComplexPlane(**self.root_plane_config),\n",
        "            ComplexPlane(**self.coef_plane_config),\n",
        "        )\n",
        "        for plane in planes:\n",
        "            plane.set_height(self.plane_height)\n",
        "        planes.arrange(self.plane_arrangement, buff=self.plane_buff)\n",
        "        planes.move_to(self.planes_center)\n",
        "\n",
        "        for plane in planes:\n",
        "            plane.add_coordinate_labels(font_size=self.coord_label_font_size)\n",
        "            plane.coordinate_labels.set_opacity(0.8)\n",
        "\n",
        "        root_plane, coef_plane = planes\n",
        "\n",
        "        # Lower labels\n",
        "        root_plane_label = Text(\"Roots\")\n",
        "        coef_plane_label = Text(\"Coefficients\")\n",
        "\n",
        "        root_plane_label.next_to(root_plane, DOWN)\n",
        "        coef_plane_label.next_to(coef_plane, DOWN)\n",
        "\n",
        "        # Upper labels\n",
        "        root_poly = self.get_root_poly()\n",
        "        self.get_r_symbols(root_poly).set_color(self.root_color)\n",
        "        root_poly.next_to(root_plane, UP)\n",
        "        root_poly.set_max_width(root_plane.get_width())\n",
        "\n",
        "        coef_poly = self.get_coef_poly()\n",
        "        self.get_c_symbols(coef_poly).set_color(self.coef_color)\n",
        "        coef_poly.set_max_width(coef_plane.get_width())\n",
        "        coef_poly.next_to(coef_plane, UP)\n",
        "        coef_poly.match_y(root_poly)\n",
        "\n",
        "        self.add(planes)\n",
        "        self.add(root_plane_label, coef_plane_label)\n",
        "        self.add(root_poly, coef_poly)\n",
        "\n",
        "        if self.show_equals:\n",
        "            equals = OldTex(\"=\")\n",
        "            equals.move_to(midpoint(root_poly.get_right(), coef_poly.get_left()))\n",
        "            self.add(equals)\n",
        "            self.poly_equal_sign = equals\n",
        "\n",
        "        self.root_plane = root_plane\n",
        "        self.coef_plane = coef_plane\n",
        "        self.root_plane_label = root_plane_label\n",
        "        self.coef_plane_label = coef_plane_label\n",
        "        self.root_poly = root_poly\n",
        "        self.coef_poly = coef_poly\n",
        "\n",
        "    def get_degree(self):\n",
        "        return len(self.coefs) - 1\n",
        "\n",
        "    def get_coef_poly(self):\n",
        "        degree = self.get_degree()\n",
        "        return OldTex(\n",
        "            f\"x^{degree}\",\n",
        "            *(\n",
        "                f\" + c_{n} x^{n}\"\n",
        "                for n in range(degree - 1, 1, -1)\n",
        "            ),\n",
        "            \" + c_{1} x\",\n",
        "            \" + c_{0}\",\n",
        "        )\n",
        "\n",
        "    def get_root_poly(self):\n",
        "        return OldTex(*(\n",
        "            f\"(x - r_{i})\"\n",
        "            for i in range(self.get_degree())\n",
        "        ))\n",
        "\n",
        "    def add_dots(self):\n",
        "        self.root_dots = VGroup()\n",
        "        self.coef_dots = VGroup()\n",
        "        roots = coefficients_to_roots(self.coefs)\n",
        "        self.add_root_dots(roots)\n",
        "        self.add_coef_dots(self.coefs)\n",
        "\n",
        "    #\n",
        "    def get_all_dots(self):\n",
        "        return (*self.root_dots, *self.coef_dots)\n",
        "\n",
        "    def get_r_symbols(self, root_poly):\n",
        "        return VGroup(*(part[3:5] for part in root_poly))\n",
        "\n",
        "    def get_c_symbols(self, coef_poly):\n",
        "        return VGroup(*(part[1:3] for part in coef_poly[:0:-1]))\n",
        "\n",
        "    def get_random_root(self):\n",
        "        return complex(\n",
        "            interpolate(*self.root_plane.x_range[:2], random.random()),\n",
        "            interpolate(*self.root_plane.y_range[:2], random.random()),\n",
        "        )\n",
        "\n",
        "    def get_random_roots(self):\n",
        "        return [self.get_random_root() for x in range(self.degree)]\n",
        "\n",
        "    def get_roots_of_unity(self):\n",
        "        return [np.exp(complex(0, TAU * n / self.degree)) for n in range(self.degree)]\n",
        "\n",
        "    def set_roots(self, roots):\n",
        "        self.root_dots.set_submobjects(\n",
        "            Dot(\n",
        "                self.root_plane.n2p(root),\n",
        "                color=self.root_color,\n",
        "                **self.dot_style,\n",
        "            )\n",
        "            for root in roots\n",
        "        )\n",
        "\n",
        "    def set_coefs(self, coefs):\n",
        "        self.coef_dots.set_submobjects(\n",
        "            Dot(\n",
        "                self.coef_plane.n2p(coef),\n",
        "                color=self.coef_color,\n",
        "                **self.dot_style,\n",
        "            )\n",
        "            for coef in coefs[:-1]  # Exclude highest term\n",
        "        )\n",
        "\n",
        "    def add_root_dots(self, roots=None):\n",
        "        if roots is None:\n",
        "            roots = self.get_roots_of_unity()\n",
        "        self.set_roots(roots)\n",
        "        self.add(self.root_dots)\n",
        "\n",
        "    def add_coef_dots(self, coefs=None):\n",
        "        if coefs is None:\n",
        "            coefs = [0] * self.degree + [1]\n",
        "        self.set_coefs(coefs)\n",
        "        self.add(self.coef_dots)\n",
        "\n",
        "    def get_roots(self):\n",
        "        return [\n",
        "            self.root_plane.p2n(root_dot.get_center())\n",
        "            for root_dot in self.root_dots\n",
        "        ]\n",
        "\n",
        "    def get_coefs(self):\n",
        "        return [\n",
        "            self.coef_plane.p2n(coef_dot.get_center())\n",
        "            for coef_dot in self.coef_dots\n",
        "        ] + [1.0]\n",
        "\n",
        "    def tie_coefs_to_roots(self, clear_updaters=True):\n",
        "        if clear_updaters:\n",
        "            self.root_dots.clear_updaters()\n",
        "            self.coef_dots.clear_updaters()\n",
        "        self.coef_dots.add_updater(self.update_coef_dots_by_roots)\n",
        "        self.add(self.coef_dots)\n",
        "        self.add(*self.root_dots)\n",
        "\n",
        "    def update_coef_dots_by_roots(self, coef_dots):\n",
        "        coefs = roots_to_coefficients(self.get_roots())\n",
        "        for dot, coef in zip(coef_dots, coefs):\n",
        "            dot.move_to(self.coef_plane.n2p(coef))\n",
        "        return coef_dots\n",
        "\n",
        "    def tie_roots_to_coefs(self, clear_updaters=True):\n",
        "        if clear_updaters:\n",
        "            self.root_dots.clear_updaters()\n",
        "            self.coef_dots.clear_updaters()\n",
        "        self.root_dots.add_updater(self.update_root_dots_by_coefs)\n",
        "        self.add(self.root_dots)\n",
        "        self.add(*self.coef_dots)\n",
        "\n",
        "    def update_root_dots_by_coefs(self, root_dots):\n",
        "        new_roots = coefficients_to_roots(self.get_coefs())\n",
        "        new_root_points = map(self.root_plane.n2p, new_roots)\n",
        "        if self.continuous_roots:\n",
        "            optimal_transport(root_dots, new_root_points)\n",
        "        else:\n",
        "            for dot, point in zip(root_dots, new_root_points):\n",
        "                dot.move_to(point)\n",
        "        return root_dots\n",
        "\n",
        "    def get_tracers(self, dots, time_traced=2.0, **kwargs):\n",
        "        tracers = VGroup()\n",
        "        for dot in dots:\n",
        "            dot.tracer = TracingTail(\n",
        "                dot,\n",
        "                stroke_color=dot.get_fill_color(),\n",
        "                time_traced=time_traced,\n",
        "                **kwargs\n",
        "            )\n",
        "            tracers.add(dot.tracer)\n",
        "        return tracers\n",
        "\n",
        "    def add_all_tracers(self, **kwargs):\n",
        "        self.tracers = self.get_tracers(self.get_all_dots())\n",
        "        self.add(self.tracers)\n",
        "\n",
        "    def get_tracking_lines(self, dots, syms, stroke_width=1, stroke_opacity=0.5):\n",
        "        lines = VGroup(*(\n",
        "            Line(\n",
        "                stroke_color=root.get_fill_color(),\n",
        "                stroke_width=stroke_width,\n",
        "                stroke_opacity=stroke_opacity,\n",
        "            )\n",
        "            for root in dots\n",
        "        ))\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for sym, dot, line in zip(syms, dots, lines):\n",
        "                line.put_start_and_end_on(\n",
        "                    sym.get_bottom(),\n",
        "                    dot.get_center()\n",
        "                )\n",
        "\n",
        "        lines.add_updater(update_lines)\n",
        "        return lines\n",
        "\n",
        "    def add_root_lines(self, **kwargs):\n",
        "        self.root_lines = self.get_tracking_lines(\n",
        "            self.root_dots,\n",
        "            self.get_r_symbols(self.root_poly),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.add(self.root_lines)\n",
        "\n",
        "    def add_coef_lines(self, **kwargs):\n",
        "        self.coef_lines = self.get_tracking_lines(\n",
        "            self.coef_dots,\n",
        "            self.get_c_symbols(self.coef_poly),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.add(self.coef_lines)\n",
        "\n",
        "    def add_dot_labels(self, labels, dots, buff=0.05):\n",
        "        for label, dot in zip(labels, dots):\n",
        "            label.scale(self.label_font_size / label.font_size)\n",
        "            label.set_fill(dot.get_fill_color())\n",
        "            label.set_stroke(BLACK, 3, background=True)\n",
        "            label.dot = dot\n",
        "            label.add_updater(lambda m: m.next_to(m.dot, UR, buff=buff))\n",
        "        self.add(*labels)\n",
        "        return labels\n",
        "\n",
        "    def add_r_labels(self):\n",
        "        self.r_dot_labels = self.add_dot_labels(\n",
        "            VGroup(*(\n",
        "                OldTex(f\"r_{i}\")\n",
        "                for i in range(self.get_degree())\n",
        "            )),\n",
        "            self.root_dots\n",
        "        )\n",
        "\n",
        "    def add_c_labels(self):\n",
        "        self.c_dot_labels = self.add_dot_labels(\n",
        "            VGroup(*(\n",
        "                OldTex(f\"c_{i}\")\n",
        "                for i in range(self.get_degree())\n",
        "            )),\n",
        "            self.coef_dots\n",
        "        )\n",
        "\n",
        "    def add_value_label(self):\n",
        "        pass  # TODO\n",
        "\n",
        "    # Animations\n",
        "    def play(self, *anims, **kwargs):\n",
        "        movers = list(it.chain(*(anim.mobject.get_family() for anim in anims)))\n",
        "        roots_move = any(rd in movers for rd in self.root_dots)\n",
        "        coefs_move = any(cd in movers for cd in self.coef_dots)\n",
        "        if roots_move and not coefs_move:\n",
        "            self.tie_coefs_to_roots()\n",
        "        elif coefs_move and not roots_move:\n",
        "            self.tie_roots_to_coefs()\n",
        "        super().play(*anims, **kwargs)\n",
        "\n",
        "    def get_root_swap_arrows(self, i, j,\n",
        "                             path_arc=90 * DEGREES,\n",
        "                             stroke_width=5,\n",
        "                             stroke_opacity=0.7,\n",
        "                             buff=0.3,\n",
        "                             **kwargs):\n",
        "        di = self.root_dots[i].get_center()\n",
        "        dj = self.root_dots[j].get_center()\n",
        "        kwargs[\"path_arc\"] = path_arc\n",
        "        kwargs[\"stroke_width\"] = stroke_width\n",
        "        kwargs[\"stroke_opacity\"] = stroke_opacity\n",
        "        kwargs[\"buff\"] = buff\n",
        "        return VGroup(\n",
        "            Arrow(di, dj, **kwargs),\n",
        "            Arrow(dj, di, **kwargs),\n",
        "        )\n",
        "\n",
        "    def swap_roots(self, *indices, run_time=2, wait_time=1, **kwargs):\n",
        "        self.play(CyclicReplace(\n",
        "            *(\n",
        "                self.root_dots[i]\n",
        "                for i in indices\n",
        "            ),\n",
        "            run_time=run_time,\n",
        "            **kwargs\n",
        "        ))\n",
        "        self.wait(wait_time)\n",
        "\n",
        "    def rotate_coefs(self, indicies, center_z=0, run_time=5, wait_time=1, **kwargs):\n",
        "        self.play(*(\n",
        "            Rotate(\n",
        "                self.coef_dots[i], TAU,\n",
        "                about_point=self.coef_plane.n2p(center_z),\n",
        "                run_time=run_time,\n",
        "                **kwargs\n",
        "            )\n",
        "            for i in indicies\n",
        "        ))\n",
        "        self.wait(wait_time)\n",
        "\n",
        "    def rotate_coef(self, i, **kwargs):\n",
        "        self.rotate_coefs([i], **kwargs)\n",
        "\n",
        "    # Interaction\n",
        "    def add_dot_auroa(self, dot):\n",
        "        glow_dot = GlowDot(color=WHITE)\n",
        "        always(glow_dot.move_to, dot)\n",
        "        self.active_dot_aura.add(glow_dot)\n",
        "\n",
        "    def remove_dot_aura(self):\n",
        "        if len(self.active_dot_aura) > 0:\n",
        "            self.play(FadeOut(self.active_dot_aura), run_time=0.5)\n",
        "            self.active_dot_aura.set_submobjects([])\n",
        "            self.add(self.active_dot_aura)\n",
        "\n",
        "    def prepare_cycle_interaction(self):\n",
        "        self.dots_awaiting_cycle = []\n",
        "        self.dot_awaiting_loop = None\n",
        "\n",
        "    def handle_cycle_preparation(self, dot):\n",
        "        if dot in self.root_dots and dot not in self.dots_awaiting_cycle:\n",
        "            self.dots_awaiting_cycle.append(dot)\n",
        "        if dot in self.coef_dots and dot is not self.dot_awaiting_loop:\n",
        "            self.dot_awaiting_loop = dot\n",
        "        self.add(dot)\n",
        "\n",
        "    def carry_out_cycle(self):\n",
        "        if self.dots_awaiting_cycle:\n",
        "            self.tie_coefs_to_roots()\n",
        "            self.play(CyclicReplace(*self.dots_awaiting_cycle, run_time=self.cycle_run_time))\n",
        "            self.remove_dot_aura()\n",
        "        if self.dot_awaiting_loop is not None:\n",
        "            self.tie_roots_to_coefs()\n",
        "            self.play(Rotate(\n",
        "                self.dot_awaiting_loop,\n",
        "                angle=TAU,\n",
        "                about_point=self.mouse_point.get_center().copy(),\n",
        "                run_time=8\n",
        "            ))\n",
        "            self.remove_dot_aura()\n",
        "        self.prepare_cycle_interaction()\n",
        "\n",
        "    def on_mouse_release(self, point, button, mods):\n",
        "        super().on_mouse_release(point, button, mods)\n",
        "        if self.root_dots.has_updaters() or self.coef_dots.has_updaters():\n",
        "            # End the interaction where a dot is tied to the mouse\n",
        "            self.root_dots.clear_updaters()\n",
        "            self.coef_dots.clear_updaters()\n",
        "            self.remove_dot_aura()\n",
        "            return\n",
        "        dot = self.point_to_mobject(point, search_set=self.get_all_dots(), buff=0.1)\n",
        "        if dot is None:\n",
        "            return\n",
        "        self.add_dot_auroa(dot)\n",
        "        if self.window.is_key_pressed(ord(\"c\")):\n",
        "            self.handle_cycle_preparation(dot)\n",
        "            return\n",
        "\n",
        "        # Make sure other dots are updated accordingly\n",
        "        if dot in self.root_dots:\n",
        "            self.tie_coefs_to_roots()\n",
        "        elif dot in self.coef_dots:\n",
        "            self.tie_roots_to_coefs()\n",
        "\n",
        "        # Have this dot track with the mouse\n",
        "        dot.mouse_point_diff = dot.get_center() - self.mouse_point.get_center()\n",
        "        dot.add_updater(lambda d: d.move_to(self.mouse_point.get_center() + d.mouse_point_diff))\n",
        "        if self.lock_coef_imag or self.window.is_key_pressed(ord(\"r\")):\n",
        "            # Fix the imaginary value\n",
        "            dot.last_y = dot.get_y()\n",
        "            dot.add_updater(lambda d: d.set_y(d.last_y))\n",
        "        elif (self.lock_coef_norm or self.window.is_key_pressed(ord(\"a\"))) and dot in self.coef_dots:\n",
        "            # Fix the norm\n",
        "            dot.last_norm = get_norm(self.coef_plane.p2c(dot.get_center()))\n",
        "            dot.add_updater(lambda d: d.move_to(self.coef_plane.c2p(\n",
        "                *d.last_norm * normalize(self.coef_plane.p2c(d.get_center()))\n",
        "            )))\n",
        "\n",
        "    def on_key_release(self, symbol, modifiers):\n",
        "        super().on_key_release(symbol, modifiers)\n",
        "        char = chr(symbol)\n",
        "        if char == \"c\":\n",
        "            self.carry_out_cycle()\n",
        "\n",
        "    #\n",
        "    def update_mobjects(self, dt):\n",
        "        # Go in reverse order, since dots are often re-added\n",
        "        # once they become interactive\n",
        "        for mobject in reversed(self.mobjects):\n",
        "            mobject.update(dt)\n",
        "\n",
        "\n",
        "class RadicalScene(RootCoefScene):\n",
        "    n = 3\n",
        "    c = 1.5\n",
        "    root_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "        }\n",
        "    }\n",
        "    coef_plane_config = {\n",
        "        \"x_range\": (-2, 2),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY,\n",
        "        }\n",
        "    }\n",
        "    plane_height = 4.0\n",
        "    plane_buff = 3.0\n",
        "    planes_center = 1.5 * DOWN\n",
        "    show_equals = False\n",
        "\n",
        "    def setup(self):\n",
        "        self.coefs = [-self.c, *[0] * (self.n - 1), 1]\n",
        "        super().setup()\n",
        "        self.remove(self.coef_plane_label)\n",
        "        self.remove(self.root_plane_label)\n",
        "        self.sync_roots(self.root_dots[0])\n",
        "\n",
        "    def get_radical_labels(self):\n",
        "        left = self.coef_plane.get_right()\n",
        "        right = self.root_plane.get_left()\n",
        "        arrow_kw = dict(\n",
        "            stroke_width=5,\n",
        "            stroke_color=GREY_A,\n",
        "            buff=0.5,\n",
        "        )\n",
        "        r_arrow = Arrow(left, right, **arrow_kw).shift(UP)\n",
        "        l_arrow = Arrow(right, left, **arrow_kw).shift(DOWN)\n",
        "\n",
        "        r_label = OldTex(f\"\\\\sqrt[{self.n}]{{c}}\")[0]\n",
        "        l_label = OldTex(f\"r_i^{{{self.n}}}\")[0]\n",
        "        r_label[3].set_color(self.coef_color)\n",
        "        l_label[-3::2].set_color(self.root_color)\n",
        "\n",
        "        if self.n == 2:\n",
        "            r_label[0].set_opacity(0)\n",
        "\n",
        "        r_label.next_to(r_arrow, UP)\n",
        "        l_label.next_to(l_arrow, UP)\n",
        "\n",
        "        return VGroup(\n",
        "            VGroup(r_arrow, l_arrow),\n",
        "            VGroup(r_label, l_label),\n",
        "        )\n",
        "\n",
        "    def get_angle_label(self, dot, plane, sym, get_theta):\n",
        "        line = Line()\n",
        "        line.set_stroke(dot.get_fill_color(), width=2)\n",
        "        line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(), dot.get_center()\n",
        "        ))\n",
        "\n",
        "        arc = always_redraw(lambda: ParametricCurve(\n",
        "            lambda t: plane.n2p((0.25 + 0.01 * t) * np.exp(complex(0, t))),\n",
        "            t_range=[0, get_theta() + 1e-5, 0.025],\n",
        "            stroke_width=2,\n",
        "        ))\n",
        "\n",
        "        tex_mob = OldTex(sym, font_size=24)\n",
        "        tex_mob.set_backstroke(width=8)\n",
        "\n",
        "        def update_sym(tex_mob):\n",
        "            tex_mob.set_opacity(min(1, 3 * get_theta()))\n",
        "            point = arc.t_func(0.5 * get_theta())\n",
        "            origin = plane.get_origin()\n",
        "            w = tex_mob.get_width()\n",
        "            tex_mob.move_to(origin + (1.3 + 2 * w) * (point - origin))\n",
        "            return tex_mob\n",
        "\n",
        "        tex_mob.add_updater(update_sym)\n",
        "\n",
        "        return VGroup(line, arc, tex_mob)\n",
        "\n",
        "    def get_c(self):\n",
        "        return -self.get_coefs()[0]\n",
        "\n",
        "    # Updates to RootCoefScene methods\n",
        "    def get_coef_poly(self):\n",
        "        degree = self.get_degree()\n",
        "        return OldTex(f\"x^{degree}\", \"-\", \"c\")\n",
        "\n",
        "    def get_c_symbols(self, coef_poly):\n",
        "        return VGroup(coef_poly[-1])\n",
        "\n",
        "    def add_c_labels(self):\n",
        "        self.c_dot_labels = self.add_dot_labels(\n",
        "            VGroup(OldTex(\"c\")),\n",
        "            VGroup(self.coef_dots[0]),\n",
        "        )\n",
        "\n",
        "    def get_coefs(self):\n",
        "        c = self.coef_plane.p2n(self.coef_dots[0].get_center())\n",
        "        return [-c, *[0] * (self.n - 1), 1]\n",
        "\n",
        "    def set_coefs(self, coefs):\n",
        "        super().set_coefs(coefs)\n",
        "        self.coef_dots[0].move_to(self.coef_plane.n2p(-coefs[0]))\n",
        "        self.coef_dots[1:].set_opacity(0)\n",
        "\n",
        "    def tie_coefs_to_roots(self, *args, **kwargs):\n",
        "        super().tie_coefs_to_roots(*args, **kwargs)\n",
        "        # Hack\n",
        "        for dot in self.root_dots:\n",
        "            dot.add_updater(lambda m: m)\n",
        "\n",
        "    def update_coef_dots_by_roots(self, coef_dots):\n",
        "        controlled_roots = [\n",
        "            d for d in self.root_dots\n",
        "            if len(d.get_updaters()) > 1\n",
        "        ]\n",
        "        root_dot = controlled_roots[0] if controlled_roots else self.root_dots[0]\n",
        "        root = self.root_plane.p2n(root_dot.get_center())\n",
        "        coef_dots[0].move_to(self.coef_plane.n2p(root**self.n))\n",
        "        # Update all the root dots\n",
        "        if controlled_roots:\n",
        "            self.sync_roots(controlled_roots[0])\n",
        "        return coef_dots\n",
        "\n",
        "    def sync_roots(self, anchor_root_dot):\n",
        "        root = self.root_plane.p2n(anchor_root_dot.get_center())\n",
        "        anchor_index = self.root_dots.submobjects.index(anchor_root_dot)\n",
        "        for i, dot in enumerate(self.root_dots):\n",
        "            if i != anchor_index:\n",
        "                zeta = np.exp(complex(0, (i - anchor_index) * TAU / self.n))\n",
        "                dot.move_to(self.root_plane.n2p(zeta * root))\n",
        "\n",
        "\n",
        "class QuadraticFormula(RootCoefScene):\n",
        "    coefs = [-1, 0, 1]\n",
        "    coef_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY_B,\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    sqrt_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_D,\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    plane_height = 3.5\n",
        "    plane_arrangement = RIGHT\n",
        "    plane_buff = 1.0\n",
        "    planes_center = 2 * LEFT + DOWN\n",
        "\n",
        "    def add_planes(self):\n",
        "        super().add_planes()\n",
        "        self.coef_plane_label.match_y(self.root_plane_label)\n",
        "        self.add_sqrt_plane()\n",
        "\n",
        "    def add_sqrt_plane(self):\n",
        "        plane = ComplexPlane(**self.sqrt_plane_config)\n",
        "        plane.next_to(self.coef_plane, self.plane_arrangement, self.plane_buff)\n",
        "        plane.set_height(self.plane_height)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "\n",
        "        label = OldTex(\n",
        "            \"-{b \\\\over 2} \\\\pm \\\\sqrt{{b^2 \\\\over 4} - c}\",\n",
        "            font_size=30,\n",
        "        )[0]\n",
        "        for i in [1, 7, 12]:\n",
        "            label[i].set_color(self.coef_color)\n",
        "        label.next_to(plane, UP)\n",
        "\n",
        "        self.sqrt_plane = plane\n",
        "        self.sqrt_label = label\n",
        "        self.add(plane)\n",
        "        self.add(label)\n",
        "\n",
        "    def add_dots(self):\n",
        "        super().add_dots()\n",
        "        dots = self.root_dots.copy().clear_updaters()\n",
        "        dots.set_color(GREEN)\n",
        "\n",
        "        def update_dots(dots):\n",
        "            for dot, root in zip(dots, self.get_roots()):\n",
        "                dot.move_to(self.sqrt_plane.n2p(root))\n",
        "            return dots\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        self.sqrt_dots = dots\n",
        "        self.add(dots)\n",
        "        self.add(self.get_tracers(dots))\n",
        "\n",
        "    def get_coef_poly(self):\n",
        "        return OldTex(\n",
        "            \"x^2\", \"+ b x\", \"+ c\"\n",
        "        )\n",
        "\n",
        "    def add_c_labels(self):\n",
        "        self.c_dot_labels = self.add_dot_labels(\n",
        "            VGroup(OldTex(\"c\"), OldTex(\"b\")),\n",
        "            self.coef_dots\n",
        "        )\n",
        "\n",
        "    def get_c_symbols(self, coef_poly):\n",
        "        return VGroup(*(part[1] for part in coef_poly[:0:-1]))\n",
        "\n",
        "\n",
        "# Analyze the cubic formula\n",
        "\n",
        "\n",
        "class Cubic(RootCoefScene):\n",
        "    coefs = [1, 0, 1]\n",
        "\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class AmbientRootSwapping(RootCoefScene):\n",
        "    n_swaps = 0\n",
        "\n",
        "    def construct(self):\n",
        "        for x in range(self.n_swaps):\n",
        "            k = random.randint(2, 5)\n",
        "            indices = random.choice(list(it.combinations(range(5), k)))\n",
        "            self.swap_roots(*indices)\n",
        "            self.wait()\n",
        "\n",
        "        self.embed()\n"
    ]
}