{
    "topic": "The mathematical concept being demonstrated is the use of Newton's method to find the roots of a polynomial",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from _2022.quintic import coefficients_to_roots\n",
        "from _2022.quintic import roots_to_coefficients\n",
        "from _2022.quintic import dpoly\n",
        "from _2022.quintic import poly\n",
        "\n",
        "\n",
        "ROOT_COLORS_BRIGHT = [RED, GREEN, BLUE, YELLOW, MAROON_B]\n",
        "ROOT_COLORS_DEEP = [\"#440154\", \"#3b528b\", \"#21908c\", \"#5dc963\", \"#29abca\"]\n",
        "CUBIC_COLORS = [RED_E, TEAL_E, BLUE_E]\n",
        "\n",
        "\n",
        "def glow_dot(point, r_min=0.05, r_max=0.15, color=YELLOW, n=20, opacity_mult=1.0):\n",
        "    result = VGroup(*(\n",
        "        Dot(point, radius=interpolate(r_min, r_max, a))\n",
        "        for a in np.linspace(0, 1, n)\n",
        "    ))\n",
        "    result.set_fill(color, opacity=opacity_mult / n)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_newton_rule(font_size=36, var=\"z\", **kwargs):\n",
        "    terms = [f\"{var}_n\", f\"{var}_{{n + 1}}\"]\n",
        "    t0, t1 = terms\n",
        "    return OldTex(\n",
        "        t1, \"=\", t0, \"-\",\n",
        "        \"{P(\", t0, \")\", \"\\\\over \", \"P'(\", t0, \")}\",\n",
        "        font_size=36,\n",
        "        **kwargs\n",
        "    )\n",
        "\n",
        "\n",
        "def coefs_to_poly_string(coefs):\n",
        "    n = len(coefs) - 1\n",
        "    tex_str = \"\" if coefs[-1] == 1 else str(int(coefs[-1]))\n",
        "    tex_str += f\"z^{{{n}}}\"\n",
        "    for c, k in zip(coefs[-2::-1], it.count(n - 1, -1)):\n",
        "        if c == 0:\n",
        "            continue\n",
        "        if isinstance(c, complex):\n",
        "            num_str = \"({:+}\".format(int(c.real))\n",
        "            num_str += \"+ {:+})\".format(int(c.imag))\n",
        "        else:\n",
        "            num_str = \"{:+}\".format(int(c))\n",
        "        if abs(c) == 1 and k > 0:\n",
        "            num_str = num_str[:-1]\n",
        "        tex_str += num_str\n",
        "        if k == 0:\n",
        "            continue\n",
        "        elif k == 1:\n",
        "            tex_str += \"z\"\n",
        "        else:\n",
        "            tex_str += f\"z^{{{k}}}\"\n",
        "    return tex_str\n",
        "\n",
        "\n",
        "def get_figure(image_name, person_name, year_text, height=3, label_direction=DOWN):\n",
        "    image = ImageMobject(image_name)\n",
        "    image.set_height(height)\n",
        "    rect = SurroundingRectangle(image, buff=0)\n",
        "    rect.set_stroke(WHITE, 2)\n",
        "    name = Text(f\"{person_name}\", font_size=36)\n",
        "    name.set_color(GREY_A)\n",
        "    year_label = Text(f\"{year_text}\", font_size=30)\n",
        "    year_label.match_color(name)\n",
        "    year_label.next_to(name, DOWN, buff=0.2)\n",
        "    VGroup(name, year_label).next_to(image, label_direction)\n",
        "    return Group(rect, image, name, year_label)\n",
        "\n",
        "\n",
        "class NewtonFractal(Mobject):\n",
        "    CONFIG = {\n",
        "        \"shader_folder\": \"newton_fractal\",\n",
        "        \"data_dtype\": [\n",
        "            ('point', np.float32, (3,)),\n",
        "        ],\n",
        "        \"colors\": ROOT_COLORS_DEEP,\n",
        "        \"coefs\": [1.0, -1.0, 1.0, 0.0, 0.0, 1.0],\n",
        "        \"scale_factor\": 1.0,\n",
        "        \"offset\": ORIGIN,\n",
        "        \"n_steps\": 30,\n",
        "        \"julia_highlight\": 0.0,\n",
        "        \"max_degree\": 5,\n",
        "        \"saturation_factor\": 0.0,\n",
        "        \"opacity\": 1.0,\n",
        "        \"black_for_cycles\": False,\n",
        "        \"is_parameter_space\": False,\n",
        "    }\n",
        "\n",
        "    def __init__(self, plane, **kwargs):\n",
        "        super().__init__(\n",
        "            scale_factor=plane.get_x_unit_size(),\n",
        "            offset=plane.n2p(0),\n",
        "            **kwargs,\n",
        "        )\n",
        "        self.replace(plane, stretch=True)\n",
        "\n",
        "    def init_data(self):\n",
        "        self.set_points([UL, DL, UR, DR])\n",
        "\n",
        "    def init_uniforms(self):\n",
        "        super().init_uniforms()\n",
        "        self.set_colors(self.colors)\n",
        "        self.set_julia_highlight(self.julia_highlight)\n",
        "        self.set_coefs(self.coefs)\n",
        "        self.set_scale(self.scale_factor)\n",
        "        self.set_offset(self.offset)\n",
        "        self.set_n_steps(self.n_steps)\n",
        "        self.set_saturation_factor(self.saturation_factor)\n",
        "        self.set_opacity(self.opacity)\n",
        "        self.uniforms[\"black_for_cycles\"] = float(self.black_for_cycles)\n",
        "        self.uniforms[\"is_parameter_space\"] = float(self.is_parameter_space)\n",
        "\n",
        "    def set_colors(self, colors):\n",
        "        self.uniforms.update({\n",
        "            f\"color{n}\": np.array(color_to_rgba(color))\n",
        "            for n, color in enumerate(colors)\n",
        "        })\n",
        "        return self\n",
        "\n",
        "    def set_julia_highlight(self, value):\n",
        "        self.uniforms[\"julia_highlight\"] = value\n",
        "\n",
        "    def set_coefs(self, coefs, reset_roots=True):\n",
        "        full_coefs = [*coefs] + [0] * (self.max_degree - len(coefs) + 1)\n",
        "        self.uniforms.update({\n",
        "            f\"coef{n}\": np.array([coef.real, coef.imag], dtype=np.float64)\n",
        "            for n, coef in enumerate(map(complex, full_coefs))\n",
        "        })\n",
        "        if reset_roots:\n",
        "            self.set_roots(coefficients_to_roots(coefs), False)\n",
        "        self.coefs = coefs\n",
        "        return self\n",
        "\n",
        "    def set_roots(self, roots, reset_coefs=True):\n",
        "        self.uniforms[\"n_roots\"] = float(len(roots))\n",
        "        full_roots = [*roots] + [0] * (self.max_degree - len(roots))\n",
        "        self.uniforms.update({\n",
        "            f\"root{n}\": np.array([root.real, root.imag], dtype=np.float64)\n",
        "            for n, root in enumerate(map(complex, full_roots))\n",
        "        })\n",
        "        if reset_coefs:\n",
        "            self.set_coefs(roots_to_coefficients(roots), False)\n",
        "        self.roots = roots\n",
        "        return self\n",
        "\n",
        "    def set_scale(self, scale_factor):\n",
        "        self.uniforms[\"scale_factor\"] = scale_factor\n",
        "        return self\n",
        "\n",
        "    def set_offset(self, offset):\n",
        "        self.uniforms[\"offset\"] = np.array(offset)\n",
        "        return self\n",
        "\n",
        "    def set_n_steps(self, n_steps):\n",
        "        self.uniforms[\"n_steps\"] = float(n_steps)\n",
        "        return self\n",
        "\n",
        "    def set_saturation_factor(self, saturation_factor):\n",
        "        self.uniforms[\"saturation_factor\"] = float(saturation_factor)\n",
        "        return self\n",
        "\n",
        "    def set_opacities(self, *opacities):\n",
        "        for n, opacity in enumerate(opacities):\n",
        "            self.uniforms[f\"color{n}\"][3] = opacity\n",
        "        return self\n",
        "\n",
        "    def set_opacity(self, opacity, recurse=True):\n",
        "        self.set_opacities(*len(self.roots) * [opacity])\n",
        "        return self\n",
        "\n",
        "\n",
        "class MetaNewtonFractal(NewtonFractal):\n",
        "    CONFIG = {\n",
        "        \"coefs\": [-1.0, 0.0, 0.0, 1.0],\n",
        "        \"colors\": [*ROOT_COLORS_DEEP[::2], BLACK, BLACK],\n",
        "        \"fixed_roots\": [-1, 1],\n",
        "        \"n_roots\": 3,\n",
        "        \"black_for_cycles\": True,\n",
        "        \"is_parameter_space\": True,\n",
        "        \"n_steps\": 300,\n",
        "    }\n",
        "\n",
        "    def init_uniforms(self):\n",
        "        super().init_uniforms()\n",
        "        self.set_fixed_roots(self.fixed_roots)\n",
        "\n",
        "    def set_fixed_roots(self, roots):\n",
        "        super().set_roots(roots, reset_coefs=False)\n",
        "        self.uniforms[\"n_roots\"] = 3.0\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class AmbientRootFinding(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class PragmaticOrigins(Scene):\n",
        "    title = \"Pragmatic origins\"\n",
        "    include_pi = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = Text(self.title, font_size=72)\n",
        "        title.set_stroke(BLACK, 5, background=True)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "        underline.insert_n_curves(30)\n",
        "        underline.set_stroke(BLUE, width=[0, 3, 3, 3, 0])\n",
        "        underline.scale(1.5)\n",
        "\n",
        "        # Axes\n",
        "        axes = NumberPlane(\n",
        "            x_range=(-3, 3),\n",
        "            y_range=(-4, 4),\n",
        "            width=6,\n",
        "            height=8,\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_A,\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        )\n",
        "        axes.set_height(5.0)\n",
        "        axes.to_corner(DL)\n",
        "        axes.shift(0.5 * UP)\n",
        "\n",
        "        coefs = np.array([2, -3, 1, -2, -1, 1], dtype=np.float)\n",
        "        roots = [\n",
        "            r.real\n",
        "            for r in coefficients_to_roots(coefs)\n",
        "            if abs(r.imag) < 1e-2\n",
        "        ]\n",
        "        roots.sort()\n",
        "        coefs *= 0.2\n",
        "\n",
        "        solve = OldTexText(\"Solve $f(x) = 0$\", font_size=36)\n",
        "        solve.next_to(axes, UP, aligned_edge=LEFT)\n",
        "        expr = OldTex(\"f(x) = x^5 - x^4 - 2x^3 + x^2 -3x + 2\")\n",
        "        expr.match_width(axes)\n",
        "        expr.next_to(axes, DOWN)\n",
        "        graph_x_range = (-2, 2.4)\n",
        "        graph = axes.get_graph(\n",
        "            lambda x: poly(x, coefs),\n",
        "            x_range=graph_x_range\n",
        "        )\n",
        "        graph.set_stroke(BLUE, [0, *50 * [4], 0])\n",
        "        root_dots = VGroup(*(\n",
        "            glow_dot(axes.c2p(root, 0))\n",
        "            for root in roots\n",
        "        ))\n",
        "        root_eqs = VGroup()\n",
        "        root_groups = VGroup()\n",
        "        for i, root, dot in zip(it.count(1), roots, root_dots):\n",
        "            lhs = OldTex(f\"x_{i} = \")\n",
        "            rhs = DecimalNumber(root, num_decimal_places=3)\n",
        "            rhs.set_color(YELLOW)\n",
        "            eq = VGroup(lhs, rhs)\n",
        "            eq.arrange(RIGHT, aligned_edge=DOWN)\n",
        "            rhs.align_to(lhs.family_members_with_points()[0], DOWN)\n",
        "            root_eqs.add(eq)\n",
        "            root_groups.add(VGroup(eq, dot))\n",
        "        root_eqs.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        root_eqs.next_to(axes, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(solve)\n",
        "        self.add(expr)\n",
        "\n",
        "        # Pi\n",
        "        if self.include_pi:\n",
        "            morty = Mortimer(height=2)\n",
        "            morty.to_corner(DR)\n",
        "            self.play(PiCreatureSays(\n",
        "                morty, \"How do you\\nfind theses?\",\n",
        "                target_mode=\"tease\",\n",
        "                bubble_config={\n",
        "                    \"width\": 4,\n",
        "                    \"height\": 2.5,\n",
        "                }\n",
        "            ))\n",
        "\n",
        "        # Animations\n",
        "        self.add(underline, title)\n",
        "        self.play(\n",
        "            ShowCreation(underline),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        alphas = [inverse_interpolate(*graph_x_range, root) for root in roots]\n",
        "        self.play(\n",
        "            ShowCreation(graph, rate_func=linear),\n",
        "            *(\n",
        "                FadeIn(\n",
        "                    rg,\n",
        "                    rate_func=squish_rate_func(rush_from, a, min(a + 0.2, 1))\n",
        "                )\n",
        "                for rg, a in zip(root_groups, alphas)\n",
        "            ),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SeekingRoots(PragmaticOrigins):\n",
        "    title = \"Seeking roots\"\n",
        "    include_pi = True\n",
        "\n",
        "\n",
        "class AskAboutComplexity(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        question = Text(\"What does this complexity reflect?\")\n",
        "        question.set_width(FRAME_WIDTH - 2)\n",
        "        question.to_edge(UP)\n",
        "        self.add(question)\n",
        "\n",
        "        screen = ScreenRectangle()\n",
        "        screen.set_height(6.0)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.next_to(question, DOWN)\n",
        "        self.add(screen)\n",
        "\n",
        "\n",
        "class WhoCares(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.students.refresh_triangulation()\n",
        "        screen = self.screen\n",
        "        screen.set_height(4, about_edge=UL)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        image = ImageMobject(\"RealNewtonStill\")\n",
        "        image.replace(screen)\n",
        "\n",
        "        self.add(screen)\n",
        "        self.add(image)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            PiCreatureSays(\n",
        "                self.students[1], \"Ooh, quintics...\",\n",
        "                target_mode=\"thinking\",\n",
        "                look_at=self.screen,\n",
        "                bubble_config={\n",
        "                    \"direction\": LEFT,\n",
        "                    \"width\": 4,\n",
        "                    \"height\": 2,\n",
        "                }\n",
        "            ),\n",
        "            self.teacher.change(\"happy\"),\n",
        "            self.students[0].change(\"thinking\", screen),\n",
        "            self.students[2].change(\"sassy\", screen),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.play(LaggedStart(\n",
        "            PiCreatureSays(\n",
        "                self.students[2], \"Who cares?\",\n",
        "                target_mode=\"tired\",\n",
        "                bubble_config={\n",
        "                    \"direction\": LEFT,\n",
        "                    \"width\": 4,\n",
        "                    \"height\": 3,\n",
        "                }\n",
        "            ),\n",
        "            self.teacher.change(\"guilty\"),\n",
        "            self.students[0].change(\"confused\", screen),\n",
        "            RemovePiCreatureBubble(\n",
        "                self.students[1],\n",
        "                look_at=self.students[2].eyes,\n",
        "                target_mode=\"erm\",\n",
        "            ),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"Who doesn't\",\n",
        "            target_mode=\"hooray\",\n",
        "            bubble_config={\"height\": 3, \"width\": 4},\n",
        "            added_anims=[self.change_students(\"pondering\", \"pondering\", \"confused\")]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class SphereExample(Scene):\n",
        "    def construct(self):\n",
        "        # Shape\n",
        "        axes = ThreeDAxes(z_range=(-4, 4))\n",
        "        axes.shift(IN)\n",
        "        sphere = Sphere(radius=1.0)\n",
        "        # sphere = TexturedSurface(sphere, \"EarthTextureMap\", \"NightEarthTextureMap\")\n",
        "        sphere.move_to(axes.c2p(0, 0, 0))\n",
        "        sphere.set_gloss(1.0)\n",
        "        sphere.set_opacity(0.5)\n",
        "        sphere.sort_faces_back_to_front(DOWN)\n",
        "        mesh = SurfaceMesh(sphere, resolution=(21, 11))\n",
        "        mesh.set_stroke(BLUE, 0.5, 0.5)\n",
        "        sphere = Group(sphere, mesh)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(20, 80)\n",
        "        frame.move_to(2 * RIGHT)\n",
        "        light = self.camera.light_source\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(sphere)\n",
        "\n",
        "        frame.add_updater(\n",
        "            lambda m, dt: m.increment_theta(1 * dt * DEGREES)\n",
        "        )\n",
        "\n",
        "        # Expression\n",
        "        equation = OldTex(\n",
        "            \"1.00\", \"\\\\,x^2\", \"+\",\n",
        "            \"1.00\", \"\\\\,y^2\", \"+\",\n",
        "            \"1.00\", \"\\\\,z^2\", \"=\",\n",
        "            \"1.00\",\n",
        "        )\n",
        "        decimals = VGroup()\n",
        "        for i in range(0, len(equation), 3):\n",
        "            decimal = DecimalNumber(1.0, edge_to_fix=RIGHT)\n",
        "            decimal.replace(equation[i])\n",
        "            equation.replace_submobject(i, decimal)\n",
        "            decimals.add(decimal)\n",
        "            decimal.add_updater(lambda m: m.fix_in_frame())\n",
        "        equation.fix_in_frame()\n",
        "        equation.to_corner(UR)\n",
        "        self.add(equation)\n",
        "\n",
        "        # Animations\n",
        "        light.move_to([-10, -10, 20])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(decimals[3], 9.0),\n",
        "            VFadeInThenOut(SurroundingRectangle(decimals[3]).fix_in_frame()),\n",
        "            sphere.animate.scale(3),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(decimals[2], 4.0),\n",
        "            VFadeInThenOut(SurroundingRectangle(decimals[2]).fix_in_frame()),\n",
        "            sphere.animate.stretch(0.5, 2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(decimals[0], 9.0),\n",
        "            VFadeInThenOut(SurroundingRectangle(decimals[0]).fix_in_frame()),\n",
        "            sphere.animate.stretch(1 / 3, 0),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ExamplePixels(Scene):\n",
        "    def construct(self):\n",
        "        pixels = Square().get_grid(5, 5, buff=0)\n",
        "        pixels.set_height(2)\n",
        "        pixels.to_corner(UL)\n",
        "        pixels.set_stroke(WHITE, 1)\n",
        "        pixels.set_fill(BLACK, 1)\n",
        "        self.add(pixels)\n",
        "\n",
        "        y, x = 1066, 1360\n",
        "\n",
        "        endpoint = np.array([x, -y, 0], dtype=np.float)\n",
        "        endpoint *= FRAME_HEIGHT / 2160\n",
        "        endpoint += np.array([-FRAME_WIDTH / 2, FRAME_HEIGHT / 2, 0])\n",
        "        lines = VGroup(\n",
        "            Line(pixels.get_corner(UR), endpoint),\n",
        "            Line(pixels.get_corner(DL), endpoint),\n",
        "        )\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "        self.add(lines)\n",
        "\n",
        "        def match_values(pixels, values):\n",
        "            for pixel, value in zip(pixels, it.chain(*values)):\n",
        "                value = value[::-1]\n",
        "                pixel.set_fill(rgb_to_color(value / 255))\n",
        "\n",
        "        values = np.load(\n",
        "            os.path.join(get_directories()[\"data\"], \"sphere_pixel_values.npy\")\n",
        "        )\n",
        "        match_values(pixels, values[0])\n",
        "        # for value in values[60::60]:\n",
        "        for value in values[1:]:\n",
        "            # pixels.generate_target()\n",
        "            # match_values(pixels.target, value)\n",
        "            # self.play(MoveToTarget(pixels))\n",
        "            match_values(pixels, value)\n",
        "            self.wait(1 / 60)\n",
        "\n",
        "\n",
        "class CurvesDefiningFonts(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        chars = OldTexText(\"When a computer\\\\\\\\renders text...\")[0]\n",
        "        chars.set_width(FRAME_WIDTH - 3)\n",
        "        chars.refresh_triangulation()\n",
        "        filled_chars = chars.copy()\n",
        "        filled_chars.insert_n_curves(50)\n",
        "        chars.set_stroke(WHITE, 0.5)\n",
        "        chars.set_fill(opacity=0.0)\n",
        "\n",
        "        dot_groups = VGroup()\n",
        "        line_groups = VGroup()\n",
        "        for char in chars:\n",
        "            dots = VGroup()\n",
        "            lines = VGroup()\n",
        "            for a1, h, a2 in char.get_bezier_tuples():\n",
        "                for pair in (a1, h), (h, a2):\n",
        "                    lines.add(Line(\n",
        "                        *pair,\n",
        "                        stroke_width=0.25,\n",
        "                        # dash_length=0.0025,\n",
        "                        stroke_color=YELLOW,\n",
        "                    ))\n",
        "                for point in (a1, h, a2):\n",
        "                    dots.add(Dot(point, radius=0.005))\n",
        "            dot_groups.add(dots)\n",
        "            line_groups.add(lines)\n",
        "\n",
        "        dot_groups.set_fill(BLUE, opacity=0)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(filled_chars, run_time=1, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in on one letter\n",
        "        char_index = 2\n",
        "        char = chars[char_index]\n",
        "        lines = line_groups[char_index]\n",
        "        dots = dot_groups[char_index]\n",
        "        char.refresh_bounding_box()\n",
        "        frame.generate_target()\n",
        "        frame.target.set_height(char.get_height() * 2)\n",
        "        frame.target.move_to(char.get_bottom(), DOWN)\n",
        "        frame.target.shift(0.1 * char.get_height() * DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            filled_chars.animate.set_opacity(0.2),\n",
        "            FadeIn(chars),\n",
        "            ShowCreation(line_groups, rate_func=linear),\n",
        "            dot_groups.animate.set_opacity(1),\n",
        "            run_time=5,\n",
        "        )\n",
        "        for group in (line_groups, dot_groups):\n",
        "            group.remove(*group[0:char_index - 1])\n",
        "            group.remove(*group[char_index + 2:])\n",
        "        self.wait()\n",
        "\n",
        "        # Pull out one curve\n",
        "        char.become(CurvesAsSubmobjects(char))\n",
        "\n",
        "        index = 26\n",
        "        curve = char[index]\n",
        "        sublines = lines[2 * index:2 * index + 2]\n",
        "        subdots = dots[3 * index:3 * index + 3]\n",
        "\n",
        "        curve_group = VGroup(curve, sublines, subdots)\n",
        "        curve_group.set_stroke(background=True)\n",
        "        curve_group.generate_target()\n",
        "        curve_group.save_state()\n",
        "        curve_group.target.scale(3)\n",
        "        curve_group.target.next_to(frame.get_top(), DOWN, buff=0.15)\n",
        "        curve_group.target.shift(0.3 * LEFT)\n",
        "        for dot in curve_group.target[2]:\n",
        "            dot.scale(1 / 2)\n",
        "\n",
        "        labels = VGroup(*(\n",
        "            OldTex(f\"P_{i}\").set_height(0.05)\n",
        "            for i in range(3)\n",
        "        ))\n",
        "        for label, dot, vect in zip(labels, curve_group.target[2], [LEFT, UP, UP]):\n",
        "            label.insert_n_curves(20)\n",
        "            label.next_to(dot, vect, buff=0.025)\n",
        "            label.match_color(dot)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(curve_group),\n",
        "            *(\n",
        "                GrowFromPoint(label, curve_group.get_center())\n",
        "                for label in labels\n",
        "            )\n",
        "        )\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"(1-t)^{2} P_0 +2(1-t)t P_1 +t^2 P_2\",\n",
        "            tex_to_color_map={\n",
        "                \"P_0\": BLUE,\n",
        "                \"P_1\": BLUE,\n",
        "                \"P_2\": BLUE,\n",
        "            }\n",
        "        )\n",
        "        equation.set_height(0.07)\n",
        "        equation.next_to(curve_group, RIGHT, buff=0.25)\n",
        "        equation.insert_n_curves(20)\n",
        "\n",
        "        poly_label = Text(\"Polynomial\")\n",
        "        poly_label.insert_n_curves(20)\n",
        "        poly_label.set_width(2)\n",
        "        poly_label.apply_function(\n",
        "            lambda p: [\n",
        "                p[0],\n",
        "                p[1] - 0.2 * p[0]**2,\n",
        "                p[2],\n",
        "            ]\n",
        "        )\n",
        "        poly_label.rotate(30 * DEGREES)\n",
        "        poly_label.match_height(curve_group)\n",
        "        poly_label.scale(0.8)\n",
        "        poly_label.move_to(curve, DR)\n",
        "        poly_label.shift(0.01 * UL)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(curve.copy().set_color(PINK), run_time=2),\n",
        "            Write(poly_label, stroke_width=0.5)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(\n",
        "                    labels[i],\n",
        "                    equation.get_part_by_tex(f\"P_{i}\").copy(),\n",
        "                    remover=True\n",
        "                )\n",
        "                for i in range(3)\n",
        "            )),\n",
        "            FadeIn(equation, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(curve_group.copy())\n",
        "        self.play(Restore(curve_group))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PlayingInFigma(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class RasterizingBezier(Scene):\n",
        "    def construct(self):\n",
        "        # Add curve and pixels\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        curve = SVGMobject(\"bezier_example\")[0]\n",
        "        curve.set_width(FRAME_WIDTH - 3)\n",
        "        curve.set_stroke(WHITE, width=1.0)\n",
        "        curve.set_fill(opacity=0)\n",
        "        curve.to_edge(DOWN, buff=1)\n",
        "        curve.insert_n_curves(10)  # To better uniformize it\n",
        "\n",
        "        thick_curve = curve.copy()\n",
        "        thick_curve.set_stroke(YELLOW, 30.0)\n",
        "        thick_curve.reverse_points()\n",
        "\n",
        "        pixels = Square().get_grid(90 // 2, 160 // 2, buff=0, fill_rows_first=False)\n",
        "        pixels.set_height(FRAME_HEIGHT)\n",
        "        pixels.set_stroke(WHITE, width=0.25)\n",
        "\n",
        "        # I fully recognize the irony is implementing this without\n",
        "        # solving polynomials, but I'm happy to be inificient on runtime\n",
        "        # to just code up the quickest thing I can think of.\n",
        "        samples = np.array([curve.pfp(x) for x in np.linspace(0, 1, 100)])\n",
        "        sw_tracker = ValueTracker(0.15)\n",
        "        get_sw = sw_tracker.get_value\n",
        "\n",
        "        for pixel in pixels:\n",
        "            diffs = samples - pixel.get_center()\n",
        "            dists = np.apply_along_axis(lambda p: np.dot(p, p), 1, diffs)\n",
        "            index = np.argmin(dists)\n",
        "            if index == 0 or index == len(samples) - 1:\n",
        "                pixel.dist = np.infty\n",
        "            else:\n",
        "                pixel.dist = dists[index]\n",
        "\n",
        "        def update_pixels(pixels):\n",
        "            for pixel in pixels:\n",
        "                pixel.set_fill(\n",
        "                    YELLOW,\n",
        "                    0.5 * clip(10 * (get_sw() - pixel.dist), 0, 1)\n",
        "                )\n",
        "\n",
        "        update_pixels(pixels)\n",
        "\n",
        "        fake_pixels = pixels.copy()\n",
        "        fake_pixels.set_stroke(width=0)\n",
        "        fake_pixels.set_fill(GREY_E, 1)\n",
        "\n",
        "        self.add(thick_curve)\n",
        "        self.wait()\n",
        "        self.add(fake_pixels, pixels)\n",
        "        self.play(\n",
        "            FadeIn(fake_pixels),\n",
        "            ShowCreation(pixels),\n",
        "            lag_ratio=10 / len(pixels),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.remove(thick_curve)\n",
        "        self.wait()\n",
        "\n",
        "        # Pixel\n",
        "        pixel = pixels[725].deepcopy()\n",
        "        pixel.set_fill(opacity=0)\n",
        "        label = OldTexText(\"Pixel $\\\\vec{\\\\textbf{p}}$\")\n",
        "        label.refresh_triangulation()\n",
        "        label.set_fill(YELLOW)\n",
        "        label.set_stroke(BLACK, 4, background=True)\n",
        "        label.next_to(pixel, UL, buff=LARGE_BUFF)\n",
        "        label.shift_onto_screen()\n",
        "        arrow = Arrow(label, pixel, buff=0.1, stroke_width=3.0)\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(label),\n",
        "            ShowCreation(arrow),\n",
        "            pixel.animate.set_stroke(YELLOW, 2.0),\n",
        "        )\n",
        "        pixels.add_updater(update_pixels)\n",
        "        self.play(sw_tracker.animate.set_value(2.0), run_time=2)\n",
        "        self.play(sw_tracker.animate.set_value(0.2), run_time=2)\n",
        "        pixels.suspend_updating()\n",
        "        self.play(ShowCreation(curve))\n",
        "\n",
        "        # Show P(t) value\n",
        "        ct = VGroup(OldTex(\"\\\\vec{\\\\textbf{c}}(\")[0], DecimalNumber(0), OldTex(\")\")[0])\n",
        "        ct.arrange(RIGHT, buff=0)\n",
        "        ct.add_updater(lambda m: m.set_stroke(BLACK, 4, background=True))\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        P_dot = Dot(color=GREEN)\n",
        "        ct[1].add_updater(lambda m: m.set_value(get_t()))\n",
        "        ct[1].next_to(ct[0], RIGHT, buff=0)\n",
        "        P_dot.add_updater(lambda m: m.move_to(curve.pfp(get_t() / 2)))\n",
        "        ct.add_updater(lambda m: m.move_to(P_dot).shift(\n",
        "            (0.3 - 0.5 * get_t() * (1 - get_t())) * rotate_vector(np.array([-3, 1, 0]), -0.8 * get_t() * PI)\n",
        "        ))\n",
        "        curve_copy = curve.copy()\n",
        "        curve_copy.pointwise_become_partial(curve, 0, 0.5)\n",
        "        curve_copy.set_points(curve_copy.get_points_without_null_curves())\n",
        "        curve_copy.set_stroke(YELLOW, 3.0)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(ct),\n",
        "            ApplyMethod(t_tracker.set_value, 1.0, run_time=3),\n",
        "            ShowCreation(curve_copy, run_time=3),\n",
        "            VFadeIn(P_dot),\n",
        "        )\n",
        "        new_ct = OldTex(\"\\\\vec{\\\\textbf{c}}(\", \"t\", \")\")\n",
        "        new_ct.move_to(ct, LEFT)\n",
        "        new_ct.set_stroke(BLACK, 4, background=True)\n",
        "        self.play(FadeTransformPieces(ct, new_ct))\n",
        "        ct = new_ct\n",
        "        self.wait()\n",
        "\n",
        "        # Show distance\n",
        "        graph_group = self.get_corner_graph_group(pixel, curve)\n",
        "        bg_rect, axes, y_label, graph = graph_group\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        dist_line = Line()\n",
        "        dist_line.set_stroke(TEAL, 5)\n",
        "        dist_line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            pixel.get_center(),\n",
        "            curve_copy.pfp(t_tracker.get_value())\n",
        "        ))\n",
        "\n",
        "        dist_lines = VGroup()\n",
        "        graph_v_lines = VGroup()\n",
        "        for t in np.linspace(0, 1, 20):\n",
        "            t_tracker.set_value(t)\n",
        "            dist_lines.add(dist_line.update().copy().clear_updaters())\n",
        "            graph_v_lines.add(axes.get_v_line(\n",
        "                axes.input_to_graph_point(t, graph)\n",
        "            ))\n",
        "        dist_lines.set_stroke(RED, 1, opacity=1.0)\n",
        "        graph_v_lines.set_stroke(RED, 1, opacity=1.0)\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        self.play(\n",
        "            *map(FadeIn, graph_group[:-1]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(dist_lines, lag_ratio=1),\n",
        "            FadeIn(graph_v_lines, lag_ratio=1),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "        t_tracker.set_value(0.0)\n",
        "        self.play(\n",
        "            VFadeIn(dist_line, rate_func=squish_rate_func(smooth, 0, 0.25)),\n",
        "            ApplyMethod(t_tracker.set_value, 1.0),\n",
        "            ShowCreation(graph),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(dist_line.animate.set_stroke(RED, 1.0))\n",
        "        self.wait()\n",
        "\n",
        "        # Show width again\n",
        "        pixels.resume_updating()\n",
        "        self.play(sw_tracker.animate.set_value(1.5), run_time=2)\n",
        "        self.play(sw_tracker.animate.set_value(0.5), run_time=1)\n",
        "        pixels.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "        # Show derivative\n",
        "        deriv_graph_group = self.get_deriv_graph_group(graph_group)\n",
        "        d_graph = deriv_graph_group[-1]\n",
        "        d_graph.set_points_smoothly([d_graph.pfp(x) for x in np.linspace(0, 1, 20)])\n",
        "        deriv_axes = deriv_graph_group[1]\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        tan_line = always_redraw(\n",
        "            lambda: axes.get_tangent_line(\n",
        "                get_t(), graph, length=3,\n",
        "            ).set_stroke(\n",
        "                color=MAROON_B,\n",
        "                width=1.0,\n",
        "                opacity=clip(20 * get_t() * (1 - get_t()), 0, 1)\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.play(*map(FadeIn, deriv_graph_group[:-1]))\n",
        "        self.add(tan_line)\n",
        "        self.play(\n",
        "            t_tracker.animate.set_value(1),\n",
        "            ShowCreation(d_graph),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.remove(tan_line)\n",
        "        self.wait()\n",
        "\n",
        "        points = graph.get_points()\n",
        "        min_point = points[np.argmin([p[1] for p in points])]\n",
        "        min_line = Line(min_point, [min_point[0], deriv_axes.c2p(0, 0)[1], 0])\n",
        "        min_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        question = Text(\"What is\\nthis value?\", font_size=30)\n",
        "        question.to_corner(DR)\n",
        "        arrow = Arrow(\n",
        "            question.get_left(), min_line.get_bottom(), stroke_width=3,\n",
        "            buff=0.1\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(min_line))\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_corner_graph_group(self, pixel, curve, t_range=(0, 0.5)):\n",
        "        axes = Axes(\n",
        "            x_range=(0, 1, 0.2),\n",
        "            y_range=(0, 20, 5),\n",
        "            height=3,\n",
        "            width=5,\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        axes.to_corner(UR, buff=SMALL_BUFF)\n",
        "        y_label = OldTex(\n",
        "            \"&\\\\text{Distance}^2\\\\\\\\\",\n",
        "            \"&||\\\\vec{\\\\textbf{p}} - \\\\vec{\\\\textbf{c}}(t)||^2\",\n",
        "            font_size=24,\n",
        "        )\n",
        "        # For future transition\n",
        "        y_label = VGroup(VectorizedPoint(y_label.get_left()), *y_label)\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, aligned_edge=UP)\n",
        "        y_label.shift_onto_screen(buff=MED_SMALL_BUFF)\n",
        "\n",
        "        graph = axes.get_graph(lambda t: get_norm(\n",
        "            pixel.get_center() - curve.pfp(interpolate(*t_range, t))\n",
        "        )**2)\n",
        "        graph.set_stroke(RED, 2)\n",
        "\n",
        "        bg_rect = BackgroundRectangle(axes, buff=SMALL_BUFF)\n",
        "        result = VGroup(bg_rect, axes, y_label, graph)\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_deriv_graph_group(self, graph_group):\n",
        "        top_bg_rect, top_axes, top_y_label, top_graph = graph_group\n",
        "\n",
        "        axes = Axes(\n",
        "            x_range=top_axes.x_range,\n",
        "            y_range=(-60, 60, 10),\n",
        "            height=top_axes.get_height(),\n",
        "            width=top_axes.get_width(),\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        axes.to_corner(DR, buff=SMALL_BUFF)\n",
        "        axes.shift((top_axes.c2p(0, 0) - axes.c2p(0, 0))[0] * RIGHT)\n",
        "        dt = 1e-5\n",
        "        f = top_graph.underlying_function\n",
        "        graph = axes.get_graph(lambda t: (f(t + dt) - f(t)) / dt)\n",
        "        graph.set_stroke(MAROON_B)\n",
        "        # Dumb hack, not sure why it's needed\n",
        "        graph.get_points()[:133] += 0.015 * UP\n",
        "\n",
        "        y_label = VGroup(OldTex(\"\\\\frac{d}{dt}\", font_size=24), top_y_label[2].copy())\n",
        "        y_label.arrange(RIGHT, buff=0.05)\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, buff=2 * SMALL_BUFF)\n",
        "\n",
        "        bg_rect = BackgroundRectangle(VGroup(axes, graph), buff=SMALL_BUFF)\n",
        "        bg_rect.stretch(1.05, 1, about_edge=DOWN)\n",
        "\n",
        "        result = VGroup(bg_rect, axes, y_label, graph)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class WriteThisIsPolynomial(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"(Some polynomial in $t$)\", font_size=24)\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DontWorryAboutDetails(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"background_color\": BLACK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        screen = self.screen\n",
        "        screen.set_height(4, about_edge=UL)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        image1, image2 = [\n",
        "            ImageMobject(f\"RasterizingBezier_{i}\").replace(screen)\n",
        "            for i in range(1, 3)\n",
        "        ]\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.replace(image1)\n",
        "\n",
        "        self.add(screen, image1)\n",
        "\n",
        "        self.play(Restore(frame))\n",
        "\n",
        "        # Student asks about what the function is.\n",
        "        self.student_says(\n",
        "            OldTexText(\"Wait, what is that\\\\\\\\function exactly?\"),\n",
        "            look_at=image1,\n",
        "            index=2,\n",
        "            added_anims=[\n",
        "                self.students[0].change(\"confused\", image1),\n",
        "                self.students[1].change(\"confused\", image1),\n",
        "            ]\n",
        "        )\n",
        "        self.play(self.teacher.change(\"tease\"))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.students[0].change(\"maybe\", image1),\n",
        "        )\n",
        "        self.play(\n",
        "            self.students[1].change(\"erm\", image1),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Just some\\\\\\\\polynomial\"),\n",
        "            bubble_config={\n",
        "                \"width\": 4,\n",
        "                \"height\": 3,\n",
        "            },\n",
        "            added_anims=[self.change_students(\"confused\", \"maybe\", \"pondering\")]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(image1)\n",
        "        self.play(\n",
        "            frame.animate.replace(image1),\n",
        "            RemovePiCreatureBubble(self.teacher),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Image 2\n",
        "        self.remove(image1)\n",
        "        self.add(image2)\n",
        "        self.play(Restore(frame))\n",
        "\n",
        "        self.play_all_student_changes(\n",
        "            \"confused\",\n",
        "            look_at=image1,\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            OldTex(\"P(x) = 0\"),\n",
        "            target_mode=\"tease\",\n",
        "            bubble_config={\n",
        "                \"width\": 3,\n",
        "                \"height\": 3,\n",
        "            }\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"raise_right_hand\", look_at=image1),\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=image1,\n",
        "            ),\n",
        "            FadeOut(image2),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class ShowManyGraphs(Scene):\n",
        "    def construct(self):\n",
        "        # Add plots\n",
        "        root_groups = [\n",
        "            (-2, 6),\n",
        "            (-5, 0, 3),\n",
        "            (-7, -2, 3, 8),\n",
        "            (-5, 1, 5, complex(0, 1), complex(0, -1)),\n",
        "        ]\n",
        "        coef_groups = list(map(roots_to_coefficients, root_groups))\n",
        "        scalars = [0.5, 0.2, 0.01, -0.01]\n",
        "        colors = [BLUE_C, BLUE_D, BLUE_B, RED]\n",
        "        plots = Group(*(\n",
        "            self.get_plot(coefs, scalar, color)\n",
        "            for coefs, scalar, color in zip(coef_groups, scalars, colors)\n",
        "        ))\n",
        "        plots.arrange_in_grid(v_buff=0.5)\n",
        "        axes, graphs, root_dots = [\n",
        "            Group(*(plot[i] for plot in plots))\n",
        "            for i in range(3)\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, axes, lag_ratio=0.3),\n",
        "            LaggedStartMap(ShowCreation, graphs, lag_ratio=0.3),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeIn(dot, scale=0.1)\n",
        "                for dot in it.chain(*root_dots)\n",
        "            ), lag_ratio=0.1)\n",
        "        )\n",
        "\n",
        "        self.add(plots)\n",
        "        self.wait()\n",
        "\n",
        "        quadratic, cubic, quartic, quintic = plots\n",
        "        for plot in plots:\n",
        "            plot.save_state()\n",
        "\n",
        "        # Show quadratic\n",
        "        kw = {\"tex_to_color_map\": {\n",
        "            \"{a}\": BLUE_B,\n",
        "            \"{b}\": BLUE_C,\n",
        "            \"{c}\": BLUE_D,\n",
        "            \"{d}\": TEAL_E,\n",
        "            \"{e}\": TEAL_D,\n",
        "            \"{f}\": TEAL_C,\n",
        "            \"{p}\": BLUE_B,\n",
        "            \"{q}\": BLUE_C,\n",
        "            \"\\\\text{root}\": YELLOW,\n",
        "            \"r_1\": YELLOW,\n",
        "            \"r_2\": YELLOW,\n",
        "            \"+\": WHITE,\n",
        "            \"-\": WHITE,\n",
        "        }}\n",
        "        quadratic.generate_target()\n",
        "        quadratic.target.set_height(6)\n",
        "        quadratic.target.center().to_edge(LEFT)\n",
        "        equation = OldTex(\"{a}x^2 + {b}x + {c} = 0\", **kw)\n",
        "        equation.next_to(quadratic.target, UP)\n",
        "        form = OldTex(\n",
        "            \"r_1, r_2 = {-{b} \\\\pm \\\\sqrt{\\\\,{b}^2 - 4{a}{c}} \\\\over 2{a}}\",\n",
        "            **kw\n",
        "        )\n",
        "        form.next_to(quadratic.target, RIGHT, buff=MED_LARGE_BUFF)\n",
        "        form_name = Text(\"Quadratic formula\")\n",
        "        form_name.match_width(form)\n",
        "        form_name.next_to(form, UP, LARGE_BUFF)\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.flip()\n",
        "        randy.next_to(form, RIGHT)\n",
        "        randy.align_to(quadratic.target, DOWN)\n",
        "        randy.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(quadratic),\n",
        "            Write(equation),\n",
        "            *map(FadeOut, plots[1:]),\n",
        "            FadeIn(randy),\n",
        "        )\n",
        "        self.play(randy.change(\"hooray\"))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(*(\n",
        "                    equation.get_part_by_tex(f\"{{{c}}}\")\n",
        "                    for c in \"abc\"\n",
        "                )).copy(),\n",
        "                form,\n",
        "                lag_ratio=0,\n",
        "                run_time=2,\n",
        "            ),\n",
        "            randy.animate.look_at(form),\n",
        "            FadeIn(form_name),\n",
        "            FlashAround(form_name),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Coco sidenote\n",
        "        form_group = VGroup(form_name, form)\n",
        "        form_group.save_state()\n",
        "        form_group.set_stroke(BLACK, 5, background=True)\n",
        "        plot_group = Group(quadratic, equation)\n",
        "        plot_group.save_state()\n",
        "\n",
        "        self.play(\n",
        "            plot_group.animate.shift(4 * LEFT).set_opacity(0),\n",
        "            form_group.animate.to_corner(UR),\n",
        "            FadeOut(randy),\n",
        "        )\n",
        "\n",
        "        pixar_image = ImageMobject(\"PixarCampus\")\n",
        "        pixar_image.set_height(FRAME_HEIGHT + 4)\n",
        "        pixar_image.to_corner(UL, buff=0)\n",
        "        pixar_image.shift(LEFT)\n",
        "        pixar_image.add_updater(lambda m, dt: m.shift(0.1 * dt * LEFT))\n",
        "\n",
        "        coco_logo = ImageMobject(\"Coco_logo\")\n",
        "        coco_logo.set_width(4)\n",
        "        coco_logo.match_y(form)\n",
        "        coco_logo.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        arrow = Arrow(form.copy().to_edge(LEFT), coco_logo, buff=0.3, stroke_width=10)\n",
        "\n",
        "        self.add(pixar_image, *self.mobjects)\n",
        "        self.play(FadeIn(pixar_image))\n",
        "        self.wait(6)\n",
        "        self.add(coco_logo, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeOut(pixar_image),\n",
        "            form_group.animate.to_corner(UL),\n",
        "            FadeIn(randy),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(coco_logo),\n",
        "        )\n",
        "\n",
        "        over_trillion = OldTex(\"> 1{,}000{,}000{,}000{,}000\")[0]\n",
        "        over_trillion.next_to(form, RIGHT)\n",
        "        over_trillion.shift(3 * DOWN)\n",
        "        form_copies = form[4:].replicate(50)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(over_trillion, run_time=1),\n",
        "            randy.change(\"thinking\", over_trillion),\n",
        "            LaggedStart(*(\n",
        "                FadeOut(form_copy, 4 * DOWN)\n",
        "                for form_copy in form_copies\n",
        "            ), lag_ratio=0.15, run_time=5)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(over_trillion),\n",
        "            FadeOut(coco_logo),\n",
        "            FadeOut(arrow),\n",
        "            randy.change(\"happy\"),\n",
        "            Restore(form_group),\n",
        "            Restore(plot_group),\n",
        "        )\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "        # Cubic\n",
        "        low_fade_rect = BackgroundRectangle(\n",
        "            Group(quartic, quintic),\n",
        "            buff=0.01,\n",
        "            fill_opacity=0.95,\n",
        "        )\n",
        "        cubic_eq = OldTex(\"x^3 + {p}x + {q} = 0\", **kw)\n",
        "        cubic_eq.next_to(cubic, LEFT, LARGE_BUFF, aligned_edge=UP)\n",
        "        cubic_eq.shift_onto_screen()\n",
        "        cubic_name = OldTexText(\"Cubic\\\\\\\\\", \"Formula\")\n",
        "        cubic_name.to_corner(UL)\n",
        "        cubic_form = OldTex(\n",
        "            \"\\\\text{root}\", \"=\",\n",
        "            \"\\\\sqrt[3]{\\\\,-{{q} \\\\over 2} + \\\\sqrt{\\\\, {{q}^2 \\\\over 4} + {{p}^3 \\\\over 27}} }+\",\n",
        "            \"\\\\sqrt[3]{\\\\,-{{q} \\\\over 2} - \\\\sqrt{\\\\, {{q}^2 \\\\over 4} + {{p}^3 \\\\over 27}} }\",\n",
        "            **kw,\n",
        "        )\n",
        "        cubic_form.set_width(7)\n",
        "        cubic_form.next_to(cubic_eq, DOWN, buff=1.25)\n",
        "        cubic_form.to_edge(LEFT)\n",
        "        cubic_arrow = Arrow(\n",
        "            cubic_eq, cubic_form,\n",
        "            stroke_width=5,\n",
        "            buff=0.1,\n",
        "        )\n",
        "\n",
        "        self.add(*plots, randy)\n",
        "        self.play(\n",
        "            Restore(quadratic),\n",
        "            *map(FadeIn, plots[1:]),\n",
        "            FadeOut(form),\n",
        "            FadeOut(form_name),\n",
        "            FadeOut(equation),\n",
        "            randy.change(\"plain\"),\n",
        "        )\n",
        "        self.play(randy.change(\"erm\", cubic))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(quadratic),\n",
        "            FadeIn(low_fade_rect),\n",
        "            Write(cubic_eq),\n",
        "            FadeIn(cubic_name),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(cubic_arrow),\n",
        "            FadeIn(cubic_form, DOWN),\n",
        "            randy.change(\"confused\", cubic_name),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        # Quartic\n",
        "        quartic_name = OldTexText(\"Quartic \", \"Formula\")\n",
        "        quartic_name.move_to(quartic).to_edge(UP)\n",
        "        cubic_fade_rect = BackgroundRectangle(cubic, buff=0.01, fill_opacity=0.95)\n",
        "        quartic_eq = OldTex(\"{a}x^4 + {b}x^3 + {c}x^2 + {d}x + {e} = 0\", **kw)\n",
        "        quartic_eq.next_to(quartic, UP)\n",
        "\n",
        "        main_form = OldTex(r\"r_{i}&=-\\frac{b}{4 a}-S \\pm \\frac{1}{2} \\sqrt{-4 S^{2}-2 p \\pm \\frac{q}{S}}\")\n",
        "        details = OldTex(r\"\"\"\n",
        "            &\\text{Where}\\\\\\\\\n",
        "            p&=\\frac{8 a c-3 b^{2}}{8 a^{2}} \\qquad \\qquad\\\\\\\\\n",
        "            q&=\\frac{b^{3}-4 a b c+8 a^{2} d}{8 a^{3}}\\\\\\\\\n",
        "            S&=\\frac{1}{2} \\sqrt{-\\frac{2}{3} p+\\frac{1}{3 a}\\left(Q+\\frac{\\Delta_{0}}{Q}\\right)}\\\\\\\\\n",
        "            Q&=\\sqrt[3]{\\frac{\\Delta_{1}+\\sqrt{\\Delta_{1}^{2}-4 \\Delta_{0}^{3}}}{2}}\\\\\\\\\n",
        "            \\Delta_{0}&=c^{2}-3 b d+12 a e\\\\\\\\\n",
        "            \\Delta_{1}&=2 c^{3}-9 b c d+27 b^{2} e+27 a d^{2}-72 a c e\\\\\\\\\n",
        "        \"\"\")\n",
        "        main_form.match_width(quartic_eq)\n",
        "        main_form.move_to(VGroup(quartic_name, quartic_eq))\n",
        "        details.scale(0.5)\n",
        "        details.to_corner(UR)\n",
        "        details.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(cubic_eq),\n",
        "            FadeOut(cubic_form),\n",
        "            FadeOut(cubic_arrow),\n",
        "            FadeIn(cubic_fade_rect),\n",
        "            FadeTransform(cubic_name[0], quartic_name[0]),\n",
        "            FadeTransform(cubic_name[1], quartic_name[1]),\n",
        "            randy.change(\"erm\", quartic_name),\n",
        "            low_fade_rect.animate.replace(quintic, stretch=True).scale(1.01),\n",
        "            FadeIn(quartic_eq),\n",
        "        )\n",
        "        self.play(Write(main_form))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change(\"horrified\", details),\n",
        "            Write(details, run_time=5)\n",
        "        )\n",
        "        self.play(randy.animate.look_at(details.get_bottom()))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Quintic\n",
        "        quintic.generate_target()\n",
        "        quintic.target.set_height(5)\n",
        "        quintic.target.to_corner(UL).shift(DOWN)\n",
        "        quintic_eq = OldTex(\n",
        "            \"{a}x^5 + {b}x^4 + {c}x^3 + {d}x^2 + {e}x + {f}\",\n",
        "            **kw\n",
        "        )\n",
        "        quintic_eq.match_width(quintic.target)\n",
        "        quintic_eq.next_to(quintic.target, UP)\n",
        "        quintic_name = Text(\"Quintic formula?\", font_size=60)\n",
        "        quintic_name.move_to(3 * RIGHT)\n",
        "        quintic_name.to_edge(UP)\n",
        "\n",
        "        subwords = VGroup(\n",
        "            OldTexText(\"There is none.\", \"$^*$\"),\n",
        "            OldTexText(\"And there never can be.\"),\n",
        "        )\n",
        "\n",
        "        subwords.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        subwords.next_to(quintic_name, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        footnote = OldTex(\n",
        "            \"^*\\\\text{Using }\",\n",
        "            \"+,\\\\,\",\n",
        "            \"-,\\\\,\",\n",
        "            \"\\\\times,\\\\,\",\n",
        "            \"/,\\\\,\",\n",
        "            \"\\\\sqrt[n]{\\\\quad},\\\\,\",\n",
        "            \"\\\\text{exp},\\\\,\",\n",
        "            \"\\\\log,\\\\,\",\n",
        "            \"\\\\sin,\\\\,\",\n",
        "            \"\\\\cos,\\\\,\",\n",
        "            \"etc.\\\\\\\\\",\n",
        "            font_size=36,\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        footnote.set_color(GREY_A)\n",
        "        footnote.next_to(subwords, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        footnote.shift_onto_screen(buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(cubic),\n",
        "            FadeOut(quartic),\n",
        "            FadeOut(quartic_eq),\n",
        "            FadeOut(main_form),\n",
        "            FadeOut(details),\n",
        "            FadeTransform(quartic_name, quintic_name),\n",
        "            MoveToTarget(quintic),\n",
        "            UpdateFromFunc(\n",
        "                low_fade_rect,\n",
        "                lambda m: m.replace(quintic, stretch=True),\n",
        "            ),\n",
        "            VFadeOut(low_fade_rect),\n",
        "            randy.change(\"tease\", quintic_name),\n",
        "            FadeIn(quintic_eq),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(subwords[0][0], 0.5 * DOWN),\n",
        "            randy.change(\"erm\", subwords),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(subwords[1], 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(subwords[0][1]),\n",
        "            LaggedStartMap(FadeIn, footnote, run_time=6, lag_ratio=0.5),\n",
        "            randy.change(\"pondering\", footnote)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    def get_plot(self, coefs, scalar=1.0, color=YELLOW, stroke_width=3, height=3.5, bound=10):\n",
        "        axes = NumberPlane(\n",
        "            (-bound, bound, 5), (-bound, bound, 5),\n",
        "            faded_line_ratio=4,\n",
        "            background_line_style={\n",
        "                \"stroke_width\": 1.0,\n",
        "                \"stroke_color\": GREY_A,\n",
        "            }\n",
        "        )\n",
        "        axes.set_height(height)\n",
        "        axes.add_coordinate_labels(\n",
        "            x_values=[-5, 0, 5, 10],\n",
        "            y_values=[-5, 5, 10],\n",
        "            font_size=16,\n",
        "            excluding=[],\n",
        "        )\n",
        "\n",
        "        def f(x):\n",
        "            return scalar * poly(x, coefs)\n",
        "\n",
        "        x_min = binary_search(\n",
        "            lambda x: abs(f(x)), bound, -bound, 0\n",
        "        )\n",
        "        x_max = binary_search(\n",
        "            lambda x: abs(f(x)), bound, 0, bound,\n",
        "        )\n",
        "\n",
        "        graph = axes.get_graph(f, x_range=(x_min, x_max))\n",
        "        graph.set_stroke(color, stroke_width)\n",
        "\n",
        "        roots = [\n",
        "            root.real\n",
        "            for root in coefficients_to_roots(coefs)\n",
        "            if np.isclose(root.imag, 0)\n",
        "        ]\n",
        "\n",
        "        def get_glow_dot(point):\n",
        "            result = DotCloud([point] * 10)\n",
        "            result.set_radii([\n",
        "                interpolate(0.03, 0.06, t**2)\n",
        "                for t in np.linspace(0, 1, 10)\n",
        "            ])\n",
        "            result.set_opacity(0.2)\n",
        "            result.set_color(YELLOW)\n",
        "            return result\n",
        "\n",
        "        root_dots = Group(*(\n",
        "            get_glow_dot(axes.c2p(root, 0))\n",
        "            for root in roots\n",
        "        ))\n",
        "\n",
        "        result = Group(axes, graph, root_dots)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ComingVideoWrapper(VideoWrapper):\n",
        "    animate_boundary = False\n",
        "    title = \"Unsolvability of the Quintic (future topic?)\"\n",
        "\n",
        "\n",
        "class QuinticAppletPlay(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AskAboutFractals(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.screen.set_height(4, about_edge=UL)\n",
        "        self.screen.set_fill(BLACK, 1)\n",
        "        self.add(self.screen)\n",
        "        self.student_says(\n",
        "            \"Fractals?\",\n",
        "            target_mode=\"raise_right_hand\",\n",
        "            index=2,\n",
        "            added_anims=[\n",
        "                self.students[0].change(\"confused\"),\n",
        "                self.students[1].change(\"sassy\"),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"We're getting\\\\\\\\there\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            },\n",
        "            target_mode=\"happy\"\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class RealNewtonsMethod(Scene):\n",
        "    coefs = [-0.2, -1, 1, 0, 0, 1]\n",
        "    poly_tex = \"x^5 + x^2 - x - 0.2\"\n",
        "    dpoly_tex = \"5x^4 + 2x - 1\"\n",
        "    seed = 1.3\n",
        "    graph_x_range = (-1.5, 1.5)\n",
        "    axes_config = {\n",
        "        \"x_range\": (-2, 2, 0.2),\n",
        "        \"y_range\": (-2, 6, 0.2),\n",
        "        \"height\": 8,\n",
        "        \"width\": 8,\n",
        "        \"axis_config\": {\n",
        "            \"tick_size\": 0.05,\n",
        "            \"longer_tick_multiple\": 2.0,\n",
        "            \"tick_offset\": 0,\n",
        "            # Change name\n",
        "            \"big_tick_numbers\": list(range(-2, 3)),\n",
        "            \"include_tip\": False,\n",
        "        }\n",
        "    }\n",
        "    graph_color = BLUE_C\n",
        "    guess_color = YELLOW\n",
        "    rule_font_size = 42\n",
        "    n_search_steps = 5\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.add_title(self.axes)\n",
        "        self.draw_graph()\n",
        "        self.highlight_roots()\n",
        "        self.preview_iterative_root_finding()\n",
        "        self.introduce_step()\n",
        "        self.find_root()\n",
        "\n",
        "    def add_graph(self):\n",
        "        axes = self.axes = Axes(**self.axes_config)\n",
        "        axes.to_edge(RIGHT)\n",
        "        axes.add_coordinate_labels(\n",
        "            np.arange(*self.axes.x_range[:2]),\n",
        "            np.arange(self.axes.y_range[0] + 1, self.axes.y_range[1]),\n",
        "        )\n",
        "        self.add(axes)\n",
        "\n",
        "        graph = self.graph = axes.get_graph(\n",
        "            lambda x: poly(x, self.coefs),\n",
        "            x_range=self.graph_x_range,\n",
        "        )\n",
        "        graph.set_color(self.graph_color)\n",
        "\n",
        "        self.add(graph)\n",
        "\n",
        "    def add_title(self, axes, opacity=0):\n",
        "        title = OldTexText(\"Newton's method\", font_size=60)\n",
        "        title.move_to(midpoint(axes.get_left(), LEFT_SIDE))\n",
        "        title.to_edge(UP)\n",
        "        title.set_opacity(opacity)\n",
        "\n",
        "        poly = OldTex(f\"P({self.poly_tex[0]}) = \", self.poly_tex, \"= 0 \")\n",
        "        poly.match_width(title)\n",
        "        poly.next_to(title, DOWN, buff=MED_LARGE_BUFF)\n",
        "        poly.set_fill(GREY_A)\n",
        "        title.add(poly)\n",
        "\n",
        "        self.title = title\n",
        "        self.poly = poly\n",
        "        self.add(title)\n",
        "\n",
        "    def draw_graph(self):\n",
        "        rect = SurroundingRectangle(self.poly[:-1])\n",
        "        rect.set_stroke(self.graph_color, 2)\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(self.poly[:-1], color=self.graph_color, run_time=2),\n",
        "            ShowCreation(rect, run_time=2),\n",
        "            ShowCreation(self.graph, run_time=4),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.replace(self.poly[-1], stretch=True).scale(1.2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "    def highlight_roots(self):\n",
        "        roots = coefficients_to_roots(self.coefs)\n",
        "        real_roots = [\n",
        "            root.real for root in roots\n",
        "            if abs(root.imag) < 1e-6\n",
        "        ]\n",
        "        real_roots.sort()\n",
        "\n",
        "        dots = VGroup(*(\n",
        "            # Dot(self.axes.c2p(r, 0), radius=0.05)\n",
        "            glow_dot(self.axes.c2p(r, 0))\n",
        "            for r in real_roots\n",
        "        ))\n",
        "        squares = VGroup(*[\n",
        "            Square().set_height(0.25).move_to(dot)\n",
        "            for dot in dots\n",
        "        ])\n",
        "        squares.set_stroke(YELLOW, 3)\n",
        "        squares.set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    FadeIn(dot, scale=0.1)\n",
        "                    for dot in dots\n",
        "                ] + [\n",
        "                    VShowPassingFlash(square, time_width=2.0, run_time=2)\n",
        "                    for square in squares\n",
        "                ],\n",
        "                lag_ratio=0.15\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show values numerically\n",
        "        root_strs = [\"{0:.4}\".format(root) for root in real_roots]\n",
        "        equations = VGroup(*(\n",
        "            OldTex(\n",
        "                \"P(\", root_str, \")\", \"=\", \"0\",\n",
        "                font_size=self.rule_font_size\n",
        "            ).set_color_by_tex(root_str, YELLOW)\n",
        "            for root_str in root_strs\n",
        "        ))\n",
        "        equations.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        equations.next_to(self.poly, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        question = Text(\"How do you\\ncompute these?\")\n",
        "        question.next_to(equations, RIGHT, buff=LARGE_BUFF)\n",
        "        question.set_color(YELLOW)\n",
        "\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(\n",
        "                question.get_corner(UL) + 0.2 * DL,\n",
        "                eq[1].get_corner(UR) + 0.25 * LEFT,\n",
        "                path_arc=arc, stroke_width=3,\n",
        "                buff=0.2,\n",
        "            )\n",
        "            for eq, arc in zip(equations, [0.7 * PI, 0.5 * PI, 0.0 * PI])\n",
        "        ))\n",
        "        arrows.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, equations, lag_ratio=0.25),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(dot.copy(), eq[1])\n",
        "                for dot, eq in zip(dots, equations)\n",
        "            ), lag_ratio=0.25)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            Write(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(dots),\n",
        "            FadeOut(question),\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(equations),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def preview_iterative_root_finding(self):\n",
        "        axes = self.axes\n",
        "        axis = axes.x_axis\n",
        "        coefs = self.coefs\n",
        "        n_steps = 5\n",
        "\n",
        "        root_seekers = VGroup(*(\n",
        "            ArrowTip().set_height(0.2).rotate(-PI / 2).move_to(axis.n2p(x), DOWN)\n",
        "            for x in np.arange(-2, 2.0, 0.2)[:-1]\n",
        "        ))\n",
        "        root_seekers.set_stroke(YELLOW, 2, opacity=0.5)\n",
        "        root_seekers.set_fill(YELLOW, opacity=0.3)\n",
        "\n",
        "        words = Text(\"Approximate\\nSolutions\", alignment=\"\\\\flushleft\")\n",
        "        words.move_to(axes.c2p(0, 3))\n",
        "        words.align_to(axis, LEFT)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(root_seekers, lag_ratio=0.1),\n",
        "            Write(words),\n",
        "        )\n",
        "\n",
        "        for n in range(n_steps):\n",
        "            for rs in root_seekers:\n",
        "                rs.generate_target()\n",
        "                x = axis.p2n(rs.get_center())\n",
        "                if n == 0 and abs(x - 0.4) < 0.1:\n",
        "                    x = 0.6\n",
        "                new_x = x - poly(x, coefs) / dpoly(x, coefs)\n",
        "                rs.target.set_x(axis.n2p(new_x)[0])\n",
        "            self.play(*map(MoveToTarget, root_seekers), run_time=1.0)\n",
        "        self.wait()\n",
        "\n",
        "        values = VGroup(*(\n",
        "            DecimalNumber(\n",
        "                axis.p2n(rs.get_center()),\n",
        "                num_decimal_places=5,\n",
        "                show_ellipsis=True,\n",
        "            ).next_to(rs, UP, SMALL_BUFF)\n",
        "            for rs in root_seekers[0::len(root_seekers) // 2]\n",
        "        ))\n",
        "        values.set_fill(YELLOW)\n",
        "        values.set_stroke(BLACK, 8, background=True)\n",
        "        last_value = VMobject()\n",
        "        for value in values:\n",
        "            self.play(\n",
        "                FadeIn(value),\n",
        "                FadeOut(last_value)\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            last_value = value\n",
        "        self.play(FadeOut(last_value))\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(root_seekers),\n",
        "        )\n",
        "\n",
        "    def introduce_step(self):\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "\n",
        "        # Add labels\n",
        "        guess_label = OldTex(\n",
        "            \"\\\\text{Guess: } x_0 = \" + f\"{self.seed}\",\n",
        "            tex_to_color_map={\"x_0\": YELLOW}\n",
        "        )\n",
        "        guess_label.next_to(self.poly, DOWN, LARGE_BUFF)\n",
        "        guess_marker, guess_value, guess_tracker = self.get_guess_group()\n",
        "        get_guess = guess_tracker.get_value\n",
        "\n",
        "        self.play(self.title.animate.set_opacity(1))\n",
        "        self.wait()\n",
        "        self.play(Write(guess_label))\n",
        "        self.play(\n",
        "            FadeTransform(\n",
        "                guess_label[1].copy(),\n",
        "                VGroup(guess_marker, guess_value)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add lines\n",
        "        v_line = axes.get_v_line(axes.i2gp(get_guess(), graph))\n",
        "        tan_line = self.get_tan_line(get_guess())\n",
        "\n",
        "        v_line_label = OldTex(\"P(x_0)\", font_size=30, fill_color=GREY_A)\n",
        "        v_line_label.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(v_line, guess_marker, guess_value)\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(FadeIn(v_line_label, 0.2 * RIGHT))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(tan_line),\n",
        "            graph.animate.set_stroke(width=2),\n",
        "        )\n",
        "\n",
        "        # Mention next guess\n",
        "        next_guess_label = Text(\"Next guess\", font_size=30)\n",
        "        next_guess_label.set_color(RED)\n",
        "        next_guess_label.next_to(axes.c2p(0, 0), RIGHT, MED_LARGE_BUFF)\n",
        "        next_guess_label.shift(UP)\n",
        "        next_guess_arrow = Arrow(next_guess_label, tan_line.get_start(), buff=0.1)\n",
        "        next_guess_arrow.set_stroke(RED, 3)\n",
        "\n",
        "        coord = axes.coordinate_labels[0][-1]\n",
        "        coord_copy = coord.copy()\n",
        "        coord.set_opacity(0)\n",
        "        self.play(\n",
        "            coord_copy.animate.scale(0),\n",
        "            ShowCreation(next_guess_arrow),\n",
        "            FadeIn(next_guess_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show derivative\n",
        "        dpoly = OldTex(\"P'(x) = \", self.dpoly_tex)\n",
        "        dpoly.match_height(self.poly)\n",
        "        dpoly.match_style(self.poly)\n",
        "        dpoly.next_to(self.poly, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dpoly, 0.5 * DOWN),\n",
        "            guess_label.animate.shift(0.25 * DOWN)\n",
        "        )\n",
        "        self.play(FlashAround(dpoly))\n",
        "        self.wait()\n",
        "\n",
        "        # Show step\n",
        "        step_arrow = Arrow(v_line.get_start(), tan_line.get_start(), buff=0)\n",
        "        step_arrow.set_stroke(GREY_A, 3)\n",
        "        step_arrow.shift(0.1 * UP)\n",
        "        step_word = Text(\"Step\", font_size=24)\n",
        "        step_word.set_stroke(BLACK, 3, background=True)\n",
        "        step_word.next_to(step_arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(step_arrow),\n",
        "            FadeIn(step_word)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show slope\n",
        "        slope_eq_texs = [\n",
        "            \"P'(x_0) = {P(x_0) \\\\over -\\\\text{Step}}\",\n",
        "            \"\\\\text{Step} = -{P(x_0) \\\\over P'(x_0)}\",\n",
        "        ]\n",
        "        slope_eqs = [\n",
        "            OldTex(\n",
        "                tex,\n",
        "                isolate=[\n",
        "                    \"P'(x_0)\",\n",
        "                    \"P(x_0)\",\n",
        "                    \"\\\\text{Step}\",\n",
        "                    \"-\"\n",
        "                ],\n",
        "                font_size=self.rule_font_size,\n",
        "            )\n",
        "            for tex in slope_eq_texs\n",
        "        ]\n",
        "        for slope_eq in slope_eqs:\n",
        "            slope_eq.set_fill(GREY_A)\n",
        "            slope_eq.set_color_by_tex(\"Step\", WHITE)\n",
        "            slope_eq.next_to(guess_label, DOWN, LARGE_BUFF)\n",
        "\n",
        "        rule = self.rule = self.get_update_rule()\n",
        "        rule.next_to(guess_label, DOWN, LARGE_BUFF)\n",
        "\n",
        "        for line in [v_line, Line(tan_line.get_start(), v_line.get_start())]:\n",
        "            self.play(\n",
        "                VShowPassingFlash(\n",
        "                    Line(line.get_start(), line.get_end()).set_stroke(YELLOW, 10).insert_n_curves(20),\n",
        "                    time_width=1.0,\n",
        "                    run_time=1.5\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(v_line_label.copy(), slope_eqs[0].get_part_by_tex(\"P(x_0)\")),\n",
        "            FadeTransform(step_word.copy(), slope_eqs[0].get_part_by_tex(\"\\\\text{Step}\")),\n",
        "            FadeIn(slope_eqs[0][3:5]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(slope_eqs[0][:2]))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(*slope_eqs, path_arc=PI / 2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rule),\n",
        "            slope_eqs[1].animate.to_edge(DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to x1\n",
        "        self.add(tan_line, guess_value)\n",
        "        self.play(\n",
        "            FadeOut(next_guess_label),\n",
        "            FadeOut(next_guess_arrow),\n",
        "            FadeOut(step_word),\n",
        "            FadeOut(step_arrow),\n",
        "            FadeOut(v_line),\n",
        "            FadeOut(v_line_label),\n",
        "            guess_tracker.animate.set_value(self.get_next_guess(get_guess())),\n",
        "        )\n",
        "        self.play(FadeOut(tan_line))\n",
        "\n",
        "    def find_root(self, cycle_run_time=1.0):\n",
        "        for n in range(self.n_search_steps):\n",
        "            self.play(*self.cycle_rule_entries_anims(), run_time=cycle_run_time)\n",
        "            self.step_towards_root()\n",
        "\n",
        "    def step_towards_root(self, fade_tan_with_vline=False, added_anims=None):\n",
        "        guess = self.guess_tracker.get_value()\n",
        "        next_guess = self.get_next_guess(guess)\n",
        "\n",
        "        v_line = self.axes.get_v_line(self.axes.i2gp(guess, self.graph))\n",
        "        tan_line = self.get_tan_line(guess)\n",
        "\n",
        "        self.add(v_line, tan_line, self.guess_marker, self.guess_value)\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            GrowFromCenter(tan_line)\n",
        "        )\n",
        "        anims = [\n",
        "            FadeOut(v_line),\n",
        "            self.guess_tracker.animate.set_value(next_guess)\n",
        "        ]\n",
        "        if added_anims is not None:\n",
        "            anims += added_anims\n",
        "        tan_fade = FadeOut(tan_line)\n",
        "        if fade_tan_with_vline:\n",
        "            self.play(*anims, tan_fade)\n",
        "        else:\n",
        "            self.play(*anims)\n",
        "            self.play(tan_fade)\n",
        "\n",
        "    #\n",
        "    def get_guess_group(self):\n",
        "        axes = self.axes\n",
        "        guess_tracker = ValueTracker(self.seed)\n",
        "        get_guess = guess_tracker.get_value\n",
        "\n",
        "        guess_marker = Triangle(start_angle=PI / 2)\n",
        "        guess_marker.set_height(0.1)\n",
        "        guess_marker.set_width(0.1, stretch=True)\n",
        "        guess_marker.set_fill(self.guess_color, 1)\n",
        "        guess_marker.set_stroke(width=0)\n",
        "        guess_marker.add_updater(lambda m: m.move_to(\n",
        "            axes.c2p(get_guess(), 0), UP\n",
        "        ))\n",
        "        guess_value = DecimalNumber(0, num_decimal_places=3, font_size=24)\n",
        "\n",
        "        def update_guess_value(gv):\n",
        "            gv.set_value(get_guess())\n",
        "            gv.next_to(guess_marker, DOWN, SMALL_BUFF)\n",
        "            gv.set_fill(self.guess_color)\n",
        "            gv.set_stroke(BLACK, 3, background=True)\n",
        "            return gv\n",
        "\n",
        "        guess_value.add_updater(update_guess_value)\n",
        "\n",
        "        self.guess_tracker = guess_tracker\n",
        "        self.guess_marker = guess_marker\n",
        "        self.guess_value = guess_value\n",
        "\n",
        "        return (guess_marker, guess_value, guess_tracker)\n",
        "\n",
        "    def get_next_guess(self, curr_guess):\n",
        "        x = curr_guess\n",
        "        return x - poly(x, self.coefs) / dpoly(x, self.coefs)\n",
        "\n",
        "    def get_tan_line(self, curr_guess):\n",
        "        next_guess = self.get_next_guess(curr_guess)\n",
        "        start = self.axes.c2p(next_guess, 0)\n",
        "        end = self.axes.i2gp(curr_guess, self.graph)\n",
        "        line = Line(start, start + 2 * (end - start))\n",
        "        line.set_stroke(RED, 3)\n",
        "        return line\n",
        "\n",
        "    def get_update_rule(self, char=\"x\"):\n",
        "        rule = OldTex(\n",
        "            \"\"\"\n",
        "                z_1 =\n",
        "                z_0 - {P(z_0) \\\\over P'(z_0)}\n",
        "            \"\"\".replace(\"z\", char),\n",
        "            tex_to_color_map={\n",
        "                f\"{char}_1\": self.guess_color,\n",
        "                f\"{char}_0\": self.guess_color\n",
        "            },\n",
        "            font_size=self.rule_font_size,\n",
        "        )\n",
        "\n",
        "        rule.n = 0\n",
        "        rule.zns = rule.get_parts_by_tex(f\"{char}_0\")\n",
        "        rule.znp1 = rule.get_parts_by_tex(f\"{char}_1\")\n",
        "        return rule\n",
        "\n",
        "    def cycle_rule_entries_anims(self):\n",
        "        rule = self.rule\n",
        "        rule.n += 1\n",
        "        char = rule.get_tex().strip()[0]\n",
        "        zns = VGroup()\n",
        "        for old_zn in rule.zns:\n",
        "            zn = OldTex(f\"{char}_{{{rule.n}}}\", font_size=self.rule_font_size)\n",
        "            zn[0][1:].set_max_width(0.2, about_edge=DL)\n",
        "            zn.move_to(old_zn)\n",
        "            zn.match_color(old_zn)\n",
        "            zns.add(zn)\n",
        "        znp1 = OldTex(f\"{char}_{{{rule.n + 1}}}\", font_size=self.rule_font_size)\n",
        "        znp1.move_to(rule.znp1)\n",
        "        znp1.match_color(rule.znp1[0])\n",
        "\n",
        "        result = (\n",
        "            FadeOut(rule.zns),\n",
        "            FadeTransformPieces(rule.znp1, zns),\n",
        "            FadeIn(znp1, 0.5 * RIGHT)\n",
        "        )\n",
        "        rule.zns = zns\n",
        "        rule.znp1 = znp1\n",
        "        return result\n",
        "\n",
        "\n",
        "class FasterNewtonExample(RealNewtonsMethod):\n",
        "    coefs = [0.1440, -1.0, 1.2, 1]\n",
        "    poly_tex = \"x^3 + 1.2x^2 - x + 0.144\"\n",
        "    dpoly_tex = \"3x^2 + 2.4x - 1\"\n",
        "    n_search_steps = 6\n",
        "    graph_x_range = (-2, 2)\n",
        "    seed = 1.18\n",
        "    axes_config = {\n",
        "        \"x_range\": (-2, 2, 0.2),\n",
        "        \"y_range\": (-1, 3, 0.2),\n",
        "        \"height\": 8,\n",
        "        \"width\": 8,\n",
        "        \"axis_config\": {\n",
        "            \"tick_size\": 0.05,\n",
        "            \"longer_tick_multiple\": 2.0,\n",
        "            \"tick_offset\": 0,\n",
        "            # Change name\n",
        "            \"big_tick_numbers\": list(range(-2, 3)),\n",
        "            \"include_tip\": False,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.add_title(self.axes)\n",
        "        self.draw_graph()\n",
        "        self.introduce_step()\n",
        "        self.find_root()\n",
        "\n",
        "    def find_root(self, cycle_run_time=1.0):\n",
        "        for n in range(self.n_search_steps):\n",
        "            self.step_towards_root(\n",
        "                added_anims=self.cycle_rule_entries_anims(),\n",
        "                fade_tan_with_vline=True\n",
        "            )\n",
        "\n",
        "\n",
        "class AssumingItsGood(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.pi_creatures.refresh_triangulation()\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Assuming this\\\\\\\\approximation\\\\\\\\is decent...\", font_size=42),\n",
        "            bubble_config={\n",
        "                \"height\": 3, \"width\": 4,\n",
        "            }\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"pondering\", \"tease\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.pi_creatures.refresh_triangulation()\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class PauseAndPonder(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Pause and\\nponder\", target_mode=\"hooray\")\n",
        "        self.play_all_student_changes(\"thinking\", look_at=self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class AltPauseAndPonder(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.flip().to_corner(DL)\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, OldTexText(\"Pause and\\\\\\\\Ponder\", font_size=36),\n",
        "            target_mode=\"hooray\",\n",
        "            bubble_config={\n",
        "                \"height\": 2,\n",
        "                \"width\": 3,\n",
        "            }\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(morty.change(\"thinking\"))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhatIsThis(Scene):\n",
        "    def construct(self):\n",
        "        words = Text(\"What is this\", color=RED)\n",
        "        arrow = Vector(UR)\n",
        "        arrow.set_color(RED)\n",
        "        words.next_to(ORIGIN, DOWN)\n",
        "        self.play(FadeIn(words, lag_ratio=0.1), ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GutCheckFormula(RealNewtonsMethod):\n",
        "    seed = 5.0\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes_and_graph()\n",
        "        self.add_rule()\n",
        "        self.add_guess()\n",
        "        self.sample_values()\n",
        "\n",
        "    def add_axes_and_graph(self):\n",
        "        axes = NumberPlane(\n",
        "            (-2, 15), (-2, 8),\n",
        "            faded_line_ratio=1,\n",
        "            background_line_style={\n",
        "                \"stroke_opacity\": 0.5,\n",
        "                \"stroke_color\": GREY,\n",
        "            }\n",
        "        )\n",
        "        axes.to_corner(DL, buff=0)\n",
        "        axes.add_coordinate_labels(font_size=16, fill_opacity=0.5)\n",
        "        axes.x_axis.numbers.next_to(axes.x_axis, UP, buff=0.05)\n",
        "        self.add(axes)\n",
        "\n",
        "        roots = [-1, 3, 4.5]\n",
        "        coefs = 0.1 * np.array(roots_to_coefficients(roots))\n",
        "        graph = axes.get_graph(lambda x: poly(x, coefs))\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        self.add(graph)\n",
        "\n",
        "        self.root_point = axes.c2p(roots[-1], 0)\n",
        "\n",
        "        self.axes = axes\n",
        "        self.graph = graph\n",
        "\n",
        "    def add_rule(self):\n",
        "        rule = OldTex(\n",
        "            \"x_{n + 1}\", \"=\",\n",
        "            \"x_{n}\", \" - \", \"{P(x) \", \"\\\\over \", \"P'(x)}\"\n",
        "        )\n",
        "        rule.set_stroke(BLACK, 5, background=True)\n",
        "        rule.to_corner(UR)\n",
        "\n",
        "        step_box = SurroundingRectangle(rule[3:], buff=0.1)\n",
        "        step_box.set_stroke(YELLOW, 1.0)\n",
        "        step_word = Text(\"Step size\", font_size=36)\n",
        "        step_word.set_color(YELLOW)\n",
        "        step_word.next_to(step_box, DOWN)\n",
        "\n",
        "        self.add(rule)\n",
        "        self.add(step_box)\n",
        "        self.add(step_word)\n",
        "\n",
        "        self.rule = rule\n",
        "        self.step_box = step_box\n",
        "        self.step_word = step_word\n",
        "\n",
        "    def add_guess(self, include_px=True):\n",
        "        guess_group = self.get_guess_group()\n",
        "        marker, value, tracker = guess_group\n",
        "        self.guess_tracker = tracker\n",
        "\n",
        "        def update_v_line(v_line):\n",
        "            x = tracker.get_value()\n",
        "            graph_point = self.graph.pfp(\n",
        "                inverse_interpolate(*self.graph.x_range[:2], x)\n",
        "            )\n",
        "            v_line.put_start_and_end_on(\n",
        "                self.axes.c2p(x, 0),\n",
        "                graph_point,\n",
        "            )\n",
        "\n",
        "        v_line = Line()\n",
        "        v_line.set_stroke(WHITE, 2)\n",
        "        v_line.add_updater(update_v_line)\n",
        "\n",
        "        self.add(*guess_group)\n",
        "        self.add(v_line)\n",
        "\n",
        "        if include_px:\n",
        "            px_label = OldTex(\"P(x)\", font_size=36)\n",
        "            px_label.add_updater(lambda m: m.next_to(v_line, RIGHT, buff=0.05))\n",
        "            self.add(px_label)\n",
        "\n",
        "    def sample_values(self):\n",
        "        box = self.step_box\n",
        "        rule = self.rule\n",
        "        tracker = self.guess_tracker\n",
        "        graph = self.graph\n",
        "\n",
        "        words = Text(\"Gut check!\")\n",
        "        words.next_to(self.step_word, DOWN, LARGE_BUFF)\n",
        "        words.shift(2 * LEFT)\n",
        "        arrow = Arrow(words, self.rule)\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time=1),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(self.step_word),\n",
        "            box.animate.replace(rule[4], stretch=True).scale(1.2).set_stroke(width=2.0),\n",
        "        )\n",
        "        self.play(\n",
        "            tracker.animate.set_value(6.666),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(\n",
        "            self.axes.c2p(tracker.get_value(), 0),\n",
        "            self.root_point,\n",
        "            buff=0,\n",
        "            stroke_color=RED,\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Large p_prime\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            tracker.animate.set_value(5.0),\n",
        "        )\n",
        "        self.play(\n",
        "            graph.animate.stretch(8, 1, about_point=self.axes.c2p(0, 0)),\n",
        "            box.animate.replace(self.rule[-1]).scale(1.2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        tan_line = self.get_tan_line(graph, tracker.get_value(), 15)\n",
        "        self.play(ShowCreation(tan_line))\n",
        "        self.wait()\n",
        "\n",
        "    def get_tan_line(self, graph, x, length=5, epsilon=1e-3):\n",
        "        alpha = inverse_interpolate(*graph.x_range[:2], x)\n",
        "        tan_line = Line(\n",
        "            graph.pfp(alpha - epsilon),\n",
        "            graph.pfp(alpha + epsilon),\n",
        "        )\n",
        "        tan_line.set_length(length)\n",
        "        tan_line.set_stroke(RED, 5)\n",
        "        return tan_line\n",
        "\n",
        "\n",
        "class HistoryWithNewton(Scene):\n",
        "    def construct(self):\n",
        "        # Add title\n",
        "        title = Text(\"Newton's method\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        # Add timeline\n",
        "        time_range = (1620, 2020)\n",
        "        timeline = NumberLine(\n",
        "            (*time_range, 1),\n",
        "            tick_size=0.025,\n",
        "            longer_tick_multiple=4,\n",
        "            big_tick_numbers=range(*time_range, 10),\n",
        "        )\n",
        "        timeline.stretch(0.2 / timeline.get_unit_size(), 0)\n",
        "        timeline_center = 2 * DOWN\n",
        "        timeline.move_to(timeline_center)\n",
        "        timeline.to_edge(RIGHT)\n",
        "        timeline.add_numbers(\n",
        "            range(*time_range, 10),\n",
        "            group_with_commas=False,\n",
        "        )\n",
        "        timeline.shift(timeline_center - timeline.n2p(1680))\n",
        "\n",
        "        self.add(timeline)\n",
        "\n",
        "        # Newton\n",
        "        newton = get_figure(\"Newton\", \"Isaac Newton\", \"1669\")\n",
        "        newton.next_to(title, DOWN, buff=0.5)\n",
        "        newton.to_edge(LEFT, buff=1.5)\n",
        "        newton_point = timeline.n2p(1669)\n",
        "        newton_arrow = Arrow(newton_point, newton[0].get_right() + DOWN, path_arc=PI / 3)\n",
        "\n",
        "        newton_words = Text(\"Overly\\ncomplicated\", font_size=36)\n",
        "        newton_words.next_to(newton[0], RIGHT)\n",
        "\n",
        "        raphson_point = timeline.n2p(1690)\n",
        "        raphson = get_figure(\"Newton\", \"Joseph Raphson\", \"1690\")\n",
        "        raphson.move_to(newton)\n",
        "        raphson.set_x(raphson_point[0] + 2)\n",
        "        raphson[1].set_opacity(0)\n",
        "        raphson_arrow = Arrow(raphson_point, raphson[0].get_left() + DOWN, path_arc=-PI / 3)\n",
        "        raphson_word = Text(\"Simplified\", font_size=36)\n",
        "        raphson_word.next_to(raphson[0], LEFT)\n",
        "\n",
        "        no_image_group = VGroup(\n",
        "            Text(\"No image\"),\n",
        "            Text(\"(sorry)\"),\n",
        "            # Randolph(mode=\"shruggie\", height=1)\n",
        "        )\n",
        "        no_image_group[:2].set_fill(GREY)\n",
        "        no_image_group.arrange(DOWN, buff=0.5)\n",
        "        no_image_group.set_width(raphson[0].get_width() - 0.5)\n",
        "        no_image_group.move_to(raphson[0])\n",
        "\n",
        "        self.add(newton, newton_arrow)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        title.fix_in_frame()\n",
        "        frame.move_to(timeline, RIGHT)\n",
        "        self.play(\n",
        "            frame.animate.match_width(timeline).set_x(timeline.get_center()[0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(Restore(frame, run_time=2))\n",
        "\n",
        "        # self.play(\n",
        "        #     GrowFromPoint(newton, newton_point),\n",
        "        #     ShowCreation(newton_arrow)\n",
        "        # )\n",
        "        self.wait()\n",
        "        self.play(Write(newton_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromPoint(raphson, raphson_point),\n",
        "            ShowCreation(raphson_arrow),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, no_image_group, lag_ratio=0.2))\n",
        "        self.play(FadeIn(raphson_word))\n",
        "        self.wait()\n",
        "\n",
        "        new_title = Text(\"Newton-Raphson method\", font_size=60)\n",
        "        new_title.to_edge(UP)\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            TransformFromCopy(\n",
        "                newton[2].get_part_by_text(\"Newton\"),\n",
        "                new_title.get_part_by_text(\"Newton\"),\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                raphson[2].get_part_by_text(\"Raphson\"),\n",
        "                new_title.get_part_by_text(\"Raphson\"),\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                title.get_part_by_text(\"method\"),\n",
        "                new_title.get_part_by_text(\"method\"),\n",
        "            ),\n",
        "            FadeIn(new_title.get_part_by_text(\"-\"))\n",
        "        )\n",
        "        self.play(FlashAround(new_title, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CalcHomework(GutCheckFormula):\n",
        "    seed = 3.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        old_title = Text(\"Newton-Raphson method\", font_size=60)\n",
        "        old_title.to_edge(UP)\n",
        "        title = Text(\"Calc 1\", font_size=72)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        line = Underline(title)\n",
        "        line.scale(2)\n",
        "        line.set_stroke(WHITE, 2)\n",
        "        self.add(old_title)\n",
        "\n",
        "        # Axes\n",
        "        axes = NumberPlane(\n",
        "            x_range=(-5, 5, 1),\n",
        "            y_range=(-8, 10, 2),\n",
        "            height=6.5,\n",
        "            width=FRAME_WIDTH,\n",
        "            faded_line_ratio=4,\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_C,\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        )\n",
        "        axes.to_edge(DOWN, buff=0)\n",
        "        axes.add_coordinate_labels(font_size=18)\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Homework\n",
        "        hw = OldTexText(\n",
        "            \"Homework:\\\\\\\\\",\n",
        "            \"\\\\quad Approximate $\\\\sqrt{7}$ by hand using\\\\\\\\\",\n",
        "            \"\\\\quad the \", \"Newton-Raphson method.\",\n",
        "            alignment=\"\",\n",
        "            font_size=36,\n",
        "            color=GREY_A,\n",
        "        )\n",
        "        hw[1:].shift(MED_SMALL_BUFF * RIGHT + SMALL_BUFF * DOWN)\n",
        "        hw.add_to_back(\n",
        "            BackgroundRectangle(hw, fill_opacity=0.8, buff=0.25)\n",
        "        )\n",
        "        hw.move_to(axes, UL)\n",
        "        hw.to_edge(LEFT, buff=0)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(hw, lag_ratio=0.1, run_time=2),\n",
        "            FadeTransform(\n",
        "                old_title,\n",
        "                hw[-1]\n",
        "            ),\n",
        "            FadeIn(title),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Graph\n",
        "        graph = axes.get_graph(\n",
        "            lambda x: x**2 - 7,\n",
        "            x_range=(-math.sqrt(17), math.sqrt(17))\n",
        "        )\n",
        "        graph.set_stroke(BLUE, 2)\n",
        "        graph_label = OldTex(\"x^2 - 7\", font_size=36)\n",
        "        graph_label.set_color(BLUE)\n",
        "        graph_label.next_to(graph.pfp(0.99), LEFT)\n",
        "\n",
        "        self.add(graph, hw)\n",
        "        self.play(ShowCreation(graph, run_time=3))\n",
        "        self.play(FadeIn(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Marker\n",
        "        axes.x_axis.numbers.remove(axes.x_axis.numbers[-3])\n",
        "        self.axes = axes\n",
        "        self.graph = graph\n",
        "        self.add_guess(include_px=False)\n",
        "        self.wait()\n",
        "\n",
        "        # Update\n",
        "        tan_line = self.get_tan_line(graph, 3)\n",
        "        tan_line.set_stroke(width=3)\n",
        "        update_tex = OldTex(\n",
        "            \"3 \\\\rightarrow 3 - {3^2 - 7 \\\\over 2 \\\\cdot 3}\",\n",
        "            tex_to_color_map={\"3\": YELLOW},\n",
        "            font_size=28\n",
        "        )\n",
        "        update_tex.next_to(axes.c2p(1.2, 0), UR, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(tan_line, self.guess_marker, self.guess_value)\n",
        "        self.play(\n",
        "            GrowFromCenter(tan_line),\n",
        "            FadeIn(update_tex),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.guess_tracker.animate.set_value(8 / 3),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "\n",
        "class RealNewtonsMethodHigherGraph(FasterNewtonExample):\n",
        "    coefs = [1, -1, 1, 0, 0, 0.99]\n",
        "    poly_tex = \"x^5 + x^2 - x + 1\"\n",
        "    n_search_steps = 20\n",
        "\n",
        "\n",
        "class FactorPolynomial(RealNewtonsMethodHigherGraph):\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.add_title(self.axes)\n",
        "        self.show_factors()\n",
        "\n",
        "    def show_factors(self):\n",
        "        poly = self.poly\n",
        "        colors = color_gradient((BLUE, YELLOW), 5)\n",
        "        factored = OldTex(\n",
        "            \"P(x) = \", *(\n",
        "                f\"(x - r_{n})\"\n",
        "                for n in range(5)\n",
        "            ),\n",
        "            tex_to_color_map={\n",
        "                f\"r_{n}\": color\n",
        "                for n, color in enumerate(colors)\n",
        "            }\n",
        "        )\n",
        "        factored.match_height(poly[0])\n",
        "        factored.next_to(poly, DOWN, LARGE_BUFF, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(poly.copy(), factored)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        words = OldTexText(\"Potentially complex\\\\\\\\\", \"$r_n = a_n + b_n i$\")\n",
        "        words.set_color(GREY_A)\n",
        "        words.next_to(factored, DOWN, buff=1.5)\n",
        "        words.shift(LEFT)\n",
        "        lines = VGroup(*(\n",
        "            Line(words, part, buff=0.15).set_stroke(part.get_color(), 2)\n",
        "            for n in range(5)\n",
        "            for part in [factored.get_part_by_tex(f\"r_{n}\")]\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words[0]),\n",
        "            Write(lines),\n",
        "        )\n",
        "        self.play(FadeIn(words[1], 0.5 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TransitionToComplexPlane(RealNewtonsMethodHigherGraph):\n",
        "    poly_tex = \"z^5 + z^2 - z + 1\"\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.add_title(self.axes)\n",
        "        self.poly.save_state()\n",
        "        self.poly.to_corner(UL)\n",
        "        self.center_graph()\n",
        "        self.show_example_point()\n",
        "        self.separate_input_and_output()\n",
        "        self.move_input_around_plane()\n",
        "\n",
        "    def center_graph(self):\n",
        "        shift_vect = DOWN - self.axes.c2p(0, 0)\n",
        "\n",
        "        self.play(\n",
        "            self.axes.animate.shift(shift_vect),\n",
        "            self.graph.animate.shift(shift_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_example_point(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        input_tracker = ValueTracker(1)\n",
        "        get_x = input_tracker.get_value\n",
        "\n",
        "        def get_px():\n",
        "            return poly(get_x(), self.coefs)\n",
        "\n",
        "        def get_graph_point():\n",
        "            return axes.c2p(get_x(), get_px())\n",
        "\n",
        "        marker = ArrowTip().set_height(0.1)\n",
        "        input_marker = marker.copy().rotate(PI / 2)\n",
        "        input_marker.set_color(YELLOW)\n",
        "        output_marker = marker.copy()\n",
        "        output_marker.set_color(MAROON_B)\n",
        "        input_marker.add_updater(lambda m: m.move_to(axes.x_axis.n2p(get_x()), UP))\n",
        "        output_marker.add_updater(lambda m: m.shift(axes.y_axis.n2p(get_px()) - m.get_start()))\n",
        "\n",
        "        v_line = always_redraw(\n",
        "            lambda: axes.get_v_line(get_graph_point(), line_func=Line).set_stroke(YELLOW, 1)\n",
        "        )\n",
        "        h_line = always_redraw(\n",
        "            lambda: axes.get_h_line(get_graph_point(), line_func=Line).set_stroke(MAROON_B, 1)\n",
        "        )\n",
        "\n",
        "        self.add(\n",
        "            input_tracker,\n",
        "            input_marker,\n",
        "            output_marker,\n",
        "            v_line,\n",
        "            h_line,\n",
        "        )\n",
        "\n",
        "        self.play(input_tracker.animate.set_value(-0.5), run_time=3)\n",
        "        self.play(input_tracker.animate.set_value(1.0), run_time=3)\n",
        "        self.play(ShowCreationThenFadeOut(\n",
        "            axes.get_tangent_line(get_x(), self.graph).set_stroke(RED, 3)\n",
        "        ))\n",
        "\n",
        "        self.input_tracker = input_tracker\n",
        "        self.input_marker = input_marker\n",
        "        self.output_marker = output_marker\n",
        "        self.v_line = v_line\n",
        "        self.h_line = h_line\n",
        "\n",
        "    def separate_input_and_output(self):\n",
        "        axes = self.axes\n",
        "        x_axis, y_axis = axes.x_axis, axes.y_axis\n",
        "        graph = self.graph\n",
        "        input_marker = self.input_marker\n",
        "        output_marker = self.output_marker\n",
        "        v_line = self.v_line\n",
        "        h_line = self.h_line\n",
        "\n",
        "        in_plane = ComplexPlane(\n",
        "            (-2, 2),\n",
        "            (-2, 2),\n",
        "            height=5,\n",
        "            width=5,\n",
        "        )\n",
        "        in_plane.add_coordinate_labels(font_size=18)\n",
        "        in_plane.to_corner(DL)\n",
        "        out_plane = in_plane.deepcopy()\n",
        "        out_plane.to_corner(DR)\n",
        "\n",
        "        input_word = Text(\"Input\")\n",
        "        output_word = Text(\"Output\")\n",
        "\n",
        "        input_word.next_to(in_plane.x_axis, UP)\n",
        "        output_word.rotate(PI / 2)\n",
        "        output_word.next_to(out_plane.y_axis, RIGHT, buff=0.5)\n",
        "\n",
        "        cl_copy = axes.coordinate_labels.copy()\n",
        "        axes.coordinate_labels.set_opacity(0)\n",
        "        self.play(\n",
        "            *map(FadeOut, (v_line, h_line, graph, cl_copy)),\n",
        "        )\n",
        "\n",
        "        for axis1, axis2 in [(x_axis, in_plane.x_axis), (y_axis, out_plane.y_axis)]:\n",
        "            axis1.generate_target()\n",
        "            axis1.target.scale(axis2.get_unit_size() / axis1.get_unit_size())\n",
        "            axis1.target.shift(axis2.n2p(0) - axis1.target.n2p(0))\n",
        "        self.play(\n",
        "            MoveToTarget(x_axis),\n",
        "            MoveToTarget(y_axis),\n",
        "            FadeIn(input_word),\n",
        "            FadeIn(output_word),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(in_plane, input_marker)\n",
        "        self.play(\n",
        "            input_word.animate.next_to(in_plane, UP),\n",
        "            x_axis.animate.set_stroke(width=0),\n",
        "            Write(in_plane, lag_ratio=0.03),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                VGroup(y_axis, output_word, output_marker),\n",
        "                -PI / 2,\n",
        "                about_point=out_plane.n2p(0)\n",
        "            )\n",
        "        )\n",
        "        self.add(out_plane, output_marker)\n",
        "        self.play(\n",
        "            output_word.animate.next_to(out_plane, UP),\n",
        "            y_axis.animate.set_stroke(width=0),\n",
        "            Write(out_plane, lag_ratio=0.03),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.in_plane = in_plane\n",
        "        self.out_plane = out_plane\n",
        "        self.input_word = input_word\n",
        "        self.output_word = output_word\n",
        "\n",
        "    def move_input_around_plane(self):\n",
        "        in_plane = self.in_plane\n",
        "        out_plane = self.out_plane\n",
        "        input_marker = self.input_marker\n",
        "        output_marker = self.output_marker\n",
        "\n",
        "        in_dot, out_dot = [\n",
        "            Dot(radius=0.05).set_fill(marker.get_fill_color()).move_to(marker.get_start())\n",
        "            for marker in (input_marker, output_marker)\n",
        "        ]\n",
        "        in_dot.set_fill(YELLOW, 1)\n",
        "\n",
        "        in_tracer = TracingTail(in_dot, stroke_color=in_dot.get_color())\n",
        "        out_tracer = TracingTail(out_dot, stroke_color=out_dot.get_color())\n",
        "        self.add(in_tracer, out_tracer)\n",
        "\n",
        "        out_dot.add_updater(lambda m: m.move_to(out_plane.n2p(\n",
        "            poly(in_plane.p2n(in_dot.get_center()), self.coefs)\n",
        "        )))\n",
        "\n",
        "        z_label = OldTex(\"z\", font_size=24)\n",
        "        z_label.set_fill(YELLOW)\n",
        "        z_label.add_background_rectangle()\n",
        "        z_label.add_updater(lambda m: m.next_to(in_dot, UP, SMALL_BUFF))\n",
        "        pz_label = OldTex(\"P(z)\", font_size=24)\n",
        "        pz_label.set_fill(MAROON_B)\n",
        "        pz_label.add_background_rectangle()\n",
        "        pz_label.add_updater(lambda m: m.next_to(out_dot, UP, SMALL_BUFF))\n",
        "\n",
        "        self.play(\n",
        "            *map(FadeOut, (input_marker, output_marker)),\n",
        "            *map(FadeIn, (in_dot, out_dot)),\n",
        "            FadeIn(z_label),\n",
        "            FlashAround(z_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(z_label.copy(), pz_label)\n",
        "        )\n",
        "        z_values = [\n",
        "            complex(-0.5, 0.5),\n",
        "            complex(-0.5, -0.5),\n",
        "            complex(-0.25, 0.25),\n",
        "            complex(0.5, -0.5),\n",
        "            complex(0.5, 0.5),\n",
        "            complex(1, 0.25),\n",
        "        ]\n",
        "        for z in z_values:\n",
        "            self.play(\n",
        "                in_dot.animate.move_to(in_plane.n2p(z)),\n",
        "                run_time=2,\n",
        "                path_arc=PI / 2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.remove(in_tracer, out_tracer)\n",
        "        in_plane.generate_target()\n",
        "        in_dot.generate_target()\n",
        "        group = VGroup(in_plane.target, in_dot.target)\n",
        "        group.set_height(8).center().to_edge(RIGHT, buff=0),\n",
        "        self.play(\n",
        "            MoveToTarget(in_plane),\n",
        "            MoveToTarget(in_dot),\n",
        "            FadeOut(self.input_word),\n",
        "            FadeOut(self.output_word),\n",
        "            FadeOut(out_plane),\n",
        "            FadeOut(out_dot),\n",
        "            FadeOut(pz_label),\n",
        "            self.poly.animate.restore().shift(0.32 * RIGHT),\n",
        "        )\n",
        "\n",
        "\n",
        "class ComplexNewtonsMethod(RealNewtonsMethod):\n",
        "    coefs = [1, -1, 1, 0, 0, 1]\n",
        "    poly_tex = \"z^5 + z^2 - z + 1\"\n",
        "    plane_config = {\n",
        "        \"x_range\": (-2, 2),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"height\": 8,\n",
        "        \"width\": 8,\n",
        "    }\n",
        "    seed = complex(-0.5, 0.5)\n",
        "    seed_tex = \"-0.5 + 0.5i\"\n",
        "    guess_color = YELLOW\n",
        "    pz_color = MAROON_B\n",
        "    step_arrow_width = 5\n",
        "    step_arrow_opacity = 1.0\n",
        "    step_arrow_len = None\n",
        "    n_search_steps = 9\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.add_z0_def()\n",
        "        self.add_pz_dot()\n",
        "        self.add_rule()\n",
        "        self.find_root()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = ComplexPlane(**self.plane_config)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        plane.to_edge(RIGHT, buff=0)\n",
        "        self.plane = plane\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_title(self, opacity=1):\n",
        "        super().add_title(self.plane, opacity)\n",
        "\n",
        "    def add_z0_def(self):\n",
        "        seed_text = Text(\"(Arbitrary seed)\")\n",
        "        z0_def = OldTex(\n",
        "            f\"z_0 = {self.seed_tex}\",\n",
        "            tex_to_color_map={\"z_0\": self.guess_color},\n",
        "            font_size=self.rule_font_size\n",
        "        )\n",
        "        z0_group = VGroup(seed_text, z0_def)\n",
        "        z0_group.arrange(DOWN)\n",
        "        z0_group.next_to(self.title, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        guess_dot = Dot(self.plane.n2p(self.seed), color=self.guess_color)\n",
        "\n",
        "        guess = DecimalNumber(self.seed, num_decimal_places=3, font_size=30)\n",
        "        guess.add_updater(\n",
        "            lambda m: m.set_value(self.plane.p2n(\n",
        "                guess_dot.get_center()\n",
        "            )).set_fill(self.guess_color).add_background_rectangle()\n",
        "        )\n",
        "        guess.add_updater(lambda m: m.next_to(guess_dot, UP, buff=0.15))\n",
        "\n",
        "        self.play(\n",
        "            Write(seed_text, run_time=1),\n",
        "            FadeIn(z0_def),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(z0_def[0].copy(), guess_dot),\n",
        "            FadeIn(guess),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.z0_group = z0_group\n",
        "        self.z0_def = z0_def\n",
        "        self.guess_dot = guess_dot\n",
        "        self.guess = guess\n",
        "\n",
        "    def add_pz_dot(self):\n",
        "        plane = self.plane\n",
        "        guess_dot = self.guess_dot\n",
        "\n",
        "        def get_pz():\n",
        "            z = plane.p2n(guess_dot.get_center())\n",
        "            return poly(z, self.coefs)\n",
        "\n",
        "        pz_dot = Dot(color=self.pz_color)\n",
        "        pz_dot.add_updater(lambda m: m.move_to(plane.n2p(get_pz())))\n",
        "        pz_label = OldTex(\"P(z)\", font_size=24)\n",
        "        pz_label.set_color(self.pz_color)\n",
        "        pz_label.add_background_rectangle()\n",
        "        pz_label.add_updater(lambda m: m.next_to(pz_dot, UL, buff=0))\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(self.poly[0].copy(), pz_label),\n",
        "            FadeIn(pz_dot),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_rule(self):\n",
        "        self.rule = rule = self.get_update_rule(\"z\")\n",
        "        rule.next_to(self.z0_group, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransformPieces(self.z0_def[0].copy(), rule.zns),\n",
        "            FadeIn(rule),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def find_root(self):\n",
        "        for x in range(self.n_search_steps):\n",
        "            self.root_search_step()\n",
        "\n",
        "    def root_search_step(self):\n",
        "        dot = self.guess_dot\n",
        "        dot_step_anims = self.get_dot_step_anims(VGroup(dot))\n",
        "        diff_rect = SurroundingRectangle(\n",
        "            self.rule.slice_by_tex(\"-\"),\n",
        "            buff=0.1,\n",
        "            stroke_color=GREY_A,\n",
        "            stroke_width=1,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(diff_rect),\n",
        "            dot_step_anims[0],\n",
        "        )\n",
        "        self.play(\n",
        "            dot_step_anims[1],\n",
        "            FadeOut(diff_rect),\n",
        "            *self.cycle_rule_entries_anims(),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_dot_step_anims(self, dots):\n",
        "        plane = self.plane\n",
        "        arrows = VGroup()\n",
        "        dots.generate_target()\n",
        "        for dot, dot_target in zip(dots, dots.target):\n",
        "            try:\n",
        "                z0 = plane.p2n(dot.get_center())\n",
        "                pz = poly(z0, self.coefs)\n",
        "                dpz = dpoly(z0, self.coefs)\n",
        "                if abs(pz) < 1e-3:\n",
        "                    z1 = z0\n",
        "                else:\n",
        "                    if dpz == 0:\n",
        "                        dpz = 0.1  # ???\n",
        "                    z1 = z0 - pz / dpz\n",
        "\n",
        "                if np.isnan(z1):\n",
        "                    z1 = z0\n",
        "\n",
        "                arrow = Arrow(\n",
        "                    plane.n2p(z0), plane.n2p(z1),\n",
        "                    buff=0,\n",
        "                    stroke_width=self.step_arrow_width,\n",
        "                    storke_opacity=self.step_arrow_opacity,\n",
        "                )\n",
        "                if self.step_arrow_len is not None:\n",
        "                    if arrow.get_length() > self.step_arrow_len:\n",
        "                        arrow.set_length(self.step_arrow_len, about_point=arrow.get_start())\n",
        "\n",
        "                if not hasattr(dot, \"history\"):\n",
        "                    dot.history = [dot.get_center().copy()]\n",
        "                dot.history.append(plane.n2p(z1))\n",
        "\n",
        "                arrows.add(arrow)\n",
        "                dot_target.move_to(plane.n2p(z1))\n",
        "            except ValueError:\n",
        "                pass\n",
        "        return [\n",
        "            ShowCreation(arrows, lag_ratio=0),\n",
        "            AnimationGroup(\n",
        "                MoveToTarget(dots),\n",
        "                FadeOut(arrows),\n",
        "            )\n",
        "        ]\n",
        "\n",
        "\n",
        "class OutputIsZero(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Output $\\\\approx 0$\")\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        arrow = Vector(0.5 * UL)\n",
        "        words.next_to(arrow, DR)\n",
        "        words.shift(0.5 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FunPartWords(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Now here's \\\\\\\\ the fun part\", font_size=72)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class ComplexNewtonsMethodManySeeds(ComplexNewtonsMethod):\n",
        "    dot_radius = 0.035\n",
        "    dot_color = WHITE\n",
        "    dot_opacity = 0.8\n",
        "    step_arrow_width = 3\n",
        "    step_arrow_opacity = 0.1\n",
        "    step_arrow_len = 0.15\n",
        "\n",
        "    plane_config = {\n",
        "        \"x_range\": (-2, 2),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"height\": 8,\n",
        "        \"width\": 8,\n",
        "    }\n",
        "    step = 0.2\n",
        "    n_search_steps = 20\n",
        "    colors = ROOT_COLORS_BRIGHT\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.add_z0_def()\n",
        "        self.add_rule()\n",
        "        self.add_true_root_circles()\n",
        "        self.find_root()\n",
        "        self.add_color()\n",
        "\n",
        "    def add_z0_def(self):\n",
        "        seed_text = Text(\"Many seeds: \")\n",
        "        z0_def = OldTex(\n",
        "            \"z_0\",\n",
        "            tex_to_color_map={\"z_0\": self.guess_color},\n",
        "            font_size=self.rule_font_size\n",
        "        )\n",
        "        z0_group = VGroup(seed_text, z0_def)\n",
        "        z0_group.arrange(RIGHT)\n",
        "        z0_group.next_to(self.title, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        x_range = self.plane_config[\"x_range\"]\n",
        "        y_range = self.plane_config[\"y_range\"]\n",
        "        step = self.step\n",
        "        x_vals = np.arange(x_range[0], x_range[1] + step, step)\n",
        "        y_vals = np.arange(y_range[0], y_range[1] + step, step)\n",
        "        guess_dots = VGroup(*(\n",
        "            Dot(\n",
        "                self.plane.c2p(x, y),\n",
        "                radius=self.dot_radius,\n",
        "                fill_opacity=self.dot_opacity,\n",
        "            )\n",
        "            for i, x in enumerate(x_vals)\n",
        "            for y in (y_vals if i % 2 == 0 else reversed(y_vals))\n",
        "        ))\n",
        "        guess_dots.set_submobject_colors_by_gradient(WHITE, GREY_B)\n",
        "        guess_dots.set_fill(opacity=self.dot_opacity)\n",
        "        guess_dots.set_stroke(BLACK, 2, background=True)\n",
        "\n",
        "        self.play(\n",
        "            Write(seed_text, run_time=1),\n",
        "            FadeIn(z0_def),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(z0_def[0].copy(), guess_dot)\n",
        "                for guess_dot in guess_dots\n",
        "            ), lag_ratio=0.1 / len(guess_dots)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(guess_dots)\n",
        "        self.wait()\n",
        "\n",
        "        self.z0_group = z0_group\n",
        "        self.z0_def = z0_def\n",
        "        self.guess_dots = guess_dots\n",
        "\n",
        "    def add_true_root_circles(self):\n",
        "        roots = coefficients_to_roots(self.coefs)\n",
        "        root_points = list(map(self.plane.n2p, roots))\n",
        "        colors = self.colors\n",
        "\n",
        "        root_circles = VGroup(*(\n",
        "            Dot(radius=0.1).set_fill(color, opacity=0.75).move_to(rp)\n",
        "            for rp, color in zip(root_points, colors)\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeIn(rc, scale=0.5)\n",
        "                for rc in root_circles\n",
        "            ), lag_ratio=0.7, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.root_circles = root_circles\n",
        "\n",
        "    def root_search_step(self):\n",
        "        dots = self.guess_dots\n",
        "        dot_step_anims = self.get_dot_step_anims(dots)\n",
        "\n",
        "        self.play(dot_step_anims[0], run_time=0.25)\n",
        "        self.play(\n",
        "            dot_step_anims[1],\n",
        "            *self.cycle_rule_entries_anims(),\n",
        "            run_time=1\n",
        "        )\n",
        "\n",
        "    def add_color(self):\n",
        "        root_points = [circ.get_center() for circ in self.root_circles]\n",
        "        colors = [circ.get_fill_color() for circ in self.root_circles]\n",
        "\n",
        "        dots = self.guess_dots\n",
        "        dots.generate_target()\n",
        "        for dot, dot_target in zip(dots, dots.target):\n",
        "            dc = dot.get_center()\n",
        "            dot_target.set_color(colors[\n",
        "                np.argmin([get_norm(dc - rp) for rp in root_points])\n",
        "            ])\n",
        "\n",
        "        rect = SurroundingRectangle(self.rule)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.set_stroke(width=0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            MoveToTarget(dots)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        len_history = max([len(dot.history) for dot in dots if hasattr(dot, \"history\")], default=0)\n",
        "        for n in range(len_history):\n",
        "            dots.generate_target()\n",
        "            for dot, dot_target in zip(dots, dots.target):\n",
        "                try:\n",
        "                    dot_target.move_to(dot.history[len_history - n - 1])\n",
        "                except Exception:\n",
        "                    pass\n",
        "            self.play(MoveToTarget(dots, run_time=0.5))\n",
        "\n",
        "\n",
        "class ZeroStepColoring(ComplexNewtonsMethodManySeeds):\n",
        "    n_search_steps = 0\n",
        "\n",
        "\n",
        "class ComplexNewtonsMethodManySeedsHigherRes(ComplexNewtonsMethodManySeeds):\n",
        "    step = 0.05\n",
        "\n",
        "\n",
        "class IntroNewtonFractal(Scene):\n",
        "    coefs = [1.0, -1.0, 1.0, 0.0, 0.0, 1.0]\n",
        "    plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-4, 4),\n",
        "        \"height\": 16,\n",
        "        \"width\": 16,\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY_A,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"axis_config\": {\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    n_steps = 30\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_fractal(root_colors=ROOT_COLORS_BRIGHT)\n",
        "        fractal, plane, root_dots = self.group\n",
        "\n",
        "        # Transition from last scene\n",
        "        frame = self.camera.frame\n",
        "        frame.shift(plane.n2p(2) - RIGHT_SIDE)\n",
        "\n",
        "        blocker = BackgroundRectangle(plane, fill_opacity=1)\n",
        "        blocker.move_to(plane.n2p(-2), RIGHT)\n",
        "        self.add(blocker)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.center(),\n",
        "            FadeOut(blocker),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            fractal.animate.set_colors(ROOT_COLORS_DEEP),\n",
        "            *(\n",
        "                dot.animate.set_fill(interpolate_color(color, WHITE, 0.2))\n",
        "                for dot, color in zip(root_dots, ROOT_COLORS_DEEP)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in\n",
        "        fractal.set_n_steps(40)\n",
        "        zoom_points = [\n",
        "            [-3.12334879, 1.61196545, 0.],\n",
        "            [1.21514006, 0.01415811, 0.],\n",
        "        ]\n",
        "        for point in zoom_points:\n",
        "            self.play(\n",
        "                frame.animate.set_height(2e-3).move_to(point),\n",
        "                run_time=25,\n",
        "                rate_func=bezier(2 * [0] + 6 * [1])\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                frame.animate.center().set_height(8),\n",
        "                run_time=10,\n",
        "                rate_func=bezier(6 * [0] + 2 * [1])\n",
        "            )\n",
        "\n",
        "        # Allow for play\n",
        "        self.tie_fractal_to_root_dots(fractal)\n",
        "        fractal.set_n_steps(12)\n",
        "\n",
        "    def init_fractal(self, root_colors=ROOT_COLORS_DEEP):\n",
        "        plane = self.get_plane()\n",
        "        fractal = self.get_fractal(\n",
        "            plane,\n",
        "            colors=root_colors,\n",
        "            n_steps=self.n_steps,\n",
        "        )\n",
        "        root_dots = self.get_root_dots(plane, fractal)\n",
        "        self.tie_fractal_to_root_dots(fractal)\n",
        "\n",
        "        self.plane = plane\n",
        "        self.fractal = fractal\n",
        "        self.group = Group(fractal, plane, root_dots)\n",
        "        self.add(*self.group)\n",
        "\n",
        "    def get_plane(self):\n",
        "        plane = ComplexPlane(**self.plane_config)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        self.plane = plane\n",
        "        return plane\n",
        "\n",
        "    def get_fractal(self, plane, colors=ROOT_COLORS_DEEP, n_steps=30):\n",
        "        return NewtonFractal(\n",
        "            plane,\n",
        "            colors=colors,\n",
        "            coefs=self.coefs,\n",
        "            n_steps=n_steps,\n",
        "        )\n",
        "\n",
        "    def get_root_dots(self, plane, fractal):\n",
        "        self.root_dots = VGroup(*(\n",
        "            Dot(plane.n2p(root), color=color)\n",
        "            for root, color in zip(\n",
        "                coefficients_to_roots(fractal.coefs),\n",
        "                fractal.colors\n",
        "            )\n",
        "        ))\n",
        "        self.root_dots.set_stroke(BLACK, 5, background=True)\n",
        "        return self.root_dots\n",
        "\n",
        "    def tie_fractal_to_root_dots(self, fractal):\n",
        "        fractal.add_updater(lambda f: f.set_roots([\n",
        "            self.plane.p2n(dot.get_center())\n",
        "            for dot in self.root_dots\n",
        "        ]))\n",
        "\n",
        "    def on_mouse_press(self, point, button, mods):\n",
        "        super().on_mouse_press(point, button, mods)\n",
        "        mob = self.point_to_mobject(point, search_set=self.root_dots)\n",
        "        if mob is None:\n",
        "            return\n",
        "        self.mouse_drag_point.move_to(point)\n",
        "        mob.add_updater(lambda m: m.move_to(self.mouse_drag_point))\n",
        "        self.unlock_mobject_data()\n",
        "        self.lock_static_mobject_data()\n",
        "\n",
        "    def on_mouse_release(self, point, button, mods):\n",
        "        super().on_mouse_release(point, button, mods)\n",
        "        self.root_dots.clear_updaters()\n",
        "\n",
        "\n",
        "class ChaosOnBoundary(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Chaos at\\\\\\\\the boundary\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 3,\n",
        "            }\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\", look_at=self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class DeepZoomFractal(IntroNewtonFractal):\n",
        "    coefs = [-1.0, 0.0, 0.0, 1.0, 0.0, 1.0]\n",
        "\n",
        "    plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-4, 4),\n",
        "        \"height\": 16 * 1,\n",
        "        \"width\": 16 * 1,\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY_A,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"axis_config\": {\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_fractal(root_colors=ROOT_COLORS_DEEP)\n",
        "        fractal, plane, root_dots = self.group\n",
        "\n",
        "        he_tracker = ValueTracker(0)\n",
        "        frame = self.camera.frame\n",
        "        zoom_point = np.array([\n",
        "            # -1.91177811, 0.52197285, 0.\n",
        "            0.72681252, -0.66973296, 0.\n",
        "        ], dtype=np.float64)\n",
        "\n",
        "        initial_fh = FRAME_HEIGHT\n",
        "        frame.add_updater(lambda m: m.set_height(\n",
        "            initial_fh * 2**(-he_tracker.get_value()),\n",
        "        ))\n",
        "        # rd_height = root_dots.get_height()\n",
        "        # root_dots.add_updater(lambda m: m.set_height(\n",
        "        #     rd_height * 2**(he_tracker.get_value() / 8),\n",
        "        #     about_point=zoom_point\n",
        "        # ))\n",
        "\n",
        "        self.add(frame)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                frame,\n",
        "                lambda m, a: m.move_to(zoom_point * a),\n",
        "                run_time=15,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                he_tracker.set_value, 14,\n",
        "                run_time=30,\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IncreasingStepsNewtonFractal(IntroNewtonFractal):\n",
        "    play_mode = False\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_fractal()\n",
        "        fractal, plane, root_dots = self.group\n",
        "        fractal.set_n_steps(0)\n",
        "\n",
        "        steps_label = VGroup(Integer(0, edge_to_fix=RIGHT), Text(\"Steps\"))\n",
        "        steps_label.arrange(RIGHT, aligned_edge=UP)\n",
        "        steps_label.next_to(ORIGIN, UP).to_edge(LEFT)\n",
        "        steps_label.set_stroke(BLACK, 5, background=True)\n",
        "        self.add(steps_label)\n",
        "\n",
        "        step_tracker = ValueTracker(0)\n",
        "        get_n_steps = step_tracker.get_value\n",
        "        fractal.add_updater(lambda m: m.set_n_steps(int(get_n_steps())))\n",
        "        steps_label[0].add_updater(\n",
        "            lambda m: m.set_value(int(get_n_steps()))\n",
        "        )\n",
        "        steps_label[0].add_updater(lambda m: m.set_stroke(BLACK, 5, background=True))\n",
        "\n",
        "        if self.play_mode:\n",
        "            self.wait(20)\n",
        "            for n in range(20):\n",
        "                step_tracker.set_value(n)\n",
        "                if n == 1:\n",
        "                    self.wait(15)\n",
        "                elif n == 2:\n",
        "                    self.wait(10)\n",
        "                else:\n",
        "                    self.wait()\n",
        "        else:\n",
        "            self.play(\n",
        "                step_tracker.animate.set_value(20),\n",
        "                run_time=10\n",
        "            )\n",
        "\n",
        "\n",
        "class ManyQuestions(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        questions = VGroup(\n",
        "            Text(\"Lower order polynomials?\"),\n",
        "            Text(\"Do points ever cycle?\"),\n",
        "            Text(\"Fractal dimension?\"),\n",
        "            Text(\"Connection to Mandelbrot?\"),\n",
        "        )\n",
        "        screens = VGroup(*(ScreenRectangle() for q in questions))\n",
        "        screens.arrange_in_grid(\n",
        "            v_buff=1.5,\n",
        "            h_buff=3.0,\n",
        "        )\n",
        "        screens.set_fill(BLACK, 1)\n",
        "\n",
        "        questions.match_width(screens[0])\n",
        "        for question, screen in zip(questions, screens):\n",
        "            question.next_to(screen, UP)\n",
        "            screen.add(question)\n",
        "\n",
        "        screens.set_height(FRAME_HEIGHT - 0.5)\n",
        "        screens.center()\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, screens,\n",
        "            lag_ratio=0.9,\n",
        "        ), run_time=8)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhatsGoingOn(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.screen.set_height(4, about_edge=UL)\n",
        "        self.screen.set_fill(BLACK, 1)\n",
        "        self.add(self.screen)\n",
        "\n",
        "        self.student_says(\n",
        "            \"What the %$!* is\\ngoing on?\",\n",
        "            target_mode=\"angry\",\n",
        "            look_at=self.screen,\n",
        "            index=2,\n",
        "            added_anims=[LaggedStart(*(\n",
        "                pi.change(\"guilty\", self.students[2].eyes)\n",
        "                for pi in [self.teacher, *self.students[:2]]\n",
        "            ), run_time=2)]\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class EquationToFrame(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = self.get_screens()\n",
        "        arrow = Arrow(*screens)\n",
        "\n",
        "        equation = get_newton_rule()\n",
        "        equation.next_to(screens[0], UP)\n",
        "\n",
        "        title = OldTexText(\"Unreasonable intricacy\")\n",
        "        title.next_to(screens[1], UP)\n",
        "\n",
        "        self.wait()\n",
        "        self.add(screens)\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeTransform(equation.copy(), title),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_screens(self):\n",
        "        screens = Square().get_grid(1, 2)\n",
        "        screens.set_height(6)\n",
        "        screens.set_width(FRAME_WIDTH - 1, stretch=True)\n",
        "        screens.set_stroke(WHITE, 3)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.arrange(RIGHT, buff=2.0)\n",
        "        screens.to_edge(DOWN)\n",
        "        return screens\n",
        "\n",
        "\n",
        "class RepeatedNewton(Scene):\n",
        "    coefs = [1.0, -1.0, 1.0, 0.0, 0.0, 1.0]\n",
        "    plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"height\": 8,\n",
        "        \"width\": 16,\n",
        "    }\n",
        "    dots_config = {\n",
        "        \"radius\": 0.05,\n",
        "        \"color\": GREY_A,\n",
        "        \"gloss\": 0.4,\n",
        "        \"shadow\": 0.1,\n",
        "        \"opacity\": 0.5,\n",
        "    }\n",
        "    arrow_style = {\n",
        "        \"stroke_color\": WHITE,\n",
        "        \"stroke_opacity\": 0.5,\n",
        "    }\n",
        "    dot_density = 5.0\n",
        "    points_scalar = 1.0\n",
        "    n_steps = 10\n",
        "    colors = ROOT_COLORS_BRIGHT\n",
        "    show_coloring = True\n",
        "    show_arrows = True\n",
        "    highlight_equation = False\n",
        "    corner_group_height = 2.0\n",
        "    step_run_time = 1.0\n",
        "    show_fractal_background = False\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_true_roots()\n",
        "        self.add_labels()\n",
        "        if self.show_fractal_background:\n",
        "            self.add_fractal_background()\n",
        "        self.add_dots()\n",
        "        self.run_iterations()\n",
        "        if self.show_coloring:\n",
        "            self.color_points()\n",
        "            self.revert_to_original_positions()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane(**self.plane_config)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_labels(self):\n",
        "        eq_label = self.eq_label = OldTex(\n",
        "            \"P(z) = \" + coefs_to_poly_string(self.coefs),\n",
        "            font_size=36\n",
        "        )\n",
        "\n",
        "        rule_label = self.rule_label = get_newton_rule()\n",
        "        rule_label.next_to(eq_label, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        corner_rect = SurroundingRectangle(\n",
        "            VGroup(eq_label, rule_label),\n",
        "            buff=MED_SMALL_BUFF\n",
        "        )\n",
        "        corner_rect.set_fill(BLACK, 0.9)\n",
        "        corner_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.corner_group = VGroup(\n",
        "            corner_rect,\n",
        "            eq_label,\n",
        "            rule_label,\n",
        "        )\n",
        "        self.corner_group.set_height(self.corner_group_height)\n",
        "        self.corner_group.to_corner(UL, buff=0)\n",
        "        self.add(self.corner_group)\n",
        "\n",
        "    def add_true_roots(self):\n",
        "        roots = self.roots = coefficients_to_roots(self.coefs)\n",
        "        root_dots = self.root_dots = VGroup(*(\n",
        "            glow_dot(self.plane.n2p(root), color=color, opacity_mult=2.0)\n",
        "            for root, color in zip(roots, self.colors)\n",
        "        ))\n",
        "\n",
        "        self.add(root_dots)\n",
        "\n",
        "    def add_dots(self):\n",
        "        dots = self.dots = DotCloud(\n",
        "            self.get_original_points(), **self.dots_config\n",
        "        )\n",
        "\n",
        "        self.add(dots, self.corner_group)\n",
        "        self.play(ShowCreation(dots))\n",
        "\n",
        "    def get_original_points(self):\n",
        "        step = 1.0 / self.dot_density\n",
        "        return self.points_scalar * np.array([\n",
        "            self.plane.c2p(x, y)\n",
        "            for x in np.arange(*self.plane.x_range[:2], step)\n",
        "            for y in np.arange(*self.plane.y_range[:2], step)\n",
        "        ])\n",
        "\n",
        "    def run_iterations(self):\n",
        "        self.points_history = []\n",
        "        for x in range(self.n_steps):\n",
        "            self.points_history.append(self.dots.get_points().copy())\n",
        "            self.take_step(run_time=self.step_run_time)\n",
        "\n",
        "    def update_z(self, z, epsilon=1e-6):\n",
        "        denom = dpoly(z, self.coefs)\n",
        "        if abs(denom) < epsilon:\n",
        "            denom = epsilon\n",
        "        return z - poly(z, self.coefs) / denom\n",
        "\n",
        "    def take_step(self, run_time=1.0):\n",
        "        plane = self.plane\n",
        "        points = self.dots.get_points()\n",
        "\n",
        "        zs = map(plane.p2n, points)\n",
        "        new_zs = map(self.update_z, zs)\n",
        "        new_points = list(map(plane.n2p, new_zs))\n",
        "\n",
        "        added_anims = []\n",
        "        if self.show_arrows:\n",
        "            arrows = []\n",
        "            max_len = 0.5 * plane.get_x_unit_size() / self.dot_density\n",
        "            for p1, p2 in zip(points, new_points):\n",
        "                vect = p2 - p1\n",
        "                norm = get_norm(vect)\n",
        "                if norm > max_len:\n",
        "                    vect = normalize(vect) * max_len\n",
        "                arrows.append(Vector(vect, **self.arrow_style).shift(p1))\n",
        "            arrows = VGroup(*arrows)\n",
        "            self.add(arrows, self.dots, self.corner_group)\n",
        "            self.play(ShowCreation(arrows, lag_ratio=0))\n",
        "            added_anims.append(FadeOut(arrows))\n",
        "\n",
        "        self.play(\n",
        "            self.dots.animate.set_points(new_points),\n",
        "            *added_anims,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.dots.filter_out(lambda p: get_norm(p) > FRAME_WIDTH)\n",
        "\n",
        "    def color_points(self):\n",
        "        root_points = [rd.get_center() for rd in self.root_dots]\n",
        "        rgbas = list(map(color_to_rgba, self.colors))\n",
        "\n",
        "        def get_rgba(point):\n",
        "            norms = [get_norm(point - rp) for rp in root_points]\n",
        "            return rgbas[np.argmin(norms)]\n",
        "\n",
        "        rgbas = list(map(get_rgba, self.dots.get_points()))\n",
        "\n",
        "        fractal = NewtonFractal(\n",
        "            self.plane,\n",
        "            coefs=self.coefs,\n",
        "            colors=self.colors,\n",
        "            n_steps=0,\n",
        "        )\n",
        "        fractal.set_opacity(0)\n",
        "\n",
        "        self.add(fractal, self.plane, self.dots, self.corner_group)\n",
        "        radius = self.dots.get_radius()\n",
        "        self.play(\n",
        "            fractal.animate.set_opacity(0.5),\n",
        "            self.dots.animate.set_rgba_array(rgbas).set_radius(1.5 * radius),\n",
        "        )\n",
        "        self.play(\n",
        "            fractal.animate.set_opacity(0),\n",
        "            self.dots.animate.set_radius(radius),\n",
        "        )\n",
        "        self.remove(fractal)\n",
        "\n",
        "    def revert_to_original_positions(self):\n",
        "        for ph in self.points_history[::-1]:\n",
        "            self.play(\n",
        "                self.dots.animate.set_points(ph),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "\n",
        "    def reveal_fractal(self, **kwargs):\n",
        "        plane = self.plane\n",
        "\n",
        "        fractal = self.fractal = self.get_fractal(**kwargs)\n",
        "        root_dot_backs = VGroup(*(Dot(rd.get_center(), radius=0.1) for rd in self.root_dots))\n",
        "        root_dot_backs.set_stroke(BLACK, 2)\n",
        "        root_dot_backs.set_fill(opacity=0)\n",
        "\n",
        "        plane.generate_target(use_deepcopy=True)\n",
        "        for lines in plane.target.background_lines, plane.target.faded_lines:\n",
        "            lines.set_stroke(WHITE)\n",
        "            for line in lines.family_members_with_points():\n",
        "                line.set_opacity(line.get_stroke_opacity() * 0.5)\n",
        "\n",
        "        self.root_dots.generate_target()\n",
        "        for rd, color in zip(self.root_dots.target, fractal.colors):\n",
        "            rd.set_fill(color)\n",
        "\n",
        "        self.add(fractal, *self.mobjects, root_dot_backs)\n",
        "        self.play(\n",
        "            FadeIn(fractal),\n",
        "            FadeOut(self.dots),\n",
        "            FadeIn(root_dot_backs),\n",
        "            MoveToTarget(plane),\n",
        "            MoveToTarget(self.root_dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_fractal(self, **kwargs):\n",
        "        if \"colors\" not in kwargs:\n",
        "            kwargs[\"colors\"] = self.colors\n",
        "        self.fractal = NewtonFractal(self.plane, coefs=self.coefs, **kwargs)\n",
        "        return self.fractal\n",
        "\n",
        "    def add_fractal_background(self):\n",
        "        fractal = self.get_fractal()\n",
        "        fractal.set_opacity(0.1)\n",
        "        fractal.set_n_steps(12)\n",
        "        boundary = self.fractal_boundary = fractal.copy()\n",
        "        boundary.set_colors(5 * [WHITE])\n",
        "        boundary.set_julia_highlight(1e-4)\n",
        "        boundary.set_opacity(0.25)\n",
        "        self.add(fractal, boundary, *self.mobjects)\n",
        "\n",
        "\n",
        "class AmbientQuinticSolving(RepeatedNewton):\n",
        "    coefs = [-23.125, -11.9375, -6.875, 0.3125, 2.5, 1]\n",
        "    show_fractal_background = True\n",
        "    dots_config = {\n",
        "        \"radius\": 0.03,\n",
        "        \"color\": GREY_A,\n",
        "        \"gloss\": 0.4,\n",
        "        \"shadow\": 0.1,\n",
        "        \"opacity\": 0.5,\n",
        "    }\n",
        "    dot_density = 10.0\n",
        "\n",
        "    def add_labels(self):\n",
        "        super().add_labels()\n",
        "        self.corner_group.set_opacity(0)\n",
        "\n",
        "\n",
        "class WhyNotThisWrapper(VideoWrapper):\n",
        "    title = \"Why not something like this?\"\n",
        "    animate_boundary = False\n",
        "    title_config = {\n",
        "        \"font_size\": 60,\n",
        "        \"color\": RED,\n",
        "    }\n",
        "    wait_time = 2\n",
        "\n",
        "\n",
        "class SimplyTendingToNearestRoot(RepeatedNewton):\n",
        "    def update_z(self, z):\n",
        "        norms = [abs(r - z) for r in self.roots]\n",
        "        nearest_root = self.roots[np.argmin(norms)]\n",
        "        norm = min(norms)\n",
        "        step_size = np.log(1 + norm * 3) / 3\n",
        "        return z + step_size * (nearest_root - z)\n",
        "\n",
        "\n",
        "class UnrelatedIdeas(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.screen.set_height(4, about_edge=UL)\n",
        "        self.add(self.screen)\n",
        "\n",
        "        self.play_student_changes(\n",
        "            \"tease\", \"thinking\", \"raise_right_hand\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[self.teacher.change(\"happy\")]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Unrelated\\\\\\\\ideas\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            },\n",
        "            added_anims=[\n",
        "                s.change(\"sassy\", self.teacher.eyes)\n",
        "                for s in self.students\n",
        "            ]\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            self.students[2].change(\"angry\"),\n",
        "            self.teacher.change(\"guilty\"),\n",
        "            lag_ratio=0.7,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class RepeatedNewtonCubic(RepeatedNewton):\n",
        "    coefs = [-1, 0, 0, 1]\n",
        "    # colors = [RED_E, GREEN_E, BLUE_E]\n",
        "    colors = ROOT_COLORS_DEEP[::2]\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        self.reveal_fractal()\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        self.play(\n",
        "            frame.animate.move_to([0.86579359, -0.8322599, 0.]).set_height(0.0029955),\n",
        "            rate_func=bezier([0, 0, 1, 1, 1, 1, 1, 1]),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "\n",
        "class RepeatedNewtonQuadratic(RepeatedNewton):\n",
        "    coefs = [-1, 0, 1]\n",
        "    colors = [RED, BLUE]\n",
        "    n_steps = 10\n",
        "\n",
        "\n",
        "class SimpleFractalScene(IntroNewtonFractal):\n",
        "    colors = ROOT_COLORS_DEEP\n",
        "    display_polynomial_label = False\n",
        "    display_root_values = False\n",
        "    n_steps = 25\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_fractal(root_colors=self.colors)\n",
        "        if self.display_polynomial_label:\n",
        "            self.add_polynomial_label()\n",
        "        if self.display_root_values:\n",
        "            self.add_root_labels()\n",
        "\n",
        "    def add_polynomial_label(self):\n",
        "        n = len(self.fractal.roots)\n",
        "        t2c = {\n",
        "            f\"r_{i + 1}\": interpolate_color(self.colors[i], WHITE, 0.5)\n",
        "            for i in range(n)\n",
        "        }\n",
        "        label = OldTex(\n",
        "            \"p(z) = \", *(\n",
        "                f\"(z - r_{i})\"\n",
        "                for i in range(1, n + 1)\n",
        "            ),\n",
        "            tex_to_color_map=t2c,\n",
        "            font_size=36\n",
        "        )\n",
        "        label.to_corner(UL)\n",
        "        label.set_stroke(BLACK, 5, background=True)\n",
        "        self.add(label)\n",
        "\n",
        "    def add_root_labels(self):\n",
        "        for n, root_dot in zip(it.count(1), self.root_dots):\n",
        "            self.add(self.get_root_label(root_dot, n))\n",
        "\n",
        "    def get_root_label(self, root_dot, n):\n",
        "        def get_z():\n",
        "            return self.plane.p2n(root_dot.get_center())\n",
        "        label = VGroup(\n",
        "            OldTex(f\"r_{n} = \"),\n",
        "            DecimalNumber(get_z(), include_sign=True),\n",
        "        )\n",
        "        label.scale(0.5)\n",
        "        label.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        def update_label(label):\n",
        "            label.arrange(RIGHT, buff=0.1)\n",
        "            label[0].shift(0.1 * label[0].get_height() * DOWN)\n",
        "            label.next_to(root_dot, UR, SMALL_BUFF)\n",
        "            label[1].set_value(get_z())\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "        return label\n",
        "\n",
        "\n",
        "class TwoRootFractal(SimpleFractalScene):\n",
        "    coefs = [-1.0, 0.0, 1.0]\n",
        "    colors = [ROOT_COLORS_DEEP[0], ROOT_COLORS_DEEP[4]]\n",
        "    n_steps = 0  # Doesn't really matter, does it?\n",
        "\n",
        "\n",
        "class TwoRootFractalWithLabels(TwoRootFractal):\n",
        "    display_polynomial_label = True\n",
        "    display_root_values = True\n",
        "\n",
        "\n",
        "class ThreeRootFractal(SimpleFractalScene):\n",
        "    coefs = [-1.0, 0.0, 0.0, 1.0]\n",
        "    colors = ROOT_COLORS_DEEP[::2]\n",
        "    n_steps = 30\n",
        "\n",
        "\n",
        "class ThreeRootFractalWithLabels(ThreeRootFractal):\n",
        "    display_polynomial_label = True\n",
        "    display_root_values = True\n",
        "\n",
        "\n",
        "class FromTwoToThree(EquationToFrame):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = self.get_screens()\n",
        "        arrow = Arrow(*screens)\n",
        "\n",
        "        quadratic = OldTex(\"x^2 + c_1 x + c_0\")\n",
        "        cubic = OldTex(\"x^3 + c_2 x^2 + c_1 x + c_0\")\n",
        "        quadratic.next_to(screens[0], UP)\n",
        "        cubic.next_to(screens[1], UP)\n",
        "\n",
        "        self.add(screens)\n",
        "        self.add(quadratic, cubic)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class StudentAsksAboutComplexity(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"Why is it\\\\\\\\so complicated?\"),\n",
        "            index=0,\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            },\n",
        "            added_anims=[\n",
        "                self.students[1].change(\"confused\", self.teacher.eyes),\n",
        "                self.students[2].change(\"erm\", self.teacher.eyes),\n",
        "            ],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change(\"shruggie\"),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            PiCreatureSays(\n",
        "                self.teacher, OldTexText(\"Math is what\\\\\\\\it is\"),\n",
        "                target_mode=\"well\",\n",
        "                bubble_config={\n",
        "                    \"height\": 3,\n",
        "                    \"width\": 4,\n",
        "                }\n",
        "            ),\n",
        "            self.students[1].change(\"maybe\"),\n",
        "            self.students[2].change(\"sassy\"),\n",
        "            lag_ratio=0.7,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        why = self.students[0].bubble.content[0][:3]\n",
        "        question = Text(\"Is this meaningful?\")\n",
        "        question.to_corner(UL)\n",
        "        question.set_color(YELLOW)\n",
        "        arrow = Arrow(question, why)\n",
        "        arrow.set_stroke(YELLOW, 5)\n",
        "\n",
        "        self.play(\n",
        "            why.animate.set_color(YELLOW),\n",
        "            Write(question),\n",
        "            ShowCreation(arrow),\n",
        "            LaggedStart(*(\n",
        "                pi.change(mode, question)\n",
        "                for pi, mode in zip(self.pi_creatures, (\"well\", \"erm\", \"sassy\", \"hesitant\"))\n",
        "            ))\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        cross = Cross(question)\n",
        "        cross.set_stroke(RED, [1, *4 * [8], 1])\n",
        "        words = Text(\"Surprisingly answerable!\")\n",
        "        words.next_to(question, RIGHT, LARGE_BUFF)\n",
        "        new_arrow = Arrow(words[:10], why)\n",
        "        new_arrow.set_stroke(WHITE, 5)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"erm\"),\n",
        "            ShowCreation(cross),\n",
        "            FadeIn(words),\n",
        "            ShowCreation(new_arrow),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class NextVideoWrapper(VideoWrapper):\n",
        "    title = \"Next video\"\n",
        "\n",
        "\n",
        "class PeculiarBoundaryProperty(Scene):\n",
        "    coefs = [-1, 0, 0, 1]\n",
        "    colors = [RED_E, TEAL_E, BLUE_E]\n",
        "\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = Text(\"Peculiar property\", font_size=60)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        title.set_stroke(BLACK, 5, background=True)\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "        underline.set_width(title.get_width() + 1)\n",
        "        underline.insert_n_curves(20)\n",
        "        underline.set_stroke(BLUE, [1, *5 * [3], 1])\n",
        "\n",
        "        subtitle = OldTexText(\n",
        "            \"Boundary of one color\",\n",
        "            \" = \"\n",
        "            \"Boundary of any other\",\n",
        "            tex_to_color_map={\n",
        "                \"one color\": BLUE_D,\n",
        "                \"any other\": RED_D,\n",
        "            }\n",
        "        )\n",
        "        subtitle.next_to(underline, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        # Setup for planes\n",
        "        grid = VGroup(*(\n",
        "            ComplexPlane(\n",
        "                x_range=(-3, 3),\n",
        "                y_range=(-2, 2),\n",
        "            )\n",
        "            for n in range(6)\n",
        "        ))\n",
        "\n",
        "        grid.arrange_in_grid(2, 3, v_buff=2, h_buff=3)\n",
        "        grid.set_width(FRAME_WIDTH - 2)\n",
        "        grid.to_edge(DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        bound_words = VGroup()\n",
        "        for p1, p2 in zip(grid[:3], grid[3:]):\n",
        "            arrow = Arrow(p1, p2, stroke_width=4, buff=0.1)\n",
        "            arrows.add(arrow)\n",
        "            bound_word = Text(\"Boundary\", font_size=24)\n",
        "            bound_word.next_to(arrow, RIGHT, buff=SMALL_BUFF)\n",
        "            bound_words.add(bound_word)\n",
        "\n",
        "        low_equals = VGroup(\n",
        "            OldTex(\"=\").move_to(grid[3:5]),\n",
        "            OldTex(\"=\").move_to(grid[4:6]),\n",
        "        )\n",
        "\n",
        "        # Fractals\n",
        "        fractals = Group(*(\n",
        "            NewtonFractal(plane, coefs=self.coefs, colors=self.colors)\n",
        "            for plane in grid\n",
        "        ))\n",
        "        alpha = 0.2\n",
        "        for k in 0, 3:\n",
        "            fractals[0 + k].set_opacities(alpha, 1, alpha)\n",
        "            fractals[1 + k].set_opacities(alpha, alpha, 1)\n",
        "            fractals[2 + k].set_opacities(1, alpha, alpha)\n",
        "\n",
        "        boxes = VGroup(*(\n",
        "            SurroundingRectangle(fractal, buff=0)\n",
        "            for fractal in fractals\n",
        "        ))\n",
        "        boxes.set_stroke(GREY_B, 1)\n",
        "\n",
        "        # Initial fractal\n",
        "        big_plane = grid[0].deepcopy()\n",
        "        big_plane.set_height(6.5)\n",
        "        big_plane.center().to_edge(DOWN)\n",
        "        big_fractal = NewtonFractal(big_plane, coefs=self.coefs, colors=self.colors)\n",
        "        big_julia = big_fractal.copy()\n",
        "        big_julia.set_julia_highlight(1e-3)\n",
        "        big_julia.set_colors(3 * [WHITE])\n",
        "\n",
        "        self.add(big_fractal)\n",
        "\n",
        "        # Animations\n",
        "        def get_show_border_anims(fractal):\n",
        "            f_copy = fractal.copy()\n",
        "            fractal.set_julia_highlight(5e-3)\n",
        "            fractal.set_colors(3 * [WHITE])\n",
        "            return (FadeOut(f_copy), GrowFromCenter(fractal))\n",
        "\n",
        "        def high_to_low_anims(index):\n",
        "            return (\n",
        "                ShowCreation(arrows[index]),\n",
        "                FadeIn(bound_words[index]),\n",
        "                TransformFromCopy(fractals[index], fractals[index + 3]),\n",
        "                TransformFromCopy(boxes[index], boxes[index + 3]),\n",
        "            )\n",
        "\n",
        "        self.add(underline, title)\n",
        "        self.play(\n",
        "            ShowCreation(underline),\n",
        "            GrowFromCenter(big_julia, run_time=4)\n",
        "        )\n",
        "        self.play(\n",
        "            big_julia.animate.set_julia_highlight(0.02).set_colors(CUBIC_COLORS).set_opacity(0)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            big_fractal.animate.set_opacities(alpha, alpha, 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(big_fractal, fractals[1]),\n",
        "            FadeIn(subtitle[:2]),\n",
        "            ReplacementTransform(\n",
        "                boxes[1].copy().replace(big_fractal).set_opacity(0),\n",
        "                boxes[1],\n",
        "            ),\n",
        "        )\n",
        "        self.play(*high_to_low_anims(1))\n",
        "        self.play(*get_show_border_anims(fractals[4]))\n",
        "        self.wait(2)\n",
        "\n",
        "        subtitle[2:].set_opacity(0)\n",
        "        self.add(subtitle[2:])\n",
        "        for i in 2, 0:\n",
        "            self.play(\n",
        "                FadeIn(fractals[i]),\n",
        "                FadeIn(boxes[i]),\n",
        "                subtitle[2:].animate.set_opacity(1),\n",
        "            )\n",
        "            self.play(*high_to_low_anims(i))\n",
        "            self.play(*get_show_border_anims(fractals[i + 3]))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(Write(low_equals))\n",
        "\n",
        "\n",
        "class DefineBoundary(Scene):\n",
        "    def construct(self):\n",
        "        # Add set\n",
        "        blob = VMobject()\n",
        "        blob.set_fill(BLUE_E, 1)\n",
        "        blob.set_stroke(width=0)\n",
        "        blob.set_points_as_corners([\n",
        "            (1 + 0.3 * random.random()) * p\n",
        "            for p in compass_directions(12)\n",
        "        ])\n",
        "        blob.close_path()\n",
        "        blob.set_height(3)\n",
        "        blob.set_width(1.0, stretch=True)\n",
        "        blob.move_to(2 * RIGHT)\n",
        "        blob.apply_complex_function(np.exp)\n",
        "        blob.make_smooth()\n",
        "        blob.rotate(90 * DEGREES)\n",
        "        blob.center()\n",
        "        blob.set_height(4)\n",
        "        blob.insert_n_curves(50)\n",
        "\n",
        "        set_text = Text(\"Set\", font_size=72)\n",
        "        set_text.set_stroke(BLACK, 3, background=True)\n",
        "        set_text.move_to(interpolate(blob.get_top(), blob.get_bottom(), 0.35))\n",
        "\n",
        "        self.add(blob)\n",
        "        self.add(set_text)\n",
        "\n",
        "        # Preview boundary\n",
        "        point = Dot(radius=0.05)\n",
        "        point.move_to(blob.get_start())\n",
        "\n",
        "        boundary_word = Text(\"Boundary\")\n",
        "        boundary_word.set_color(YELLOW)\n",
        "        boundary_word.next_to(blob, LEFT)\n",
        "        outline = blob.copy()\n",
        "        outline.set_fill(opacity=0)\n",
        "        outline.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.add(point)\n",
        "\n",
        "        kw = {\n",
        "            \"rate_func\": bezier([0, 0, 1, 1]),\n",
        "            \"run_time\": 5,\n",
        "        }\n",
        "        self.play(\n",
        "            FadeIn(boundary_word),\n",
        "            ShowCreation(outline, **kw),\n",
        "            MoveAlongPath(point, blob, **kw)\n",
        "        )\n",
        "        self.play(FadeOut(outline))\n",
        "\n",
        "        # Mention formality\n",
        "        boundary_word.generate_target()\n",
        "        boundary_word.target.to_corner(UL)\n",
        "        formally_word = Text(\"More formally\")\n",
        "        formally_word.next_to(boundary_word.target, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(boundary_word),\n",
        "            FadeTransform(boundary_word.copy(), formally_word)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Draw circle\n",
        "        circle = Circle()\n",
        "        circle.move_to(point)\n",
        "        circle.set_stroke(TEAL, 3.0)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            point.animate.scale(0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        group = VGroup(blob, set_text)\n",
        "        self.add(group, point, circle)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                group.scale, 2, {\"about_point\": point.get_center()},\n",
        "                run_time=4\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                circle.set_height, 0.5,\n",
        "                run_time=2,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Labels\n",
        "        inside_words = Text(\"Points inside\", font_size=36)\n",
        "        outside_words = Text(\"Points outside\", font_size=36)\n",
        "        inside_words.next_to(circle, DOWN, buff=0.5).shift(0.5 * LEFT)\n",
        "        outside_words.next_to(circle, UP, buff=0.5).shift(0.5 * RIGHT)\n",
        "        inside_arrow = Arrow(\n",
        "            inside_words, point,\n",
        "            stroke_width=3,\n",
        "            buff=0.1,\n",
        "        )\n",
        "        outside_arrow = Arrow(\n",
        "            outside_words, point,\n",
        "            stroke_width=3,\n",
        "            buff=0.1,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(inside_words),\n",
        "            ShowCreation(inside_arrow)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(outside_words),\n",
        "            ShowCreation(outside_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show interior\n",
        "        point_group = VGroup(point, circle)\n",
        "\n",
        "        self.play(\n",
        "            point_group.animate.shift(circle.get_height() * DOWN / 4),\n",
        "            LaggedStartMap(\n",
        "                FadeOut, VGroup(inside_words, inside_arrow, outside_words, outside_arrow)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(circle.animate.set_height(0.2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show exterior\n",
        "        point_group.generate_target()\n",
        "        point_group.target.move_to(blob.get_start() + 0.25 * UP)\n",
        "        point_group.target[1].set_height(1.0)\n",
        "\n",
        "        self.play(MoveToTarget(point_group))\n",
        "        self.wait()\n",
        "        self.play(circle.animate.set_height(0.2))\n",
        "        self.wait()\n",
        "\n",
        "        # Back to boundary\n",
        "        self.play(point_group.animate.move_to(blob.get_start()))\n",
        "        frame = self.camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.set_height(0.2)\n",
        "        frame.target.move_to(point)\n",
        "        point_group.generate_target()\n",
        "        point_group.target.set_height(0.2 / 8)\n",
        "        point_group.target[1].set_stroke(width=0.1)\n",
        "\n",
        "        self.play(MoveToTarget(point_group))\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "\n",
        "class VariousCirclesOnTheFractal(SimpleFractalScene):\n",
        "    coefs = [-1.0, 0.0, 0.0, 1.0]\n",
        "    colors = CUBIC_COLORS\n",
        "    sample_density = 0.02\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        frame = self.camera.frame\n",
        "        plane = self.plane\n",
        "        fractal = self.fractal\n",
        "        frame.save_state()\n",
        "\n",
        "        # Setup samples\n",
        "        n_steps = 20\n",
        "        density = self.sample_density\n",
        "        samples = np.array([\n",
        "            [complex(x, y), 0]\n",
        "            for x in np.arange(0, 2, density)\n",
        "            for y in np.arange(0, 2, density)\n",
        "        ])\n",
        "        roots = coefficients_to_roots(self.coefs)\n",
        "        for i in range(len(samples)):\n",
        "            z = samples[i, 0]\n",
        "            for n in range(n_steps):\n",
        "                z = z - poly(z, self.coefs) / dpoly(z, self.coefs)\n",
        "            norms = [abs(z - root) for root in roots]\n",
        "            samples[i, 1] = np.argmin(norms)\n",
        "\n",
        "        unit_size = plane.get_x_unit_size()\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(WHITE, 3.0)\n",
        "        circle.move_to(2 * UR)\n",
        "\n",
        "        words = VGroup(\n",
        "            Text(\"#Colors inside: \"),\n",
        "            Integer(3),\n",
        "        )\n",
        "        words.arrange(RIGHT)\n",
        "        words[1].align_to(words[0][-2], DOWN)\n",
        "        height_ratio = words.get_height() / FRAME_HEIGHT\n",
        "\n",
        "        def get_interior_count(circle):\n",
        "            radius = circle.get_height() / 2 / unit_size\n",
        "            norms = abs(samples[:, 0] - plane.p2n(circle.get_center()))\n",
        "            true_result = len(set(samples[norms < radius, 1]))\n",
        "            # In principle this would work, but the samples are not perfect\n",
        "            return 3 if true_result > 1 else 1\n",
        "\n",
        "        def get_frame_ratio():\n",
        "            return frame.get_height() / FRAME_HEIGHT\n",
        "\n",
        "        def update_words(words):\n",
        "            words.set_height(height_ratio * frame.get_height())\n",
        "            ratio = get_frame_ratio()\n",
        "            words.next_to(circle, UP, buff=SMALL_BUFF * ratio)\n",
        "            count = get_interior_count(circle)\n",
        "            words[1].set_value(count)\n",
        "            words.set_stroke(BLACK, 5 * ratio, background=True)\n",
        "            return words\n",
        "\n",
        "        words.add_updater(update_words)\n",
        "\n",
        "        circle.add_updater(lambda m: m.set_stroke(width=3.0 * get_frame_ratio()))\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(FadeIn(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(circle.animate.set_height(0.25))\n",
        "        self.wait()\n",
        "        point = plane.c2p(0.5, 0.5)\n",
        "        self.play(circle.animate.move_to(point))\n",
        "        self.play(frame.animate.set_height(2).move_to(point))\n",
        "        self.wait()\n",
        "        point = plane.c2p(0.25, 0.4)\n",
        "        self.play(circle.animate.move_to(point).set_height(0.1))\n",
        "        self.wait()\n",
        "        for xy in (0.6, 0.4), (0.2, 0.6):\n",
        "            self.play(\n",
        "                circle.animate.move_to(plane.c2p(*xy)),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Back to larger\n",
        "        self.play(\n",
        "            Restore(frame),\n",
        "            circle.animate.set_height(0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show smooth boundary\n",
        "        count_tracker = ValueTracker(3)\n",
        "        words.add_updater(lambda m: m[1].set_value(count_tracker.get_value()))\n",
        "\n",
        "        def change_count_at(new_value, alpha):\n",
        "            curr_value = count_tracker.get_value()\n",
        "            return UpdateFromAlphaFunc(\n",
        "                count_tracker,\n",
        "                lambda m, a: m.set_value(curr_value if a < alpha else new_value)\n",
        "            )\n",
        "\n",
        "        fractal.set_n_steps(10)\n",
        "        self.play(\n",
        "            fractal.animate.set_n_steps(3),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            circle.animate.move_to(plane.c2p(0, 0.3)),\n",
        "            change_count_at(2, 0.75),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            circle.animate.move_to(plane.c2p(0, 0)),\n",
        "            change_count_at(3, 0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            circle.animate.move_to(plane.c2p(-0.6, 0.2)),\n",
        "            Succession(\n",
        "                change_count_at(2, 0.9),\n",
        "                change_count_at(3, 0.7),\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            circle.animate.set_height(0.1).move_to(plane.c2p(-0.6, 0.24)),\n",
        "            change_count_at(2, 0.8),\n",
        "            frame.animate.set_height(2.5).move_to(plane.c2p(-0.5, 0.5)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            fractal.animate.set_n_steps(20),\n",
        "            change_count_at(3, 0.1),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Just show boundary\n",
        "        boundary = fractal.copy()\n",
        "        boundary.set_colors(3 * [WHITE])\n",
        "        boundary.add_updater(\n",
        "            lambda m: m.set_julia_highlight(get_frame_ratio() * 1e-3)\n",
        "        )\n",
        "        boundary.set_n_steps(50)\n",
        "\n",
        "        frame.generate_target()\n",
        "        frame.target.set_height(0.0018),\n",
        "        frame.target.move_to([-1.15535091, 0.23001433, 0.])\n",
        "        self.play(\n",
        "            FadeOut(circle),\n",
        "            FadeOut(words),\n",
        "            FadeOut(self.root_dots),\n",
        "            GrowFromCenter(boundary, run_time=3),\n",
        "            fractal.animate.set_opacity(0.35),\n",
        "            MoveToTarget(\n",
        "                frame,\n",
        "                run_time=10,\n",
        "                rate_func=bezier([0, 0, 1, 1, 1, 1, 1])\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ArtPuzzle(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            Text(\"Art Puzzle:\", font_size=60),\n",
        "            OldTexText(\"- Use $\\\\ge 3$ colors\"),\n",
        "            OldTexText(\"- Boundary of one color = Boundary of all\"),\n",
        "        )\n",
        "        words.set_color(BLACK)\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        words[1:].shift(0.5 * DOWN + 0.5 * RIGHT)\n",
        "        words.to_corner(UL)\n",
        "\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word, lag_ratio=0.1))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ZoomInOnCubic(ThreeRootFractal):\n",
        "    colors = CUBIC_COLORS\n",
        "    coefs = [complex(0, -1), 0, 0, 1]\n",
        "    n_steps = 30\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        height_exp_tracker = ValueTracker()\n",
        "        get_height_exp = height_exp_tracker.get_value\n",
        "        center_tracker = VectorizedPoint(ORIGIN)\n",
        "\n",
        "        frame.add_updater(lambda m: m.move_to(center_tracker))\n",
        "        frame.add_updater(lambda m: m.set_height(FRAME_HEIGHT * 2**(-get_height_exp())))\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(center_tracker.move_to, [0.2986952, 1.11848235, 0], run_time=4),\n",
        "            ApplyMethod(\n",
        "                height_exp_tracker.set_value, 7,\n",
        "                run_time=15,\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BlobsOnBlobsOnBlobs(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Blobs\", *(\n",
        "                \" on blobs \" + (\"\\\\\\\\\" if n == 2 else \"\")\n",
        "                for n in range(6)\n",
        "            ),\n",
        "            \"...\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 2)\n",
        "        words.to_edge(UP)\n",
        "        words.set_color(BLACK)\n",
        "        self.add(words[0])\n",
        "        for word in words[1:]:\n",
        "            self.play(FadeIn(word, 0.25 * UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FractalDimensionWords(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Fractal dimension $\\\\approx$ 1.44\", font_size=60)\n",
        "        text.to_corner(UL)\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThinkAboutWhatPropertyMeans(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.screen.set_height(4, about_edge=UL)\n",
        "        self.add(self.screen)\n",
        "        image = ImageMobject(\"NewtonBoundaryProperty\")\n",
        "        image.replace(self.screen)\n",
        "        self.add(image)\n",
        "\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Think about what\\\\\\\\this tells us.\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            }\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"pondering\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class InterpretBoundaryProperty(RepeatedNewton):\n",
        "    plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"height\": 12,\n",
        "        \"width\": 24,\n",
        "    }\n",
        "    n_steps = 15\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        plane = self.plane\n",
        "        plane.shift(2 * RIGHT)\n",
        "        self.add_true_roots()\n",
        "        self.add_labels()\n",
        "        self.add_fractal_background()\n",
        "\n",
        "        # Show sensitive point\n",
        "        point = plane.c2p(-0.8, 0.4)\n",
        "        dots = self.dots = DotCloud()\n",
        "        dots.set_points([\n",
        "            [r * math.cos(theta), r * math.sin(theta), 0]\n",
        "            for r in np.linspace(0, 1, 20)\n",
        "            for theta in np.linspace(0, TAU, int(r * 20)) + random.random() * TAU\n",
        "        ])\n",
        "        dots.set_height(2).center()\n",
        "        dots.filter_out(lambda p: get_norm(p) > 1)\n",
        "        dots.set_height(0.3)\n",
        "        dots.set_radius(0.04)\n",
        "        dots.make_3d()\n",
        "        dots.set_color(GREY_A)\n",
        "        dots.move_to(point)\n",
        "\n",
        "        sensitive_words = Text(\"Sensitive area\")\n",
        "        sensitive_words.next_to(dots, RIGHT, buff=SMALL_BUFF)\n",
        "        sensitive_words.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        def get_arrows():\n",
        "            root_dots = self.root_dots\n",
        "            if plane.p2n(dots.get_center()).real < -1.25:\n",
        "                root_dots = [root_dots[4]]\n",
        "            return VGroup(*(\n",
        "                Arrow(\n",
        "                    dots, root_dot,\n",
        "                    buff=0.1,\n",
        "                    stroke_color=root_dot[0].get_color()\n",
        "                )\n",
        "                for root_dot in root_dots\n",
        "            ))\n",
        "\n",
        "        arrows = get_arrows()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dots, scale=2),\n",
        "            FadeIn(sensitive_words, shift=0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrows[2]))\n",
        "        self.play(ShowCreation(arrows[4]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(sensitive_words),\n",
        "            LaggedStartMap(ShowCreation, VGroup(*(\n",
        "                arrows[i] for i in (0, 1, 3)\n",
        "            )))\n",
        "        )\n",
        "        self.wait()\n",
        "        arrows.add_updater(lambda m: m.become(get_arrows()))\n",
        "        self.add(arrows)\n",
        "\n",
        "        self.play(dots.animate.move_to(plane.c2p(-1.4, 0.4)), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(dots.animate.move_to(point), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        not_allowed = Text(\"Not allowed!\")\n",
        "        not_allowed.set_color(RED)\n",
        "        not_allowed.set_stroke(BLACK, 8, background=True)\n",
        "        not_allowed.next_to(dots, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        arrows.clear_updaters()\n",
        "        self.play(\n",
        "            arrows[:2].animate.set_opacity(0),\n",
        "            FadeIn(not_allowed, scale=0.7)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrows), FadeOut(not_allowed))\n",
        "\n",
        "        # For fun\n",
        "        self.run_iterations()\n",
        "\n",
        "\n",
        "class CommentsOnNaming(Scene):\n",
        "    def construct(self):\n",
        "        self.setup_table()\n",
        "        self.show_everyone()\n",
        "\n",
        "    def setup_table(self):\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"How it started\", font_size=60),\n",
        "            OldTexText(\"How it's going\", font_size=60),\n",
        "        )\n",
        "        titles.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        titles.set_color(GREY_A)\n",
        "        titles[0].set_x(-FRAME_WIDTH / 4)\n",
        "        titles[1].set_x(FRAME_WIDTH / 4)\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(titles, DOWN).set_x(0)\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        lines = VGroup(h_line, v_line)\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.left_point = [-FRAME_WIDTH / 4, -1, 0]\n",
        "        self.right_point = [FRAME_WIDTH / 4, -1, 0]\n",
        "\n",
        "        self.add(titles, lines)\n",
        "\n",
        "    def show_everyone(self):\n",
        "        # Newton\n",
        "        newton = get_figure(\n",
        "            \"Newton\", \"Isaac Newton\", \"1643-1727\",\n",
        "            height=4,\n",
        "        )\n",
        "        newton.move_to(self.left_point)\n",
        "\n",
        "        newton_formula = get_newton_rule(var=\"x\")\n",
        "        newton_formula.next_to(newton, UP)\n",
        "\n",
        "        nf_label = OldTexText(\"``Newton's'' fractal\")\n",
        "        nf_label.align_to(newton_formula, UP)\n",
        "        nf_label.set_x(self.right_point[0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(newton_formula),\n",
        "            LaggedStartMap(FadeIn, newton)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(nf_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Hamilton\n",
        "        hamilton = get_figure(\n",
        "            \"Hamilton\", \"William Rowan Hamilton\", \"1805 - 1865\",\n",
        "            height=4,\n",
        "        )\n",
        "        hamilton.move_to(self.left_point)\n",
        "        hamiltons_equation = OldTex(\n",
        "            r\"\\frac{\\mathrm{d} \\boldsymbol{q}}{\\mathrm{d} t}=\\frac{\\partial \\mathcal{H}}{\\partial \\boldsymbol{p}}, \\quad \\frac{\\mathrm{d} \\boldsymbol{p}}{\\mathrm{d} t}=-\\frac{\\partial \\mathcal{H}}{\\partial \\boldsymbol{q}}\"\n",
        "        )\n",
        "        hamiltons_equation.match_width(hamilton[0])\n",
        "        hamiltons_equation.next_to(hamilton, UP)\n",
        "\n",
        "        hamiltonians = Text(\"Hamiltonians\")\n",
        "        hamiltonians.move_to(nf_label)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(newton, shift=0.25 * LEFT),\n",
        "                FadeOut(newton_formula, shift=0.25 * LEFT),\n",
        "                FadeOut(nf_label, shift=0.25 * RIGHT),\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(hamilton, shift=0.25 * LEFT),\n",
        "                FadeIn(hamiltons_equation, shift=0.25 * LEFT),\n",
        "                FadeIn(hamiltonians, shift=0.25 * RIGHT),\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Fourier\n",
        "        fourier = get_figure(\n",
        "            \"Joseph Fourier\", \"Joseph Fourier\", \"1768-1830\",\n",
        "            height=4\n",
        "        )\n",
        "        fourier.move_to(self.left_point)\n",
        "        fourier_transform = OldTex(\n",
        "            r\"f(t)=\\int_{0}^{\\infty}(a(\\lambda) \\cos (2 \\pi \\lambda t)+b(\\lambda) \\sin (2 \\pi \\lambda t)) d \\lambda\"\n",
        "        )\n",
        "        fourier_transform.set_width(fourier.get_width() * 1.5)\n",
        "        fourier_transform.next_to(fourier, UP)\n",
        "\n",
        "        FFT = Text(\"FFT\")\n",
        "        FFT.move_to(hamiltonians)\n",
        "\n",
        "        FFT_diagram = ImageMobject(\"FFT_Diagram\")\n",
        "        FFT_diagram.move_to(self.right_point),\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(hamilton, shift=0.25 * LEFT),\n",
        "                FadeOut(hamiltons_equation, shift=0.25 * LEFT),\n",
        "                FadeOut(hamiltonians, shift=0.25 * RIGHT),\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(fourier, shift=0.25 * LEFT),\n",
        "                FadeIn(fourier_transform, shift=0.25 * LEFT),\n",
        "                FadeIn(FFT, shift=0.25 * RIGHT),\n",
        "            ),\n",
        "            FadeIn(FFT_diagram),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Everyone\n",
        "        people = Group(newton, hamilton, fourier)\n",
        "        people.generate_target()\n",
        "        people.target.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        people.target.set_height(6.4)\n",
        "        people.target.move_to(self.left_point)\n",
        "        people.target.to_edge(DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(fourier_transform),\n",
        "            FadeOut(FFT),\n",
        "            MoveToTarget(people, run_time=2),\n",
        "            FFT_diagram.animate.scale(1 / 3).match_y(people.target[2]),\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(\n",
        "            fourier, FFT_diagram,\n",
        "            buff=1.0,\n",
        "            stroke_width=8\n",
        "        )\n",
        "        arrows = VGroup(\n",
        "            arrow.copy().match_y(newton),\n",
        "            arrow.copy().match_y(hamilton),\n",
        "            arrow,\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, arrows, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MakeFunOfNextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"``Next part''...I've\\\\\\\\heard that before.\"),\n",
        "            target_mode=\"sassy\",\n",
        "            index=2,\n",
        "            added_anims=[LaggedStart(\n",
        "                self.teacher.change(\"guilty\"),\n",
        "                self.students[0].change(\"sassy\"),\n",
        "                self.students[1].change(\"hesitant\"),\n",
        "            )]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Wait, for real\\\\\\\\this time!\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 3,\n",
        "            },\n",
        "            target_mode=\"speaking\",\n",
        "            added_anims=[\n",
        "                self.students[0].change(\"hesitant\"),\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class Part1EndScroll(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"title_text\": \"\",\n",
        "        \"scroll_time\": 60,\n",
        "        \"show_pis\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class Thanks(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer(mode=\"happy\")\n",
        "        thanks = Text(\"Thank you\")\n",
        "        thanks.next_to(morty, LEFT)\n",
        "        self.play(\n",
        "            morty.change(\"gracious\"),\n",
        "            FadeIn(thanks, lag_ratio=0.1)\n",
        "        )\n",
        "        for n in range(5):\n",
        "            self.play(morty.animate.look([DL, DR][n % 2]))\n",
        "            self.wait(random.random() * 5)\n",
        "            self.play(Blink(morty))\n",
        "\n",
        "\n",
        "class HolomorphicDynamics(Scene):\n",
        "    def construct(self):\n",
        "        self.ask_about_property()\n",
        "        self.repeated_functions()\n",
        "\n",
        "    def ask_about_property(self):\n",
        "        back_plane = FullScreenRectangle()\n",
        "        self.add(back_plane)\n",
        "\n",
        "        image = ImageMobject(\"NewtonBoundaryProperty\")\n",
        "        border = SurroundingRectangle(image, buff=0)\n",
        "        border.set_stroke(WHITE, 2)\n",
        "        image = Group(border, image)\n",
        "        image.set_height(FRAME_HEIGHT)\n",
        "\n",
        "        image.generate_target()\n",
        "        image.target.set_height(6)\n",
        "        image.target.to_corner(DL)\n",
        "\n",
        "        question = Text(\"Why is this true?\")\n",
        "        question.to_corner(UR)\n",
        "        arrow = Arrow(\n",
        "            question.get_left(), image.target.get_top() + RIGHT,\n",
        "            path_arc=45 * DEGREES\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            image.animate.set_height(6).to_corner(DL),\n",
        "            Write(question),\n",
        "            ShowCreation(arrow, rate_func=squish_rate_func(smooth, 0.5, 1), run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        title = self.title = Text(\"Holomorphic Dynamics\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            image.animate.set_height(1).to_corner(DL),\n",
        "            FadeOut(question, shift=DL, scale=0.2),\n",
        "            FadeOut(arrow, shift=DL, scale=0.2),\n",
        "            FadeIn(title, shift=3 * DL, scale=0.5),\n",
        "            FadeOut(back_plane),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.image = image\n",
        "\n",
        "    def repeated_functions(self):\n",
        "        basic_expr = OldTex(\n",
        "            \"z\", \"\\\\rightarrow \", \" f(z)\"\n",
        "        )\n",
        "        fz = basic_expr.get_part_by_tex(\"f(z)\")\n",
        "        basic_expr.next_to(self.title, DOWN, LARGE_BUFF)\n",
        "        basic_expr.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        brace = Brace(fz, DOWN)\n",
        "        newton = OldTex(\"z - {P(z) \\\\over P'(z)}\")\n",
        "        newton.next_to(brace, DOWN)\n",
        "        newton.align_to(basic_expr[1], LEFT)\n",
        "        newton_example = OldTex(\"z - {z^3 + z - 1 \\\\over 3z^2 + 1}\")\n",
        "        eq = OldTex(\"=\").rotate(PI / 2)\n",
        "        eq.next_to(newton, DOWN)\n",
        "        newton_example.next_to(eq, DOWN)\n",
        "\n",
        "        newton_group = VGroup(newton, eq, newton_example)\n",
        "        newton_group.generate_target()\n",
        "        newton_group.target[1].rotate(-PI / 2)\n",
        "        newton_group.target.arrange(RIGHT, buff=0.2)\n",
        "        newton_group.target[2].shift(SMALL_BUFF * UP)\n",
        "        newton_group.target.scale(0.7)\n",
        "        newton_group.target.to_corner(DL)\n",
        "\n",
        "        mandelbrot = OldTex(\"z^2 + c\")\n",
        "        mandelbrot.next_to(brace, DOWN)\n",
        "\n",
        "        exponential = OldTex(\"a^z\")\n",
        "        exponential.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(basic_expr),\n",
        "            FadeOut(self.image)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.describe_holomorphic(fz, brace)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(newton),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(eq),\n",
        "            FadeIn(newton_example),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(newton_group),\n",
        "            FadeIn(mandelbrot, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mandelbrot.animate.scale(0.7).next_to(newton, UP, LARGE_BUFF, LEFT),\n",
        "            FadeIn(exponential, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show fractals\n",
        "        rhss = VGroup(exponential, mandelbrot, newton)\n",
        "        f_eqs = VGroup()\n",
        "        lhss = VGroup()\n",
        "        for rhs in rhss:\n",
        "            rhs.generate_target()\n",
        "            if rhs is not exponential:\n",
        "                rhs.target.scale(1 / 0.7)\n",
        "            lhs = OldTex(\"f(z) = \")\n",
        "            lhs.next_to(rhs.target, LEFT)\n",
        "            f_eqs.add(VGroup(lhs, rhs.target))\n",
        "            lhss.add(lhs)\n",
        "        f_eqs.arrange(RIGHT, buff=1.5)\n",
        "        f_eqs.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        rects = ScreenRectangle().replicate(3)\n",
        "        rects.arrange(DOWN, buff=0.5)\n",
        "        rects.set_height(6.5)\n",
        "        rects.next_to(ORIGIN, RIGHT, MED_LARGE_BUFF)\n",
        "        rects.to_edge(DOWN, MED_SMALL_BUFF)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        arrows = VGroup()\n",
        "        for rect, f_eq in zip(rects, f_eqs):\n",
        "            arrow = Vector(0.7 * RIGHT)\n",
        "            arrow.next_to(rect, LEFT)\n",
        "            arrows.add(arrow)\n",
        "            f_eq.next_to(arrow, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, rhss),\n",
        "            LaggedStartMap(Write, lhss),\n",
        "            LaggedStartMap(FadeIn, rects),\n",
        "            LaggedStartMap(ShowCreation, arrows),\n",
        "            FadeOut(brace),\n",
        "            basic_expr.animate.to_edge(UP),\n",
        "            FadeOut(newton_group[1:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def describe_holomorphic(self, fz, brace):\n",
        "        self.title.set_stroke(BLACK, 5, background=True)\n",
        "        word = self.title.get_part_by_text(\"Holomorphic\")\n",
        "        underline = Underline(word, buff=-0.05)\n",
        "        underline.scale(1.2)\n",
        "        underline.insert_n_curves(40)\n",
        "        underline.set_stroke(YELLOW, [1, *6 * [3], 1])\n",
        "\n",
        "        self.add(underline, self.title)\n",
        "        self.play(\n",
        "            word.animate.set_fill(YELLOW),\n",
        "            ShowCreation(underline)\n",
        "        )\n",
        "\n",
        "        in_words = Text(\"Complex\\ninputs\", font_size=36)\n",
        "        in_words.to_corner(UL)\n",
        "        in_arrow = Arrow(\n",
        "            in_words.get_right(),\n",
        "            fz[2].get_top(),\n",
        "            path_arc=-80 * DEGREES,\n",
        "            buff=0.2,\n",
        "        )\n",
        "        VGroup(in_words, in_arrow).set_color(YELLOW)\n",
        "\n",
        "        out_words = Text(\"Complex\\noutputs\", font_size=36)\n",
        "        out_words.next_to(brace, DOWN)\n",
        "        out_words.set_color(YELLOW)\n",
        "\n",
        "        f_prime = OldTexText(\"$f'(z)$ exists\")\n",
        "        f_prime.set_color(YELLOW)\n",
        "        f_prime.next_to(underline, DOWN, MED_LARGE_BUFF)\n",
        "        f_prime.match_y(fz)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(in_words),\n",
        "            ShowCreation(in_arrow),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(out_words, lag_ratio=0.05)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(f_prime, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                in_words, in_arrow, out_words, f_prime, underline,\n",
        "            )),\n",
        "            word.animate.set_fill(WHITE)\n",
        "        )\n",
        "\n",
        "\n",
        "class AmbientRepetition(Scene):\n",
        "    n_steps = 30\n",
        "\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        self.add(plane)\n",
        "\n",
        "        font_size = 36\n",
        "\n",
        "        z0 = complex(0, 0)\n",
        "        dot = Dot(color=BLUE)\n",
        "        dot.move_to(plane.n2p(z0))\n",
        "        z_label = OldTex(\"z\", font_size=font_size)\n",
        "        z_label.set_stroke(BLACK, 5, background=True)\n",
        "        z_label.next_to(dot, UP, SMALL_BUFF)\n",
        "        self.add(dot, z_label)\n",
        "\n",
        "        def func(z):\n",
        "            return z**2 + complex(-0.6436875, -0.441)\n",
        "\n",
        "        def get_new_point():\n",
        "            z = plane.p2n(dot.get_center())\n",
        "            return plane.n2p(func(z))\n",
        "\n",
        "        for n in range(self.n_steps):\n",
        "            new_point = get_new_point()\n",
        "            arrow = Arrow(dot.get_center(), new_point, buff=dot.get_height() / 2)\n",
        "\n",
        "            dot_copy = dot.copy()\n",
        "            dot_copy.move_to(new_point)\n",
        "            dot_copy.set_color(YELLOW)\n",
        "            fz_label = OldTex(\"f(z)\", font_size=font_size)\n",
        "            fz_label.set_stroke(BLACK, 8, background=True)\n",
        "            fz_label.next_to(dot_copy, UP, SMALL_BUFF)\n",
        "\n",
        "            self.add(dot, dot_copy, arrow, z_label)\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                TransformFromCopy(dot, dot_copy),\n",
        "                FadeInFromPoint(fz_label, z_label.get_center()),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            to_fade = VGroup(\n",
        "                dot.copy(), z_label.copy(),\n",
        "                dot_copy, arrow, fz_label,\n",
        "            )\n",
        "            dot.move_to(dot_copy)\n",
        "            z_label.next_to(dot, UP, SMALL_BUFF)\n",
        "            self.remove(z_label)\n",
        "            self.play(\n",
        "                *map(FadeOut, to_fade),\n",
        "                FadeIn(z_label),\n",
        "            )\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class BriefMandelbrot(Scene):\n",
        "    n_iterations = 30\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_process_description()\n",
        "        self.show_iterations()\n",
        "        self.wait(10)  # Time to play\n",
        "        self.add_mandelbrot_image()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane((-2, 1), (-2, 2))\n",
        "\n",
        "        plane.set_height(4)\n",
        "        plane.scale(FRAME_HEIGHT / 2.307)\n",
        "        plane.next_to(2 * LEFT, RIGHT, buff=0)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_process_description(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{c}\": YELLOW,\n",
        "            }\n",
        "        }\n",
        "        terms = self.terms = VGroup(\n",
        "            OldTex(\"z_{n + 1} = z_n^2 + {c}\", **kw),\n",
        "            OldTex(\"z_0 = 0\", **kw),\n",
        "            OldTex(\"{c} \\\\text{ can be changed}\", **kw),\n",
        "        )\n",
        "        terms.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        terms.next_to(self.plane, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(terms)\n",
        "\n",
        "    def show_iterations(self):\n",
        "        plane = self.plane\n",
        "\n",
        "        c0 = complex(-0.2, 0.95)\n",
        "\n",
        "        c_dot = self.c_dot = Dot()\n",
        "        c_dot.set_fill(YELLOW)\n",
        "        c_dot.set_stroke(BLACK, 5, background=True)\n",
        "        c_dot.move_to(plane.n2p(c0))\n",
        "\n",
        "        lines = VGroup()\n",
        "        lines.set_stroke(background=True)\n",
        "\n",
        "        def get_c():\n",
        "            return plane.p2n(c_dot.get_center())\n",
        "\n",
        "        def update_lines(lines):\n",
        "            z1 = 0\n",
        "            c = get_c()\n",
        "            new_lines = []\n",
        "\n",
        "            for n in range(self.n_iterations):\n",
        "                try:\n",
        "                    z2 = z1**2 + c\n",
        "                    new_lines.append(Line(\n",
        "                        plane.n2p(z1),\n",
        "                        plane.n2p(z2),\n",
        "                        stroke_color=GREY,\n",
        "                        stroke_width=2,\n",
        "                    ))\n",
        "                    new_lines.append(Dot(\n",
        "                        plane.n2p(z2),\n",
        "                        fill_color=YELLOW,\n",
        "                        fill_opacity=0.5,\n",
        "                        radius=0.05,\n",
        "                    ))\n",
        "                    z1 = z2\n",
        "                except Exception:\n",
        "                    pass\n",
        "\n",
        "            lines.set_submobjects(new_lines)\n",
        "\n",
        "        update_lines(lines)\n",
        "        self.add(lines[:2], c_dot)\n",
        "        last_dot = Dot(plane.n2p(0)).scale(0)\n",
        "        for line, dot in zip(lines[0:20:2], lines[1:20:2]):\n",
        "            self.add(line, dot, c_dot)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                TransformFromCopy(last_dot, dot)\n",
        "            )\n",
        "            last_dot = dot\n",
        "        self.remove(*lines)\n",
        "        lines.add_updater(update_lines)\n",
        "        self.add(lines, c_dot)\n",
        "\n",
        "    def add_mandelbrot_image(self):\n",
        "        image = ImageMobject(\"MandelbrotSet\")\n",
        "        image.set_height(FRAME_HEIGHT)\n",
        "        image.shift(self.plane.n2p(-0.7) - image.get_center())\n",
        "\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.next_to(self.plane, LEFT, buff=0)\n",
        "\n",
        "        self.add(image, rect, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeIn(image, run_time=2),\n",
        "            self.plane.animate.set_opacity(0.5)\n",
        "        )\n",
        "\n",
        "    def on_mouse_press(self, point, button, mods):\n",
        "        # TODO, copy-pasted, should factor out\n",
        "        super().on_mouse_press(point, button, mods)\n",
        "        mob = self.point_to_mobject(point, search_set=[self.c_dot])\n",
        "        if mob is None:\n",
        "            return\n",
        "        self.mouse_drag_point.move_to(point)\n",
        "        mob.add_updater(lambda m: m.move_to(self.mouse_drag_point))\n",
        "        self.unlock_mobject_data()\n",
        "        self.lock_static_mobject_data()\n",
        "\n",
        "    def on_mouse_release(self, point, button, mods):\n",
        "        super().on_mouse_release(point, button, mods)\n",
        "        self.c_dot.clear_updaters()\n",
        "\n",
        "\n",
        "class CyclicAttractor(RepeatedNewton):\n",
        "    coefs = [2, -2, 0, 1]\n",
        "    n_steps = 20\n",
        "    show_coloring = False\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "\n",
        "    def add_plane(self):\n",
        "        super().add_plane()\n",
        "        self.plane.axes.set_stroke(GREY_B, 1)\n",
        "\n",
        "    def add_labels(self):\n",
        "        super().add_labels()\n",
        "        eq = self.corner_group[1]\n",
        "        self.play(FlashAround(eq, run_time=3))\n",
        "\n",
        "    def get_original_points(self):\n",
        "        return [\n",
        "            (r * np.cos(theta), r * np.sin(theta), 0)\n",
        "            for r in np.linspace(0, 0.2, 10)\n",
        "            for theta in np.linspace(0, TAU, int(50 * r)) + TAU * np.random.random()\n",
        "        ]\n",
        "\n",
        "\n",
        "class HighlightedJulia(IntroNewtonFractal):\n",
        "    coefs = [-1.0, 0.0, 0.0, 1.0, 0.0, 1.0]\n",
        "\n",
        "    def construct(self):\n",
        "        # self.init_fractal(root_colors=ROOT_COLORS_DEEP[0::2])\n",
        "        self.init_fractal(root_colors=ROOT_COLORS_DEEP)\n",
        "        fractal = self.fractal\n",
        "\n",
        "        def get_height_ratio():\n",
        "            return self.camera.frame.get_height() / FRAME_HEIGHT\n",
        "\n",
        "        fractal.set_colors(5 * [WHITE])\n",
        "        fractal.add_updater(lambda m: m.set_julia_highlight(get_height_ratio() * 1e-3))\n",
        "        fractal.set_n_steps(50)\n",
        "        # self.play(\n",
        "        #     fractal.animate.set_julia_highlight(1e-3),\n",
        "        #     run_time=5\n",
        "        # )\n",
        "\n",
        "        # self.embed()\n",
        "\n",
        "\n",
        "class MontelCorrolaryScreenGrab(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class MetaFractal(IntroNewtonFractal):\n",
        "    fixed_roots = [-1, 1]\n",
        "    z0 = complex(0.5, 0)\n",
        "    n_steps = 200\n",
        "\n",
        "    def construct(self):\n",
        "        colors = ROOT_COLORS_DEEP[0::2]\n",
        "        self.plane_config[\"faded_line_ratio\"] = 3\n",
        "        plane = self.get_plane()\n",
        "        root_dots = self.root_dots = VGroup(*(\n",
        "            Dot(plane.n2p(root), color=color)\n",
        "            for root, color in zip(self.fixed_roots, colors)\n",
        "        ))\n",
        "        root_dots.set_stroke(BLACK, 3)\n",
        "        fractal = MetaNewtonFractal(\n",
        "            plane,\n",
        "            fixed_roots=self.fixed_roots,\n",
        "            colors=colors,\n",
        "            n_steps=self.n_steps,\n",
        "        )\n",
        "        fractal.add_updater(lambda f: f.set_fixed_roots([\n",
        "            plane.p2n(dot.get_center())\n",
        "            for dot in root_dots\n",
        "        ]))\n",
        "\n",
        "        self.add(fractal, plane)\n",
        "        self.add(root_dots)\n",
        "\n",
        "        point1 = np.array([1.62070862, 1.68700851, 0.])\n",
        "        point2 = np.array([0.81263967, 2.84042313, 0.])\n",
        "        height1 = 0.083\n",
        "        height2 = 0.035\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.move_to(point1)\n",
        "        frame.target.set_height(height1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            run_time=10,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                frame,\n",
        "                lambda m, a: m.set_height(\n",
        "                    interpolate(\n",
        "                        interpolate(height1, 2, a),\n",
        "                        interpolate(2, height2, a),\n",
        "                        a,\n",
        "                    ),\n",
        "                ).move_to(\n",
        "                    interpolate(point1, point2, a)\n",
        "                )\n",
        "            ),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "\n",
        "class Thumbnail2(SimpleFractalScene):\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        fractal = self.fractal\n",
        "        fractal.set_saturation_factor(4.5)\n",
        "        self.remove(self.plane)\n",
        "        self.remove(self.root_dots)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(4)\n",
        "\n",
        "        fc = fractal.copy()\n",
        "        fc.set_saturation_factor(2)\n",
        "        fc.set_julia_highlight(0.01)\n",
        "        self.add(fc)\n",
        "\n",
        "        # self.clear()\n",
        "        # back = fractal.copy()\n",
        "        # back.set_saturation_factor(0)\n",
        "        # back.set_opacity(0.1)\n",
        "        # self.add(back)\n",
        "\n",
        "        # N = 20\n",
        "        # for x in np.linspace(np.log(1e-3), np.log(0.1), N):\n",
        "        #     jh = np.exp(x)\n",
        "        #     fc = fractal.copy()\n",
        "        #     fc.set_saturation_factor(1)\n",
        "        #     fc.set_julia_highlight(jh)\n",
        "        #     fc.set_opacity(2 / N)\n",
        "        #     self.add(fc)\n",
        "\n",
        "        self.embed()\n"
    ]
}