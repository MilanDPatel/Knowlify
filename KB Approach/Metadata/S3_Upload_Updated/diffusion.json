{
    "topic": "demonstrates the concept of diffusion in one dimension. It sets up an axes object and adds",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class Diffusion1D(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 100,\n",
        "        \"y_range\": (0, 100, 10),\n",
        "        \"x_range\": (-20, 20),\n",
        "        \"show_y_axis\": False,\n",
        "        \"dot_radius\": 0.07,\n",
        "        \"dot_opacity\": 0.5,\n",
        "        \"dither_dots\": True,\n",
        "        \"total_steps\": 100,\n",
        "        \"clip_at_bounds\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        y_range = self.y_range\n",
        "        x_range = self.x_range\n",
        "\n",
        "        # Set up axes\n",
        "        axes = Axes(\n",
        "            x_range=x_range,\n",
        "            y_range=y_range,\n",
        "            axis_config={\n",
        "                \"stroke_width\": 2,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            width=FRAME_WIDTH,\n",
        "            height=FRAME_HEIGHT - 1,\n",
        "        )\n",
        "\n",
        "        axes.x_axis.add_numbers(\n",
        "            range(*x_range, 5)\n",
        "        )\n",
        "\n",
        "        if self.show_y_axis:\n",
        "            axes.y_axis.add_numbers(\n",
        "                np.arange(*y_range) + y_range[2],\n",
        "                height=0.2,\n",
        "            )\n",
        "        else:\n",
        "            axes.y_axis.scale(0, about_point=axes.c2p(0, 0))\n",
        "\n",
        "        axes.center()\n",
        "        x_unit = axes.c2p(1, 0)[0] - axes.c2p(0, 0)[0]\n",
        "        y_unit = axes.c2p(0, 1)[1] - axes.c2p(0, 0)[1]\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Set up time label\n",
        "        time_label = self.get_time_label()\n",
        "        self.add(time_label)\n",
        "\n",
        "        # Set up dots (make generalizable)\n",
        "        dots = self.get_dots()\n",
        "        dots.move_to(axes.c2p(0, 0))\n",
        "        self.adjust_initial_dot_positions(dots, x_unit)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Set up bars\n",
        "        bars = VGroup()\n",
        "        epsilon = 1e-6\n",
        "\n",
        "        for x in range(x_range[0], x_range[1] + 1):\n",
        "            bar = Rectangle()\n",
        "            bar.x = x\n",
        "            bar.set_width(0.5 * x_unit)\n",
        "            bar.set_height(epsilon, stretch=True)\n",
        "            bar.move_to(axes.c2p(x, 0), DOWN)\n",
        "            bars.add(bar)\n",
        "\n",
        "        bars.set_fill(GREY, 0.8)\n",
        "        bars.set_stroke(GREY_B, 0.2)\n",
        "\n",
        "        def update_bars(bars, dots=dots, y_unit=y_unit, epsilon=epsilon):\n",
        "            for bar in bars:\n",
        "                count = 0\n",
        "                for dot in dots:\n",
        "                    if dot.x == bar.x:\n",
        "                        count += 1\n",
        "                bar.set_height(\n",
        "                    count * y_unit + epsilon,\n",
        "                    about_edge=bar.get_bottom(),\n",
        "                    stretch=True\n",
        "                )\n",
        "\n",
        "        update_bars(bars, dots)\n",
        "\n",
        "        self.add(bars, dots)\n",
        "\n",
        "        # Include rule for updating\n",
        "        def step(dots=dots, bars=bars,\n",
        "                 x_unit=x_unit, x_range=x_range,\n",
        "                 time_label=time_label):\n",
        "            time_label[1].increment_value()\n",
        "            for dot in dots:\n",
        "                u = random.choice([-1, 1])\n",
        "\n",
        "                if self.clip_at_bounds:\n",
        "                    # Boundary condition\n",
        "                    if dot.x == x_range[0]:\n",
        "                        u = max(0, u)\n",
        "                    elif dot.x == x_range[1]:\n",
        "                        u = min(0, u)\n",
        "                dot.shift(u * x_unit * RIGHT)\n",
        "                dot.x += u\n",
        "\n",
        "            update_bars(bars)\n",
        "\n",
        "        # Let it play out.\n",
        "        for t in range(self.total_steps):\n",
        "            if t < 6:\n",
        "                self.wait()\n",
        "            else:\n",
        "                self.wait(0.1)\n",
        "            step()\n",
        "\n",
        "    def get_time_label(self):\n",
        "        time_label = VGroup(\n",
        "            OldTexText(\"Time: \"),\n",
        "            Integer(0),\n",
        "        )\n",
        "        time_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        time_label.to_corner(UR)\n",
        "        time_label.shift(0.5 * LEFT)\n",
        "        return time_label\n",
        "\n",
        "    def get_dots(self):\n",
        "        dots = VGroup(*[Dot() for x in range(self.n_dots)])\n",
        "        dots.set_height(2 * self.dot_radius)\n",
        "        dots.set_fill(opacity=self.dot_opacity)\n",
        "\n",
        "        for dot in dots:\n",
        "            dot.x = 0\n",
        "            if self.dither_dots:\n",
        "                dot.shift(\n",
        "                    self.dot_radius * random.random() * RIGHT,\n",
        "                    self.dot_radius * random.random() * UP\n",
        "                )\n",
        "            dot.set_color(interpolate_color(\n",
        "                BLUE_B, BLUE_D, random.random()\n",
        "            ))\n",
        "\n",
        "        return dots\n",
        "\n",
        "    def adjust_initial_dot_positions(self, dots, x_unit):\n",
        "        pass\n",
        "\n",
        "\n",
        "class Diffusion1DWith1Dot(Diffusion1D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 1,\n",
        "        \"dot_radius\": 0.1,\n",
        "        \"dot_opacity\": 1,\n",
        "        \"dither_dots\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class Diffusion1DStepFunction(Diffusion1D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 15000,\n",
        "        \"initial_range\": (-20, 0),\n",
        "        \"y_range\": (0, 1000, 100),\n",
        "        \"total_steps\": 100,\n",
        "    }\n",
        "\n",
        "    def adjust_initial_dot_positions(self, dots, x_unit):\n",
        "        initial_positions = list(range(*self.initial_range))\n",
        "        for n, dot in enumerate(dots):\n",
        "            x = initial_positions[n % len(initial_positions)]\n",
        "            dot.x = x\n",
        "            dot.shift(x * x_unit * RIGHT)\n",
        "\n",
        "\n",
        "class Diffusion1DStepFunctionGraphed(Diffusion1DStepFunction):\n",
        "    CONFIG = {\n",
        "        \"show_y_axis\": True,\n",
        "        \"total_steps\": 500,\n",
        "    }\n",
        "\n",
        "\n",
        "class DiffusionDeltaGraphed(Diffusion1D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 1000,\n",
        "        \"show_y_axis\": True,\n",
        "        \"y_range\": (0, 1000, 100),\n",
        "        \"total_steps\": 200,\n",
        "    }\n",
        "\n",
        "\n",
        "class DiffusionDeltaGraphedTripleStart(DiffusionDeltaGraphed):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 2000,\n",
        "    }\n",
        "\n",
        "    def adjust_initial_dot_positions(self, dots, x_unit):\n",
        "        for n, dot in enumerate(dots):\n",
        "            x = int(n % 4 - 1.5)\n",
        "            dot.x = x\n",
        "            dot.shift(x * x_unit * RIGHT)\n",
        "\n",
        "\n",
        "class DiffusionDeltaGraphedShowingMean(DiffusionDeltaGraphed):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 10000,\n",
        "        \"y_range\": (0, 10000, 1000),\n",
        "        \"clip_at_bounds\": False,\n",
        "        \"total_steps\": 100,\n",
        "    }\n",
        "\n",
        "    def adjust_initial_dot_positions(self, dots, x_unit):\n",
        "        # Hack, just using this to add something new and updated\n",
        "        label = VGroup(\n",
        "            OldTex(\"\\\\overline{x^2} = \"),\n",
        "            DecimalNumber(0),\n",
        "        )\n",
        "        label.arrange(RIGHT)\n",
        "        label.to_corner(UL)\n",
        "        label.add_updater(lambda m: m[1].set_value(np.mean([\n",
        "            dot.x**2 for dot in dots\n",
        "        ])))\n",
        "\n",
        "        self.add(label)\n",
        "\n",
        "\n",
        "class Diffusion2D(Diffusion1D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 100,\n",
        "        \"dot_opacity\": 0.5,\n",
        "        \"dither_dots\": True,\n",
        "        \"grid_dimensions\": (19, 35),\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        grid_dimensions = self.grid_dimensions\n",
        "\n",
        "        # Setup grid\n",
        "        grid = VGroup(*[\n",
        "            Square()\n",
        "            for x in range(grid_dimensions[0])\n",
        "            for y in range(grid_dimensions[1])\n",
        "        ])\n",
        "        grid.arrange_in_grid(*grid_dimensions, buff=0)\n",
        "        grid.set_height(FRAME_HEIGHT)\n",
        "        grid.set_stroke(GREY_B, 1)\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        step_size = get_norm(grid[1].get_center() - grid[0].get_center())\n",
        "\n",
        "        # Add time label\n",
        "        time_label = self.get_time_label()\n",
        "        br = BackgroundRectangle(time_label)\n",
        "        br.stretch(1.5, 0, about_edge=LEFT)\n",
        "        time_label.add_to_back(br)\n",
        "        self.add(time_label)\n",
        "\n",
        "        # Initialize dots\n",
        "        dots = self.get_dots()\n",
        "        self.add(dots)\n",
        "\n",
        "        # Rule for updating\n",
        "        def step(dots=dots, step_size=step_size, time_label=time_label):\n",
        "            for dot in dots:\n",
        "                vect = random.choice([\n",
        "                    UP, DOWN, LEFT, RIGHT, ORIGIN\n",
        "                ])\n",
        "                dot.shift(step_size * vect)\n",
        "            time_label[-1].increment_value()\n",
        "\n",
        "        # Let it play out\n",
        "        for t in range(self.total_steps):\n",
        "            if t < 6:\n",
        "                self.wait()\n",
        "            else:\n",
        "                self.wait(0.1)\n",
        "            step()\n",
        "\n",
        "\n",
        "class Diffusion2D1Dot(Diffusion2D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 1,\n",
        "        \"dither_dots\": False,\n",
        "        \"dot_opacity\": 1,\n",
        "        \"total_steps\": 50,\n",
        "    }\n",
        "\n",
        "\n",
        "class Diffusion2D10KDots(Diffusion2D):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 10000,\n",
        "        \"dot_opacity\": 0.2,\n",
        "        \"total_steps\": 200,\n",
        "    }\n"
    ]
}