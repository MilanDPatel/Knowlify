{
    "topic": "The mathematical concept being demonstrated is the Moser function, which is a combinatorial function that counts the",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "import operator as op\n",
        "from copy import deepcopy\n",
        "from random import random, randint\n",
        "import sys\n",
        "import inspect\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from script_wrapper import command_line_create_scene\n",
        "from functools import reduce\n",
        "\n",
        "RADIUS            = FRAME_Y_RADIUS - 0.1\n",
        "CIRCLE_DENSITY    = DEFAULT_POINT_DENSITY_1D*RADIUS\n",
        "MOVIE_PREFIX      = \"moser/\"\n",
        "RADIANS           = np.arange(0, 6, 6.0/7)\n",
        "MORE_RADIANS      = np.append(RADIANS, RADIANS + 0.5)\n",
        "N_PASCAL_ROWS     = 7\n",
        "BIG_N_PASCAL_ROWS = 11\n",
        "\n",
        "def int_list_to_string(int_list):\n",
        "    return \"-\".join(map(str, int_list))\n",
        "\n",
        "def moser_function(n):\n",
        "    return choose(n, 4) + choose(n, 2) + 1\n",
        "\n",
        "###########################################\n",
        "\n",
        "class CircleScene(Scene):\n",
        "    args_list = [\n",
        "        (RADIANS[:x],)\n",
        "        for x in range(1, len(RADIANS)+1)\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return str(len(args[0])) #Length of radians\n",
        "\n",
        "    def __init__(self, radians, radius = RADIUS, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        self.radius = radius\n",
        "        self.circle = Circle(density = CIRCLE_DENSITY).scale(self.radius)\n",
        "        self.points = [\n",
        "            (self.radius * np.cos(angle), self.radius * np.sin(angle), 0)\n",
        "            for angle in radians\n",
        "        ]\n",
        "        self.dots = [Dot(point) for point in self.points]\n",
        "        self.lines = [Line(p1, p2) for p1, p2 in it.combinations(self.points, 2)]\n",
        "        self.n_equals = OldTex(\n",
        "            \"n=%d\"%len(radians),\n",
        "        ).shift((-FRAME_X_RADIUS+1, FRAME_Y_RADIUS-1.5, 0))\n",
        "        self.add(self.circle, self.n_equals, *self.dots + self.lines)\n",
        "\n",
        "\n",
        "    def generate_intersection_dots(self):\n",
        "        \"\"\"\n",
        "        Generates and adds attributes intersection_points and\n",
        "        intersection_dots, but does not yet add them to the scene\n",
        "        \"\"\"\n",
        "        self.intersection_points = [\n",
        "            intersection((p[0], p[2]), (p[1], p[3]))\n",
        "            for p in it.combinations(self.points, 4)\n",
        "        ]\n",
        "        self.intersection_dots = [\n",
        "            Dot(point) for point in self.intersection_points\n",
        "        ]\n",
        "\n",
        "    def chop_lines_at_intersection_points(self):\n",
        "        if not hasattr(self, \"intersection_dots\"):\n",
        "            self.generate_intersection_dots()\n",
        "        self.remove(*self.lines)\n",
        "        self.lines = []\n",
        "        for point_pair in it.combinations(self.points, 2):\n",
        "            int_points = [p for p in self.intersection_points if is_on_line(p, *point_pair)]\n",
        "            points = list(point_pair) + int_points\n",
        "            points = [(p[0], p[1], 0) for p in points]\n",
        "            points.sort(cmp = lambda x,y: cmp(x[0], y[0]))\n",
        "            self.lines += [\n",
        "                Line(points[i], points[i+1])\n",
        "                for i in range(len(points)-1)\n",
        "            ]\n",
        "        self.add(*self.lines)\n",
        "\n",
        "    def chop_circle_at_points(self):\n",
        "        self.remove(self.circle)\n",
        "        self.circle_pieces = []\n",
        "        self.smaller_circle_pieces = []\n",
        "        for i in range(len(self.points)):\n",
        "            pp = self.get_points()[i], self.get_points()[(i+1)%len(self.points)]\n",
        "            transform = np.array([\n",
        "                [pp[0][0], pp[1][0], 0],\n",
        "                [pp[0][1], pp[1][1], 0],\n",
        "                [0, 0, 1]\n",
        "            ])\n",
        "            circle = deepcopy(self.circle)\n",
        "            smaller_circle = deepcopy(self.circle)\n",
        "            for c in circle, smaller_circle:\n",
        "                c.points = np.dot(\n",
        "                    c.points, \n",
        "                    np.transpose(np.linalg.inv(transform))\n",
        "                )\n",
        "                c.filter_out(\n",
        "                    lambda p : p[0] < 0 or p[1] < 0\n",
        "                )\n",
        "                if c == smaller_circle:\n",
        "                    c.filter_out(\n",
        "                        lambda p : p[0] > 4*p[1] or p[1] > 4*p[0]\n",
        "                    )\n",
        "                c.points = np.dot(\n",
        "                    c.points, \n",
        "                    np.transpose(transform)\n",
        "                )\n",
        "            self.circle_pieces.append(circle)\n",
        "            self.smaller_circle_pieces.append(smaller_circle)\n",
        "        self.add(*self.circle_pieces)\n",
        "\n",
        "    def generate_regions(self):\n",
        "        self.regions = plane_partition_from_points(*self.points)\n",
        "        interior = Region(lambda x, y : x**2 + y**2 < self.radius**2)\n",
        "        list(map(lambda r : r.intersect(interior), self.regions))\n",
        "        self.exterior = interior.complement()\n",
        "\n",
        "\n",
        "class CountSections(CircleScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        CircleScene.__init__(self, *args, **kwargs)\n",
        "        self.remove(*self.lines)\n",
        "        self.play(*[\n",
        "            Transform(Dot(points[i]),Line(points[i], points[1-i]))\n",
        "            for points in it.combinations(self.points, 2)\n",
        "            for i in (0, 1)\n",
        "        ], run_time = 2.0)\n",
        "        regions = plane_partition_from_points(*self.points)\n",
        "        interior = Region(lambda x, y : x**2 + y**2 < self.radius**2)\n",
        "        list(map(lambda r : r.intersect(interior), regions))\n",
        "        regions = [r for r in regions if r.bool_grid.any()]\n",
        "        self.count_regions(regions, num_offset = ORIGIN)\n",
        "\n",
        "class MoserPattern(CircleScene):\n",
        "    args_list = [(MORE_RADIANS,)]\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        self.remove(*self.dots + self.lines + [self.n_equals])\n",
        "        n_equals, num = OldTex([\"n=\", \"10\"]).split()\n",
        "        for mob in n_equals, num:\n",
        "            mob.shift((-FRAME_X_RADIUS + 1.5, FRAME_Y_RADIUS - 1.5, 0))\n",
        "        self.add(n_equals)\n",
        "        for n in range(1, len(radians)+1):\n",
        "            self.add(*self.dots[:n])\n",
        "            self.add(*[Line(p[0], p[1]) for p in it.combinations(self.get_points()[:n], 2)])\n",
        "            tex_stuffs = [\n",
        "                OldTex(str(moser_function(n))),\n",
        "                OldTex(str(n)).shift(num.get_center())\n",
        "            ]\n",
        "            self.add(*tex_stuffs)\n",
        "            self.wait(0.5)\n",
        "            self.remove(*tex_stuffs)\n",
        "\n",
        "def hpsq_taylored_alpha(t):\n",
        "    return 0.3*np.sin(5*t-5)*np.exp(-20*(t-0.6)**2) + smooth(t)\n",
        "\n",
        "class HardProblemsSimplerQuestions(Scene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        right_center = np.array((4, 1, 0))\n",
        "        left_center = np.array((-5, 1, 0))\n",
        "        scale_factor = 0.7\n",
        "        fermat = dict([\n",
        "            (\n",
        "                sym, \n",
        "                Mobject(*Texs(\n",
        "                    [\"x\",\"^\"+sym,\"+\",\"y\",\"^\"+sym,\"=\",\"z\",\"^\"+sym]\n",
        "                ))\n",
        "            )\n",
        "            for sym in [\"n\", \"2\", \"3\"]\n",
        "        ])\n",
        "        # not_that_hard = OldTexText(\"(maybe not that hard...)\").scale(0.5)\n",
        "        fermat2, fermat2_jargon = OldTex([\n",
        "            r\"&x^2 + y^2 = z^2 \\\\\",\n",
        "            r\"\"\"\n",
        "                &(3, 4, 5) \\\\\n",
        "                &(5, 12, 13) \\\\\n",
        "                &(15, 8, 17) \\\\\n",
        "                &\\quad \\vdots \\\\\n",
        "                (m^2 - &n^2, 2mn, m^2 + n^2) \\\\\n",
        "                &\\quad \\vdots\n",
        "            \"\"\"\n",
        "        ]).split()\n",
        "        fermat3, fermat3_jargon = OldTex([\n",
        "            r\"&x^3 + y^3 = z^3\\\\\",\n",
        "            r\"\"\"\n",
        "                &y^3 = (z - x)(z - \\omega x)(z - \\omega^2 x) \\\\\n",
        "                &\\mathds{Z}[\\omega] \\text{ is a UFD...}\n",
        "            \"\"\"\n",
        "        ]).split()\n",
        "        for mob in [fermat2, fermat3, fermat[\"2\"], fermat[\"3\"],\n",
        "                    fermat2_jargon, fermat3_jargon]:\n",
        "            mob.scale(scale_factor)\n",
        "        fermat[\"2\"].shift(right_center)\n",
        "        fermat[\"3\"].shift(left_center)\n",
        "        fermat[\"n\"].shift((0, FRAME_Y_RADIUS - 1, 0))\n",
        "        shift_val = right_center - fermat2.get_center()\n",
        "        fermat2.shift(shift_val)\n",
        "        fermat2_jargon.shift(shift_val)\n",
        "        shift_val = left_center - fermat3.get_center()\n",
        "        fermat3.shift(shift_val)\n",
        "        fermat3_jargon.shift(shift_val)\n",
        "\n",
        "        copies = [\n",
        "            deepcopy(fermat[\"n\"]).center().scale(scale_factor).shift(c)\n",
        "            for c in [left_center, right_center]\n",
        "        ]\n",
        "        self.add(fermat[\"n\"])\n",
        "        self.play(*[\n",
        "            Transform(deepcopy(fermat[\"n\"]), f_copy)\n",
        "            for f_copy in copies\n",
        "        ])\n",
        "        self.remove(*self.mobjects)\n",
        "        self.add(fermat[\"n\"])\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(mobs[0], mobs[1])\n",
        "            for f_copy, sym in zip(copies, [\"3\", \"2\"])            \n",
        "            for mobs in zip(f_copy.split(), fermat[sym].split())\n",
        "        ])\n",
        "        self.remove(*self.mobjects)\n",
        "        self.add(fermat[\"n\"], fermat2, fermat3)\n",
        "        self.wait()\n",
        "\n",
        "        circle_grid = Mobject(\n",
        "            Circle(), \n",
        "            Grid(radius = 2),\n",
        "            OldTex(r\"\\mathds{R}^2\").shift((2, -2, 0))\n",
        "        )\n",
        "        start_line = Line((-1, 0, 0), (-1, 2, 0))\n",
        "        end_line   = Line((-1, 0, 0), (-1, -2, 0))\n",
        "        for mob in circle_grid, start_line, end_line:\n",
        "            mob.scale(0.5).shift(right_center + (0, 2, 0))\n",
        "\n",
        "        other_grid = Mobject(\n",
        "            Grid(radius = 2),\n",
        "            OldTex(r\"\\mathds{C}\").shift((2, -2, 0))\n",
        "        )\n",
        "        omega = np.array((0.5, 0.5*np.sqrt(3), 0))\n",
        "        dots = Mobject(*[\n",
        "            Dot(t*np.array((1, 0, 0)) + s * omega)\n",
        "            for t, s in it.product(list(range(-2, 3)), list(range(-2, 3)))\n",
        "        ])\n",
        "        for mob in dots, other_grid:\n",
        "            mob.scale(0.5).shift(left_center + (0, 2, 0))\n",
        "\n",
        "        self.add(circle_grid, other_grid)\n",
        "        self.play(\n",
        "            FadeIn(fermat2_jargon),\n",
        "            FadeIn(fermat3_jargon),\n",
        "            CounterclockwiseTransform(start_line, end_line),\n",
        "            ShowCreation(dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        all_mobjects = Mobject(*self.mobjects)\n",
        "        self.remove(*self.mobjects)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                all_mobjects,\n",
        "                Point((FRAME_X_RADIUS, 0, 0))\n",
        "            ),\n",
        "            Transform(\n",
        "                Point((-FRAME_X_RADIUS, 0, 0)), \n",
        "                Mobject(*CircleScene(RADIANS).mobjects)\n",
        "            )\n",
        "        )\n",
        "\n",
        "class CountLines(CircleScene):\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        #TODO, Count things explicitly?        \n",
        "        text_center = (self.radius + 1, self.radius -1, 0)\n",
        "        scale_factor = 0.4\n",
        "        text = OldTex(r\"\\text{How Many Lines?}\", size = r\"\\large\")\n",
        "        n = len(radians)\n",
        "        formula, answer = OldTex([\n",
        "            r\"{%d \\choose 2} = \\frac{%d(%d - 1)}{2} = \"%(n, n, n),\n",
        "            str(choose(n, 2))\n",
        "        ])\n",
        "        text.scale(scale_factor).shift(text_center)\n",
        "        x = text_center[0]\n",
        "        new_lines = [\n",
        "            Line((x-1, y, 0), (x+1, y, 0))\n",
        "            for y in np.arange(\n",
        "                -(self.radius - 1), \n",
        "                self.radius - 1, \n",
        "                (2*self.radius - 2)/len(self.lines)\n",
        "            )\n",
        "        ]\n",
        "        self.add(text)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "           Transform(line1, line2, run_time = 2)\n",
        "           for line1, line2 in zip(self.lines, new_lines)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.remove(text)\n",
        "        self.count(new_lines)\n",
        "        anims = [FadeIn(formula)]\n",
        "        for mob in self.mobjects:\n",
        "            if mob == self.number:\n",
        "                anims.append(Transform(mob, answer))\n",
        "            else:\n",
        "                anims.append(FadeOut(mob))\n",
        "        self.play(*anims, run_time = 1)\n",
        "\n",
        "class CountIntersectionPoints(CircleScene):\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        radians = [r % (2*np.pi) for r in radians]\n",
        "        radians.sort()\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "\n",
        "        intersection_points = [\n",
        "            intersection((p[0], p[2]), (p[1], p[3]))\n",
        "            for p in it.combinations(self.points, 4)\n",
        "        ]\n",
        "        intersection_dots = [Dot(point) for point in intersection_points]\n",
        "        text_center = (self.radius + 0.5, self.radius -0.5, 0)\n",
        "        size = r\"\\large\"\n",
        "        scale_factor = 0.4\n",
        "        text = OldTex(r\"\\text{How Many Intersection Points?}\", size = size)\n",
        "        n = len(radians)\n",
        "        formula, answer = OldTex([\n",
        "            r\"{%d \\choose 4} = \\frac{%d(%d - 1)(%d - 2)(%d-3)}{1\\cdot 2\\cdot 3 \\cdot 4}=\"%(n, n, n, n, n),\n",
        "            str(choose(n, 4))\n",
        "        ]).split()\n",
        "        text.scale(scale_factor).shift(text_center)\n",
        "        self.add(text)\n",
        "        self.count(intersection_dots, mode=\"show\", num_offset = ORIGIN)\n",
        "        self.wait()\n",
        "        anims = []\n",
        "        for mob in self.mobjects:\n",
        "            if mob == self.number: #put in during count\n",
        "                anims.append(Transform(mob, answer))\n",
        "            else:\n",
        "                anims.append(FadeOut(mob))\n",
        "        anims.append(Animation(formula))\n",
        "        self.play(*anims, run_time = 1)\n",
        "\n",
        "class NonGeneralPosition(CircleScene):\n",
        "    args_list = []\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return \"\"\n",
        "\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        radians = np.arange(1, 7)\n",
        "        new_radians = (np.pi/3)*radians\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "\n",
        "        new_cs = CircleScene(new_radians)\n",
        "        center_region = reduce(\n",
        "            Region.intersect,\n",
        "            [\n",
        "                HalfPlane((self.get_points()[x], self.get_points()[(x+3)%6]))\n",
        "                for x in [0, 4, 2]#Ya know, trust it\n",
        "            ]\n",
        "        )\n",
        "        center_region\n",
        "        text = OldTex(r\"\\text{This region disappears}\", size = r\"\\large\")\n",
        "        text.center().scale(0.5).shift((-self.radius, self.radius-0.3, 0))\n",
        "        arrow = Arrow(\n",
        "            point = (-0.35, -0.1, 0),\n",
        "            direction = (1, -1, 0), \n",
        "            length = self.radius + 1,\n",
        "            color = \"white\",\n",
        "        )\n",
        "\n",
        "        self.set_color_region(center_region, \"green\")\n",
        "        self.add(text, arrow)\n",
        "        self.wait(2)\n",
        "        self.remove(text, arrow)\n",
        "        self.reset_background()\n",
        "        self.play(*[\n",
        "            Transform(mob1, mob2, run_time = DEFAULT_ANIMATION_RUN_TIME)\n",
        "            for mob1, mob2 in zip(self.mobjects, new_self.mobjects)\n",
        "        ])\n",
        "\n",
        "class GeneralPositionRule(Scene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        tuples = [\n",
        "            (\n",
        "                np.arange(0, 2*np.pi, np.pi/3), \n",
        "                \"Not okay\", \n",
        "                list(zip(list(range(3)), list(range(3, 6))))\n",
        "            ),\n",
        "            (\n",
        "                RADIANS,\n",
        "                \"Okay\",\n",
        "                [],\n",
        "            ),\n",
        "            (\n",
        "                np.arange(0, 2*np.pi, np.pi/4),\n",
        "                \"Not okay\",\n",
        "                list(zip(list(range(4)), list(range(4, 8))))\n",
        "            ),\n",
        "            (\n",
        "                [2*np.pi*random() for x in range(5)],\n",
        "                \"Okay\",\n",
        "                [],\n",
        "            ),\n",
        "        ]\n",
        "        first_time = True\n",
        "        for radians, words, pairs in tuples:\n",
        "            cs = CircleScene(radians)\n",
        "            self.add(*cs.mobjects)\n",
        "            words_mob = OldTexText(words).scale(2).shift((5, 3, 0))\n",
        "            if not first_time:\n",
        "                self.add(words_mob)\n",
        "            if words == \"Okay\":\n",
        "                words_mob.set_color(\"green\")\n",
        "                self.wait(2)                \n",
        "            else:\n",
        "                words_mob.set_color()\n",
        "                intersecting_lines = [\n",
        "                    line.scale(0.3).set_color()\n",
        "                    for i, j in pairs                    \n",
        "                    for line in [Line(cs.get_points()[i], cs.get_points()[j])]\n",
        "                ]\n",
        "                self.play(*[\n",
        "                    ShowCreation(line, run_time = 1.0)\n",
        "                    for line in intersecting_lines                    \n",
        "                ])\n",
        "                if first_time:\n",
        "                    self.play(Transform(\n",
        "                        Mobject(*intersecting_lines),\n",
        "                        words_mob\n",
        "                    ))\n",
        "                    first_time = False\n",
        "                self.wait()\n",
        "            self.remove(*self.mobjects)\n",
        "\n",
        "\n",
        "class LineCorrespondsWithPair(CircleScene):\n",
        "    args_list = [\n",
        "        (RADIANS, 2, 5),\n",
        "        (RADIANS, 0, 4)\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return int_list_to_string(args[1:])\n",
        "\n",
        "    def __init__(self, radians, dot0_index, dot1_index, \n",
        "                 *args, **kwargs):\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        #Remove from self.lines list, so they won't be faded out\n",
        "        radians = list(radians)    \n",
        "        r1, r2 = radians[dot0_index], radians[dot1_index]\n",
        "        line_index = list(it.combinations(radians, 2)).index((r1, r2))\n",
        "        line, dot0, dot1 = self.lines[line_index], self.dots[dot0_index], self.dots[dot1_index]\n",
        "        self.lines.remove(line)\n",
        "        self.dots.remove(dot0)\n",
        "        self.dots.remove(dot1)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 0.2)\n",
        "            for mob in self.lines + self.dots\n",
        "        ])\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                dot, Dot(dot.get_center(), 3*dot.radius),\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "            for dot in (dot0, dot1)\n",
        "        ])\n",
        "        self.play(Transform(line, dot0))\n",
        "\n",
        "class IllustrateNChooseK(Scene):\n",
        "    args_list = [\n",
        "        (n, k)\n",
        "        for n in range(1, 10)\n",
        "        for k in range(n+1)\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return int_list_to_string(args)\n",
        "\n",
        "    def __init__(self, n, k, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        nrange = list(range(1, n+1))\n",
        "        tuples  = list(it.combinations(nrange, k))\n",
        "        nrange_mobs = OldTex([str(n) + r'\\;' for n in nrange]).split()\n",
        "        tuple_mobs  = Texs(\n",
        "            [\n",
        "                (r'\\\\&' if c%(20//k) == 0 else r'\\;\\;') + str(p)\n",
        "                for p, c in zip(tuples, it.count())\n",
        "            ],\n",
        "            size = r\"\\small\",\n",
        "        )#TODO, scale these up!\n",
        "        tuple_terms = {\n",
        "            2 : \"pairs\", \n",
        "            3 : \"triplets\",\n",
        "            4 : \"quadruplets\",\n",
        "        }\n",
        "        tuple_term = tuple_terms[k] if k in tuple_terms else \"tuples\"\n",
        "        if k == 2:\n",
        "            str1 = r\"{%d \\choose %d} = \\frac{%d(%d - 1)}{2}=\"%(n, k, n, n)\n",
        "        elif k == 4:\n",
        "            str1 = r\"\"\"\n",
        "                {%d \\choose %d} = \n",
        "                \\frac{%d(%d - 1)(%d-2)(%d-3)}{1\\cdot 2\\cdot 3 \\cdot 4}=\n",
        "            \"\"\"%(n, k, n, n, n, n)\n",
        "        else: \n",
        "            str1 = r\"{%d \\choose %d} =\"%(n, k)\n",
        "        form1, count, form2 = OldTex([\n",
        "            str1,\n",
        "            \"%d\"%choose(n, k),\n",
        "            r\" \\text{ total %s}\"%tuple_term\n",
        "        ])\n",
        "        pronunciation = OldTexText(\n",
        "            \"(pronounced ``%d choose %d\\'\\')\"%(n, k)\n",
        "        )\n",
        "        for mob in nrange_mobs:\n",
        "            mob.shift((0, 2, 0))\n",
        "        for mob in form1, count, form2:\n",
        "            mob.scale(0.75).shift((0, -FRAME_Y_RADIUS + 1, 0))\n",
        "        count_center = count.get_center()\n",
        "        for mob in tuple_mobs:\n",
        "            mob.scale(0.6)\n",
        "        pronunciation.shift(\n",
        "            form1.get_center() + (0, 1, 0)\n",
        "        )\n",
        "\n",
        "        self.add(*nrange_mobs)\n",
        "        self.wait()\n",
        "        run_time = 6.0\n",
        "        frame_time = run_time / len(tuples)\n",
        "        for tup, count in zip(tuples, it.count()):\n",
        "            count_mob = OldTex(str(count+1))\n",
        "            count_mob.center().shift(count_center)\n",
        "            self.add(count_mob)\n",
        "            tuple_copy = Mobject(*[nrange_mobs[index-1] for index in tup])\n",
        "            tuple_copy.set_color()\n",
        "            self.add(tuple_copy)\n",
        "            self.add(tuple_mobs[count])\n",
        "            self.wait(frame_time)\n",
        "            self.remove(count_mob)\n",
        "            self.remove(tuple_copy)\n",
        "        self.add(count_mob)\n",
        "        self.play(FadeIn(Mobject(form1, form2, pronunciation)))\n",
        "\n",
        "class IntersectionPointCorrespondances(CircleScene):\n",
        "    args_list = [\n",
        "        (RADIANS, list(range(0, 7, 2))),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return int_list_to_string(args[1])\n",
        "\n",
        "    def __init__(self, radians, indices, *args, **kwargs):\n",
        "        assert(len(indices) == 4)\n",
        "        indices.sort()\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        intersection_point = intersection(\n",
        "            (self.get_points()[indices[0]], self.get_points()[indices[2]]),\n",
        "            (self.get_points()[indices[1]], self.get_points()[indices[3]])\n",
        "        )\n",
        "        if len(intersection_point) == 2:\n",
        "            intersection_point = list(intersection_point) + [0]\n",
        "        intersection_dot = Dot(intersection_point)\n",
        "        intersection_dot_arrow = Arrow(intersection_point).nudge()\n",
        "        self.add(intersection_dot)\n",
        "        pairs = list(it.combinations(list(range(len(radians))), 2))\n",
        "        lines_to_save = [\n",
        "            self.lines[pairs.index((indices[p0], indices[p1]))]\n",
        "            for p0, p1 in [(0, 2), (1, 3)]\n",
        "        ]\n",
        "        dots_to_save = [\n",
        "            self.dots[p]\n",
        "            for p in indices\n",
        "        ]\n",
        "        line_statement = OldTex(r\"\\text{Pair of Lines}\")\n",
        "        dots_statement = OldTex(r\"&\\text{Quadruplet of} \\\\ &\\text{outer dots}\")\n",
        "        for mob in line_statement, dots_statement:\n",
        "            mob.center()\n",
        "            mob.scale(0.7)\n",
        "            mob.shift((FRAME_X_RADIUS-2, FRAME_Y_RADIUS - 1, 0))\n",
        "        fade_outs = []\n",
        "        line_highlights = []\n",
        "        dot_highlights = []\n",
        "        dot_pointers = []\n",
        "        for mob in self.mobjects:\n",
        "            if mob in lines_to_save:\n",
        "                line_highlights.append(Highlight(mob))\n",
        "            elif mob in dots_to_save:\n",
        "                dot_highlights.append(Highlight(mob))\n",
        "                dot_pointers.append(Arrow(mob.get_center()).nudge())\n",
        "            elif mob != intersection_dot:\n",
        "                fade_outs.append(FadeOut(mob, rate_func = not_quite_there))\n",
        "\n",
        "        self.add(intersection_dot_arrow)\n",
        "        self.play(Highlight(intersection_dot))\n",
        "        self.remove(intersection_dot_arrow)\n",
        "        self.play(*fade_outs)\n",
        "        self.wait()\n",
        "        self.add(line_statement)\n",
        "        self.play(*line_highlights)\n",
        "        self.remove(line_statement)\n",
        "        self.wait()\n",
        "        self.add(dots_statement, *dot_pointers)\n",
        "        self.play(*dot_highlights)\n",
        "        self.remove(dots_statement, *dot_pointers)\n",
        "\n",
        "class LinesIntersectOutside(CircleScene):\n",
        "    args_list = [\n",
        "        (RADIANS, [2, 4, 5, 6]),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return int_list_to_string(args[1])\n",
        "\n",
        "    def __init__(self, radians, indices, *args, **kwargs):\n",
        "        assert(len(indices) == 4)\n",
        "        indices.sort()\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        intersection_point = intersection(\n",
        "            (self.get_points()[indices[0]], self.get_points()[indices[1]]),\n",
        "            (self.get_points()[indices[2]], self.get_points()[indices[3]])\n",
        "        )\n",
        "        intersection_point = tuple(list(intersection_point) + [0])\n",
        "        intersection_dot = Dot(intersection_point)\n",
        "        pairs = list(it.combinations(list(range(len(radians))), 2))\n",
        "        lines_to_save = [\n",
        "            self.lines[pairs.index((indices[p0], indices[p1]))]\n",
        "            for p0, p1 in [(0, 1), (2, 3)]\n",
        "        ]\n",
        "        self.play(*[\n",
        "            FadeOut(mob, rate_func = not_quite_there)\n",
        "            for mob in self.mobjects if mob not in lines_to_save\n",
        "        ])\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                Line(self.get_points()[indices[p0]], self.get_points()[indices[p1]]), \n",
        "                Line(self.get_points()[indices[p0]], intersection_point))\n",
        "            for p0, p1 in [(0, 1), (3, 2)]\n",
        "        ] + [ShowCreation(intersection_dot)])\n",
        "\n",
        "class QuadrupletsToIntersections(CircleScene):\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        quadruplets = it.combinations(list(range(len(radians))), 4)\n",
        "        frame_time = 1.0\n",
        "        for quad in quadruplets:\n",
        "            intersection_dot = Dot(intersection(\n",
        "                (self.get_points()[quad[0]], self.get_points()[quad[2]]),\n",
        "                (self.get_points()[quad[1]], self.get_points()[quad[3]])\n",
        "            )).repeat(3)\n",
        "            dot_quad = [deepcopy(self.dots[i]) for i in quad]\n",
        "            for dot in dot_quad:\n",
        "                dot.scale(2)\n",
        "            dot_quad = Mobject(*dot_quad)\n",
        "            dot_quad.set_color()\n",
        "            self.add(dot_quad)\n",
        "            self.wait(frame_time / 3)\n",
        "            self.play(Transform(\n",
        "                dot_quad,\n",
        "                intersection_dot,\n",
        "                run_time = 3*frame_time/2\n",
        "            ))\n",
        "\n",
        "class GraphsAndEulersFormulaJoke(Scene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        axes = Mobject(\n",
        "            NumberLine(),\n",
        "            NumberLine().rotate(np.pi / 2)\n",
        "        )\n",
        "        graph = ParametricCurve(\n",
        "            lambda t : (10*t, ((10*t)**3 - 10*t), 0),\n",
        "            expected_measure = 40.0\n",
        "        )\n",
        "        graph.filter_out(lambda x_y_z : abs(x_y_z[1]) > FRAME_Y_RADIUS)\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph), run_time = 1.0)\n",
        "        eulers = OldTex(\"e^{\\pi i} = -1\").shift((0, 3, 0))\n",
        "        self.play(CounterclockwiseTransform(\n",
        "            deepcopy(graph), eulers\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.add(eulers)\n",
        "        self.play(CounterclockwiseTransform(\n",
        "            Mobject(axes, graph),\n",
        "            Point((-FRAME_X_RADIUS, FRAME_Y_RADIUS, 0))\n",
        "        ))\n",
        "        self.play(CounterclockwiseTransform(\n",
        "            eulers,\n",
        "            Point((FRAME_X_RADIUS, FRAME_Y_RADIUS, 0))\n",
        "        ))\n",
        "\n",
        "class DefiningGraph(GraphScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        GraphScene.__init__(self, *args, **kwargs)\n",
        "        word_center = (0, 3, 0)\n",
        "        vertices_word = OldTexText(\"``Vertices\\\"\").shift(word_center)\n",
        "        edges_word = OldTexText(\"``Edges\\\"\").shift(word_center)\n",
        "        dots, lines = self.vertices, self.edges\n",
        "        self.remove(*dots + lines)\n",
        "        all_dots = Mobject(*dots)\n",
        "        self.play(ShowCreation(all_dots))\n",
        "        self.remove(all_dots)\n",
        "        self.add(*dots)\n",
        "        self.play(FadeIn(vertices_word))\n",
        "        self.wait()\n",
        "        self.remove(vertices_word)\n",
        "        self.play(*[\n",
        "            ShowCreation(line) for line in lines\n",
        "        ])\n",
        "        self.play(FadeIn(edges_word))\n",
        "\n",
        "        #Move to new graph\n",
        "        # new_graph = deepcopy(self.graph)\n",
        "        # new_graph.vertices = [\n",
        "        #     (v[0] + 3*random(), v[1] + 3*random(), 0)\n",
        "        #     for v in new_graph.vertices\n",
        "        # ]\n",
        "        # new_graph_scene = GraphScene(new_graph)\n",
        "        # self.play(*[\n",
        "        #     Transform(m[0], m[1])\n",
        "        #     for m in zip(self.mobjects, new_graph_scene.mobjects)\n",
        "        # ], run_time = 7.0)\n",
        "\n",
        "class IntersectCubeGraphEdges(GraphScene):\n",
        "    args_list = []\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return \"\"\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        GraphScene.__init__(self, CubeGraph(), *args, **kwargs)\n",
        "        self.remove(self.edges[0], self.edges[4])\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                Line(self.get_points()[i], self.get_points()[j]),\n",
        "                CurvedLine(self.get_points()[i], self.get_points()[j]),\n",
        "            )\n",
        "            for i, j in [(0, 1), (5, 4)]\n",
        "        ])\n",
        "\n",
        "\n",
        "class DoubledEdges(GraphScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        GraphScene.__init__(self, *args, **kwargs)\n",
        "        lines_to_double = self.edges[:9:3]\n",
        "        crazy_lines = [\n",
        "            (\n",
        "                line,\n",
        "                Line(line.end, line.start),\n",
        "                CurvedLine(line.start, line.end) ,\n",
        "                CurvedLine(line.end, line.start)\n",
        "            )\n",
        "            for line in lines_to_double\n",
        "        ]\n",
        "        anims = []\n",
        "        outward_curved_lines = []\n",
        "        kwargs = {\"run_time\" : 3.0}\n",
        "        for straight, backwards, inward, outward in crazy_lines:\n",
        "            anims += [\n",
        "                Transform(straight, inward, **kwargs),\n",
        "                Transform(backwards, outward, **kwargs),\n",
        "            ]\n",
        "            outward_curved_lines.append(outward)\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "        self.remove(*outward_curved_lines)\n",
        "\n",
        "class EulersFormula(GraphScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        GraphScene.__init__(self, *args, **kwargs)\n",
        "        terms = \"V - E + F =2\".split(\" \")\n",
        "        form = dict([\n",
        "            (key, mob)\n",
        "            for key, mob in zip(terms, Texs(terms))\n",
        "        ])\n",
        "        for mob in list(form.values()):\n",
        "            mob.shift((0, FRAME_Y_RADIUS-0.7, 0))\n",
        "        formula = Mobject(*[form[k] for k in list(form.keys()) if k != \"=2\"])\n",
        "        new_form = dict([\n",
        "            (key, deepcopy(mob).shift((0, -0.7, 0)))\n",
        "            for key, mob in zip(list(form.keys()), list(form.values()))\n",
        "        ])\n",
        "        self.add(formula)\n",
        "        colored_dots = [\n",
        "            deepcopy(d).scale(1.5).set_color(\"red\") \n",
        "            for d in self.dots\n",
        "        ]\n",
        "        colored_edges = [\n",
        "            Mobject(\n",
        "                Line(midpoint, start),\n",
        "                Line(midpoint, end),\n",
        "            ).set_color(\"red\")\n",
        "            for e in self.edges\n",
        "            for start, end, midpoint in [\n",
        "                (e.start, e.end, (e.start + e.end)/2.0)\n",
        "            ]\n",
        "        ]\n",
        "        frame_time = 0.3\n",
        "\n",
        "        self.generate_regions()\n",
        "        parameters = [\n",
        "            (colored_dots,  \"V\", \"mobject\", \"-\", \"show\"),\n",
        "            (colored_edges, \"E\", \"mobject\", \"+\", \"show\"),\n",
        "            (self.regions,  \"F\", \"region\", \"=2\", \"show_all\")\n",
        "        ]\n",
        "        for items, letter, item_type, symbol, mode in parameters:\n",
        "            self.count(\n",
        "                items,\n",
        "                item_type  = item_type,\n",
        "                mode       = mode,\n",
        "                num_offset = new_form[letter].get_center(), \n",
        "                run_time   = frame_time*len(items)\n",
        "            )\n",
        "            self.wait()\n",
        "            if item_type == \"mobject\":\n",
        "                self.remove(*items)\n",
        "            self.add(new_form[symbol])\n",
        "\n",
        "class CannotDirectlyApplyEulerToMoser(CircleScene):\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        self.remove(self.n_equals)\n",
        "        n_equals, intersection_count = OldTex([\n",
        "            r\"&n = %d\\\\\"%len(radians),\n",
        "            r\"&{%d \\choose 4} = %d\"%(len(radians), choose(len(radians), 4))\n",
        "        ]).split()\n",
        "        shift_val = self.n_equals.get_center() - n_equals.get_center()\n",
        "        for mob in n_equals, intersection_count:\n",
        "            mob.shift(shift_val)\n",
        "        self.add(n_equals)\n",
        "        yellow_dots  = [\n",
        "            d.set_color(\"yellow\").scale(2)\n",
        "            for d in deepcopy(self.dots)\n",
        "        ]\n",
        "        yellow_lines = Mobject(*[\n",
        "            l.set_color(\"yellow\") for l in deepcopy(self.lines)\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ShowCreation(dot) for dot in yellow_dots\n",
        "        ], run_time = 1.0)\n",
        "        self.wait()\n",
        "        self.remove(*yellow_dots)\n",
        "        self.play(ShowCreation(yellow_lines))\n",
        "        self.wait()\n",
        "        self.remove(yellow_lines)\n",
        "        cannot_intersect = OldTexText(r\"\"\"\n",
        "            Euler's formula does not apply to \\\\\n",
        "            graphs whose edges intersect!\n",
        "            \"\"\"\n",
        "        )\n",
        "        cannot_intersect.center()\n",
        "        for mob in self.mobjects:\n",
        "            mob.fade(0.3)\n",
        "        self.add(cannot_intersect)\n",
        "        self.wait()\n",
        "        self.remove(cannot_intersect)\n",
        "        for mob in self.mobjects:\n",
        "            mob.fade(1/0.3)\n",
        "        self.generate_intersection_dots()\n",
        "        self.play(FadeIn(intersection_count), *[\n",
        "            ShowCreation(dot) for dot in self.intersection_dots\n",
        "        ])\n",
        "\n",
        "class ShowMoserGraphLines(CircleScene):\n",
        "    def __init__(self, radians, *args, **kwargs):\n",
        "        radians = list(set([x%(2*np.pi) for x in radians]))\n",
        "        radians.sort()\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        n, plus_n_choose_4 = OldTex([\"n\", \"+{n \\\\choose 4}\"]).split()\n",
        "        n_choose_2, plus_2_n_choose_4, plus_n = OldTex([\n",
        "            r\"{n \\choose 2}\",r\"&+2{n \\choose 4}\\\\\",r\"&+n\"\n",
        "        ]).split()\n",
        "        for mob in n, plus_n_choose_4, n_choose_2, plus_2_n_choose_4, plus_n:\n",
        "            mob.shift((FRAME_X_RADIUS - 2, FRAME_Y_RADIUS-1, 0))\n",
        "        self.chop_lines_at_intersection_points()\n",
        "        self.add(*self.intersection_dots)\n",
        "        small_lines = [\n",
        "            deepcopy(line).scale(0.5) \n",
        "            for line in self.lines\n",
        "        ]\n",
        "\n",
        "        for mobs, symbol in [\n",
        "            (self.dots, n), \n",
        "            (self.intersection_dots, plus_n_choose_4),\n",
        "            (self.lines, n_choose_2)\n",
        "            ]:\n",
        "            self.add(symbol)\n",
        "            compound = Mobject(*mobs)            \n",
        "            if mobs in (self.dots, self.intersection_dots):\n",
        "                self.remove(*mobs)\n",
        "                self.play(CounterclockwiseTransform(\n",
        "                    compound,\n",
        "                    deepcopy(compound).scale(1.05),\n",
        "                    rate_func = there_and_back,\n",
        "                    run_time = 2.0,\n",
        "                ))\n",
        "            else:\n",
        "                compound.set_color(\"yellow\")\n",
        "                self.play(ShowCreation(compound))\n",
        "                self.remove(compound)\n",
        "            if mobs == self.intersection_dots:\n",
        "                self.remove(n, plus_n_choose_4)\n",
        "\n",
        "        self.play(*[\n",
        "            Transform(line, small_line, run_time = 3.0)\n",
        "            for line, small_line in zip(self.lines, small_lines)\n",
        "        ])\n",
        "        yellow_lines = Mobject(*[\n",
        "            line.set_color(\"yellow\") for line in small_lines\n",
        "        ])\n",
        "        self.add(plus_2_n_choose_4)\n",
        "        self.play(ShowCreation(yellow_lines))\n",
        "        self.wait()\n",
        "        self.remove(yellow_lines)\n",
        "        self.chop_circle_at_points()\n",
        "        self.play(*[\n",
        "            Transform(p, sp, run_time = 3.0)\n",
        "            for p, sp in zip(self.circle_pieces, self.smaller_circle_pieces)\n",
        "        ])\n",
        "        self.add(plus_n)\n",
        "        self.play(ShowCreation(Mobject(*[\n",
        "            mob.set_color(\"yellow\") for mob in self.circle_pieces\n",
        "        ])))\n",
        "\n",
        "class HowIntersectionChopsLine(CircleScene):\n",
        "    args_list = [\n",
        "        (RADIANS, list(range(0, 7, 2))),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return int_list_to_string(args[1])\n",
        "\n",
        "    def __init__(self, radians, indices, *args, **kwargs):\n",
        "        assert(len(indices) == 4)\n",
        "        indices.sort()\n",
        "        CircleScene.__init__(self, radians, *args, **kwargs)\n",
        "        intersection_point = intersection(\n",
        "            (self.get_points()[indices[0]], self.get_points()[indices[2]]),\n",
        "            (self.get_points()[indices[1]], self.get_points()[indices[3]])\n",
        "        )\n",
        "        if len(intersection_point) == 2:\n",
        "            intersection_point = list(intersection_point) + [0]\n",
        "        pairs = list(it.combinations(list(range(len(radians))), 2))\n",
        "        lines = [\n",
        "            Line(self.get_points()[indices[p0]], self.get_points()[indices[p1]])\n",
        "            for p0, p1 in [(2, 0), (1, 3)]\n",
        "        ]\n",
        "        self.remove(*[\n",
        "            self.lines[pairs.index((indices[p0], indices[p1]))]\n",
        "            for p0, p1 in [(0, 2), (1, 3)]\n",
        "        ])\n",
        "        self.add(*lines)\n",
        "        self.play(*[\n",
        "            FadeOut(mob)\n",
        "            for mob in self.mobjects\n",
        "            if mob not in lines\n",
        "        ])\n",
        "        new_lines = [\n",
        "            Line(line.start, intersection_point)\n",
        "            for line in lines\n",
        "        ] + [\n",
        "            Line(intersection_point, line.end)\n",
        "            for line in lines\n",
        "        ]\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                line, \n",
        "                Line(\n",
        "                    (-3, h, 0),\n",
        "                    (3, h, 0)\n",
        "                ), \n",
        "                rate_func = there_and_back, \n",
        "                run_time = 3.0\n",
        "            )\n",
        "            for line, h in zip(lines, (-1, 1))\n",
        "        ])\n",
        "        self.remove(*lines)\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                line, \n",
        "                deepcopy(line).scale(1.1).scale(1/1.1),\n",
        "                run_time = 1.5\n",
        "            )\n",
        "            for line in new_lines\n",
        "        ])\n",
        "\n",
        "\n",
        "class ApplyEulerToMoser(CircleScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        radius = 2\n",
        "        CircleScene.__init__(self, *args, radius = radius, **kwargs)\n",
        "        self.generate_intersection_dots()\n",
        "        self.chop_lines_at_intersection_points()\n",
        "        self.chop_circle_at_points()\n",
        "        self.generate_regions()\n",
        "        for dot in self.dots + self.intersection_dots:\n",
        "            dot.scale(radius / RADIUS)\n",
        "        self.remove(*self.mobjects)\n",
        "\n",
        "        V      = {}\n",
        "        minus  = {}\n",
        "        minus1 = {}\n",
        "        E      = {}\n",
        "        plus   = {}\n",
        "        plus1  = {}\n",
        "        plus2  = {}\n",
        "        F      = {}\n",
        "        equals = {}\n",
        "        two    = {}\n",
        "        two1   = {}\n",
        "        n      = {}\n",
        "        n1     = {}\n",
        "        nc2    = {}\n",
        "        nc4    = {}\n",
        "        nc41   = {}\n",
        "        dicts = [V, minus, minus1, E, plus, plus1, plus2, F, \n",
        "                 equals, two, two1, n, n1, nc2, nc4, nc41]\n",
        "\n",
        "        V[1], minus[1], E[1], plus[1], F[1], equals[1], two[1] = \\\n",
        "            OldTex([\"V\", \"-\", \"E\", \"+\", \"F\", \"=\", \"2\"]).split()\n",
        "        F[2], equals[2], E[2], minus[2], V[2], plus[2], two[2] = \\\n",
        "            OldTex([\"F\", \"=\", \"E\", \"-\", \"V\", \"+\", \"2\"]).split()\n",
        "        F[3], equals[3], E[3], minus[3], n[3], minus1[3], nc4[3], plus[3], two[3] = \\\n",
        "            OldTex([\"F\", \"=\", \"E\", \"-\", \"n\", \"-\", r\"{n \\choose 4}\", \"+\", \"2\"]).split()\n",
        "        F[4], equals[4], nc2[4], plus1[4], two1[4], nc41[4], plus2[4], n1[4], minus[4], n[4], minus1[4], nc4[4], plus[4], two[4] = \\\n",
        "            OldTex([\"F\", \"=\", r\"{n \\choose 2}\", \"+\", \"2\", r\"{n \\choose 4}\", \"+\", \"n\",\"-\", \"n\", \"-\", r\"{n \\choose 4}\", \"+\", \"2\"]).split()\n",
        "        F[5], equals[5], nc2[5], plus1[5], two1[5], nc41[5], minus1[5], nc4[5], plus[5], two[5] = \\\n",
        "            OldTex([\"F\", \"=\", r\"{n \\choose 2}\", \"+\", \"2\", r\"{n \\choose 4}\", \"-\", r\"{n \\choose 4}\", \"+\", \"2\"]).split()\n",
        "        F[6], equals[6], nc2[6], plus1[6], nc4[6], plus[6], two[6] = \\\n",
        "            OldTex([\"F\", \"=\", r\"{n \\choose 2}\", \"+\", r\"{n \\choose 4}\", \"+\", \"2\"]).split()\n",
        "        F[7], equals[7], two[7], plus[7], nc2[7], plus1[7], nc4[7] = \\\n",
        "            OldTex([\"F\", \"=\", \"2\", \"+\", r\"{n \\choose 2}\", \"+\", r\"{n \\choose 4}\"]).split()\n",
        "        shift_val = (0, 3, 0)\n",
        "        for d in dicts:\n",
        "            if not d:\n",
        "                continue\n",
        "            main_key = list(d.keys())[0]\n",
        "            for key in list(d.keys()):\n",
        "                d[key].shift(shift_val)\n",
        "            main_center = d[main_key].get_center()\n",
        "            for key in list(d.keys()):\n",
        "                d[key] = deepcopy(d[main_key]).shift(\n",
        "                    d[key].get_center() - main_center\n",
        "                )\n",
        "\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(d[1], d[2], run_time = 2.0)\n",
        "            for d in [V, minus, E, plus, F, equals, two]\n",
        "        ])\n",
        "        self.wait()\n",
        "        F[1].set_color()\n",
        "        self.add(*self.lines + self.circle_pieces)\n",
        "        for region in self.regions:\n",
        "            self.set_color_region(region)\n",
        "        self.set_color_region(self.exterior, \"blue\")\n",
        "        self.wait()\n",
        "        self.reset_background()\n",
        "        F[1].set_color(\"white\")\n",
        "        E[1].set_color()\n",
        "        self.remove(*self.lines + self.circle_pieces)\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                deepcopy(line),\n",
        "                deepcopy(line).scale(0.5),\n",
        "                run_time = 2.0,\n",
        "            )\n",
        "            for line in self.lines\n",
        "        ] + [\n",
        "            Transform(\n",
        "                deepcopy(cp), scp,\n",
        "                run_time = 2.0\n",
        "            )\n",
        "            for cp, scp in zip(self.circle_pieces, self.smaller_circle_pieces)\n",
        "        ])\n",
        "        self.wait()\n",
        "        E[1].set_color(\"white\")\n",
        "        V[1].set_color()\n",
        "        self.add(*self.dots + self.intersection_dots)\n",
        "        self.remove(*self.lines + self.circle_pieces)\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                deepcopy(dot), \n",
        "                deepcopy(dot).scale(1.4).set_color(\"yellow\")\n",
        "            )\n",
        "            for dot in self.dots + self.intersection_dots\n",
        "        ] + [\n",
        "            Transform(\n",
        "                deepcopy(line),\n",
        "                deepcopy(line).fade(0.4)\n",
        "            )\n",
        "            for line in self.lines + self.circle_pieces\n",
        "        ])\n",
        "        self.wait()\n",
        "        all_mobs = [mob for mob in self.mobjects]\n",
        "        self.remove(*all_mobs)\n",
        "        self.add(*[d[1] for d in [V, minus, E, plus, F, equals, two]])\n",
        "        V[1].set_color(\"white\")\n",
        "        two[1].set_color()\n",
        "        self.wait()\n",
        "        self.add(*all_mobs)\n",
        "        self.remove(*[d[1] for d in [V, minus, E, plus, F, equals, two]])\n",
        "        self.play(\n",
        "            Transform(V[2].repeat(2), Mobject(n[3], minus1[3], nc4[3])),\n",
        "            *[\n",
        "                Transform(d[2], d[3])\n",
        "                for d in [F, equals, E, minus, plus, two]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.play(\n",
        "            Transform(E[3], Mobject(\n",
        "                nc2[4], plus1[4], two1[4], nc41[4], plus2[4], n1[4]\n",
        "            )),\n",
        "            *[\n",
        "                Transform(d[3], d[4])\n",
        "                for d in [F, equals, minus, n, minus1, nc4, plus, two]\n",
        "            ] + [\n",
        "                Transform(\n",
        "                    deepcopy(line),\n",
        "                    deepcopy(line).scale(0.5),\n",
        "                )\n",
        "                for line in self.lines\n",
        "            ] + [\n",
        "                Transform(deepcopy(cp), scp)\n",
        "                for cp, scp in zip(self.circle_pieces, self.smaller_circle_pieces)\n",
        "            ],\n",
        "            run_time = 2.0\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                Mobject(plus2[4], n1[4], minus[4], n[4]),\n",
        "                Point((FRAME_X_RADIUS, FRAME_Y_RADIUS, 0))\n",
        "            ),\n",
        "            *[\n",
        "                Transform(d[4], d[5])\n",
        "                for d in [F, equals, nc2, plus1, two1, \n",
        "                          nc41, minus1, nc4, plus, two]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.play(\n",
        "            Transform(nc41[5], nc4[6]),\n",
        "            Transform(two1[5],  Point(nc4[6].get_center())),\n",
        "            *[\n",
        "                Transform(d[5], d[6])\n",
        "                for d in [F, equals, nc2, plus1, nc4, plus, two]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.play(\n",
        "            CounterclockwiseTransform(two[6], two[7]),\n",
        "            CounterclockwiseTransform(plus[6], plus[7]),\n",
        "            *[\n",
        "                Transform(d[6], d[7])\n",
        "                for d in [F, equals, nc2, plus1, nc4]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(*self.lines + self.circle_pieces)        \n",
        "        for region in self.regions:\n",
        "            self.set_color_region(region)\n",
        "        self.wait()\n",
        "        self.set_color_region(self.exterior, \"blue\")\n",
        "        self.wait()\n",
        "        self.set_color_region(self.exterior, \"black\")\n",
        "        self.remove(two[6])\n",
        "        two = two[7]\n",
        "        one = OldTex(\"1\").shift(two.get_center())\n",
        "        two.set_color(\"red\")\n",
        "        self.add(two)\n",
        "        self.play(CounterclockwiseTransform(two, one))\n",
        "\n",
        "class FormulaRelatesToPowersOfTwo(Scene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        pof2_range = [1, 2, 3, 4, 5, 10]\n",
        "        strings = [\n",
        "            [\n",
        "                r\"&1 + {%d \\choose 2} + {%d \\choose 4} =\"%(n, n),\n",
        "                r\"1 + %d + %d =\"%(choose(n, 2), choose(n, 4)),\n",
        "                r\"%d \\\\\"%moser_function(n)\n",
        "            ]\n",
        "            for n in [1, 2, 3, 4, 5, 10]\n",
        "        ]\n",
        "        everything = Texs(sum(strings, []), size = r\"\\large\")\n",
        "        scale_factor = 1\n",
        "        for mob in everything:\n",
        "            mob.scale(scale_factor)\n",
        "        Mobject(*everything).show()\n",
        "        forms   = everything[0::3]\n",
        "        sums    = everything[1::3]\n",
        "        results = everything[2::3]\n",
        "        self.add(*forms)\n",
        "        self.play(*[\n",
        "            FadeIn(s) for s in sums\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(deepcopy(s), result)\n",
        "            for s, result in zip(sums, results)\n",
        "        ])\n",
        "        powers_of_two = [\n",
        "            OldTex(\"2^{%d}\"%(i-1)\n",
        "            ).scale(scale_factor\n",
        "            ).shift(result.get_center()\n",
        "            ).set_color()\n",
        "            for i, result in zip(pof2_range, results)\n",
        "        ]\n",
        "        self.wait()\n",
        "        self.remove(*self.mobjects)\n",
        "        self.add(*forms + sums + results)\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(result, pof2)\n",
        "            for result, pof2 in zip(results, powers_of_two)\n",
        "        ])        \n",
        "\n",
        "class DrawPascalsTriangle(PascalsTriangleScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        PascalsTriangleScene.__init__(self, *args, **kwargs)\n",
        "        self.remove(*self.mobjects)\n",
        "        self.add(self.coords_to_mobs[0][0])\n",
        "        for n in range(1, nrows):\n",
        "            starts  = [deepcopy(self.coords_to_mobs[n-1][0])]\n",
        "            starts += [\n",
        "                Mobject(\n",
        "                    self.coords_to_mobs[n-1][k-1],\n",
        "                    self.coords_to_mobs[n-1][k]\n",
        "                )\n",
        "                for k in range(1, n)\n",
        "            ]\n",
        "            starts.append(deepcopy(self.coords_to_mobs[n-1][n-1]))\n",
        "            self.play(*[\n",
        "                Transform(starts[i], self.coords_to_mobs[n][i],\n",
        "                          run_time = 1.5, black_out_extra_points = False)\n",
        "                for i in range(n+1)\n",
        "            ])\n",
        "\n",
        "class PascalRuleExample(PascalsTriangleScene):\n",
        "    def __init__(self, nrows, *args, **kwargs):\n",
        "        assert(nrows > 1)    \n",
        "        PascalsTriangleScene.__init__(self, nrows, *args, **kwargs)\n",
        "        self.wait()\n",
        "        n = randint(2, nrows-1)\n",
        "        k = randint(1, n-1)\n",
        "        self.coords_to_mobs[n][k].set_color(\"green\")\n",
        "        self.wait()\n",
        "        plus = OldTex(\"+\").scale(0.5)\n",
        "        nums_above = [self.coords_to_mobs[n-1][k-1], self.coords_to_mobs[n-1][k]]\n",
        "        plus.center().shift(sum(map(Mobject.get_center, nums_above)) / 2)\n",
        "        self.add(plus)\n",
        "        for mob in nums_above + [plus]:\n",
        "            mob.set_color(\"yellow\")\n",
        "        self.wait()\n",
        "\n",
        "class PascalsTriangleWithNChooseK(PascalsTriangleScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        PascalsTriangleScene.__init__(self, *args, **kwargs)\n",
        "        self.generate_n_choose_k_mobs()\n",
        "        mob_dicts = (self.coords_to_mobs, self.coords_to_n_choose_k)\n",
        "        for i in [0, 1]:\n",
        "            self.wait()\n",
        "            self.remove(*self.mobjects)\n",
        "            self.play(*[\n",
        "                CounterclockwiseTransform(\n",
        "                    deepcopy(mob_dicts[i][n][k]), \n",
        "                    mob_dicts[1-i][n][k]\n",
        "                )\n",
        "                for n, k in self.coords\n",
        "            ])\n",
        "            self.remove(*self.mobjects)\n",
        "            self.add(*[mob_dicts[1-i][n][k] for n, k in self.coords])\n",
        "\n",
        "class PascalsTriangleNChooseKExample(PascalsTriangleScene):\n",
        "    args_list = [\n",
        "        (N_PASCAL_ROWS, 5, 3),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(nrows, n, k):\n",
        "        return \"%d_n=%d_k=%d\"%(nrows, n, k)\n",
        "\n",
        "    def __init__(self, nrows, n, k, *args, **kwargs):\n",
        "        PascalsTriangleScene.__init__(self, nrows, *args, **kwargs)\n",
        "        wait_time = 0.5\n",
        "        triangle_terms = [self.coords_to_mobs[a][b] for a, b in self.coords]\n",
        "        formula_terms = left, n_mob, k_mob, right = OldTex([\n",
        "            r\"\\left(\", str(n), r\"\\atop %d\"%k, r\"\\right)\"\n",
        "        ])\n",
        "        formula_center = (FRAME_X_RADIUS - 1, FRAME_Y_RADIUS - 1, 0)\n",
        "        self.remove(*triangle_terms)\n",
        "        self.add(*formula_terms)\n",
        "        self.wait()\n",
        "        self.play(*\n",
        "            [\n",
        "                ShowCreation(mob) for mob in triangle_terms\n",
        "            ]+[\n",
        "                ApplyMethod(mob.shift, formula_center)\n",
        "                for mob in formula_terms\n",
        "            ], \n",
        "            run_time = 1.0\n",
        "        )\n",
        "        self.remove(n_mob, k_mob)\n",
        "        for a in range(n+1):\n",
        "            row = [self.coords_to_mobs[a][b] for b in range(a+1)]\n",
        "            a_mob = OldTex(str(a))\n",
        "            a_mob.shift(n_mob.get_center())\n",
        "            a_mob.set_color(\"green\")\n",
        "            self.add(a_mob)\n",
        "            for mob in row:\n",
        "                mob.set_color(\"green\")\n",
        "            self.wait(wait_time)\n",
        "            if a < n:\n",
        "                for mob in row:\n",
        "                    mob.set_color(\"white\")\n",
        "                self.remove(a_mob)\n",
        "        self.wait()\n",
        "        for b in range(k+1):\n",
        "            b_mob = OldTex(str(b))\n",
        "            b_mob.shift(k_mob.get_center())\n",
        "            b_mob.set_color(\"yellow\")\n",
        "            self.add(b_mob)\n",
        "            self.coords_to_mobs[n][b].set_color(\"yellow\")\n",
        "            self.wait(wait_time)\n",
        "            if b < k:\n",
        "                self.coords_to_mobs[n][b].set_color(\"green\")\n",
        "                self.remove(b_mob)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 0.2)\n",
        "            for mob in triangle_terms\n",
        "            if mob != self.coords_to_mobs[n][k]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class PascalsTriangleSumRows(PascalsTriangleScene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        PascalsTriangleScene.__init__(self, *args, **kwargs)\n",
        "        pluses          = []\n",
        "        powers_of_two   = []\n",
        "        equalses        = []\n",
        "        powers_of_two_symbols = []\n",
        "        plus = OldTex(\"+\")\n",
        "        desired_plus_width = self.coords_to_mobs[0][0].get_width()\n",
        "        if plus.get_width() > desired_plus_width:\n",
        "            plus.scale(desired_plus_width / plus.get_width())\n",
        "        for n, k in self.coords:\n",
        "            if k == 0:\n",
        "                continue\n",
        "            new_plus = deepcopy(plus)\n",
        "            new_plus.center().shift(self.coords_to_mobs[n][k].get_center())\n",
        "            new_plus.shift((-self.cell_width / 2.0, 0, 0))\n",
        "            pluses.append(new_plus)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.scale(min(1, 0.7 * self.cell_height / equals.get_width()))\n",
        "        for n in range(self.nrows):\n",
        "            new_equals = deepcopy(equals)\n",
        "            pof2 = Texs(str(2**n))\n",
        "            symbol = OldTex(\"2^{%d}\"%n)\n",
        "            desired_center = np.array((\n",
        "                self.diagram_width / 2.0, \n",
        "                self.coords_to_mobs[n][0].get_center()[1],\n",
        "                0\n",
        "            ))\n",
        "            new_equals.shift(desired_center - new_equals.get_center())\n",
        "            desired_center += (1.5*equals.get_width(), 0, 0)\n",
        "            scale_factor = self.coords_to_mobs[0][0].get_height() / pof2.get_height()\n",
        "            for mob in pof2, symbol:\n",
        "                mob.center().scale(scale_factor).shift(desired_center)\n",
        "            symbol.shift((0, 0.5*equals.get_height(), 0)) #FUAH! Stupid\n",
        "            powers_of_two.append(pof2)\n",
        "            equalses.append(new_equals)\n",
        "            powers_of_two_symbols.append(symbol)\n",
        "        self.play(FadeIn(Mobject(*pluses)))\n",
        "        run_time = 0.5\n",
        "        to_remove = []\n",
        "        for n in range(self.nrows):\n",
        "            start = Mobject(*[self.coords_to_mobs[n][k] for k in range(n+1)])\n",
        "            to_remove.append(start)\n",
        "            self.play(\n",
        "                Transform(start, powers_of_two[n]),\n",
        "                FadeIn(equalses[n]),\n",
        "                run_time = run_time\n",
        "            )\n",
        "        self.wait()\n",
        "        self.remove(*to_remove)\n",
        "        self.add(*powers_of_two)\n",
        "        for n in range(self.nrows):\n",
        "            self.play(CounterclockwiseTransform(\n",
        "                powers_of_two[n], powers_of_two_symbols[n], \n",
        "                run_time = run_time\n",
        "            ))\n",
        "            self.remove(powers_of_two[n])\n",
        "            self.add(powers_of_two_symbols[n])\n",
        "    \n",
        "\n",
        "class MoserSolutionInPascal(PascalsTriangleScene):\n",
        "    args_list = [\n",
        "        (N_PASCAL_ROWS, n)\n",
        "        for n in range(3, 8)\n",
        "    ] + [\n",
        "        (BIG_N_PASCAL_ROWS, 10)\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(nrows, n):\n",
        "        return \"%d_n=%d\"%(nrows,n)\n",
        "\n",
        "    def __init__(self, nrows, n, *args, **kwargs):\n",
        "        PascalsTriangleScene.__init__(self, nrows, *args, **kwargs)\n",
        "        term_color = \"green\"\n",
        "        self.generate_n_choose_k_mobs()\n",
        "        self.remove(*[self.coords_to_mobs[n0][k0] for n0, k0 in self.coords])\n",
        "        terms = one, plus0, n_choose_2, plus1, n_choose_4 = OldTex([\n",
        "            \"1\", \"+\", r\"{%d \\choose 2}\"%n, \"+\", r\"{%d \\choose 4}\"%n\n",
        "        ]).split()\n",
        "        target_terms = []\n",
        "        for k in range(len(terms)):\n",
        "            if k%2 == 0 and k <= n:\n",
        "                new_term = deepcopy(self.coords_to_n_choose_k[n][k])\n",
        "                new_term.set_color(term_color)\n",
        "            else:\n",
        "                new_term = Point(\n",
        "                    self.coords_to_center(n, k)\n",
        "                )\n",
        "            target_terms.append(new_term)\n",
        "        self.add(*terms)\n",
        "        self.wait()\n",
        "        self.play(*\n",
        "            [\n",
        "                FadeIn(self.coords_to_n_choose_k[n0][k0])\n",
        "                for n0, k0 in self.coords\n",
        "                if (n0, k0) not in [(n, 0), (n, 2), (n, 4)]\n",
        "            ]+[\n",
        "                Transform(term, target_term)\n",
        "                for term, target_term in zip(terms, target_terms)\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        term_range = list(range(0, min(4, n)+1, 2))\n",
        "        target_terms = dict([\n",
        "            (k, deepcopy(self.coords_to_mobs[n][k]).set_color(term_color))\n",
        "            for k in term_range\n",
        "        ])\n",
        "        self.play(*\n",
        "            [\n",
        "                CounterclockwiseTransform(\n",
        "                    self.coords_to_n_choose_k[n0][k0],\n",
        "                    self.coords_to_mobs[n0][k0]\n",
        "                )\n",
        "                for n0, k0 in self.coords\n",
        "                if (n0, k0) not in [(n, k) for k in term_range]\n",
        "            ]+[\n",
        "                CounterclockwiseTransform(terms[k], target_terms[k])\n",
        "                for k in term_range\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        for k in term_range:\n",
        "            if k == 0:\n",
        "                above_terms = [self.coords_to_n_choose_k[n-1][k]]\n",
        "            elif k == n:\n",
        "                above_terms = [self.coords_to_n_choose_k[n-1][k-1]]\n",
        "            else:\n",
        "                above_terms = [\n",
        "                    self.coords_to_n_choose_k[n-1][k-1],\n",
        "                    self.coords_to_n_choose_k[n-1][k],\n",
        "                ]\n",
        "            self.add(self.coords_to_mobs[n][k])\n",
        "            self.play(Transform(\n",
        "                terms[k], \n",
        "                Mobject(*above_terms).set_color(term_color)\n",
        "            ))\n",
        "            self.remove(*above_terms)\n",
        "        self.wait()\n",
        "        terms_sum = OldTex(str(moser_function(n)))\n",
        "        terms_sum.shift((FRAME_X_RADIUS-1, terms[0].get_center()[1], 0))\n",
        "        terms_sum.set_color(term_color)\n",
        "        self.play(Transform(Mobject(*terms), terms_sum))\n",
        "\n",
        "class RotatingPolyhedra(Scene):\n",
        "    args_list = [\n",
        "        ([Cube, Dodecahedron],)\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(class_list):\n",
        "        return \"\".join([c.__name__ for c in class_list])\n",
        "\n",
        "    def __init__(self, polyhedra_classes, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        rot_kwargs = {\n",
        "            \"radians\"  : np.pi / 2,\n",
        "            \"run_time\" : 5.0,\n",
        "            \"axis\"     : [0, 1, 0]\n",
        "        }\n",
        "        polyhedra = [\n",
        "            Class().scale(1.5).shift((1, 0, 0))\n",
        "            for Class in polyhedra_classes\n",
        "        ]\n",
        "        curr_mob = polyhedra.pop()\n",
        "        for mob in polyhedra:\n",
        "            self.play(TransformAnimations(\n",
        "                Rotating(curr_mob, **rot_kwargs),\n",
        "                Rotating(mob, **rot_kwargs)\n",
        "            ))\n",
        "            for m in polyhedra:\n",
        "                m.rotate(rot_kwargs[\"radians\"], rot_kwargs[\"axis\"])\n",
        "        self.play(Rotating(curr_mob, **rot_kwargs))\n",
        "\n",
        "class ExplainNChoose2Formula(Scene):\n",
        "    args_list = [(7,2,6)]\n",
        "    @staticmethod\n",
        "    def args_to_string(n, a, b):\n",
        "        return \"n=%d_a=%d_b=%d\"%(n, a, b)\n",
        "\n",
        "    def __init__(self, n, a, b, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        r_paren, a_mob, comma, b_mob, l_paren = Texs(\n",
        "            (\"( %d , %d )\"%(a, b)).split(\" \")\n",
        "        )\n",
        "        parens = Mobject(r_paren, comma, l_paren)\n",
        "        nums = [Tex(str(k)) for k in range(1, n+1)]\n",
        "        height = 1.5*nums[0].get_height()\n",
        "        for x in range(n):\n",
        "            nums[x].shift((0, x*height, 0))\n",
        "        nums_compound = Mobject(*nums)\n",
        "        nums_compound.shift(a_mob.get_center() - nums[0].get_center())\n",
        "        n_mob, n_minus_1, over_2 = OldTex([\n",
        "            str(n), \"(%d-1)\"%n, r\"\\over{2}\"\n",
        "        ]).split()\n",
        "        for part in n_mob, n_minus_1, over_2:\n",
        "            part.shift((FRAME_X_RADIUS-1.5, FRAME_Y_RADIUS-1, 0))\n",
        "\n",
        "        self.add(parens, n_mob)\n",
        "        up_unit = np.array((0, height, 0))\n",
        "        self.play(ApplyMethod(nums_compound.shift, -(n-1)*up_unit))\n",
        "        self.play(ApplyMethod(nums_compound.shift, (n-a)*up_unit))\n",
        "        self.remove(nums_compound)\n",
        "        nums = nums_compound.split()\n",
        "        a_mob = nums.pop(a-1)\n",
        "        nums_compound = Mobject(*nums)\n",
        "        self.add(a_mob, nums_compound)\n",
        "        self.wait()        \n",
        "        right_shift = b_mob.get_center() - a_mob.get_center()\n",
        "        right_shift[1] = 0\n",
        "        self.play(\n",
        "            ApplyMethod(nums_compound.shift, right_shift),\n",
        "            FadeIn(n_minus_1)\n",
        "        )\n",
        "        self.play(ApplyMethod(nums_compound.shift, (a-b)*up_unit))\n",
        "        self.remove(nums_compound)\n",
        "        nums = nums_compound.split()\n",
        "        b_mob = nums.pop(b-2 if a < b else b-1)\n",
        "        self.add(b_mob)\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(\n",
        "                mob, \n",
        "                Point(mob.get_center()).set_color(\"black\")\n",
        "            )\n",
        "            for mob in nums\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, (0, 1, 0))\n",
        "            for mob in (parens, a_mob, b_mob)\n",
        "        ])\n",
        "        parens_copy = deepcopy(parens).shift((0, -2, 0))\n",
        "        a_center = a_mob.get_center()\n",
        "        b_center = b_mob.get_center()\n",
        "        a_copy = deepcopy(a_mob).center().shift(b_center - (0, 2, 0))\n",
        "        b_copy = deepcopy(b_mob).center().shift(a_center - (0, 2, 0))\n",
        "        self.add(over_2, deepcopy(a_mob), deepcopy(b_mob))\n",
        "        self.play(\n",
        "            CounterclockwiseTransform(a_mob, a_copy),\n",
        "            CounterclockwiseTransform(b_mob, b_copy),\n",
        "            FadeIn(parens_copy),\n",
        "            FadeIn(OldTexText(\"is considered the same as\"))\n",
        "        )\n",
        "\n",
        "class ExplainNChoose4Formula(Scene):\n",
        "    args_list = [(7,)]\n",
        "    @staticmethod\n",
        "    def args_to_string(n):\n",
        "        return \"n=%d\"%n\n",
        "\n",
        "    def __init__(self, n, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        # quad = list(it.combinations(range(1,n+1), 4))[randint(0, choose(n, 4)-1)]\n",
        "        quad = (4, 2, 5, 1)\n",
        "        tuple_mobs = Texs(\n",
        "            (\"( %d , %d , %d , %d )\"%quad).split(\" \")\n",
        "        )\n",
        "        quad_mobs = tuple_mobs[1::2]\n",
        "        parens = Mobject(*tuple_mobs[0::2])\n",
        "        form_mobs = OldTex([\n",
        "            str(n), \"(%d-1)\"%n, \"(%d-2)\"%n,\"(%d-3)\"%n,\n",
        "            r\"\\over {4 \\cdot 3 \\cdot 2 \\cdot 1}\"\n",
        "        ]).split()\n",
        "        form_mobs = Mobject(*form_mobs).scale(0.7).shift((4, 3, 0)).split()\n",
        "        nums = [Tex(str(k)) for k in range(1, n+1)]\n",
        "        height = 1.5*nums[0].get_height()\n",
        "        for x in range(n):\n",
        "            nums[x].shift((0, x*height, 0))\n",
        "        nums_compound = Mobject(*nums)\n",
        "        nums_compound.shift(quad_mobs[0].get_center() - nums[0].get_center())\n",
        "        curr_num = 1 \n",
        "        self.add(parens)\n",
        "        up_unit = np.array((0, height, 0))\n",
        "        for i in range(4):\n",
        "            self.add(form_mobs[i])\n",
        "            self.play(ApplyMethod(\n",
        "                nums_compound.shift, (curr_num-quad[i])*up_unit))\n",
        "            self.remove(nums_compound)\n",
        "            nums = nums_compound.split()\n",
        "            chosen = nums[quad[i]-1]\n",
        "            nums[quad[i]-1] = Point(chosen.get_center()).set_color(\"black\")\n",
        "            nums_compound = Mobject(*nums)\n",
        "            self.add(chosen)\n",
        "            if i < 3:\n",
        "                right_shift = quad_mobs[i+1].get_center() - chosen.get_center()\n",
        "                right_shift[1] = 0\n",
        "                self.play(\n",
        "                    ApplyMethod(nums_compound.shift, right_shift)\n",
        "                )\n",
        "            else:\n",
        "                self.play(*[\n",
        "                    CounterclockwiseTransform(\n",
        "                        mob, \n",
        "                        Point(mob.get_center()).set_color(\"black\")\n",
        "                    )\n",
        "                    for mob in nums\n",
        "                ])\n",
        "            curr_num = quad[i]\n",
        "        self.remove(*self.mobjects)\n",
        "        num_perms_explain = OldTexText(\n",
        "            r\"There are $(4 \\cdot 3 \\cdot 2 \\cdot 1)$ total permutations\"\n",
        "        ).shift((0, -2, 0))\n",
        "        self.add(parens, num_perms_explain, *form_mobs)\n",
        "        perms = list(it.permutations(list(range(4))))        \n",
        "        for count in range(6):\n",
        "            perm = perms[randint(0, 23)]\n",
        "            new_quad_mobs = [\n",
        "                deepcopy(quad_mobs[i]).shift(\n",
        "                    quad_mobs[perm[i]].get_center() - \\\n",
        "                    quad_mobs[i].get_center()\n",
        "                )\n",
        "                for i in range(4)\n",
        "            ]\n",
        "            compound_quad = Mobject(*quad_mobs)\n",
        "            self.play(CounterclockwiseTransform(\n",
        "                compound_quad,\n",
        "                Mobject(*new_quad_mobs)\n",
        "            ))\n",
        "            self.remove(compound_quad)\n",
        "            quad_mobs = new_quad_mobs\n",
        "\n",
        "class IntersectionChoppingExamples(Scene):\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "        pairs1 = [\n",
        "            ((-1,-1, 0), (-1, 0, 0)),\n",
        "            ((-1, 0, 0), (-1, 1, 0)),\n",
        "            ((-2, 0, 0), (-1, 0, 0)),\n",
        "            ((-1, 0, 0), ( 1, 0, 0)),\n",
        "            (( 1, 0, 0), ( 2, 0, 0)),\n",
        "            (( 1,-1, 0), ( 1, 0, 0)),\n",
        "            (( 1, 0, 0), ( 1, 1, 0)),\n",
        "        ]\n",
        "        pairs2 = pairs1 + [\n",
        "            (( 1, 1, 0), ( 1, 2, 0)),\n",
        "            (( 0, 1, 0), ( 1, 1, 0)),\n",
        "            (( 1, 1, 0), ( 2, 1, 0)),\n",
        "        ]\n",
        "        for pairs, exp in [(pairs1, \"3 + 2(2) = 7\"), \n",
        "                           (pairs2, \"4 + 2(3) = 10\")]:\n",
        "            lines = [Line(*pair).scale(2) for pair in pairs]\n",
        "            self.add(OldTex(exp).shift((0, FRAME_Y_RADIUS-1, 0)))\n",
        "            self.add(*lines)\n",
        "            self.wait()\n",
        "            self.play(*[\n",
        "                Transform(line, deepcopy(line).scale(1.2).scale(1/1.2))\n",
        "                for line in lines\n",
        "            ])\n",
        "            self.count(lines, run_time = 3.0, num_offset = ORIGIN)\n",
        "            self.wait()\n",
        "            self.remove(*self.mobjects)\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}