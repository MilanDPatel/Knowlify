{
    "topic": "demonstrates the concept of a chessboard with alternating colors and a slightly higher resolution",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def boolian_linear_combo(bools):\n",
        "    return reduce(op.xor, [b * n for n, b in enumerate(bools)], 0)\n",
        "\n",
        "\n",
        "def string_to_bools(message):\n",
        "    # For easter eggs on the board\n",
        "    as_int = int.from_bytes(message.encode(), 'big')\n",
        "    bits = \"{0:b}\".format(as_int)\n",
        "    bits = (len(message) * 8 - len(bits)) * '0' + bits\n",
        "    return [bool(int(b)) for b in bits]\n",
        "\n",
        "\n",
        "def layer_mobject(mobject, nudge=1e-6):\n",
        "    for i, sm in enumerate(mobject.family_members_with_points()):\n",
        "        sm.shift(i * nudge * OUT)\n",
        "\n",
        "\n",
        "def int_to_bit_coords(n, min_dim=3):\n",
        "    bits = \"{0:b}\".format(n)\n",
        "    bits = (min_dim - len(bits)) * '0' + bits\n",
        "    return np.array(list(map(int, bits)))\n",
        "\n",
        "\n",
        "def bit_coords_to_int(bits):\n",
        "    return sum([(2**n) * b for n, b in enumerate(reversed(bits))])\n",
        "\n",
        "\n",
        "def get_vertex_sphere(height=0.4, color=GREY, resolution=(21, 21)):\n",
        "    sphere = Sphere(resolution=resolution)\n",
        "    sphere.set_height(height)\n",
        "    sphere.set_color(color)\n",
        "    return sphere\n",
        "\n",
        "\n",
        "def get_bit_string(bit_coords):\n",
        "    result = VGroup(*[Integer(int(b)) for b in bit_coords])\n",
        "    result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "    result.set_stroke(BLACK, 4, background=True)\n",
        "    return result\n",
        "\n",
        "\n",
        "class Chessboard(SGroup):\n",
        "    CONFIG = {\n",
        "        \"shape\": (8, 8),\n",
        "        \"height\": 7,\n",
        "        \"depth\": 0.25,\n",
        "        \"colors\": [GREY_B, GREY_E],\n",
        "        \"gloss\": 0.2,\n",
        "        \"square_resolution\": (3, 3),\n",
        "        \"top_square_resolution\": (5, 5),\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        nr, nc = self.shape\n",
        "        cube = Cube(square_resolution=self.square_resolution)\n",
        "        # Replace top square with something slightly higher res\n",
        "        top_square = Square3D(resolution=self.top_square_resolution)\n",
        "        top_square.replace(cube[0])\n",
        "        cube.replace_submobject(0, top_square)\n",
        "        self.add(*[cube.copy() for x in range(nc * nr)])\n",
        "        self.arrange_in_grid(nr, nc, buff=0)\n",
        "        self.set_height(self.height)\n",
        "        self.set_depth(self.depth, stretch=True)\n",
        "        for i, j in it.product(range(nr), range(nc)):\n",
        "            color = self.colors[(i + j) % 2]\n",
        "            self[i * nc + j].set_color(color)\n",
        "        self.center()\n",
        "        self.set_gloss(self.gloss)\n",
        "\n",
        "\n",
        "class Coin(Group):\n",
        "    CONFIG = {\n",
        "        \"disk_resolution\": (4, 51),\n",
        "        \"height\": 1,\n",
        "        \"depth\": 0.1,\n",
        "        \"color\": GOLD_D,\n",
        "        \"tails_color\": RED,\n",
        "        \"include_labels\": True,\n",
        "        \"numeric_labels\": False,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        res = self.disk_resolution\n",
        "        self.top = Disk3D(resolution=res, gloss=0.2)\n",
        "        self.bottom = self.top.copy()\n",
        "        self.top.shift(OUT)\n",
        "        self.bottom.shift(IN)\n",
        "        self.edge = Cylinder(height=2, resolution=(res[1], 2))\n",
        "        self.add(self.top, self.bottom, self.edge)\n",
        "        self.rotate(90 * DEGREES, OUT)\n",
        "        self.set_color(self.color)\n",
        "        self.bottom.set_color(RED)\n",
        "\n",
        "        if self.include_labels:\n",
        "            chars = \"10\" if self.numeric_labels else \"HT\"\n",
        "            labels = VGroup(*[TexText(c) for c in chars])\n",
        "            for label, vect in zip(labels, [OUT, IN]):\n",
        "                label.shift(1.02 * vect)\n",
        "                label.set_height(0.8)\n",
        "            labels[1].rotate(PI, RIGHT)\n",
        "            labels.apply_depth_test()\n",
        "            labels.set_stroke(width=0)\n",
        "            self.add(*labels)\n",
        "            self.labels = labels\n",
        "\n",
        "        self.set_height(self.height)\n",
        "        self.set_depth(self.depth, stretch=True)\n",
        "\n",
        "    def is_heads(self):\n",
        "        return self.top.get_center()[2] > self.bottom.get_center()[2]\n",
        "\n",
        "    def flip(self, axis=RIGHT):\n",
        "        super().flip(axis)\n",
        "        return self\n",
        "\n",
        "\n",
        "class CoinsOnBoard(Group):\n",
        "    CONFIG = {\n",
        "        \"proportion_of_square_height\": 0.7,\n",
        "        \"coin_config\": {},\n",
        "    }\n",
        "\n",
        "    def __init__(self, chessboard, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        prop = self.proportion_of_square_height\n",
        "        for cube in chessboard:\n",
        "            coin = Coin(**self.coin_config)\n",
        "            coin.set_height(prop * cube.get_height())\n",
        "            coin.next_to(cube, OUT, buff=0)\n",
        "            self.add(coin)\n",
        "\n",
        "    def flip_at_random(self, p=0.5):\n",
        "        bools = np.random.random(len(self)) < p\n",
        "        self.flip_by_bools(bools)\n",
        "        return self\n",
        "\n",
        "    def flip_by_message(self, message):\n",
        "        self.flip_by_bools(string_to_bools(message))\n",
        "        return self\n",
        "\n",
        "    def flip_by_bools(self, bools):\n",
        "        for coin, head in zip(self, bools):\n",
        "            if coin.is_heads() ^ head:\n",
        "                coin.flip()\n",
        "        return self\n",
        "\n",
        "    def get_bools(self):\n",
        "        return [coin.is_heads() for coin in self]\n",
        "\n",
        "\n",
        "class Key(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"key\",\n",
        "        \"fill_color\": YELLOW_D,\n",
        "        \"fill_opacity\": 1,\n",
        "        \"stroke_color\": YELLOW_D,\n",
        "        \"stroke_width\": 0,\n",
        "        \"gloss\": 0.5,\n",
        "        \"depth_test\": True,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        self.rotate(PI / 2, OUT)\n",
        "\n",
        "\n",
        "class FlipCoin(Animation):\n",
        "    CONFIG = {\n",
        "        \"axis\": RIGHT,\n",
        "        \"run_time\": 1,\n",
        "        \"shift_dir\": OUT,\n",
        "    }\n",
        "\n",
        "    def __init__(self, coin, **kwargs):\n",
        "        super().__init__(coin, **kwargs)\n",
        "        self.shift_vect = coin.get_height() * self.shift_dir / 2\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        coin = self.mobject\n",
        "        for sm, start_sm in self.families:\n",
        "            sm.match_points(start_sm)\n",
        "        coin.rotate(alpha * PI, axis=self.axis)\n",
        "        coin.shift(4 * alpha * (1 - alpha) * self.shift_vect)\n",
        "        return coin\n",
        "\n",
        "\n",
        "# Scenes\n",
        "class IntroducePuzzle(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\": ThreeDCamera,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        chessboard = Chessboard()\n",
        "        chessboard.move_to(ORIGIN, OUT)\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            x_range=(0, 8), y_range=(0, 8),\n",
        "            faded_line_ratio=0\n",
        "        )\n",
        "        grid.match_height(chessboard)\n",
        "        grid.next_to(chessboard, OUT, 1e-8)\n",
        "        low_grid = grid.copy()\n",
        "        low_grid.next_to(chessboard, IN, 1e-8)\n",
        "        grid.add(low_grid)\n",
        "        grid.set_stroke(GREY, width=2)\n",
        "        grid.set_gloss(0.5)\n",
        "        grid.prepare_for_nonlinear_transform(0)\n",
        "\n",
        "        coins = CoinsOnBoard(chessboard)\n",
        "        coins.set_gloss(0.2)\n",
        "        coins_to_flip = Group()\n",
        "        head_bools = string_to_bools('3b1b  :)')\n",
        "        for coin, heads in zip(coins, head_bools):\n",
        "            if not heads:\n",
        "                coins_to_flip.add(coin)\n",
        "        coins_to_flip.shuffle()\n",
        "\n",
        "        count_label = VGroup(\n",
        "            Integer(0, edge_to_fix=RIGHT),\n",
        "            OldTexText(\"Coins\")\n",
        "        )\n",
        "        count_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        count_label.to_corner(UL)\n",
        "        count_label.fix_in_frame()\n",
        "\n",
        "        # Draw board and coins\n",
        "        frame.set_euler_angles(-25 * DEGREES, 70 * DEGREES, 0)\n",
        "        self.play(\n",
        "            FadeIn(chessboard),\n",
        "            ShowCreationThenDestruction(grid, lag_ratio=0.01),\n",
        "            frame.set_theta, 0,\n",
        "            frame.set_phi, 45 * DEGREES,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(count_label)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coins),\n",
        "            UpdateFromFunc(count_label[0], lambda m, c=coins: m.set_value(len(c))),\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FlipCoin, coins_to_flip, run_time=6, lag_ratio=0.1))\n",
        "        self.add(coins)\n",
        "        self.wait()\n",
        "\n",
        "        # Show key\n",
        "        key = Key()\n",
        "        key.rotate(PI / 4, RIGHT)\n",
        "        key.move_to(3 * OUT)\n",
        "        key.scale(0.8)\n",
        "        key.to_edge(LEFT, buff=1)\n",
        "\n",
        "        k = boolian_linear_combo(head_bools) ^ 63  # To make the flip below the actual solution\n",
        "        key_cube = Cube(square_resolution=(6, 6))\n",
        "        key_cube.match_color(chessboard[k])\n",
        "        key_cube.replace(chessboard[k], stretch=True)\n",
        "        chessboard.replace_submobject(k, key_cube)\n",
        "        key_square = key_cube[0]\n",
        "        chessboard.generate_target()\n",
        "        chessboard.save_state()\n",
        "        for i, cube in enumerate(chessboard.target):\n",
        "            if i == k:\n",
        "                cube[0].set_color(MAROON_E)\n",
        "            else:\n",
        "                cube.set_color(interpolate_color(cube.get_color(), BLACK, 0.8))\n",
        "\n",
        "        key.generate_target()\n",
        "        key.target.rotate(PI / 4, LEFT)\n",
        "        key.target.set_width(0.7 * key_square.get_width())\n",
        "        key.target.next_to(key_square, IN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(key, LEFT))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(coins, lag_ratio=0.01),\n",
        "            MoveToTarget(chessboard),\n",
        "        )\n",
        "        ks_top = key_square.get_top()\n",
        "        self.play(\n",
        "            Rotate(key_square, PI / 2, axis=LEFT, about_point=ks_top),\n",
        "            MoveToTarget(key),\n",
        "            frame.set_phi, 60 * DEGREES,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(key_square, PI / 2, axis=RIGHT, about_point=ks_top),\n",
        "            run_time=2,\n",
        "        )\n",
        "        chessboard.saved_state[k][0].match_color(key_square)\n",
        "        self.play(\n",
        "            chessboard.restore,\n",
        "            FadeIn(coins),\n",
        "            frame.set_phi, 0 * DEGREES,\n",
        "            frame.move_to, 2 * LEFT,\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # State goal\n",
        "        goal = OldTexText(\n",
        "            \"Communicate where\\\\\\\\the key is\",\n",
        "            \" by turning\\\\\\\\over one coin.\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        goal.next_to(count_label, DOWN, LARGE_BUFF, LEFT)\n",
        "        goal.fix_in_frame()\n",
        "        goal[1].set_color(YELLOW)\n",
        "\n",
        "        self.play(FadeIn(goal[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(goal[1]))\n",
        "        self.wait()\n",
        "\n",
        "        coin = coins[63]\n",
        "        rect = SurroundingRectangle(coin, color=TEAL)\n",
        "        rect.set_opacity(0.5)\n",
        "        rect.save_state()\n",
        "        rect.replace(chessboard)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(opacity=0)\n",
        "\n",
        "        self.play(Restore(rect, run_time=2))\n",
        "        self.add(coin, rect)\n",
        "        self.play(FlipCoin(coin), FadeOut(rect))\n",
        "\n",
        "\n",
        "class PrisonerPuzzleSetting(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"background_color\": GREY_E\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        p1 = PiCreature(color=BLUE_C, height=2)\n",
        "        p2 = PiCreature(color=RED, height=2)\n",
        "        warden = PiCreature(color=GREY_BROWN, height=2.5)\n",
        "        warden.flip()\n",
        "        result = VGroup(p1, p2, warden)\n",
        "        result.arrange(RIGHT, buff=2, aligned_edge=DOWN)\n",
        "        warden.shift(RIGHT)\n",
        "        result.center().to_edge(DOWN, buff=1.5)\n",
        "        return result\n",
        "\n",
        "    def construct(self):\n",
        "        pis = self.pi_creatures\n",
        "        p1, p2, warden = self.pi_creatures\n",
        "\n",
        "        names = VGroup(\n",
        "            OldTexText(\"Prisoner 1\\\\\\\\(you)\"),\n",
        "            OldTexText(\"Prisoner 2\"),\n",
        "            OldTexText(\"Warden\"),\n",
        "        )\n",
        "        for name, pi in zip(names, pis):\n",
        "            name.match_color(pi.body)\n",
        "            name.next_to(pi, DOWN)\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"Why do mathematicians\\\\\\\\always set their puzzles\\\\\\\\in prisons?\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        question.to_corner(UR)\n",
        "\n",
        "        self.remove(warden)\n",
        "        warden.look_at(p2.eyes)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, pis[:2], run_time=1.5, lag_ratio=0.3),\n",
        "            LaggedStartMap(FadeIn, names[:2], run_time=1.5, lag_ratio=0.3),\n",
        "        )\n",
        "        self.play(\n",
        "            p1.change, \"sad\",\n",
        "            p2.change, \"pleading\", warden.eyes\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(warden),\n",
        "            FadeIn(names[2]),\n",
        "        )\n",
        "        self.play(warden.change, \"conniving\", p2.eyes)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(question, lag_ratio=0.1))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(question))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class FromCoinToSquareMaps(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"messages\": [\n",
        "            \"Please, \",\n",
        "            \"go watch\",\n",
        "            \"Stand-up\",\n",
        "            \"Maths on\",\n",
        "            \"YouTube.\"\n",
        "        ],\n",
        "        \"flip_lag_ratio\": 0.05,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        messages = self.messages\n",
        "\n",
        "        board1 = Chessboard()\n",
        "        board1.set_width(5.5)\n",
        "        board1.to_corner(DL)\n",
        "\n",
        "        board2 = board1.copy()\n",
        "        board2.to_corner(DR)\n",
        "\n",
        "        coins = CoinsOnBoard(board1)\n",
        "        bools = string_to_bools(messages[0])\n",
        "        for coin, head in zip(coins, bools):\n",
        "            if not head:\n",
        "                coin.flip(RIGHT)\n",
        "\n",
        "        for cube in board2:\n",
        "            cube.original_color = cube.get_color()\n",
        "\n",
        "        arrow = Arrow(board1.get_right(), board2.get_left())\n",
        "        arrow.tip.set_stroke(width=0)\n",
        "\n",
        "        title1 = OldTexText(\"Pattern of coins\")\n",
        "        title2 = OldTexText(\"Individual square\")\n",
        "\n",
        "        for title, board in [(title1, board1), (title2, board2)]:\n",
        "            title.scale(0.5 / title[0][0].get_height())\n",
        "            title.next_to(board, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        title2.align_to(title1, UP)\n",
        "\n",
        "        def get_special_square(coins=coins, board=board2):\n",
        "            bools = [coin.is_heads() for coin in coins]\n",
        "            return board[boolian_linear_combo(bools)]\n",
        "\n",
        "        self.add(board1)\n",
        "        self.add(title1)\n",
        "        self.add(coins)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(board2, 2 * LEFT)\n",
        "        )\n",
        "        square = get_special_square()\n",
        "        rect = SurroundingRectangle(square, buff=0)\n",
        "        rect.set_color(PINK)\n",
        "        rect.next_to(square, OUT, buff=0.01)\n",
        "        self.play(\n",
        "            square.set_color, MAROON_C,\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(title2)\n",
        "        )\n",
        "\n",
        "        for message in messages[1:]:\n",
        "            new_bools = string_to_bools(message)\n",
        "            coins_to_flip = Group()\n",
        "            for coin, to_heads in zip(coins, new_bools):\n",
        "                if coin.is_heads() ^ to_heads:\n",
        "                    coins_to_flip.add(coin)\n",
        "            coins_to_flip.shuffle()\n",
        "            self.play(LaggedStartMap(\n",
        "                FlipCoin, coins_to_flip,\n",
        "                lag_ratio=self.flip_lag_ratio,\n",
        "                run_time=1,\n",
        "            ))\n",
        "\n",
        "            new_square = get_special_square()\n",
        "            self.play(\n",
        "                square.set_color, square.original_color,\n",
        "                new_square.set_color, MAROON_C,\n",
        "                rect.move_to, new_square, OUT,\n",
        "                rect.shift, 0.01 * OUT,\n",
        "            )\n",
        "            square = new_square\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class FromCoinToSquareMapsSingleFlips(FromCoinToSquareMaps):\n",
        "    CONFIG = {\n",
        "        \"messages\": [\n",
        "            \"FlipBits\",\n",
        "            \"BlipBits\",\n",
        "            \"ClipBits\",\n",
        "            \"ChipBits\",\n",
        "            \"ChipBats\",\n",
        "            \"ChipRats\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class DiagramOfProgression(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup panels\n",
        "        P1_COLOR = BLUE_C\n",
        "        P2_COLOR = RED\n",
        "\n",
        "        rect = Rectangle(4, 2)\n",
        "        rect.set_fill(GREY_E, 1)\n",
        "        panels = Group()\n",
        "        for x in range(4):\n",
        "            panels.add(Group(rect.copy()))\n",
        "        panels.arrange_in_grid(buff=1)\n",
        "        panels[::2].shift(0.5 * LEFT)\n",
        "        panels.set_width(FRAME_WIDTH - 2)\n",
        "        panels.center().to_edge(DOWN)\n",
        "        p1_shift = panels[1].get_center() - panels[0].get_center()\n",
        "        panels[1].move_to(panels[0])\n",
        "\n",
        "        chessboard = Chessboard()\n",
        "        chessboard.set_height(0.9 * panels[0].get_height())\n",
        "        coins = CoinsOnBoard(\n",
        "            chessboard,\n",
        "            coin_config={\n",
        "                \"disk_resolution\": (2, 25),\n",
        "            }\n",
        "        )\n",
        "        coins.flip_by_message(\"Tau > Pi\")\n",
        "\n",
        "        for panel in panels[1:]:\n",
        "            cb = chessboard.copy()\n",
        "            co = coins.copy()\n",
        "            cb.next_to(panel.get_right(), LEFT)\n",
        "            co.next_to(cb, OUT, 0)\n",
        "            panel.chessboard = cb\n",
        "            panel.coins = co\n",
        "            panel.add(cb, co)\n",
        "\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"Prisoner 1\": P1_COLOR,\n",
        "                \"Prisoner 2\": P2_COLOR,\n",
        "            }\n",
        "        }\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Prisoners conspire\", **kw),\n",
        "            OldTexText(\"Prisoner 1 sees key\", **kw),\n",
        "            OldTexText(\"Prisoner 1 flips coin\", **kw),\n",
        "            OldTexText(\"Prisoner 2 guesses key square\", **kw),\n",
        "        )\n",
        "\n",
        "        for panel, title in zip(panels, titles):\n",
        "            title.next_to(panel, UP)\n",
        "            panel.title = title\n",
        "            panel.add(title)\n",
        "\n",
        "        # Darken first chessboard\n",
        "        for coin in panels[1].coins:\n",
        "            coin.remove(coin.edge)\n",
        "            if coin.is_heads():\n",
        "                coin.remove(coin.bottom)\n",
        "                coin.remove(coin.labels[1])\n",
        "            else:\n",
        "                coin.remove(coin.top)\n",
        "                coin.remove(coin.labels[0])\n",
        "            coin.set_opacity(0.25)\n",
        "\n",
        "        # Add characters\n",
        "        prisoner1 = PiCreature(color=P1_COLOR)\n",
        "        prisoner2 = PiCreature(color=P2_COLOR)\n",
        "        pis = VGroup(prisoner1, prisoner2)\n",
        "        pis.arrange(RIGHT, buff=1)\n",
        "        pis.set_height(1.5)\n",
        "\n",
        "        p0_pis = pis.copy()\n",
        "        p0_pis.set_height(2.0, about_edge=DOWN)\n",
        "        p0_pis[1].flip()\n",
        "        p0_pis.next_to(panels[0].get_bottom(), UP, SMALL_BUFF)\n",
        "        p0_pis[0].change(\"pondering\", p0_pis[1].eyes)\n",
        "        p0_pis[1].change(\"speaking\", p0_pis[0].eyes)\n",
        "        panels[0].add(p0_pis)\n",
        "\n",
        "        p1_pi = pis[0].copy()\n",
        "        p1_pi.next_to(panels[1].get_corner(DL), UR, SMALL_BUFF)\n",
        "        p1_pi.change(\"happy\")\n",
        "        key = Key()\n",
        "        key.set_height(0.5)\n",
        "        key.next_to(p1_pi, UP)\n",
        "        key.set_color(YELLOW)\n",
        "        key_cube = panels[1].chessboard[18]\n",
        "        key_square = Square()\n",
        "        key_square.replace(key_cube)\n",
        "        key_square.set_stroke(width=3)\n",
        "        key_square.match_color(key)\n",
        "        p1_pi.look_at(key_square)\n",
        "        key_arrow = Arrow(\n",
        "            key.get_right() + SMALL_BUFF * UP,\n",
        "            key_square.get_corner(UL),\n",
        "            path_arc=-45 * DEGREES,\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "        key_arrow.tip.set_stroke(width=0)\n",
        "        key_arrow.match_color(key)\n",
        "        panels[1].add(p1_pi, key)\n",
        "\n",
        "        p2_pi = pis[0].copy()\n",
        "        p2_pi.next_to(panels[2].get_corner(DL), UR, SMALL_BUFF)\n",
        "        p2_pi.change(\"tease\")\n",
        "        flip_coin = panels[2].coins[38]\n",
        "        panels[3].coins[38].flip()\n",
        "        flip_square = Square()\n",
        "        flip_square.replace(panels[2].chessboard[38])\n",
        "        flip_square.set_stroke(BLUE, 5)\n",
        "        for coin in panels[2].coins:\n",
        "            if coin is not flip_coin:\n",
        "                coin.remove(coin.edge)\n",
        "                if coin.is_heads():\n",
        "                    coin.remove(coin.bottom)\n",
        "                    coin.remove(coin.labels[1])\n",
        "                else:\n",
        "                    coin.remove(coin.top)\n",
        "                    coin.remove(coin.labels[0])\n",
        "                coin.set_opacity(0.25)\n",
        "        panels[2].add(p2_pi)\n",
        "\n",
        "        p3_pi = pis[1].copy()\n",
        "        p3_pi.next_to(panels[3].get_corner(DL), UR, SMALL_BUFF)\n",
        "        p3_pi.shift(MED_LARGE_BUFF * RIGHT)\n",
        "        p3_pi.change(\"confused\")\n",
        "        panels[3].add(p3_pi)\n",
        "\n",
        "        # Animate each panel in\n",
        "        self.play(FadeIn(panels[1], DOWN))\n",
        "        self.play(\n",
        "            ShowCreation(key_arrow),\n",
        "            FadeInFromLarge(key_square),\n",
        "        )\n",
        "        panels[1].add(key_arrow, key_square)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(panels[2], UP))\n",
        "        self.play(\n",
        "            ShowCreation(flip_square),\n",
        "            FlipCoin(flip_coin),\n",
        "            p2_pi.look_at, flip_coin,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(panels[3], LEFT))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(panels[0], LEFT),\n",
        "            panels[1].shift, p1_shift,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ImpossibleVariations(FromCoinToSquareMaps):\n",
        "    CONFIG = {\n",
        "        \"messages\": [\n",
        "            \"FlipBits\",\n",
        "            \"BlipBits\",\n",
        "            \"ClipBits\",\n",
        "            \"ChipBits\",\n",
        "            \"ChipBats\",\n",
        "            \"ChipRats\",\n",
        "            \"ChipVats\",\n",
        "            \"ChipFats\",\n",
        "            \"ChapFats\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Definitions\n",
        "        frame = self.camera.frame\n",
        "        title = OldTexText(\"Describe any square\\\\\\\\with one flip\")\n",
        "        title.set_height(1.2)\n",
        "        title.to_edge(UP)\n",
        "        title.fix_in_frame()\n",
        "        messages = it.cycle(self.messages)\n",
        "\n",
        "        left_board = Chessboard()\n",
        "        right_board = Chessboard()\n",
        "        for board, vect in (left_board, LEFT), (right_board, RIGHT):\n",
        "            board.set_width(4.5)\n",
        "            board.to_corner(DOWN + vect, buff=LARGE_BUFF)\n",
        "        coins = CoinsOnBoard(left_board)\n",
        "        coins.flip_by_message(next(messages))\n",
        "\n",
        "        arrow = Arrow(left_board.get_right(), right_board.get_left())\n",
        "\n",
        "        # Prepare for colorings\n",
        "        for cube in right_board:\n",
        "            cube.original_color = cube.get_color()\n",
        "\n",
        "        def get_special_square(board=right_board, coins=coins):\n",
        "            return board[boolian_linear_combo(coins.get_bools())]\n",
        "\n",
        "        frame.set_phi(45 * DEGREES)\n",
        "\n",
        "        # Introduce boards\n",
        "        self.add(title)\n",
        "        group = Group(*left_board, *coins, *right_board)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, group, lambda m: (m, 1.3), lag_ratio=0.01),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "\n",
        "        # Flip one at a time\n",
        "        square = Square()\n",
        "        square.set_stroke(TEAL, 3)\n",
        "        square.replace(right_board[0])\n",
        "        square.move_to(right_board[0], OUT)\n",
        "        self.moving_square = square\n",
        "        self.colored_square = right_board[0]\n",
        "\n",
        "        for x in range(8):\n",
        "            self.set_board_message(next(messages), left_board, coins, get_special_square)\n",
        "            self.wait()\n",
        "\n",
        "        # To 6x6\n",
        "        to_fade = Group()\n",
        "        for grid in left_board, right_board, coins:\n",
        "            for n, mob in enumerate(grid):\n",
        "                row = n // 8\n",
        "                col = n % 8\n",
        "                if not ((0 < row < 7) and (0 < col < 7)):\n",
        "                    to_fade.add(mob)\n",
        "\n",
        "        cross = Cross(title)\n",
        "        cross.fix_in_frame()\n",
        "        cross.set_stroke(RED, 8)\n",
        "        cross.shift(2 * LEFT)\n",
        "        imp_words = OldTexText(\"Impossible!\")\n",
        "        imp_words.fix_in_frame()\n",
        "        imp_words.next_to(title, RIGHT, buff=1.5)\n",
        "        imp_words.shift(2 * LEFT)\n",
        "        imp_words.set_height(0.7)\n",
        "        imp_words.set_color(RED)\n",
        "\n",
        "        self.play(to_fade.set_opacity, 0.05)\n",
        "        self.play(\n",
        "            title.shift, 2 * LEFT,\n",
        "            FadeIn(cross, 2 * RIGHT),\n",
        "            FadeIn(imp_words, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(to_fade.set_opacity, 1)\n",
        "\n",
        "        # Remove a square\n",
        "        to_remove = Group(\n",
        "            left_board[63], right_board[63], coins[63]\n",
        "        )\n",
        "        remove_words = OldTexText(\"Remove one\\\\\\\\square\")\n",
        "        remove_words.set_color(RED)\n",
        "        remove_words.to_corner(DOWN, buff=1.5)\n",
        "        remove_words.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(remove_words, DOWN),\n",
        "            FadeOut(to_remove, 3 * IN),\n",
        "        )\n",
        "\n",
        "    def set_board_message(self, message, left_board, coins, get_special_square):\n",
        "        new_bools = string_to_bools(message)\n",
        "        coins_to_flip = Group()\n",
        "        for coin, to_heads in zip(coins, new_bools):\n",
        "            if coin.is_heads() ^ to_heads:\n",
        "                coins_to_flip.add(coin)\n",
        "        coins_to_flip.shuffle()\n",
        "        self.play(LaggedStartMap(\n",
        "            FlipCoin, coins_to_flip,\n",
        "            lag_ratio=self.flip_lag_ratio,\n",
        "            run_time=1,\n",
        "        ))\n",
        "\n",
        "        new_colored_square = get_special_square()\n",
        "        self.play(\n",
        "            new_colored_square.set_color, BLUE,\n",
        "            self.colored_square.set_color, self.colored_square.original_color,\n",
        "            self.moving_square.move_to, get_special_square(), OUT,\n",
        "        )\n",
        "        self.colored_square = new_colored_square\n",
        "\n",
        "\n",
        "class ErrorCorrectionMention(Scene):\n",
        "    def construct(self):\n",
        "        # Setup board\n",
        "        message = \"Do math!\"\n",
        "        error_message = \"Do meth!\"\n",
        "        board = Chessboard()\n",
        "        board.set_width(5)\n",
        "        board.to_corner(DL)\n",
        "        coins = CoinsOnBoard(board)\n",
        "        coins.flip_by_message(message)\n",
        "        bools = coins.get_bools()\n",
        "\n",
        "        right_board = board.copy()\n",
        "        right_board.to_corner(DR)\n",
        "        right_board.set_opacity(0.5)\n",
        "        right_board[boolian_linear_combo(bools)].set_color(BLUE, 1)\n",
        "\n",
        "        arrow = Arrow(board.get_right(), right_board.get_left())\n",
        "\n",
        "        words = OldTexText(\"Feels a bit like \", \"Error correction codes\", \"$\\\\dots$\")\n",
        "        words.scale(1.2)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(board, coins, right_board)\n",
        "        self.add(arrow)\n",
        "        self.add(words)\n",
        "\n",
        "        # Go from board diagram to bit string\n",
        "        bits = VGroup()\n",
        "        for coin in coins:\n",
        "            bit = Integer(1 if coin.is_heads() else 0)\n",
        "            bit.replace(coin, dim_to_match=1)\n",
        "            bits.add(bit)\n",
        "\n",
        "            coin.generate_target()\n",
        "            coin.target.rotate(90 * DEGREES, RIGHT)\n",
        "            coin.target.set_opacity(0)\n",
        "\n",
        "        bits_rect = SurroundingRectangle(bits, buff=MED_SMALL_BUFF)\n",
        "        bits_rect.set_stroke(YELLOW, 2)\n",
        "        data_label = OldTexText(\"Data\")\n",
        "        data_label.next_to(bits_rect, UP)\n",
        "        data_label.set_color(YELLOW)\n",
        "\n",
        "        meaning_label = OldTexText(f\"``{message}''\")\n",
        "        error_meaning_label = OldTexText(f\"``{error_message}''\")\n",
        "        for label in meaning_label, error_meaning_label:\n",
        "            label.scale(1.5)\n",
        "            label.next_to(arrow, RIGHT)\n",
        "        error_meaning_label[0][5].set_color(RED)\n",
        "\n",
        "        message_label = OldTexText(\"Message\")\n",
        "        message_label.set_color(BLUE)\n",
        "        message_label.next_to(meaning_label, UP, buff=1.5)\n",
        "        message_label.to_edge(RIGHT, LARGE_BUFF)\n",
        "        message_arrow = Arrow(\n",
        "            message_label.get_bottom(),\n",
        "            meaning_label.get_top(),\n",
        "        )\n",
        "        message_arrow = Arrow(\n",
        "            message_label.get_left(),\n",
        "            meaning_label.get_top(),\n",
        "            path_arc=70 * DEGREES,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, coins),\n",
        "            LaggedStartMap(FadeOut, board),\n",
        "            Write(bits),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            words[1].set_x, 0,\n",
        "            FadeOut(words[0], LEFT),\n",
        "            FadeOut(words[2], LEFT),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(bits_rect),\n",
        "            FadeIn(data_label, DOWN)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(right_board),\n",
        "            FadeIn(message_label, DOWN),\n",
        "            ShowCreation(message_arrow),\n",
        "            FadeIn(meaning_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Describe ECC\n",
        "        error_index = 8 * 4 + 5\n",
        "        error_bit = bits[error_index]\n",
        "        error_bit_rect = SurroundingRectangle(error_bit)\n",
        "        error_bit_rect.set_stroke(RED, 2)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromLarge(error_bit_rect),\n",
        "            error_bit.set_value, 1 - error_bit.get_value(),\n",
        "            error_bit.set_color, RED,\n",
        "        )\n",
        "        meaning_label.save_state()\n",
        "        self.play(\n",
        "            Transform(meaning_label, error_meaning_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about correction\n",
        "        question = OldTexText(\"How can you\\\\\\\\detect the error?\")\n",
        "        question.next_to(bits_rect, RIGHT, aligned_edge=UP)\n",
        "        self.play(Write(question))\n",
        "        self.wait(2)\n",
        "\n",
        "        ecc = VGroup()\n",
        "        for bit in int_to_bit_coords(boolian_linear_combo(bools), 6):\n",
        "            ecc.add(Integer(bit).match_height(bits[0]))\n",
        "        ecc.arrange(RIGHT, buff=0.2)\n",
        "        ecc.set_color(GREEN)\n",
        "        ecc.next_to(bits, RIGHT, MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "        ecc_rect = SurroundingRectangle(ecc, buff=MED_SMALL_BUFF)\n",
        "        ecc_rect.set_stroke(GREEN, 2)\n",
        "\n",
        "        ecc_name = words[1]\n",
        "        ecc_name.generate_target()\n",
        "        ecc_name.target[-1].set_opacity(0)\n",
        "        ecc_name.target.scale(0.75)\n",
        "        ecc_name.target.next_to(ecc_rect)\n",
        "        ecc_name.target.match_color(ecc)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(ecc_name),\n",
        "            ShowIncreasingSubsets(ecc),\n",
        "            ShowCreation(ecc_rect),\n",
        "            ApplyMethod(frame.move_to, DOWN, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show correction at play\n",
        "        lines = VGroup()\n",
        "        for bit in bits:\n",
        "            line = Line(ecc_rect.get_top(), bit.get_center())\n",
        "            line.set_stroke(GREEN, 1, opacity=0.7)\n",
        "            lines.add(line)\n",
        "\n",
        "        alert = OldTex(\"!!!\")[0]\n",
        "        alert.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        alert.scale(1.5)\n",
        "        alert.set_color(RED)\n",
        "        alert.next_to(ecc_rect, UP)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeOut, lines,\n",
        "            lag_ratio=0.02, run_time=3\n",
        "        ))\n",
        "        self.play(FadeIn(alert, DOWN, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(lines, lag_ratio=0))\n",
        "        for line in lines:\n",
        "            line.generate_target()\n",
        "            line.target.become(lines[error_index])\n",
        "        self.play(LaggedStartMap(MoveToTarget, lines, lag_ratio=0, run_time=1))\n",
        "        self.play(\n",
        "            error_bit.set_value, 0,\n",
        "            Restore(meaning_label)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(alert),\n",
        "            FadeOut(error_bit_rect),\n",
        "            error_bit.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Hamming name\n",
        "        hamming_label = OldTexText(\"e.g. Hamming codes\")\n",
        "        hamming_label.move_to(ecc_name, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(hamming_label),\n",
        "            FadeOut(ecc_name, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class StandupMathsWrapper(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\": \"Solution on Stand-up Maths\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        fsr = FullScreenFadeRectangle()\n",
        "        fsr.set_fill(GREY_E, 1)\n",
        "        self.add(fsr)\n",
        "\n",
        "        title = OldTexText(self.title)\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.next_to(title, DOWN)\n",
        "        rb = AnimatedBoundary(rect)\n",
        "\n",
        "        self.add(rect, rb)\n",
        "        self.play(Write(title))\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class ComingUpWrapper(StandupMathsWrapper):\n",
        "    CONFIG = {\n",
        "        \"title\": \"Coming up\"\n",
        "    }\n",
        "\n",
        "\n",
        "class TitleCard(Scene):\n",
        "    def construct(self):\n",
        "        n = 6\n",
        "        board = Chessboard(shape=(n, n))\n",
        "        for square in board:\n",
        "            square.set_color(interpolate_color(square.get_color(), BLACK, 0.25))\n",
        "        # board[0].set_opacity(0)\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            x_range=(0, n),\n",
        "            y_range=(0, n),\n",
        "            faded_line_ratio=0\n",
        "        )\n",
        "        grid.match_height(board)\n",
        "        grid.next_to(board, OUT, 1e-8)\n",
        "        low_grid = grid.copy()\n",
        "        low_grid.next_to(board, IN, 1e-8)\n",
        "        grid.add(low_grid)\n",
        "        grid.set_stroke(GREY, width=1)\n",
        "        grid.set_gloss(0.5)\n",
        "        grid.prepare_for_nonlinear_transform(0)\n",
        "        grid.rotate(PI, RIGHT)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_phi(45 * DEGREES)\n",
        "\n",
        "        text = OldTexText(\"The impossible\\\\\\\\chessboard puzzle\")\n",
        "        # text.set_width(board.get_width() - 0.5)\n",
        "        text.set_width(FRAME_WIDTH - 2)\n",
        "        text.set_stroke(BLACK, 10, background=True)\n",
        "        text.fix_in_frame()\n",
        "        self.play(\n",
        "            ApplyMethod(frame.set_phi, 0, run_time=5),\n",
        "            ShowCreationThenDestruction(grid, lag_ratio=0.02, run_time=3),\n",
        "            LaggedStartMap(FadeIn, board, run_time=3, lag_ratio=0),\n",
        "            Write(text, lag_ratio=0.1, run_time=3, stroke_color=BLUE_A),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WhatAreWeDoingHere(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait, what are we\\\\\\\\doing here then?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.change_students(\"hesitant\", \"angry\", \"sassy\")],\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(self.teacher.change, \"tease\")\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class HowCanWeVisualizeSolutions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"How can we\\\\\\\\visualize solutions\",\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "                \"fill_opacity\": 0,\n",
        "            },\n",
        "            added_anims=[self.change_students(\"pondering\", \"thinking\", \"pondering\")]\n",
        "        )\n",
        "        self.look_at(self.screen),\n",
        "        self.wait(1)\n",
        "        self.play_student_changes(\"thinking\", \"erm\", \"confused\")\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class TwoSquareCase(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"coin_names\": [\"c_0\", \"c_1\"]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        # Transition to just two square\n",
        "        chessboard = Chessboard()\n",
        "        chessboard.shift(2 * IN + UP)\n",
        "        coins = CoinsOnBoard(chessboard)\n",
        "        coins.flip_by_message(\"To 2 bits\")\n",
        "\n",
        "        to_remove = Group(*it.chain(*zip(chessboard[:1:-1], coins[:1:-1])))\n",
        "        small_board = chessboard[:2]\n",
        "        coin_pair = coins[:2]\n",
        "        small_group = Group(small_board, coin_pair)\n",
        "\n",
        "        frame.set_phi(45 * DEGREES)\n",
        "\n",
        "        two_square_words = OldTexText(\"What about a 2-square board?\")\n",
        "        two_square_words.fix_in_frame()\n",
        "        two_square_words.set_height(0.5)\n",
        "        two_square_words.center().to_edge(UP)\n",
        "\n",
        "        self.add(chessboard, coins)\n",
        "        self.play(\n",
        "            Write(two_square_words, run_time=1),\n",
        "            LaggedStartMap(\n",
        "                FadeOut, to_remove,\n",
        "                lambda m: (m, DOWN),\n",
        "                run_time=2,\n",
        "                lag_ratio=0.01\n",
        "            ),\n",
        "            small_group.center,\n",
        "            small_group.set_height, 1.5,\n",
        "            frame.set_phi, 10 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        coins = coin_pair\n",
        "\n",
        "        # Show two locations for the key\n",
        "        key = Key()\n",
        "        key.set_width(0.7 * small_board[0].get_width())\n",
        "        key.move_to(small_board[0])\n",
        "        key.shift(0.01 * OUT)\n",
        "\n",
        "        coin_pair.shift(0.04 * OUT)\n",
        "        s0_top = small_board[0][0].get_top()\n",
        "        s1_top = small_board[1][0].get_top()\n",
        "\n",
        "        s0_rot_group = Group(small_board[0][0], coin_pair[0])\n",
        "        s1_rot_group = Group(small_board[1][0], coin_pair[1])\n",
        "\n",
        "        self.add(key)\n",
        "        angle = 170 * DEGREES\n",
        "        self.play(\n",
        "            Rotate(s0_rot_group, angle, LEFT, about_point=s0_top),\n",
        "            Rotate(s1_rot_group, angle, LEFT, about_point=s1_top),\n",
        "            frame.set_phi, 45 * DEGREES,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            key.match_x, small_board[1],\n",
        "            path_arc=PI,\n",
        "            path_arc_axis=UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(s0_rot_group, angle, RIGHT, about_point=s0_top),\n",
        "            Rotate(s1_rot_group, angle, RIGHT, about_point=s1_top),\n",
        "            frame.set_phi, 0,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show four states pointing to two message\n",
        "        states = VGroup(*[\n",
        "            OldTexText(letters, tex_to_color_map={\"H\": GOLD, \"T\": RED_D})\n",
        "            for letters in [\"TT\", \"HT\", \"TH\", \"HH\"]\n",
        "        ])\n",
        "        states.set_height(0.8)\n",
        "        states.arrange(DOWN, buff=1)\n",
        "        states.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(two_square_words),\n",
        "            FlipCoin(coins[1]),\n",
        "            FadeIn(states[0])\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            FadeIn(states[1])\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            FlipCoin(coins[1]),\n",
        "            FadeIn(states[2])\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            FadeIn(states[3])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        key_copy = key.copy()\n",
        "        key_copy.match_x(small_board[0])\n",
        "        small_board_copy = small_board.copy()\n",
        "        small_boards = Group(small_board_copy, small_board)\n",
        "        for board, vect in zip(small_boards, [UP, DOWN]):\n",
        "            board.generate_target()\n",
        "            board.target.set_opacity(0.7)\n",
        "            board.target.shift(2 * vect)\n",
        "            board.target.set_depth(0.01, stretch=True)\n",
        "        self.add(key, key_copy, *small_boards)\n",
        "        self.play(\n",
        "            FadeOut(coins),\n",
        "            MoveToTarget(small_board),\n",
        "            MaintainPositionRelativeTo(key, small_board),\n",
        "            MoveToTarget(small_board_copy),\n",
        "            MaintainPositionRelativeTo(key_copy, small_board_copy),\n",
        "        )\n",
        "        self.add(*small_boards, key, key_copy)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for i in range(4):\n",
        "            arrows.add(Arrow(states[i].get_right(), small_boards[i // 2].get_left()))\n",
        "        arrows.set_opacity(0.75)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows, lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        # Show one flip changing interpretation\n",
        "        coins.next_to(states, LEFT, buff=1.5)\n",
        "\n",
        "        def get_state(coins=coins):\n",
        "            bools = [c.is_heads() for c in coins]\n",
        "            return sum([b * (2**n) for n, b in enumerate(reversed(bools))])\n",
        "\n",
        "        n = 3\n",
        "        state_rect = SurroundingRectangle(states[n])\n",
        "        board_rects = VGroup()\n",
        "        for board in small_boards:\n",
        "            br = SurroundingRectangle(board, buff=0)\n",
        "            br.move_to(board, OUT)\n",
        "            br.set_stroke(YELLOW, 3)\n",
        "            board_rects.add(br)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(frame.shift, 4.5 * LEFT, run_time=1),\n",
        "            FadeIn(coins),\n",
        "            FadeIn(state_rect),\n",
        "            FadeIn(board_rects[1]),\n",
        "            arrows[n].set_color, YELLOW,\n",
        "            arrows[n].set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            FadeOut(board_rects[1]),\n",
        "            FadeIn(board_rects[0]),\n",
        "            state_rect.move_to, states[1],\n",
        "            arrows[3].match_style, arrows[0],\n",
        "            arrows[1].match_style, arrows[3],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            state_rect.move_to, states[0],\n",
        "            arrows[0].match_style, arrows[1],\n",
        "            arrows[1].match_style, arrows[3],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            state_rect.move_to, states[1],\n",
        "            arrows[0].match_style, arrows[1],\n",
        "            arrows[1].match_style, arrows[0],\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Erase H and T, replace with 1 and 0\n",
        "        bin_states = VGroup(*[\n",
        "            OldTexText(letters, tex_to_color_map={\"1\": GOLD, \"0\": RED_D})\n",
        "            for letters in [\"00\", \"10\", \"01\", \"11\"]\n",
        "        ])\n",
        "        for bin_state, state in zip(bin_states, states):\n",
        "            for bit, letter in zip(bin_state, state):\n",
        "                bit.replace(letter, dim_to_match=1)\n",
        "        bin_coins = CoinsOnBoard(small_board, coin_config={\"numeric_labels\": True})\n",
        "        bin_coins[1].flip()\n",
        "        bin_coins.move_to(coins)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(coins, IN),\n",
        "            FadeIn(bin_coins),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, Group(*bin_states.family_members_with_points())),\n",
        "            LaggedStartMap(ApplyMethod, Group(*states.family_members_with_points()), lambda m: (m.scale, 0)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add labels\n",
        "        c_labels = VGroup(*[\n",
        "            OldTex(name)\n",
        "            for name in self.coin_names\n",
        "        ])\n",
        "        arrow_kw = {\n",
        "            \"tip_config\": {\n",
        "                \"width\": 0.2,\n",
        "                \"length\": 0.2,\n",
        "            },\n",
        "            \"buff\": 0.1,\n",
        "            \"color\": GREY_B,\n",
        "        }\n",
        "        # s_label_arrows = VGroup()\n",
        "        # for high_square, low_square, label in zip(*small_boards, s_labels):\n",
        "        #     label.move_to(Group(high_square, low_square))\n",
        "        #     label.arrows = VGroup(\n",
        "        #         Arrow(label.get_bottom(), low_square.get_top(), **arrow_kw),\n",
        "        #         Arrow(label.get_top(), high_square.get_bottom(), **arrow_kw),\n",
        "        #     )\n",
        "        #     s_label_arrows.add(*label.arrows)\n",
        "\n",
        "        #     self.play(\n",
        "        #         FadeIn(label),\n",
        "        #         *map(GrowArrow, label.arrows)\n",
        "        #     )\n",
        "\n",
        "        c_label_arrows = VGroup()\n",
        "        for label, coin in zip(c_labels, bin_coins):\n",
        "            label.next_to(coin, UP, LARGE_BUFF)\n",
        "            arrow = Arrow(label.get_bottom(), coin.get_top(), **arrow_kw)\n",
        "            c_label_arrows.add(arrow)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(label),\n",
        "                GrowArrow(arrow)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Coin 1 communicates location\n",
        "        bit1_rect = SurroundingRectangle(\n",
        "            VGroup(\n",
        "                bin_states[0][1],\n",
        "                bin_states[-1][1],\n",
        "            ),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        coin1_rect = SurroundingRectangle(\n",
        "            Group(c_labels[1], bin_coins[1]),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        for rect in bit1_rect, coin1_rect:\n",
        "            rect.insert_n_curves(100)\n",
        "            nd = int(12 * get_norm(rect.get_area_vector()))\n",
        "            rect.become(DashedVMobject(rect, num_dashes=nd))\n",
        "            rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        kw = {\n",
        "            \"stroke_width\": 2,\n",
        "            \"stroke_color\": YELLOW,\n",
        "            \"buff\": 0.05,\n",
        "        }\n",
        "        zero_rects, one_rects = [\n",
        "            VGroup(\n",
        "                SurroundingRectangle(bin_states[0][1], **kw),\n",
        "                SurroundingRectangle(bin_states[1][1], **kw),\n",
        "            ),\n",
        "            VGroup(\n",
        "                SurroundingRectangle(bin_states[2][1], **kw),\n",
        "                SurroundingRectangle(bin_states[3][1], **kw),\n",
        "            ),\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(bit1_rect),\n",
        "            ShowCreation(coin1_rect),\n",
        "            FadeOut(state_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(board_rects[0].stretch, 0.5, 0, {\"about_edge\": LEFT})\n",
        "        self.play(ShowCreation(zero_rects))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(board_rects[0]),\n",
        "            FadeOut(zero_rects),\n",
        "            FadeIn(board_rects[1])\n",
        "        )\n",
        "        self.play(\n",
        "            board_rects[1].stretch, 0.5, 0, {\"about_edge\": RIGHT}\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(bin_coins[1]),\n",
        "            arrows[1].match_style, arrows[0],\n",
        "            arrows[3].match_style, arrows[1],\n",
        "        )\n",
        "        self.play(ShowCreation(one_rects[1]))\n",
        "        self.wait()\n",
        "\n",
        "        # Talk about null bit\n",
        "        null_word = OldTexText(\"Null bit\")\n",
        "        null_word.next_to(bin_coins[0], DOWN, buff=1.5, aligned_edge=LEFT)\n",
        "        null_arrow = Arrow(null_word.get_top(), bin_coins[0].get_bottom())\n",
        "\n",
        "        self.play(\n",
        "            Write(null_word),\n",
        "            GrowArrow(null_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for i in (0, 1, 0):\n",
        "            self.play(\n",
        "                FlipCoin(bin_coins[0]),\n",
        "                arrows[3 - i].match_style, arrows[0],\n",
        "                arrows[2 + i].match_style, arrows[3 - i],\n",
        "                FadeOut(one_rects[1 - i]),\n",
        "                FadeIn(one_rects[i]),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Written mathematically\n",
        "        frame.generate_target()\n",
        "        frame.target.set_height(10, about_edge=DOWN)\n",
        "        rule_words = OldTexText(\"Rule: Just look at coin 1\")\n",
        "        rule_words.set_height(0.6)\n",
        "        rule_words.next_to(frame.target.get_corner(UL), DR, buff=0.5)\n",
        "        rule_arrow = Vector(1.5 * RIGHT)\n",
        "        rule_arrow.next_to(rule_words, RIGHT)\n",
        "        rule_arrow.set_color(BLUE)\n",
        "        rule_equation = OldTex(\"K\", \"=\", self.coin_names[1])\n",
        "        rule_equation_long = OldTex(\n",
        "            \"K\", \"=\", \"0\", \"\\\\cdot\",\n",
        "            self.coin_names[0], \"+\", \"1\", \"\\\\cdot\",\n",
        "            self.coin_names[1],\n",
        "        )\n",
        "\n",
        "        for equation in rule_equation, rule_equation_long:\n",
        "            equation.set_color_by_tex(\"S\", YELLOW)\n",
        "            equation.set_height(0.7)\n",
        "            equation.next_to(rule_arrow, RIGHT)\n",
        "\n",
        "        s_labels = VGroup(\n",
        "            OldTex(\"K\", \"= 0\"),\n",
        "            OldTex(\"K\", \"= 1\"),\n",
        "        )\n",
        "        for label, board in zip(s_labels, small_boards):\n",
        "            label.set_height(0.5)\n",
        "            label.next_to(board, UP)\n",
        "            label.set_color_by_tex(\"S\", YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            FadeIn(rule_words, 2 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        for label in s_labels:\n",
        "            self.play(Write(label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(rule_arrow),\n",
        "            FadeIn(rule_equation, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        mid_equation = rule_equation_long[2:-1]\n",
        "        mid_equation.save_state()\n",
        "        mid_equation.scale(0, about_edge=LEFT)\n",
        "        self.play(\n",
        "            Transform(rule_equation[:2], rule_equation_long[:2]),\n",
        "            Transform(rule_equation[2], rule_equation_long[-1]),\n",
        "            Restore(mid_equation),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(bin_coins)\n",
        "        for mob in self.mobjects:\n",
        "            for submob in mob.get_family():\n",
        "                if isinstance(submob, TexSymbol):\n",
        "                    submob.set_stroke(BLACK, 8, background=True)\n",
        "        self.add(bin_coins)\n",
        "\n",
        "\n",
        "class TwoSquaresAB(TwoSquareCase):\n",
        "    CONFIG = {\n",
        "        \"coin_names\": [\"a\", \"b\"]\n",
        "    }\n",
        "\n",
        "\n",
        "class IGotThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Pssh, I got this\",\n",
        "            target_mode=\"tease\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[self.teacher.change, \"happy\", self.screen],\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"thinking\", \"pondering\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class WalkingTheSquare(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup objects\n",
        "        plane = NumberPlane(\n",
        "            x_range=(-2, 2, 1),\n",
        "            y_range=(-2, 2, 1),\n",
        "            height=15,\n",
        "            width=15,\n",
        "            faded_line_ratio=3,\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        plane.move_to(1.5 * DOWN)\n",
        "        plane.add_coordinate_labels()\n",
        "        plane.x_axis.add_numbers([0])\n",
        "\n",
        "        board = Chessboard(shape=(1, 2))\n",
        "        board.set_height(1.5)\n",
        "        board.move_to(plane.c2p(-0.75, 0.75))\n",
        "        coins = CoinsOnBoard(\n",
        "            board,\n",
        "            coin_config={\"numeric_labels\": True}\n",
        "        )\n",
        "        coins.flip(RIGHT)\n",
        "\n",
        "        coords = [(0, 0), (0, 1), (1, 0), (1, 1)]\n",
        "        coord_labels = VGroup()\n",
        "        dots = VGroup()\n",
        "        for x, y in coords:\n",
        "            label = OldTex(f\"({x}, {y})\")\n",
        "            point = plane.c2p(x, y)\n",
        "            label.next_to(point, UR, buff=0.25)\n",
        "            dot = Dot(point, radius=0.075)\n",
        "            dot.set_color(GREY)\n",
        "            dots.add(dot)\n",
        "            coord_labels.add(label)\n",
        "\n",
        "        active_dot = Dot(radius=0.15, color=YELLOW)\n",
        "        active_dot.move_to(plane.c2p(0, 0))\n",
        "\n",
        "        # Walk around square\n",
        "        self.play(Write(plane))\n",
        "        self.play(\n",
        "            FadeIn(board),\n",
        "            FadeIn(coins),\n",
        "            FadeIn(active_dot),\n",
        "            FadeIn(coord_labels[0]),\n",
        "        )\n",
        "        edges = VGroup()\n",
        "        for i, j, c in [(0, 1, 1), (1, 3, 0), (3, 2, 1), (2, 0, 0)]:\n",
        "            edge = Line(plane.c2p(*coords[i]), plane.c2p(*coords[j]))\n",
        "            edge.set_stroke(PINK, 3)\n",
        "            edges.add(edge)\n",
        "\n",
        "            anims = [\n",
        "                FlipCoin(coins[c]),\n",
        "                ShowCreation(edge),\n",
        "                ApplyMethod(active_dot.move_to, dots[j])\n",
        "            ]\n",
        "            if j != 0:\n",
        "                anims += [\n",
        "                    FadeInFromPoint(coord_labels[j], coord_labels[i].get_center()),\n",
        "                ]\n",
        "            self.add(edge, dots[i], active_dot)\n",
        "            self.play(*anims)\n",
        "        self.add(edges, dots, active_dot)\n",
        "        self.wait()\n",
        "\n",
        "        # Show a few more flips\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            active_dot.move_to, dots[2],\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            active_dot.move_to, dots[3],\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            active_dot.move_to, dots[2],\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Circles illustrating scheme\n",
        "        low_rect = SurroundingRectangle(\n",
        "            VGroup(edges[3], coord_labels[0], coord_labels[2], plane.x_axis.numbers[-1]),\n",
        "            buff=0.25,\n",
        "        )\n",
        "        low_rect.round_corners()\n",
        "        low_rect.insert_n_curves(30)\n",
        "        low_rect.set_stroke(YELLOW, 3)\n",
        "        high_rect = low_rect.copy()\n",
        "        high_rect.shift(dots[1].get_center() - dots[0].get_center())\n",
        "\n",
        "        key = Key()\n",
        "        key.set_color(YELLOW)\n",
        "        key.set_gloss(0)\n",
        "        key.match_width(board[0])\n",
        "        key.next_to(board[0], UP, SMALL_BUFF)\n",
        "\n",
        "        s_labels = VGroup(\n",
        "            OldTex(\"\\\\text{Key} = 0\").next_to(low_rect, UP, SMALL_BUFF),\n",
        "            OldTex(\"\\\\text{Key} = 1\").next_to(high_rect, UP, SMALL_BUFF),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(low_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(key, DOWN),\n",
        "            FadeIn(s_labels[0], DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            active_dot.move_to, dots[0],\n",
        "        )\n",
        "        self.wait(0.5)\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            active_dot.move_to, dots[2],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(low_rect, high_rect),\n",
        "            FadeIn(s_labels[1], DOWN),\n",
        "            low_rect.set_stroke, GREY, 1,\n",
        "            FlipCoin(coins[1]),\n",
        "            active_dot.move_to, dots[3],\n",
        "            key.match_x, board[1],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[0]),\n",
        "            active_dot.move_to, dots[1],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            active_dot.move_to, dots[0],\n",
        "            key.match_x, board[0],\n",
        "            high_rect.match_style, low_rect,\n",
        "            low_rect.match_style, high_rect,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeSquareCase(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"coin_names\": [\"c_0\", \"c_1\", \"c_2\"]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Show sequence of boards\n",
        "        boards = Group(\n",
        "            Chessboard(shape=(1, 2), height=0.25 * 1),\n",
        "            Chessboard(shape=(1, 3), height=0.25 * 1),\n",
        "            Chessboard(shape=(2, 2), height=0.25 * 2),\n",
        "            Chessboard(shape=(8, 8), height=0.25 * 8),\n",
        "        )\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        group = Group(*boards[:3], dots, boards[3])\n",
        "\n",
        "        group.arrange(RIGHT)\n",
        "        group.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        board_groups = Group()\n",
        "        for board in boards:\n",
        "            board.coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "            board_groups.add(Group(board, board.coins))\n",
        "        boards[0].coins.flip_at_random()\n",
        "        boards[1].coins.flip_by_bools([False, True, False])\n",
        "        boards[2].coins.flip_at_random()\n",
        "        boards[3].coins.flip_by_message(\"3 Fails!\")\n",
        "\n",
        "        def get_board_transform(i, bgs=board_groups):\n",
        "            return TransformFromCopy(\n",
        "                bgs[i], bgs[i + 1],\n",
        "                path_arc=PI / 2,\n",
        "                run_time=2,\n",
        "            )\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.scale(0.5)\n",
        "        frame.move_to(boards[:2])\n",
        "\n",
        "        self.add(board_groups[0])\n",
        "        self.play(get_board_transform(0))\n",
        "        turn_animation_into_updater(Restore(frame, run_time=4))\n",
        "        self.add(frame)\n",
        "        self.play(get_board_transform(1))\n",
        "        self.play(\n",
        "            Write(dots),\n",
        "            get_board_transform(2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate 3 square board\n",
        "        board_group = board_groups[1]\n",
        "        board = boards[1]\n",
        "        coins = board.coins\n",
        "\n",
        "        title = OldTexText(\"Three square case\")\n",
        "        title.set_height(0.7)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        board_group.generate_target()\n",
        "        board_group.target.set_width(4)\n",
        "        board_group.target.move_to(DOWN, OUT)\n",
        "\n",
        "        self.save_state()\n",
        "        self.play(\n",
        "            MoveToTarget(board_group, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            Write(title),\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                board_groups[0],\n",
        "                board_groups[2],\n",
        "                dots,\n",
        "                board_groups[3],\n",
        "            ), lambda m: (m, DOWN)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Try 0*c0 + 1*c1 + 2*c2\n",
        "        s_sum = OldTex(\n",
        "            \"0\", \"\\\\cdot\", self.coin_names[0], \"+\",\n",
        "            \"1\", \"\\\\cdot\", self.coin_names[1], \"+\",\n",
        "            \"2\", \"\\\\cdot\", self.coin_names[2],\n",
        "        )\n",
        "        s_sum.set_height(0.6)\n",
        "        c_sum = s_sum.copy()\n",
        "        s_sum.center().to_edge(UP)\n",
        "        c_sum.next_to(s_sum, DOWN, LARGE_BUFF)\n",
        "\n",
        "        coin_copies = Group()\n",
        "        for i in range(3):\n",
        "            part = c_sum.get_part_by_tex(self.coin_names[i], substring=False)\n",
        "            coin_copy = coins[i].copy()\n",
        "            coin_copy.set_height(1.2 * c_sum[0].get_height())\n",
        "            coin_copy.move_to(part)\n",
        "            coin_copy.align_to(c_sum, UP)\n",
        "            part.set_opacity(0)\n",
        "            coin_copies.add(coin_copy)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            FadeIn(s_sum[:3]),\n",
        "            FadeIn(c_sum[:2]),\n",
        "        )\n",
        "        self.play(TransformFromCopy(coins[0], coin_copies[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(s_sum[3:7]),\n",
        "            FadeIn(c_sum[3:6]),\n",
        "        )\n",
        "        self.play(TransformFromCopy(coins[1], coin_copies[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(s_sum[7:11]),\n",
        "            FadeIn(c_sum[7:10]),\n",
        "        )\n",
        "        self.play(TransformFromCopy(coins[2], coin_copies[2]))\n",
        "        self.wait()\n",
        "        self.add(s_sum, c_sum, coin_copies)\n",
        "\n",
        "        rhs = VGroup(OldTex(\"=\"), Integer(1))\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs[1].set_color(YELLOW)\n",
        "        rhs.match_height(c_sum[0])\n",
        "        rhs.next_to(c_sum, RIGHT, aligned_edge=UP)\n",
        "        braces = VGroup(\n",
        "            Brace(c_sum[0:3], DOWN),\n",
        "            Brace(c_sum[0:7], DOWN),\n",
        "            Brace(c_sum[0:11], DOWN),\n",
        "        )\n",
        "        for brace, n in zip(braces, [0, 1, 1]):\n",
        "            brace.add(brace.get_tex(n))\n",
        "        self.play(GrowFromCenter(braces[0]))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(braces[0], braces[1]))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(braces[1], braces[2]))\n",
        "        self.play(\n",
        "            TransformFromCopy(braces[2][-1], rhs[1], path_arc=-PI / 2),\n",
        "            Write(rhs[0]),\n",
        "        )\n",
        "        self.play(FadeOut(braces[2]))\n",
        "        self.wait()\n",
        "\n",
        "        # Show values of S\n",
        "        s_labels = VGroup(*[\n",
        "            OldTex(f\"K = {n}\")\n",
        "            for n in range(3)\n",
        "        ])\n",
        "        for label, square in zip(s_labels, board):\n",
        "            label.next_to(square, UP)\n",
        "            label.set_width(0.8 * square.get_width())\n",
        "            label.set_color(YELLOW)\n",
        "\n",
        "        key = Key(depth_test=False)\n",
        "        key.set_stroke(BLACK, 3, background=True)\n",
        "        key.set_width(0.8 * board[0].get_width())\n",
        "        key.move_to(board[0])\n",
        "\n",
        "        self.play(\n",
        "            coins.next_to, board, DOWN,\n",
        "            coins.match_z, coins,\n",
        "            board.set_opacity, 0.75,\n",
        "            FadeIn(key),\n",
        "            FadeIn(s_labels[0])\n",
        "        )\n",
        "        self.wait(0.5)\n",
        "        for i in (1, 2):\n",
        "            self.play(\n",
        "                ApplyMethod(key.move_to, board[i], path_arc=-45 * DEGREES),\n",
        "                s_labels[i - 1].set_fill, GREY, 0.25,\n",
        "                FadeIn(s_labels[i]),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Mod 3 label\n",
        "        mod3_label = OldTexText(\"(mod 3)\")\n",
        "        mod3_label.match_height(s_sum)\n",
        "        mod3_label.set_color(BLUE)\n",
        "        mod3_label.next_to(s_sum, RIGHT, buff=0.75)\n",
        "\n",
        "        rhs_rhs = OldTex(\"\\\\equiv 0\")\n",
        "        rhs_rhs.match_height(rhs)\n",
        "        rhs_rhs.next_to(rhs, RIGHT)\n",
        "\n",
        "        self.play(Write(mod3_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[2]),\n",
        "            FlipCoin(coin_copies[2]),\n",
        "            rhs[1].set_value, 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(rhs_rhs))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rhs[1].set_value, 0,\n",
        "            FadeOut(rhs_rhs)\n",
        "        )\n",
        "\n",
        "        # Show a few flips\n",
        "        for i in [2, 1, 0, 2, 1, 2, 0]:\n",
        "            bools = coins.get_bools()\n",
        "            bools[i] = not bools[i]\n",
        "            new_sum = sum([n * b for n, b in enumerate(bools)]) % 3\n",
        "            self.play(\n",
        "                FlipCoin(coins[i]),\n",
        "                FlipCoin(coin_copies[i]),\n",
        "                rhs[1].set_value, new_sum,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show general sum\n",
        "        general_sum = OldTex(r\"\\sum ^{63}_{n=0}n\\cdot c_n\")\n",
        "        mod_64 = OldTexText(\"(mod 64)\")\n",
        "        mod_64.next_to(general_sum, DOWN)\n",
        "        general_sum.add(mod_64)\n",
        "        general_sum.to_corner(UL)\n",
        "\n",
        "        self.play(FadeIn(general_sum))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(general_sum))\n",
        "\n",
        "        # Walk through 010 example\n",
        "        board.flip_by_bools([False, False, True])\n",
        "        self.play(\n",
        "            s_labels[2].set_fill, GREY, 0.25,\n",
        "            s_labels[0].set_fill, YELLOW, 1,\n",
        "            ApplyMethod(key.move_to, board[0], path_arc=30 * DEGREES)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            FlipCoin(coin_copies[1]),\n",
        "            rhs[1].set_value, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "        square = Square()\n",
        "        square.set_stroke(YELLOW, 3)\n",
        "        square.replace(board[0])\n",
        "        square[0].move_to(board[0], OUT)\n",
        "        self.play(ShowCreation(square))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(square))\n",
        "\n",
        "        # Walk through alternate flip on 010 example\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            FlipCoin(coin_copies[1]),\n",
        "            rhs[1].set_value, 1,\n",
        "        )\n",
        "\n",
        "        morty = Mortimer(height=1.5, mode=\"hooray\")\n",
        "        morty.to_corner(DR)\n",
        "        bubble = SpeechBubble(height=2, width=2)\n",
        "        bubble.pin_to(morty)\n",
        "        bubble.write(\"There's another\\\\\\\\way!\")\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(morty),\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content, run_time=1),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeOut(VGroup(morty, bubble, bubble.content))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FlipCoin(coins[2]),\n",
        "            FlipCoin(coin_copies[2]),\n",
        "            rhs[1].set_value, 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(rhs[1].set_value, 0)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeSquaresABC(ThreeSquareCase):\n",
        "    CONFIG = {\n",
        "        \"coin_names\": [\"a\", \"b\", \"c\"]\n",
        "    }\n",
        "\n",
        "\n",
        "class FailedMod3Addition(Scene):\n",
        "    def construct(self):\n",
        "        coin = Coin(height=0.5, numeric_labels=True)\n",
        "        csum = Group(\n",
        "            OldTex(\"0 \\\\cdot\"),\n",
        "            coin.deepcopy().flip(),\n",
        "            OldTex(\" + 1 \\\\cdot\"),\n",
        "            coin.deepcopy().flip(),\n",
        "            OldTex(\"+ 2 \\\\cdot\"),\n",
        "            coin.deepcopy(),\n",
        "            OldTex(\"=\"),\n",
        "            Integer(2, color=YELLOW),\n",
        "        )\n",
        "        csum.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        csum[-1].shift(SMALL_BUFF * RIGHT)\n",
        "        coins = csum[1:7:2]\n",
        "        csum[-1].add_updater(lambda m, coins=coins: m.set_value(coins[1].is_heads() + 2 * coins[2].is_heads()))\n",
        "\n",
        "        self.add(csum)\n",
        "\n",
        "        for coin in coins[::-1]:\n",
        "            rect = SurroundingRectangle(coin)\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.play(FlipCoin(coin))\n",
        "            self.wait()\n",
        "            self.play(FlipCoin(coin), FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class TreeOfThreeFlips(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup sums\n",
        "        csum = Group(\n",
        "            OldTex(\"0 \\\\cdot\"),\n",
        "            Coin(numeric_labels=True),\n",
        "            OldTex(\"+\\\\,1 \\\\cdot\"),\n",
        "            Coin(numeric_labels=True),\n",
        "            OldTex(\"+\\\\,2 \\\\cdot\"),\n",
        "            Coin(numeric_labels=True),\n",
        "            OldTex(\"=\"),\n",
        "            Integer(0)\n",
        "        )\n",
        "        csum.coins = csum[1:7:2]\n",
        "        csum.coins.set_height(1.5 * csum[0].get_height())\n",
        "        csum.coins.flip(RIGHT)\n",
        "        csum.coins[1].flip(RIGHT)\n",
        "        csum.arrange(RIGHT, buff=0.1)\n",
        "        csum[-1].align_to(csum[0], DOWN)\n",
        "        csum[-1].shift(SMALL_BUFF * RIGHT)\n",
        "        csum.to_edge(LEFT)\n",
        "\n",
        "        csum_rect = SurroundingRectangle(csum, buff=SMALL_BUFF)\n",
        "        csum_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        # Set rhs values\n",
        "        def set_rhs_target(cs, colors=[RED, GREEN, BLUE]):\n",
        "            bools = [c.is_heads() for c in cs.coins]\n",
        "            value = sum([n * b for n, b in enumerate(bools)]) % 3\n",
        "            cs[-1].generate_target()\n",
        "            cs[-1].target.set_value(value)\n",
        "            cs[-1].target.set_color(colors[value])\n",
        "            return cs[-1]\n",
        "\n",
        "        rhs = set_rhs_target(csum)\n",
        "        rhs.become(rhs.target)\n",
        "\n",
        "        # Create copies\n",
        "        new_csums = Group()\n",
        "        for i in range(3):\n",
        "            new_csum = csum.deepcopy()\n",
        "            new_csum.coins = new_csum[1:7:2]\n",
        "            new_csums.add(new_csum)\n",
        "        new_csums.arrange(DOWN, buff=1.5)\n",
        "        new_csums.next_to(csum, RIGHT, buff=3)\n",
        "\n",
        "        # Arrows\n",
        "        arrows = VGroup()\n",
        "        for i, ncs in enumerate(new_csums):\n",
        "            arrow = Arrow(csum_rect.get_right(), ncs.get_left())\n",
        "            label = OldTexText(f\"Flip coin {i}\")\n",
        "            label.set_height(0.3)\n",
        "            label.set_fill(GREY_A)\n",
        "            label.set_stroke(BLACK, 3, background=True)\n",
        "            label.next_to(ORIGIN, UP, buff=0)\n",
        "            label.rotate(arrow.get_angle(), about_point=ORIGIN)\n",
        "            label.shift(arrow.get_center())\n",
        "            arrow.label = label\n",
        "            arrows.add(arrow)\n",
        "        arrows.set_color(GREY)\n",
        "\n",
        "        # Initial state label\n",
        "        is_label = OldTexText(\n",
        "            \"Initial state: 010\",\n",
        "            tex_to_color_map={\"0\": RED_D, \"1\": GOLD_D}\n",
        "        )\n",
        "        is_label.set_height(0.4)\n",
        "        is_label.next_to(csum_rect, UP, aligned_edge=LEFT)\n",
        "\n",
        "        # Show three flips\n",
        "        self.add(csum)\n",
        "        self.add(csum_rect)\n",
        "        self.add(is_label)\n",
        "        self.wait()\n",
        "\n",
        "        anims = []\n",
        "        for i, arrow, ncs in zip(it.count(), arrows, new_csums):\n",
        "            anims += [\n",
        "                GrowArrow(arrow),\n",
        "                FadeIn(arrow.label, lag_ratio=0.2),\n",
        "            ]\n",
        "        self.play(LaggedStart(*anims))\n",
        "        for indices in [[0], [1, 2]]:\n",
        "            self.play(*[\n",
        "                TransformFromCopy(csum, new_csums[i], path_arc=30 * DEGREES, run_time=2)\n",
        "                for i in indices\n",
        "            ])\n",
        "            self.wait()\n",
        "            for i in indices:\n",
        "                ncs = new_csums[i]\n",
        "                ncs.coins[i].flip()\n",
        "                rhs = set_rhs_target(ncs)\n",
        "                ncs.coins[i].flip()\n",
        "                self.play(\n",
        "                    FlipCoin(ncs.coins[i]),\n",
        "                    MoveToTarget(rhs)\n",
        "                )\n",
        "\n",
        "        # Put key in square 2\n",
        "        board = Chessboard(shape=(1, 3), square_resolution=(5, 5))\n",
        "        board.set_gloss(0.5)\n",
        "        board.set_width(3)\n",
        "        board.set_depth(0.25, stretch=True)\n",
        "        board.space_out_submobjects(factor=1.001)\n",
        "        board.next_to(ORIGIN, LEFT)\n",
        "        board.to_edge(UP)\n",
        "        board.shift(IN)\n",
        "        board.rotate(60 * DEGREES, LEFT)\n",
        "        opening_square = board[2][0]\n",
        "        opening_square_top = opening_square.get_corner(UP + IN)\n",
        "\n",
        "        key = Key()\n",
        "        key.to_corner(UL, buff=LARGE_BUFF)\n",
        "        key.shift(OUT)\n",
        "        key.generate_target()\n",
        "        key.target.scale(0.3)\n",
        "        key.target.rotate(60 * DEGREES, LEFT)\n",
        "        key.target.move_to(board[2][0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(board, DOWN),\n",
        "            FadeIn(key)\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(key, path_arc=30 * DEGREES),\n",
        "            Rotate(opening_square, 90 * DEGREES, LEFT, about_point=opening_square_top),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(opening_square, 90 * DEGREES, RIGHT, about_point=opening_square_top),\n",
        "            key.next_to, board[1], RIGHT, buff=0.01,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(key)\n",
        "        self.play(Rotate(board, 0 * DEGREES, RIGHT, run_time=0))\n",
        "        self.play(Rotate(board, 60 * DEGREES, RIGHT))\n",
        "\n",
        "        # Put coins on\n",
        "        coins = csum.coins.copy()\n",
        "        for coin, cube in zip(coins, board):\n",
        "            coin.generate_target()\n",
        "            coin.target.next_to(cube, OUT, buff=0)\n",
        "        self.play(LaggedStartMap(MoveToTarget, coins, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SeventyFivePercentChance(Scene):\n",
        "    def construct(self):\n",
        "        # Setup column\n",
        "        rows = []\n",
        "        n_shown = 5\n",
        "        coins = Group()\n",
        "        nums = VGroup()\n",
        "        for n in it.chain(range(n_shown), range(64 - n_shown, 64)):\n",
        "            coin = Coin(numeric_labels=True)\n",
        "            coin.set_height(0.7)\n",
        "            if (random.random() < 0.5 or (n == 2)) and (n != 62):\n",
        "                coin.flip()\n",
        "            num = Integer(n)\n",
        "            row = Group(\n",
        "                coin,\n",
        "                OldTex(\"\\\\cdot\"),\n",
        "                num,\n",
        "                OldTex(\"+\"),\n",
        "            )\n",
        "            VGroup(*row[1:]).set_stroke(BLACK, 3, background=True)\n",
        "            row.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            rows.append(row)\n",
        "            coins.add(coin)\n",
        "            nums.add(num)\n",
        "\n",
        "        vdots = OldTex(\"\\\\vdots\")\n",
        "        rows = Group(*rows[:n_shown], vdots, *rows[n_shown:])\n",
        "        rows.arrange(DOWN, buff=MED_SMALL_BUFF, aligned_edge=LEFT)\n",
        "        vdots.match_x(rows[0][2])\n",
        "        rows.set_height(7)\n",
        "        rows.to_edge(RIGHT)\n",
        "        rows[-1][-1].set_opacity(0)\n",
        "\n",
        "        nums = VGroup(*nums[:n_shown], vdots, *nums[n_shown:])\n",
        "        self.play(Write(nums))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, rows, lag_ratio=0.1, run_time=3),\n",
        "            Animation(nums.copy(), remover=True),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show desired sums\n",
        "        brace = Brace(rows, LEFT)\n",
        "        b_label = brace.get_text(\"Sum mod 64\")\n",
        "        sum_label = OldTexText(\"=\\\\, 53 (say)\")\n",
        "        sum_label.next_to(b_label, DOWN)\n",
        "        want_label = OldTexText(\"Need to encode 55 (say)\")\n",
        "        want_label.next_to(sum_label, DOWN, buff=0.25, aligned_edge=RIGHT)\n",
        "        want_label.set_color(YELLOW)\n",
        "        need_label = OldTexText(\"Must add 2\")\n",
        "        need_label.next_to(want_label, DOWN, buff=0.25)\n",
        "        need_label.set_color(BLUE)\n",
        "\n",
        "        for label in b_label, sum_label, want_label, need_label:\n",
        "            label.set_stroke(BLACK, 7, background=True)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(b_label, RIGHT)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(sum_label, 0.25 * UP))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(want_label, UP),\n",
        "            FadeIn(need_label, UP),\n",
        "            lag_ratio=0.3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show attempts\n",
        "        s_rect = SurroundingRectangle(rows[2])\n",
        "\n",
        "        self.play(ShowCreation(s_rect))\n",
        "        self.wait()\n",
        "        self.play(FlipCoin(rows[2][0]))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            s_rect.move_to, rows[-2],\n",
        "            s_rect.stretch, 1.1, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlipCoin(rows[-2][0]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ModNStrategy(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Board\n",
        "        n_shown = 5\n",
        "        board = Chessboard()\n",
        "        coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "        coins.flip_by_message(r\"75% odds\")\n",
        "\n",
        "        nums = VGroup()\n",
        "        for n, square in enumerate(board):\n",
        "            num = Integer(n)\n",
        "            num.set_height(0.4 * square.get_height())\n",
        "            num.next_to(square, OUT, buff=0)\n",
        "            nums.add(num)\n",
        "        nums.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        coins.generate_target()\n",
        "        for coin in coins.target:\n",
        "            coin.set_opacity(0.2)\n",
        "            coin[-2:].set_opacity(0)\n",
        "\n",
        "        self.add(board)\n",
        "        self.add(coins)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(coins),\n",
        "            FadeIn(nums, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # # Compress\n",
        "        # square_groups = Group(*[\n",
        "        #     Group(square, coin, num)\n",
        "        #     for square, coin, num in zip(board, coins, nums)\n",
        "        # ])\n",
        "        # segments = Group(\n",
        "        #     square_groups[:n_shown],\n",
        "        #     square_groups[n_shown:-n_shown],\n",
        "        #     square_groups[-n_shown:],\n",
        "        # )\n",
        "        # segments.generate_target()\n",
        "        # dots = OldTex(\"\\\\cdots\")\n",
        "        # dots.center()\n",
        "        # segments.target[0].next_to(dots, LEFT)\n",
        "        # segments.target[2].next_to(dots, RIGHT)\n",
        "        # segments.target[1].scale(0)\n",
        "        # segments.target[1].move_to(dots)\n",
        "\n",
        "        # self.play(\n",
        "        #     Write(dots),\n",
        "        #     MoveToTarget(segments),\n",
        "        # )\n",
        "        # self.wait()\n",
        "        # self.remove(segments[1])\n",
        "\n",
        "        # # Raise coins\n",
        "        # coins = Group(*coins[:n_shown], *coins[-n_shown:])\n",
        "        # nums = VGroup(*nums[:n_shown], *nums[-n_shown:])\n",
        "        # board = Group(*board[:n_shown], *board[-n_shown:])\n",
        "        # self.play(\n",
        "        #     coins.shift, UP,\n",
        "        #     coins.set_opacity, 1,\n",
        "        # )\n",
        "\n",
        "        # Setup sum\n",
        "        mid_coins = coins[n_shown:-n_shown]\n",
        "        mid_nums = nums[n_shown:-n_shown]\n",
        "        coins = Group(*coins[:n_shown], *coins[-n_shown:])\n",
        "        nums = VGroup(*nums[:n_shown], *nums[-n_shown:])\n",
        "        nums.generate_target()\n",
        "        coins.generate_target()\n",
        "        coins.target.set_opacity(1)\n",
        "\n",
        "        full_sum = Group()\n",
        "        to_fade_in = VGroup()\n",
        "        for num, coin in zip(nums.target, coins.target):\n",
        "            coin.set_height(0.7)\n",
        "            num.set_height(0.5)\n",
        "            summand = Group(\n",
        "                coin,\n",
        "                OldTex(\"\\\\cdot\"),\n",
        "                num,\n",
        "                OldTex(\"+\"),\n",
        "            )\n",
        "            to_fade_in.add(summand[1], summand[3])\n",
        "            VGroup(*summand[1:]).set_stroke(BLACK, 3, background=True)\n",
        "            summand.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "            full_sum.add(summand)\n",
        "\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        full_sum = Group(*full_sum[:n_shown], dots, *full_sum[n_shown:])\n",
        "        full_sum.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        full_sum.set_width(FRAME_WIDTH - 1)\n",
        "        full_sum[-1][-1].scale(0, about_edge=LEFT)\n",
        "        full_sum.move_to(UP)\n",
        "\n",
        "        brace = Brace(full_sum, DOWN)\n",
        "        s_label = VGroup(\n",
        "            OldTexText(\"Sum (mod 64) = \"),\n",
        "            Integer(53),\n",
        "        )\n",
        "        s_label[1].set_color(BLUE)\n",
        "        s_label[1].match_height(s_label[0][0][0])\n",
        "        s_label.arrange(RIGHT)\n",
        "        s_label[1].align_to(s_label[0][0][0], DOWN)\n",
        "        s_label.next_to(brace, DOWN)\n",
        "\n",
        "        words = OldTexText(\"Can't know if a flip will add or subtract\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        for mob in mid_coins, mid_nums:\n",
        "            mob.generate_target()\n",
        "            mob.target.move_to(dots)\n",
        "            mob.target.scale(0)\n",
        "            mob.target.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(board, IN),\n",
        "            MoveToTarget(mid_coins, remover=True),\n",
        "            MoveToTarget(mid_nums, remover=True),\n",
        "            MoveToTarget(nums),\n",
        "            MoveToTarget(coins),\n",
        "            Write(dots),\n",
        "            FadeIn(to_fade_in, lag_ratio=0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(s_label, 0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(words, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Do some flips\n",
        "        s_label[1].add_updater(lambda m: m.set_value(m.get_value() % 64))\n",
        "        for x in range(10):\n",
        "            n = random.randint(-n_shown, n_shown - 1)\n",
        "            coin = coins[n]\n",
        "            n = n % 64\n",
        "            diff_label = Integer(n, include_sign=True)\n",
        "            if not coin.is_heads():\n",
        "                diff_label.set_color(GREEN)\n",
        "            else:\n",
        "                diff_label.set_color(RED)\n",
        "                diff_label.set_value(-diff_label.get_value())\n",
        "            diff_label.next_to(coin, UP, aligned_edge=LEFT)\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(\n",
        "                    s_label[1],\n",
        "                    s_label[1].get_value() + n,\n",
        "                    rate_func=squish_rate_func(smooth, 0.5, 1)\n",
        "                ),\n",
        "                FlipCoin(coin),\n",
        "                FadeIn(diff_label, 0.5 * DOWN)\n",
        "            )\n",
        "            self.play(FadeOut(diff_label))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ShowCube(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Camera stuffs\n",
        "        frame = self.camera.frame\n",
        "        light = self.camera.light_source\n",
        "        light.move_to([-10, -10, 20])\n",
        "\n",
        "        # Plane and axes\n",
        "        plane = NumberPlane(\n",
        "            x_range=(-2, 2, 1),\n",
        "            y_range=(-2, 2, 1),\n",
        "            height=15,\n",
        "            width=15,\n",
        "            faded_line_ratio=3,\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        plane.add_coordinate_labels()\n",
        "        plane.coordinate_labels.set_stroke(width=0)\n",
        "        axes = ThreeDAxes(\n",
        "            x_range=(-2, 2, 1),\n",
        "            y_range=(-2, 2, 1),\n",
        "            z_range=(-2, 2, 1),\n",
        "            height=15,\n",
        "            width=15,\n",
        "            depth=15,\n",
        "        )\n",
        "        axes.apply_depth_test()\n",
        "\n",
        "        # Vertices and edges\n",
        "        vert_coords = [\n",
        "            (n % 2, (n // 2) % 2, (n // 4) % 2)\n",
        "            for n in range(8)\n",
        "        ]\n",
        "        verts = []\n",
        "        coord_labels = VGroup()\n",
        "        coord_labels_2d = VGroup()\n",
        "        for coords in vert_coords:\n",
        "            vert = axes.c2p(*coords)\n",
        "            verts.append(vert)\n",
        "            x, y, z = coords\n",
        "            label = OldTex(f\"({x}, {y}, {z})\")\n",
        "            label.set_height(0.3)\n",
        "            label.next_to(vert, UR, SMALL_BUFF)\n",
        "            label.rotate(89 * DEGREES, RIGHT, about_point=vert)\n",
        "            coord_labels.add(label)\n",
        "            if z == 0:\n",
        "                label_2d = OldTex(f\"({x}, {y})\")\n",
        "                label_2d.set_height(0.3)\n",
        "                label_2d.next_to(vert, UR, SMALL_BUFF)\n",
        "                coord_labels_2d.add(label_2d)\n",
        "\n",
        "        edge_indices = [\n",
        "            (0, 1), (0, 2), (1, 3), (2, 3),\n",
        "            (0, 4), (1, 5), (2, 6), (3, 7),\n",
        "            (4, 5), (4, 6), (5, 7), (6, 7),\n",
        "        ]\n",
        "\n",
        "        # Vertex and edge drawings\n",
        "        spheres = SGroup()\n",
        "        for vert in verts:\n",
        "            sphere = Sphere(\n",
        "                radius=0.1,\n",
        "                resolution=(9, 9),\n",
        "            )\n",
        "            sphere.set_gloss(0.3)\n",
        "            sphere.set_color(GREY)\n",
        "            sphere.move_to(vert)\n",
        "            spheres.add(sphere)\n",
        "\n",
        "        edges = SGroup()\n",
        "        for i, j in edge_indices:\n",
        "            edge = Line3D(\n",
        "                verts[i], verts[j],\n",
        "                resolution=(5, 51),\n",
        "                width=0.04,\n",
        "                gloss=0.5,\n",
        "            )\n",
        "            edge.set_color(GREY_BROWN)\n",
        "            edges.add(edge)\n",
        "\n",
        "        # Setup highlight animations\n",
        "        def highlight(n, spheres=spheres, coord_labels=coord_labels):\n",
        "            anims = []\n",
        "            for k, sphere, cl in zip(it.count(), spheres, coord_labels):\n",
        "                if k == n:\n",
        "                    sphere.save_state()\n",
        "                    cl.save_state()\n",
        "                    sphere.generate_target()\n",
        "                    cl.generate_target()\n",
        "                    cl.target.set_fill(YELLOW)\n",
        "                    sphere.target.set_color(YELLOW)\n",
        "                    Group(cl.target, sphere.target).scale(1.5, about_point=sphere.get_center())\n",
        "                    anims += [\n",
        "                        MoveToTarget(sphere),\n",
        "                        MoveToTarget(cl),\n",
        "                    ]\n",
        "                elif sphere.get_color() == Color(YELLOW):\n",
        "                    anims += [\n",
        "                        Restore(sphere),\n",
        "                        Restore(cl),\n",
        "                    ]\n",
        "            return AnimationGroup(*anims)\n",
        "\n",
        "        # Setup 2d case\n",
        "        frame.move_to(1.5 * UP)\n",
        "        self.add(plane)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, coord_labels_2d),\n",
        "            LaggedStartMap(GrowFromCenter, spheres[:4]),\n",
        "            LaggedStartMap(GrowFromCenter, edges[:4]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to 3d case\n",
        "        frame.generate_target()\n",
        "        frame.target.set_euler_angles(-25 * DEGREES, 70 * DEGREES)\n",
        "        frame.target.move_to([1, 2, 0])\n",
        "        frame.target.set_height(10)\n",
        "        to_grow = Group(*edges[4:], *spheres[4:], *coord_labels[4:])\n",
        "        to_grow.save_state()\n",
        "        to_grow.set_depth(0, about_edge=IN, stretch=True)\n",
        "\n",
        "        rf = squish_rate_func(smooth, 0.5, 1)\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            ShowCreation(axes.z_axis),\n",
        "            Restore(to_grow, rate_func=rf),\n",
        "            FadeOut(coord_labels_2d, rate_func=rf),\n",
        "            *[\n",
        "                FadeInFromPoint(cl, cl2.get_center(), rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "                for cl, cl2 in zip(coord_labels[:4], coord_labels_2d)\n",
        "            ],\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        frame.start_time = self.time\n",
        "        frame.scene = self\n",
        "        frame.add_updater(lambda m: m.set_theta(\n",
        "            -25 * DEGREES * math.cos((m.scene.time - m.start_time) * PI / 60)\n",
        "        ))\n",
        "\n",
        "        self.add(axes.z_axis)\n",
        "        self.add(edges)\n",
        "        self.add(spheres)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[Indicate(s, color=GREEN) for s in spheres], run_time=2, lag_ratio=0.1),\n",
        "            LaggedStart(*[Indicate(c, color=GREEN) for c in coord_labels], run_time=2, lag_ratio=0.1),\n",
        "        )\n",
        "\n",
        "        # Add chessboard\n",
        "        board = Chessboard(\n",
        "            shape=(1, 3), height=1,\n",
        "            square_resolution=(5, 5),\n",
        "        )\n",
        "        board.move_to(plane.c2p(-1, 0), DOWN + IN)\n",
        "        coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(board),\n",
        "            FadeIn(coins),\n",
        "            highlight(7)\n",
        "        )\n",
        "\n",
        "        # Walk along a few edges\n",
        "        for ci in [1, 2, 0, 1, 2, 1, 0, 1]:\n",
        "            coin = coins[ci]\n",
        "            curr_n = sum([(2**k) * c.is_heads() for k, c in enumerate(coins)])\n",
        "            coin.flip()\n",
        "            new_n = sum([(2**k) * c.is_heads() for k, c in enumerate(coins)])\n",
        "            coin.flip()\n",
        "            line = Line(verts[curr_n], verts[new_n])\n",
        "            line.set_stroke(YELLOW, 3)\n",
        "            self.play(\n",
        "                FlipCoin(coin),\n",
        "                highlight(new_n),\n",
        "                ShowCreationThenDestruction(line)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Color the corners\n",
        "        self.play(\n",
        "            highlight(-1),\n",
        "            edges.set_color, GREY, 0.5,\n",
        "        )\n",
        "\n",
        "        colors = [RED, GREEN, BLUE_D]\n",
        "        title = OldTexText(\"Strategy\", \"\\\\, $\\\\Leftrightarrow$ \\\\,\", \"Coloring\")\n",
        "        title[2].set_submobject_colors_by_gradient(*colors)\n",
        "        title.set_stroke(BLACK, 5, background=True)\n",
        "        title.set_height(0.7)\n",
        "        title.to_edge(UP)\n",
        "        title.shift(LEFT)\n",
        "        title.fix_in_frame()\n",
        "\n",
        "        color_label_templates = [\n",
        "            OldTex(char, color=color).rotate(PI / 2, RIGHT).match_depth(coord_labels[0])\n",
        "            for char, color in zip(\"RGB\", colors)\n",
        "        ]\n",
        "        coord_labels.color_labels = VGroup(*[VMobject() for cl in coord_labels])\n",
        "\n",
        "        def get_coloring_animation(ns,\n",
        "                                   spheres=spheres,\n",
        "                                   coord_labels=coord_labels,\n",
        "                                   colors=colors,\n",
        "                                   color_label_templates=color_label_templates,\n",
        "                                   ):\n",
        "            anims = []\n",
        "            new_color_labels = VGroup()\n",
        "            for n, sphere, coord_label, old_color_label in zip(ns, spheres, coord_labels, coord_labels.color_labels):\n",
        "                color = colors[int(n)]\n",
        "                sphere.generate_target()\n",
        "                coord_label.generate_target()\n",
        "                sphere.target.set_color(color)\n",
        "                coord_label.target.set_fill(color)\n",
        "                color_label = color_label_templates[n].copy()\n",
        "                color_label.next_to(coord_label, RIGHT, SMALL_BUFF)\n",
        "                anims += [\n",
        "                    MoveToTarget(sphere),\n",
        "                    MoveToTarget(coord_label),\n",
        "                    FadeIn(color_label, 0.25 * IN),\n",
        "                    FadeOut(old_color_label, 0.25 * OUT),\n",
        "                ]\n",
        "                new_color_labels.add(color_label)\n",
        "            coord_labels.color_labels = new_color_labels\n",
        "            return LaggedStart(*anims, run_time=2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(title, DOWN),\n",
        "            get_coloring_animation(np.random.randint(0, 3, 8)),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(4):\n",
        "            self.play(get_coloring_animation(np.random.randint(0, 3, 8)))\n",
        "            self.wait()\n",
        "\n",
        "        # Some specific color examples\n",
        "        S0 = OldTex(\"\\\\text{Key} = 0\")\n",
        "        S0.to_edge(LEFT)\n",
        "        S0.shift(UP)\n",
        "        S0.fix_in_frame()\n",
        "        self.play(\n",
        "            FadeIn(S0, DOWN),\n",
        "            get_coloring_animation([0] * 8)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        bit_sum = OldTex(\"\\\\text{Key} = \\\\,&c_0 + c_1\")\n",
        "        bit_sum.scale(0.8)\n",
        "        bit_sum.to_edge(LEFT)\n",
        "        bit_sum.shift(UP)\n",
        "        bit_sum.fix_in_frame()\n",
        "        self.play(\n",
        "            FadeIn(bit_sum, DOWN),\n",
        "            FadeOut(S0, UP),\n",
        "            get_coloring_animation([sum(coords[:2]) for coords in vert_coords])\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        bit_sum_with_coefs = OldTex(\n",
        "            \"\\\\text{Key} = \\\\,&(0\\\\cdot c_0 + 1\\\\cdot c_1 + 2\\\\cdot c_2) \\\\\\\\ &\\\\quad \\\\mod 3\"\n",
        "        )\n",
        "        bit_sum_with_coefs.scale(0.8)\n",
        "        bit_sum_with_coefs.move_to(bit_sum, LEFT)\n",
        "        bit_sum_with_coefs.fix_in_frame()\n",
        "        self.play(\n",
        "            FadeIn(bit_sum_with_coefs, DOWN),\n",
        "            FadeOut(bit_sum, UP),\n",
        "            get_coloring_animation([np.dot(coords, [0, 1, 2]) % 3 for coords in vert_coords])\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Focus on (0, 0, 0)\n",
        "        self.play(\n",
        "            FlipCoin(coins),\n",
        "            coord_labels[1:].set_opacity, 0.2,\n",
        "            coord_labels.color_labels[1:].set_opacity, 0.2,\n",
        "            spheres[1:].set_opacity, 0.2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for n in [1, 2, 4]:\n",
        "            line = Line(verts[0], verts[n], buff=0.1)\n",
        "            line.set_stroke(YELLOW, 3)\n",
        "            coin = coins[int(np.log2(n))]\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(line),\n",
        "                spheres[n].set_opacity, 1,\n",
        "                coord_labels[n].set_opacity, 1,\n",
        "                coord_labels.color_labels[n].set_opacity, 1,\n",
        "                FlipCoin(coin)\n",
        "            )\n",
        "            line.reverse_points()\n",
        "            self.add(line, coord_labels)\n",
        "            self.play(\n",
        "                FlipCoin(coin),\n",
        "                ShowCreation(line)\n",
        "            )\n",
        "            lines.add(line)\n",
        "        self.wait(10)\n",
        "\n",
        "        # Focus on (0, 1, 0)\n",
        "        self.play(\n",
        "            FlipCoin(coins[1]),\n",
        "            Uncreate(lines[1]),\n",
        "            FadeOut(lines[::2]),\n",
        "            Group(\n",
        "                spheres[0], coord_labels[0], coord_labels.color_labels[0],\n",
        "                spheres[1], coord_labels[1], coord_labels.color_labels[1],\n",
        "                spheres[4], coord_labels[4], coord_labels.color_labels[4],\n",
        "            ).set_opacity, 0.2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        lines = VGroup()\n",
        "        curr_n = 2\n",
        "        for n in [1, 2, 4]:\n",
        "            new_n = n ^ curr_n\n",
        "            line = Line(verts[curr_n], verts[new_n], buff=0.1)\n",
        "            line.set_stroke(YELLOW, 3)\n",
        "            coin = coins[int(np.log2(n))]\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(line),\n",
        "                spheres[new_n].set_opacity, 1,\n",
        "                coord_labels[new_n].set_opacity, 1,\n",
        "                coord_labels.color_labels[new_n].set_opacity, 1,\n",
        "                FlipCoin(coin)\n",
        "            )\n",
        "            line.reverse_points()\n",
        "            self.add(line, coord_labels)\n",
        "            self.play(\n",
        "                FlipCoin(coin),\n",
        "                ShowCreation(line)\n",
        "            )\n",
        "            lines.add(line)\n",
        "        self.wait(10)\n",
        "        self.play(\n",
        "            LaggedStartMap(Uncreate, lines),\n",
        "            spheres.set_opacity, 1,\n",
        "            coord_labels.set_opacity, 1,\n",
        "            coord_labels.color_labels.set_opacity, 1,\n",
        "            FadeOut(bit_sum_with_coefs),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(8):\n",
        "            self.play(get_coloring_animation(np.random.randint(0, 3, 8)))\n",
        "            self.wait()\n",
        "\n",
        "        # Count all strategies\n",
        "        count = OldTexText(\"$3^8$ total strategies\")\n",
        "        count64 = OldTexText(\"$64^{(2^{64})}$ total strategies\")\n",
        "        for words in count, count64:\n",
        "            words.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "            words.shift(UP)\n",
        "            words.fix_in_frame()\n",
        "\n",
        "        full_board = Chessboard()\n",
        "        full_board.set_height(6)\n",
        "        full_board.next_to(axes.c2p(0, 0, 0), np.array([-1, 1, 1]), buff=0)\n",
        "        full_board.shift(SMALL_BUFF * UP + LEFT)\n",
        "\n",
        "        full_coins = CoinsOnBoard(full_board, coin_config={\"numeric_labels\": True})\n",
        "        full_coins.flip_by_message(\"64^ 2^64\")\n",
        "\n",
        "        self.play(FadeIn(count, DOWN))\n",
        "        self.wait(4)\n",
        "        self.remove(board, coins)\n",
        "        frame.clear_updaters()\n",
        "        frame.generate_target()\n",
        "        frame.target.set_euler_angles(0, 45 * DEGREES)\n",
        "        frame.target.shift(2 * UP)\n",
        "        self.play(\n",
        "            count.shift, UP,\n",
        "            count.set_opacity, 0.5,\n",
        "            ShowIncreasingSubsets(full_board, run_time=4),\n",
        "            ShowIncreasingSubsets(full_coins, run_time=4),\n",
        "            FadeIn(count64, DOWN),\n",
        "            MoveToTarget(frame, run_time=5)\n",
        "        )\n",
        "\n",
        "        messages = [\n",
        "            \"Or, use \",\n",
        "            \"Burnside\",\n",
        "            \"to count\",\n",
        "            \"modulo  \",\n",
        "            \"symmetry\",\n",
        "        ]\n",
        "        for message in messages:\n",
        "            bools = string_to_bools(message)\n",
        "            to_flip = Group()\n",
        "            for head, coin in zip(bools, full_coins):\n",
        "                if head ^ coin.is_heads():\n",
        "                    to_flip.add(coin)\n",
        "            self.play(\n",
        "                LaggedStartMap(FlipCoin, to_flip, run_time=1)\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "        frame.generate_target()\n",
        "        frame.target.shift(2 * DOWN)\n",
        "        frame.target.set_euler_angles(-15 * DEGREES, 70 * DEGREES)\n",
        "        self.play(\n",
        "            MoveToTarget(frame, run_time=3),\n",
        "            LaggedStartMap(FadeOut, full_board),\n",
        "            LaggedStartMap(FadeOut, full_coins),\n",
        "            FadeOut(count),\n",
        "            FadeOut(count64),\n",
        "        )\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(0.01 * dt))\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class CubeSupplement(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"try_different_strategies\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Map 8 states to square choices\n",
        "        boards = Group(*[Chessboard(shape=(1, 3)) for x in range(8)])\n",
        "        boards.arrange(DOWN, buff=0.5 * boards[0].get_height())\n",
        "        boards.set_height(7)\n",
        "        boards.to_edge(LEFT)\n",
        "\n",
        "        coin_sets = Group(*[\n",
        "            CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "            for board in boards\n",
        "        ])\n",
        "        vert_coords = [[n // 4, (n // 2) % 2, n % 2] for n in range(7, -1, -1)]\n",
        "        for coords, coins in zip(vert_coords, coin_sets):\n",
        "            coins.flip_by_bools(coords)\n",
        "\n",
        "        def get_choice_boards(values, boards):\n",
        "            choices = VGroup()\n",
        "            for value, board in zip(values, boards):\n",
        "                choice = VGroup(*[Square() for x in range(3)])\n",
        "                choice.arrange(RIGHT, buff=0)\n",
        "                choice.match_height(board)\n",
        "                choice.next_to(board, RIGHT, buff=1.25)\n",
        "                choice.set_fill(GREY_D, 1)\n",
        "                choice.set_stroke(WHITE, 1)\n",
        "                choice[value].set_fill(TEAL)\n",
        "                choices.add(choice)\n",
        "            return choices\n",
        "\n",
        "        colors = [RED, GREEN, BLUE_D]\n",
        "        color_words = [\"Red\", \"Green\", \"Blue\"]\n",
        "        s_values = [sum([n * v for n, v in enumerate(cs)]) % 3 for cs in vert_coords]\n",
        "        choice_boards = get_choice_boards(s_values, boards)\n",
        "        c_labels = VGroup()\n",
        "        s_arrows = VGroup()\n",
        "        for value, board, choice_board in zip(s_values, boards, choice_boards):\n",
        "            arrow = Vector(RIGHT)\n",
        "            arrow.next_to(board, RIGHT, SMALL_BUFF)\n",
        "            c_label = OldTexText(color_words[value], color=colors[value])\n",
        "            c_label.next_to(choice_board, RIGHT)\n",
        "            c_labels.add(c_label)\n",
        "            s_arrows.add(arrow)\n",
        "\n",
        "            choice_board.generate_target()\n",
        "            choice_board.target[value].set_fill(colors[value])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, boards, lag_ratio=0.25),\n",
        "            LaggedStartMap(FadeIn, coin_sets, lag_ratio=0.25),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, s_arrows, lag_ratio=0.25),\n",
        "            LaggedStartMap(FadeIn, choice_boards, lambda m: (m, LEFT), lag_ratio=0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fork\n",
        "        if self.try_different_strategies:\n",
        "            for x in range(5):\n",
        "                values = list(np.arange(8) % 3)\n",
        "                random.shuffle(values)\n",
        "                new_cboards = get_choice_boards(values, boards)\n",
        "                self.play(\n",
        "                    LaggedStartMap(FadeOut, choice_boards, lambda m: (m, 0.25 * UP)),\n",
        "                    LaggedStartMap(FadeIn, new_cboards, lambda m: (m, 0.25 * DOWN)),\n",
        "                )\n",
        "                choice_boards = new_cboards\n",
        "                self.wait(2)\n",
        "\n",
        "        else:\n",
        "            # Associate choices with colors\n",
        "            self.play(\n",
        "                LaggedStartMap(MoveToTarget, choice_boards),\n",
        "                LaggedStartMap(FadeIn, c_labels),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class TryDifferentCaseThreeStrategies(CubeSupplement):\n",
        "    CONFIG = {\n",
        "        \"try_different_strategies\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class CubeEdgeDescription(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_color\": GREY_E}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        bits = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Integer(int(b))\n",
        "                for b in string_to_bools(char)\n",
        "            ]).arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            for char in \"hi\"\n",
        "        ])\n",
        "        bits.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            bits[0][7].get_bottom(),\n",
        "            bits[1][7].get_top(),\n",
        "            buff=SMALL_BUFF,\n",
        "            tip_config={\"length\": 0.15, \"width\": 0.15}\n",
        "        )\n",
        "        arrow.set_color(BLUE)\n",
        "        words = OldTexText(\"Bit flip\")\n",
        "        words.set_color(BLUE)\n",
        "        words.next_to(arrow, LEFT)\n",
        "        bf_group = VGroup(bits, arrow, words)\n",
        "        parens = OldTex(\"()\")[0]\n",
        "        parens.scale(2)\n",
        "        parens.match_height(bf_group, stretch=True)\n",
        "        parens[0].next_to(bf_group, LEFT, SMALL_BUFF)\n",
        "        parens[1].next_to(bf_group, RIGHT, SMALL_BUFF)\n",
        "        bf_group.add(parens)\n",
        "        bf_group.to_edge(UP)\n",
        "\n",
        "        cube_words = OldTexText(\"Edge of an\\\\\\\\n-dimensional cube\")\n",
        "        top_group = VGroup(\n",
        "            bf_group,\n",
        "            Vector(RIGHT),\n",
        "            cube_words\n",
        "        )\n",
        "        top_group.arrange(RIGHT)\n",
        "        top_group.to_edge(UP)\n",
        "\n",
        "        self.add(bf_group)\n",
        "        self.play(\n",
        "            TransformFromCopy(*bits),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(words, 0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(top_group[1]),\n",
        "            FadeIn(cube_words, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EdgeColoringExample(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\n",
        "                \"Color edges\\\\\\\\red or blue\",\n",
        "                tex_to_color_map={\"red\": RED, \"blue\": BLUE}\n",
        "            ),\n",
        "            OldTexText(\"Prove there is a\\\\\\\\monochromatic triangle\", alignment=\"\"),\n",
        "        )\n",
        "        words.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        words.to_edge(RIGHT)\n",
        "        words.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        def get_graph(words=words):\n",
        "            points = compass_directions(6)\n",
        "            points *= 3\n",
        "            verts = VGroup(*[Dot(p, radius=0.1) for p in points])\n",
        "            verts.set_fill(GREY_B, 1)\n",
        "            edges = VGroup(*[\n",
        "                Line(p1, p2, color=random.choice([RED, BLUE]))\n",
        "                for p1, p2 in it.combinations(points, 2)\n",
        "            ])\n",
        "            graph = VGroup(verts, edges)\n",
        "            graph.set_height(6)\n",
        "            graph.next_to(words, LEFT, LARGE_BUFF)\n",
        "            graph.set_y(0)\n",
        "            graph.set_stroke(background=True)\n",
        "            return graph\n",
        "\n",
        "        graph = get_graph()\n",
        "\n",
        "        self.add(words)\n",
        "        self.add(graph)\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            new_graph = get_graph()\n",
        "            self.play(\n",
        "                ShowCreation(\n",
        "                    new_graph, lag_ratio=0.1,\n",
        "                    run_time=3,\n",
        "                ),\n",
        "                ApplyMethod(\n",
        "                    graph[1].set_stroke, None, 0,\n",
        "                    run_time=2,\n",
        "                )\n",
        "            )\n",
        "            graph = new_graph\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class GrahamsConstantAlt(Scene):\n",
        "    def construct(self):\n",
        "        # lhs = OldTex(\"g_{64}\", \"=\")\n",
        "        # lhs[0][1:].scale(0.7, about_edge=DL)\n",
        "        lhs = OldTex(\"\")\n",
        "        lhs.scale(2)\n",
        "\n",
        "        rhs = VGroup()\n",
        "        for ndots in [1, 3, 6, 7, 9, 12]:\n",
        "            row = VGroup(*[\n",
        "                OldTex(\"2\"),\n",
        "                OldTex(\"\\\\uparrow\\\\uparrow\"),\n",
        "                VGroup(*[\n",
        "                    OldTex(\"\\\\cdot\") for x in range(ndots)\n",
        "                ]).arrange(RIGHT, buff=0.2),\n",
        "                OldTex(\"\\\\uparrow\\\\uparrow\"),\n",
        "                OldTex(\"3\"),\n",
        "            ])\n",
        "            row.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            if ndots == 1:\n",
        "                rc = row.get_center()\n",
        "                row[:2].move_to(rc, RIGHT)\n",
        "                row[2].set_opacity(0)\n",
        "                row[3:].move_to(rc, LEFT)\n",
        "            row.add(Brace(row[1:-1], DOWN, buff=SMALL_BUFF))\n",
        "            rhs.add(row)\n",
        "        rhs.replace_submobject(0, Integer(12))\n",
        "        # rhs[0][-1].set_opacity(0)\n",
        "        rhs.replace_submobject(3, OldTex(\"\\\\vdots\"))\n",
        "        rhs.arrange(UP)\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        rbrace = Brace(rhs[1:], RIGHT)\n",
        "        rbrace_tex = rbrace.get_text(\"7 times\")\n",
        "\n",
        "        equation = VGroup(lhs, rhs, rbrace, rbrace_tex)\n",
        "        equation.center().to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.add(lhs, rhs[0])\n",
        "        self.play(TransformFromCopy(rhs[0], rhs[1]),)\n",
        "        self.play(TransformFromCopy(rhs[1], rhs[2]))\n",
        "        self.play(\n",
        "            Write(rhs[3]),\n",
        "            TransformFromCopy(rhs[2], rhs[4]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs[4], rhs[5]),\n",
        "            GrowFromCenter(rbrace),\n",
        "            Write(rbrace_tex)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThinkAboutNewTrick(PiCreatureScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        board = Chessboard(shape=(1, 3))\n",
        "        board.set_height(1.5)\n",
        "        coins = CoinsOnBoard(board)\n",
        "        coins.flip_at_random()\n",
        "\n",
        "        self.add(board, coins)\n",
        "        self.play(randy.change, \"confused\", board)\n",
        "\n",
        "        for x in range(4):\n",
        "            self.play(FlipCoin(random.choice(coins)))\n",
        "            if x == 1:\n",
        "                self.play(randy.change, \"maybe\")\n",
        "            else:\n",
        "                self.wait()\n",
        "\n",
        "\n",
        "class AttemptAColoring(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup cube\n",
        "        short_vert_height = 0.3\n",
        "        tall_vert_height = 0.4\n",
        "\n",
        "        vert_coords = np.array(list(map(int_to_bit_coords, range(8))))\n",
        "        vert_coords = vert_coords - 0.5\n",
        "        vert_coords = vert_coords * 4\n",
        "        vert_coords[:, 2] *= 1.25  # Stretch in the z\n",
        "        cube = Group()\n",
        "        cube.verts = SGroup()\n",
        "        cube.edges = VGroup()\n",
        "        cube.add(cube.verts, cube.edges)\n",
        "        for n, coords in enumerate(vert_coords):\n",
        "            vert = Sphere(resolution=(21, 21))\n",
        "            vert.set_height(short_vert_height)\n",
        "            vert.rotate(90 * DEGREES, RIGHT)\n",
        "            vert.move_to(coords)\n",
        "            cube.verts.add(vert)\n",
        "            vert.edges = VGroup()\n",
        "            for m, coords2 in enumerate(vert_coords):\n",
        "                if sum(int_to_bit_coords(n ^ m)) == 1:\n",
        "                    edge = Line(coords, coords2)\n",
        "                    cube.edges.add(edge)\n",
        "                    vert.edges.add(edge)\n",
        "            vert.edges.apply_depth_test()\n",
        "\n",
        "        cube.edges.set_color(GREY)\n",
        "        cube.edges.apply_depth_test()\n",
        "\n",
        "        cube.rotate(30 * DEGREES, DOWN)\n",
        "        cube.to_edge(RIGHT)\n",
        "        cube.set_height(4)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(cube.edges, lag_ratio=0.1),\n",
        "            LaggedStartMap(FadeInFromLarge, cube.verts, lambda m: (m, 0.2)),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Setup cube color\n",
        "        def get_colored_vertices(values, verts=cube.verts):\n",
        "            color_choices = [RED, GREEN, BLUE_D]\n",
        "            color_label_choices = [\"R\", \"G\", \"B\"]\n",
        "            vert_targets = SGroup()\n",
        "            labels = VGroup()\n",
        "            for n, vert in zip(values, verts):\n",
        "                color = color_choices[n]\n",
        "                v_target = vert.copy()\n",
        "                if n == -1:\n",
        "                    v_target.set_height(short_vert_height)\n",
        "                    v_target.set_color(GREY)\n",
        "                    label = VectorizedPoint()\n",
        "                else:\n",
        "                    v_target.set_color(color)\n",
        "                    v_target.set_height(tall_vert_height)\n",
        "                    label = OldTex(color_label_choices[n])\n",
        "                    label.set_color(color)\n",
        "                    label.set_stroke(BLACK, 3, background=True)\n",
        "                label.next_to(vert, UR, buff=0)\n",
        "                vert_targets.add(v_target)\n",
        "                labels.add(label)\n",
        "            return vert_targets, labels\n",
        "\n",
        "        new_verts, color_labels = get_colored_vertices(np.arange(0, 8) % 3)\n",
        "        for vert, label in zip(cube.verts, color_labels):\n",
        "            vert.label = label\n",
        "\n",
        "        self.play(\n",
        "            Transform(cube.verts, new_verts),\n",
        "            Write(color_labels),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        def get_color_change_animations(values, verts=cube.verts, labels=color_labels, gcv=get_colored_vertices):\n",
        "            new_verts, new_labels = gcv(values)\n",
        "            old_labels = labels.copy()\n",
        "            labels.become(new_labels)\n",
        "            return [\n",
        "                Transform(verts, new_verts),\n",
        "                LaggedStartMap(FadeOut, old_labels, lambda m: (m, 0.5 * UP), lag_ratio=0.03),\n",
        "                LaggedStartMap(FadeIn, labels, lambda m: (m, 0.5 * DOWN), lag_ratio=0.03),\n",
        "            ]\n",
        "\n",
        "        # Prepare a few colorings\n",
        "        mod3_strategy = [\n",
        "            np.dot(int_to_bit_coords(n), [0, 1, 2]) % 3\n",
        "            for n in range(8)\n",
        "        ]\n",
        "        sum_bits = [sum(int_to_bit_coords(n)) % 3 for n in range(8)]\n",
        "\n",
        "        self.play(*get_color_change_animations(sum_bits))\n",
        "        self.wait()\n",
        "        self.play(*get_color_change_animations(mod3_strategy))\n",
        "        self.wait()\n",
        "\n",
        "        # Pull out vertices with their neighbors\n",
        "        # first just one, then all of them.\n",
        "        trees = Group()\n",
        "        tree_targets = Group()\n",
        "        for n, vert in enumerate(cube.verts):\n",
        "            tree = Group()\n",
        "            tree.root = vert.copy()\n",
        "            tree.root.origin = tree.root.get_center()\n",
        "            tree.edges = VGroup()\n",
        "            tree.leafs = Group()\n",
        "            tree.labels = Group()\n",
        "            for mask in [1, 2, 4]:\n",
        "                leaf = cube.verts[n ^ mask]\n",
        "                leaf.origin = leaf.get_center()\n",
        "                label = leaf.label.copy()\n",
        "                label.original = leaf.label\n",
        "                tree.edges.add(Line(vert.get_center(), leaf.get_center()))\n",
        "                tree.leafs.add(leaf.copy())\n",
        "                tree.labels.add(label)\n",
        "            tree.edges.apply_depth_test()\n",
        "            tree.edges.match_style(vert.edges)\n",
        "            tree.edges.save_state()\n",
        "            tree.add(tree.root, tree.edges, tree.leafs, tree.labels)\n",
        "            trees.add(tree)\n",
        "\n",
        "            tree.generate_target(use_deepcopy=True)\n",
        "            for edge, leaf, label, y in zip(tree.target.edges, tree.target.leafs, tree.target.labels, [0.4, 0, -0.4]):\n",
        "                start = vert.get_center()\n",
        "                end = start + RIGHT + y * UP\n",
        "                edge.set_points_as_corners([start, end])\n",
        "                leaf.move_to(edge.get_end())\n",
        "                label.next_to(leaf, RIGHT, buff=SMALL_BUFF)\n",
        "                label.scale(0.7)\n",
        "            tree_targets.add(tree.target)\n",
        "        tree_targets.arrange_in_grid(4, 2, buff=LARGE_BUFF)\n",
        "        tree_targets[1::2].shift(0.5 * RIGHT)\n",
        "        tree_targets.set_height(6)\n",
        "        tree_targets.center()\n",
        "        tree_targets.to_corner(DL)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(trees[0]),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, trees[1:],\n",
        "                lag_ratio=0.3,\n",
        "            ),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.add(trees)\n",
        "        self.wait()\n",
        "\n",
        "        # Show what we want\n",
        "        want_rect = SurroundingRectangle(trees, buff=MED_SMALL_BUFF)\n",
        "        want_rect.set_stroke(WHITE, 1)\n",
        "        want_label = OldTexText(\"What we want\")\n",
        "        want_label.next_to(want_rect, UP)\n",
        "\n",
        "        trees.save_state()\n",
        "        anims = []\n",
        "        for tree in trees:\n",
        "            anims.append(ApplyMethod(tree.root.set_color, GREY))\n",
        "            colors = [RED, GREEN, BLUE_D]\n",
        "            letters = [\"R\", \"G\", \"B\"]\n",
        "            for color, letter, leaf, label in zip(colors, letters, tree.leafs, tree.labels):\n",
        "                new_label = OldTexText(letter)\n",
        "                new_label.set_fill(color)\n",
        "                new_label.replace(label, dim_to_match=1)\n",
        "                old_label = label.copy()\n",
        "                label.become(new_label)\n",
        "                anims += [\n",
        "                    FadeIn(label, 0.1 * LEFT),\n",
        "                    FadeOut(old_label, 0.1 * RIGHT),\n",
        "                    ApplyMethod(leaf.set_color, color),\n",
        "                ]\n",
        "\n",
        "        cube.verts.generate_target()\n",
        "        cube.verts.save_state()\n",
        "        cube.verts.target.set_color(GREY)\n",
        "        for vert in cube.verts.target:\n",
        "            vert.scale(0.75)\n",
        "        self.play(\n",
        "            ShowCreation(want_rect),\n",
        "            Write(want_label),\n",
        "            LaggedStart(*anims, lag_ratio=0.001, run_time=3),\n",
        "            FadeOut(color_labels),\n",
        "            MoveToTarget(cube.verts),\n",
        "        )\n",
        "        self.add(trees)\n",
        "        self.wait()\n",
        "\n",
        "        # Try to fit these back onto the cube\n",
        "        # First attempt\n",
        "        def restore_tree(tree, **kwargs):\n",
        "            anims = []\n",
        "            for mob in [tree.root, *tree.leafs]:\n",
        "                anims.append(ApplyMethod(mob.move_to, mob.origin))\n",
        "            for label in tree.labels:\n",
        "                label.generate_target()\n",
        "                label.target.replace(label.original, dim_to_match=1)\n",
        "                anims.append(MoveToTarget(label))\n",
        "            anims.append(Restore(tree.edges))\n",
        "            return AnimationGroup(*anims, **kwargs)\n",
        "\n",
        "        tree_copies = trees.deepcopy()\n",
        "        self.play(restore_tree(tree_copies[0], run_time=2))\n",
        "        self.wait()\n",
        "        self.play(restore_tree(tree_copies[1], run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                frame,\n",
        "                lambda m, a: m.move_to(0.1 * wiggle(a, 6) * RIGHT),\n",
        "            ),\n",
        "            FadeOut(tree_copies[0]),\n",
        "            FadeOut(tree_copies[1]),\n",
        "        )\n",
        "\n",
        "        # Second attempt\n",
        "        def restore_vertex(n, verts=cube.verts, labels=color_labels):\n",
        "            return AnimationGroup(\n",
        "                Transform(verts[n], verts.saved_state[n]),\n",
        "                FadeIn(labels[n], DOWN)\n",
        "            )\n",
        "\n",
        "        for i in [0, 4, 2, 1]:\n",
        "            self.play(restore_vertex(i))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(cube.verts[4]))\n",
        "        for i in [6, 5]:\n",
        "            self.play(restore_vertex(i))\n",
        "        self.wait()\n",
        "\n",
        "        q_marks = VGroup(*[Tex(\"???\") for x in range(2)])\n",
        "        q_marks[0].next_to(cube.verts[7], UP, SMALL_BUFF)\n",
        "        q_marks[1].next_to(cube.verts[3], UP, SMALL_BUFF)\n",
        "        self.play(Write(q_marks))\n",
        "        self.wait()\n",
        "\n",
        "        # Mention it'll never work\n",
        "        nv_label = OldTexText(\"It'll never work!\")\n",
        "        nv_label.set_height(0.5)\n",
        "        nv_label.next_to(cube, UP, buff=0.75)\n",
        "\n",
        "        cube_copy = cube.deepcopy()\n",
        "        self.remove(cube)\n",
        "        self.add(cube_copy)\n",
        "        new_verts, new_labels = get_colored_vertices([-1] * 8)\n",
        "        self.play(\n",
        "            Transform(cube_copy.verts, new_verts),\n",
        "            FadeOut(q_marks),\n",
        "            FadeOut(color_labels[:3]),\n",
        "            FadeOut(color_labels[4:7]),\n",
        "        )\n",
        "        self.add(cube_copy)\n",
        "        self.play(FadeIn(nv_label, DOWN))\n",
        "        for vert in cube_copy.verts:\n",
        "            vert.generate_target()\n",
        "            vert.target.scale(0.01)\n",
        "            vert.target.set_opacity(0)\n",
        "        self.play(\n",
        "            LaggedStartMap(Uncreate, cube_copy.edges),\n",
        "            LaggedStartMap(MoveToTarget, cube_copy.verts),\n",
        "        )\n",
        "\n",
        "        # Highlight symmetry\n",
        "        rects = VGroup()\n",
        "        for tree in trees:\n",
        "            t_rect = SurroundingRectangle(\n",
        "                Group(tree.leafs, tree.labels),\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            t_rect.set_stroke(YELLOW, 2)\n",
        "            rects.add(t_rect)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreationThenFadeOut, rects, lag_ratio=0.025, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Show implication\n",
        "        implies = OldTex(\"\\\\Rightarrow\")\n",
        "        implies.set_height(0.7)\n",
        "        implies.next_to(want_rect, RIGHT)\n",
        "        number_labels = VGroup(*[\n",
        "            OldTexText(\"Number of \", f\"{color} vertices\")\n",
        "            for color in [\"red\", \"green\", \"blue\"]\n",
        "        ])\n",
        "        for color, label in zip(colors, number_labels):\n",
        "            label[1].set_color(color)\n",
        "        number_labels.set_height(0.5)\n",
        "        number_labels.arrange(DOWN, buff=1.5, aligned_edge=LEFT)\n",
        "        number_labels.next_to(implies, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        vert_eqs = VGroup(*[Tex(\"=\") for x in range(2)])\n",
        "        vert_eqs.scale(1.5)\n",
        "        vert_eqs.rotate(90 * DEGREES)\n",
        "        vert_eqs[0].move_to(number_labels[0:2])\n",
        "        vert_eqs[1].move_to(number_labels[1:3])\n",
        "\n",
        "        rhss = VGroup()\n",
        "        for label in number_labels:\n",
        "            rhs = OldTex(\"= \\\\frac{8}{3}\")\n",
        "            rhs.scale(1.25)\n",
        "            rhs.next_to(label, RIGHT)\n",
        "            rhss.add(rhs)\n",
        "\n",
        "        self.play(\n",
        "            Write(implies),\n",
        "            FadeOut(nv_label),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(vert_eqs),\n",
        "            FadeIn(number_labels[0], DOWN),\n",
        "            FadeIn(number_labels[1]),\n",
        "            FadeIn(number_labels[2], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(rhss))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut, VGroup(*number_labels, *vert_eqs, *rhss, *implies),\n",
        "            ),\n",
        "            ShowCreation(cube.edges, lag_ratio=0.1),\n",
        "            LaggedStartMap(FadeInFromLarge, cube.verts, lambda m: (m, 0.2)),\n",
        "        )\n",
        "        self.add(cube)\n",
        "        new_verts, color_labels = get_colored_vertices(mod3_strategy)\n",
        "        true_trees = trees.saved_state\n",
        "        self.play(\n",
        "            Transform(cube.verts, new_verts),\n",
        "            FadeIn(color_labels),\n",
        "            FadeOut(trees),\n",
        "            FadeOut(want_label)\n",
        "        )\n",
        "        self.play(FadeIn(true_trees))\n",
        "        self.wait()\n",
        "\n",
        "        # Count colors\n",
        "        for edge in cube.edges:\n",
        "            edge.insert_n_curves(10)\n",
        "\n",
        "        red_total = Integer(height=0.6)\n",
        "        red_total.next_to(want_rect, UP)\n",
        "        red_total.set_color(RED)\n",
        "        self.play(FadeIn(red_total))\n",
        "\n",
        "        all_label_rects = VGroup()\n",
        "        for n in range(8):\n",
        "            tree = true_trees[n]\n",
        "            vert = cube.verts[n]\n",
        "            neighbor_highlights = VGroup()\n",
        "            new_edges = VGroup()\n",
        "            label_rects = VGroup()\n",
        "            for mask, label in zip([1, 2, 4], tree.labels):\n",
        "                neighbor = cube.verts[n ^ mask]\n",
        "                edge = Line(vert, neighbor, buff=0)\n",
        "                edge.set_stroke(YELLOW, 5)\n",
        "                edge.insert_n_curves(10)\n",
        "                new_edges.add(edge)\n",
        "                if neighbor.get_color() == Color(RED):\n",
        "                    circ = Circle()\n",
        "                    circ.set_stroke(YELLOW, 3)\n",
        "                    circ.replace(neighbor)\n",
        "                    neighbor_highlights.add(circ)\n",
        "                    rect = SurroundingRectangle(label, buff=0.025)\n",
        "                    rect.set_stroke(YELLOW, 2)\n",
        "                    label_rects.add(rect)\n",
        "            new_edges.apply_depth_test()\n",
        "            new_edges.shift(0.01 * OUT)\n",
        "            new_tree_edges = tree.edges.copy()\n",
        "            new_tree_edges.set_stroke(YELLOW, 3)\n",
        "            new_tree_edges.shift(0.01 * OUT)\n",
        "\n",
        "            self.play(\n",
        "                *map(ShowCreation, [*new_edges, *new_tree_edges]),\n",
        "            )\n",
        "            for highlight, rect in zip(neighbor_highlights, label_rects):\n",
        "                self.play(\n",
        "                    FadeInFromLarge(highlight, 1.2),\n",
        "                    FadeInFromLarge(rect, 1.2),\n",
        "                    run_time=0.25\n",
        "                )\n",
        "                red_total.increment_value()\n",
        "                self.wait(0.25)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(neighbor_highlights),\n",
        "                FadeOut(new_edges),\n",
        "                FadeOut(new_tree_edges),\n",
        "            )\n",
        "            all_label_rects.add(*label_rects)\n",
        "        self.wait()\n",
        "\n",
        "        # Show count to 8\n",
        "        new_verts = get_colored_vertices([-1] * 8)[0]\n",
        "        self.play(\n",
        "            FadeOut(true_trees),\n",
        "            FadeOut(all_label_rects),\n",
        "            FadeOut(red_total),\n",
        "            FadeOut(color_labels),\n",
        "            Transform(cube.verts, new_verts),\n",
        "        )\n",
        "        self.play(FadeIn(trees))\n",
        "        label_rects = VGroup()\n",
        "        for tree in trees:\n",
        "            rect = SurroundingRectangle(tree.labels[0], buff=0.025)\n",
        "            rect.match_style(all_label_rects[0])\n",
        "            label_rects.add(rect)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(label_rects, rate_func=linear),\n",
        "            UpdateFromFunc(\n",
        "                red_total, lambda m, lr=label_rects: m.set_value(len(lr))\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show red corners\n",
        "        r_verts = SGroup(cube.verts[3], cube.verts[4]).copy()\n",
        "        r_labels = VGroup()\n",
        "        r_edge_groups = VGroup()\n",
        "        for r_vert in r_verts:\n",
        "            r_label = OldTex(\"R\")\n",
        "            r_label.set_color(RED)\n",
        "            r_label.next_to(r_vert, UR, buff=0)\n",
        "            r_labels.add(r_label)\n",
        "            r_vert.set_height(tall_vert_height)\n",
        "            r_vert.set_color(RED)\n",
        "            edges = VGroup()\n",
        "            for edge in r_vert.edges:\n",
        "                to_r_edge = edge.copy()\n",
        "                to_r_edge.reverse_points()\n",
        "                to_r_edge.set_stroke(YELLOW, 3)\n",
        "                to_r_edge.shift(0.01 * OUT)\n",
        "                edges.add(to_r_edge)\n",
        "            edges.apply_depth_test()\n",
        "            r_edge_groups.add(edges)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, r_verts),\n",
        "            LaggedStartMap(FadeInFromLarge, r_labels),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        for edges in r_edge_groups:\n",
        "            self.play(ShowCreationThenDestruction(edges, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        rhs = OldTex(\"=\", \"3\", \"\\\\, (\\\\text{\\\\# Red corners})\")\n",
        "        rhs[2].set_color(RED)\n",
        "        rhs.match_height(red_total)\n",
        "        rhs[:2].match_height(red_total, about_edge=RIGHT)\n",
        "        rhs.next_to(red_total, RIGHT)\n",
        "\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "\n",
        "        three = rhs[1]\n",
        "        three.generate_target()\n",
        "        three.target.move_to(red_total, RIGHT)\n",
        "        over = OldTex(\"/\")\n",
        "        over.match_height(three)\n",
        "        over.next_to(three.target, LEFT, MED_SMALL_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(three, path_arc=90 * DEGREES),\n",
        "            red_total.next_to, over, LEFT, MED_SMALL_BUFF,\n",
        "            FadeIn(over, UR),\n",
        "            rhs[2].move_to, three, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        np_label = OldTexText(\"Not possible!\")\n",
        "        np_label.set_height(0.6)\n",
        "        np_label.next_to(rhs, RIGHT, LARGE_BUFF)\n",
        "        self.play(Write(np_label))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TryTheProofYourself(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Can you predict\\\\\\\\the proof?\",\n",
        "            target_mode=\"hooray\",\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 3,\n",
        "            },\n",
        "        )\n",
        "        self.teacher.bubble.set_fill(opacity=0)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"confused\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play_student_changes(\"thinking\", \"pondering\", \"erm\", look_at=self.screen)\n",
        "        self.wait(4)\n",
        "        self.play_student_changes(\"tease\", \"pondering\", \"thinking\", look_at=self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class HighDimensionalCount(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Definitions\n",
        "        N = 6\n",
        "        colors = [RED, GREEN, BLUE_D, YELLOW, PINK, TEAL]\n",
        "        coords = np.array([0, 1, 1, 1, 0, 0])\n",
        "\n",
        "        # Add chess board\n",
        "        board = Chessboard(shape=(2, 3))\n",
        "        board.set_height(2)\n",
        "        board.to_corner(UL)\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            x_range=(0, 3), y_range=(0, 2),\n",
        "            faded_line_ratio=0\n",
        "        )\n",
        "        grid.match_height(board)\n",
        "        grid.match_width(board, stretch=True)\n",
        "        grid.next_to(board, OUT, 1e-8)\n",
        "        grid.set_gloss(0.5)\n",
        "\n",
        "        coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "        coins.flip_by_bools(coords)\n",
        "        coin_labels = VGroup()\n",
        "        for i, coin in zip(coords, coins):\n",
        "            coin_labels.add(coin.labels[1 - i])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(grid, lag_ratio=0.1),\n",
        "            FadeIn(board),\n",
        "            FadeIn(coins, lag_ratio=0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Setup corners\n",
        "        def get_vert(height=0.4, color=RED):\n",
        "            return get_vertex_sphere(height, color)\n",
        "\n",
        "        def get_vert_label(coords):\n",
        "            args = [\"(\"]\n",
        "            for coord in coords:\n",
        "                args.append(str(coord))\n",
        "                args.append(\",\")\n",
        "            args[-1] = \")\"\n",
        "            return OldTex(*args)\n",
        "\n",
        "        def get_board_with_highlights(n, height=1, N=N, colors=colors):\n",
        "            board = VGroup(*[Square() for x in range(N)])\n",
        "            board.arrange_in_grid(2, 3, buff=0)\n",
        "            board.set_fill(GREY_E, 1)\n",
        "            board.set_stroke(WHITE, 1)\n",
        "            board.set_height(height)\n",
        "            board[n].set_fill(colors[n])\n",
        "            return board\n",
        "\n",
        "        vert = get_vert()\n",
        "        vert_label = get_vert_label(coords)\n",
        "        vert_board = get_board_with_highlights(0)\n",
        "        vert_label.next_to(vert, LEFT)\n",
        "        vert_board.next_to(vert_label, DOWN, MED_LARGE_BUFF)\n",
        "        neighbors = SGroup()\n",
        "        for color in colors:\n",
        "            neighbors.add(get_vert(color=color))\n",
        "        neighbors.arrange(DOWN, buff=0.75)\n",
        "        neighbors.next_to(vert, RIGHT, buff=2)\n",
        "        neighbor_labels = VGroup()\n",
        "        edges = VGroup()\n",
        "        neighbor_boards = VGroup()\n",
        "        for n, neighbor in enumerate(neighbors):\n",
        "            edge = Line(\n",
        "                vert.get_center(),\n",
        "                neighbor.get_center(),\n",
        "                buff=vert.get_height() / 2,\n",
        "            )\n",
        "            new_coords = list(coords)\n",
        "            new_coords[n] ^= 1\n",
        "            label = get_vert_label(new_coords)\n",
        "            label.next_to(neighbor, RIGHT)\n",
        "            label.add(SurroundingRectangle(label[2 * n + 1], buff=0.05))\n",
        "            n_board = get_board_with_highlights(n, height=0.7)\n",
        "            n_board.next_to(label, RIGHT)\n",
        "\n",
        "            neighbor_boards.add(n_board)\n",
        "            edges.add(edge)\n",
        "            neighbor_labels.add(label)\n",
        "\n",
        "        vertex_group = Group(\n",
        "            vert_board, vert_label, vert,\n",
        "            edges,\n",
        "            neighbors, neighbor_labels, neighbor_boards\n",
        "        )\n",
        "        vertex_group.to_corner(DL)\n",
        "\n",
        "        # Show coords with states\n",
        "        cl_mover = coin_labels.copy()\n",
        "        cl_mover.generate_target()\n",
        "        for m1, m2 in zip(cl_mover.target, vert_label[1::2]):\n",
        "            m1.replace(m2)\n",
        "        self.play(\n",
        "            MoveToTarget(cl_mover),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(vert_label),\n",
        "            FadeOut(cl_mover)\n",
        "        )\n",
        "        self.play(FadeIn(vert_board))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(neighbor_labels),\n",
        "            ShowCreation(edges),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            TransformFromCopy, neighbor_boards,\n",
        "            lambda m, b=vert_board: (b, m)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show one vertex\n",
        "        self.play(FadeInFromLarge(vert))\n",
        "        self.play(LaggedStartMap(\n",
        "            TransformFromCopy, neighbors,\n",
        "            lambda m, v=vert: (v, m)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate vertex\n",
        "        edges.apply_depth_test()\n",
        "        tree = Group(vert, edges, neighbors)\n",
        "        tree.generate_target()\n",
        "        tree.target[0].scale(0.5)\n",
        "        tree.target[2].scale(0.5)\n",
        "        tree.target[2].arrange(DOWN, buff=0)\n",
        "        tree.target[2].next_to(vert, RIGHT, MED_LARGE_BUFF)\n",
        "        for edge, nv in zip(tree.target[1], tree.target[2]):\n",
        "            new_edge = Line(\n",
        "                vert.get_center(),\n",
        "                nv.get_center(),\n",
        "            )\n",
        "            edge.become(new_edge)\n",
        "            edge.set_stroke(WHITE, 2)\n",
        "        tree.target.rotate(-90 * DEGREES)\n",
        "        tree.target.center()\n",
        "\n",
        "        short_label = vert_label[1::2]\n",
        "        short_label.generate_target()\n",
        "        short_label.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        short_label.target.match_width(tree.target)\n",
        "        short_label.target.next_to(tree.target, UP)\n",
        "        short_label.target.set_fill(GREY_A)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(tree),\n",
        "            MoveToTarget(short_label),\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                vert_label[0::2],\n",
        "                vert_board,\n",
        "                *neighbor_labels,\n",
        "                *neighbor_boards,\n",
        "                *board,\n",
        "                *coins,\n",
        "            )),\n",
        "            run_time=2,\n",
        "        )\n",
        "        tree.add(short_label)\n",
        "\n",
        "        # Show all vertices\n",
        "        def get_bit_string(n, template=short_label):\n",
        "            bits = VGroup(*map(Integer, int_to_bit_coords(n, min_dim=6)))\n",
        "            bits.arrange(RIGHT, buff=0.075)\n",
        "            bits.match_height(template)\n",
        "            bits.set_color(GREY_A)\n",
        "            return bits\n",
        "\n",
        "        new_trees = Group()\n",
        "        for n in [0, 1, 62, 63]:\n",
        "            new_tree = tree.copy()\n",
        "            bits = get_bit_string(n)\n",
        "            bits.move_to(new_tree[3])\n",
        "            new_tree.replace_submobject(3, bits)\n",
        "            new_trees.add(new_tree)\n",
        "        for new_tree, color in zip(new_trees, [YELLOW, GREEN, RED, BLUE_D]):\n",
        "            new_tree[0].set_color(color)\n",
        "        new_trees.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        new_trees.move_to(tree)\n",
        "        new_trees[:2].to_edge(LEFT)\n",
        "        new_trees[2:].to_edge(RIGHT)\n",
        "\n",
        "        dots = VGroup(*[Tex(\"\\\\dots\") for x in range(2)])\n",
        "        dots.scale(2)\n",
        "        dots[0].move_to(Group(new_trees[1], tree))\n",
        "        dots[1].move_to(Group(new_trees[2], tree))\n",
        "\n",
        "        top_brace = Brace(new_trees, UP, buff=MED_LARGE_BUFF)\n",
        "        total_label = top_brace.get_text(\"$2^n$ total vertices\", buff=MED_LARGE_BUFF)\n",
        "\n",
        "        low_brace = Brace(tree, DOWN)\n",
        "        neighbors_label = low_brace.get_text(\"n neighbors\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(low_brace),\n",
        "            Write(neighbors_label, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(dots),\n",
        "            GrowFromCenter(top_brace),\n",
        "            LaggedStartMap(\n",
        "                TransformFromCopy, new_trees,\n",
        "                lambda m, t=tree: (t, m)\n",
        "            ),\n",
        "            Write(total_label, run_time=1),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Count red neighbors\n",
        "        middle_tree = tree\n",
        "        frame = self.camera.frame\n",
        "        self.play(frame.move_to, UP)\n",
        "\n",
        "        count = Integer(1)\n",
        "        count.set_color(RED)\n",
        "        count.scale(1.5)\n",
        "        count.next_to(total_label, UP, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        two_to_n_label = OldTex(\"2^n\")\n",
        "        two_to_n_label.scale(1.5)\n",
        "        two_to_n_label.set_color(RED)\n",
        "        two_to_n_label.move_to(count, LEFT)\n",
        "\n",
        "        n_arrows = VGroup()\n",
        "        for tree in [*new_trees[:2], middle_tree, *new_trees[2:]]:\n",
        "            arrow = Vector(\n",
        "                [-1, -2, 0],\n",
        "                tip_config={\"width\": 0.2, \"length\": 0.2}\n",
        "            )\n",
        "            arrow.match_height(tree[1])\n",
        "            arrow.next_to(tree[2][0], UR, buff=0)\n",
        "            arrow.set_color(RED)\n",
        "            n_arrows.add(arrow)\n",
        "\n",
        "        self.add(n_arrows[0], count)\n",
        "        self.wait()\n",
        "        self.add(n_arrows[1])\n",
        "        count.increment_value()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(count, 63, rate_func=rush_into),\n",
        "            LaggedStartMap(FadeIn, n_arrows[2:], lag_ratio=0.5),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.remove(count)\n",
        "        self.add(two_to_n_label)\n",
        "        self.wait()\n",
        "\n",
        "        rhs = OldTex(\"=\", \"n\", \"\\\\cdot\", \"(\\\\text{\\\\# Red vertices})\")\n",
        "        rhs.scale(1.5)\n",
        "        rhs.next_to(two_to_n_label, RIGHT)\n",
        "        rhs.shift(0.05 * DOWN)\n",
        "        rhs.set_color_by_tex(\"Red\", RED)\n",
        "        highlighted_edges = VGroup(*middle_tree[1], new_trees[2][1]).copy()\n",
        "        highlighted_edges.set_stroke(YELLOW, 3)\n",
        "        highlighted_edges.shift(0.01 * OUT)\n",
        "        edge_anim = ShowCreationThenFadeOut(\n",
        "            highlighted_edges, lag_ratio=0.3\n",
        "        )\n",
        "\n",
        "        self.play(edge_anim)\n",
        "        self.play(Write(rhs), run_time=1)\n",
        "        self.play(edge_anim)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Conclusion\n",
        "        pairs = VGroup(VGroup(OldTex(\"n\"), OldTex(\"2^n\")))\n",
        "        pairs.set_color(YELLOW)\n",
        "        for n in range(1, 10):\n",
        "            pairs.add(VGroup(Integer(n), Integer(2**n)))\n",
        "        for pair in pairs:\n",
        "            pair.arrange(RIGHT, buff=0.75, aligned_edge=DOWN)\n",
        "            line = Line(LEFT, RIGHT)\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            line.set_width(2)\n",
        "            line.next_to(pair, DOWN, aligned_edge=LEFT)\n",
        "            line.shift(SMALL_BUFF * LEFT)\n",
        "            pair.add(line)\n",
        "            pairs.add(pair)\n",
        "        pairs.arrange(DOWN, aligned_edge=LEFT, buff=0.25)\n",
        "        pairs.set_height(7)\n",
        "        pairs.to_edge(LEFT)\n",
        "        pairs.shift(UP)\n",
        "\n",
        "        marks = VGroup()\n",
        "        for n, pair in zip(it.count(1), pairs[1:]):\n",
        "            if sum(int_to_bit_coords(n)) == 1:\n",
        "                mark = Checkmark()\n",
        "            else:\n",
        "                mark = Exmark()\n",
        "            mark.move_to(pair[1], LEFT)\n",
        "            mark.shift(RIGHT)\n",
        "            marks.add(mark)\n",
        "\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_height(7)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "        v_line.set_x((pairs[0][0].get_right() + pairs[0][1].get_left())[0] / 2)\n",
        "        v_line.match_y(pairs)\n",
        "        pairs.add(v_line)\n",
        "\n",
        "        new_trees.generate_target()\n",
        "        new_trees.target[:2].move_to(middle_tree, RIGHT)\n",
        "        shift_vect = new_trees.target[0].get_center() - new_trees[0].get_center()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(new_trees),\n",
        "            top_brace.match_width, new_trees.target, {\"about_edge\": RIGHT},\n",
        "            total_label.shift, shift_vect * 0.5,\n",
        "            n_arrows[:2].shift, shift_vect,\n",
        "            FadeOut(middle_tree, RIGHT),\n",
        "            FadeOut(n_arrows[2], RIGHT),\n",
        "            FadeOut(dots[0], 2 * RIGHT),\n",
        "            Write(pairs)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, marks,\n",
        "            lambda m: (m, 0.2 * LEFT),\n",
        "            lag_ratio=0.4,\n",
        "            run_time=5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleRect(Scene):\n",
        "    def construct(self):\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(Integer(4), Integer(16), Integer(0)).arrange(RIGHT, MED_LARGE_BUFF),\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class WhenIsItHopeless(Scene):\n",
        "    def construct(self):\n",
        "        boards = Group(\n",
        "            Chessboard(shape=(1, 3)),\n",
        "            Chessboard(shape=(2, 2)),\n",
        "            Chessboard(shape=(2, 3)),\n",
        "            Chessboard(shape=(2, 3)),\n",
        "            Chessboard(shape=(2, 4)),\n",
        "            Chessboard(shape=(2, 4)),\n",
        "            Chessboard(shape=(3, 3)),\n",
        "            Chessboard(shape=(3, 4)),\n",
        "            Chessboard(shape=(3, 4)),\n",
        "            Chessboard(shape=(3, 4)),\n",
        "        )\n",
        "        last_board = None\n",
        "        last_coins = None\n",
        "        last_words = None\n",
        "        for n, board in zip(it.count(3), boards):\n",
        "            board.scale(1 / board[0].get_height())\n",
        "            coins = CoinsOnBoard(board)\n",
        "            coins.flip_at_random()\n",
        "            diff = len(board) - n\n",
        "            if diff > 0:\n",
        "                board[-diff:].set_opacity(0)\n",
        "                coins[-diff:].set_opacity(0)\n",
        "\n",
        "            if sum(int_to_bit_coords(n)) == 1:\n",
        "                words = OldTexText(\"Maybe possible\")\n",
        "                words.set_color(GREEN)\n",
        "            else:\n",
        "                words = OldTexText(\"Futile!\")\n",
        "                words.set_color(RED)\n",
        "            words.scale(1.5)\n",
        "            words.next_to(board, UP, MED_LARGE_BUFF)\n",
        "\n",
        "            if n == 3:\n",
        "                self.play(\n",
        "                    FadeIn(board),\n",
        "                    FadeIn(coins),\n",
        "                    FadeIn(words, DOWN),\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    ReplacementTransform(last_board, board),\n",
        "                    ReplacementTransform(last_coins, coins),\n",
        "                    FadeOut(last_words),\n",
        "                    FadeIn(words, DOWN),\n",
        "                )\n",
        "            self.wait()\n",
        "\n",
        "            last_board = board\n",
        "            last_coins = coins\n",
        "            last_words = words\n",
        "\n",
        "\n",
        "class FourDCubeColoringFromTrees(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Camera stuffs\n",
        "        frame = self.camera.frame\n",
        "        light = self.camera.light_source\n",
        "        light.move_to([-25, -20, 20])\n",
        "\n",
        "        # Setup cube\n",
        "        colors = [RED, GREEN, BLUE_D, YELLOW]\n",
        "        cube = self.get_hypercube()\n",
        "        for n, vert in enumerate(cube.verts):\n",
        "            code = boolian_linear_combo(int_to_bit_coords(n, 4))\n",
        "            cube.verts[n].set_color(colors[code])\n",
        "\n",
        "        # Create trees\n",
        "        trees = Group()\n",
        "        original_trees = Group()\n",
        "        for vert in cube.verts:\n",
        "            tree = Group(\n",
        "                vert,\n",
        "                vert.edges,\n",
        "                vert.neighbors,\n",
        "            ).copy()\n",
        "            original = tree.copy()\n",
        "            original[0].set_color(GREY)\n",
        "            original[0].scale(0)\n",
        "            original_trees.add(original)\n",
        "            trees.add(tree)\n",
        "        for tree in trees:\n",
        "            tree[0].set_color(GREY)\n",
        "            tree[0].rotate(90 * DEGREES, LEFT)\n",
        "            sorted_verts = Group(*tree[2])\n",
        "            sorted_verts.submobjects.sort(key=lambda m: m.get_color().hex)\n",
        "            sorted_verts.arrange(DOWN, buff=SMALL_BUFF)\n",
        "            sorted_verts.next_to(tree[0], RIGHT, buff=0.75)\n",
        "            for edge, neighbor in zip(tree[1], tree[2]):\n",
        "                edge.become(Line3D(\n",
        "                    tree[0].get_center(),\n",
        "                    neighbor.get_center(),\n",
        "                    resolution=edge.resolution,\n",
        "                ))\n",
        "                neighbor.rotate(90 * DEGREES, LEFT)\n",
        "\n",
        "        trees.arrange_in_grid(4, 4, buff=MED_LARGE_BUFF)\n",
        "        for i in range(4):\n",
        "            trees[i::4].shift(0.5 * i * RIGHT)\n",
        "        trees.center()\n",
        "        trees.set_height(6)\n",
        "        trees.rotate(PI / 2, RIGHT)\n",
        "        trees.move_to(10 * LEFT, LEFT)\n",
        "\n",
        "        frame.set_phi(90 * DEGREES)\n",
        "        frame.move_to(5 * LEFT)\n",
        "        self.add(trees)\n",
        "        self.wait()\n",
        "\n",
        "        # Show transition\n",
        "        anims = []\n",
        "        for tree, original in zip(trees, original_trees):\n",
        "            anims.append(Transform(tree, original))\n",
        "        self.play(\n",
        "            frame.set_euler_angles, 20 * DEGREES, 70 * DEGREES,\n",
        "            frame.move_to, ORIGIN,\n",
        "            LaggedStart(*anims, lag_ratio=0.2),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.remove(trees)\n",
        "        self.add(cube)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(2 * dt * DEGREES))\n",
        "        self.wait(30)\n",
        "\n",
        "    def get_hypercube(self, dim=4, width=4):\n",
        "        hc_points = self.get_hypercube_points(dim, width)\n",
        "        cube = Group()\n",
        "        cube.verts = SGroup()\n",
        "        cube.edges = SGroup()\n",
        "        cube.add(cube.verts, cube.edges)\n",
        "        for point in hc_points:\n",
        "            vert = get_vertex_sphere(resolution=(25, 13))\n",
        "            vert.rotate(PI / 2, UP)\n",
        "            vert.move_to(point)\n",
        "            cube.verts.add(vert)\n",
        "            vert.edges = SGroup()\n",
        "            vert.neighbors = SGroup()\n",
        "        for n in range(2**dim):\n",
        "            for power in range(dim):\n",
        "                k = n ^ (1 << power)\n",
        "                edge = Line3D(\n",
        "                    hc_points[n],\n",
        "                    hc_points[k],\n",
        "                    width=0.05,\n",
        "                    resolution=(31, 31)\n",
        "                )\n",
        "                cube.edges.add(edge)\n",
        "                cube.verts[n].edges.add(edge)\n",
        "                cube.verts[n].neighbors.add(cube.verts[k])\n",
        "        return cube\n",
        "\n",
        "    def get_hypercube_points(self, dim=4, width=4):\n",
        "        all_coords = [\n",
        "            int_to_bit_coords(n, dim).astype(float)\n",
        "            for n in range(2**dim)\n",
        "        ]\n",
        "        vertex_holder = Mobject()\n",
        "        vertex_holder.set_points([\n",
        "            sum([c * v for c, v in zip(reversed(coords), [RIGHT, UP, OUT])])\n",
        "            for coords in all_coords\n",
        "        ])\n",
        "        vertex_holder.center()\n",
        "        if dim == 4:\n",
        "            vertex_holder.get_points()[8:] *= 2\n",
        "        vertex_holder.set_width(width)\n",
        "        return vertex_holder.get_points()\n",
        "\n",
        "\n",
        "class IntroduceHypercube(FourDCubeColoringFromTrees):\n",
        "    def construct(self):\n",
        "        # Camera stuffs\n",
        "        frame = self.camera.frame\n",
        "        light = self.camera.light_source\n",
        "        light.move_to([-25, -20, 20])\n",
        "\n",
        "        # Setup cubes\n",
        "        cubes = [\n",
        "            self.get_hypercube(dim=d)\n",
        "            for d in range(5)\n",
        "        ]\n",
        "\n",
        "        def reconnect_edges(cube):\n",
        "            for vert in cube.verts:\n",
        "                for edge, neighbor in zip(vert.edges, vert.neighbors):\n",
        "                    edge.become(Line3D(\n",
        "                        vert.get_center(),\n",
        "                        neighbor.get_center(),\n",
        "                        resolution=edge.resolution\n",
        "                    ))\n",
        "\n",
        "        # Show increasing dimensions\n",
        "        label = VGroup(Integer(0), OldTex(\"D\"))\n",
        "        label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        label.scale(1.5)\n",
        "        label.to_edge(UP)\n",
        "        label.fix_in_frame()\n",
        "\n",
        "        def get_cube_intro_anim(n, cubes=cubes, reconnect_edges=reconnect_edges, label=label):\n",
        "            if n == 0:\n",
        "                return GrowFromCenter(cubes[n])\n",
        "            self.remove(cubes[n - 1])\n",
        "            cubes[n].save_state()\n",
        "            for v1, v2 in zip(cubes[n].verts, it.cycle(cubes[n - 1].verts)):\n",
        "                v1.move_to(v2)\n",
        "            reconnect_edges(cubes[n])\n",
        "            if n == 1:\n",
        "                cubes[n].edges.scale(0)\n",
        "            return AnimationGroup(\n",
        "                Restore(cubes[n]),\n",
        "                ChangeDecimalToValue(label[0], n),\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(label, DOWN),\n",
        "            get_cube_intro_anim(0)\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in [1, 2]:\n",
        "            self.play(get_cube_intro_anim(n))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            get_cube_intro_anim(3),\n",
        "            ApplyMethod(\n",
        "                frame.set_euler_angles, -20 * DEGREES, 75 * DEGREES,\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(dt * DEGREES))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Flatten cube\n",
        "        flat_cube = self.get_hypercube(3)\n",
        "        for n, vert in enumerate(flat_cube.verts):\n",
        "            point = vert.get_center()\n",
        "            if n < 4:\n",
        "                point *= 1.5\n",
        "            else:\n",
        "                point *= 0.75\n",
        "            point[2] = 0\n",
        "            vert.move_to(point)\n",
        "        reconnect_edges(flat_cube)\n",
        "\n",
        "        plane = NumberPlane(x_range=(-10, 10), y_range=(-10, 10), faded_line_ratio=0)\n",
        "        plane.set_opacity(0.25)\n",
        "        plane.apply_depth_test()\n",
        "        plane.axes.shift(0.01 * OUT)\n",
        "        plane.shift(0.02 * IN)\n",
        "\n",
        "        cubes[3].save_state()\n",
        "        self.add(cubes[3], plane)\n",
        "        self.play(\n",
        "            FadeIn(plane, run_time=2),\n",
        "            Transform(cubes[3], flat_cube, run_time=2),\n",
        "        )\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            Restore(cubes[3], run_time=2),\n",
        "            FadeOut(plane)\n",
        "        )\n",
        "        self.play(get_cube_intro_anim(4), run_time=3)\n",
        "        self.wait(10)\n",
        "\n",
        "        # Highlight some neighbor groups\n",
        "        colors = [RED, GREEN, BLUE_D, YELLOW]\n",
        "        for x in range(6):\n",
        "            vert = random.choice(cubes[4].verts)\n",
        "            neighbors = vert.neighbors.copy()\n",
        "            neighbors.save_state()\n",
        "            neighbors.generate_target()\n",
        "            new_edges = VGroup()\n",
        "            for neighbor, color in zip(neighbors.target, colors):\n",
        "                neighbor.set_color(color)\n",
        "                edge = Line(\n",
        "                    vert.get_center(),\n",
        "                    neighbor.get_center(),\n",
        "                    buff=vert.get_height() / 2,\n",
        "                )\n",
        "                edge.set_stroke(color, 5)\n",
        "                new_edges.add(edge)\n",
        "            self.remove(vert.neighbors)\n",
        "            self.play(\n",
        "                ShowCreation(new_edges, lag_ratio=0.2),\n",
        "                MoveToTarget(neighbors),\n",
        "            )\n",
        "            self.wait(1)\n",
        "            self.play(\n",
        "                FadeOut(new_edges),\n",
        "                Restore(neighbors),\n",
        "            )\n",
        "            self.remove(neighbors)\n",
        "            self.add(vert.neighbors)\n",
        "\n",
        "        # Show valid coloring\n",
        "        cubes[4].generate_target()\n",
        "        for n, vert in enumerate(cubes[4].target[0]):\n",
        "            code = boolian_linear_combo(int_to_bit_coords(n, 4))\n",
        "            vert.set_color(colors[code])\n",
        "        self.play(MoveToTarget(cubes[4], lag_ratio=0.2, run_time=3))\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "# Animations for Matt\n",
        "class WantAdditionToBeSubtraction(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Add sum\n",
        "        coins = CoinsOnBoard(\n",
        "            Chessboard(shape=(1, 4)),\n",
        "            coin_config={\"numeric_labels\": True},\n",
        "        )\n",
        "        for coin in coins[0], coins[2]:\n",
        "            coin.flip()\n",
        "\n",
        "        coefs = VGroup(*[Tex(f\"X_{i}\") for i in range(len(coins))])\n",
        "        full_sum = Group()\n",
        "        to_fade = VGroup()\n",
        "        for coin, coef in zip(coins, coefs):\n",
        "            coin.set_height(0.7)\n",
        "            coef.set_height(0.5)\n",
        "            summand = Group(coin, OldTex(\"\\\\cdot\"), coef, OldTex(\"+\"))\n",
        "            to_fade.add(*summand[1::2])\n",
        "            summand.arrange(RIGHT, buff=0.2)\n",
        "            full_sum.add(summand)\n",
        "        full_sum.add(OldTex(\"\\\\dots\"))\n",
        "        full_sum.arrange(RIGHT, buff=0.2)\n",
        "        to_fade.add(full_sum[-1])\n",
        "\n",
        "        some_label = OldTexText(\"Some kind of ``numbers''\")\n",
        "        some_label.next_to(full_sum, DOWN, buff=2)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(some_label.get_top(), coef.get_bottom())\n",
        "            for coef in coefs\n",
        "        ])\n",
        "\n",
        "        for coin in coins:\n",
        "            coin.save_state()\n",
        "            coin.rotate(90 * DEGREES, UP)\n",
        "            coin.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, coins, lag_ratio=0.3),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(to_fade),\n",
        "            LaggedStartMap(FadeInFromPoint, coefs, lambda m: (m, some_label.get_top())),\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "            Write(some_label, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(some_label), FadeOut(arrows))\n",
        "\n",
        "        # Show a flip\n",
        "        add_label = OldTex(\"+X_2\", color=GREEN)\n",
        "        sub_label = OldTex(\"-X_2\", color=RED)\n",
        "        for label in add_label, sub_label:\n",
        "            label.next_to(coins[2], UR)\n",
        "            label.match_height(coefs[2])\n",
        "            self.play(\n",
        "                FlipCoin(coins[2]),\n",
        "                FadeIn(label, 0.5 * DOWN)\n",
        "            )\n",
        "            self.play(FadeOut(label))\n",
        "\n",
        "        # What we want\n",
        "        want_label = OldTexText(\"Want: \", \"$X_i = -X_i$\")\n",
        "        eq = OldTexText(\"$X_i + X_i = 0$\")\n",
        "        want_label.next_to(full_sum, DOWN, LARGE_BUFF)\n",
        "        eq.next_to(want_label[1], DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(FadeIn(want_label))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(eq, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BitVectorSum(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        board = Chessboard(shape=(1, 4))\n",
        "        board.set_height(1)\n",
        "        coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "        coins[2].flip()\n",
        "\n",
        "        all_coords = [np.array([b0, b1]) for b0, b1 in it.product(range(2), range(2))]\n",
        "        bit_vectors = VGroup(*[\n",
        "            IntegerMatrix(coords.reshape((2, 1))).set_height(1)\n",
        "            for coords in all_coords\n",
        "        ])\n",
        "        bit_vectors.arrange(RIGHT, buff=2)\n",
        "        bit_vectors.to_edge(UP)\n",
        "        bit_vectors.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Arrow(board[0].get_corner(UL), bit_vectors[0].get_corner(DR)),\n",
        "            Arrow(board[1].get_corner(UP), bit_vectors[1].get_corner(DOWN)),\n",
        "            Arrow(board[2].get_corner(UP), bit_vectors[2].get_corner(DOWN)),\n",
        "            Arrow(board[3].get_corner(UR), bit_vectors[3].get_corner(DL)),\n",
        "        )\n",
        "\n",
        "        # Show vectors\n",
        "        self.add(board)\n",
        "        self.add(coins)\n",
        "        for arrow, vector in zip(arrows, bit_vectors):\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                FadeInFromPoint(vector, arrow.get_start()),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Move coins\n",
        "        coin_copies = coins.copy()\n",
        "        cdots = VGroup()\n",
        "        plusses = VGroup()\n",
        "        for cc, vector in zip(coin_copies, bit_vectors):\n",
        "            dot = OldTex(\"\\\\cdot\")\n",
        "            dot.next_to(vector, LEFT, MED_SMALL_BUFF)\n",
        "            cdots.add(dot)\n",
        "            plus = OldTex(\"+\")\n",
        "            plus.next_to(vector, RIGHT, MED_SMALL_BUFF)\n",
        "            plusses.add(plus)\n",
        "            cc.next_to(dot, LEFT, MED_SMALL_BUFF)\n",
        "        plusses[-1].set_opacity(0)\n",
        "\n",
        "        for coin, cc, dot, plus in zip(coins, coin_copies, cdots, plusses):\n",
        "            self.play(\n",
        "                TransformFromCopy(coin, cc),\n",
        "                Write(dot),\n",
        "            )\n",
        "            self.play(Write(plus))\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.move_to(plusses[-1])\n",
        "\n",
        "        def get_rhs(coins=coins, bit_vectors=bit_vectors, all_coords=all_coords, eq=eq):\n",
        "            bit_coords = sum([\n",
        "                (b * coords)\n",
        "                for coords, b in zip(all_coords, coins.get_bools())\n",
        "            ]) % 2\n",
        "            n = bit_coords_to_int(bit_coords)\n",
        "            result = bit_vectors[n].copy()\n",
        "            result.next_to(eq, RIGHT)\n",
        "            result.n = n\n",
        "            return result\n",
        "\n",
        "        def get_rhs_anim(rhs, bit_vectors=bit_vectors):\n",
        "            bv_copies = bit_vectors.copy()\n",
        "            bv_copies.generate_target()\n",
        "            for bv in bv_copies.target:\n",
        "                bv.move_to(rhs)\n",
        "                bv.set_opacity(0)\n",
        "            bv_copies.target[rhs.n].set_opacity(1)\n",
        "            return AnimationGroup(\n",
        "                MoveToTarget(bv_copies, remover=True),\n",
        "                ShowIncreasingSubsets(Group(rhs), int_func=np.floor)\n",
        "            )\n",
        "\n",
        "        rhs = get_rhs()\n",
        "\n",
        "        mod2_label = OldTexText(\"(Add mod 2)\")\n",
        "        mod2_label.next_to(rhs, DOWN, MED_LARGE_BUFF)\n",
        "        mod2_label.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(eq),\n",
        "            get_rhs_anim(rhs),\n",
        "            FadeIn(mod2_label),\n",
        "            FadeOut(board),\n",
        "            FadeOut(coins),\n",
        "            FadeOut(arrows),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show some flips\n",
        "        for x in range(8):\n",
        "            i = random.randint(0, 3)\n",
        "            rect = SurroundingRectangle(Group(coin_copies[i], bit_vectors[i]))\n",
        "            old_rhs = rhs\n",
        "            coins[i].flip()\n",
        "            rhs = get_rhs()\n",
        "            self.play(\n",
        "                ShowCreation(rect),\n",
        "                FlipCoin(coin_copies[i]),\n",
        "                FadeOut(old_rhs, RIGHT),\n",
        "                FadeIn(rhs, LEFT),\n",
        "            )\n",
        "            self.play(FadeOut(rect))\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class ExampleSquareAsBinaryNumber(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        board = Chessboard()\n",
        "        nums = VGroup()\n",
        "        bin_nums = VGroup()\n",
        "        for n, square in enumerate(board):\n",
        "            bin_num = VGroup(*[\n",
        "                Integer(int(b))\n",
        "                for b in int_to_bit_coords(n, min_dim=6)\n",
        "            ])\n",
        "            bin_num.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            bin_num.set_width((square.get_width() * 0.8))\n",
        "            num = Integer(n)\n",
        "            num.set_height(square.get_height() * 0.4)\n",
        "\n",
        "            for mob in num, bin_num:\n",
        "                mob.move_to(square, OUT)\n",
        "                mob.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "            num.generate_target()\n",
        "            num.target.replace(bin_num, stretch=True)\n",
        "            num.target.set_opacity(0)\n",
        "            bin_num.save_state()\n",
        "            bin_num.replace(num, stretch=True)\n",
        "            bin_num.set_opacity(0)\n",
        "\n",
        "            nums.add(num)\n",
        "            bin_nums.add(bin_num)\n",
        "\n",
        "        # Transform to binary\n",
        "        self.add(board, nums)\n",
        "        self.wait()\n",
        "        original_nums = nums.copy()\n",
        "        self.play(LaggedStart(*[\n",
        "            AnimationGroup(MoveToTarget(num), Restore(bin_num))\n",
        "            for num, bin_num in zip(nums, bin_nums)\n",
        "        ]), lag_ratio=0.1)\n",
        "        self.remove(nums)\n",
        "        nums = original_nums\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            bin_nums.set_stroke, None, 0,\n",
        "            bin_nums.set_opacity, 0.1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Count\n",
        "        n = 43\n",
        "        self.play(\n",
        "            board[n].set_color, MAROON_E,\n",
        "            Animation(bin_nums[n]),\n",
        "        )\n",
        "\n",
        "        last = VMobject()\n",
        "        shown_nums = VGroup()\n",
        "        for k in [0, 8, 16, 24, 32, 40, 41, 42, 43]:\n",
        "            nums[k].set_fill(YELLOW)\n",
        "            self.add(nums[k])\n",
        "            self.play(last.set_fill, WHITE, run_time=0.5)\n",
        "            last = nums[k]\n",
        "            shown_nums.add(last)\n",
        "            if k == 40:\n",
        "                self.wait()\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, shown_nums[:-1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(last),\n",
        "            bin_nums[n].set_opacity, 1,\n",
        "            bin_nums[n].set_fill, YELLOW\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SkipSkipYesYes(Scene):\n",
        "    def construct(self):\n",
        "        board = Chessboard()\n",
        "        board.next_to(ORIGIN, DOWN)\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Skip\"),\n",
        "            OldTexText(\"Skip\"),\n",
        "            OldTexText(\"Yes\"),\n",
        "            OldTexText(\"Yes\"),\n",
        "        )\n",
        "        words.add(*words.copy())\n",
        "        words.set_width(board[0].get_width() * 0.8)\n",
        "        for word, square in zip(words, board):\n",
        "            word.move_to(square)\n",
        "            word.set_y(0, UP)\n",
        "\n",
        "        for group in words[:4], words[4:]:\n",
        "            self.play(ShowIncreasingSubsets(group, rate_func=double_smooth, run_time=2))\n",
        "            self.play(FadeOut(group))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ShowCurrAndTarget(Scene):\n",
        "    CONFIG = {\n",
        "        \"bit_strings\": [\n",
        "            \"011010\",\n",
        "            \"110001\",\n",
        "            \"101011\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Current: \"),\n",
        "            OldTexText(\"Need to\\\\\\\\change:\"),\n",
        "            OldTexText(\"Target: \"),\n",
        "        )\n",
        "        words.arrange(DOWN, buff=0.75, aligned_edge=RIGHT)\n",
        "        words.to_corner(UL)\n",
        "\n",
        "        def get_bit_aligned_bit_string(bit_coords):\n",
        "            result = VGroup(*[Integer(int(b)) for b in bit_coords])\n",
        "            for i, bit in enumerate(result):\n",
        "                bit.move_to(ORIGIN, LEFT)\n",
        "                bit.shift(i * RIGHT * 0.325)\n",
        "            result.set_stroke(BLACK, 4, background=True)\n",
        "            return result\n",
        "\n",
        "        bit_strings = VGroup(*[\n",
        "            get_bit_aligned_bit_string(bs)\n",
        "            for bs in self.bit_strings\n",
        "        ])\n",
        "        for word, bs in zip(words, bit_strings):\n",
        "            bs.next_to(word.family_members_with_points()[-1], RIGHT, aligned_edge=DOWN)\n",
        "\n",
        "        words[1].set_fill(YELLOW)\n",
        "        bit_strings[1].set_fill(YELLOW)\n",
        "\n",
        "        self.add(words[::2])\n",
        "        self.add(bit_strings[::2])\n",
        "        self.wait()\n",
        "        self.play(FadeIn(words[1]))\n",
        "\n",
        "        curr_rect = None\n",
        "        for n in reversed(range(6)):\n",
        "            rect = SurroundingRectangle(Group(\n",
        "                bit_strings[0][n],\n",
        "                bit_strings[2][n],\n",
        "                buff=0.05,\n",
        "            ))\n",
        "            rect.stretch(0.9, 0)\n",
        "            rect.set_stroke(WHITE, 1)\n",
        "            if curr_rect is None:\n",
        "                curr_rect = rect\n",
        "                self.play(ShowCreation(curr_rect))\n",
        "            else:\n",
        "                self.play(Transform(curr_rect, rect, run_time=0.25))\n",
        "                self.wait(0.75)\n",
        "            self.play(FadeIn(bit_strings[1][n]))\n",
        "        self.play(FadeOut(curr_rect))\n",
        "\n",
        "\n",
        "class ShowCurrAndTargetAlt(ShowCurrAndTarget):\n",
        "    CONFIG = {\n",
        "        \"bit_strings\": [\n",
        "            \"110100\",\n",
        "            \"010101\",\n",
        "            \"100001\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class EulerDiagram(Scene):\n",
        "    def construct(self):\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "        vects = compass_directions(3, UP)\n",
        "        circles = VGroup(*[\n",
        "            Circle(\n",
        "                radius=2,\n",
        "                fill_color=color,\n",
        "                stroke_color=color,\n",
        "                fill_opacity=0.5,\n",
        "                stroke_width=3,\n",
        "            ).shift(1.2 * vect)\n",
        "            for vect, color in zip(vects, colors)\n",
        "        ])\n",
        "        bit_coords = list(map(int_to_bit_coords, range(8)))\n",
        "        bit_strings = VGroup(*map(get_bit_string, bit_coords))\n",
        "        bit_strings.center()\n",
        "        r1 = 2.2\n",
        "        r2 = 1.4\n",
        "        bit_strings[0].next_to(circles[0], LEFT).shift(UP)\n",
        "        bit_strings[1].shift(r1 * vects[0])\n",
        "        bit_strings[2].shift(r1 * vects[1])\n",
        "        bit_strings[3].shift(r2 * (vects[0] + vects[1]))\n",
        "        bit_strings[4].shift(r1 * vects[2])\n",
        "        bit_strings[5].shift(r2 * (vects[0] + vects[2]))\n",
        "        bit_strings[6].shift(r2 * (vects[1] + vects[2]))\n",
        "\n",
        "        self.add(circles)\n",
        "\n",
        "        for circle in circles:\n",
        "            circle.save_state()\n",
        "\n",
        "        for coords, bstring in zip(bit_coords[1:], bit_strings[1:]):\n",
        "            for circ, coord in zip(circles, reversed(coords)):\n",
        "                circ.generate_target()\n",
        "                if coord:\n",
        "                    circ.target.become(circ.saved_state)\n",
        "                else:\n",
        "                    circ.target.set_opacity(0.1)\n",
        "            self.play(\n",
        "                FadeIn(bstring),\n",
        "                *map(MoveToTarget, circles),\n",
        "                run_time=0.25,\n",
        "            )\n",
        "            self.wait(0.75)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(bit_strings[0], DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowBoardRegions(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        board = Chessboard()\n",
        "        nums = VGroup()\n",
        "        pre_bin_nums = VGroup()\n",
        "        bin_nums = VGroup()\n",
        "        for n, square in enumerate(board):\n",
        "            bin_num = VGroup(*[\n",
        "                Integer(int(b), fill_color=GREY_A)\n",
        "                for b in int_to_bit_coords(n, min_dim=6)\n",
        "            ])\n",
        "            bin_num.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            bin_num.set_width((square.get_width() * 0.8))\n",
        "            num = Integer(n)\n",
        "            num.set_height(square.get_height() * 0.4)\n",
        "\n",
        "            for mob in num, bin_num:\n",
        "                mob.move_to(square, OUT)\n",
        "                mob.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "            bin_num.align_to(square, DOWN)\n",
        "            bin_num.shift(SMALL_BUFF * UP)\n",
        "\n",
        "            pre_bin_num = num.copy()\n",
        "            pre_bin_num.generate_target()\n",
        "            pre_bin_num.target.replace(bin_num, stretch=True)\n",
        "            pre_bin_num.target.set_opacity(0)\n",
        "\n",
        "            num.generate_target()\n",
        "            num.target.scale(0.7)\n",
        "            num.target.align_to(square, UP)\n",
        "            num.target.shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "            bin_num.save_state()\n",
        "            bin_num.replace(num, stretch=True)\n",
        "            bin_num.set_opacity(0)\n",
        "\n",
        "            nums.add(num)\n",
        "            bin_nums.add(bin_num)\n",
        "            pre_bin_nums.add(pre_bin_num)\n",
        "\n",
        "        # Transform to binary\n",
        "        self.add(board)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(nums, run_time=4, rate_func=bezier([0, 0, 1, 1]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                AnimationGroup(\n",
        "                    MoveToTarget(num),\n",
        "                    MoveToTarget(pbn),\n",
        "                    Restore(bin_num),\n",
        "                )\n",
        "                for num, pbn, bin_num in zip(nums, pre_bin_nums, bin_nums)\n",
        "            ], lag_ratio=1.5 / 64),\n",
        "        )\n",
        "        self.remove(pre_bin_nums)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Build groups to highlight\n",
        "        one_groups = VGroup()\n",
        "        highlights = VGroup()\n",
        "        for i in reversed(range(6)):\n",
        "            one_group = VGroup()\n",
        "            highlight = VGroup()\n",
        "            for bin_num, square in zip(bin_nums, board):\n",
        "                boundary_square = Square()\n",
        "                # boundary_square.set_stroke(YELLOW, 4)\n",
        "                boundary_square.set_stroke(BLUE, 4)\n",
        "                boundary_square.set_fill(BLUE, 0.5)\n",
        "                boundary_square.replace(square)\n",
        "                boundary_square.move_to(square, OUT)\n",
        "                bit = bin_num[i]\n",
        "                if bit.get_value() == 1:\n",
        "                    one_group.add(bit)\n",
        "                    highlight.add(boundary_square)\n",
        "            one_group.save_state()\n",
        "            one_groups.add(one_group)\n",
        "            highlights.add(highlight)\n",
        "\n",
        "        # Highlight hit_groups\n",
        "        curr_highlight = None\n",
        "        for one_group, highlight in zip(one_groups, highlights):\n",
        "            one_group.generate_target()\n",
        "            one_group.target.set_fill(YELLOW)\n",
        "            one_group.target.set_stroke(YELLOW, 2)\n",
        "            if curr_highlight is None:\n",
        "                self.play(MoveToTarget(one_group))\n",
        "                self.wait()\n",
        "                self.play(LaggedStartMap(DrawBorderThenFill, highlight, lag_ratio=0.1, run_time=3))\n",
        "                curr_highlight = highlight\n",
        "            else:\n",
        "                self.add(one_group, curr_highlight)\n",
        "                self.play(\n",
        "                    MoveToTarget(one_group),\n",
        "                    Transform(curr_highlight, highlight)\n",
        "                )\n",
        "            self.wait()\n",
        "            self.play(Restore(one_group))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(curr_highlight))\n",
        "\n",
        "\n",
        "class ShowFinalStrategy(Scene):\n",
        "    CONFIG = {\n",
        "        \"show_with_lines\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup board and such\n",
        "        board = Chessboard()\n",
        "        board.to_edge(RIGHT)\n",
        "        coins = CoinsOnBoard(board, coin_config={\"numeric_labels\": True})\n",
        "        coins.flip_by_message(\"3b1b  :)\")\n",
        "\n",
        "        encoding_lines = VGroup(*[Line(ORIGIN, 0.5 * RIGHT) for x in range(6)])\n",
        "        encoding_lines.arrange(LEFT, buff=SMALL_BUFF)\n",
        "        encoding_lines.next_to(board, LEFT, LARGE_BUFF)\n",
        "        encoding_lines.shift(UP)\n",
        "\n",
        "        code_words = OldTexText(\"Encoding\")\n",
        "        code_words.next_to(encoding_lines, DOWN)\n",
        "\n",
        "        add_words = OldTexText(\"Check the parity\\\\\\\\of these coins\")\n",
        "        add_words.next_to(board, LEFT, LARGE_BUFF, aligned_edge=UP)\n",
        "\n",
        "        self.add(board, coins)\n",
        "        self.add(encoding_lines)\n",
        "        self.add(code_words)\n",
        "\n",
        "        # Set up groups\n",
        "        fade_groups = Group()\n",
        "        line_groups = VGroup()\n",
        "        mover_groups = VGroup()\n",
        "        count_mobs = VGroup()\n",
        "        one_groups = VGroup()\n",
        "        bits = VGroup()\n",
        "        for i in range(6):\n",
        "            bit = Integer(0)\n",
        "            bit.next_to(encoding_lines[i], UP, SMALL_BUFF)\n",
        "            bits.add(bit)\n",
        "\n",
        "            count_mob = Integer(0)\n",
        "            count_mob.set_color(RED)\n",
        "            count_mob.next_to(add_words, DOWN, MED_SMALL_BUFF)\n",
        "            count_mobs.add(count_mob)\n",
        "\n",
        "            line_group = VGroup()\n",
        "            fade_group = Group()\n",
        "            mover_group = VGroup()\n",
        "            one_rect_group = VGroup()\n",
        "            count = 0\n",
        "            for n, coin in enumerate(coins):\n",
        "                if bool(n & (1 << i)):\n",
        "                    line_group.add(Line(\n",
        "                        coin.get_center(),\n",
        "                        bit.get_center(),\n",
        "                    ))\n",
        "                    mover_group.add(coin.labels[1 - int(coin.is_heads())].copy())\n",
        "                    if coin.is_heads():\n",
        "                        one_rect_group.add(SurroundingRectangle(coin))\n",
        "                        count += 1\n",
        "                else:\n",
        "                    fade_group.add(coin)\n",
        "            bit.set_value(count % 2)\n",
        "            fade_group.save_state()\n",
        "            line_group.set_stroke(BLUE, width=1, opacity=0.5)\n",
        "            fade_groups.add(fade_group)\n",
        "            line_groups.add(line_group)\n",
        "            mover_groups.add(mover_group)\n",
        "            one_groups.add(one_rect_group)\n",
        "\n",
        "        # Animate\n",
        "        for lines, fades, movers, og, cm, bit in zip(line_groups, fade_groups, mover_groups, one_groups, count_mobs, bits):\n",
        "            self.play(\n",
        "                FadeIn(add_words),\n",
        "                fades.set_opacity, 0.1,\n",
        "            )\n",
        "            if self.show_with_lines:\n",
        "                for mover in movers:\n",
        "                    mover.generate_target()\n",
        "                    mover.target.replace(bit)\n",
        "                    mover.target.set_opacity(0)\n",
        "                bit.save_state()\n",
        "                bit.replace(movers[0])\n",
        "                bit.set_opacity(0)\n",
        "                self.play(\n",
        "                    LaggedStartMap(ShowCreation, lines, run_time=2),\n",
        "                    LaggedStartMap(MoveToTarget, movers, lag_ratio=0.01),\n",
        "                    Restore(bit)\n",
        "                )\n",
        "                self.remove(movers)\n",
        "                self.add(bit)\n",
        "                self.play(\n",
        "                    FadeOut(lines)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    ShowIncreasingSubsets(og),\n",
        "                    UpdateFromFunc(cm, lambda m: m.set_value(len(og)))\n",
        "                )\n",
        "                self.play(FadeInFromPoint(bit, cm.get_center()))\n",
        "                self.play(\n",
        "                    FadeOut(og),\n",
        "                    FadeOut(cm),\n",
        "                )\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(add_words),\n",
        "                Restore(fades),\n",
        "            )\n",
        "            self.remove(fades)\n",
        "            self.add(coins)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowFinalStrategyWithFadeLines(ShowFinalStrategy):\n",
        "    CONFIG = {\n",
        "        \"show_with_lines\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail(FourDCubeColoringFromTrees):\n",
        "    def construct(self):\n",
        "        # Board\n",
        "        board = Chessboard(\n",
        "            shape=(8, 8),\n",
        "            # shape=(6, 6),\n",
        "            square_resolution=(5, 5),\n",
        "            top_square_resolution=(7, 7),\n",
        "        )\n",
        "        board.set_gloss(0.3)\n",
        "        k = 16\n",
        "        board[k].set_color(YELLOW)\n",
        "        board.set_height(7)\n",
        "\n",
        "        coins = CoinsOnBoard(\n",
        "            board,\n",
        "            coin_config={\n",
        "                # \"disk_resolution\": (80, 51),\n",
        "                \"disk_resolution\": (2, 12),\n",
        "            }\n",
        "        )\n",
        "        coins.flip_by_message(\"A colab!\")\n",
        "\n",
        "        board_group = Group(board, coins)\n",
        "        board_group.set_width(FRAME_WIDTH / 2 - 2)\n",
        "        board_group.set_x(-FRAME_WIDTH / 4)\n",
        "        self.add(board_group)\n",
        "\n",
        "        # Hypercube\n",
        "        cube = self.get_hypercube(width=2)\n",
        "        colors = [BLUE_D, TEAL, GREEN, YELLOW]\n",
        "        for n, vert in enumerate(cube.verts):\n",
        "            code = boolian_linear_combo(int_to_bit_coords(n, 4))\n",
        "            cube.verts[n].set_color(colors[code])\n",
        "\n",
        "        cube.set_width(FRAME_WIDTH / 2 - 2)\n",
        "        cube.set_x(FRAME_WIDTH / 4)\n",
        "        cube.set_z(0, OUT)\n",
        "        cube.rotate(7 * DEGREES, UP)\n",
        "        self.add(cube)\n",
        "\n",
        "        Group(cube, board_group).to_edge(UP, LARGE_BUFF)\n",
        "\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(GREY_A, 3)\n",
        "        self.add(v_line)\n",
        "\n",
        "        titles = VGroup(Text(\"From chessboards\"), Text(\"to hypercubes\"))\n",
        "        titles.match_width(board_group)\n",
        "        for title, mob in zip(titles, [board_group, cube]):\n",
        "            title.match_x(mob)\n",
        "        titles.to_edge(DOWN)\n",
        "        self.add(titles)\n",
        "        return\n",
        "\n",
        "        # Instructions\n",
        "        message = OldTexText(\n",
        "            \"Flip one coin\\\\\\\\to describe a\\\\\\\\\",\n",
        "            \"unique square\",\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        message[1].set_color(YELLOW)\n",
        "        message.scale(1.25)\n",
        "        message.to_edge(LEFT)\n",
        "        message.shift(1.25 * DOWN)\n",
        "        message.fix_in_frame()\n",
        "        arrow = Arrow(\n",
        "            message.get_corner(UR),\n",
        "            message.get_corner(UR) + 3 * RIGHT + UP,\n",
        "            path_arc=-70 * DEGREES,\n",
        "        )\n",
        "        arrow.fix_in_frame()\n",
        "        arrow.shift(1.5 * LEFT)\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        # self.add(message)\n",
        "        # self.add(arrow)\n",
        "\n",
        "\n",
        "class ChessEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"scroll_time\": 25,\n",
        "    }\n"
    ]
}