{
    "topic": "is demonstrating the concept of differentiation and its application in mathematics. Specifically, it shows",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "SINE_COLOR = BLUE\n",
        "X_SQUARED_COLOR = GREEN\n",
        "SUM_COLOR = YELLOW\n",
        "PRODUCT_COLOR = YELLOW\n",
        "\n",
        "class Chapter4OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"Using the chain rule is like peeling an onion: \",\n",
        "            \"you have to deal with each layer at a time, and \",\n",
        "            \"if it is too big you will start crying.\"\n",
        "        ],\n",
        "        \"author\" : \"(Anonymous professor)\"\n",
        "    }\n",
        "\n",
        "class TransitionFromLastVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        simple_rules = VGroup(*list(map(Tex, [\n",
        "            \"\\\\frac{d(x^3)}{dx} = 3x^2\",\n",
        "            \"\\\\frac{d(\\\\sin(x))}{dx} = \\\\cos(x)\",\n",
        "            \"\\\\frac{d(1/x)}{dx} = -\\\\frac{1}{x^2}\",\n",
        "        ])))\n",
        "\n",
        "        combination_rules = VGroup(*[\n",
        "            OldTex(\"\\\\frac{d}{dx}\\\\left(%s\\\\right)\"%tex)\n",
        "            for tex in [\n",
        "                \"\\\\sin(x) + x^2\",\n",
        "                \"\\\\sin(x)(x^2)\",\n",
        "                \"\\\\sin(x^2)\",\n",
        "            ]\n",
        "        ])\n",
        "        for rules in simple_rules, combination_rules:\n",
        "            rules.arrange(buff = LARGE_BUFF)\n",
        "            rules.next_to(self.get_teacher(), UP, buff = MED_LARGE_BUFF)\n",
        "            rules.to_edge(LEFT)\n",
        "\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        last_video = series[2]\n",
        "        last_video.save_state()\n",
        "        this_video = series[3]\n",
        "        brace = Brace(last_video)\n",
        "\n",
        "        #Simple rules\n",
        "        self.add(series)\n",
        "        self.play(\n",
        "            FadeIn(brace),\n",
        "            last_video.set_color, YELLOW\n",
        "        )\n",
        "        for rule in simple_rules:\n",
        "            self.play(\n",
        "                Write(rule, run_time = 2),\n",
        "                self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "                *[\n",
        "                    ApplyMethod(pi.change_mode, \"pondering\")\n",
        "                    for pi in self.get_students()\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "        self.play(simple_rules.replace, last_video)\n",
        "        self.play(\n",
        "            last_video.restore,            \n",
        "            Animation(simple_rules),\n",
        "            brace.next_to, this_video, DOWN,\n",
        "            this_video.set_color, YELLOW\n",
        "        )\n",
        "\n",
        "        #Combination rules\n",
        "        self.play(\n",
        "            Write(combination_rules),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"confused\")\n",
        "                for pi in self.get_students()\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for rule in combination_rules:\n",
        "            interior = VGroup(*rule[5:-1])\n",
        "            added_anims = []\n",
        "            if rule is combination_rules[-1]:\n",
        "                inner_func = VGroup(*rule[-4:-2])\n",
        "                self.play(inner_func.shift, 0.5*UP)\n",
        "                added_anims = [\n",
        "                    inner_func.shift, 0.5*DOWN,\n",
        "                    inner_func.set_color, YELLOW\n",
        "                ]\n",
        "            self.play(\n",
        "                interior.set_color, YELLOW,\n",
        "                *added_anims,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        #Address subtraction and division\n",
        "        subtraction = OldTex(\"\\\\sin(x)\", \"-\", \"x^2\")\n",
        "        decomposed_subtraction = OldTex(\"\\\\sin(x)\", \"+(-1)\\\\cdot\", \"x^2\")\n",
        "        pre_division = OldTex(\"\\\\frac{\\\\sin(x)}{x^2}\")\n",
        "        division = VGroup(\n",
        "            VGroup(*pre_division[:6]),\n",
        "            VGroup(*pre_division[6:7]),\n",
        "            VGroup(*pre_division[7:]),\n",
        "        )\n",
        "        pre_decomposed_division = OldTex(\"\\\\sin(x)\\\\cdot\\\\frac{1}{x^2}\")\n",
        "        decomposed_division = VGroup(\n",
        "            VGroup(*pre_decomposed_division[:6]),\n",
        "            VGroup(*pre_decomposed_division[6:9]),\n",
        "            VGroup(*pre_decomposed_division[9:]),\n",
        "        )\n",
        "        for mob in subtraction, decomposed_subtraction, division, decomposed_division:\n",
        "            mob.next_to(\n",
        "                VGroup(self.get_teacher(), self.get_students()[-1]),\n",
        "                UP, buff = MED_LARGE_BUFF\n",
        "            )\n",
        "\n",
        "        top_group = VGroup(series, simple_rules, brace)\n",
        "        combination_rules.save_state()\n",
        "        self.play(\n",
        "            top_group.next_to, FRAME_Y_RADIUS*UP, UP,\n",
        "            combination_rules.to_edge, UP,\n",
        "        )\n",
        "        pairs = [\n",
        "            (subtraction, decomposed_subtraction), \n",
        "            (division, decomposed_division)\n",
        "        ]\n",
        "        for question, answer in pairs:\n",
        "            self.play(\n",
        "                Write(question),\n",
        "                combination_rules.fade, 0.2,\n",
        "                self.get_students()[2].change_mode, \"raise_right_hand\",\n",
        "                self.get_teacher().change_mode, \"plain\",\n",
        "            )\n",
        "            self.wait()\n",
        "            answer[1].set_color(GREEN)\n",
        "            self.play(\n",
        "                Transform(question, answer),\n",
        "                self.get_teacher().change_mode, \"hooray\",\n",
        "                self.get_students()[2].change_mode, \"plain\",\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(FadeOut(question))\n",
        "\n",
        "        #Monstrous expression\n",
        "        monster = OldTex(\n",
        "            \"\\\\Big(\",\n",
        "            \"e^{\\\\sin(x)} \\\\cdot\",\n",
        "            \"\\\\cos\\\\Big(\",\n",
        "            \"\\\\frac{1}{x^3}\",\n",
        "            \" + x^3\",\n",
        "            \"\\\\Big)\",\n",
        "            \"\\\\Big)^4\"\n",
        "        )\n",
        "        monster.next_to(self.get_pi_creatures(), UP)\n",
        "        parts = [\n",
        "            VGroup(*monster[3][2:]),\n",
        "            VGroup(*monster[3][:2]),\n",
        "            monster[4],\n",
        "            VGroup(monster[2], monster[5]),\n",
        "            monster[1],\n",
        "            VGroup(monster[0], monster[6])\n",
        "        ]\n",
        "        modes = 3*[\"erm\"] + 3*[\"pleading\"]\n",
        "        for part, mode in zip(parts, modes):\n",
        "            self.play(\n",
        "                FadeIn(part, lag_ratio = 0.5),\n",
        "                self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "                *[\n",
        "                    ApplyMethod(pi.change_mode, mode)\n",
        "                    for pi in self.get_students()\n",
        "                ]\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        words = list(map(TexText, [\n",
        "            \"composition\", \"product\", \n",
        "            \"composition\", \"sum\",\n",
        "            \"composition\"\n",
        "        ]))\n",
        "\n",
        "        for word, part in zip(words, reversed(parts)):\n",
        "            word.set_color(YELLOW)\n",
        "            word.next_to(monster, UP)\n",
        "            self.play(\n",
        "                FadeIn(word),\n",
        "                part.scale, 1.2,\n",
        "                part.set_color, YELLOW\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(*list(map(FadeOut, [word, part])))\n",
        "        self.play(FadeOut(parts[0]))\n",
        "\n",
        "        #Bring back combinations\n",
        "        self.play(\n",
        "            combination_rules.restore,\n",
        "            *[\n",
        "                ApplyMethod(pi_creature.change_mode, \"pondering\")\n",
        "                for pi_creature in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class DampenedSpring(Scene):\n",
        "    def construct(self):\n",
        "        compact_spring, extended_spring = [\n",
        "            ParametricCurve(\n",
        "                lambda t : (t/denom)*RIGHT+np.sin(t)*UP+np.cos(t)*OUT,\n",
        "                t_max = 12*np.pi,\n",
        "                color = GREY,\n",
        "            ).shift(3*LEFT)\n",
        "            for denom in (12.0, 2.0)\n",
        "        ]\n",
        "        for spring in compact_spring, extended_spring:\n",
        "            spring.scale(0.5)\n",
        "            spring.rotate(np.pi/6, UP)\n",
        "            spring.set_color(GREY)\n",
        "            spring.shift(-spring.get_points()[0] + 3*LEFT)\n",
        "\n",
        "        moving_spring = compact_spring.copy()\n",
        "\n",
        "        def update_spring(spring, a):\n",
        "            spring.interpolate(\n",
        "                compact_spring, \n",
        "                extended_spring,\n",
        "                0.5*(np.exp(-4*a)*np.cos(40*a)+1)\n",
        "            )\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{Length} = 2 + e^{-4t}\\\\cos(20t)\"\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "\n",
        "        self.add(moving_spring, equation)\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            moving_spring, update_spring, run_time = 10,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class ComingUp(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_stroke(WHITE)\n",
        "        rect.set_height(FRAME_HEIGHT-2)\n",
        "        title = OldTexText(\"Coming up...\")\n",
        "        title.to_edge(UP)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "class PreSumRuleDiscussion(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Sum rule\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        specific = OldTex(\n",
        "            \"\\\\frac{d}{dx}(\", \"\\\\sin(x)\", \"+\", \"x^2\", \")\",\n",
        "            \"=\", \"\\\\cos(x)\", \"+\", \"2x\"\n",
        "        )\n",
        "        general = OldTex(\n",
        "            \"\\\\frac{d}{dx}(\", \"g(x)\", \"+\", \"h(x)\", \")\",\n",
        "            \"=\", \"\\\\frac{dg}{dx}\", \"+\", \"\\\\frac{dh}{dx}\"\n",
        "        )\n",
        "        for formula in specific, general:\n",
        "            formula[1].set_color(SINE_COLOR)\n",
        "            formula[6].set_color(SINE_COLOR)\n",
        "            formula[3].set_color(X_SQUARED_COLOR)\n",
        "            formula[8].set_color(X_SQUARED_COLOR)\n",
        "        VGroup(specific, general).arrange(DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        #Add on rules\n",
        "        self.add(specific)\n",
        "        for i in 0, 4, 5:\n",
        "            self.add(general[i])\n",
        "        self.wait(2)\n",
        "        for indices in [(1, 2, 3), (6,), (7, 8)]:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    specific[i].copy(), general[i]\n",
        "                )\n",
        "                for i in indices\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "        #Highlight parts\n",
        "        for i in 1, 3, -1, 6, 8:\n",
        "            if i < 0:\n",
        "                self.wait()\n",
        "            else:\n",
        "                part = specific[i]\n",
        "                self.play(\n",
        "                    part.set_color, YELLOW,\n",
        "                    part.scale, 1.2,\n",
        "                    rate_func = there_and_back\n",
        "                )\n",
        "        self.wait()\n",
        "\n",
        "class SumRule(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_max\" : 4,\n",
        "        \"x_axis_width\" : FRAME_WIDTH,\n",
        "        \"y_max\" : 3,\n",
        "        \"graph_origin\" : 2.5*DOWN + 2.5*LEFT,\n",
        "        \"graph_label_x_value\" : 1.5,\n",
        "        \"example_input\" : 0.5,\n",
        "        \"example_input_string\" : \"0.5\",\n",
        "        \"dx\" : 0.05,\n",
        "        \"v_lines_x_min\" : -1,\n",
        "        \"v_lines_x_max\" : 2,\n",
        "        \"graph_scale_factor\" : 2,\n",
        "        \"tex_scale_factor\" : 0.8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.write_function()\n",
        "        self.add_graphs()\n",
        "        self.zoom_in_on_graph()\n",
        "        self.show_example_stacking()\n",
        "        self.show_df()\n",
        "        self.expand_derivative()\n",
        "\n",
        "    def write_function(self):\n",
        "        func_mob = OldTex(\"f(x)\", \"=\", \"\\\\sin(x)\", \"+\", \"x^2\")\n",
        "        func_mob.scale(self.tex_scale_factor)\n",
        "        func_mob.set_color_by_tex(\"f(x)\", SUM_COLOR)\n",
        "        func_mob.set_color_by_tex(\"\\\\sin(x)\", SINE_COLOR)\n",
        "        func_mob.set_color_by_tex(\"x^2\", X_SQUARED_COLOR)\n",
        "        func_mob.to_corner(UP+LEFT)\n",
        "        self.add(func_mob)\n",
        "\n",
        "        self.func_mob = func_mob\n",
        "\n",
        "    def add_graphs(self):\n",
        "        self.setup_axes()\n",
        "        sine_graph = self.get_graph(np.sin, color = SINE_COLOR)\n",
        "        parabola = self.get_graph(lambda x : x**2, color = X_SQUARED_COLOR)\n",
        "        sum_graph = self.get_graph(\n",
        "            lambda x : np.sin(x) + x**2, \n",
        "            color = SUM_COLOR\n",
        "        )\n",
        "        sine_label = self.get_graph_label(\n",
        "            sine_graph, \"\\\\sin(x)\",\n",
        "            x_val = self.graph_label_x_value,\n",
        "            direction = UP+RIGHT,\n",
        "            buff = 0,\n",
        "        )\n",
        "        sine_label.scale(self.tex_scale_factor)\n",
        "        parabola_label = self.get_graph_label(\n",
        "            parabola, \"x^2\", x_val = self.graph_label_x_value,\n",
        "        )\n",
        "        parabola_label.scale(self.tex_scale_factor)\n",
        "\n",
        "        graphs = VGroup(sine_graph, parabola)\n",
        "        labels = VGroup(sine_label, parabola_label)\n",
        "        for label in labels:\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "        for graph, label in zip(graphs, labels):\n",
        "            self.play(\n",
        "                ShowCreation(graph),\n",
        "                Write(label)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        num_lines = (self.v_lines_x_max-self.v_lines_x_min)/self.dx\n",
        "        sine_v_lines, parabox_v_lines = v_line_sets = [\n",
        "            self.get_vertical_lines_to_graph(\n",
        "                graph, \n",
        "                x_min = self.v_lines_x_min,\n",
        "                x_max = self.v_lines_x_max, \n",
        "                num_lines = num_lines,\n",
        "                stroke_width = 2\n",
        "            )\n",
        "            for graph in graphs\n",
        "        ]\n",
        "        sine_v_lines.shift(0.02*RIGHT)\n",
        "        for v_lines in v_line_sets:\n",
        "            self.play(ShowCreation(v_lines), Animation(labels))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ApplyMethod(l2.move_to, l1.get_top(), DOWN)\n",
        "                for l1, l2, in zip(*v_line_sets)\n",
        "            ],\n",
        "            [graph.fade for graph in graphs],\n",
        "            [Animation(labels)]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(sum_graph))\n",
        "        self.wait()\n",
        "\n",
        "        self.sum_graph = sum_graph\n",
        "        self.parabola = parabola\n",
        "        self.sine_graph = sine_graph\n",
        "        self.graph_labels = labels\n",
        "        self.v_line_sets = v_line_sets\n",
        "\n",
        "    def zoom_in_on_graph(self):\n",
        "        graph_parts = VGroup(\n",
        "            self.axes, \n",
        "            self.sine_graph, self.parabola, self.sum_graph,\n",
        "            *self.v_line_sets\n",
        "        )\n",
        "        graph_parts.remove(self.func_mob, *self.graph_labels)\n",
        "        graph_parts.generate_target()\n",
        "        self.graph_labels.generate_target()\n",
        "        for mob in graph_parts, self.graph_labels:\n",
        "            mob.target.scale(\n",
        "                self.graph_scale_factor, \n",
        "                about_point = self.graph_origin,\n",
        "            )\n",
        "        for mob in self.graph_labels.target:\n",
        "            mob.scale(\n",
        "                1./self.graph_scale_factor,\n",
        "                about_point = mob.get_bottom()\n",
        "            )\n",
        "            mob.shift_onto_screen()\n",
        "        self.play(*list(map(MoveToTarget, [\n",
        "            graph_parts, self.graph_labels\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "    def show_example_stacking(self):\n",
        "        v_line_sets = self.v_line_sets\n",
        "        num_lines = len(v_line_sets[0])\n",
        "        example_v_lines, nudged_v_lines = [\n",
        "            VGroup(*[v_lines[index] for v_lines in v_line_sets])\n",
        "            for index in (num_lines/2, num_lines/2+1)\n",
        "        ]\n",
        "        for line in nudged_v_lines:\n",
        "            line.save_state()\n",
        "        sine_lines, parabola_lines = [\n",
        "            VGroup(example_v_lines[i], nudged_v_lines[i])\n",
        "            for i in (0, 1)\n",
        "        ]\n",
        "        faders = VGroup(*[line for line in it.chain(*v_line_sets) if line not in example_v_lines])\n",
        "        label_groups = []\n",
        "        for line, tex, vect in zip(sine_lines, [\"\", \"+dx\"], [LEFT, RIGHT]):\n",
        "            dot = Dot(line.get_bottom(), radius = 0.03, color = YELLOW)\n",
        "            label = OldTex(\n",
        "                \"x=\" + str(self.example_input) + tex\n",
        "            )\n",
        "            label.next_to(dot, DOWN+vect, buff = MED_LARGE_BUFF)\n",
        "            arrow = Arrow(\n",
        "                label.get_corner(UP-vect), dot,\n",
        "                buff = SMALL_BUFF,\n",
        "                color = WHITE,\n",
        "                tip_length = 0.1\n",
        "            )\n",
        "            label_groups.append(VGroup(label, arrow, dot))\n",
        "\n",
        "        line_tex_direction_triplets = [\n",
        "            (sine_lines[0], \"\\\\sin(0.5)\", LEFT),\n",
        "            (sine_lines[1], \"\\\\sin(0.5+dx)\", RIGHT),\n",
        "            (parabola_lines[0], \"(0.5)^2\", LEFT),\n",
        "            (parabola_lines[1], \"(0.5+dx)^2\", RIGHT),\n",
        "        ]\n",
        "        for line, tex, direction in line_tex_direction_triplets:\n",
        "            line.brace = Brace(\n",
        "                line, direction,\n",
        "                buff = SMALL_BUFF,\n",
        "                min_num_quads = 2,\n",
        "            )\n",
        "            line.brace.set_color(line.get_color())\n",
        "            line.brace.add_background_rectangle()\n",
        "            line.brace_text = line.brace.get_text(\"$%s$\"%tex)\n",
        "            line.brace_text.scale(\n",
        "                self.tex_scale_factor,\n",
        "                about_point = line.brace_text.get_edge_center(-direction)\n",
        "            )\n",
        "            line.brace_text.add_background_rectangle()\n",
        "            line.brace_anim = MaintainPositionRelativeTo(\n",
        "                VGroup(line.brace, line.brace_text), line\n",
        "            )\n",
        "\n",
        "        ##Look at example lines\n",
        "        self.play(\n",
        "            example_v_lines.set_stroke, None, 4,\n",
        "            faders.fade,\n",
        "            Animation(self.graph_labels),\n",
        "            Write(label_groups[0]),\n",
        "        )\n",
        "        for line in example_v_lines:\n",
        "            line.save_state()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(sine_lines[0].brace),\n",
        "            Write(sine_lines[0].brace_text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            sine_lines[0].shift, UP+4*LEFT,\n",
        "            sine_lines[0].brace_anim,\n",
        "            parabola_lines[0].move_to, sine_lines[0], DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "        parabola_lines[0].brace_anim.update(1)\n",
        "        self.play(\n",
        "            GrowFromCenter(parabola_lines[0].brace),\n",
        "            Write(parabola_lines[0].brace_text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*it.chain(*[\n",
        "            [line.restore, line.brace_anim]\n",
        "            for line in example_v_lines\n",
        "        ]))\n",
        "\n",
        "        ## Nudged_lines\n",
        "        self.play(\n",
        "            Write(label_groups[1]),\n",
        "            *it.chain(*[\n",
        "                [line.restore, line.set_stroke, None, 4]\n",
        "                for line in nudged_v_lines\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "        for line in nudged_v_lines:\n",
        "            self.play(\n",
        "                GrowFromCenter(line.brace),\n",
        "                Write(line.brace_text)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.sine_lines = sine_lines\n",
        "        self.parabola_lines = parabola_lines\n",
        "\n",
        "    def show_df(self):\n",
        "        sine_lines = self.sine_lines\n",
        "        parabola_lines = self.parabola_lines\n",
        "\n",
        "        df, equals, d_sine, plus, d_x_squared = deriv_mob = OldTex(\n",
        "            \"df\", \"=\", \"d(\\\\sin(x))\", \"+\", \"d(x^2)\"\n",
        "        )\n",
        "        df.set_color(SUM_COLOR)\n",
        "        d_sine.set_color(SINE_COLOR)\n",
        "        d_x_squared.set_color(X_SQUARED_COLOR)\n",
        "        deriv_mob.scale(self.tex_scale_factor)\n",
        "        deriv_mob.next_to(\n",
        "            self.func_mob, DOWN, \n",
        "            buff = MED_LARGE_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        for submob in deriv_mob:\n",
        "            submob.add_to_back(BackgroundRectangle(submob))\n",
        "\n",
        "        df_lines = self.show_difference(parabola_lines, df, equals)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(df_lines))\n",
        "        self.play(\n",
        "            parabola_lines[0].shift,\n",
        "            (parabola_lines[1].get_bottom()[1]-parabola_lines[0].get_bottom()[1])*UP,\n",
        "            parabola_lines[0].brace_anim\n",
        "        )\n",
        "        d_sine_lines = self.show_difference(sine_lines, d_sine, plus)\n",
        "        d_x_squared_lines = self.show_difference(parabola_lines, d_x_squared, VGroup())\n",
        "        self.wait()\n",
        "\n",
        "        self.deriv_mob = deriv_mob\n",
        "        self.d_sine_lines = d_sine_lines\n",
        "        self.d_x_squared_lines = d_x_squared_lines\n",
        "\n",
        "    def show_difference(self, v_lines, target_tex, added_tex):\n",
        "        distance = v_lines[1].get_top()[1]-v_lines[0].get_top()[1]\n",
        "        h_lines = VGroup(*[\n",
        "            DashedLine(ORIGIN, 2*RIGHT, stroke_width = 3)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        h_lines.arrange(DOWN, buff = distance)\n",
        "        h_lines.move_to(v_lines[1].get_top(), UP+RIGHT)\n",
        "\n",
        "        brace = Brace(h_lines, LEFT)\n",
        "        brace_text = target_tex.copy()\n",
        "        brace_text.next_to(brace, LEFT)\n",
        "\n",
        "        self.play(ShowCreation(h_lines))\n",
        "        self.play(GrowFromCenter(brace), Write(brace_text))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(brace_text.copy(), target_tex),\n",
        "            Write(added_tex)\n",
        "        )\n",
        "        return VGroup(h_lines, brace, brace_text)\n",
        "\n",
        "    def expand_derivative(self):\n",
        "        expanded_deriv = OldTex(\n",
        "            \"df\", \"=\", \"\\\\cos(x)\", \"\\\\,dx\", \"+\", \"2x\", \"\\\\,dx\"\n",
        "        )\n",
        "        expanded_deriv.set_color_by_tex(\"df\", SUM_COLOR)\n",
        "        VGroup(*expanded_deriv[2:4]).set_color(SINE_COLOR)\n",
        "        VGroup(*expanded_deriv[5:7]).set_color(X_SQUARED_COLOR)\n",
        "        expanded_deriv.scale(self.tex_scale_factor)\n",
        "        expanded_deriv.next_to(\n",
        "            self.deriv_mob, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        background_rect = BackgroundRectangle(expanded_deriv)\n",
        "\n",
        "        rearranged_deriv = OldTex(\n",
        "            \"{df \\\\over\", \"dx}\", \"=\", \"\\\\cos(x)\", \"+\", \"2x\"\n",
        "        )\n",
        "        rearranged_deriv[0].set_color(SUM_COLOR)\n",
        "        rearranged_deriv[3].set_color(SINE_COLOR)\n",
        "        rearranged_deriv[5].set_color(X_SQUARED_COLOR)\n",
        "        rearranged_deriv.scale(self.tex_scale_factor)\n",
        "        rearranged_deriv.move_to(expanded_deriv, UP+LEFT)\n",
        "        deriv_target_indices = [0, 2, 3, 1, 4, 5, 1]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                background_rect, \n",
        "                rate_func = squish_rate_func(smooth, 0.6, 1)\n",
        "            ),\n",
        "            Write(expanded_deriv)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        tex_group_pairs = [\n",
        "            (\"\\\\cos(0.5)dx\", self.d_sine_lines),\n",
        "            (\"2(0.5)dx\", self.d_x_squared_lines),\n",
        "        ]\n",
        "        def indicate(mob):\n",
        "            self.play(\n",
        "                mob.set_color, YELLOW,\n",
        "                mob.scale, 1.2,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "        for tex, group in tex_group_pairs:\n",
        "            old_label = group[-1]\n",
        "            new_label = OldTex(tex)\n",
        "            pre_dx = VGroup(*new_label[:-2])\n",
        "            dx = VGroup(*new_label[-2:])\n",
        "            new_label.add_background_rectangle()\n",
        "            new_label.scale(self.tex_scale_factor)\n",
        "            new_label.move_to(old_label, RIGHT)\n",
        "            new_label.set_color(old_label.get_color())\n",
        "\n",
        "            self.play(FocusOn(old_label))\n",
        "            indicate(old_label)\n",
        "            self.wait()\n",
        "            self.play(FadeOut(old_label))\n",
        "            self.play(FadeIn(new_label))\n",
        "            self.wait()\n",
        "            indicate(dx)\n",
        "            self.wait()\n",
        "            indicate(pre_dx)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                expanded_deriv[i], rearranged_deriv[j],\n",
        "                path_arc = -np.pi/2\n",
        "            )\n",
        "            for i, j in enumerate(deriv_target_indices)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class DiscussProducts(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        wrong_product_rule = OldTex(\n",
        "            \"\\\\frac{d(\\\\sin(x)x^2)}{dx}\", \n",
        "            \"\\\\ne\",\n",
        "            \"\\\\left(\\\\frac{d(\\\\sin(x))}{dx}\\\\right)\",\n",
        "            \"\\\\left(\\\\frac{d(x^2)}{dx}\\\\right)\",\n",
        "        )\n",
        "        not_equals = wrong_product_rule[1]\n",
        "        wrong_product_rule[2].set_color(SINE_COLOR)\n",
        "        wrong_product_rule[3].set_color(X_SQUARED_COLOR)\n",
        "        wrong_product_rule.next_to(\n",
        "            self.get_teacher().get_corner(UP+LEFT),\n",
        "            UP,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        ).shift_onto_screen()\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"Products are a bit different\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            self.get_teacher(), \n",
        "            target_mode = \"raise_right_hand\"\n",
        "        ))\n",
        "        self.play(Write(wrong_product_rule))\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"confused\", \"erm\",\n",
        "            added_anims = [\n",
        "                not_equals.scale, 1.3,\n",
        "                not_equals.set_color, RED\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Think about the \\\\\\\\ underlying meaning\",\n",
        "            bubble_config = {\"height\" : 3},\n",
        "            added_anims = [\n",
        "                wrong_product_rule.scale, 0.7,\n",
        "                wrong_product_rule.to_corner, UP+LEFT\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class NotGraphsForProducts(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"y_max\" : 25,\n",
        "        \"x_max\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        sine_graph = self.get_graph(np.sin, color = SINE_COLOR)\n",
        "        sine_graph.label = self.get_graph_label(\n",
        "            sine_graph, \"\\\\sin(x)\",\n",
        "            x_val = 3*np.pi/2,\n",
        "            direction = DOWN\n",
        "        )\n",
        "        parabola = self.get_graph(\n",
        "            lambda x : x**2, color = X_SQUARED_COLOR\n",
        "        )\n",
        "        parabola.label = self.get_graph_label(\n",
        "            parabola, \"x^2\",\n",
        "            x_val = 2.5,\n",
        "            direction = UP+LEFT,\n",
        "        )\n",
        "        product_graph = self.get_graph(\n",
        "            lambda x : np.sin(x)*(x**2), color = PRODUCT_COLOR\n",
        "        )\n",
        "        product_graph.label = self.get_graph_label(\n",
        "            product_graph, \"\\\\sin(x)x^2\",\n",
        "            x_val = 2.8,\n",
        "            direction = UP+RIGHT,\n",
        "            buff = 0\n",
        "        )\n",
        "\n",
        "        graphs = [sine_graph, parabola, product_graph]\n",
        "        for graph in graphs:\n",
        "            self.play(\n",
        "                ShowCreation(graph),\n",
        "                Write(graph.label, run_time = 2)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        everything = VGroup(*[m for m in self.get_mobjects() if not m.is_subpath])\n",
        "        words = OldTexText(\"Not the best visualization\")\n",
        "        words.scale(1.5)\n",
        "        words.shift(FRAME_Y_RADIUS*UP/2)\n",
        "        words.add_background_rectangle()\n",
        "        words.set_color(RED)\n",
        "        self.play(\n",
        "            everything.fade,\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ConfusedMorty(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        self.add(morty)\n",
        "        self.wait()\n",
        "        self.play(morty.change_mode, \"confused\")\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceProductAsArea(ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"top_func\" : np.sin,\n",
        "        \"top_func_label\" : \"\\\\sin(x)\",\n",
        "        \"top_func_nudge_label\" : \"d(\\\\sin(x))\",\n",
        "        \"top_func_derivative\" : \"\\\\cos(x)\",\n",
        "        \"side_func\" : lambda x : x**2,\n",
        "        \"side_func_label\" : \"x^2\",\n",
        "        \"side_func_nudge_label\" : \"d(x^2)\",\n",
        "        \"side_func_derivative\" : \"2x\",\n",
        "        \"x_unit_to_space_unit\" : 3,\n",
        "        \"box_kwargs\" : {\n",
        "            \"fill_color\" : YELLOW,\n",
        "            \"fill_opacity\" : 0.75,\n",
        "            \"stroke_width\" : 1,\n",
        "        },\n",
        "        \"df_box_kwargs\" : {\n",
        "            \"fill_color\" : GREEN,\n",
        "            \"fill_opacity\" : 0.75,\n",
        "            \"stroke_width\" : 0,\n",
        "        },\n",
        "        \"box_corner_location\" : 6*LEFT+2.5*UP,\n",
        "        \"slider_center\" : 3.5*RIGHT+2*DOWN,\n",
        "        \"slider_width\" : 6,\n",
        "        \"slider_x_max\" : 3,\n",
        "        \"x_slider_handle_height\" : 0.25,\n",
        "        \"slider_handle_color\" : BLUE,\n",
        "        \"default_x\" : .75,\n",
        "        \"dx\" : 0.1,\n",
        "        \"tiny_dx\" : 0.01,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_box()\n",
        "        self.talk_though_sine()\n",
        "        self.define_f_of_x()\n",
        "        self.nudge_x()\n",
        "        self.write_df()\n",
        "        self.show_thinner_dx()\n",
        "        self.expand_derivative()\n",
        "        self.write_derivative_abstractly()\n",
        "        self.write_mneumonic()\n",
        "\n",
        "    def introduce_box(self):\n",
        "        box, labels = self.box_label_group = self.get_box_label_group(self.default_x)\n",
        "        self.x_slider = self.get_x_slider(self.default_x)\n",
        "\n",
        "        self.play(Write(labels))\n",
        "        self.play(DrawBorderThenFill(box))\n",
        "        self.wait()\n",
        "        for mob in self.x_slider:\n",
        "            self.play(Write(mob, run_time = 1))\n",
        "        self.wait()\n",
        "        for new_x in 0.5, 2, self.default_x:\n",
        "            self.animate_x_change(\n",
        "                new_x, run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def talk_though_sine(self):\n",
        "        x_axis = self.x_slider[0]\n",
        "        graph = FunctionGraph(\n",
        "            np.sin, x_min = 0, x_max = np.pi,\n",
        "            color = SINE_COLOR\n",
        "        )\n",
        "        scale_factor = self.x_slider.get_width()/self.slider_x_max\n",
        "        graph.scale(scale_factor)\n",
        "        graph.move_to(x_axis.number_to_point(0), DOWN+LEFT)\n",
        "\n",
        "        label = OldTex(\"\\\\sin(x)\")\n",
        "        label.set_color(SINE_COLOR)\n",
        "        label.next_to(graph, UP)\n",
        "\n",
        "        y_axis = x_axis.copy()\n",
        "        y_axis.remove(*y_axis.numbers)\n",
        "\n",
        "        v_line = Line(ORIGIN, UP, color = WHITE, stroke_width = 2)\n",
        "        def v_line_update(v_line):\n",
        "            x = x_axis.point_to_number(self.x_slider[1].get_top())\n",
        "            v_line.set_height(np.sin(x)*scale_factor)\n",
        "            v_line.move_to(x_axis.number_to_point(x), DOWN)\n",
        "        v_line_update(v_line)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(y_axis, np.pi/2, about_point = y_axis.get_left()),\n",
        "            Animation(x_axis)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(label, run_time = 1)\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        for x, rt in zip([0.25, np.pi/2, 3, self.default_x], [2, 4, 4, 2]):\n",
        "            self.animate_x_change(\n",
        "                x, run_time = rt, \n",
        "                added_anims = [\n",
        "                    UpdateFromFunc(v_line, v_line_update)\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeOut, [y_axis, graph, label, v_line])),\n",
        "            [Animation(x_axis)]\n",
        "        ))\n",
        "        self.wait()\n",
        "        for x in 1, 0.5, self.default_x:\n",
        "            self.animate_x_change(x)\n",
        "        self.wait()\n",
        "\n",
        "    def define_f_of_x(self):\n",
        "        f_def = OldTex(\n",
        "            \"f(x)\", \"=\",\n",
        "            self.top_func_label,\n",
        "            self.side_func_label,\n",
        "            \"=\", \n",
        "            \"\\\\text{Area}\"\n",
        "        )\n",
        "        f_def.to_corner(UP+RIGHT)\n",
        "        f_def[-1].set_color(self.box_kwargs[\"fill_color\"])\n",
        "\n",
        "        box, labels = self.box_label_group\n",
        "\n",
        "        self.play(Write(VGroup(*f_def[:-1])))\n",
        "        self.play(Transform(\n",
        "            box.copy().set_fill(opacity = 0), f_def[-1],\n",
        "            run_time = 1.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.f_def = f_def\n",
        "\n",
        "    def nudge_x(self):\n",
        "        box, labels = self.box_label_group\n",
        "        nudge_label_group = self.get_nudge_label_group()\n",
        "        original_dx = self.dx\n",
        "        self.dx = self.tiny_dx\n",
        "        thin_df_boxes = self.get_df_boxes()\n",
        "        self.dx = original_dx\n",
        "        df_boxes = self.get_df_boxes()\n",
        "        right_box, corner_box, right_box = df_boxes\n",
        "\n",
        "        self.play(FocusOn(nudge_label_group))\n",
        "        self.play(*list(map(GrowFromCenter, nudge_label_group)))\n",
        "        self.animate_x_change(\n",
        "            self.default_x+self.dx,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2,\n",
        "            added_anims = [Animation(nudge_label_group)]\n",
        "        ) \n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(thin_df_boxes, df_boxes),\n",
        "            VGroup(*labels[1]).shift, right_box.get_width()*RIGHT,\n",
        "        )\n",
        "        self.play(\n",
        "            df_boxes.space_out_submobjects, 1.1,\n",
        "            df_boxes.move_to, box, UP+LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.df_boxes = df_boxes\n",
        "        self.df_box_labels = self.get_df_box_labels(df_boxes)\n",
        "        self.x_slider.add(nudge_label_group)\n",
        "\n",
        "    def get_nudge_label_group(self):\n",
        "        line, triangle, x_mob = self.x_slider\n",
        "        dx_line = Line(*[\n",
        "            line.number_to_point(self.x_slider.x_val + num)\n",
        "            for num in (0, self.dx,)\n",
        "        ])\n",
        "        dx_line.set_stroke(\n",
        "            self.df_box_kwargs[\"fill_color\"], \n",
        "            width = 6\n",
        "        )\n",
        "        brace = Brace(dx_line, UP, buff = SMALL_BUFF)\n",
        "        brace.stretch_to_fit_height(0.2)\n",
        "        brace.next_to(dx_line, UP, buff = SMALL_BUFF)\n",
        "        brace.set_stroke(width = 1)\n",
        "        dx = OldTex(\"dx\")\n",
        "        dx.scale(0.7)\n",
        "        dx.next_to(brace, UP, buff = SMALL_BUFF)\n",
        "        dx.set_color(dx_line.get_color())\n",
        "\n",
        "        return VGroup(dx_line, brace, dx)\n",
        "\n",
        "    def get_df_boxes(self):\n",
        "        box, labels = self.box_label_group\n",
        "        alt_box = self.get_box(self.x_slider.x_val + self.dx)\n",
        "\n",
        "        h, w = box.get_height(), box.get_width()\n",
        "        dh, dw = alt_box.get_height()-h, alt_box.get_width()-w\n",
        "        heights_and_widths = [(dh, w), (dh, dw), (h, dw)]\n",
        "        vects = [DOWN, DOWN+RIGHT, RIGHT]\n",
        "        df_boxes = VGroup(*[\n",
        "            Rectangle(\n",
        "                height = height, width = width, **self.df_box_kwargs\n",
        "            ).next_to(box, vect, buff = 0)\n",
        "            for (height, width), vect in zip(\n",
        "                heights_and_widths, vects\n",
        "            )\n",
        "        ])\n",
        "        return df_boxes\n",
        "\n",
        "    def get_df_box_labels(self, df_boxes):\n",
        "        bottom_box, corner_box, right_box = df_boxes\n",
        "        result = VGroup()\n",
        "        quads = [\n",
        "            (right_box, UP, self.top_func_nudge_label, LEFT),\n",
        "            (corner_box, RIGHT, self.side_func_nudge_label, ORIGIN),\n",
        "        ]\n",
        "        for box, vect, label_tex, aligned_edge in quads:\n",
        "            brace = Brace(box, vect)\n",
        "            label = OldTex(label_tex)\n",
        "            label.next_to(\n",
        "                brace, vect,\n",
        "                aligned_edge = aligned_edge,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            label.set_color(df_boxes[0].get_color())\n",
        "            result.add(VGroup(brace, label))\n",
        "        return result\n",
        "\n",
        "    def write_df(self):\n",
        "        deriv = OldTex(\n",
        "            \"df\", \"=\", \n",
        "            self.top_func_label, \n",
        "            self.side_func_nudge_label,\n",
        "            \"+\",\n",
        "            self.side_func_label,\n",
        "            self.top_func_nudge_label,\n",
        "        )\n",
        "        deriv.scale(0.9)\n",
        "        deriv.next_to(self.f_def, DOWN, buff = LARGE_BUFF)\n",
        "        deriv.to_edge(RIGHT)\n",
        "        for submob, tex in zip(deriv, deriv.expression_parts):\n",
        "            if tex.startswith(\"d\"):\n",
        "                submob.set_color(self.df_box_kwargs[\"fill_color\"])\n",
        "        bottom_box_area = VGroup(*deriv[2:4])\n",
        "        right_box_area = VGroup(*deriv[5:7])\n",
        "\n",
        "        bottom_box, corner_box, right_box = self.df_boxes\n",
        "        plus = OldTex(\"+\").set_fill(opacity = 0)\n",
        "        df_boxes_copy = VGroup(\n",
        "            bottom_box.copy(),\n",
        "            plus,\n",
        "            right_box.copy(),\n",
        "            plus.copy(),\n",
        "            corner_box.copy(),\n",
        "        )\n",
        "\n",
        "        self.deriv = deriv\n",
        "        self.df_boxes_copy = df_boxes_copy\n",
        "        box, labels = self.box_label_group\n",
        "        self.full_box_parts = VGroup(*it.chain(\n",
        "            [box], self.df_boxes, labels, self.df_box_labels\n",
        "        ))\n",
        "\n",
        "        self.play(Write(VGroup(*deriv[:2])))\n",
        "        self.play(\n",
        "            df_boxes_copy.arrange,\n",
        "            df_boxes_copy.set_fill, None, self.df_box_kwargs[\"fill_opacity\"],\n",
        "            df_boxes_copy.next_to, deriv[1]\n",
        "        )\n",
        "        deriv.submobjects[4] = df_boxes_copy[1]\n",
        "        self.wait()\n",
        "\n",
        "        self.set_color_right_boxes()\n",
        "        self.set_color_bottom_boxes()\n",
        "        self.describe_bottom_box(bottom_box_area)\n",
        "        self.describe_right_box(right_box_area)\n",
        "        self.ignore_corner()\n",
        "\n",
        "        # self.add(deriv)\n",
        "\n",
        "    def set_color_boxes_and_label(self, boxes, label):\n",
        "        boxes.save_state()\n",
        "        label.save_state()\n",
        "\n",
        "        self.play(GrowFromCenter(label))\n",
        "        self.play(\n",
        "            boxes.set_color, RED,\n",
        "            label.set_color, RED,\n",
        "        )\n",
        "        self.play(\n",
        "            label[1].scale, 1.1,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(boxes.restore, label.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def set_color_right_boxes(self):\n",
        "        self.set_color_boxes_and_label(\n",
        "            VGroup(*self.df_boxes[1:]),\n",
        "            self.df_box_labels[0]\n",
        "        )\n",
        "\n",
        "    def set_color_bottom_boxes(self):\n",
        "        self.set_color_boxes_and_label(\n",
        "            VGroup(*self.df_boxes[:-1]),\n",
        "            self.df_box_labels[1]\n",
        "        )\n",
        "\n",
        "    def describe_bottom_box(self, bottom_box_area):\n",
        "        bottom_box = self.df_boxes[0]\n",
        "        bottom_box_copy = self.df_boxes_copy[0]\n",
        "        other_box_copies = VGroup(*self.df_boxes_copy[1:])\n",
        "        top_label = self.box_label_group[1][0]\n",
        "        right_label = self.df_box_labels[1]\n",
        "\n",
        "        faders = VGroup(*[m for m in self.full_box_parts if m not in [bottom_box, top_label, right_label]])\n",
        "        faders.save_state()\n",
        "\n",
        "        self.play(faders.fade, 0.8)\n",
        "        self.wait()\n",
        "        self.play(FocusOn(bottom_box_copy))\n",
        "        self.play(\n",
        "            ReplacementTransform(bottom_box_copy, bottom_box_area),\n",
        "            other_box_copies.next_to, bottom_box_area, RIGHT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(faders.restore)\n",
        "\n",
        "    def describe_right_box(self, right_box_area):\n",
        "        right_box = self.df_boxes[2]\n",
        "        right_box_copy = self.df_boxes_copy[2]\n",
        "        right_box_area.next_to(self.df_boxes_copy[1])\n",
        "        other_box_copies = VGroup(*self.df_boxes_copy[3:])\n",
        "        top_label = self.df_box_labels[0]\n",
        "        right_label = self.box_label_group[1][1]\n",
        "\n",
        "        faders = VGroup(*[m for m in self.full_box_parts if m not in [right_box, top_label, right_label]])\n",
        "        faders.save_state()\n",
        "\n",
        "        self.play(faders.fade, 0.8)\n",
        "        self.wait()\n",
        "        self.play(FocusOn(right_box_copy))\n",
        "        self.play(\n",
        "            ReplacementTransform(right_box_copy, right_box_area),                        \n",
        "            other_box_copies.next_to, right_box_area, DOWN, \n",
        "            MED_SMALL_BUFF, RIGHT,\n",
        "\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(faders.restore)\n",
        "\n",
        "    def ignore_corner(self):\n",
        "        corner = self.df_boxes[1]\n",
        "        corner.save_state()\n",
        "        corner_copy = VGroup(*self.df_boxes_copy[-2:])\n",
        "        words = OldTexText(\"Ignore\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(corner_copy, LEFT, buff = LARGE_BUFF)\n",
        "        words.shift(MED_SMALL_BUFF*DOWN)\n",
        "        arrow = Arrow(words, corner_copy, buff = SMALL_BUFF, color = RED)\n",
        "\n",
        "        self.play(\n",
        "            corner.set_color, RED,\n",
        "            corner_copy.set_color, RED,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(words), ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [words, arrow, corner_copy])))\n",
        "        self.wait()\n",
        "        corner_copy.set_color(BLACK)\n",
        "\n",
        "    def show_thinner_dx(self):\n",
        "        self.transition_to_alt_config(dx = self.tiny_dx)\n",
        "\n",
        "    def expand_derivative(self):\n",
        "        # self.play(\n",
        "        #     self.deriv.next_to, self.f_def, DOWN, MED_LARGE_BUFF,\n",
        "        #     self.deriv.shift_onto_screen\n",
        "        # )\n",
        "        # self.wait()\n",
        "\n",
        "        expanded_deriv = OldTex(\n",
        "            \"df\", \"=\", \n",
        "            self.top_func_label, \n",
        "            self.side_func_derivative,\n",
        "            \"\\\\,dx\",\n",
        "            \"+\", \n",
        "            self.side_func_label,\n",
        "            self.top_func_derivative, \n",
        "            \"\\\\,dx\"\n",
        "        )\n",
        "        final_deriv = OldTex(\n",
        "            \"{df \\\\over \", \"dx}\", \"=\", \n",
        "            self.top_func_label, \n",
        "            self.side_func_derivative,\n",
        "            \"+\", \n",
        "            self.side_func_label,\n",
        "            self.top_func_derivative, \n",
        "        )\n",
        "        color = self.deriv[0].get_color()\n",
        "        for new_deriv in expanded_deriv, final_deriv:        \n",
        "            for submob, tex in zip(new_deriv, new_deriv.expression_parts):\n",
        "                for substr in \"df\", \"dx\", self.top_func_derivative, self.side_func_derivative:\n",
        "                    if substr in tex:\n",
        "                        submob.set_color(color)\n",
        "            new_deriv.scale(0.9)\n",
        "            new_deriv.next_to(self.deriv, DOWN, buff = MED_LARGE_BUFF)\n",
        "            new_deriv.shift_onto_screen()\n",
        "\n",
        "        def indicate(mob):\n",
        "            self.play(\n",
        "                mob.scale, 1.2,\n",
        "                mob.set_color, YELLOW,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "\n",
        "\n",
        "        for index in 6, 3:\n",
        "            self.deriv.submobjects.insert(\n",
        "                index+1, self.deriv[index].copy()\n",
        "            )\n",
        "        non_deriv_indices = list(range(len(expanded_deriv)))\n",
        "        for indices in [(3, 4), (7, 8)]:\n",
        "            top_part = VGroup()\n",
        "            bottom_part = VGroup()            \n",
        "            for i in indices:\n",
        "                non_deriv_indices.remove(i)\n",
        "                top_part.add(self.deriv[i].copy())\n",
        "                bottom_part.add(expanded_deriv[i])\n",
        "            self.play(top_part.move_to, bottom_part)\n",
        "            self.wait()\n",
        "            indicate(top_part)\n",
        "            self.wait()\n",
        "            self.play(ReplacementTransform(top_part, bottom_part))\n",
        "            self.wait()\n",
        "        top_part = VGroup()\n",
        "        bottom_part = VGroup()\n",
        "        for i in non_deriv_indices:\n",
        "            top_part.add(self.deriv[i].copy())\n",
        "            bottom_part.add(expanded_deriv[i])\n",
        "        self.play(ReplacementTransform(\n",
        "            top_part, bottom_part\n",
        "        ))\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                expanded_deriv[i], final_deriv[j],\n",
        "                path_arc = -np.pi/2\n",
        "            )\n",
        "            for i, j in [\n",
        "                (0, 0),\n",
        "                (1, 2),\n",
        "                (2, 3),\n",
        "                (3, 4),\n",
        "                (4, 1),\n",
        "                (5, 5),\n",
        "                (6, 6),\n",
        "                (7, 7),\n",
        "                (8, 1),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "        for index in 0, 1, 3, 4, 6, 7:\n",
        "            indicate(final_deriv[index])\n",
        "        self.wait()\n",
        "\n",
        "    def write_derivative_abstractly(self):\n",
        "        self.transition_to_alt_config(\n",
        "            return_to_original_configuration = False,\n",
        "            top_func_label = \"g(x)\",\n",
        "            top_func_nudge_label = \"dg\",\n",
        "            top_func_derivative = \"\\\\frac{dg}{dx}\",\n",
        "            side_func_label = \"h(x)\",\n",
        "            side_func_nudge_label = \"dh\",\n",
        "            side_func_derivative = \"\\\\frac{dh}{dx}\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_mneumonic(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_edge(DOWN)\n",
        "        morty.shift(2*LEFT)\n",
        "        words = OldTexText(\n",
        "            \"``Left \", \"d(Right) \", \"+\", \" Right \", \"d(Left)\", \"''\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        VGroup(words[1], words[4]).set_color(self.df_boxes[0].get_color())\n",
        "        words.scale(0.7)\n",
        "        words.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ###############\n",
        "\n",
        "    def animate_x_change(\n",
        "        self, target_x, \n",
        "        box_label_group = None, \n",
        "        x_slider = None,\n",
        "        **kwargs\n",
        "        ):\n",
        "        box_label_group = box_label_group or self.box_label_group\n",
        "        x_slider = x_slider or self.x_slider\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "\n",
        "        start_x = x_slider.x_val\n",
        "        def update_box_label_group(box_label_group, alpha):\n",
        "            new_x = interpolate(start_x, target_x, alpha)\n",
        "            new_box_label_group = self.get_box_label_group(new_x)\n",
        "            Transform(box_label_group, new_box_label_group).update(1)\n",
        "        \n",
        "        def update_x_slider(x_slider, alpha):\n",
        "            new_x = interpolate(start_x, target_x, alpha)\n",
        "            new_x_slider = self.get_x_slider(new_x)\n",
        "            Transform(x_slider, new_x_slider).update(1)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                box_label_group, \n",
        "                update_box_label_group\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                x_slider, \n",
        "                update_x_slider\n",
        "            ),\n",
        "            *added_anims,\n",
        "            **kwargs\n",
        "        )\n",
        "        x_slider.x_val = target_x\n",
        "\n",
        "    def get_x_slider(self, x):\n",
        "        numbers = list(range(int(self.slider_x_max) + 1))\n",
        "        line = NumberLine(\n",
        "            x_min = 0,\n",
        "            x_max = self.slider_x_max,\n",
        "            unit_size = float(self.slider_width)/self.slider_x_max,\n",
        "            color = GREY,\n",
        "            big_tick_numbers = numbers,\n",
        "            tick_frequency = 0.25,\n",
        "        )\n",
        "        line.add_numbers(*numbers)\n",
        "        line.numbers.next_to(line, UP, buff = SMALL_BUFF)\n",
        "        for number in line.numbers:\n",
        "            number.add_background_rectangle()\n",
        "        line.move_to(self.slider_center)\n",
        "\n",
        "        triangle = RegularPolygon(\n",
        "            3, start_angle = np.pi/2,\n",
        "            fill_color = self.slider_handle_color,\n",
        "            fill_opacity = 0.8,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        triangle.set_height(self.x_slider_handle_height)\n",
        "        triangle.move_to(line.number_to_point(x), UP)\n",
        "\n",
        "        x_mob = OldTex(\"x\")\n",
        "        x_mob.next_to(triangle, DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        result = VGroup(line, triangle, x_mob)\n",
        "        result.x_val = x\n",
        "        return result\n",
        "\n",
        "    def get_box_label_group(self, x):\n",
        "        box = self.get_box(x)\n",
        "        labels = self.get_box_labels(box)\n",
        "        return VGroup(box, labels)\n",
        "\n",
        "    def get_box(self, x):\n",
        "        box = Rectangle(\n",
        "            width = self.x_unit_to_space_unit * self.top_func(x),\n",
        "            height = self.x_unit_to_space_unit * self.side_func(x),\n",
        "            **self.box_kwargs\n",
        "        )\n",
        "        box.move_to(self.box_corner_location, UP+LEFT)\n",
        "        return box\n",
        "\n",
        "    def get_box_labels(self, box):\n",
        "        result = VGroup()\n",
        "        for label_tex, vect in (self.top_func_label, UP), (self.side_func_label, RIGHT):\n",
        "            brace = Brace(box, vect, min_num_quads = 5)\n",
        "            label = OldTex(label_tex)\n",
        "            label.next_to(brace, vect, buff = SMALL_BUFF)\n",
        "            result.add(VGroup(brace, label))\n",
        "        return result\n",
        "\n",
        "class WriteDXSquared(Scene):\n",
        "    def construct(self):\n",
        "        term = OldTex(\"(...)(dx)^2\")\n",
        "        term.set_color(RED)\n",
        "        self.play(Write(term))\n",
        "        self.wait()\n",
        "\n",
        "class MneumonicExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        d, left, right, rp = deriv_q = OldTex(\n",
        "            \"\\\\frac{d}{dx}(\", \"\\\\sin(x)\", \"x^2\", \")\"\n",
        "        )\n",
        "        deriv_q.to_edge(UP)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Left \", \"d(Right) \", \"+\", \" Right \", \"d(Left)\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        deriv = OldTex(\"\\\\sin(x)\", \"2x\", \"+\", \"x^2\", \"\\\\cos(x)\")\n",
        "        for mob in words, deriv:\n",
        "            VGroup(mob[1], mob[4]).set_color(GREEN)\n",
        "            mob.next_to(deriv_q, DOWN, buff = MED_LARGE_BUFF)\n",
        "        deriv.shift(words[2].get_center()-deriv[2].get_center())\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            Write(deriv_q),\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "\n",
        "        left_words = VGroup(*words[:2])\n",
        "        left_terms = VGroup(*deriv[:2])\n",
        "        self.play(\n",
        "            left_words.next_to, left_terms, DOWN,\n",
        "            MED_LARGE_BUFF, RIGHT\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            left_words.copy(), left_terms\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Indicate, [left, left_words[0], left_terms[0]])))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Indicate, [right, left_words[1], left_terms[1]])))\n",
        "        self.wait()\n",
        "\n",
        "        right_words = VGroup(*words[2:])\n",
        "        right_terms = VGroup(*deriv[2:])\n",
        "        self.play(\n",
        "            right_words.next_to, right_terms, DOWN,\n",
        "            MED_LARGE_BUFF, LEFT\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            right_words.copy(), right_terms\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Indicate, [right, right_words[1], right_terms[1]])))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Indicate, [left, right_words[2], right_terms[2]])))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(self.get_teacher().change_mode, \"shruggie\")\n",
        "        self.wait()\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ConstantMultiplication(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\"What about $\\\\dfrac{d}{dx}(2\\\\sin(x))$?\")\n",
        "        answer = OldTexText(\"2\\\\cos(x)\")\n",
        "        self.teacher_says(question)\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            answer, target_mode = \"hooray\",\n",
        "            added_anims = [question.copy().to_edge, UP]\n",
        "        )\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.play_student_changes(\"pondering\", \"hooray\", \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class ConstantMultiplicationFigure(IntroduceProductAsArea):\n",
        "    CONFIG = {\n",
        "        \"side_func\" : lambda x : 1,\n",
        "        \"side_func_label\" : \"\\\\text{Constant}\",\n",
        "        \"side_func_nudge_label\" : \"\",\n",
        "        \"side_func_derivative\" : \"\",\n",
        "        \"x_unit_to_space_unit\" : 3,\n",
        "        \"default_x\" : 0.5,\n",
        "        \"dx\" : 0.1\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.box_label_group = self.get_box_label_group(self.default_x)\n",
        "        self.x_slider = self.get_x_slider(self.default_x)\n",
        "        # df_boxes = self.get_df_boxes()\n",
        "        # df_box_labels = self.get_df_box_labels(df_boxes)\n",
        "\n",
        "        self.add(self.box_label_group, self.x_slider)\n",
        "        self.nudge_x()\n",
        "\n",
        "class ShoveXSquaredInSine(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Function composition\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        sine = OldTex(\"g(\", \"x\", \")\", \"=\", \"\\\\sin(\", \"x\", \")\")\n",
        "        sine.set_color(SINE_COLOR)\n",
        "        x_squared = OldTex(\"h(x)\", \"=\", \"x^2\")\n",
        "        x_squared.set_color(X_SQUARED_COLOR)\n",
        "        group = VGroup(sine, x_squared)\n",
        "        group.arrange(buff = LARGE_BUFF)\n",
        "        group.shift(UP)\n",
        "        composition = OldTex(\n",
        "            \"g(\", \"h(x)\", \")\", \"=\", \"\\\\sin(\", \"x^2\", \")\"\n",
        "        )\n",
        "        for i in 0, 2, 4, 6:\n",
        "            composition[i].set_color(SINE_COLOR)\n",
        "        for i in 1, 5:\n",
        "            composition[i].set_color(X_SQUARED_COLOR)\n",
        "        composition.next_to(group, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        brace = Brace(VGroup(*composition[-3:]), DOWN)\n",
        "        deriv_q = brace.get_text(\"Derivative?\")\n",
        "\n",
        "        self.add(group)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        triplets = [\n",
        "            [sine, (0, 2), (0, 2)],\n",
        "            [x_squared, (0,), (1,)],\n",
        "            [sine, (3, 4, 6), (3, 4, 6)],\n",
        "            [x_squared, (2,), (5,)]\n",
        "        ]\n",
        "        for premob, pre_indices, comp_indicies in triplets:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    premob[i].copy(), composition[j]\n",
        "                )\n",
        "                for i, j in zip(pre_indices, comp_indicies)\n",
        "            ])\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(deriv_q)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ThreeLinesChainRule(ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 0.5,\n",
        "        \"max_x\" : 1,\n",
        "        \"min_x\" : 0,\n",
        "        \"top_x\" : 3,\n",
        "        \"example_x\" : 1.5,\n",
        "        \"dx\" : 0.1,\n",
        "        \"line_configs\" : [\n",
        "            {\n",
        "                \"func\" : lambda x : x,\n",
        "                \"func_label\" : \"x\",\n",
        "                \"triangle_color\" : WHITE,\n",
        "                \"center_y\" : 3,\n",
        "                \"x_min\" : 0,\n",
        "                \"x_max\" : 3,\n",
        "                \"numbers_to_show\" : list(range(4)),\n",
        "                \"big_tick_numbers\" : list(range(4)),\n",
        "                \"tick_frequency\" : 0.25,\n",
        "            },\n",
        "            {\n",
        "                \"func\" : lambda x : x**2,\n",
        "                \"func_label\" : \"x^2\",\n",
        "                \"triangle_color\" : X_SQUARED_COLOR,\n",
        "                \"center_y\" : 0.5,\n",
        "                \"x_min\" : 0,\n",
        "                \"x_max\" : 10,\n",
        "                \"numbers_to_show\" : list(range(0, 11)),\n",
        "                \"big_tick_numbers\" : list(range(0, 11, 1)),\n",
        "                \"tick_frequency\" : 0.25,\n",
        "            },\n",
        "            {\n",
        "                \"func\" : lambda x : np.sin(x**2),\n",
        "                \"func_label\" : \"\\\\sin(x^2)\",\n",
        "                \"triangle_color\" : SINE_COLOR,\n",
        "                \"center_y\" : -2,\n",
        "                \"x_min\" : -2,\n",
        "                \"x_max\" : 2,\n",
        "                \"numbers_to_show\" : list(range(-2, 3)),\n",
        "                \"big_tick_numbers\" : list(range(-2, 3)),\n",
        "                \"tick_frequency\" : 0.25,\n",
        "            },\n",
        "        ],\n",
        "        \"line_width\" : 8,\n",
        "        \"triangle_height\" : 0.25,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_line_group()\n",
        "        self.draw_function_arrows()\n",
        "        self.talk_through_movement()\n",
        "        self.nudge_x()\n",
        "        self.give_example_of_meaning()\n",
        "\n",
        "    def introduce_line_group(self):\n",
        "        self.line_group = self.get_line_group(self.start_x)\n",
        "        lines, labels = self.line_group\n",
        "\n",
        "        for line in lines:\n",
        "            self.play(Write(line, run_time = 2))\n",
        "        self.wait()\n",
        "        last_label = labels[0].copy()\n",
        "        last_label.to_corner(UP+LEFT)\n",
        "        last_label.set_fill(opacity = 0)\n",
        "        for label in labels:\n",
        "            self.play(ReplacementTransform(\n",
        "                last_label.copy(), label\n",
        "            ))\n",
        "            self.wait()\n",
        "            last_label = label\n",
        "        for x in self.max_x, self.min_x, self.start_x:\n",
        "            self.animate_x_change(x, run_time = 1)\n",
        "        self.wait()\n",
        "\n",
        "    def draw_function_arrows(self):\n",
        "        lines, line_labels = self.line_group\n",
        "        labels = VGroup(*[\n",
        "            OldTex(\"(\\\\dots)^2\").set_color(X_SQUARED_COLOR), \n",
        "            OldTex(\"\\\\sin(\\\\dots)\").set_color(SINE_COLOR)\n",
        "        ])\n",
        "        arrows = VGroup()\n",
        "        for lines_subset, label in zip([lines[:2], lines[1:]], labels):\n",
        "            arrow = Arc(start_angle = np.pi/3, angle = -2*np.pi/3)\n",
        "            arrow.add_tip()\n",
        "            arrow.set_color(label.get_color())\n",
        "            arrow.next_to(VGroup(*lines_subset))\n",
        "            arrows.add(arrow)\n",
        "            label.next_to(arrow, RIGHT)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                Write(label)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.arrows = arrows\n",
        "        self.arrow_labels = labels\n",
        "\n",
        "    def talk_through_movement(self):\n",
        "        lines, labels = self.line_group\n",
        "\n",
        "        self.animate_x_change(self.top_x, run_time = 4)\n",
        "        self.wait()\n",
        "        for label in labels[0], labels[1]:\n",
        "            oval = Circle(color = YELLOW)\n",
        "            oval.replace(label, stretch = True)\n",
        "            oval.scale(2.5)\n",
        "            oval.move_to(label.get_bottom())\n",
        "            self.play(ShowCreation(oval))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(oval))\n",
        "        sine_text = OldTex(\"\\\\sin(9) \\\\approx 0.412\")\n",
        "        sine_text.move_to(labels[-1][-1])\n",
        "        sine_text.to_edge(DOWN)\n",
        "        sine_arrow = Arrow(\n",
        "            sine_text.get_top(),\n",
        "            labels[-1][0].get_bottom(),\n",
        "            buff = SMALL_BUFF,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(sine_text),\n",
        "            ShowCreation(sine_arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [sine_text, sine_arrow])))\n",
        "        self.animate_x_change(self.example_x, run_time = 3)\n",
        "\n",
        "    def nudge_x(self):\n",
        "        lines, labels = self.line_group\n",
        "        def get_value_points():\n",
        "            return [\n",
        "                label[0].get_bottom()\n",
        "                for label in labels\n",
        "            ]\n",
        "        starts = get_value_points()\n",
        "        self.animate_x_change(self.example_x + self.dx, run_time = 0)\n",
        "        ends = get_value_points()\n",
        "        self.animate_x_change(self.example_x, run_time = 0)\n",
        "\n",
        "        nudge_lines = VGroup()\n",
        "        braces = VGroup()\n",
        "        numbers = VGroup()\n",
        "        for start, end, line, label, config in zip(starts, ends, lines, labels, self.line_configs):\n",
        "            color = label[0].get_color()\n",
        "            nudge_line = Line(start, end)\n",
        "            nudge_line.set_stroke(color, width = 6)\n",
        "            brace = Brace(nudge_line, DOWN, buff = SMALL_BUFF)\n",
        "            brace.set_color(color)\n",
        "            func_label = config[\"func_label\"]\n",
        "            if len(func_label) == 1:\n",
        "                text = \"$d%s$\"%func_label\n",
        "            else:\n",
        "                text = \"$d(%s)$\"%func_label\n",
        "            brace.text = brace.get_text(text, buff = SMALL_BUFF)\n",
        "            brace.text.set_color(color)\n",
        "            brace.add(brace.text)\n",
        "\n",
        "            line.add(nudge_line)\n",
        "            nudge_lines.add(nudge_line)\n",
        "            braces.add(brace)\n",
        "            numbers.add(line.numbers)\n",
        "            line.remove(*line.numbers)\n",
        "        dx_brace, dx_squared_brace, dsine_brace = braces\n",
        "\n",
        "        x_value = str(self.example_x)\n",
        "        x_value_label = OldTex(\"=%s\"%x_value)\n",
        "        x_value_label.next_to(labels[0][1], RIGHT)\n",
        "        dx_squared_value = OldTex(\n",
        "            \"= 2x\\\\,dx \", \"\\\\\\\\ = 2(%s)dx\"%x_value\n",
        "        )\n",
        "        dx_squared_value.shift(\n",
        "            dx_squared_brace.text.get_right()+MED_SMALL_BUFF*RIGHT - \\\n",
        "            dx_squared_value[0].get_left()\n",
        "        )\n",
        "        dsine_value = OldTexText(\n",
        "            \"$=\\\\cos(%s)$\"%self.line_configs[1][\"func_label\"],\n",
        "            dx_squared_brace.text.get_tex()\n",
        "        )\n",
        "        dsine_value.next_to(dsine_brace.text)\n",
        "        less_than_zero = OldTex(\"<0\")\n",
        "        less_than_zero.next_to(dsine_brace.text)\n",
        "\n",
        "        all_x_squared_relevant_labels = VGroup(\n",
        "            dx_squared_brace, dsine_brace,\n",
        "            labels[1], labels[2],\n",
        "            dsine_value,\n",
        "        )\n",
        "        all_x_squared_relevant_labels.save_state()\n",
        "\n",
        "        self.play(FadeOut(numbers))\n",
        "        self.animate_x_change(\n",
        "            self.example_x + self.dx,\n",
        "            run_time = 1,\n",
        "            added_anims = it.chain(\n",
        "                [GrowFromCenter(dx_brace)],\n",
        "                list(map(ShowCreation, nudge_lines))\n",
        "            )\n",
        "        )\n",
        "        self.animate_x_change(self.example_x)\n",
        "        self.wait()\n",
        "        self.play(Write(x_value_label))\n",
        "        self.wait()\n",
        "        self.play(FocusOn(dx_squared_brace))\n",
        "        self.play(Write(dx_squared_brace))\n",
        "        self.wiggle_by_dx()\n",
        "        self.wait()\n",
        "        for part in dx_squared_value:\n",
        "            self.play(Write(part))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(dx_squared_value))\n",
        "        self.wait()\n",
        "        #Needs to be part of everything for the reconfiguraiton\n",
        "        dsine_brace.set_fill(opacity = 0)\n",
        "        dsine_value.set_fill(opacity = 0)\n",
        "        self.add(dsine_brace, dsine_value)\n",
        "        self.replace_x_squared_with_h()\n",
        "        self.wait()\n",
        "        self.play(dsine_brace.set_fill, None, 1)\n",
        "        self.discuss_dsine_sign(less_than_zero)\n",
        "        self.wait()\n",
        "        dsine_value.set_fill(opacity = 1)\n",
        "        self.play(Write(dsine_value))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            all_x_squared_relevant_labels.restore,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.__dict__.update(self.__class__.CONFIG)\n",
        "        self.wait()\n",
        "        for mob in dsine_value:\n",
        "            self.play(Indicate(mob))\n",
        "            self.wait()\n",
        "\n",
        "        two_x_dx = dx_squared_value[0]\n",
        "        dx_squared = dsine_value[1]\n",
        "        two_x_dx_copy = VGroup(*two_x_dx[1:]).copy()\n",
        "        self.play(FocusOn(two_x_dx))\n",
        "        self.play(Write(two_x_dx))\n",
        "        self.play(\n",
        "            two_x_dx_copy.move_to, dx_squared, LEFT,\n",
        "            dx_squared.next_to, dx_squared, UP,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeOut(dx_squared))\n",
        "        for sublist in two_x_dx_copy[:2], two_x_dx_copy[2:]:\n",
        "            self.play(Indicate(VGroup(*sublist)))\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "        self.final_derivative = dsine_value\n",
        "\n",
        "    def discuss_dsine_sign(self, less_than_zero):\n",
        "        self.wiggle_by_dx()\n",
        "        self.wait()\n",
        "        for x in self.example_x+self.dx, self.example_x:\n",
        "            self.animate_x_change(x, run_time = 2)\n",
        "            self.wait()\n",
        "            if less_than_zero not in self.get_mobjects():\n",
        "                self.play(Write(less_than_zero))\n",
        "            else:\n",
        "                self.play(FadeOut(less_than_zero))\n",
        "\n",
        "    def replace_x_squared_with_h(self):\n",
        "        new_config = copy.deepcopy(self.__class__.CONFIG)\n",
        "        new_config[\"line_configs\"][1][\"func_label\"] = \"h\"\n",
        "        new_config[\"line_configs\"][2][\"func_label\"] = \"\\\\sin(h)\"\n",
        "        self.transition_to_alt_config(\n",
        "            return_to_original_configuration = False,\n",
        "            **new_config\n",
        "        )\n",
        "\n",
        "    def give_example_of_meaning(self):\n",
        "        words = OldTexText(\"For example,\")\n",
        "        expression = OldTex(\"\\\\cos(1.5^2)\\\\cdot 2(1.5)\\\\,dx\")\n",
        "        group = VGroup(words, expression)\n",
        "        group.arrange(DOWN, aligned_edge = LEFT)\n",
        "        group.scale(0.8)\n",
        "        group.to_edge(RIGHT)\n",
        "        arrow = Arrow(group.get_bottom(), self.final_derivative[0].get_top())\n",
        "\n",
        "        self.play(*list(map(FadeOut, [self.arrows, self.arrow_labels])))\n",
        "        self.play(FadeIn(group))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.wiggle_by_dx()\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ########\n",
        "\n",
        "    def wiggle_by_dx(self, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 1)\n",
        "        kwargs[\"rate_func\"] = kwargs.get(\"rate_func\", there_and_back)\n",
        "        target_x = self.line_group.x_val + self.dx\n",
        "        self.animate_x_change(target_x, **kwargs)\n",
        "\n",
        "    def animate_x_change(self, target_x, **kwargs):\n",
        "        #Assume fixed lines, only update labels\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        start_x = self.line_group.x_val\n",
        "        def update(line_group, alpha):\n",
        "            lines, labels = line_group\n",
        "            new_x = interpolate(start_x, target_x, alpha)\n",
        "            for line, label, config in zip(lines, labels, self.line_configs):\n",
        "                new_label = self.get_line_label(\n",
        "                    line, new_x, **config\n",
        "                )\n",
        "                Transform(label, new_label).update(1)\n",
        "            line_group.x_val = new_x\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(self.line_group, update),\n",
        "            *added_anims,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_line_group(self, x):\n",
        "        group = VGroup()\n",
        "        group.lines, group.labels = VGroup(), VGroup()\n",
        "        for line_config in self.line_configs:\n",
        "            number_line = self.get_number_line(**line_config)\n",
        "            label = self.get_line_label(number_line, x, **line_config)\n",
        "            group.lines.add(number_line)\n",
        "            group.labels.add(label)\n",
        "        group.add(group.lines, group.labels)\n",
        "        group.x_val = x\n",
        "        return group\n",
        "\n",
        "    def get_number_line(\n",
        "        self, center_y, **number_line_config\n",
        "        ):\n",
        "        number_line = NumberLine(color = GREY, **number_line_config)\n",
        "        number_line.stretch_to_fit_width(self.line_width)\n",
        "        number_line.add_numbers()\n",
        "        number_line.shift(center_y*UP)\n",
        "        number_line.to_edge(LEFT, buff = LARGE_BUFF)\n",
        "\n",
        "        return number_line\n",
        "\n",
        "    def get_line_label(\n",
        "        self, number_line, x, func, func_label, triangle_color, \n",
        "        **spillover_kwargs\n",
        "        ):\n",
        "        triangle = RegularPolygon(\n",
        "            n=3, start_angle = -np.pi/2,\n",
        "            fill_color = triangle_color,\n",
        "            fill_opacity = 0.75,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        triangle.set_height(self.triangle_height)\n",
        "        triangle.move_to(\n",
        "            number_line.number_to_point(func(x)), DOWN\n",
        "        )\n",
        "\n",
        "        label_mob = OldTex(func_label)\n",
        "        label_mob.next_to(triangle, UP, buff = SMALL_BUFF, aligned_edge = LEFT)\n",
        "\n",
        "        return VGroup(triangle, label_mob)\n",
        "\n",
        "class GeneralizeChainRule(Scene):\n",
        "    def construct(self):\n",
        "        example = OldTex(\n",
        "            \"\\\\frac{d}{dx}\", \"\\\\sin(\", \"x^2\", \")\", \"=\",\n",
        "            \"\\\\cos(\", \"x^2\", \")\", \"\\\\,2x\",\n",
        "        )\n",
        "        general = OldTex(\n",
        "            \"\\\\frac{d}{dx}\", \"g(\", \"h(x)\", \")\", \"=\",\n",
        "            \"{dg \\\\over \", \" dh}\", \"(\", \"h(x)\", \")\", \"{dh \\\\over\", \" dx}\", \"(x)\"\n",
        "        )\n",
        "        example.to_edge(UP, buff = LARGE_BUFF)\n",
        "        example.shift(RIGHT)\n",
        "        general.next_to(example, DOWN, buff = 1.5*LARGE_BUFF)\n",
        "        for mob in example, general:\n",
        "            mob.set_color(SINE_COLOR)\n",
        "            mob[0].set_color(WHITE)\n",
        "            for tex in \"x^2\", \"2x\", \"(x)\", \"{dh\", \" dx}\":\n",
        "                mob.set_color_by_tex(tex, X_SQUARED_COLOR, substring = True)\n",
        "\n",
        "        example_outer = VGroup(*example[1:4])\n",
        "        example_inner = example[2]\n",
        "        d_example_outer = VGroup(*example[5:8])\n",
        "        d_example_inner = example[6]\n",
        "        d_example_d_inner = example[8]\n",
        "\n",
        "        general_outer = VGroup(*general[1:4])\n",
        "        general_inner = general[2]\n",
        "        d_general_outer = VGroup(*general[5:10])\n",
        "        d_general_inner = general[8]\n",
        "        d_general_d_inner = VGroup(*general[10:13])\n",
        "\n",
        "        example_outer_brace = Brace(example_outer)\n",
        "        example_inner_brace = Brace(example_inner, UP, buff = SMALL_BUFF)\n",
        "        d_example_outer_brace = Brace(d_example_outer)\n",
        "        d_example_inner_brace = Brace(d_example_inner, buff = SMALL_BUFF)\n",
        "        d_example_d_inner_brace = Brace(d_example_d_inner, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        general_outer_brace = Brace(general_outer)\n",
        "        general_inner_brace = Brace(general_inner, UP, buff = SMALL_BUFF)\n",
        "        d_general_outer_brace = Brace(d_general_outer)\n",
        "        d_general_inner_brace = Brace(d_general_inner, buff = SMALL_BUFF)\n",
        "        d_general_d_inner_brace = Brace(d_general_d_inner, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        for brace in example_outer_brace, general_outer_brace:\n",
        "            brace.text = brace.get_text(\"Outer\")\n",
        "        for brace in example_inner_brace, general_inner_brace:\n",
        "            brace.text = brace.get_text(\"Inner\")\n",
        "        for brace in d_example_outer_brace, d_general_outer_brace:\n",
        "            brace.text = brace.get_text(\"d(Outer)\")\n",
        "            brace.text.shift(SMALL_BUFF*LEFT)\n",
        "        for brace in d_example_d_inner_brace, d_general_d_inner_brace:\n",
        "            brace.text = brace.get_text(\"d(Inner)\", buff = SMALL_BUFF)\n",
        "\n",
        "        #d(out)d(in) for example\n",
        "        self.add(example)\n",
        "        braces = VGroup(\n",
        "            example_outer_brace, \n",
        "            example_inner_brace, \n",
        "            d_example_outer_brace\n",
        "        )\n",
        "        for brace in braces:\n",
        "            self.play(GrowFromCenter(brace))\n",
        "            self.play(Write(brace.text, run_time = 1))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*it.chain(*[\n",
        "            [mob.scale, 1.2, mob.set_color, YELLOW]\n",
        "            for mob in (example_inner, d_example_inner)\n",
        "        ]), rate_func = there_and_back)\n",
        "        self.play(Transform(\n",
        "            example_inner.copy(), d_example_inner,\n",
        "            path_arc = -np.pi/2,\n",
        "            remover = True\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(d_example_d_inner_brace),\n",
        "            Write(d_example_d_inner_brace.text)\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            VGroup(*reversed(example_inner.copy())),\n",
        "            d_example_d_inner,\n",
        "            path_arc = -np.pi/2,\n",
        "            run_time = 2,\n",
        "            remover = True\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        #Generalize\n",
        "        self.play(*list(map(FadeIn, general[:5])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(example_outer_brace, general_outer_brace),\n",
        "            Transform(example_outer_brace.text, general_outer_brace.text),\n",
        "            Transform(example_inner_brace, general_inner_brace),\n",
        "            Transform(example_inner_brace.text, general_inner_brace.text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(d_example_outer_brace, d_general_outer_brace),\n",
        "            Transform(d_example_outer_brace.text, d_general_outer_brace.text),\n",
        "        )\n",
        "        self.play(Write(d_general_outer))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Transform(d_example_d_inner_brace, d_general_d_inner_brace),\n",
        "            Transform(d_example_d_inner_brace.text, d_general_d_inner_brace.text),\n",
        "        )\n",
        "        self.play(Write(d_general_d_inner))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Name chain rule\n",
        "        name = OldTexText(\"``Chain rule''\")\n",
        "        name.scale(1.2)\n",
        "        name.set_color(YELLOW)\n",
        "        name.to_corner(UP+LEFT)\n",
        "        self.play(Write(name))\n",
        "        self.wait()\n",
        "\n",
        "        #Point out dh bottom\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        d_general_outer_copy = d_general_outer.copy()\n",
        "        morty.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            morty.set_fill, None, 1,\n",
        "            morty.change_mode, \"raise_left_hand\",\n",
        "            morty.look, UP+LEFT,\n",
        "            d_general_outer_copy.next_to, \n",
        "            morty.get_corner(UP+LEFT), UP, MED_LARGE_BUFF,\n",
        "            d_general_outer_copy.shift_onto_screen\n",
        "        )\n",
        "        self.wait()        \n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(d_general_outer_copy[1])\n",
        "        circle.scale(1.4)\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        inner = d_general_outer_copy[3]\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            morty.look_at, inner,\n",
        "            inner.shift, UP\n",
        "        )\n",
        "        self.play(inner.shift, DOWN)\n",
        "        self.wait()\n",
        "        self.play(morty.change_mode, \"pondering\")\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            d_general_outer_copy, inner, circle\n",
        "        ])))\n",
        "\n",
        "        #Show cancelation\n",
        "        braces = [\n",
        "            d_example_d_inner_brace,\n",
        "            d_example_outer_brace,\n",
        "            example_inner_brace,\n",
        "            example_outer_brace,\n",
        "        ]\n",
        "        texts = [brace.text for brace in braces]\n",
        "        self.play(*list(map(FadeOut, braces+texts)))\n",
        "\n",
        "        to_collapse = VGroup(VGroup(*general[7:10]), general[12])\n",
        "        dg_dh = VGroup(*general[5:7])\n",
        "        dh_dx = VGroup(*general[10:12])\n",
        "        to_collapse.generate_target()\n",
        "        points = VGroup(*list(map(VectorizedPoint, \n",
        "            [m.get_left() for m in to_collapse]\n",
        "        )))\n",
        "        self.play(\n",
        "            Transform(to_collapse, points),\n",
        "            dh_dx.next_to, dg_dh,\n",
        "            morty.look_at, dg_dh,\n",
        "        )\n",
        "        self.wait()\n",
        "        for mob in list(dg_dh)+list(dh_dx):\n",
        "            circle = Circle(color = YELLOW)\n",
        "            circle.replace(mob)\n",
        "            circle.scale(1.3)\n",
        "            self.play(ShowCreation(circle))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(circle))\n",
        "\n",
        "        strikes = VGroup()\n",
        "        for dh in dg_dh[1], dh_dx[0]:\n",
        "            strike = OldTex(\"/\")\n",
        "            strike.stretch(2, dim = 0)\n",
        "            strike.rotate(-np.pi/12)\n",
        "            strike.move_to(dh)\n",
        "            strike.set_color(RED)\n",
        "            strikes.add(strike)\n",
        "        self.play(Write(strikes))\n",
        "        self.play(morty.change_mode, \"hooray\")\n",
        "        equals_dg_dx = OldTex(\"= \\\\frac{dg}{dx}\")\n",
        "        equals_dg_dx.next_to(dh_dx)\n",
        "        self.play(Write(equals_dg_dx))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "        ##More than a notational trick\n",
        "        self.play(\n",
        "            PiCreatureSays(morty, \"\"\"\n",
        "                This is more than a\n",
        "                notational trick\n",
        "            \"\"\"),\n",
        "            VGroup(\n",
        "                dg_dh, dh_dx, equals_dg_dx, strikes,\n",
        "                *general[:5]\n",
        "            ).shift, DOWN,\n",
        "            FadeOut(example)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class WatchingVideo(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        laptop = Laptop()\n",
        "        laptop.scale(2)\n",
        "        laptop.to_corner(UP+RIGHT)\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy.move_to(laptop, DOWN+LEFT)\n",
        "        randy.shift(MED_SMALL_BUFF*UP)\n",
        "        randy.look_at(laptop.screen)\n",
        "\n",
        "\n",
        "        formulas = VGroup(*[\n",
        "            OldTex(\"\\\\frac{d}{dx}\\\\left( %s \\\\right)\"%s)\n",
        "            for s in [\n",
        "                \"e^x \\\\sin(x)\",\n",
        "                \"\\\\sin(x) \\\\cdot  \\\\frac{1}{\\\\cos(x)}\",\n",
        "                \"\\\\cos(3x)^2\",\n",
        "                \"e^x(x^2 + 3x + 2)\",\n",
        "            ]\n",
        "        ])\n",
        "        formulas.arrange(\n",
        "            DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        formulas.next_to(randy, LEFT, buff = MED_LARGE_BUFF)\n",
        "        formulas.shift_onto_screen()\n",
        "\n",
        "        self.add(randy, laptop)\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"erm\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"maybe\")\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        for formula in formulas:\n",
        "            self.play(\n",
        "                Write(formula, run_time = 2),\n",
        "                randy.change_mode, \"thinking\"\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        return [Randolph().shift(DOWN+RIGHT)]\n",
        "\n",
        "class NextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        next_video = series[4]\n",
        "\n",
        "        pre_expression = OldTex(\n",
        "            \"x\", \"^2\", \"+\", \"y\", \"^2\", \"=\", \"1\"\n",
        "        )\n",
        "        d_expression = OldTex(\n",
        "            \"2\", \"x\", \"\\\\,dx\", \"+\", \"2\", \"y\", \"\\\\,dy\", \"=\", \"0\"\n",
        "        )\n",
        "        expression_to_d_expression_indices = [\n",
        "            1, 0, 0, 2, 4, 3, 3, 5, 6\n",
        "        ]\n",
        "        expression = VGroup()\n",
        "        for i, j in enumerate(expression_to_d_expression_indices):\n",
        "            submob = pre_expression[j].copy()\n",
        "            if d_expression.expression_parts[i] == \"2\":\n",
        "                two = OldTex(\"2\")\n",
        "                two.replace(submob)\n",
        "                expression.add(two)\n",
        "            else:\n",
        "                expression.add(submob)\n",
        "\n",
        "        for mob in expression, d_expression:\n",
        "            mob.scale(1.2)\n",
        "            mob.next_to(\n",
        "                self.get_teacher().get_corner(UP+LEFT), UP,\n",
        "                buff = MED_LARGE_BUFF\n",
        "            )\n",
        "            mob.shift_onto_screen()\n",
        "\n",
        "        axes = Axes(x_min = -3, x_max = 3, color = GREY)\n",
        "        axes.add(Circle(color = YELLOW))\n",
        "        line = Line(np.sqrt(2)*UP, np.sqrt(2)*RIGHT)\n",
        "        line.scale(1.5)\n",
        "        axes.add(line)\n",
        "\n",
        "        axes.scale(0.5)\n",
        "        axes.next_to(d_expression, LEFT)\n",
        "\n",
        "        self.add(series)        \n",
        "        self.play(\n",
        "            next_video.shift, 0.5*DOWN,\n",
        "            next_video.set_color, YELLOW,\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(expression),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"pondering\")\n",
        "                for pi in self.get_students()\n",
        "            ]\n",
        "        )\n",
        "        self.play(FadeIn(axes))\n",
        "        self.wait()\n",
        "        self.remove(expression)\n",
        "        self.play(Transform(expression, d_expression, path_arc = np.pi/2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                line, np.pi/4, \n",
        "                about_point = axes.get_center(),\n",
        "                rate_func = wiggle,\n",
        "                run_time = 3\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class Chapter4Thanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali  Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Ankit   Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Nils Schneider\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ],\n",
        "        \"patron_group_size\" : 8,\n",
        "    }\n",
        "\n",
        "class Thumbnail(IntroduceProductAsArea):\n",
        "    CONFIG = {\n",
        "        \"default_x\" : 0.8,\n",
        "        \"dx\" : 0.05\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.x_slider = self.get_x_slider(self.default_x)\n",
        "        blg = self.box_label_group = self.get_box_label_group(\n",
        "            self.default_x\n",
        "        )\n",
        "        df_boxes = self.get_df_boxes()\n",
        "        df_boxes.space_out_submobjects(1.1)\n",
        "        df_boxes.move_to(blg[0], UP+LEFT)\n",
        "        blg[1][1].next_to(df_boxes[-1], RIGHT)\n",
        "        df_box_labels = self.get_df_box_labels(df_boxes)\n",
        "        blg.add(df_boxes, df_box_labels)\n",
        "        blg.set_height(FRAME_HEIGHT-2*MED_LARGE_BUFF)\n",
        "        blg.center()\n",
        "        self.add(blg)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}