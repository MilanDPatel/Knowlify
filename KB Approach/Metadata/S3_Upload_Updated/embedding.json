{
    "topic": "is demonstrating the concept of dimensionality reduction using Principal Component Analysis (PCA",
    "code": [
        "import gensim\n",
        "import tiktoken\n",
        "from pathlib import Path\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from _2024.transformers.helpers import *\n",
        "\n",
        "\n",
        "def get_token_encoding():\n",
        "    return tiktoken.encoding_for_model(\"davinci\")\n",
        "\n",
        "\n",
        "def get_principle_components(data, n_components=3):\n",
        "    covariance_matrix = np.cov(data, rowvar=False)\n",
        "    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n",
        "\n",
        "    order_of_importance = np.argsort(eigenvalues)[::-1]\n",
        "    sorted_eigenvectors = eigenvectors[:, order_of_importance]  # sort the columns\n",
        "    return sorted_eigenvectors[:, :n_components]\n",
        "\n",
        "\n",
        "def find_nearest_words(model, vector, n=20):\n",
        "    data = model.vectors\n",
        "    indices = np.argsort(((data - vector)**2).sum(1))\n",
        "    return [model.index_to_key[i] for i in indices[:n]]\n",
        "\n",
        "\n",
        "def break_into_pieces(phrase_mob: Text, offsets: list[int]):\n",
        "    phrase = phrase_mob.get_string()\n",
        "    lhs = offsets\n",
        "    rhs = [*offsets[1:], len(phrase)]\n",
        "    result = []\n",
        "    for lh, rh in zip(lhs, rhs):\n",
        "        substr = phrase[lh:rh]\n",
        "        start = phrase_mob.substr_to_path_count(phrase[:lh])\n",
        "        end = start + phrase_mob.substr_to_path_count(substr)\n",
        "        result.append(phrase_mob[start:end])\n",
        "    return VGroup(*result)\n",
        "\n",
        "\n",
        "def break_into_words(phrase_mob):\n",
        "    offsets = [m.start() for m in re.finditer(\" \", phrase_mob.get_string())]\n",
        "    return break_into_pieces(phrase_mob, [0, *offsets])\n",
        "\n",
        "\n",
        "def break_into_tokens(phrase_mob):\n",
        "    tokenizer = get_token_encoding()\n",
        "    tokens = tokenizer.encode(phrase_mob.get_string())\n",
        "    _, offsets = tokenizer.decode_with_offsets(tokens)\n",
        "    return break_into_pieces(phrase_mob, offsets)\n",
        "\n",
        "\n",
        "def get_piece_rectangles(\n",
        "    phrase_pieces,\n",
        "    h_buff=0.05,\n",
        "    v_buff=0.1,\n",
        "    fill_opacity=0.15,\n",
        "    fill_color=None,\n",
        "    stroke_width=1,\n",
        "    stroke_color=None,\n",
        "    hue_range=(0.5, 0.6),\n",
        "    leading_spaces=False,\n",
        "):\n",
        "    rects = VGroup()\n",
        "    height = phrase_pieces.get_height() + 2 * v_buff\n",
        "    last_right_x = phrase_pieces.get_x(LEFT)\n",
        "    for piece in phrase_pieces:\n",
        "        left_x = last_right_x if leading_spaces else piece.get_x(LEFT)\n",
        "        right_x = piece.get_x(RIGHT)\n",
        "        fill = random_bright_color(hue_range) if fill_color is None else fill_color\n",
        "        stroke = fill if stroke_color is None else stroke_color\n",
        "        rect = Rectangle(\n",
        "            width=right_x - left_x + 2 * h_buff,\n",
        "            height=height,\n",
        "            fill_color=fill,\n",
        "            fill_opacity=fill_opacity,\n",
        "            stroke_color=stroke,\n",
        "            stroke_width=stroke_width\n",
        "        )\n",
        "        if leading_spaces:\n",
        "            rect.set_x(left_x, LEFT)\n",
        "        else:\n",
        "            rect.move_to(piece)\n",
        "        rect.set_y(0)\n",
        "        rects.add(rect)\n",
        "\n",
        "        last_right_x = right_x\n",
        "\n",
        "    rects.match_y(phrase_pieces)\n",
        "    return rects\n",
        "\n",
        "\n",
        "def get_word_to_vec_model(model_name=\"glove-wiki-gigaword-50\"):\n",
        "    filename = str(Path(DATA_DIR, model_name))\n",
        "    if os.path.exists(filename):\n",
        "        return gensim.models.keyedvectors.KeyedVectors.load(filename)\n",
        "    model = gensim.downloader.load(model_name)\n",
        "    model.save(filename)\n",
        "    return model\n",
        "\n",
        "\n",
        "def get_direction_lines(axes, direction, n_lines=500, color=YELLOW, line_length=1.0, stroke_width=3):\n",
        "    line = Line(ORIGIN, line_length * normalize(direction))\n",
        "    line.insert_n_curves(20).set_stroke(width=(0, stroke_width, stroke_width, stroke_width, 0))\n",
        "    lines = line.replicate(n_lines)\n",
        "    lines.set_color(color)\n",
        "    for line in lines:\n",
        "        line.move_to(axes.c2p(\n",
        "            random.uniform(*axes.x_range[:2]),\n",
        "            random.uniform(*axes.y_range[:2]),\n",
        "            random.uniform(*axes.z_range[:2]),\n",
        "        ))\n",
        "    return lines\n",
        "\n",
        "\n",
        "# For chapter 5\n",
        "\n",
        "\n",
        "class LyingAboutTokens2(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Mention next word prediction task\n",
        "        phrase = Text(\"The goal of our model is to predict the next word\")\n",
        "\n",
        "        words = break_into_tokens(phrase)\n",
        "        rects = get_piece_rectangles(words, leading_spaces=True, h_buff=0)\n",
        "\n",
        "        words.remove(words[-1])\n",
        "        q_marks = Text(\"???\")\n",
        "        rects[-1].set_color(YELLOW)\n",
        "        q_marks.next_to(rects[-1], DOWN)\n",
        "\n",
        "        big_rect = Rectangle()\n",
        "        big_rect.replace(rects[:-1], stretch=True)\n",
        "        big_rect.set_stroke(GREY_B, 2)\n",
        "        arrow = Arrow(big_rect.get_top(), rects[-1].get_top(), path_arc=-120 * DEGREES)\n",
        "        arrow.scale(0.5, about_edge=DR)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(words, run_time=1))\n",
        "        self.add(rects[-1])\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(big_rect),\n",
        "            ShowCreation(arrow),\n",
        "            Write(q_marks),\n",
        "            lag_ratio=0.3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(big_rect),\n",
        "            LaggedStart(*(\n",
        "                DrawBorderThenFill(rect)\n",
        "                for rect in rects[:-1]\n",
        "            ), lag_ratio=0.02),\n",
        "            LaggedStart(*(\n",
        "                word.animate.match_color(rect)\n",
        "                for word, rect in zip(words, rects)\n",
        "            )),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show words into vectors\n",
        "        vectors = VGroup(*(\n",
        "            NumericEmbedding(length=8)\n",
        "            for word in words\n",
        "        ))\n",
        "        vectors.arrange(RIGHT, buff=1.0 * vectors[0].get_width())\n",
        "        vectors.set_width(12)\n",
        "        vectors.to_edge(DOWN, buff=1.0)\n",
        "        vectors.to_edge(LEFT, buff=0.5)\n",
        "        for vector, word in zip(vectors, words):\n",
        "            vector.get_brackets().match_color(word[0])\n",
        "\n",
        "        blocks = VGroup(*(VGroup(rect, word) for rect, word in zip(rects, words)))\n",
        "        q_group = VGroup(rects[-1], q_marks)\n",
        "        blocks.target = blocks.generate_target()\n",
        "        for block, vector in zip(blocks.target, vectors):\n",
        "            block.next_to(vector, UP, buff=1.5)\n",
        "\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(block, vect, stroke_width=3)\n",
        "            for block, vect in zip(blocks.target, vectors)\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(blocks),\n",
        "            q_group.animate.next_to(blocks.target, RIGHT, aligned_edge=UP),\n",
        "            LaggedStartMap(FadeIn, vectors, shift=0.5 * DOWN),\n",
        "            LaggedStartMap(GrowFromCenter, arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Setup titles\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        title1, title2 = titles = VGroup(\n",
        "            Text(\"The Truth\", font_size=72).to_edge(UP),\n",
        "            Text(\"A Convenient Lie\", font_size=72).next_to(h_line, DOWN),\n",
        "        )\n",
        "        h_line.set_stroke(WHITE, 2)\n",
        "        h_line.next_to(titles[1], UP)\n",
        "        for title in titles:\n",
        "            title.add(Underline(title))\n",
        "\n",
        "        # Show the lie\n",
        "        phrase1, phrase2 = phrases = VGroup(\n",
        "            Text(\"This process (known fancifully as tokenization) frequently subdivides words\"),\n",
        "            # Text(\"It's nice to sometimes pretend tokens are words\"),\n",
        "            Text(\"Let's pretend that tokens are always simply words\"),\n",
        "        )\n",
        "        for phrase, title in zip(phrases, titles):\n",
        "            phrase.set_width(FRAME_WIDTH - 1)\n",
        "            phrase.next_to(title, DOWN, buff=1.0)\n",
        "\n",
        "        tokens = break_into_tokens(phrase1)\n",
        "        words = break_into_words(phrase2)\n",
        "        token_rects = get_piece_rectangles(tokens, hue_range=(0.1, 0.2), leading_spaces=True, h_buff=0.0)\n",
        "        word_rects = get_piece_rectangles(words, hue_range=(0.5, 0.6))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(blocks),\n",
        "            FadeOut(q_group),\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(vectors),\n",
        "            ShowCreation(h_line),\n",
        "            FadeIn(title1, lag_ratio=0.1),\n",
        "            FadeIn(tokens),\n",
        "        )\n",
        "        self.add(token_rects, tokens)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, token_rects),\n",
        "            LaggedStart(*(\n",
        "                token.animate.set_color(rect.get_color())\n",
        "                for token, rect in zip(tokens, token_rects)\n",
        "            ))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(title2, lag_ratio=0.1),\n",
        "            FadeIn(words),\n",
        "        )\n",
        "        self.add(word_rects, words)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, word_rects),\n",
        "            LaggedStart(*(\n",
        "                token.animate.set_color(rect.get_color())\n",
        "                for token, rect in zip(words, word_rects)\n",
        "            ))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Analyze tokenization\n",
        "        brace = Brace(token_rects[8], buff=0.05)\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        for index in [2, 4, 5, 7, 8, 9, 11, 12]:\n",
        "            self.play(brace.animate.become(Brace(token_rects[index], buff=0.05)))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class DiscussTokenization(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ImageTokens(InteractiveScene):\n",
        "    n_divisions = 52\n",
        "\n",
        "    def construct(self):\n",
        "        # Add image\n",
        "        image = ImageMobject(\"SmallFluffCreature\")  # Change\n",
        "        image.set_height(5)\n",
        "        self.add(image)\n",
        "\n",
        "        # Add pixels\n",
        "        pixels = create_pixels(image, pixel_width=image.get_width() / self.n_divisions)\n",
        "        big_pixels = create_pixels(image, pixel_width=image.get_width() / (self.n_divisions / 4))\n",
        "\n",
        "        patches = big_pixels.copy().set_fill(opacity=0)\n",
        "        p_points = np.array([p.get_center() for p in pixels])\n",
        "        bp_points = np.array([bp.get_center() for bp in big_pixels])\n",
        "\n",
        "        for pixel in pixels:\n",
        "            dists = np.linalg.norm(bp_points - pixel.get_center(), axis=1)\n",
        "            patches[np.argmin(dists)].add(pixel)\n",
        "\n",
        "        # Anim test\n",
        "        self.play(FadeIn(patches))\n",
        "        self.remove(image)\n",
        "        self.play(patches.animate.space_out_submobjects(2.0).scale(0.75))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            (patch.animate.set_stroke(TEAL, 3).set_anim_args(rate_func=there_and_back)\n",
        "            for patch in patches),\n",
        "            lag_ratio=5.0 / len(patches),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SoundTokens(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add wave form\n",
        "        n_lines = 100\n",
        "        wave_form = Line(UP, DOWN).replicate(n_lines)\n",
        "        wave_form.arrange(RIGHT)\n",
        "        wave_form.arrange_to_fit_width(5)\n",
        "        wave_form.next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        def func(x):\n",
        "            x *= 1.7\n",
        "            return sum([\n",
        "                math.sin(x),\n",
        "                0.5 * math.sin(2 * x),\n",
        "                0.3 * math.sin(3 * x),\n",
        "                0.2 * math.sin(4 * x),\n",
        "                0.1 * math.sin(5 * x),\n",
        "                0.15 * math.sin(6 * x),\n",
        "            ])\n",
        "\n",
        "        for line in wave_form:\n",
        "            line.set_height(abs(func(line.get_x())))\n",
        "\n",
        "        wave_form.center()\n",
        "        self.add(wave_form)\n",
        "\n",
        "        # Subdivide\n",
        "        step = 5\n",
        "        chunks = VGroup(wave_form[i:i + step] for i in range(0, len(wave_form), step))\n",
        "\n",
        "        self.add(chunks)\n",
        "        self.wait()\n",
        "        self.play(chunks.animate.space_out_submobjects(2.0).scale(0.75))\n",
        "        self.play(LaggedStart(\n",
        "            (chunk.animate.set_stroke(TEAL, 3).scale(1.5).set_anim_args(rate_func=there_and_back)\n",
        "            for chunk in chunks),\n",
        "            lag_ratio=2.0 / len(chunks),\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceEmbeddingMatrix(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Load words\n",
        "        words = [\n",
        "            'aah',\n",
        "            'aardvark',\n",
        "            'aardwolf',\n",
        "            'aargh',\n",
        "            'ab',\n",
        "            'aback',\n",
        "            'abacterial',\n",
        "            'abacus',\n",
        "            'abalone',\n",
        "            'abandon',\n",
        "            'zygoid',\n",
        "            'zygomatic',\n",
        "            'zygomorphic',\n",
        "            'zygosis',\n",
        "            'zygote',\n",
        "            'zygotic',\n",
        "            'zyme',\n",
        "            'zymogen',\n",
        "            'zymosis',\n",
        "            'zzz'\n",
        "        ]\n",
        "\n",
        "        # Get all words\n",
        "        dots = Tex(R\"\\vdots\")\n",
        "        shown_words = VGroup(\n",
        "            *map(Text, words[:10]),\n",
        "            dots,\n",
        "            *map(Text, words[-10:]),\n",
        "        )\n",
        "        shown_words.arrange(DOWN, aligned_edge=LEFT)\n",
        "        dots.match_x(shown_words[:5])\n",
        "        shown_words.set_height(FRAME_HEIGHT - 1)\n",
        "        shown_words.move_to(LEFT)\n",
        "        shown_words.set_fill(border_width=0)\n",
        "\n",
        "        brace = Brace(shown_words, RIGHT)\n",
        "        brace_text = brace.get_tex(R\"\\text{All words, } \\sim 50\\text{k}\")\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, shown_words, shift=0.5 * LEFT, lag_ratio=0.1, run_time=2),\n",
        "            GrowFromCenter(brace, time_span=(0.5, 2.0)),\n",
        "            FadeIn(brace_text, time_span=(0.5, 1.5)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show embedding matrix\n",
        "        dots_index = shown_words.submobjects.index(dots)\n",
        "        matrix = WeightMatrix(\n",
        "            shape=(10, len(shown_words)),\n",
        "            ellipses_col=dots_index\n",
        "        )\n",
        "        matrix.set_width(13.5)\n",
        "        matrix.center()\n",
        "        columns = matrix.get_columns()\n",
        "\n",
        "        matrix_name = Text(\"Embedding matrix\", font_size=90)\n",
        "        matrix_name.next_to(matrix, DOWN, buff=0.5)\n",
        "\n",
        "        shown_words.target = shown_words.generate_target()\n",
        "        shown_words.target.rotate(PI / 2)\n",
        "        shown_words.target.next_to(matrix, UP)\n",
        "        for word, column in zip(shown_words.target, columns):\n",
        "            word.match_x(column)\n",
        "            word.rotate(-45 * DEGREES, about_edge=DOWN)\n",
        "        shown_words.target[dots_index].rotate(45 * DEGREES).move_to(\n",
        "            shown_words.target[dots_index - 1:dots_index + 2]\n",
        "        )\n",
        "        new_brace = Brace(shown_words.target, UP, buff=0.0)\n",
        "        column_rects = VGroup(*(\n",
        "            SurroundingRectangle(column, buff=0.05)\n",
        "            for column in columns\n",
        "        ))\n",
        "        column_rects.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(shown_words),\n",
        "            brace.animate.become(new_brace),\n",
        "            brace_text.animate.next_to(new_brace, UP, buff=0.1),\n",
        "            LaggedStart(*(\n",
        "                Write(column, lag_ratio=0.01, stroke_width=1)\n",
        "                for column in columns\n",
        "            ), lag_ratio=0.2, run_time=2),\n",
        "            LaggedStartMap(FadeIn, matrix.get_brackets(), scale=0.5, lag_ratio=0)\n",
        "        )\n",
        "        self.play(Write(matrix_name, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show a few columns\n",
        "        last_rect = VMobject()\n",
        "        # for index in [9, -7, 7, -5, -6]:\n",
        "        for index in range(len(columns)):\n",
        "            for group in shown_words, columns:\n",
        "                group.target = group.generate_target()\n",
        "                group.target.set_opacity(0.2)\n",
        "                group.target[index].set_opacity(1)\n",
        "            rect = column_rects[index]\n",
        "            self.play(\n",
        "                *map(MoveToTarget, [shown_words, columns]),\n",
        "                FadeIn(rect),\n",
        "                FadeOut(last_rect),\n",
        "            )\n",
        "            last_rect = rect\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            FadeOut(last_rect),\n",
        "            shown_words.animate.set_opacity(1),\n",
        "            columns.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "        # Label as W_E\n",
        "        frame = self.frame\n",
        "        lhs = Tex(\"W_E = \", font_size=90)\n",
        "        lhs.next_to(matrix, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_width(FRAME_WIDTH + 3, about_edge=RIGHT),\n",
        "            Write(lhs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Randomize entries\n",
        "        rects = VGroup(*(\n",
        "            SurroundingRectangle(entry).insert_n_curves(20)\n",
        "            for entry in matrix.get_entries()\n",
        "            if entry not in matrix.ellipses\n",
        "        ))\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        for x in range(1):\n",
        "            self.play(\n",
        "                RandomizeMatrixEntries(matrix, lag_ratio=0.01),\n",
        "                LaggedStartMap(VShowPassingFlash, rects, lag_ratio=0.01, time_width=1.5),\n",
        "                run_time=2,\n",
        "            )\n",
        "        data_modifying_matrix(self, matrix)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight just one word\n",
        "        matrix_group = VGroup(lhs, matrix, shown_words, matrix_name)\n",
        "        index = words.index(\"aardvark\")\n",
        "        vector = VGroup(\n",
        "            matrix.get_brackets()[0],\n",
        "            matrix.get_columns()[index],\n",
        "            matrix.get_brackets()[1],\n",
        "        ).copy()\n",
        "        vector.target = vector.generate_target()\n",
        "        vector.target.arrange(RIGHT, buff=0.1)\n",
        "        vector.target.set_height(4.5)\n",
        "        vector.target.move_to(frame, DOWN).shift(0.5 * UP)\n",
        "        vector.target.set_x(-3)\n",
        "\n",
        "        word = shown_words[index].copy()\n",
        "        word.target = word.generate_target()\n",
        "        word.target.rotate(-45 * DEGREES)\n",
        "        word.target.scale(3)\n",
        "        word.target.next_to(vector.target, LEFT, buff=1.5)\n",
        "        arrow = Arrow(word.target, vector.target)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            matrix_group.animate.scale(0.5).next_to(frame.get_top(), DOWN, 0.5),\n",
        "            FadeOut(brace, UP),\n",
        "            FadeOut(brace_text, 0.5 * UP),\n",
        "            MoveToTarget(word),\n",
        "            MoveToTarget(vector),\n",
        "            GrowFromPoint(arrow, word.get_center()),\n",
        "        ), lag_ratio=0.15)\n",
        "        self.wait()\n",
        "\n",
        "        word_group = VGroup(word, arrow, vector)\n",
        "\n",
        "        # Pull the matrix back up\n",
        "        self.play(\n",
        "            FadeOut(word_group, DOWN),\n",
        "            matrix_group.animate.scale(2.0).move_to(frame)\n",
        "        )\n",
        "\n",
        "        # Have data fly across\n",
        "        data_modifying_matrix(self, matrix, word_shape=(3, 10), alpha_maxes=(0.5, 0.9))\n",
        "        self.wait()\n",
        "\n",
        "        # Prep tokens\n",
        "        encoding = get_token_encoding()\n",
        "        n_vocab = encoding.n_vocab\n",
        "        kw = dict(font_size=24)\n",
        "        shown_tokens = VGroup(\n",
        "            *(Text(encoding.decode([i]), **kw) for i in range(10)),\n",
        "            shown_words[dots_index].copy().rotate(-45 * DEGREES),\n",
        "            *(Text(encoding.decode([i]), **kw) for i in range(n_vocab - 10, n_vocab)),\n",
        "        )\n",
        "        for token, word in zip(shown_tokens, shown_words):\n",
        "            token.rotate(45 * DEGREES)\n",
        "            token.move_to(word, DL)\n",
        "        shown_tokens[dots_index].move_to(\n",
        "            shown_tokens[dots_index-1:dots_index + 2:2]\n",
        "        )\n",
        "\n",
        "        # Show dimensions\n",
        "        top_brace = Brace(shown_words, UP)\n",
        "        left_brace = Brace(matrix, LEFT, buff=SMALL_BUFF)\n",
        "        vocab_count = Integer(50257)\n",
        "        vocab_label = VGroup(vocab_count, Text(\"words\"))\n",
        "        vocab_label.arrange(RIGHT, aligned_edge=UP)\n",
        "        vocab_label.next_to(top_brace, UP, SMALL_BUFF)\n",
        "        token_label = Text(\"tokens\", fill_color=YELLOW)\n",
        "        token_label.move_to(vocab_label[1], LEFT)\n",
        "\n",
        "        dim_count = Integer(12288)\n",
        "        dim_count.next_to(left_brace, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(top_brace),\n",
        "            CountInFrom(vocab_count, 0),\n",
        "            FadeIn(vocab_label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(vocab_label[1], 0.5 * UP),\n",
        "            FadeIn(token_label, 0.5 * UP),\n",
        "            LaggedStartMap(FadeOut, shown_words, shift=0.25 * UP, lag_ratio=0.1),\n",
        "            LaggedStartMap(FadeIn, shown_tokens, shift=0.25 * UP, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        matrix_name.target = matrix_name.generate_target()\n",
        "        matrix_name.target.shift(RIGHT)\n",
        "        self.play(\n",
        "            MoveToTarget(matrix_name),\n",
        "            lhs.animate.next_to(matrix_name.target, LEFT),\n",
        "            GrowFromCenter(left_brace),\n",
        "            CountInFrom(dim_count, 0),\n",
        "        )\n",
        "        self.play(FlashAround(dim_count))\n",
        "        self.wait()\n",
        "\n",
        "        # Count total parameters\n",
        "        matrix_group = VGroup(\n",
        "            top_brace, vocab_count,\n",
        "            left_brace, dim_count,\n",
        "            matrix, shown_words, matrix_name, lhs\n",
        "        )\n",
        "\n",
        "        top_equation = VGroup(\n",
        "            Text(\"Total parameters = \"),\n",
        "            dim_count.copy(),\n",
        "            Tex(R\"\\times\"),\n",
        "            vocab_count.copy(),\n",
        "            Tex(\"=\"),\n",
        "            Integer(vocab_count.get_value() * dim_count.get_value()).set_color(YELLOW),\n",
        "        )\n",
        "        top_equation.arrange(RIGHT)\n",
        "        top_equation.set_height(0.5)\n",
        "        top_equation.next_to(matrix_group, UP, buff=1.0)\n",
        "        result_rect = SurroundingRectangle(top_equation[-1])\n",
        "        result_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, top_equation[::2], shift=0.25 * UP, lag_ratio=0.5),\n",
        "            TransformFromCopy(dim_count, top_equation[1]),\n",
        "            TransformFromCopy(vocab_count, top_equation[3]),\n",
        "            frame.animate.set_height(11).move_to(matrix_group, DOWN).shift(DOWN),\n",
        "        )\n",
        "        self.play(FadeTransform(\n",
        "            top_equation[1:5:2].copy(), top_equation[-1]\n",
        "        ))\n",
        "        self.play(ShowCreation(result_rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Word2VecScene(InteractiveScene):\n",
        "    default_frame_orientation = (-30, 70)\n",
        "\n",
        "    axes_config = dict(\n",
        "        x_range=(-5, 5, 1),\n",
        "        y_range=(-5, 5, 1),\n",
        "        z_range=(-4, 4, 1),\n",
        "        width=8,\n",
        "        height=8,\n",
        "        depth=6.4,\n",
        "    )\n",
        "    label_rotation = PI / 2\n",
        "    # embedding_model = \"word2vec-google-news-300\"\n",
        "    embedding_model = \"glove-wiki-gigaword-50\"\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "\n",
        "        # Load model\n",
        "        self.model = get_word_to_vec_model(self.embedding_model)\n",
        "\n",
        "        # Decide on basis\n",
        "        self.basis = self.get_basis(self.model)\n",
        "\n",
        "        # Add axes\n",
        "        self.axes = ThreeDAxes(**self.axes_config)\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def get_basis(self, model):\n",
        "        return get_principle_components(model.vectors, 3).T\n",
        "\n",
        "    def add_plane(self, color=GREY, stroke_width=1.0):\n",
        "        axes = self.axes\n",
        "        plane = NumberPlane(\n",
        "            axes.x_range, axes.y_range,\n",
        "            width=axes.get_width(),\n",
        "            height=axes.get_height(),\n",
        "            background_line_style=dict(\n",
        "                stroke_color=color,\n",
        "                stroke_width=stroke_width,\n",
        "            ),\n",
        "            faded_line_style=dict(\n",
        "                stroke_opacity=0.25,\n",
        "                stroke_width=0.5 * stroke_width,\n",
        "            ),\n",
        "            faded_line_ratio=1,\n",
        "        )\n",
        "        self.plane = plane\n",
        "        self.add(plane)\n",
        "        return plane\n",
        "\n",
        "    def get_labeled_vector(\n",
        "        self,\n",
        "        word,\n",
        "        coords=None,\n",
        "        thickness=5,\n",
        "        color=YELLOW,\n",
        "        func_name: str | None = \"E\",\n",
        "        buff=0.05,\n",
        "        direction=None,\n",
        "        label_config: dict = dict()\n",
        "    ):\n",
        "        # Return an arrow with word label next to it\n",
        "        axes = self.axes\n",
        "        if coords is None:\n",
        "            coords = self.basis @ self.model[word.lower()]\n",
        "        point = axes.c2p(*coords)\n",
        "        label_config.update(label_buff=buff)\n",
        "        if \"label_rotation\" not in label_config:\n",
        "            label_config.update(label_rotation=self.label_rotation)\n",
        "        arrow = LabeledArrow(\n",
        "            axes.get_origin(),\n",
        "            point,\n",
        "            thickness=thickness,\n",
        "            fill_color=color,\n",
        "            label_text=word if func_name is None else f\"{func_name}({word})\",\n",
        "            buff=0,\n",
        "            direction=direction,\n",
        "            **label_config,\n",
        "        )\n",
        "        arrow.always.set_perpendicular_to_camera(self.frame)\n",
        "        return arrow\n",
        "\n",
        "\n",
        "class AmbientWordEmbedding(Word2VecScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        frame.reorient(-30, 82, 0)\n",
        "        frame.add_ambient_rotation(3 * DEGREES)\n",
        "\n",
        "        axes = self.axes\n",
        "        axes.set_stroke(width=2)\n",
        "        axes.set_height(7)\n",
        "        axes.move_to(0.2 * FRAME_WIDTH * RIGHT + 1.0 * IN)\n",
        "\n",
        "        # Add titles\n",
        "        titles = VGroup(Text(\"Words\"), Text(\"Vectors\"))\n",
        "        colors = [YELLOW, BLUE]\n",
        "        titles.set_height(0.5)\n",
        "        xs = [-4.0, axes.get_x()]\n",
        "        for title, x, color in zip(titles, xs, colors):\n",
        "            title.move_to(x * RIGHT)\n",
        "            title.to_edge(UP)\n",
        "            title.add(Underline(title))\n",
        "            title.fix_in_frame()\n",
        "            title.set_color(color)\n",
        "\n",
        "        arrow = Arrow(titles[0], titles[1], buff=0.5)\n",
        "        arrow.fix_in_frame()\n",
        "\n",
        "        arrow_label = TexText(\"``Embedding''\")\n",
        "        arrow_label.set_submobject_colors_by_gradient(YELLOW, BLUE)\n",
        "        arrow_label.next_to(arrow, UP, SMALL_BUFF)\n",
        "        arrow_label.fix_in_frame()\n",
        "\n",
        "        self.add(titles)\n",
        "        self.add(arrow)\n",
        "\n",
        "        # Add words\n",
        "        words = \"All data in deep learning must be represented as vectors\".split(\" \")\n",
        "        pre_labels = VGroup(*(Text(word) for word in words))\n",
        "        pre_labels.fix_in_frame()\n",
        "        pre_labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        pre_labels.next_to(titles[0], DOWN, buff=0.5)\n",
        "        pre_labels.align_to(titles[0][0], LEFT)\n",
        "        pre_labels.set_backstroke()\n",
        "\n",
        "        coords = np.array([\n",
        "            self.basis @ self.model[word.lower()]\n",
        "            for word in words\n",
        "        ])\n",
        "        coords -= coords.mean(0)\n",
        "        max_coord = max(coords.max(), -coords.min())\n",
        "        coords *= 4.0 / max_coord\n",
        "\n",
        "        embeddings = VGroup(*(\n",
        "            self.get_labeled_vector(\n",
        "                word,\n",
        "                coord,\n",
        "                stroke_width=2,\n",
        "                color=interpolate_color(BLUE_D, BLUE_A, random.random()),\n",
        "                func_name=None,\n",
        "                label_config=dict(font_size=24)\n",
        "            )\n",
        "            for word, coord in zip(words, coords)\n",
        "        ))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, pre_labels, shift=0.2 * UP, lag_ratio=0.1, run_time=1))\n",
        "\n",
        "        # Transition\n",
        "        self.add(turn_animation_into_updater(\n",
        "            Write(arrow_label, time_span=(1, 3))\n",
        "        ))\n",
        "        for label, vect in zip(pre_labels, embeddings):\n",
        "            self.add(turn_animation_into_updater(\n",
        "                TransformFromCopy(label, vect.label, run_time=2)\n",
        "            ))\n",
        "            self.add(turn_animation_into_updater(\n",
        "                FadeIn(vect, run_time=1)\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "        self.play(FlashAround(arrow_label, time_width=1.5, run_time=3))\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class ThreeDSpaceExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up axes\n",
        "        frame = self.frame\n",
        "        frame.reorient(-15, 78, 0, (1.07, 1.71, 1.41), 6.72)\n",
        "        frame.add_ambient_rotation(1 * DEGREES)\n",
        "        axes = ThreeDAxes((-5, 5), (-5, 5), (-4, 4))\n",
        "        plane = NumberPlane((-5, 5), (-5, 5))\n",
        "        plane.fade(0.5)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Show coordiantes creating directions\n",
        "        x, y, z = coordinates = np.array([3, 1, 2])\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "\n",
        "        coords = DecimalMatrix(np.zeros((3, 1)), num_decimal_places=1)\n",
        "        coords.fix_in_frame()\n",
        "        coords.to_corner(UR)\n",
        "        coords.shift(1.5 * LEFT)\n",
        "        coords.get_entries().set_submobject_colors_by_gradient(*colors)\n",
        "\n",
        "        lines = VGroup(\n",
        "            Line(axes.c2p(0, 0, 0), axes.c2p(x, 0, 0)),\n",
        "            Line(axes.c2p(x, 0, 0), axes.c2p(x, y, 0)),\n",
        "            Line(axes.c2p(x, y, 0), axes.c2p(x, y, z)),\n",
        "        )\n",
        "        lines.set_flat_stroke(False)\n",
        "        lines.set_submobject_colors_by_gradient(*colors)\n",
        "        labels = VGroup(*map(Tex, \"xyz\"))\n",
        "        labels.rotate(89 * DEGREES, RIGHT)\n",
        "        directions = [OUT, OUT + RIGHT, RIGHT]\n",
        "        for label, line, direction in zip(labels, lines, directions):\n",
        "            label.next_to(line, direction, buff=SMALL_BUFF)\n",
        "            label.match_color(line)\n",
        "\n",
        "        dot = GlowDot(color=WHITE)\n",
        "        dot.move_to(axes.get_origin())\n",
        "\n",
        "        vect = Arrow(axes.get_origin(), axes.c2p(x, y, z), buff=0)\n",
        "        vect.set_flat_stroke(False)\n",
        "\n",
        "        self.add(coords)\n",
        "        for entry, line, label, value in zip(coords.get_entries(), lines, labels, coordinates):\n",
        "            rect = SurroundingRectangle(entry)\n",
        "            rect.set_fill(line.get_color(), 0.3)\n",
        "            rect.set_stroke(line.get_color(), width=2)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeInFromPoint(label, line.get_start()),\n",
        "                VFadeInThenOut(rect),\n",
        "                ChangeDecimalToValue(entry, value),\n",
        "                dot.animate.move_to(line.get_end()),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(ShowCreation(vect))\n",
        "\n",
        "        # Wait for a bit\n",
        "        self.wait(15)\n",
        "\n",
        "        # Show many points\n",
        "        points = GlowDots(np.random.uniform(-3, 3, size=(50, 3)), radius=0.1)\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(coords),\n",
        "            FadeOut(dot),\n",
        "            FadeOut(plane),\n",
        "            LaggedStartMap(FadeOut, VGroup(*lines, vect, *labels)),\n",
        "            frame.animate.reorient(-81, 61, 0, (-0.82, 0.6, 0.36), 8.95),\n",
        "            ShowCreation(points),\n",
        "            run_time=2,\n",
        "        )\n",
        "        frame.add_ambient_rotation(5 * DEGREES)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Take a 2d slice\n",
        "        plane = Square3D()\n",
        "        plane.set_height(10)\n",
        "        plane.set_color([GREY_E, GREY_C])\n",
        "        plane.set_opacity(0.25)\n",
        "        grid = NumberPlane(\n",
        "            (-5, 5), (-5, 5),\n",
        "            background_line_style=dict(stroke_color=GREY_B, stroke_width=1),\n",
        "            faded_line_ratio=0,\n",
        "        )\n",
        "        grid.axes.match_style(grid.background_lines)\n",
        "        grid.match_height(plane)\n",
        "        plane_group = Group(plane, grid)\n",
        "        plane_group.rotate(60 * DEGREES, UR)\n",
        "\n",
        "        bases = [\n",
        "            normalize(point)\n",
        "            for point in plane.get_points()[:2]\n",
        "        ]\n",
        "\n",
        "        def project(points):\n",
        "            return np.array([\n",
        "                sum(np.dot(point, b) * b for b in bases)\n",
        "                for point in points\n",
        "            ])\n",
        "\n",
        "        projected_points = points.copy()\n",
        "        projected_points.apply_points_function(project)\n",
        "\n",
        "        projection_lines = VGroup(*(\n",
        "            Line(p1, p2)\n",
        "            for p1, p2 in zip(points.get_points(), projected_points.get_points())\n",
        "        ))\n",
        "        projection_lines.set_stroke()\n",
        "\n",
        "        self.play(ShowCreation(plane), Write(grid, lag_ratio=0.01, stroke_width=1))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            axes.animate.set_stroke(opacity=0.25),\n",
        "            points.animate.set_opacity(0.5),\n",
        "            TransformFromCopy(points, projected_points),\n",
        "            ShowCreation(projection_lines, lag_ratio=0.05),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(points),\n",
        "            FadeOut(projection_lines),\n",
        "            FadeOut(axes)\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class HighDimensionalSpaceCompanion(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Vector example\n",
        "        word = Text(\"bank\")\n",
        "        vect = WeightMatrix(shape=(8, 1))\n",
        "        vect.next_to(word, RIGHT, buff=LARGE_BUFF)\n",
        "        vect.set_height(3)\n",
        "        arrow = Arrow(word, vect)\n",
        "        group = VGroup(word, arrow, vect)\n",
        "        group.move_to(RIGHT)\n",
        "        group.to_edge(UP, buff=0.1)\n",
        "        self.add(group)\n",
        "\n",
        "        # Draw vague embedding space\n",
        "        bubble_center = np.array([0.5, -2.25, 0])\n",
        "        base_bubble: VMobject = OldThoughtBubble()[-2][-1]\n",
        "        base_bubble.set_shape(8, 7)\n",
        "        base_bubble.rotate(PI)\n",
        "        base_bubble.set_fill(GREY_D, opacity=[0.25, 1, 0.25])\n",
        "        base_bubble.move_to(bubble_center)\n",
        "        bubble_label = Text(\"Word vector space\", font_size=60)\n",
        "        bubble_label.move_to(base_bubble)\n",
        "        bubble_label.shift(2.0 * UP)\n",
        "        # bubble_label = Text(\"Embedding space\", font_size=72)\n",
        "        q_marks = Tex(\"???\", font_size=120)\n",
        "        q_marks.next_to(bubble_label, DOWN, buff=0.5)\n",
        "        base_bubble.add(bubble_label, q_marks)\n",
        "\n",
        "        def get_bubble():\n",
        "            result = base_bubble.copy()\n",
        "            result.apply_complex_function(\n",
        "                lambda z: z * (1 + 0.025 * np.cos(5 * np.log(z).imag + self.time))\n",
        "            )\n",
        "            result.move_to(bubble_center)\n",
        "            return result\n",
        "\n",
        "        bubble = always_redraw(get_bubble)\n",
        "        self.add(bubble)\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show dimension\n",
        "        brace = Brace(vect, RIGHT)\n",
        "        label = VGroup(\n",
        "            # Integer(12288),\n",
        "            Integer(10000),\n",
        "            Text(\"coordinates\")\n",
        "        )\n",
        "        label.arrange(DOWN, aligned_edge=LEFT)\n",
        "        label.set_height(1)\n",
        "        label.set_color(YELLOW)\n",
        "        label.next_to(brace, RIGHT)\n",
        "\n",
        "        dimension_label = VGroup(\n",
        "            label[0].copy(),\n",
        "            Text(\"-dimensional\")\n",
        "        )\n",
        "        dimension_label.arrange(RIGHT, buff=0.05, aligned_edge=UP)\n",
        "        dimension_label.match_height(bubble_label).scale(0.8)\n",
        "        dimension_label.set_color(YELLOW)\n",
        "        dimension_label.next_to(q_marks, DOWN, buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            CountInFrom(label[0], 0),\n",
        "            FadeIn(label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(label[0], dimension_label[0]),\n",
        "            FadeInFromPoint(dimension_label[1], label[0].get_center()),\n",
        "        )\n",
        "        self.remove(dimension_label)\n",
        "        bubble_label.add(*dimension_label)\n",
        "\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show 3d slice\n",
        "        axes = ThreeDAxes()\n",
        "        axes.rotate(20 * DEGREES, OUT)\n",
        "        axes.rotate(80 * DEGREES, LEFT)\n",
        "        axes.set_height(3)\n",
        "        axes.move_to(bubble)\n",
        "        axes.shift(0.5 * RIGHT)\n",
        "        axes_label = TexText(\"3d ``slice''\")\n",
        "        axes_label.next_to(axes, RIGHT)\n",
        "        axes_label.shift(0.35 * DOWN + 1.5 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            bubble_label.animate.scale(0.5).shift(1.2 * UP + 1.5 * LEFT),\n",
        "            FadeOut(q_marks),\n",
        "            Write(axes, lag_ratio=0.01),\n",
        "            Write(axes_label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show some vector projections\n",
        "        vectors = VGroup(*(\n",
        "            Arrow(\n",
        "                axes.get_origin(),\n",
        "                axes.c2p(*np.random.uniform(-3, 3, 3)),\n",
        "                buff=0,\n",
        "                stroke_color=random_bright_color(hue_range=(0.55, 0.65))\n",
        "            )\n",
        "            for x in range(5)\n",
        "        ))\n",
        "        vectors.set_flat_stroke(False)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, vectors, scale=0.5, lag_ratio=0.3))\n",
        "        z_direction = axes.z_axis.get_vector()\n",
        "        axes.add(vectors)\n",
        "        self.play(Rotate(axes, -200 * DEGREES, axis=z_direction, run_time=10))\n",
        "\n",
        "\n",
        "class LearningEmbeddings(Word2VecScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.add_plane()\n",
        "        axes = self.axes\n",
        "        plane = self.plane\n",
        "        frame = self.frame\n",
        "        frame.reorient(0, 90, 0)\n",
        "\n",
        "        # Get sample words\n",
        "        # phrase = \"The first big idea is that as a model tweaks and tunes its weights\"\n",
        "        # phrase = \"The big idea as a model tweaks and tunes its weights\"\n",
        "        phrase = \"Features can be encoded with directions in a big space\"\n",
        "        words = [word.lower() for word in phrase.split(\" \")]\n",
        "\n",
        "        # Get initial and final states\n",
        "        colors = [random_bright_color(hue_range=(0.5, 0.6)) for word in words]\n",
        "        true_embeddings = np.array([\n",
        "            self.basis @ self.model[word]\n",
        "            for word in words\n",
        "        ])\n",
        "        true_embeddings -= true_embeddings.mean(0)\n",
        "        true_embeddings *= 5 / np.abs(true_embeddings).max(0)\n",
        "\n",
        "        np.random.seed(2)\n",
        "        thetas = np.arange(0, TAU, TAU / len(words))\n",
        "        thetas += np.random.uniform(-0.5, 0.5, thetas.size)\n",
        "        amps = np.random.uniform(3, 5, thetas.size)\n",
        "        initial_coords = [\n",
        "            rotate_vector(amp * OUT, theta, axis=UP)\n",
        "            for theta, amp in zip(thetas, amps)\n",
        "        ]\n",
        "\n",
        "        # Create word vectors\n",
        "        word_vects = VGroup(*(\n",
        "            self.get_labeled_vector(\n",
        "                word,\n",
        "                coords=coords,\n",
        "                color=color,\n",
        "                buff=0.05,\n",
        "                func_name=None,\n",
        "                label_config=dict(font_size=36)\n",
        "            )\n",
        "            for word, color, coords in zip(words, colors, initial_coords)\n",
        "        ))\n",
        "        labels = VGroup()\n",
        "        for vect in word_vects:\n",
        "            label = vect.label\n",
        "            label.set_backstroke(BLACK, 3)\n",
        "            label.vect = vect\n",
        "            label.add_updater(lambda m: m.move_to(\n",
        "                m.vect.get_end() + 0.25 * normalize(m.vect.get_vector())\n",
        "            ))\n",
        "            labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, word_vects, lag_ratio=0.2),\n",
        "            LaggedStartMap(FadeIn, labels, lag_ratio=0.2),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Tweak and tune weights\n",
        "        turn_animation_into_updater(\n",
        "            ApplyMethod(frame.reorient, 4, 72, 0, (-0.04, -0.18, -0.5), 8.00),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.progressive_nudges(word_vects, true_embeddings, 8)\n",
        "        frame.clear_updaters()\n",
        "        turn_animation_into_updater(\n",
        "            ApplyMethod(frame.reorient, 38, 69, 0, (-0.32, 0.02, -0.54), 7.68),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.progressive_nudges(word_vects, true_embeddings, 12)\n",
        "\n",
        "    def progressive_nudges(self, word_vects, true_embeddings, n_nudges, step_size=0.2):\n",
        "        for x in range(n_nudges):\n",
        "            anims = [\n",
        "                vect.animate.put_start_and_end_on(\n",
        "                    self.axes.get_origin(),\n",
        "                    interpolate(vect.get_end(), self.axes.c2p(*embedding), step_size)\n",
        "                )\n",
        "                for vect, embedding in zip(word_vects, true_embeddings)\n",
        "            ]\n",
        "            self.play(*anims, run_time=0.5)\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class KingQueenExample(Word2VecScene):\n",
        "    default_frame_orientation = (20, 70)\n",
        "\n",
        "    def get_basis(self, model):\n",
        "        basis = super().get_basis(model)\n",
        "        basis[1] *= 2\n",
        "        return basis\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes and frame\n",
        "        axes = self.axes\n",
        "        frame = self.frame\n",
        "        self.add_plane()\n",
        "        self.plane.rotate(90 * DEGREES, LEFT)\n",
        "        frame.reorient(-178, 9, 178, (2.15, 1.12, 0.56), 6.84)\n",
        "\n",
        "        # Initial word vectors\n",
        "        words = [\"man\", \"woman\", \"king\", \"queen\"]\n",
        "        colors = [BLUE_B, RED_B, BLUE_D, RED_D]\n",
        "        directions = [UR, RIGHT, UR, LEFT]\n",
        "        all_coords = np.array([self.basis @ self.model[word] for word in words])\n",
        "        all_coords[:2] += DOWN\n",
        "        all_coords[2:] += 4 * LEFT + 1 * DOWN + IN\n",
        "\n",
        "        label_config = dict(\n",
        "            font_size=30,\n",
        "            label_rotation=0,\n",
        "        )\n",
        "        man, woman, king, queen = word_vects = [\n",
        "            self.get_labeled_vector(\n",
        "                word,\n",
        "                coords=coords,\n",
        "                color=color,\n",
        "                buff=0.05,\n",
        "                direction=direction,\n",
        "                label_config=label_config,\n",
        "            )\n",
        "            for word, color, direction, coords in zip(words, colors, directions, all_coords)\n",
        "        ]\n",
        "        woman.label.shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        fake_queen_coords = all_coords[2] - all_coords[0] + all_coords[1]  # Tweak queen for demo purposes\n",
        "        fake_queen = self.get_labeled_vector(\n",
        "            \"queen\", fake_queen_coords,\n",
        "            color=colors[3],\n",
        "            label_config=label_config,\n",
        "        )\n",
        "        fake_queen.label.shift(0.1 * LEFT + 0.2 * DOWN)\n",
        "\n",
        "        # Equation\n",
        "        equation = self.get_equation1(\"queen\", \"king\", \"woman\", \"man\")\n",
        "        equation.set_x(0)\n",
        "        eq, minus1, ek, approx, ew, minus2, em = equation\n",
        "        top_rect = FullScreenFadeRectangle().set_fill(BLACK, 1)\n",
        "        top_rect.set_height(1.5, about_edge=UP, stretch=True)\n",
        "        top_rect.fix_in_frame()\n",
        "\n",
        "        for part, vect in zip([em, ew, ek, eq], word_vects):\n",
        "            part.set_fill(vect.get_color())\n",
        "\n",
        "        # Show man and woman vectors\n",
        "        diff = Arrow(man.get_end(), woman.get_end(), buff=0, stroke_color=YELLOW)\n",
        "        diff.set_fill(YELLOW, opacity=0.8)\n",
        "        diff.set_backstroke(BLACK, 3)\n",
        "        self.play(\n",
        "            LaggedStart(*map(Write, [ew, minus2, em])),\n",
        "            GrowArrow(woman),\n",
        "            FadeInFromPoint(woman.label, man.get_center()),\n",
        "            GrowArrow(man),\n",
        "            FadeInFromPoint(man.label, man.get_center()),\n",
        "            frame.animate.reorient(0, 0, 0, (2.04, 2.06, 0.38), 4.76).set_anim_args(run_time=6)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(diff, time_span=(1, 3)),\n",
        "            frame.animate.reorient(-179, 19, 179, (2.49, 1.96, 0.4), 4.76),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Show king and fake queen\n",
        "        self.add(top_rect, *equation)\n",
        "        new_diff = diff.copy()\n",
        "        new_diff.shift(king.get_end() - man.get_end())\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(top_rect),\n",
        "            *map(Write, [eq, minus1, ek, approx]),\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(man, king),\n",
        "                TransformFromCopy(man.label, king.label),\n",
        "                TransformFromCopy(woman, fake_queen),\n",
        "                TransformFromCopy(woman.label, fake_queen.label),\n",
        "            ),\n",
        "            TransformFromCopy(diff, new_diff, time_span=(2, 3)),\n",
        "            frame.animate.reorient(0, 2, 0, (0.04, 1.96, -0.13), 5.51).set_anim_args(run_time=3)\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-110, 10, 110, (0.22, 1.6, -0.07), 6.72),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "        # Rearrange the equation\n",
        "        for mob in [ek, approx]:\n",
        "            mob.target = mob.generate_target()\n",
        "        approx.target.move_to(minus1, LEFT)\n",
        "        ek.target.next_to(approx.target, RIGHT)\n",
        "        minus1.target = Tex(\"+\").next_to(ek.target, RIGHT, SMALL_BUFF)\n",
        "        minus1.target.move_to(midpoint(ek.target.get_right(), ew.get_left()))\n",
        "        minus1.target.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(fake_queen),\n",
        "            FadeOut(fake_queen.label),\n",
        "            FadeOut(new_diff),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, [minus1, ek, approx], path_arc=PI / 2)\n",
        "        )\n",
        "        self.play(FlashAround(VGroup(ek, em), run_time=3, time_width=1.5))\n",
        "        self.play(TransformFromCopy(diff, new_diff))\n",
        "\n",
        "        # Search near tip\n",
        "        n_circs = 5\n",
        "        src_circles = Circle(radius=1e-2).set_stroke(width=5, opacity=1).replicate(n_circs)\n",
        "        trg_circles = Circle(radius=1).set_stroke(width=0, opacity=1).replicate(n_circs)\n",
        "        circs = VGroup(src_circles, trg_circles)\n",
        "        circs.set_stroke(WHITE)\n",
        "        circs.move_to(new_diff.get_end())\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                Transform(src, trg)\n",
        "                for src, trg in zip(src_circles, trg_circles)\n",
        "            ), lag_ratio=0.15, run_time=3)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(fake_queen),\n",
        "            FadeIn(fake_queen.label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Correct it\n",
        "        self.play(\n",
        "            TransformFromCopy(fake_queen, queen),\n",
        "            TransformFromCopy(fake_queen.label, queen.label),\n",
        "            VGroup(fake_queen, fake_queen.label).animate.set_opacity(0.2),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(fake_queen),\n",
        "            FadeOut(fake_queen.label),\n",
        "            frame.animate.reorient(103, 9, -101, (0.01, 1.45, 0.07), 6.72),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "        # Show a few other examples\n",
        "        word_pairs = [\n",
        "            (\"uncle\", \"aunt\"),\n",
        "            (\"brother\", \"sister\"),\n",
        "            (\"nephew\", \"niece\"),\n",
        "            (\"father\", \"mother\"),\n",
        "            (\"son\", \"daughter\"),\n",
        "        ]\n",
        "        turn_animation_into_updater(\n",
        "            ApplyMethod(frame.reorient, -116, 21, 114, (0.37, 1.45, 0.23), 7.59, run_time=12)\n",
        "        )\n",
        "\n",
        "        last_group = VGroup(king, queen, king.label, queen.label, new_diff)\n",
        "        last_equation = equation\n",
        "        for word1, word2 in word_pairs:\n",
        "            new_coords = np.array([self.basis @ self.model[w] for w in [word1, word2]])\n",
        "            adj_point = np.array([\n",
        "                np.random.uniform(-5, 0),\n",
        "                np.random.uniform(2, 4),\n",
        "                np.random.uniform(-3, 3),\n",
        "            ])\n",
        "            new_coords += (adj_point - new_coords[0])\n",
        "            vect1 = self.get_labeled_vector(word1, color=colors[2], label_config=label_config, coords=new_coords[0])\n",
        "            vect2 = self.get_labeled_vector(word2, color=colors[3], label_config=label_config, coords=new_coords[1])\n",
        "            vect2.put_start_and_end_on(ORIGIN, vect1.get_end() + diff.get_vector() + np.random.uniform(-0.1, 0.1, 3))\n",
        "            vect2.label.next_to(vect2.get_end(), LEFT)\n",
        "\n",
        "            new_equation = self.get_equation1(word2, word1, \"woman\", \"man\")\n",
        "            new_equation.move_to(equation, RIGHT)\n",
        "            new_equation.match_style(equation)\n",
        "            new_equation.set_fill(opacity=1)\n",
        "            new_equation.fix_in_frame()\n",
        "\n",
        "            diff_copy = diff.copy()\n",
        "            diff_copy.shift(vect1.get_end() - diff_copy.get_start())\n",
        "\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    FadeOut(last_group),\n",
        "                    GrowArrow(vect1),\n",
        "                    FadeIn(vect1.label),\n",
        "                    GrowArrow(vect2),\n",
        "                    FadeIn(vect2.label),\n",
        "                ),\n",
        "                *(\n",
        "                    FadeTransform(sm1, sm2)\n",
        "                    for sm1, sm2 in zip(last_equation, new_equation)\n",
        "                ),\n",
        "            )\n",
        "            self.play(TransformFromCopy(diff, diff_copy))\n",
        "            self.wait(2)\n",
        "\n",
        "            last_equation = new_equation\n",
        "            last_group = VGroup(vect1, vect2, vect1.label, vect2.label, diff_copy)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Flash in direction\n",
        "        vect = diff.get_vector()\n",
        "        color = YELLOW\n",
        "        lines = Line(ORIGIN, 2 * normalize(vect)).replicate(200)\n",
        "        lines.insert_n_curves(20)\n",
        "        lines.set_stroke(color, 3)\n",
        "        for line in lines:\n",
        "            line.move_to(np.random.uniform(-3, 3, 3))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                VShowPassingFlash, lines,\n",
        "                lag_ratio=1 / len(lines),\n",
        "                run_time=4\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def get_labeled_vector(self, *args, **kwargs):\n",
        "        kwargs.update(func_name = None)\n",
        "        kwargs.update(thickness=3)\n",
        "        return super().get_labeled_vector(*args, **kwargs)\n",
        "\n",
        "    def get_equation1(self, word1, word2, word3, word4, colors=None):\n",
        "        equation = TexText(\n",
        "            # Rf\"E({word1}) - E({word2}) $\\approx$ E({word3}) - E({word4})\",\n",
        "            Rf\"{{{word1}}} - {{{word2}}} $\\approx$ {{{word3}}} - {{{word4}}}\",\n",
        "            font_size=48\n",
        "        )\n",
        "        equation.fix_in_frame(True)\n",
        "        equation.to_corner(UR)\n",
        "        if colors:\n",
        "            words = [word1, word2, word3, word4]\n",
        "            for word, color in zip(words, colors):\n",
        "                equation[word].set_fill(color)\n",
        "        pieces = VGroup(\n",
        "            equation[f\"{{{word1}}}\"][0],\n",
        "            equation[\"-\"][0],\n",
        "            equation[f\"{{{word2}}}\"][0],\n",
        "            equation[R\"$\\approx$\"][0],\n",
        "            equation[f\"{{{word3}}}\"][0],\n",
        "            equation[\"-\"][1],\n",
        "            equation[f\"{{{word4}}}\"][0],\n",
        "        )\n",
        "        pieces.fix_in_frame(True)\n",
        "        return pieces\n",
        "\n",
        "    def get_equation2(self, word1, word2, word3, word4, colors=None):\n",
        "        equation = TexText(\n",
        "            # Rf\"E({word1}) + E({word2}) - E({word3}) $\\approx$ E({word4})\",\n",
        "            Rf\"{{{word1}}} + {{{word2}}} - {{{word3}}} $\\approx$ {{{word4}}}\",\n",
        "            font_size=48\n",
        "        )\n",
        "        equation.fix_in_frame(True)\n",
        "        equation.to_corner(UR)\n",
        "        if colors:\n",
        "            words = [word1, word2, word3, word4]\n",
        "            for word, color in zip(words, colors):\n",
        "                equation[word].set_fill(color)\n",
        "        pieces = VGroup(\n",
        "            equation[f\"{{{word1}}}\"],\n",
        "            equation[\"+\"],\n",
        "            equation[f\"{{{word2}}}\"],\n",
        "            equation[\"-\"],\n",
        "            equation[f\"{{{word3}}}\"],\n",
        "            equation[R\"$\\approx$ \"],\n",
        "            equation[f\"{{{word4}}}\"],\n",
        "        )\n",
        "        pieces.fix_in_frame(True)\n",
        "        return pieces\n",
        "\n",
        "\n",
        "class HitlerMussoliniExample(KingQueenExample):\n",
        "    words = [\"Hitler\", \"Italy\", \"Germany\", \"Mussolini\"]\n",
        "    colors = [GREY_C, \"#008C45\", \"#FFCC00\", GREY_B]\n",
        "    default_frame_orientation = (-17, 75, 0)\n",
        "    second_frame_orientation = (-24, 66, 0)\n",
        "    interpolation_factor = 0.2\n",
        "    diff_color = RED_B\n",
        "\n",
        "    def get_basis(self, model):\n",
        "        v1, v2, v3, v4 = [model[word.lower()] for word in self.words]\n",
        "        b1 = normalize(v2 - v3)\n",
        "        b2 = normalize(v1 - v3)\n",
        "        b3 = normalize(get_principle_components(model.vectors)[:, 0])\n",
        "        return np.array([b1, b2, b3])\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        frame = self.frame\n",
        "        frame.move_to(1.0 * UP)\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(dt * 1 * DEGREES))\n",
        "        axes = self.axes\n",
        "\n",
        "        # Add equation\n",
        "        equation = self.get_equation2(*self.words, colors=self.colors)\n",
        "        equation.center().to_edge(UP)\n",
        "        self.add(equation[:-1])\n",
        "\n",
        "        # Initialize vectors\n",
        "        v1, v2, v3, v4 = vects = [\n",
        "            self.get_labeled_vector(word, color=color)\n",
        "            for word, color in zip(self.words, self.colors)\n",
        "        ]\n",
        "        fudged_v4 = self.get_labeled_vector(\n",
        "            self.words[3],\n",
        "            axes.p2c(interpolate(\n",
        "                v1.get_end() + v2.get_end() - v3.get_end(),\n",
        "                v4.get_end(),\n",
        "                self.interpolation_factor,\n",
        "            )),\n",
        "            color=self.colors[3]\n",
        "        )\n",
        "        vects[3] = fudged_v4\n",
        "        for vect in vects:\n",
        "            vect.apply_depth_test()\n",
        "\n",
        "        # Show (v3 - v2) difference\n",
        "        diff = Arrow(\n",
        "            v3.get_end(), v2.get_end(),\n",
        "            buff=0,\n",
        "            stroke_color=self.diff_color,\n",
        "            stroke_width=2,\n",
        "            flat_stroke=False,\n",
        "        )\n",
        "        diff.apply_depth_test()\n",
        "        rect = SurroundingRectangle(equation[2:5])\n",
        "        rect.set_stroke(diff.get_stroke_color(), 2)\n",
        "        self.play(\n",
        "            GrowArrow(v2),\n",
        "            GrowArrow(v3),\n",
        "            FadeIn(v2.label),\n",
        "            FadeIn(v3.label),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Transform(v3.copy(), v2, remover=True),\n",
        "            ShowCreation(diff)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Add to v1\n",
        "        diff_copy = diff.copy()\n",
        "        diff_copy.shift(v1.get_end() - diff.get_start())\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(v1),\n",
        "            FadeIn(v1.label),\n",
        "            frame.animate.reorient(*self.second_frame_orientation),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(diff, diff_copy),\n",
        "            rect.animate.surround(equation[:5])\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            rect.animate.surround(equation[-1]),\n",
        "            FadeIn(equation[-1]),\n",
        "            GrowArrow(fudged_v4),\n",
        "            FadeIn(fudged_v4.label),\n",
        "        )\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait(6)\n",
        "\n",
        "        # Emphasize directions\n",
        "        italy_vect = diff.get_vector()\n",
        "        axis_vect = v1.get_end() - v3.get_end()\n",
        "        for vect, color in [(italy_vect, RED), (axis_vect, GREY)]:\n",
        "            lines = Line(ORIGIN, 2 * normalize(vect)).replicate(200)\n",
        "            lines.insert_n_curves(20)\n",
        "            lines.set_stroke(color, 3)\n",
        "            for line in lines:\n",
        "                line.move_to(np.random.uniform(-3, 3, 3))\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    VShowPassingFlash, lines,\n",
        "                    lag_ratio=1 / len(lines),\n",
        "                    run_time=4\n",
        "                )\n",
        "            )\n",
        "\n",
        "\n",
        "class SushiBratwurstExample(HitlerMussoliniExample):\n",
        "    words = [\"Sushi\", \"Germany\", \"Japan\", \"Bratwurst\"]\n",
        "    colors = [WHITE, \"#FFCC00\", \"#BC002D\", interpolate_color(GREY_BROWN, WHITE, 0.25)]\n",
        "    interpolation_factor = -0.1\n",
        "    default_frame_orientation = (-17, 80, 0)\n",
        "    second_frame_orientation = (-24, 75, 0)\n",
        "    diff_color = GREY_B\n",
        "\n",
        "    def get_basis(self, model):\n",
        "        basis = super().get_basis(model)\n",
        "        basis = basis[[1, 2, 0]]\n",
        "        basis[1] /= -2\n",
        "        basis[2] /= 3\n",
        "        return basis\n",
        "\n",
        "\n",
        "class SizeDirection(Word2VecScene):\n",
        "    def construct(self):\n",
        "        # To illustrate \"You could imagine many other directions in this space corresponding to semantic meaning\"\n",
        "\n",
        "        # Set up axes\n",
        "        axes = self.axes\n",
        "        frame = self.frame\n",
        "        self.basis *= 1.5\n",
        "\n",
        "        # Add vectors\n",
        "        frame.reorient(35, 80, 0)\n",
        "        colors = [BLUE_B, BLUE_C, BLUE_D]\n",
        "        word_lists = [\n",
        "            [\"micrometer\", \"millimeter\", \"meter\"],\n",
        "            [\"microgram\", \"milligram\", \"gram\"],\n",
        "            [\"microliter\", \"milliliter\", \"liter\"],\n",
        "        ]\n",
        "        vect_groups = VGroup(\n",
        "            VGroup(\n",
        "                self.get_labeled_vector(word, color=color, func_name=None)\n",
        "                for word, color in zip(word_list, colors)\n",
        "            )\n",
        "            for word_list in word_lists\n",
        "        )\n",
        "\n",
        "        over_arrow = Arrow(2 * LEFT, 2 * RIGHT).shift(UP)\n",
        "        over_arrow.set_stroke(YELLOW, width=10)\n",
        "        over_words = Text(\"Size\", font_size=72)\n",
        "        over_words.set_color(YELLOW)\n",
        "        over_words.set_backstroke(BLACK, 5)\n",
        "        over_words.next_to(over_arrow, UP)\n",
        "        annotation = VGroup(over_arrow, over_words)\n",
        "        annotation.shift(LEFT)\n",
        "        annotation.fix_in_frame()\n",
        "\n",
        "        for vect_group in vect_groups:\n",
        "            vect_group.labels = VGroup()\n",
        "            for vect in vect_group:\n",
        "                vect.label.rotate(45 * DEGREES, OUT)\n",
        "                vect.label.next_to(vect.get_end(), normalize(vect.get_vector()), SMALL_BUFF)\n",
        "                vect_group.labels.add(vect.label)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(49, 87, 0),\n",
        "            LaggedStartMap(FadeIn, vect_groups[0], lag_ratio=0.25),\n",
        "            LaggedStartMap(FadeIn, vect_groups[0].labels, lag_ratio=0.25),\n",
        "            FadeIn(annotation, lag_ratio=0.1, time_span=(2, 3)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in [0, 1]:\n",
        "            self.play(\n",
        "                ReplacementTransform(vect_groups[i], vect_groups[i + 1]),\n",
        "                ReplacementTransform(vect_groups[i].labels, vect_groups[i + 1].labels),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class PluralityDirection(Word2VecScene):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.axes.x_axis.set_stroke(opacity=0)\n",
        "        self.axes.y_axis.set_stroke(opacity=0)\n",
        "\n",
        "        # Test\n",
        "        self.frame.reorient(-21, 77, 0, (1.97, -0.73, 0.54), 3.67)\n",
        "        self.frame.add_updater(lambda m, dt: m.increment_theta(dt * DEGREES))\n",
        "        words = [\"cat\", \"cats\"]\n",
        "        all_coords = 2 * np.array([self.basis @ self.model[word] for word in words])\n",
        "        colors = [BLUE, RED]\n",
        "        cat, cats = [\n",
        "            self.get_labeled_vector(\n",
        "                word,\n",
        "                coords=coords,\n",
        "                color=color,\n",
        "                buff=0.05,\n",
        "            )\n",
        "            for word, color, coords in zip(words, colors, all_coords)\n",
        "        ]\n",
        "        diff = Arrow(cat.get_end(), cats.get_end(), buff=0)\n",
        "        diff.set_color(YELLOW)\n",
        "\n",
        "        self.add(cat, cats)\n",
        "        self.add(cat.label, cats.label)\n",
        "\n",
        "        self.wait(5)\n",
        "        self.play(ShowCreation(diff))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ShowNearestNeighbors(Word2VecScene):\n",
        "    seed_word = \"tower\"\n",
        "    color = YELLOW\n",
        "    n_shown = 10\n",
        "    frame_height = 4\n",
        "    frame_center = (2.18, 0.09, 0.72)\n",
        "    frame_orientation = (-21, 87, 0)\n",
        "    wait_time_per_example = 0.5\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        frame.reorient(*self.frame_orientation, self.frame_center, self.frame_height)\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(dt * DEGREES))\n",
        "        self.add_plane()\n",
        "\n",
        "        # Add seed\n",
        "        word = self.seed_word.lower()\n",
        "        seed_vect = self.get_labeled_vector(word, color=self.color)\n",
        "        seed_group = VGroup(seed_vect, seed_vect.label)\n",
        "        self.add(seed_group)\n",
        "\n",
        "        # Add neighbors\n",
        "        nearest_words = self.get_nearest_words(word)\n",
        "        neighbors = VGroup(*(\n",
        "            self.get_labeled_vector(\n",
        "                word,\n",
        "                # coords=seed_vect.get_end() + np.random.uniform(-0.5, 0.5, 3),\n",
        "                color=WHITE\n",
        "            )\n",
        "            for word in nearest_words\n",
        "        ))\n",
        "        for neighbor in neighbors:\n",
        "            neighbor.label.scale(0.75, about_edge=LEFT)\n",
        "            neighbor.label.set_fill(border_width=0)\n",
        "            neighbor.add(neighbor.label)\n",
        "\n",
        "        # Description\n",
        "        title = Text(f\"Embeddings closest to E({self.seed_word})\")\n",
        "        underline = Underline(title)\n",
        "        items = VGroup(*(\n",
        "            Text(f\"E({word})\", font_size=36)\n",
        "            for word in nearest_words\n",
        "        ))\n",
        "        items.arrange(DOWN, aligned_edge=LEFT)\n",
        "        items.next_to(underline, DOWN, buff=0.5)\n",
        "        items.align_to(title[\"E\"][-1], LEFT)\n",
        "        items.set_backstroke(BLACK, 8)\n",
        "\n",
        "        desc = VGroup(title, underline, items)\n",
        "        desc.fix_in_frame()\n",
        "        desc.to_corner(UR)\n",
        "\n",
        "        self.add(title, underline)\n",
        "\n",
        "        # Add them all\n",
        "        last_neighbor = VectorizedPoint()\n",
        "        for item, neighbor in zip(items, neighbors):\n",
        "            faded_last_neighbor = last_neighbor.copy()\n",
        "            faded_last_neighbor.set_opacity(0.2)\n",
        "            self.add(faded_last_neighbor, seed_group, neighbor)\n",
        "            self.play(\n",
        "                FadeIn(item),\n",
        "                FadeIn(neighbor),\n",
        "                FadeOut(last_neighbor),\n",
        "                FadeIn(faded_last_neighbor),\n",
        "            )\n",
        "            last_neighbor = neighbor\n",
        "            self.wait(self.wait_time_per_example)\n",
        "        self.play(last_neighbor.animate.set_opacity(0.2))\n",
        "\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_nearest_words(self, word):\n",
        "        return find_nearest_words(self.model, self.model[word], self.n_shown + 1)[1:]\n",
        "\n",
        "    def animate_in_neighbors(self, neighbors):\n",
        "        # Old\n",
        "        to_fade = VGroup()\n",
        "        for neighbor in neighbors:\n",
        "            neighbor.label.set_fill(border_width=0)\n",
        "            self.add(to_fade, neighbor.label, seed_vect, seed_vect.label)\n",
        "            self.play(\n",
        "                FadeIn(neighbor),\n",
        "                FadeIn(neighbor.label),\n",
        "                to_fade.animate.set_opacity(0.25),\n",
        "            )\n",
        "            to_fade = VGroup(neighbor, neighbor.label)\n",
        "        self.add(to_fade, neighbor.label, seed_vect, seed_vect.label)\n",
        "        self.play(to_fade.animate.set_opacity(0.2))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ShowNearestNeighborsToWikipedia(ShowNearestNeighbors):\n",
        "    seed_word = \"wikipedia\"\n",
        "    color = BLUE\n",
        "    default_frame_orientation = (10, 70)\n",
        "\n",
        "\n",
        "class ShowNearestNeighborsToCat(ShowNearestNeighbors):\n",
        "    seed_word = \"cat\"\n",
        "    color = YELLOW\n",
        "\n",
        "\n",
        "class ShowNearestNeighborsToNavy(ShowNearestNeighbors):\n",
        "    seed_word = \"navy\"\n",
        "    color = RED\n",
        "\n",
        "\n",
        "class ShowNearestNeighborsToJump(ShowNearestNeighbors):\n",
        "    seed_word = \"jump\"\n",
        "    color = BLUE\n",
        "    wait_time_per_example = 1.0\n",
        "    frame_center = (2.18, -2.0, 0.0)\n",
        "    random_seed = 1\n",
        "\n",
        "    def add_plane(self):\n",
        "        return VGroup()\n",
        "\n",
        "    def get_nearest_words(self, word):\n",
        "        return [\"hop\", \"skip\", \"leap\", \"bound\", \"bounce\", \"drop\", \"vault\"]\n",
        "\n",
        "\n",
        "class DotProducts(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add vectors\n",
        "        plane = NumberPlane(\n",
        "            (-4, 4), (-4, 4),\n",
        "            background_line_style=dict(\n",
        "                stroke_width=2,\n",
        "                stroke_opacity=0.5,\n",
        "                stroke_color=BLUE,\n",
        "            ),\n",
        "            faded_line_ratio=1\n",
        "        )\n",
        "        plane.set_height(6)\n",
        "        plane.to_edge(LEFT, buff=0)\n",
        "        vects = VGroup(\n",
        "            Vector(0.5 * RIGHT + 2 * UP).set_stroke(MAROON_B, 6),\n",
        "            Vector(1.0 * RIGHT + 0.5 * UP).set_stroke(YELLOW, 6),\n",
        "        )\n",
        "        vects.shift(plane.get_center())\n",
        "\n",
        "        def get_dot_product():\n",
        "            coords = np.array([plane.p2c(v.get_end()) for v in vects])\n",
        "            return np.dot(coords[0], coords[1])\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(vects)\n",
        "\n",
        "        # Vector labels\n",
        "        vect_labels = VGroup(*(\n",
        "            Tex(Rf\"\\vec{{\\textbf{{ {char} }} }}\")\n",
        "            for char in \"vw\"\n",
        "        ))\n",
        "        for label, vect in zip(vect_labels, vects):\n",
        "            label.vect = vect\n",
        "            label.match_color(vect)\n",
        "            label.add_updater(lambda l: l.move_to(\n",
        "                l.vect.get_end() + 0.25 * normalize(l.vect.get_vector())\n",
        "            ))\n",
        "\n",
        "        self.add(vect_labels)\n",
        "\n",
        "        # Add coordinate expressions\n",
        "        vect_coords = VGroup(*(\n",
        "            TexMatrix(\n",
        "                [\n",
        "                    [char + f\"_{{{str(n)}}}\"]\n",
        "                    for n in [1, 2, 3, 4, \"n\"]\n",
        "                ],\n",
        "                bracket_h_buff=0.1,\n",
        "                ellipses_row=-2,\n",
        "            )\n",
        "            for char in \"vw\"\n",
        "        ))\n",
        "        vect_coords.arrange(RIGHT, buff=0.75)\n",
        "        vect_coords.next_to(plane, RIGHT, buff=1)\n",
        "        vect_coords.set_y(1)\n",
        "        for coords, vect in zip(vect_coords, vects):\n",
        "            coords.get_entries().match_color(vect)\n",
        "        dot = Tex(R\"\\cdot\", font_size=72)\n",
        "        dot.move_to(vect_coords)\n",
        "\n",
        "        self.add(vect_coords, dot)\n",
        "\n",
        "        # Add right hand side\n",
        "        rhs = Tex(\"= +0.00\", font_size=60)\n",
        "        rhs.next_to(vect_coords, RIGHT)\n",
        "        result = rhs.make_number_changeable(\"+0.00\", include_sign=True)\n",
        "        result.add_updater(lambda m: m.set_value(get_dot_product()))\n",
        "\n",
        "        self.add(rhs)\n",
        "\n",
        "        # Add dot product label\n",
        "        brace = Brace(vect_coords, DOWN, buff=0.25)\n",
        "        dp_label = brace.get_text(\"Dot product\", buff=0.25)\n",
        "\n",
        "        self.add(brace, dp_label)\n",
        "\n",
        "        # Play around\n",
        "        def dual_rotate(angle1, angle2, run_time=2):\n",
        "            self.play(\n",
        "                Rotate(vects[0], angle1 * DEGREES, about_point=plane.get_origin()),\n",
        "                Rotate(vects[1], angle2 * DEGREES, about_point=plane.get_origin()),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "        dual_rotate(-20, 20)\n",
        "        dual_rotate(50, -60)\n",
        "        dual_rotate(0, 80)\n",
        "        dual_rotate(20, -80)\n",
        "\n",
        "        # Show computation\n",
        "        equals = rhs[0].copy()\n",
        "        entry_pairs = VGroup(*(\n",
        "            VGroup(*pair)\n",
        "            for pair in zip(*[vc.get_columns()[0] for vc in vect_coords])\n",
        "        ))\n",
        "        prod_terms = entry_pairs.copy()\n",
        "        for src_pair, trg_pair in zip(entry_pairs, prod_terms):\n",
        "            trg_pair.arrange(RIGHT, buff=0.1)\n",
        "            trg_pair.next_to(equals, RIGHT, buff=0.5)\n",
        "            trg_pair.match_y(src_pair)\n",
        "        prod_terms[-2].space_out_submobjects(1e-3)\n",
        "        prod_terms[-2].match_x(prod_terms)\n",
        "        prod_terms.target = prod_terms.generate_target()\n",
        "        prod_terms.target.space_out_submobjects(1.5).match_y(vect_coords)\n",
        "        plusses = VGroup(*(\n",
        "            Tex(\"+\", font_size=48).move_to(midpoint(m1.get_bottom(), m2.get_top()))\n",
        "            for m1, m2 in zip(prod_terms.target, prod_terms.target[1:])\n",
        "        ))\n",
        "\n",
        "        rhs.target = rhs.generate_target()\n",
        "        rhs.target[0].rotate(PI / 2)\n",
        "        rhs.target.arrange(DOWN)\n",
        "        rhs.target.next_to(prod_terms, DOWN)\n",
        "\n",
        "        self.add(equals)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(m1, m2)\n",
        "                for m1, m2 in zip(entry_pairs, prod_terms)\n",
        "            ), lag_ratio=0.1, run_time=2),\n",
        "            MoveToTarget(rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(prod_terms),\n",
        "            rhs.animate.next_to(prod_terms.target, DOWN),\n",
        "            LaggedStartMap(Write, plusses),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Positive value\n",
        "        dual_rotate(-65, 65)\n",
        "        self.play(FlashAround(result, time_width=1.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Orthogonal\n",
        "        elbow = Elbow(width=0.25, angle=vects[0].get_angle())\n",
        "        elbow.shift(plane.get_origin())\n",
        "        zero = DecimalNumber(0)\n",
        "        zero.replace(result, 1)\n",
        "        dual_rotate(\n",
        "            (vects[1].get_angle() + PI / 2 - vects[0].get_angle()) / DEGREES,\n",
        "            0,\n",
        "        )\n",
        "        self.remove(result)\n",
        "        self.add(zero)\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.wait()\n",
        "        self.remove(elbow, zero)\n",
        "        self.add(result)\n",
        "\n",
        "        # Negative\n",
        "        dual_rotate(20, -60)\n",
        "        self.play(FlashAround(result, time_width=1.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Play again\n",
        "        dual_rotate(75, -95, run_time=8)\n",
        "\n",
        "\n",
        "class DotProductWithPluralDirection(InteractiveScene):\n",
        "    vec_tex = R\"\\vec{\\text{plur}}\"\n",
        "    ref_words = [\"cat\", \"cats\"]\n",
        "    word_groups = [\n",
        "        [\"puppy\", \"puppies\"],\n",
        "        [\"octopus\", \"octopi\", \"octopuses\", \"octopodes\"],\n",
        "        [\"student\", \"students\"],\n",
        "        [\"one\", \"two\", \"three\", \"four\"],\n",
        "    ]\n",
        "    x_range = (-4, 4 + 1e-4, 0.25)\n",
        "    colors = [BLUE, RED]\n",
        "    threshold = -1.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Initialize equation\n",
        "        self.model = get_word_to_vec_model()\n",
        "        word_groups = self.word_groups\n",
        "        words = list(it.chain(*word_groups))\n",
        "\n",
        "        # Write plurality equation\n",
        "        gen_lhs = self.get_equation_lhs(words[0])[0].copy()\n",
        "        equals = Tex(\":=\")\n",
        "        rf1, rf2 = self.ref_words\n",
        "        rhs = Tex(\n",
        "            Rf\"E(\\text{{{rf2}}}) - E(\\text{{{rf1}}})\",\n",
        "            tex_to_color_map={\n",
        "                Rf\"\\text{{{ref_word}}}\": color\n",
        "                for ref_word, color in zip(self.ref_words, self.colors)\n",
        "            }\n",
        "        )\n",
        "        top_eq = VGroup(gen_lhs, equals, rhs)\n",
        "        top_eq.arrange(RIGHT)\n",
        "        gen_lhs.align_to(rhs, DOWN)\n",
        "        top_eq.center().to_edge(UP, buff=0.5)\n",
        "\n",
        "        self.play(FadeIn(rhs, UP))\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(equals, 0.5 * LEFT),\n",
        "            FadeIn(gen_lhs, 1.0 * LEFT),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show on number line\n",
        "        x_range = self.x_range\n",
        "        number_line = NumberLine(\n",
        "            x_range,\n",
        "            big_tick_numbers=list(np.arange(*x_range[:2])),\n",
        "            tick_size=0.05,\n",
        "            longer_tick_multiple=3.0,\n",
        "            width=12\n",
        "        )\n",
        "        number_line.rotate(PI / 2)\n",
        "        number_line.add_numbers(\n",
        "            np.arange(*x_range[:2]),\n",
        "            num_decimal_places=1,\n",
        "            font_size=40,\n",
        "            direction=LEFT,\n",
        "        )\n",
        "        number_line.numbers.shift(SMALL_BUFF * LEFT)\n",
        "        number_line.set_max_height(FRAME_HEIGHT - 1)\n",
        "        number_line.to_edge(LEFT, buff=1.0)\n",
        "\n",
        "        eq_lhs = self.get_equation_lhs(words[0])\n",
        "        eq_rhs = self.get_equation_rhs(eq_lhs, words[0])\n",
        "        equation = VGroup(eq_lhs, eq_rhs)\n",
        "        brace = Brace(eq_lhs[2], LEFT, buff=0.1)\n",
        "        brace.next_to(equation, LEFT, SMALL_BUFF, DOWN)\n",
        "        equation_group = VGroup(brace, equation)\n",
        "        dp = eq_rhs.get_value()\n",
        "\n",
        "        word = eq_lhs[2][2:-1]\n",
        "        lil_word = word.copy().scale(0.25)\n",
        "        dot = GlowDot(color=word[0].get_color())\n",
        "        dot.move_to(number_line.n2p(dp))\n",
        "\n",
        "        lil_word.next_to(dot, RIGHT, buff=0)\n",
        "        equation_group.next_to(dot, RIGHT, buff=0, submobject_to_align=brace)\n",
        "\n",
        "        self.play(\n",
        "            top_eq.animate.scale(0.75).to_corner(UR),\n",
        "            TransformFromCopy(gen_lhs, eq_lhs[0]),\n",
        "            FadeIn(eq_lhs[1:], shift=DOWN),\n",
        "            FadeIn(brace, shift=DOWN),\n",
        "            UpdateFromAlphaFunc(\n",
        "                eq_rhs,\n",
        "                lambda m, a: m.set_value(a * dp).next_to(eq_lhs[-1], RIGHT),\n",
        "                run_time=1,\n",
        "            ),\n",
        "            Write(number_line, run_time=1)\n",
        "        )\n",
        "        self.add_dot(word, dot)\n",
        "        self.wait()\n",
        "\n",
        "        # Show some alternate\n",
        "        new_rhs = eq_rhs.copy()\n",
        "        eq_rhs.set_opacity(0)\n",
        "        new_rhs.f_always.set_value(lambda: number_line.p2n(brace.get_center()))\n",
        "        new_rhs.always.next_to(eq_lhs[-1], RIGHT)\n",
        "        self.add(new_rhs)\n",
        "\n",
        "        to_fade = Group(dot)\n",
        "        for word_group in self.word_groups:\n",
        "            for new_word in word_group:\n",
        "                new_dp = self.get_dot_with_key_word(new_word)\n",
        "                nl_point = number_line.n2p(new_dp)\n",
        "                color = self.colors[int(new_dp > self.threshold)]\n",
        "                new_dot = GlowDot(number_line.n2p(new_dp), color=color)\n",
        "                new_lhs = self.get_equation_lhs(new_word)\n",
        "                new_rhs = self.get_equation_rhs(new_lhs, new_word)\n",
        "                new_rhs.set_opacity(0)\n",
        "                new_equation = VGroup(new_lhs, new_rhs)\n",
        "                new_equation.move_to(equation, LEFT)\n",
        "                new_brace = brace.copy()\n",
        "                new_equation_group = VGroup(new_brace, new_equation)\n",
        "                y_shift = new_dot.get_y() - brace.get_y()\n",
        "                new_equation_group.shift(y_shift * UP)\n",
        "\n",
        "                if new_word == word_group[0]:\n",
        "                    added_anim = FadeOut(to_fade)\n",
        "                    to_fade = Group()\n",
        "                else:\n",
        "                    ghost = equation_group.copy()\n",
        "                    ghost.target = ghost.generate_target()\n",
        "                    ghost.target.set_fill(opacity=0.75)\n",
        "                    ghost.target.scale(0.5, about_point=ghost[0].get_left())\n",
        "                    added_anim = MoveToTarget(ghost)\n",
        "                    to_fade.add(ghost)\n",
        "                self.play(\n",
        "                    Transform(equation_group, new_equation_group),\n",
        "                    added_anim,\n",
        "                )\n",
        "                self.add_dot(new_lhs[2][2:-1], new_dot)\n",
        "                to_fade.add(new_dot)\n",
        "\n",
        "    def add_dot(self, word, dot):\n",
        "        self.play(\n",
        "            FadeInFromPoint(dot, word.get_center()),\n",
        "            LaggedStart(\n",
        "                (FadeTransform(char.copy(), dot.copy().set_opacity(0))\n",
        "                for char in word),\n",
        "                lag_ratio=2e-2,\n",
        "                group_type=Group\n",
        "            ),\n",
        "            run_time=1\n",
        "        )\n",
        "\n",
        "    def get_equation_lhs(self, word):\n",
        "        tex_pieces = [\n",
        "            self.vec_tex, R\"\\cdot\", Rf\"E(\\text{{{word}}})\", \"=\"\n",
        "        ]\n",
        "        expression = Tex(\n",
        "            \" \".join(tex_pieces),\n",
        "            tex_to_color_map={self.vec_tex: YELLOW}\n",
        "        )\n",
        "        parts = [\n",
        "            expression[tex_piece][0]\n",
        "            for tex_piece in tex_pieces\n",
        "        ]\n",
        "        gen_part = parts[0]\n",
        "        gen_part[0].set_width(0.75 * gen_part.get_width(), about_edge=DOWN)\n",
        "        gen_part[0].shift(SMALL_BUFF * DOWN)\n",
        "        value = self.get_dot_with_key_word(word)\n",
        "        parts[2][2:-1].set_color(self.colors[int(value > self.threshold)])\n",
        "        return VGroup(*parts)\n",
        "\n",
        "    def get_equation_rhs(self, equation_lhs, word):\n",
        "        rhs = DecimalNumber(self.get_dot_with_key_word(word))\n",
        "        rhs.next_to(equation_lhs[-1], RIGHT)\n",
        "        return rhs\n",
        "\n",
        "    def get_dot_with_key_word(self, word):\n",
        "        if word == \"octopodes\":\n",
        "            return 2.3  # Hack\n",
        "        elif word == \"four\":\n",
        "            return 1.80  # To make the spacing nicer\n",
        "        rf1, rf2 = self.ref_words\n",
        "        return np.dot(\n",
        "            (self.model[rf2] - self.model[rf1]).flatten(),\n",
        "            self.model[word].flatten(),\n",
        "        )\n",
        "\n",
        "\n",
        "class DotProductWithGenderDirection(DotProductWithPluralDirection):\n",
        "    vec_tex = R\"\\vec{\\text{gen}}\"\n",
        "    ref_words = [\"man\", \"woman\"]\n",
        "    words = [\n",
        "        \"mother\", \"father\",\n",
        "        \"aunt\", \"uncle\",\n",
        "        \"sister\", \"brother\",\n",
        "        \"mama\", \"papa\",\n",
        "    ]\n",
        "    x_range = (-5, 7 + 1e-4, 0.25)\n",
        "    colors = [BLUE, RED]\n",
        "    threshold = 1.0\n",
        "\n",
        "\n",
        "class RicherEmbedding(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add phrase\n",
        "        phrase = Text(\"The King doth wake tonight and takes his rouse ...\")\n",
        "        phrase.to_edge(UP)\n",
        "        words = break_into_words(phrase)\n",
        "        rects = get_piece_rectangles(words)\n",
        "        king_index = 1\n",
        "\n",
        "        words.fix_in_frame()\n",
        "        rects.fix_in_frame()\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "        # Setup axes\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "        frame.reorient(9, -6, 0)\n",
        "        axes = ThreeDAxes((-5, 5), (-2, 2), (-5, 5))\n",
        "        axes.shift(DOWN)\n",
        "        plane = NumberPlane(\n",
        "            (-5, 5), (-5, 5),\n",
        "            background_line_style=dict(stroke_width=1, stroke_color=BLUE_E),\n",
        "            faded_line_ratio=1,\n",
        "        )\n",
        "        plane.axes.set_stroke(GREY)\n",
        "        plane.set_flat_stroke(False)\n",
        "        plane.rotate(PI / 2, RIGHT)\n",
        "        plane.move_to(axes)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Embed the word\n",
        "        king_rect = rects[king_index]\n",
        "        vector = Vector([-1, 1, 1])\n",
        "        vector.shift(axes.get_origin())\n",
        "        vector.match_color(king_rect)\n",
        "        vector.set_flat_stroke(False)\n",
        "        label = Text(\"King\", font_size=24)\n",
        "        label.next_to(vector.get_end(), normalize(vector.get_vector()), buff=0.1)\n",
        "\n",
        "        self.play(DrawBorderThenFill(king_rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(words[king_index], label),\n",
        "            GrowArrow(vector),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Mention position\n",
        "        index_labels = VGroup(*(\n",
        "            Integer(n + 1, font_size=36).next_to(rect, DOWN, buff=0.2)\n",
        "            for n, rect in enumerate(rects)\n",
        "        ))\n",
        "        index_labels.fix_in_frame()\n",
        "        idx_vect, idx_label = self.get_added_vector(\n",
        "            vector.get_end(), 0.5 * (RIGHT + OUT), \"Pos. 2\", TEAL,\n",
        "            next_to_direction=UP,\n",
        "            font_size=16\n",
        "        )\n",
        "        idx_label.rotate(45 * DEGREES, DOWN)\n",
        "        idx_label.set_backstroke(BLACK, 1)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, index_labels, shift=0.5 * DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(index_labels[king_index].set_backstroke(), idx_label),\n",
        "            GrowArrow(idx_vect),\n",
        "            frame.animate.reorient(-28, -22, 0).set_anim_args(run_time=3)\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-11, -4, 0),\n",
        "            LaggedStartMap(FadeOut, index_labels, lag_ratio=0.05, shift=0.5 * DOWN, time_span=(6, 7)),\n",
        "            run_time=7\n",
        "        )\n",
        "\n",
        "        # Show king ingesting context\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                ContextAnimation(\n",
        "                    words[king_index],\n",
        "                    [*words[:king_index], *words[king_index + 1:]],\n",
        "                    direction=DOWN,\n",
        "                    fix_in_frame=True,\n",
        "                    time_width=3,\n",
        "                    min_stroke_width=3,\n",
        "                    lag_ratio=0.05,\n",
        "                    path_arc=PI / 3,\n",
        "                )\n",
        "                for n in range(3)\n",
        "            ), lag_ratio=0.5),\n",
        "            frame.animate.reorient(-5, -12, 0),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Knock in many directions\n",
        "        new_labeled_vector_args = [\n",
        "            ([2, 1, 0], \"lived in Scotland\", None, DR),\n",
        "            ([0, -1, -1], \"murdered predecessor\", None, RIGHT),\n",
        "            ([-1.5, 1, -2], \"in Shakespearean language\", None, RIGHT),\n",
        "        ]\n",
        "        new_labeled_vects = VGroup()\n",
        "        last_vect = idx_vect\n",
        "        for args in new_labeled_vector_args:\n",
        "            new_labeled_vects.add(self.get_added_vector(\n",
        "                last_vect.get_end(), *args\n",
        "            ))\n",
        "            last_vect = new_labeled_vects[-1][0]\n",
        "            last_vect.apply_depth_test()\n",
        "\n",
        "\n",
        "        (vect1, label1), (vect2, label2), (vect3, label3) = new_labeled_vects\n",
        "        self.play(\n",
        "            GrowArrow(vect1),\n",
        "            FadeIn(label1, 0.5 * DOWN),\n",
        "            frame.animate.reorient(2, -16, 0, (0.6, -0.04, 0.02), 6.01).set_anim_args(run_time=8),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(vect2),\n",
        "            FadeIn(label2, 0.5 * DOWN),\n",
        "            frame.animate.reorient(35, -23, 0, (0.6, -0.04, 0.02), 6.01).set_anim_args(run_time=5),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(vect3),\n",
        "            FadeIn(label3, 0.5 * DOWN),\n",
        "            frame.animate.reorient(20, -29, 0, (0.61, 0.01, 0.0), 6.10).set_anim_args(run_time=5),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-19, -25, 0, (0.61, 0.01, 0.0), 6.10),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "    def get_added_vector(self, curr_tip, direction, label, color=None, next_to_direction=UP, buff=0.1, font_size=24):\n",
        "        if color is None:\n",
        "            color = random_bright_color(hue_range=(0.45, 0.65))\n",
        "        vect = Vector(direction)\n",
        "        vect.set_color(color)\n",
        "        vect.set_flat_stroke(False)\n",
        "        vect.shift(curr_tip)\n",
        "        text = Text(label, font_size=font_size)\n",
        "        text.set_backstroke(BLACK, 4)\n",
        "        text.next_to(vect.get_center(), next_to_direction, buff=buff)\n",
        "        text.set_fill(border_width=0)\n",
        "\n",
        "        result = VGroup(vect, text)\n",
        "        return result\n",
        "\n",
        "\n",
        "# For chapter 6\n",
        "\n",
        "class MultipleMoleEmbeddings(Word2VecScene):\n",
        "    default_frame_orientation = (0, 0)\n",
        "    label_rotation = 0\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        self.frame.add_ambient_rotation()\n",
        "        self.add_plane()\n",
        "        for mob in [self.plane, self.axes]:\n",
        "            mob.rotate(-90 * DEGREES, RIGHT)\n",
        "\n",
        "    def construct(self):\n",
        "        # Show generic mole embedding\n",
        "        frame = self.frame\n",
        "        frame.reorient(-6, -6, 0, (-0.73, 1.29, -0.57), 5.27)\n",
        "        phrases = VGroup(map(Text, [\n",
        "            \"American shrew mole\",\n",
        "            \"One mole of carbon dioxide\",\n",
        "            \"Take a biopsy of the mole\",\n",
        "        ]))\n",
        "        for phrase in phrases:\n",
        "            phrases.fix_in_frame()\n",
        "            phrases.to_corner(UL)\n",
        "            phrase[\"mole\"][0].set_color(YELLOW)\n",
        "\n",
        "        gen_vector = self.get_labeled_vector(\"mole\", coords=(-2, 1.0, 1.5))\n",
        "        curr_phrase = phrases[1]\n",
        "        mover = curr_phrase[\"mole\"][0]\n",
        "        mover.set_backstroke(BLACK, 4)\n",
        "\n",
        "        self.add(curr_phrase)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(gen_vector),\n",
        "            TransformFromCopy(mover, gen_vector.label),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show three refined meanings\n",
        "        images = Group(\n",
        "            ImageMobject(\"ShrewMole\"),\n",
        "            Tex(R\"6.02 \\times 10^{23}\", font_size=24).set_color(BLUE),\n",
        "            ImageMobject(\"LipMole\"),\n",
        "        )\n",
        "        for image in images[::2]:\n",
        "            image.set_height(0.5)\n",
        "            image.set_opacity(0.75)\n",
        "\n",
        "        colors = [GREY_BROWN, BLUE, ORANGE]\n",
        "        ref_vects = VGroup(\n",
        "            self.get_labeled_vector(\"\", coords=coords)\n",
        "            for coords in [\n",
        "                (-1.0, -1.5, 1.5),\n",
        "                (-4.0, 0.5, 1.0),\n",
        "                (-0.5, 1.0, 2.5),\n",
        "            ]\n",
        "        )\n",
        "        for vect, image, color in zip(ref_vects, images, colors):\n",
        "            vect.set_color(color)\n",
        "            image.next_to(vect.get_end(), UP, SMALL_BUFF)\n",
        "\n",
        "        gen_vect_group = VGroup(gen_vector, gen_vector.label)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-30, -5, 0, (-1.11, 1.35, -0.72), 5.27),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(gen_vector, ref_vect)\n",
        "                for ref_vect in ref_vects),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=2,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (FadeInFromPoint(image, gen_vector.label.get_center())\n",
        "                for image in images),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=2,\n",
        "                group_type=Group,\n",
        "            ),\n",
        "            gen_vect_group.animate.set_opacity(0.25).set_anim_args(run_time=2),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        ref_vect_groups = Group(\n",
        "            Group(*pair) for pair in zip(ref_vects, images)\n",
        "        )\n",
        "\n",
        "        # Oscillate between meanings based on context\n",
        "        diff_vects = VGroup(\n",
        "            Arrow(gen_vector.get_end(), ref_vect.get_end(), buff=0)\n",
        "            for ref_vect in ref_vects\n",
        "        )\n",
        "        diff_vects.set_color(GREY_B)\n",
        "\n",
        "        last_phrase = curr_phrase\n",
        "        last_diff = VGroup()\n",
        "        for n, diff in enumerate(diff_vects):\n",
        "            ref_vect_groups.target = ref_vect_groups.generate_target()\n",
        "            ref_vect_groups.target.set_opacity(0.2)\n",
        "            ref_vect_groups.target[n].set_opacity(1)\n",
        "            if n != 2:\n",
        "                ref_vect_groups.target[2][1].set_opacity(0.1)\n",
        "            phrase = phrases[n]\n",
        "            self.play(\n",
        "                gen_vect_group.animate.set_opacity(1),\n",
        "                MoveToTarget(ref_vect_groups),\n",
        "                FadeOut(last_phrase, UP),\n",
        "                FadeIn(phrase, UP),\n",
        "                FadeOut(last_diff)\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(diff, time_span=(1, 2)),\n",
        "                TransformFromCopy(gen_vector, ref_vects[n], time_span=(1, 2)),\n",
        "                ContextAnimation(\n",
        "                    phrase[\"mole\"][0], phrase,\n",
        "                    direction=DOWN,\n",
        "                    fix_in_frame=True,\n",
        "                ),\n",
        "            )\n",
        "            self.wait(3)\n",
        "\n",
        "            last_phrase = phrase\n",
        "            last_diff = diff\n",
        "\n",
        "        self.wait(5)\n",
        "\n",
        "    def get_basis(self, model):\n",
        "        basis = super().get_basis(model) * 2\n",
        "        basis[2] *= -1\n",
        "        return basis\n",
        "\n",
        "\n",
        "class RefineTowerMeaning(MultipleMoleEmbeddings):\n",
        "    def construct(self):\n",
        "        # Set up vectors and images\n",
        "        frame = self.frame\n",
        "        frame.reorient(-26, -4, 0, (3.27, 1.57, 0.59), 5.28)\n",
        "        frame.add_ambient_rotation(0.5 * DEGREES)\n",
        "\n",
        "        words = VGroup(Text(word) for word in \"Miniature Eiffel Tower\".split(\" \"))\n",
        "        words.scale(1.25)\n",
        "        words.to_edge(UP)\n",
        "        words.fix_in_frame()\n",
        "\n",
        "        tower_images = Group(\n",
        "            ImageMobject(f\"Tower{n}\")\n",
        "            for n in range(1, 5)\n",
        "        )\n",
        "        eiffel_tower_images = Group(\n",
        "            ImageMobject(f\"EiffelTower{n}\")\n",
        "            for n in range(1, 4)\n",
        "        )\n",
        "        mini_eiffel_tower_images = Group(\n",
        "            ImageMobject(\"MiniEiffelTower1\")\n",
        "        )\n",
        "        image_groups = Group(\n",
        "            tower_images,\n",
        "            eiffel_tower_images,\n",
        "            mini_eiffel_tower_images\n",
        "        )\n",
        "\n",
        "        vectors = VGroup(\n",
        "            self.get_labeled_vector(\"\", coords=coords)\n",
        "            for coords in [\n",
        "                (4, -1, 3.0),\n",
        "                (5, -2, 1.5),\n",
        "                (-3, -1, 2.5),\n",
        "            ]\n",
        "        )\n",
        "        colors = [BLUE_D, GREY_B, GREY_C]\n",
        "        for vector, color, image_group in zip(vectors, colors, image_groups):\n",
        "            vector.set_color(color)\n",
        "            for image in image_group:\n",
        "                image.set_height(1.5)\n",
        "                image.next_to(vector.get_end(), RIGHT * np.sign(vector.get_end()[0]))\n",
        "\n",
        "        # Show tower\n",
        "        tower = words[-1]\n",
        "        tower.set_x(0)\n",
        "        pre_tower_image = tower_images[0].copy()\n",
        "        pre_tower_image.fix_in_frame()\n",
        "        pre_tower_image.replace(tower, stretch=True)\n",
        "        pre_tower_image.set_opacity(0)\n",
        "\n",
        "        self.add(tower)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(vectors[0]),\n",
        "            ReplacementTransform(pre_tower_image, tower_images[0]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        for ti1, ti2 in zip(tower_images, tower_images[1:]):\n",
        "            self.play(\n",
        "                FadeTransform(ti1, ti2),\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Eiffel tower\n",
        "        words[:-1].set_opacity(0)\n",
        "        eiffel_tower = words[-2:]\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-4, -7, 0, (2.95, 1.82, 0.49), 6.59),\n",
        "            eiffel_tower.animate.set_opacity(1).arrange(RIGHT, aligned_edge=DOWN).to_edge(UP),\n",
        "        )\n",
        "        self.play(\n",
        "            vectors[0].animate.set_opacity(0.25),\n",
        "            tower_images[-1].animate.set_opacity(0.2),\n",
        "            TransformFromCopy(vectors[0], vectors[1]),\n",
        "            FadeTransform(tower_images[-1].copy(), eiffel_tower_images[0]),\n",
        "            ContextAnimation(words[2], words[1], direction=DOWN, fix_in_frame=True),\n",
        "            run_time=2,\n",
        "        )\n",
        "        for ti1, ti2 in zip(eiffel_tower_images, eiffel_tower_images[1:]):\n",
        "            self.play(\n",
        "                FadeTransform(ti1, ti2),\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Miniature eiffel tower\n",
        "        self.play(\n",
        "            frame.animate.reorient(-14, -2, 0, (-0.12, 2.21, 0.72), 7.05).set_anim_args(run_time=2),\n",
        "            words.animate.set_opacity(1).arrange(RIGHT, aligned_edge=DOWN).to_edge(UP),\n",
        "        )\n",
        "        self.play(\n",
        "            vectors[1].animate.set_opacity(0.25),\n",
        "            eiffel_tower_images[-1].animate.set_opacity(0.2),\n",
        "            TransformFromCopy(vectors[1], vectors[2]),\n",
        "            FadeTransform(eiffel_tower_images[-1].copy(), mini_eiffel_tower_images[0]),\n",
        "            ContextAnimation(words[2], words[0], direction=DOWN, fix_in_frame=True),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class UpdatingPoetryEmbedding(RicherEmbedding):\n",
        "    def construct(self):\n",
        "        # (Largely copied from RicherEmbedding, could factor better later)\n",
        "        # Add phrase\n",
        "        poem_str = \"...\\nTwo roads diverged in a wood, and I\u2014\\nI took the one less traveled by,\"\n",
        "        phrase = Text(poem_str, alignment=\"LEFT\")\n",
        "        phrase[:3].rotate(PI / 2).shift(SMALL_BUFF * UP)\n",
        "        phrase.refresh_bounding_box()\n",
        "        phrase.to_edge(UP, buff=SMALL_BUFF)\n",
        "        words = break_into_words(phrase)\n",
        "        rects = get_piece_rectangles(words)\n",
        "\n",
        "        words.fix_in_frame()\n",
        "        rects.fix_in_frame()\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "        # Setup axes\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "        frame.reorient(9, -6, 0)\n",
        "        frame.reorient(9, -1, 0, 0.75 * UP)\n",
        "        axes = ThreeDAxes((-5, 5), (-2, 2), (-5, 5))\n",
        "        axes.shift(DOWN)\n",
        "        plane = NumberPlane(\n",
        "            (-5, 5), (-5, 5),\n",
        "            background_line_style=dict(stroke_width=1, stroke_color=BLUE_E),\n",
        "            faded_line_ratio=1,\n",
        "        )\n",
        "        plane.axes.set_stroke(GREY)\n",
        "        plane.set_flat_stroke(False)\n",
        "        plane.rotate(PI / 2, RIGHT)\n",
        "        plane.move_to(axes)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Embed the word\n",
        "        one_index = len(words) - 4\n",
        "        one_rect = SurroundingRectangle(words[one_index])\n",
        "        one_rect.set_fill(GREEN, 0.2)\n",
        "        one_rect.set_stroke(GREEN, 2)\n",
        "        one_rect.fix_in_frame()\n",
        "        vector = Vector([-3, 1, 2])\n",
        "        vector.shift(axes.get_origin())\n",
        "        vector.match_color(one_rect)\n",
        "        vector.set_flat_stroke(False)\n",
        "        label = Text(\"one\", font_size=36)\n",
        "        label.next_to(vector.get_end(), normalize(vector.get_vector()), buff=0.1)\n",
        "\n",
        "        self.play(DrawBorderThenFill(one_rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(words[one_index], label),\n",
        "            GrowArrow(vector),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Knock in many directions\n",
        "        new_labeled_vector_args = [\n",
        "            ([2, 1, 0], \"of two roads\", None, UL),\n",
        "            ([2, -1, -1], \"symbolizing choice\", None, UR),\n",
        "            ([0.5, 1, -3], \"contrasting the original\\nwith the familiar\", None, DR),\n",
        "        ]\n",
        "        new_labeled_vects = VGroup()\n",
        "        last_vect = vector\n",
        "        for args in new_labeled_vector_args:\n",
        "            new_labeled_vects.add(self.get_added_vector(\n",
        "                last_vect.get_end(), *args\n",
        "            ))\n",
        "            last_vect = new_labeled_vects[-1][0]\n",
        "            last_vect.apply_depth_test()\n",
        "        orientation_args = [\n",
        "            (-4, -12, 0, (-0.89, 0.03, -0.41), 8.10),\n",
        "            (3, -9, 0, (-0.34, 0.49, -0.63), 8.60),\n",
        "            (34, -14, 0, (-0.59, 0.49, -0.62), 9.20),\n",
        "            (20, -29, 0, (0.61, 0.01, 0.0), 6.10),\n",
        "        ]\n",
        "\n",
        "\n",
        "        for (vect, label), orientation in zip(new_labeled_vects, orientation_args):\n",
        "            self.play(\n",
        "                GrowArrow(vect, time_span=(2, 3)),\n",
        "                FadeIn(label, 0.5 * DOWN, time_span=(2, 3)),\n",
        "                frame.animate.reorient(*orientation).set_anim_args(run_time=6),\n",
        "                ContextAnimation(\n",
        "                    one_rect, phrase[:-16],\n",
        "                    run_time=4,\n",
        "                    fix_in_frame=True,\n",
        "                    path_arc=60 * DEGREES,\n",
        "                    lag_ratio=1e-3,\n",
        "                    direction=UP,\n",
        "                ),\n",
        "            )\n",
        "        self.play(\n",
        "            frame.animate.reorient(22, -23, 0, (-0.86, 0.4, -0.35), 7.15),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "\n",
        "# For chapter 7\n",
        "\n",
        "class SimpleSpaceExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup axes\n",
        "        frame = self.frame\n",
        "        plane, axes = self.add_plane_and_axes()\n",
        "        frame.reorient(14, 77, 0, (2.23, 0.25, 1.13), 4.46)\n",
        "\n",
        "        # Show an initial vector in the space\n",
        "        frame.add_ambient_rotation()\n",
        "        vect = Arrow(axes.c2p(0, 0, 0), axes.c2p(2, -1, 1), buff=0)\n",
        "        vect.set_color(BLUE)\n",
        "        vect.always.set_perpendicular_to_camera(self.frame)\n",
        "        label = Text(\"you\", font_size=24)\n",
        "        # label = Text(\"Photo\", font_size=24).set_backstroke(BLACK, 5)\n",
        "        label.rotate(PI / 2, RIGHT)\n",
        "        label.next_to(vect.get_center(), OUT + LEFT, buff=0)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(vect),\n",
        "            FadeIn(label, vect.get_vector())\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Many directions -> Different kinds of meaning\n",
        "        ideas = VGroup(\n",
        "            Text(\"Part of a command\"),\n",
        "            Text(\"Affectionate\"),\n",
        "            Text(\"Sadness\"),\n",
        "        )\n",
        "        ideas.set_backstroke(BLACK, 3)\n",
        "        ideas.scale(0.35)\n",
        "        ideas.rotate(PI / 2, RIGHT)\n",
        "\n",
        "        last_idea = VGroup()\n",
        "        last_direction = 1.0 * normalize(cross(RIGHT, vect.get_vector()))\n",
        "        for idea in ideas:\n",
        "            direction = rotate_vector(last_direction, PI / 3, vect.get_vector())\n",
        "            new_vect = self.get_added_vector(vect, direction)\n",
        "            new_vect.set_perpendicular_to_camera(self.frame)\n",
        "            idea.next_to(new_vect.get_center(), buff=0.1)\n",
        "            lines = get_direction_lines(axes, new_vect.get_vector(), color=new_vect.get_color())\n",
        "            self.play(\n",
        "                FadeOut(last_idea),\n",
        "                ShowCreation(new_vect),\n",
        "                FadeIn(idea, new_vect.get_vector()),\n",
        "                LaggedStartMap(ShowCreationThenFadeOut, lines, lag_ratio=2 / len(lines), run_time=2)\n",
        "            )\n",
        "            self.wait(1)\n",
        "            last_idea = VGroup(new_vect, idea)\n",
        "            last_direction = direction\n",
        "        self.play(FadeOut(last_idea))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Specific ideas added onto \"you\"\n",
        "        ideas = VGroup(\n",
        "            # Text(\"Astronaut\"),\n",
        "            # Text(\"Riding a Horse\"),\n",
        "            # Text(\"On the moon\"),\n",
        "            #\n",
        "            Text(\"needs an adjective next\"),\n",
        "            Text(\"preceded by \\\"that which does not kill\\\"\"),\n",
        "            Text(\"related to growth and strength\"),\n",
        "            #\n",
        "            # Text(\"River bank\"),\n",
        "            # Text(\"Beginning of a story\"),\n",
        "            # Text(\"Establishing a setting\"),\n",
        "        )\n",
        "        ideas.scale(0.4)\n",
        "        ideas.rotate(PI / 2, RIGHT)\n",
        "        directions = [\n",
        "            (-0.25, -1, 0.75),\n",
        "            (-0.5, -0.25, 0.5),\n",
        "            (1.0, -0.5, 1.0),\n",
        "        ]\n",
        "        orientations = [\n",
        "            (11, 92, 0, (2.69, 0.55, 1.12), 6.25),\n",
        "            (-8, 83, 0, (2.73, 0.56, 1.24), 6.80),\n",
        "            (-14, 79, 0, (2.49, 0.61, 1.41), 7.64),\n",
        "        ]\n",
        "\n",
        "        vects = VGroup(vect)\n",
        "        concepts = VGroup(label)\n",
        "        for idea, direction, orientation in zip(ideas, directions, orientations):\n",
        "            point = vects[-1].get_end()\n",
        "            new_vect = self.get_added_vector(vects[-1], direction)\n",
        "            new_vect.always.set_perpendicular_to_camera(self.frame)\n",
        "            idea.next_to(new_vect.get_center())\n",
        "            self.play(\n",
        "                frame.animate.reorient(*orientation),\n",
        "                GrowArrow(new_vect),\n",
        "                FadeIn(idea, 0.5 * new_vect.get_vector())\n",
        "            )\n",
        "            self.wait(2)\n",
        "            vects.add(new_vect)\n",
        "        self.wait(15)\n",
        "\n",
        "    def add_plane_and_axes(\n",
        "        self,\n",
        "        x_range=(-4, 4),\n",
        "        y_range=(-4, 4),\n",
        "        z_range=(-3, 3),\n",
        "    ):\n",
        "        axes = ThreeDAxes(x_range, y_range, z_range)\n",
        "        plane = NumberPlane(\n",
        "            x_range, y_range,\n",
        "            background_line_style=dict(\n",
        "                stroke_color=GREY_D,\n",
        "                stroke_width=1\n",
        "            ),\n",
        "            faded_line_ratio=1,\n",
        "        )\n",
        "        plane.axes.set_stroke(GREY_D, 0)\n",
        "\n",
        "        self.add(plane, axes)\n",
        "        return plane, axes\n",
        "\n",
        "    def get_added_vector(self, last_vect, direction):\n",
        "        point = last_vect.get_end()\n",
        "        new_vect = Arrow(point, point + direction, buff=0)\n",
        "        new_vect.set_color(random_bright_color())\n",
        "        new_vect.set_flat_stroke(False)\n",
        "        return new_vect\n",
        "\n",
        "\n",
        "class ManyIdeasManyDirections(SimpleSpaceExample):\n",
        "    random_seed = 2\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        frame = self.frame\n",
        "        plane, axes = self.add_plane_and_axes()\n",
        "        frame.reorient(-17, 73, 0, (-0.06, 0.11, 0.31), 6.03)\n",
        "        frame.add_ambient_rotation()\n",
        "\n",
        "        # Many directions -> Different kinds of meaning\n",
        "        ideas = VGroup(\n",
        "            Text(word)\n",
        "            for word in [\n",
        "                \"Typewriter\",\n",
        "                \"Paradigm\",\n",
        "                \"Whimsical\",\n",
        "                \"Gelatinous\",\n",
        "                \"Rainbow\",\n",
        "                \"Serendipitous\",\n",
        "                \"Algorithm\",\n",
        "                \"Nebulous\",\n",
        "                \"Spatula\",\n",
        "                \"Lethargic\",\n",
        "                \"Effervescent\",\n",
        "                \"Asteroid\",\n",
        "                \"Pungent\",\n",
        "                \"Daydream\",\n",
        "                \"Mercurial\",\n",
        "                \"Cactus\",\n",
        "                \"Diaphanous\",\n",
        "                \"Hiccup\",\n",
        "                \"Viscous\",\n",
        "                \"Thunderclap\",\n",
        "            ]\n",
        "        )\n",
        "        ideas.set_backstroke(BLACK, 3)\n",
        "        ideas.scale(0.5)\n",
        "        ideas.rotate(PI / 2, RIGHT)\n",
        "\n",
        "        last_idea = VGroup()\n",
        "        last_direction = RIGHT + OUT\n",
        "        for idea in ideas:\n",
        "            direction = normalize(cross(last_direction, np.random.uniform(-1, 1, 3)))\n",
        "            new_vect = Vector(direction)\n",
        "            new_vect.set_perpendicular_to_camera(self.frame)\n",
        "            new_vect.set_color(random_bright_color())\n",
        "            idea.next_to(new_vect.get_end(), direction, buff=0.1)\n",
        "            lines = get_direction_lines(axes, direction, color=new_vect.get_color(), n_lines=250, stroke_width=2)\n",
        "            idea.set_fill(interpolate_color(new_vect.get_color(), WHITE, 0.5))\n",
        "            self.play(\n",
        "                FadeOut(last_idea),\n",
        "                GrowArrow(new_vect),\n",
        "                FadeIn(idea, new_vect.get_vector()),\n",
        "                LaggedStartMap(ShowCreationThenFadeOut, lines, lag_ratio=1 / len(lines), run_time=1.5)\n",
        "            )\n",
        "            self.wait()\n",
        "            last_idea = VGroup(new_vect, idea)\n",
        "            last_direction = direction\n",
        "        self.play(FadeOut(last_idea))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class MJSpace(SimpleSpaceExample):\n",
        "    def construct(self):\n",
        "        # Set up axes\n",
        "        frame = self.frame\n",
        "        plane, axes = self.add_plane_and_axes()\n",
        "        axes.set_stroke(width=1)\n",
        "        frame.add_ambient_rotation()\n",
        "\n",
        "        # Show vectors landing in the space\n",
        "        sentence = Text(\"Michael Jordan plays the sport of basketball\", font_size=36)\n",
        "        sentence.to_edge(UP)\n",
        "        tokens = break_into_tokens(sentence)\n",
        "        token_rects = get_piece_rectangles(tokens, leading_spaces=True, h_buff=0)\n",
        "        arrs = VGroup(\n",
        "            NumericEmbedding().scale(0.25).next_to(rect, DOWN, buff=1.0)\n",
        "            for rect in token_rects\n",
        "        )\n",
        "        arrows = VGroup(Arrow(rect, arr, buff=0.1) for rect, arr in zip(token_rects, arrs))\n",
        "        vects = VGroup(\n",
        "            Vector(np.random.uniform(-3, 3, 3))\n",
        "            for arr in arrs\n",
        "        )\n",
        "        vects.set_stroke(GREY_B)\n",
        "        vects.fix_in_frame()\n",
        "\n",
        "        VGroup(token_rects, tokens, arrows, arrs).fix_in_frame()\n",
        "\n",
        "        frame.reorient(-18, 86, 0, (0.21, 0.12, 3.56), 11.65)\n",
        "        self.add(token_rects, tokens)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, arrs, shift=DOWN, lag_ratio=0.1),\n",
        "            LaggedStartMap(GrowArrow, arrows, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(11, 76, 0, ORIGIN, FRAME_HEIGHT),\n",
        "            FadeOut(VGroup(token_rects, tokens, arrows), UP, time_span=(1, 2)),\n",
        "            LaggedStart(\n",
        "                (Transform(arrow, vect)\n",
        "                for arrow, vect in zip(arrs, vects)),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.remove(arrs)\n",
        "        self.add(vects)\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            (vect.animate.scale(0, about_point=vect.get_start())\n",
        "            for vect in vects),\n",
        "            lag_ratio=0.05,\n",
        "            remover=True\n",
        "        ))\n",
        "\n",
        "        # Show three directions\n",
        "        colors = [YELLOW, RED, \"#F88158\"]\n",
        "        all_coords = [normalize([-1, -1, 1])]\n",
        "        all_coords.append(normalize(cross(all_coords[0], IN)))\n",
        "        all_coords.append(-normalize(cross(all_coords[0], all_coords[1])))\n",
        "        all_coords = np.array(all_coords)[[0, 2, 1]]\n",
        "        labels = VGroup(*map(Text, [\"First Name Michael\", \"Last Name Jordan\", \"Basketball\"]))\n",
        "        label_directions = [LEFT + OUT, IN, RIGHT + OUT]\n",
        "\n",
        "        vect_groups = VGroup()\n",
        "        vects = VGroup()\n",
        "        for coords, label, color, direction in zip(all_coords, labels, colors, label_directions):\n",
        "            vect = Vector(2.0 * coords)\n",
        "            vect.set_color(color)\n",
        "            vect.always.set_perpendicular_to_camera(self.frame)\n",
        "            label.scale(0.5)\n",
        "            label.rotate(PI / 2, RIGHT)\n",
        "            label.set_color(color)\n",
        "            label.next_to(vect.get_end(), direction, buff=0.1)\n",
        "            label.set_fill(border_width=0.5)\n",
        "            label.set_backstroke(BLACK, 4)\n",
        "            vects.add(vect)\n",
        "            vect_groups.add(VGroup(vect, label))\n",
        "\n",
        "        orientations = [\n",
        "            (17, 76, 0),\n",
        "            (17, 80, 0),\n",
        "            (-16, 77, 0),\n",
        "        ]\n",
        "\n",
        "        for vect, label, orientation in zip(vects, labels, orientations):\n",
        "            lines = get_direction_lines(axes, vect.get_vector(), color=vect.get_color())\n",
        "            self.play(\n",
        "                GrowArrow(vect),\n",
        "                FadeIn(label, vect.get_vector()),\n",
        "                frame.animate.reorient(*orientation),\n",
        "            )\n",
        "            self.play(\n",
        "                LaggedStartMap(ShowCreationThenFadeOut, lines, lag_ratio=2 / len(lines))\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        # Bring in \"plucked out\" vector\n",
        "        emb_coords = 2.0 * all_coords[:2].sum(0)\n",
        "        emb = Vector(emb_coords)\n",
        "        emb.always.set_perpendicular_to_camera(self.frame)\n",
        "        emb.set_flat_stroke(False)\n",
        "        emb_label = Tex(R\"\\vec{\\textbf{E}}\", font_size=30)\n",
        "        emb_label.rotate(89 * DEGREES, RIGHT)\n",
        "        emb_label.add_updater(lambda m: m.move_to(1.1 * emb.get_end()))\n",
        "        emb_label.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(7, 66, 0).set_anim_args(run_time=2),\n",
        "            FadeIn(emb, shift=2 * (IN + LEFT)),\n",
        "            FadeIn(emb_label, shift=2 * (IN + LEFT)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Set up dot product display\n",
        "        def get_proj_point(vect1, vect2):\n",
        "            v1 = vect1.get_end()\n",
        "            v2 = vect2.get_end()\n",
        "            return v2 * np.dot(v1, v2) / np.dot(v2, v2)\n",
        "\n",
        "        def get_dot_product_lines(vect, proj_line_color=GREY_A):\n",
        "            dashed_line = always_redraw(\n",
        "                lambda: Line(emb.get_end(), get_proj_point(emb, vect)).set_stroke(WHITE, 2).set_anti_alias_width(10)\n",
        "            )\n",
        "            proj_line = always_redraw(\n",
        "                lambda: Line(ORIGIN, get_proj_point(emb, vect)).set_stroke(proj_line_color, width=4, opacity=0.75)\n",
        "            )\n",
        "            return dashed_line, proj_line\n",
        "\n",
        "        m_dashed_line, m_proj_line = get_dot_product_lines(vects[0])\n",
        "\n",
        "        formula = Tex(R\"\\vec{\\textbf{E}} \\cdot \\big(\\overrightarrow{\\text{First Name Michael}}\\big) = \", font_size=36)\n",
        "        formula[3:-1].set_color(YELLOW)\n",
        "        formula.to_corner(UL)\n",
        "        formula.fix_in_frame()\n",
        "        rhs = DecimalNumber(font_size=42)\n",
        "        rhs.fix_in_frame()\n",
        "        rhs.next_to(formula[-1], RIGHT, buff=0.15)\n",
        "        rhs.target_vect = vects[0]\n",
        "        rhs.add_updater(lambda m: m.set_value(np.dot(m.target_vect.get_end(), emb.get_end()) / 4.0))\n",
        "\n",
        "        m_proj_line.suspend_updating()\n",
        "        self.play(\n",
        "            ShowCreation(m_dashed_line),\n",
        "            TransformFromCopy(Line(ORIGIN, emb.get_end(), flat_stroke=False), m_proj_line),\n",
        "            FadeIn(formula, UP),\n",
        "            vect_groups[1:].animate.set_opacity(0.25),\n",
        "        )\n",
        "        m_proj_line.resume_updating()\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs.copy().unfix_from_frame().set_opacity(0).move_to(m_proj_line), rhs),\n",
        "        )\n",
        "        emb_label.resume_updating()\n",
        "        for _ in range(2):\n",
        "            self.play(\n",
        "                emb.animate.put_start_and_end_on(ORIGIN, [-2.5, -2.0, -0.5]),\n",
        "                rate_func=wiggle,\n",
        "                run_time=5\n",
        "            )\n",
        "        self.wait(2)\n",
        "        self.play(emb.animate.put_start_and_end_on(axes.get_origin(), 1.5 * all_coords[1:3].sum(0)), run_time=3)\n",
        "        self.play(frame.animate.reorient(26, 68, 0), run_time=2 )\n",
        "        self.play(emb.animate.put_start_and_end_on(ORIGIN, [1.0, -1.5, -1.0]), run_time=3)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-4, 73, 0),\n",
        "            emb.animate.put_start_and_end_on(ORIGIN, emb_coords),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Dotting against L.N. Jordan\n",
        "        j_dashed_line, j_proj_line = get_dot_product_lines(vects[1])\n",
        "        j_paren = Tex(R\"\\big(\\overrightarrow{\\text{Last Name Jordan}}\\big) = \", font_size=36)\n",
        "        j_paren[:-1].set_color(RED)\n",
        "        m_paren = formula[3:]\n",
        "        m_paren.fix_in_frame()\n",
        "        j_paren.move_to(m_paren, LEFT)\n",
        "        j_paren.fix_in_frame()\n",
        "        rhs.target_vect = vects[1]\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(15, 97, 0),\n",
        "            FadeOut(m_paren, UP, time_span=(1, 2)),\n",
        "            FadeIn(j_paren, UP, time_span=(1, 2)),\n",
        "            rhs.animate.next_to(j_paren, RIGHT, buff=0.15).set_anim_args(time_span=(1, 2)),\n",
        "            LaggedStart(\n",
        "                vect_groups[0].animate.set_opacity(0.25),\n",
        "                vect_groups[1].animate.set_opacity(1),\n",
        "                FadeOut(m_dashed_line),\n",
        "                FadeOut(m_proj_line),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        j_proj_line.suspend_updating()\n",
        "        self.play(\n",
        "            ShowCreation(j_dashed_line),\n",
        "            TransformFromCopy(Line(ORIGIN, emb.get_end(), flat_stroke=False), j_proj_line),\n",
        "        )\n",
        "        j_proj_line.resume_updating()\n",
        "        self.play(\n",
        "            emb.animate.put_start_and_end_on(ORIGIN, [-1.5, -1.5, 0]).set_anim_args(run_time=3, rate_func=there_and_back)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Dotting against basketball\n",
        "        b_dashed_line, b_proj_line = get_dot_product_lines(vects[2])\n",
        "        b_paren = Tex(R\"\\big(\\overrightarrow{\\text{Basketball}}\\big) = \", font_size=36)\n",
        "        b_paren[:-1].set_color(vects[2].get_color())\n",
        "        b_paren.move_to(m_paren, LEFT)\n",
        "        b_paren.fix_in_frame()\n",
        "        rhs.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(2, 65, 0),\n",
        "            FadeOut(j_paren, UP),\n",
        "            FadeIn(b_paren, UP),\n",
        "            rhs.animate.next_to(b_paren[-1], RIGHT, buff=0.2).set_value(0),\n",
        "            FadeOut(j_dashed_line),\n",
        "            FadeOut(j_proj_line),\n",
        "            vect_groups[1].animate.set_opacity(0.25),\n",
        "            vect_groups[2].animate.set_opacity(1.0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rhs.target_vect = vects[2]\n",
        "        rhs.resume_updating()\n",
        "        self.add(b_dashed_line, b_proj_line)\n",
        "        self.play(\n",
        "            emb.animate.put_start_and_end_on(ORIGIN, [0.6, -2.2, 0]),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Emphasize dot products with first two names\n",
        "        self.play(\n",
        "            frame.animate.reorient(5, 85, 0).set_anim_args(run_time=2),\n",
        "            FadeOut(formula[:3]),\n",
        "            FadeOut(b_paren),\n",
        "            FadeOut(rhs),\n",
        "            FadeOut(b_dashed_line),\n",
        "            FadeOut(b_proj_line),\n",
        "            vect_groups[:2].animate.set_opacity(1),\n",
        "            vect_groups[2].animate.set_opacity(0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(m_dashed_line),\n",
        "            ShowCreation(m_proj_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(j_dashed_line),\n",
        "            ShowCreation(j_proj_line),\n",
        "        )\n",
        "        self.wait(20)\n",
        "        self.play(\n",
        "            *map(FadeOut, [j_dashed_line, j_proj_line, m_dashed_line, m_proj_line, emb, emb_label]),\n",
        "        )\n",
        "\n",
        "        # Show sum of the first two names\n",
        "        j_vect_copy, m_vect_copy = vect_copies = vects[:2].copy()\n",
        "        vect_copies.clear_updaters()\n",
        "        vect_copies.set_stroke(opacity=0.5)\n",
        "        j_vect_copy.shift(vects[1].get_vector())\n",
        "        m_vect_copy.shift(vects[0].get_vector())\n",
        "        emb.put_start_and_end_on(axes.get_origin(), m_vect_copy.get_end())\n",
        "\n",
        "        self.play(frame.animate.reorient(-6, 78, 0), run_time=2)\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(vects[1], m_vect_copy),\n",
        "            TransformFromCopy(vects[0], j_vect_copy),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(GrowArrow(emb))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show the basketball direction\n",
        "        self.play(\n",
        "            *map(FadeOut, [m_vect_copy, j_vect_copy, emb])\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-19, 77, 0, (1.32, -0.22, -0.12), 3.75),\n",
        "            vect_groups[:2].animate.set_opacity(0.25),\n",
        "            vect_groups[2][0].animate.set_opacity(1.0),\n",
        "            vect_groups[2][1].animate.set_opacity(1.0),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(20)\n"
    ]
}