{
    "topic": "demonstrates the concept of a mirrored image of an object as it moves along a",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class MirrorScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"center\": DOWN + 3 * LEFT,\n",
        "        \"line_length\": FRAME_WIDTH,\n",
        "        \"start_theta\": np.arctan(0.25),\n",
        "        \"start_y_offset\": 0.5,\n",
        "        \"start_x_offset\": 8,\n",
        "        \"arc_config\": {\n",
        "            \"radius\": 1,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"trajectory_point_spacing\": 0.1,\n",
        "        \"trajectory_style\": {\n",
        "            \"stroke_color\": YELLOW,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"ghost_lines_style\": {\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "        },\n",
        "        # \"reflect_sound\": \"ping\",\n",
        "        \"reflect_sound\": \"pen_click\",\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.theta_tracker = ValueTracker(self.start_theta)\n",
        "        self.start_y_offset_tracker = ValueTracker(self.start_y_offset)\n",
        "        self.start_x_offset_tracker = ValueTracker(self.start_x_offset)\n",
        "        self.center_tracker = VectorizedPoint(self.center)\n",
        "        self.beam_point = VectorizedPoint(np.array([\n",
        "            self.get_start_x_offset(),\n",
        "            self.get_start_y_offset(),\n",
        "            0\n",
        "        ]))\n",
        "        self.ghost_beam_point = self.beam_point.copy()\n",
        "        self.is_sound_allowed = False\n",
        "\n",
        "        self.mirrors = self.get_mirrors()\n",
        "        self.arc = self.get_arc()\n",
        "        self.theta_symbol = self.get_theta_symbol()\n",
        "        self.trajectory = self.get_trajectory()\n",
        "        self.ghost_trajectory = self.get_ghost_trajectory()\n",
        "        self.theta_display = self.get_theta_display()\n",
        "        self.count_display_word = self.get_count_display_word()\n",
        "        self.count_display_number = self.get_count_display_number()\n",
        "        self.last_count = self.get_count()\n",
        "\n",
        "        # Add some of them\n",
        "        self.add(\n",
        "            self.mirrors,\n",
        "            self.arc,\n",
        "            self.theta_symbol,\n",
        "            self.theta_display,\n",
        "            self.count_display_word,\n",
        "            self.count_display_number,\n",
        "        )\n",
        "\n",
        "    def get_center(self):\n",
        "        return self.center_tracker.get_location()\n",
        "\n",
        "    def get_theta(self):\n",
        "        return self.theta_tracker.get_value()\n",
        "\n",
        "    def get_start_y_offset(self):\n",
        "        return self.start_y_offset_tracker.get_value()\n",
        "\n",
        "    def get_start_x_offset(self):\n",
        "        return self.start_x_offset_tracker.get_value()\n",
        "\n",
        "    def get_mirror(self):\n",
        "        mirror = VGroup(\n",
        "            Line(ORIGIN, 2 * RIGHT),\n",
        "            Line(ORIGIN, 2 * RIGHT),\n",
        "            Line(ORIGIN, (self.line_length - 4) * RIGHT),\n",
        "        )\n",
        "        mirror.arrange(RIGHT, buff=0)\n",
        "        mirror.set_stroke(width=5)\n",
        "        mirror[0::2].set_stroke((WHITE, GREY))\n",
        "        mirror[1::2].set_stroke((GREY, WHITE))\n",
        "        return mirror\n",
        "\n",
        "    def get_mirrors(self):\n",
        "        mirrors = VGroup(self.get_mirror(), self.get_mirror())\n",
        "\n",
        "        def update_mirrors(mirrors):\n",
        "            m1, m2 = mirrors\n",
        "            center = self.get_center()\n",
        "            theta = self.get_theta()\n",
        "            m1.move_to(center, DL)\n",
        "            m2.become(m1)\n",
        "            m2.rotate(theta, about_point=center)\n",
        "\n",
        "        mirrors.add_updater(update_mirrors)\n",
        "        return mirrors\n",
        "\n",
        "    def get_arc(self, radius=0.5):\n",
        "        return always_redraw(lambda: Arc(\n",
        "            start_angle=0,\n",
        "            angle=self.get_theta(),\n",
        "            arc_center=self.get_center(),\n",
        "            **self.arc_config,\n",
        "        ))\n",
        "\n",
        "    def get_theta_symbol(self, arc=None, buff=0.15):\n",
        "        if arc is None:\n",
        "            arc = self.arc\n",
        "        symbol = OldTex(\"\\\\theta\")\n",
        "\n",
        "        def update_symbol(symbol):\n",
        "            midpoint = arc.point_from_proportion(0.5)\n",
        "            center = arc.arc_center\n",
        "            vect = (midpoint - center)\n",
        "            max_height = 0.8 * arc.get_height()\n",
        "            if symbol.get_height() > max_height:\n",
        "                symbol.set_height(max_height)\n",
        "            symbol.move_to(\n",
        "                center + vect + buff * normalize(vect)\n",
        "            )\n",
        "        symbol.add_updater(update_symbol)\n",
        "        return symbol\n",
        "\n",
        "    def get_ghost_collision_points(self):\n",
        "        x = self.get_start_x_offset()\n",
        "        y = self.get_start_y_offset()\n",
        "        theta = self.get_theta()\n",
        "\n",
        "        points = [np.array([x, y, 0])]\n",
        "        points += [\n",
        "            np.array([x, y, 0])\n",
        "            for k in range(1, int(PI / theta) + 1)\n",
        "            for x in [y / np.tan(k * theta)]\n",
        "            if abs(x) < FRAME_WIDTH\n",
        "        ]\n",
        "        points.append(points[-1] + x * LEFT)\n",
        "        points = np.array(points)\n",
        "        points += self.get_center()\n",
        "        return points\n",
        "\n",
        "    def get_collision_points(self, ghost_points=None):\n",
        "        if ghost_points is None:\n",
        "            ghost_points = self.get_ghost_collision_points()\n",
        "        theta = self.get_theta()\n",
        "        center = self.get_center()\n",
        "        points = []\n",
        "        for ghost_point in ghost_points:\n",
        "            vect = ghost_point - center\n",
        "            angle = angle_of_vector(vect)\n",
        "            k = int(angle / theta)\n",
        "            if k % 2 == 0:\n",
        "                vect = rotate_vector(vect, -k * theta)\n",
        "            else:\n",
        "                vect = rotate_vector(vect, -(k + 1) * theta)\n",
        "                vect[1] = abs(vect[1])\n",
        "            points.append(center + vect)\n",
        "        return points\n",
        "\n",
        "    def get_trajectory(self, collision_points=None):\n",
        "        if collision_points is None:\n",
        "            collision_points = self.get_collision_points()\n",
        "        points = []\n",
        "        spacing = self.trajectory_point_spacing\n",
        "        for p0, p1 in zip(collision_points, collision_points[1:]):\n",
        "            n_intervals = max(1, int(get_norm(p1 - p0) / spacing))\n",
        "            for alpha in np.linspace(0, 1, n_intervals + 1):\n",
        "                points.append(interpolate(p0, p1, alpha))\n",
        "        trajectory = VMobject()\n",
        "        trajectory.set_points_as_corners(points)\n",
        "        trajectory.set_style(**self.trajectory_style)\n",
        "        return trajectory\n",
        "\n",
        "    def get_ghost_trajectory(self):\n",
        "        return self.get_trajectory(self.get_ghost_collision_points())\n",
        "\n",
        "    def get_collision_point_counts(self, collision_points=None):\n",
        "        if collision_points is None:\n",
        "            collision_points = self.get_collision_points()[1:-1]\n",
        "        result = VGroup()\n",
        "        for n, point in enumerate(collision_points):\n",
        "            count = Integer(n + 1)\n",
        "            count.set_height(0.25)\n",
        "            vect = UP if n % 2 == 0 else DOWN\n",
        "            count.next_to(point, vect, SMALL_BUFF)\n",
        "            result.add(count)\n",
        "        return result\n",
        "\n",
        "    def get_collision_count_anim(self, collision_point_counts=None):\n",
        "        if collision_point_counts is None:\n",
        "            collision_point_counts = self.get_collision_point_counts()\n",
        "        group = VGroup()\n",
        "\n",
        "        def update(group):\n",
        "            count = self.get_count()\n",
        "            if count == 0:\n",
        "                group.submobjects = []\n",
        "            elif count < len(collision_point_counts) + 1:\n",
        "                group.submobjects = [\n",
        "                    collision_point_counts[count - 1]\n",
        "                ]\n",
        "\n",
        "        return UpdateFromFunc(group, update, remover=True)\n",
        "\n",
        "    def get_ghost_lines(self):\n",
        "        line = self.mirrors[0]\n",
        "        center = self.get_center()\n",
        "        theta = self.get_theta()\n",
        "        lines = VGroup()\n",
        "        for k in range(1, int(PI / theta) + 2):\n",
        "            new_line = line.copy()\n",
        "            new_line.rotate(k * theta, about_point=center)\n",
        "            lines.add(new_line)\n",
        "        lines.set_style(**self.ghost_lines_style)\n",
        "        return lines\n",
        "\n",
        "    # Displays\n",
        "    def get_theta_display(self):\n",
        "        lhs = OldTex(\"\\\\theta = \")\n",
        "        radians = DecimalNumber()\n",
        "        radians.add_updater(\n",
        "            lambda m: m.set_value(self.get_theta())\n",
        "        )\n",
        "        radians_word = OldTexText(\"radians\")\n",
        "        radians_word.next_to(\n",
        "            radians, RIGHT, aligned_edge=DOWN\n",
        "        )\n",
        "        equals = OldTex(\"=\")\n",
        "        degrees = Integer(0, unit=\"^\\\\circ\")\n",
        "        degrees.add_updater(\n",
        "            lambda m: m.set_value(\n",
        "                int(np.round(self.get_theta() / DEGREES))\n",
        "            )\n",
        "        )\n",
        "        group = VGroup(lhs, radians, radians_word, equals, degrees)\n",
        "        group.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        equals.align_to(lhs[-1], DOWN)\n",
        "        group.to_corner(UL)\n",
        "        return group\n",
        "\n",
        "    def get_count_display_word(self):\n",
        "        result = OldTexText(\"\\\\# Bounces: \")\n",
        "        result.to_corner(UL)\n",
        "        result.shift(DOWN)\n",
        "        result.set_color(YELLOW)\n",
        "        return result\n",
        "\n",
        "    def get_count_display_number(self, count_display_word=None, ghost_beam_point=None):\n",
        "        if count_display_word is None:\n",
        "            count_display_word = self.count_display_word\n",
        "        result = Integer()\n",
        "        result.next_to(\n",
        "            count_display_word[-1], RIGHT,\n",
        "            aligned_edge=DOWN,\n",
        "        )\n",
        "        result.set_color(YELLOW)\n",
        "        result.add_updater(\n",
        "            lambda m: m.set_value(self.get_count())\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def get_count(self, ghost_beam_point=None):\n",
        "        if ghost_beam_point is None:\n",
        "            ghost_beam_point = self.ghost_beam_point.get_location()\n",
        "        angle = angle_of_vector(\n",
        "            ghost_beam_point - self.get_center()\n",
        "        )\n",
        "        return int(angle / self.get_theta())\n",
        "\n",
        "    # Sounds\n",
        "    def allow_sound(self):\n",
        "        self.is_sound_allowed = True\n",
        "\n",
        "    def disallow_sound(self):\n",
        "        self.is_sound_allowed = False\n",
        "\n",
        "    def update_mobjects(self, dt):\n",
        "        super().update_mobjects(dt)\n",
        "        if self.get_count() != self.last_count:\n",
        "            self.last_count = self.get_count()\n",
        "            if self.is_sound_allowed:\n",
        "                self.add_sound(\n",
        "                    self.reflect_sound,\n",
        "                    gain=-20,\n",
        "                )\n",
        "\n",
        "    # Bouncing animations\n",
        "    def show_bouncing(self, run_time=5):\n",
        "        trajectory = self.trajectory\n",
        "        ghost_trajectory = self.get_ghost_trajectory()\n",
        "\n",
        "        beam_anims = self.get_shooting_beam_anims(\n",
        "            trajectory, ghost_trajectory\n",
        "        )\n",
        "        count_anim = self.get_collision_count_anim()\n",
        "\n",
        "        self.allow_sound()\n",
        "        self.play(count_anim, *beam_anims, run_time=run_time)\n",
        "        self.disallow_sound()\n",
        "\n",
        "    def get_special_flash(self, mobject, stroke_width, time_width, rate_func=linear, **kwargs):\n",
        "        kwargs[\"rate_func\"] = rate_func\n",
        "        mob_copy = mobject.copy()\n",
        "        mob_copy.set_stroke(width=stroke_width)\n",
        "        mob_copy.time_width = time_width\n",
        "        return UpdateFromAlphaFunc(\n",
        "            mob_copy,\n",
        "            lambda m, a: m.pointwise_become_partial(\n",
        "                mobject,\n",
        "                max(a - (1 - a) * m.time_width, 0),\n",
        "                a,\n",
        "            ),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_shooting_beam_anims(self,\n",
        "                                trajectory,\n",
        "                                ghost_trajectory=None,\n",
        "                                update_beam_point=True,\n",
        "                                num_flashes=20,\n",
        "                                min_time_width=0.01,\n",
        "                                max_time_width=0.5,\n",
        "                                min_stroke_width=0.01,\n",
        "                                max_stroke_width=6,\n",
        "                                fade_trajectory=True,\n",
        "                                faded_trajectory_width=0.25,\n",
        "                                faded_trajectory_time_exp=0.2,\n",
        "                                ):\n",
        "        # Most flashes\n",
        "        result = [\n",
        "            self.get_special_flash(trajectory, stroke_width, time_width)\n",
        "            for stroke_width, time_width in zip(\n",
        "                np.linspace(max_stroke_width, min_stroke_width, num_flashes),\n",
        "                np.linspace(min_time_width, max_time_width, num_flashes),\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        # Make sure beam point is updated\n",
        "        if update_beam_point:\n",
        "            smallest_flash = result[0]\n",
        "            result.append(\n",
        "                UpdateFromFunc(\n",
        "                    self.beam_point,\n",
        "                    lambda m: m.move_to(smallest_flash.mobject.get_points()[-1])\n",
        "                )\n",
        "            )\n",
        "\n",
        "        # Make sure ghost beam point is updated\n",
        "        if ghost_trajectory:\n",
        "            ghost_flash = self.get_special_flash(\n",
        "                ghost_trajectory, 0, min_time_width,\n",
        "            )\n",
        "            ghost_beam_point_update = UpdateFromFunc(\n",
        "                self.ghost_beam_point,\n",
        "                lambda m: m.move_to(ghost_flash.mobject.get_points()[-1])\n",
        "            )\n",
        "            result += [\n",
        "                ghost_flash,\n",
        "                ghost_beam_point_update,\n",
        "            ]\n",
        "\n",
        "        # Fade trajectory\n",
        "        if fade_trajectory:\n",
        "            ftte = faded_trajectory_time_exp\n",
        "            result.append(\n",
        "                ApplyMethod(\n",
        "                    trajectory.set_stroke,\n",
        "                    {\"width\": faded_trajectory_width},\n",
        "                    rate_func=lambda t: there_and_back(t)**ftte\n",
        "                ),\n",
        "            )\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShowTrajectoryWithChangingTheta(MirrorScene):\n",
        "    def construct(self):\n",
        "        trajectory = self.trajectory\n",
        "        self.add(trajectory)\n",
        "        angles = [30 * DEGREES, 10 * DEGREES]\n",
        "        ys = [1, 1]\n",
        "        self.show_bouncing()\n",
        "        for angle, y in zip(angles, ys):\n",
        "            rect = SurroundingRectangle(self.theta_display)\n",
        "            self.play(\n",
        "                self.theta_tracker.set_value, angle,\n",
        "                self.start_y_offset_tracker.set_value, y,\n",
        "                FadeIn(rect, rate_func=there_and_back, remover=True),\n",
        "                UpdateFromFunc(\n",
        "                    trajectory,\n",
        "                    lambda m: m.become(self.get_trajectory())\n",
        "                ),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.show_bouncing()\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ReflectWorldThroughMirrorNew(MirrorScene):\n",
        "    CONFIG = {\n",
        "        \"start_y_offset\": 1.25,\n",
        "        \"center\": DOWN,\n",
        "        \"randy_height\": 1,\n",
        "        \"partial_trajectory_values\": [\n",
        "            0, 0.22, 0.28, 0.315, 1,\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_randy()\n",
        "        self.shift_displays()\n",
        "        self.add_ghost_beam_point()\n",
        "        self.up_through_first_bounce()\n",
        "        self.create_reflected_worlds()\n",
        "        self.create_reflected_trajectories()\n",
        "        self.first_reflection()\n",
        "        self.next_reflection(2)\n",
        "        self.next_reflection(3)\n",
        "        self.unfold_all_reflected_worlds()\n",
        "        self.show_completed_beam()\n",
        "        self.blink_all_randys()\n",
        "        self.add_randy_updates()\n",
        "        self.show_all_trajectories()\n",
        "        self.focus_on_two_important_trajectories()\n",
        "\n",
        "    def add_randy(self):\n",
        "        randy = self.randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.set_height(self.randy_height)\n",
        "        randy.change(\"pondering\")\n",
        "        randy.align_to(self.mirrors, DOWN)\n",
        "        randy.shift(0.01 * UP)\n",
        "        randy.to_edge(RIGHT, buff=1)\n",
        "        randy.tracked_mobject = self.trajectory\n",
        "        randy.add_updater(\n",
        "            lambda m: m.look_at(\n",
        "                m.tracked_mobject.get_points()[-1]\n",
        "            )\n",
        "        )\n",
        "        self.add(randy)\n",
        "\n",
        "    def shift_displays(self):\n",
        "        VGroup(\n",
        "            self.theta_display,\n",
        "            self.count_display_word,\n",
        "            self.count_display_number,\n",
        "        ).to_edge(DOWN)\n",
        "\n",
        "    def add_ghost_beam_point(self):\n",
        "        self.ghost_beam_point.add_updater(\n",
        "            lambda m: m.move_to(\n",
        "                self.ghost_trajectory.get_points()[-1]\n",
        "            )\n",
        "        )\n",
        "        self.add(self.ghost_beam_point)\n",
        "\n",
        "    def up_through_first_bounce(self):\n",
        "        self.play(*self.get_both_partial_trajectory_anims(\n",
        "            *self.partial_trajectory_values[:2]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def create_reflected_worlds(self):\n",
        "        mirrors = self.mirrors\n",
        "        triangle = Polygon(*[\n",
        "            mirrors.get_corner(corner)\n",
        "            for corner in (DR, DL, UR)\n",
        "        ])\n",
        "        triangle.set_stroke(width=0)\n",
        "        triangle.set_fill(BLUE_E, opacity=0)\n",
        "        world = self.world = VGroup(\n",
        "            triangle,\n",
        "            mirrors,\n",
        "            self.arc,\n",
        "            self.theta_symbol,\n",
        "            self.randy,\n",
        "        )\n",
        "        reflected_worlds = self.get_reflected_worlds(world)\n",
        "        self.reflected_worlds = reflected_worlds\n",
        "        # Alternating triangle opacities\n",
        "        for rw in reflected_worlds[::2]:\n",
        "            rw[0].set_fill(opacity=0.25)\n",
        "\n",
        "    def create_reflected_trajectories(self):\n",
        "        self.reflected_trajectories = always_redraw(\n",
        "            lambda: self.get_reflected_worlds(self.trajectory)\n",
        "        )\n",
        "\n",
        "    def first_reflection(self):\n",
        "        reflected_trajectory = self.reflected_trajectories[0]\n",
        "        reflected_world = self.reflected_worlds[0]\n",
        "        world = self.world\n",
        "        trajectory = self.trajectory\n",
        "        ghost_trajectory = self.ghost_trajectory\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(world, reflected_world),\n",
        "            TransformFromCopy(trajectory, reflected_trajectory),\n",
        "            run_time=2\n",
        "        )\n",
        "        beam_anims = self.get_shooting_beam_anims(\n",
        "            ghost_trajectory,\n",
        "            fade_trajectory=False,\n",
        "        )\n",
        "        self.play(\n",
        "            *[\n",
        "                ApplyMethod(m.set_stroke, GREY, 1)\n",
        "                for m in (trajectory, reflected_trajectory)\n",
        "            ] + beam_anims,\n",
        "            run_time=2\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(*beam_anims, run_time=2)\n",
        "\n",
        "        ghost_trajectory.set_stroke(YELLOW, 4)\n",
        "        self.bring_to_front(ghost_trajectory)\n",
        "        self.play(FadeIn(ghost_trajectory))\n",
        "        self.wait()\n",
        "\n",
        "    def next_reflection(self, index=2):\n",
        "        i = index\n",
        "        self.play(\n",
        "            *self.get_both_partial_trajectory_anims(\n",
        "                *self.partial_trajectory_values[i - 1:i + 1]\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                VMobject(),  # Null\n",
        "                lambda m: self.reflected_trajectories.update(),\n",
        "                remover=True,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        anims = [\n",
        "            TransformFromCopy(*reflections[i - 2:i])\n",
        "            for reflections in [\n",
        "                self.reflected_worlds,\n",
        "                self.reflected_trajectories\n",
        "            ]\n",
        "        ]\n",
        "        self.play(*anims, run_time=2)\n",
        "        self.add(self.ghost_trajectory)\n",
        "        self.wait()\n",
        "\n",
        "    def unfold_all_reflected_worlds(self):\n",
        "        worlds = self.reflected_worlds\n",
        "        trajectories = self.reflected_trajectories\n",
        "\n",
        "        pairs = [\n",
        "            (VGroup(w1, t1), VGroup(w2, t2))\n",
        "            for w1, w2, t1, t2 in zip(\n",
        "                worlds[2:], worlds[3:],\n",
        "                trajectories[2:], trajectories[3:],\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        new_worlds = VGroup()  # Brought to you by Dvorak\n",
        "        for m1, m2 in pairs:\n",
        "            m2.pre_world = m1.copy()\n",
        "            new_worlds.add(m2)\n",
        "        for mob in new_worlds:\n",
        "            mob.save_state()\n",
        "            mob.become(mob.pre_world)\n",
        "            mob.fade(1)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            Restore, new_worlds,\n",
        "            lag_ratio=0.4,\n",
        "            run_time=3\n",
        "        ))\n",
        "\n",
        "    def show_completed_beam(self):\n",
        "        self.add(self.reflected_trajectories)\n",
        "        self.add(self.ghost_trajectory)\n",
        "        self.play(*self.get_both_partial_trajectory_anims(\n",
        "            *self.partial_trajectory_values[-2:],\n",
        "            run_time=7\n",
        "        ))\n",
        "\n",
        "    def blink_all_randys(self):\n",
        "        randys = self.randys = VGroup(self.randy)\n",
        "        randys.add(*[rw[-1] for rw in self.reflected_worlds])\n",
        "        self.play(LaggedStartMap(Blink, randys))\n",
        "\n",
        "    def add_randy_updates(self):\n",
        "        # Makes it run slower, but it's fun!\n",
        "        reflected_randys = VGroup(*[\n",
        "            rw[-1] for rw in self.reflected_worlds\n",
        "        ])\n",
        "        reflected_randys.add_updater(\n",
        "            lambda m: m.become(\n",
        "                self.get_reflected_worlds(self.randy)\n",
        "            )\n",
        "        )\n",
        "        self.add(reflected_randys)\n",
        "\n",
        "    def show_all_trajectories(self):\n",
        "        ghost_trajectory = self.ghost_trajectory\n",
        "        reflected_trajectories = self.reflected_trajectories\n",
        "        trajectory = self.trajectory\n",
        "        reflected_trajectories.suspend_updating()\n",
        "        trajectories = VGroup(trajectory, *reflected_trajectories)\n",
        "\n",
        "        all_mirrors = VGroup(*[\n",
        "            world[1]\n",
        "            for world in it.chain([self.world], self.reflected_worlds)\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(ghost_trajectory),\n",
        "            trajectories.set_stroke, YELLOW, 0.5,\n",
        "            all_mirrors.set_stroke, {\"width\": 1},\n",
        "        )\n",
        "\n",
        "        # All trajectory light beams\n",
        "        flash_groups = [\n",
        "            self.get_shooting_beam_anims(\n",
        "                mob, fade_trajectory=False,\n",
        "            )\n",
        "            for mob in trajectories\n",
        "        ]\n",
        "        all_flashes = list(it.chain(*flash_groups))\n",
        "\n",
        "        # Have all the pi creature eyes follows\n",
        "        self.randy.tracked_mobject = all_flashes[0].mobject\n",
        "\n",
        "        # Highlight the illustory straight beam\n",
        "        red_ghost = self.ghost_trajectory.copy()\n",
        "        red_ghost.set_color(RED)\n",
        "        red_ghost_beam = self.get_shooting_beam_anims(\n",
        "            red_ghost, fade_trajectory=False,\n",
        "        )\n",
        "\n",
        "        num_repeats = 3\n",
        "        for x in range(num_repeats):\n",
        "            anims = list(all_flashes)\n",
        "            if x == num_repeats - 1:\n",
        "                anims += list(red_ghost_beam)\n",
        "                self.randy.tracked_mobject = red_ghost_beam[0].mobject\n",
        "                for flash in all_flashes:\n",
        "                    if hasattr(flash.mobject, \"time_width\"):\n",
        "                        flash.mobject.set_stroke(\n",
        "                            width=0.25 * flash.mobject.get_stroke_width()\n",
        "                        )\n",
        "                        flash.mobject.time_width *= 0.25\n",
        "            self.play(*anims, run_time=3)\n",
        "\n",
        "    def focus_on_two_important_trajectories(self):\n",
        "        self.ghost_trajectory.set_stroke(YELLOW, 1)\n",
        "        self.play(\n",
        "            FadeOut(self.reflected_trajectories),\n",
        "            FadeIn(self.ghost_trajectory),\n",
        "            self.trajectory.set_stroke, YELLOW, 1,\n",
        "        )\n",
        "        self.add_flashing_windows()\n",
        "        t_beam_anims = self.get_shooting_beam_anims(self.trajectory)\n",
        "        gt_beam_anims = self.get_shooting_beam_anims(self.ghost_trajectory)\n",
        "        self.ghost_beam_point.clear_updaters()\n",
        "        self.ghost_beam_point.add_updater(\n",
        "            lambda m: m.move_to(\n",
        "                gt_beam_anims[0].mobject.get_points()[-1]\n",
        "            )\n",
        "        )\n",
        "        self.randy.tracked_mobject = t_beam_anims[0].mobject\n",
        "        self.allow_sound()\n",
        "        self.play(\n",
        "            *t_beam_anims, *gt_beam_anims,\n",
        "            run_time=6\n",
        "        )\n",
        "        self.add_room_color_updates()\n",
        "        self.play(\n",
        "            *t_beam_anims, *gt_beam_anims,\n",
        "            run_time=6\n",
        "        )\n",
        "        self.blink_all_randys()\n",
        "        self.play(\n",
        "            *t_beam_anims, *gt_beam_anims,\n",
        "            run_time=6\n",
        "        )\n",
        "\n",
        "    # Helpers\n",
        "    def get_reflected_worlds(self, world, n_reflections=None):\n",
        "        theta = self.get_theta()\n",
        "        center = self.get_center()\n",
        "        if n_reflections is None:\n",
        "            n_reflections = int(PI / theta)\n",
        "\n",
        "        result = VGroup()\n",
        "        last_world = world\n",
        "        for n in range(n_reflections):\n",
        "            vect = rotate_vector(RIGHT, (n + 1) * theta)\n",
        "            reflected_world = last_world.copy()\n",
        "            reflected_world.clear_updaters()\n",
        "            reflected_world.rotate(\n",
        "                PI, axis=vect, about_point=center,\n",
        "            )\n",
        "            last_world = reflected_world\n",
        "            result.add(last_world)\n",
        "        return result\n",
        "\n",
        "    def get_partial_trajectory_anims(self, trajectory, a, b, **kwargs):\n",
        "        if not hasattr(trajectory, \"full_self\"):\n",
        "            trajectory.full_self = trajectory.copy()\n",
        "        return UpdateFromAlphaFunc(\n",
        "            trajectory,\n",
        "            lambda m, alpha: m.pointwise_become_partial(\n",
        "                m.full_self, 0,\n",
        "                interpolate(a, b, alpha)\n",
        "            ),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_both_partial_trajectory_anims(self, a, b, run_time=2, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        return [\n",
        "            self.get_partial_trajectory_anims(\n",
        "                mob, a, b, **kwargs\n",
        "            )\n",
        "            for mob in (self.trajectory, self.ghost_trajectory)\n",
        "        ]\n",
        "\n",
        "    def add_flashing_windows(self):\n",
        "        theta = self.get_theta()\n",
        "        center = self.get_center()\n",
        "        windows = self.windows = VGroup(*[\n",
        "            Line(\n",
        "                center,\n",
        "                center + rotate_vector(10 * RIGHT, k * theta),\n",
        "                color=BLUE,\n",
        "                stroke_width=0,\n",
        "            )\n",
        "            for k in range(0, self.get_count() + 1)\n",
        "        ])\n",
        "        windows[0].set_stroke(opacity=0)\n",
        "\n",
        "        # Warning, windows update manager may launch\n",
        "        def update_windows(windows):\n",
        "            windows.set_stroke(width=0)\n",
        "            windows[self.get_count()].set_stroke(width=5)\n",
        "        windows.add_updater(update_windows)\n",
        "        self.add(windows)\n",
        "\n",
        "    def add_room_color_updates(self):\n",
        "        def update_reflected_worlds(worlds):\n",
        "            for n, world in enumerate(worlds):\n",
        "                worlds[n][0].set_fill(\n",
        "                    opacity=(0.25 if (n % 2 == 0) else 0)\n",
        "                )\n",
        "            index = self.get_count() - 1\n",
        "            if index < 0:\n",
        "                return\n",
        "            worlds[index][0].set_fill(opacity=0.5)\n",
        "        self.reflected_worlds.add_updater(update_reflected_worlds)\n",
        "        self.add(self.reflected_worlds)\n",
        "\n",
        "\n",
        "class ReflectWorldThroughMirrorThetaPoint2(ReflectWorldThroughMirrorNew):\n",
        "    CONFIG = {\n",
        "        \"start_theta\": 0.2,\n",
        "        \"randy_height\": 0.8,\n",
        "    }\n",
        "\n",
        "\n",
        "class ReflectWorldThroughMirrorThetaPoint1(ReflectWorldThroughMirrorNew):\n",
        "    CONFIG = {\n",
        "        \"start_theta\": 0.1,\n",
        "        \"randy_height\": 0.5,\n",
        "        \"start_y_offset\": 0.5,\n",
        "        \"arc_config\": {\n",
        "            \"radius\": 0.5,\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class MirrorAndWiresOverlay(MirrorScene):\n",
        "    CONFIG = {\n",
        "        \"wire_pixel_points\": [\n",
        "            (355, 574),\n",
        "            (846, 438),\n",
        "            (839, 629),\n",
        "            (845, 288),\n",
        "            (1273, 314),\n",
        "        ],\n",
        "        \"max_x_pixel\": 1440,\n",
        "        \"max_y_pixel\": 1440,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.last_count = 0\n",
        "\n",
        "    def get_count(self):\n",
        "        return 0\n",
        "\n",
        "    def get_shooting_beam_anims(self, mobject, **new_kwargs):\n",
        "        kwargs = {\n",
        "            \"update_beam_point\": False,\n",
        "            \"fade_trajectory\": False,\n",
        "            \"max_stroke_width\": 10,\n",
        "        }\n",
        "        kwargs.update(new_kwargs)\n",
        "        return super().get_shooting_beam_anims(mobject, **kwargs)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_wires()\n",
        "        self.add_diagram()\n",
        "\n",
        "        self.introduce_wires()\n",
        "        self.show_illusion()\n",
        "        self.show_angles()\n",
        "\n",
        "        # self.show_reflecting_beam()\n",
        "\n",
        "    def add_wires(self):\n",
        "        ul_corner = TOP + LEFT_SIDE\n",
        "        points = self.wire_points = [\n",
        "            ul_corner + np.array([\n",
        "                (x / self.max_x_pixel) * FRAME_HEIGHT,\n",
        "                (-y / self.max_y_pixel) * FRAME_HEIGHT,\n",
        "                0\n",
        "            ])\n",
        "            for x, y in self.wire_pixel_points\n",
        "        ]\n",
        "        wires = self.wires = VGroup(\n",
        "            Line(points[0], points[1]),\n",
        "            Line(points[1], points[2]),\n",
        "            Line(points[1], points[3]),\n",
        "            Line(points[1], points[4]),\n",
        "        )\n",
        "        wires.set_stroke(RED, 4)\n",
        "        self.dl_wire, self.dr_wire, self.ul_wire, self.ur_wire = wires\n",
        "\n",
        "        self.trajectory = VMobject()\n",
        "        self.trajectory.set_points_as_corners(points[:3])\n",
        "        self.ghost_trajectory = VMobject()\n",
        "        self.ghost_trajectory.set_points_as_corners([*points[:2], points[4]])\n",
        "        VGroup(self.trajectory, self.ghost_trajectory).match_style(\n",
        "            self.wires\n",
        "        )\n",
        "\n",
        "    def add_diagram(self):\n",
        "        diagram = self.diagram = VGroup()\n",
        "        rect = diagram.rect = Rectangle(\n",
        "            height=4, width=5,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=0.9,\n",
        "        )\n",
        "        rect.to_corner(UR)\n",
        "        diagram.add(rect)\n",
        "\n",
        "        center = rect.get_center()\n",
        "\n",
        "        mirror = diagram.mirror = VGroup(\n",
        "            Line(rect.get_left(), center + 1.5 * LEFT),\n",
        "            Line(center + 1.5 * LEFT, rect.get_right()),\n",
        "        )\n",
        "        mirror.scale(0.8)\n",
        "        mirror[0].set_color((WHITE, GREY))\n",
        "        mirror[1].set_color((GREY, WHITE))\n",
        "        diagram.add(mirror)\n",
        "\n",
        "        def set_as_reflection(m1, m2):\n",
        "            m1.become(m2)\n",
        "            m1.rotate(PI, axis=UP, about_point=center)\n",
        "\n",
        "        def set_as_mirror_image(m1, m2):\n",
        "            m1.become(m2)\n",
        "            m1.rotate(PI, axis=RIGHT, about_point=center)\n",
        "\n",
        "        wires = VGroup(*[\n",
        "            Line(center + np.array([-1, -1.5, 0]), center)\n",
        "            for x in range(4)\n",
        "        ])\n",
        "        dl_wire, dr_wire, ul_wire, ur_wire = wires\n",
        "        dr_wire.add_updater(\n",
        "            lambda m: set_as_reflection(m, dl_wire)\n",
        "        )\n",
        "        ul_wire.add_updater(\n",
        "            lambda m: set_as_mirror_image(m, dl_wire)\n",
        "        )\n",
        "        ur_wire.add_updater(\n",
        "            lambda m: set_as_mirror_image(m, dr_wire)\n",
        "        )\n",
        "\n",
        "        diagram.wires = wires\n",
        "        diagram.wires.set_stroke(RED, 2)\n",
        "        diagram.add(diagram.wires)\n",
        "\n",
        "    def introduce_wires(self):\n",
        "        dl_wire = self.dl_wire\n",
        "        dr_wire = self.dr_wire\n",
        "\n",
        "        def get_rect(wire):\n",
        "            rect = Rectangle(\n",
        "                width=wire.get_length(),\n",
        "                height=0.25,\n",
        "                color=YELLOW,\n",
        "            )\n",
        "            rect.rotate(wire.get_angle())\n",
        "            rect.move_to(wire)\n",
        "            return rect\n",
        "\n",
        "        for wire in dl_wire, dr_wire:\n",
        "            self.play(ShowCreationThenFadeOut(get_rect(wire)))\n",
        "            self.play(*self.get_shooting_beam_anims(wire))\n",
        "            self.wait()\n",
        "\n",
        "        diagram = self.diagram.copy()\n",
        "        diagram.clear_updaters()\n",
        "        self.play(\n",
        "            FadeIn(diagram.rect),\n",
        "            ShowCreation(diagram.mirror),\n",
        "            LaggedStartMap(ShowCreation, diagram.wires),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.remove(diagram)\n",
        "        self.add(self.diagram)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def show_illusion(self):\n",
        "        g_trajectory = self.ghost_trajectory\n",
        "        d_trajectory = self.d_trajectory = Line(\n",
        "            self.diagram.wires[0].get_start(),\n",
        "            self.diagram.wires[3].get_start(),\n",
        "        )\n",
        "        d_trajectory.match_style(g_trajectory)\n",
        "\n",
        "        g_trajectory.get_points()[0] += 0.2 * RIGHT + 0.1 * DOWN\n",
        "        g_trajectory.make_jagged()\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                *self.get_shooting_beam_anims(g_trajectory),\n",
        "                *self.get_shooting_beam_anims(d_trajectory),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_angles(self):\n",
        "        dl_wire = self.diagram.wires[0]\n",
        "        dr_wire = self.diagram.wires[1]\n",
        "        center = self.diagram.get_center()\n",
        "        arc_config = {\n",
        "            \"radius\": 0.5,\n",
        "            \"arc_center\": center,\n",
        "        }\n",
        "\n",
        "        def get_dl_arc():\n",
        "            return Arc(\n",
        "                start_angle=PI,\n",
        "                angle=dl_wire.get_angle(),\n",
        "                **arc_config,\n",
        "            )\n",
        "        dl_arc = always_redraw(get_dl_arc)\n",
        "\n",
        "        def get_dr_arc():\n",
        "            return Arc(\n",
        "                start_angle=0,\n",
        "                angle=dr_wire.get_angle() - PI,\n",
        "                **arc_config,\n",
        "            )\n",
        "        dr_arc = always_redraw(get_dr_arc)\n",
        "\n",
        "        incidence = OldTexText(\"Incidence\")\n",
        "        reflection = OldTexText(\"Reflection\")\n",
        "        words = VGroup(incidence, reflection)\n",
        "        words.scale(0.75)\n",
        "        incidence.add_updater(\n",
        "            lambda m: m.next_to(dl_arc, LEFT, SMALL_BUFF)\n",
        "        )\n",
        "        reflection.add_updater(\n",
        "            lambda m: m.next_to(dr_arc, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "        for word in words:\n",
        "            word.set_background_stroke(width=0)\n",
        "            word.add_updater(lambda m: m.shift(SMALL_BUFF * DOWN))\n",
        "\n",
        "        self.add(incidence)\n",
        "        self.play(\n",
        "            ShowCreation(dl_arc),\n",
        "            UpdateFromAlphaFunc(\n",
        "                VMobject(),\n",
        "                lambda m, a: incidence.set_fill(opacity=a),\n",
        "                remover=True\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(reflection)\n",
        "        self.play(\n",
        "            ShowCreation(dr_arc),\n",
        "            UpdateFromAlphaFunc(\n",
        "                VMobject(),\n",
        "                lambda m, a: reflection.set_fill(opacity=a),\n",
        "                remover=True\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change dr wire angle\n",
        "        # dr_wire.suspend_updating()\n",
        "        dr_wire.clear_updaters()\n",
        "        for angle in [20 * DEGREES, -20 * DEGREES]:\n",
        "            self.play(\n",
        "                Rotate(\n",
        "                    dr_wire, angle,\n",
        "                    about_point=dr_wire.get_end(),\n",
        "                    run_time=2,\n",
        "                ),\n",
        "            )\n",
        "            self.play(\n",
        "                *self.get_shooting_beam_anims(self.ghost_trajectory),\n",
        "                *self.get_shooting_beam_anims(self.d_trajectory),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_reflecting_beam(self):\n",
        "        self.play(\n",
        "            *self.get_shooting_beam_anims(self.trajectory),\n",
        "            *self.get_shooting_beam_anims(self.ghost_trajectory),\n",
        "        )\n",
        "        self.wait()\n"
    ]
}