{
    "topic": "demonstrates the concept of an oscillating vector, which is a mathematical object that represents a",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "import warnings\n",
        "warnings.warn(\"\"\"\n",
        "    Warning: This file makes use of\n",
        "    ContinualAnimation, which has since\n",
        "    been deprecated\n",
        "\"\"\")\n",
        "\n",
        "\n",
        "E_COLOR = BLUE\n",
        "M_COLOR = YELLOW\n",
        "\n",
        "\n",
        "# Warning, much of what is below was implemented using\n",
        "# ConintualAnimation, which has now been deprecated.  One\n",
        "# Should use Mobject updaters instead.\n",
        "# \n",
        "# That is, anything below implemented as a ContinualAnimation\n",
        "# should instead be a Mobject, where the update methods\n",
        "# should be added via Mobject.add_udpater.\n",
        "\n",
        "\n",
        "class OscillatingVector(ContinualAnimation):\n",
        "    CONFIG = {\n",
        "        \"tail\" : ORIGIN,\n",
        "        \"frequency\" : 1,\n",
        "        \"A_vect\" : [1, 0, 0],\n",
        "        \"phi_vect\" : [0, 0, 0],\n",
        "        \"vector_to_be_added_to\" : None,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.vector = self.mobject\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        f = self.frequency\n",
        "        t = self.internal_time\n",
        "        angle = 2*np.pi*f*t\n",
        "        vect = np.array([\n",
        "            A*np.exp(complex(0, angle + phi))\n",
        "            for A, phi in zip(self.A_vect, self.phi_vect)\n",
        "        ]).real\n",
        "        self.update_tail()\n",
        "        self.vector.put_start_and_end_on(self.tail, self.tail+vect)\n",
        "\n",
        "    def update_tail(self):\n",
        "        if self.vector_to_be_added_to is not None:\n",
        "            self.tail = self.vector_to_be_added_to.get_end()\n",
        "\n",
        "class OscillatingVectorComponents(ContinualAnimationGroup):\n",
        "    CONFIG = {\n",
        "        \"tip_to_tail\" : False,\n",
        "    }\n",
        "    def __init__(self, oscillating_vector, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        vx = Vector(UP, color = GREEN).fade()\n",
        "        vy = Vector(UP, color = RED).fade()\n",
        "        kwargs = {\n",
        "            \"frequency\" : oscillating_vector.frequency,\n",
        "            \"tail\" : oscillating_vector.tail,\n",
        "        }\n",
        "        ovx = OscillatingVector(\n",
        "            vx,\n",
        "            A_x = oscillating_vector.A_x,\n",
        "            phi_x = oscillating_vector.phi_x,\n",
        "            A_y = 0,\n",
        "            phi_y = 0,\n",
        "            **kwargs\n",
        "        )\n",
        "        ovy = OscillatingVector(\n",
        "            vy,\n",
        "            A_x = 0,\n",
        "            phi_x = 0,\n",
        "            A_y = oscillating_vector.A_y,\n",
        "            phi_y = oscillating_vector.phi_y,\n",
        "            **kwargs\n",
        "        )\n",
        "        components = [ovx, ovy]\n",
        "        self.vectors = VGroup(ovx.vector, ovy.vector)\n",
        "        if self.tip_to_tail:\n",
        "            ovy.vector_to_be_added_to = ovx.vector\n",
        "        else:\n",
        "            self.lines = VGroup()\n",
        "            for ov1, ov2 in (ovx, ovy), (ovy, ovx):\n",
        "                ov_line = ov1.copy()\n",
        "                ov_line.mobject = ov_line.vector = DashedLine(\n",
        "                    UP, DOWN, color = ov1.vector.get_color()\n",
        "                )\n",
        "                ov_line.vector_to_be_added_to = ov2.vector\n",
        "                components.append(ov_line)\n",
        "                self.lines.add(ov_line.line)\n",
        "\n",
        "        ContinualAnimationGroup.__init__(self, *components, **kwargs)\n",
        "\n",
        "class EMWave(ContinualAnimationGroup):\n",
        "    CONFIG = {\n",
        "        \"wave_number\" : 1,\n",
        "        \"frequency\" : 0.25,\n",
        "        \"n_vectors\" : 40,\n",
        "        \"propogation_direction\" : RIGHT,\n",
        "        \"start_point\" : FRAME_X_RADIUS*LEFT + DOWN + OUT,\n",
        "        \"length\" : FRAME_WIDTH,\n",
        "        \"amplitude\" : 1,\n",
        "        \"rotation\" : 0,\n",
        "        \"A_vect\" : [0, 0, 1],\n",
        "        \"phi_vect\" : [0, 0, 0],\n",
        "        \"requires_start_up\" : False,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        if not all(self.propogation_direction == RIGHT):\n",
        "            self.matrix_transform = np.dot(\n",
        "                z_to_vector(self.propogation_direction),\n",
        "                np.linalg.inv(z_to_vector(RIGHT)),\n",
        "            )\n",
        "        else:\n",
        "            self.matrix_transform = None\n",
        "\n",
        "        vector_oscillations = []\n",
        "        self.E_vects = VGroup()\n",
        "        self.M_vects = VGroup()\n",
        "\n",
        "        self.A_vect = np.array(self.A_vect)/get_norm(self.A_vect)\n",
        "        self.A_vect *= self.amplitude\n",
        "\n",
        "        for alpha in np.linspace(0, 1, self.n_vectors):\n",
        "            tail = interpolate(ORIGIN, self.length*RIGHT, alpha)\n",
        "            phase = -alpha*self.length*self.wave_number\n",
        "            kwargs = {\n",
        "                \"phi_vect\" : np.array(self.phi_vect) + phase,\n",
        "                \"frequency\" : self.frequency,\n",
        "                \"tail\" : np.array(tail),\n",
        "            }\n",
        "            E_ov = OscillatingVector(\n",
        "                Vector(\n",
        "                    OUT, color = E_COLOR,\n",
        "                    normal_vector = UP,\n",
        "                ),\n",
        "                A_vect = self.A_vect,\n",
        "                **kwargs\n",
        "            )\n",
        "            M_ov = OscillatingVector(\n",
        "                Vector(\n",
        "                    UP, color = M_COLOR,\n",
        "                    normal_vector = OUT,\n",
        "                ),\n",
        "                A_vect = rotate_vector(self.A_vect, np.pi/2, RIGHT),\n",
        "                **kwargs\n",
        "            )\n",
        "            vector_oscillations += [E_ov, M_ov]\n",
        "            self.E_vects.add(E_ov.vector)\n",
        "            self.M_vects.add(M_ov.vector)\n",
        "        ContinualAnimationGroup.__init__(self, *vector_oscillations)\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        if self.requires_start_up:\n",
        "            n_wave_lengths = self.length / (2*np.pi*self.wave_number)\n",
        "            prop_time = n_wave_lengths/self.frequency\n",
        "            middle_alpha = interpolate(\n",
        "                0.4, 1.4,\n",
        "                self.external_time / prop_time\n",
        "            )\n",
        "            new_smooth = squish_rate_func(smooth, 0.4, 0.6)\n",
        "\n",
        "            ovs = self.continual_animations\n",
        "            for ov, alpha in zip(ovs, np.linspace(0, 1, len(ovs))):\n",
        "                epsilon = 0.0001\n",
        "                new_amplitude = np.clip(\n",
        "                    new_smooth(middle_alpha - alpha), epsilon, 1\n",
        "                )\n",
        "                norm = get_norm(ov.A_vect)\n",
        "                if norm != 0:\n",
        "                    ov.A_vect = new_amplitude * np.array(ov.A_vect) / norm\n",
        "\n",
        "        ContinualAnimationGroup.update_mobject(self, dt)\n",
        "        self.mobject.rotate(self.rotation, RIGHT)\n",
        "        if self.matrix_transform:\n",
        "            self.mobject.apply_matrix(self.matrix_transform)\n",
        "        self.mobject.shift(self.start_point)\n",
        "\n",
        "class WavePacket(Animation):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"wave_number\" : 0,\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "            \"phi_vect\" : np.ones(3)*np.pi/4,\n",
        "        },\n",
        "        \"em_wave\" : None,\n",
        "        \"run_time\" : 4,\n",
        "        \"rate_func\" : None,\n",
        "        \"packet_width\" : 6,\n",
        "        \"include_E_vects\" : True,\n",
        "        \"include_M_vects\" : True,\n",
        "        \"filter_distance\" : FRAME_X_RADIUS,\n",
        "        \"get_filtered\" : False,\n",
        "        \"remover\" : True,\n",
        "        \"width\" : 2*np.pi,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        em_wave = self.em_wave\n",
        "        if em_wave is None:\n",
        "            em_wave = EMWave(**self.EMWave_config)\n",
        "            em_wave.update(0)\n",
        "            self.em_wave = em_wave\n",
        "\n",
        "        self.vects = VGroup()\n",
        "        if self.include_E_vects:\n",
        "            self.vects.add(*em_wave.E_vects)\n",
        "        if self.include_M_vects:\n",
        "            self.vects.add(*em_wave.M_vects)\n",
        "        for vect in self.vects:\n",
        "            vect.save_state()\n",
        "\n",
        "        u = em_wave.propogation_direction\n",
        "        self.wave_packet_start, self.wave_packet_end = [\n",
        "            em_wave.start_point - u*self.packet_width/2,\n",
        "            em_wave.start_point + u*(em_wave.length + self.packet_width/2)\n",
        "        ]\n",
        "        Animation.__init__(self, self.vects, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        packet_center = interpolate(\n",
        "            self.wave_packet_start,\n",
        "            self.wave_packet_end,\n",
        "            alpha\n",
        "        )\n",
        "        em_wave = self.em_wave\n",
        "        for vect in self.vects:\n",
        "            tail = vect.get_start()\n",
        "            distance_from_packet = np.dot(\n",
        "                tail - packet_center,\n",
        "                em_wave.propogation_direction\n",
        "            )\n",
        "            A = em_wave.amplitude*self.E_func(distance_from_packet)\n",
        "            distance_from_start = get_norm(tail - em_wave.start_point)\n",
        "            if self.get_filtered and distance_from_start > self.filter_distance:\n",
        "                A = 0\n",
        "            epsilon = 0.05\n",
        "            if abs(A) < epsilon:\n",
        "                A = 0\n",
        "            vect.restore()\n",
        "            vect.scale(A/vect.get_length(), about_point = tail)\n",
        "\n",
        "    def E_func(self, x):\n",
        "        x0 = 2*np.pi*x/self.width\n",
        "        return np.sin(x0)*np.exp(-0.25*x0*x0)\n",
        "\n",
        "class FilterLabel(Tex):\n",
        "    def __init__(self, tex, degrees, **kwargs):\n",
        "        Tex.__init__(self, tex + \" \\\\uparrow\", **kwargs)\n",
        "        self[-1].rotate(-degrees * np.pi / 180)\n",
        "\n",
        "class PolarizingFilter(Circle):\n",
        "    CONFIG = {\n",
        "        \"stroke_color\" : GREY_D,\n",
        "        \"fill_color\" : GREY_B,\n",
        "        \"fill_opacity\" : 0.5,\n",
        "        \"label_tex\" : None,\n",
        "        \"filter_angle\" : 0,\n",
        "        \"include_arrow_label\" : True,\n",
        "        \"arrow_length\" : 0.7,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        Circle.__init__(self, **kwargs)\n",
        "\n",
        "        if self.label_tex:\n",
        "            self.label = OldTex(self.label_tex)\n",
        "            self.label.next_to(self.get_top(), DOWN, MED_SMALL_BUFF)\n",
        "            self.add(self.label)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            ORIGIN, self.arrow_length*UP, \n",
        "            color = WHITE,\n",
        "            buff = 0,\n",
        "        )\n",
        "        arrow.shift(self.get_top())\n",
        "        arrow.rotate(-self.filter_angle)\n",
        "        self.add(arrow)\n",
        "        self.arrow = arrow\n",
        "        shade_in_3d(self)\n",
        "\n",
        "        if self.include_arrow_label:\n",
        "            arrow_label = OldTex(\n",
        "                \"%.1f^\\\\circ\"%(self.filter_angle*180/np.pi)\n",
        "            )\n",
        "            arrow_label.add_background_rectangle()\n",
        "            arrow_label.next_to(arrow.get_tip(), UP)\n",
        "            self.add(arrow_label)\n",
        "            self.arrow_label = arrow_label\n",
        "\n",
        "################\n",
        "\n",
        "class FilterScene(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [0],\n",
        "        \"pol_filter_configs\" : [{}],\n",
        "        \"EMWave_config\" : {\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT + DOWN+OUT\n",
        "        },\n",
        "        \"axes_config\" : {},\n",
        "        \"start_phi\" : 0.8*np.pi/2,\n",
        "        \"start_theta\" : -0.6*np.pi,\n",
        "        \"ambient_rotation_rate\" : 0.01,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.axes = ThreeDAxes(**self.axes_config)\n",
        "        self.add(self.axes)\n",
        "        for x in range(len(self.filter_x_coordinates) - len(self.pol_filter_configs)):\n",
        "            self.pol_filter_configs.append({})\n",
        "        self.pol_filters = VGroup(*[\n",
        "            PolarizingFilter(**config)\n",
        "            for config in self.pol_filter_configs\n",
        "        ])\n",
        "        self.pol_filters.rotate(np.pi/2, RIGHT)\n",
        "        self.pol_filters.rotate(-np.pi/2, OUT)\n",
        "        pol_filter_shift = np.array(self.EMWave_config[\"start_point\"])\n",
        "        pol_filter_shift[0] = 0\n",
        "        self.pol_filters.shift(pol_filter_shift)\n",
        "        for x, pf in zip(self.filter_x_coordinates, self.pol_filters):\n",
        "            pf.shift(x*RIGHT)\n",
        "        self.add(self.pol_filters)\n",
        "        self.pol_filter = self.pol_filters[0]\n",
        "\n",
        "        self.set_camera_orientation(self.start_phi, self.start_theta)\n",
        "        if self.ambient_rotation_rate > 0:\n",
        "            self.begin_ambient_camera_rotation(self.ambient_rotation_rate)\n",
        "\n",
        "    def get_filter_absorption_animation(self, pol_filter, photon):\n",
        "        x = pol_filter.get_center()[0]\n",
        "        alpha = (x + FRAME_X_RADIUS) / (FRAME_WIDTH)\n",
        "        return ApplyMethod(\n",
        "            pol_filter.set_fill, RED,\n",
        "            run_time = photon.run_time,\n",
        "            rate_func = squish_rate_func(there_and_back, alpha - 0.1, alpha + 0.1)\n",
        "        )\n",
        "\n",
        "class DirectionOfPolarizationScene(FilterScene):\n",
        "    CONFIG = {\n",
        "        \"pol_filter_configs\" : [{\n",
        "            \"include_arrow_label\" : False,\n",
        "        }],\n",
        "        \"target_theta\" : -0.97*np.pi,\n",
        "        \"target_phi\" : 0.9*np.pi/2,\n",
        "        \"ambient_rotation_rate\" : 0.005,\n",
        "        \"apply_filter\" : False,\n",
        "        \"quantum\" : False,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.reference_line = Line(ORIGIN, RIGHT)\n",
        "        self.reference_line.set_stroke(width = 0)\n",
        "        self.em_wave = EMWave(**self.EMWave_config)\n",
        "        self.add(self.em_wave)\n",
        "\n",
        "        FilterScene.setup(self)\n",
        "\n",
        "    def change_polarization_direction(self, angle, **kwargs):\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.reference_line.rotate, angle,\n",
        "                **kwargs\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def setup_rectangles(self):\n",
        "        rect1 = Rectangle(\n",
        "            height = 2*self.em_wave.amplitude,\n",
        "            width = FRAME_X_RADIUS + 0.25,\n",
        "            stroke_color = BLUE,\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.2,\n",
        "        )\n",
        "        rect1.rotate(np.pi/2, RIGHT)\n",
        "        pf_copy = self.pol_filter.deepcopy()\n",
        "        pf_copy.remove(pf_copy.arrow)\n",
        "        center = pf_copy.get_center()\n",
        "        rect1.move_to(center, RIGHT)\n",
        "        rect2 = rect1.copy()\n",
        "        rect2.move_to(center, LEFT)\n",
        "\n",
        "        self.rectangles = VGroup(rect1, rect2)\n",
        "\n",
        "    def update_mobjects(self, *args, **kwargs):\n",
        "        reference_angle = self.reference_line.get_angle()\n",
        "        self.em_wave.rotation = reference_angle\n",
        "        FilterScene.update_mobjects(self, *args, **kwargs)\n",
        "        if self.apply_filter:\n",
        "            self.apply_filters()\n",
        "        self.update_rectangles()\n",
        "\n",
        "    def apply_filters(self):\n",
        "        vect_groups = [self.em_wave.E_vects, self.em_wave.M_vects]\n",
        "        filters = sorted(\n",
        "            self.pol_filters,\n",
        "            lambda pf1, pf2 : cmp(\n",
        "                pf1.get_center()[0], \n",
        "                pf2.get_center()[0],\n",
        "            )\n",
        "        )\n",
        "        for pol_filter in filters:\n",
        "            filter_x = pol_filter.arrow.get_center()[0]\n",
        "            for vect_group, angle in zip(vect_groups, [0, -np.pi/2]):\n",
        "                target_angle = pol_filter.filter_angle + angle\n",
        "                for vect_mob in vect_group:\n",
        "                    vect = vect_mob.get_vector()\n",
        "                    vect_angle = angle_of_vector([\n",
        "                        vect[2], -vect[1]\n",
        "                    ])\n",
        "                    angle_diff = target_angle - vect_angle\n",
        "                    angle_diff = (angle_diff+np.pi/2)%np.pi - np.pi/2\n",
        "                    start, end = vect_mob.get_start_and_end()\n",
        "                    if start[0] > filter_x:\n",
        "                        vect_mob.rotate(angle_diff, RIGHT)\n",
        "                        if not self.quantum:\n",
        "                            vect_mob.scale(\n",
        "                                np.cos(angle_diff),\n",
        "                                about_point = start,\n",
        "                            )\n",
        "\n",
        "    def update_rectangles(self):\n",
        "        if not hasattr(self, \"rectangles\") or self.rectangles not in self.mobjects:\n",
        "            return\n",
        "\n",
        "        r1, r2 = self.rectangles\n",
        "\n",
        "        target_angle = self.reference_line.get_angle()\n",
        "        anchors = r1.get_anchors()\n",
        "        vect = anchors[0] - anchors[3]\n",
        "        curr_angle = angle_of_vector([vect[2], -vect[1]])\n",
        "        r1.rotate(target_angle - curr_angle, RIGHT)\n",
        "\n",
        "        epsilon = 0.001\n",
        "        curr_depth = max(r2.get_depth(), epsilon)\n",
        "        target_depth = max(\n",
        "            2*self.em_wave.amplitude*abs(np.cos(target_angle)),\n",
        "            epsilon\n",
        "        )\n",
        "        r2.stretch_in_place(target_depth/curr_depth, 2)\n",
        "\n",
        "################\n",
        "\n",
        "class WantToLearnQM(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        question1 = OldTex(\n",
        "            \"\\\\text{What does }\\\\qquad \\\\\\\\\", \n",
        "            \"|\\\\!\\\\psi \\\\rangle\", \"=\",\n",
        "            \"\\\\frac{1}{\\\\sqrt{2}}\", \"|\\\\!\\\\uparrow \\\\rangle\", \"+\",\n",
        "            \"\\\\frac{1}{\\\\sqrt{2}}\", \"|\\\\!\\\\downarrow \\\\rangle \\\\\\\\\",\n",
        "            \"\\\\text{mean?}\\\\qquad\\\\quad\"\n",
        "        )\n",
        "        question1.set_color_by_tex_to_color_map({\n",
        "            \"psi\" : BLUE,\n",
        "            \"uparrow\" : GREEN,\n",
        "            \"downarrow\" : RED,\n",
        "        })\n",
        "        question2 = OldTexText(\n",
        "            \"Why are complex \\\\\\\\ numbers involved?\"\n",
        "        )\n",
        "        question3 = OldTexText(\n",
        "            \"How do you compute \\\\\\\\ quantum probabilities?\"\n",
        "        )\n",
        "        questions = [question1, question2, question3]\n",
        "        bubbles = VGroup()\n",
        "\n",
        "        for i, question in zip([1, 2, 0], questions):\n",
        "            self.student_says(\n",
        "                question, \n",
        "                content_introduction_kwargs = {\"run_time\" : 2},\n",
        "                index = i,\n",
        "                bubble_config = {\"fill_opacity\" : 1},\n",
        "                bubble_creation_class = FadeIn,\n",
        "            )\n",
        "            bubble = self.students[i].bubble\n",
        "            bubble.add(bubble.content)\n",
        "            bubbles.add(bubble)\n",
        "            self.students\n",
        "            self.students[i].bubble = None\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"First, lots and lots \\\\\\\\ of linear algebra\",\n",
        "            added_anims = list(map(FadeOut, bubbles))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class Goal(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        goal = OldTexText(\"Goal: \")\n",
        "        goal.set_color(YELLOW)\n",
        "        goal.shift(FRAME_X_RADIUS*LEFT/2 + UP)\n",
        "        weirdness = OldTexText(\"Eye-catching quantum weirdness\")\n",
        "        weirdness.next_to(goal, RIGHT)\n",
        "        cross = Cross(weirdness)\n",
        "        foundations = OldTexText(\"Foundational intuitions\")\n",
        "        foundations.next_to(goal, RIGHT)\n",
        "\n",
        "        goal.save_state()\n",
        "        goal.scale(0.01)\n",
        "        goal.move_to(randy.get_right())\n",
        "\n",
        "        self.play(\n",
        "            goal.restore,\n",
        "            randy.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(Write(weirdness, run_time = 2))\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            randy.change, \"sassy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(weirdness, cross).shift, DOWN,\n",
        "            Write(foundations, run_time = 2),\n",
        "            randy.change, \"happy\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().to_corner(DOWN+LEFT)\n",
        "\n",
        "class AskWhatsDifferentInQM(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What's different in \\\\\\\\ quantum mechanics?\"\n",
        "        )\n",
        "        self.play(self.teacher.change, \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class VideoWrapper(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(self.title)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_height(6)\n",
        "        rect.next_to(title, DOWN)\n",
        "        self.add(rect)\n",
        "        self.wait()\n",
        "\n",
        "class BellsWrapper(VideoWrapper):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Bell's inequalities\"\n",
        "    }\n",
        "\n",
        "class FromOtherVideoWrapper(VideoWrapper):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"See the other video...\"\n",
        "    }\n",
        "\n",
        "class OriginOfQuantumMechanicsWrapper(VideoWrapper):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"The origin of quantum mechanics\"\n",
        "    }\n",
        "\n",
        "class IntroduceElectricField(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"vector_field_colors\" : [BLUE_B, BLUE_D],\n",
        "        \"max_vector_length\" : 0.9,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.write_title()\n",
        "        self.draw_field()\n",
        "        self.add_particle()\n",
        "        self.let_particle_wander()\n",
        "\n",
        "    def write_title(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"Electro\", \"magnetic\", \" field\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        title.next_to(morty, UP+LEFT)\n",
        "        electric = OldTexText(\"Electric\")\n",
        "        electric.next_to(title[-1], LEFT)\n",
        "        electric.set_color(BLUE)\n",
        "\n",
        "        title.save_state()\n",
        "        title.shift(DOWN)\n",
        "        title.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            title.restore,\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(\n",
        "            title[0].set_color, BLUE,\n",
        "            title[1].set_color, YELLOW,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShrinkToCenter(title[1]),\n",
        "            Transform(title[0], electric)\n",
        "        )\n",
        "\n",
        "        title.add_background_rectangle()\n",
        "        self.title = title\n",
        "\n",
        "    def draw_field(self):\n",
        "        morty = self.pi_creature\n",
        "        vector_field = self.get_vector_field()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, vector_field, \n",
        "                run_time = 3\n",
        "            ),\n",
        "            self.title.center,\n",
        "            self.title.scale, 1.5,\n",
        "            self.title.to_edge, UP,\n",
        "            morty.change, \"happy\", ORIGIN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.vector_field = vector_field\n",
        "\n",
        "    def add_particle(self):\n",
        "        morty = self.pi_creature\n",
        "        point = UP+LEFT + SMALL_BUFF*(UP+RIGHT)\n",
        "        particle = self.get_particle()\n",
        "        particle.move_to(point)\n",
        "\n",
        "        vector = self.get_vector(particle.get_center())\n",
        "        vector.set_color(RED)\n",
        "        vector.scale(1.5, about_point = point)\n",
        "        vector.shift(SMALL_BUFF*vector.get_vector())\n",
        "        force = OldTexText(\"Force\")\n",
        "        force.next_to(ORIGIN, UP+RIGHT, SMALL_BUFF)\n",
        "        force.rotate(vector.get_angle())\n",
        "        force.shift(vector.get_start())\n",
        "\n",
        "        particle.save_state()\n",
        "        particle.move_to(morty.get_left() + 0.5*UP + 0.2*RIGHT)\n",
        "        particle.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            particle.restore,\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(morty.change, \"thinking\", particle)\n",
        "        self.play(\n",
        "            ShowCreation(vector),\n",
        "            Write(force, run_time = 1),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.particle = particle\n",
        "        self.force_vector = VGroup(vector, force)\n",
        "\n",
        "    def let_particle_wander(self):\n",
        "        possible_points = [v.get_start() for v in self.vector_field]\n",
        "        points = random.sample(possible_points, 45)\n",
        "        points.append(3*UP+3*LEFT)\n",
        "        particles = VGroup(self.particle, *[\n",
        "            self.particle.copy().move_to(point)\n",
        "            for point in points\n",
        "        ])\n",
        "        for particle in particles:\n",
        "            particle.velocity = np.zeros(3)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.force_vector),\n",
        "            LaggedStartMap(FadeIn, VGroup(*particles[1:]))\n",
        "        )\n",
        "        self.moving_particles = particles\n",
        "        self.add_foreground_mobjects(self.moving_particles, self.pi_creature)\n",
        "        self.always_update_mobjects = True\n",
        "        self.wait(10)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def update_mobjects(self, *args, **kwargs):\n",
        "        Scene.update_mobjects(self, *args, **kwargs)\n",
        "        if hasattr(self, \"moving_particles\"):\n",
        "            dt = self.frame_duration\n",
        "            for p in self.moving_particles:\n",
        "                vect = self.field_function(p.get_center())\n",
        "                p.velocity += vect*dt\n",
        "                p.shift(p.velocity*dt)\n",
        "            self.pi_creature.look_at(self.moving_particles[-1])\n",
        "\n",
        "    def get_particle(self):\n",
        "        particle = Circle(radius = 0.2)\n",
        "        particle.set_stroke(RED, 3)\n",
        "        particle.set_fill(RED, 0.5)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.scale(0.7)\n",
        "        plus.move_to(particle)\n",
        "        particle.add(plus)\n",
        "        return particle\n",
        "\n",
        "    def get_vector_field(self):\n",
        "        result = VGroup(*[\n",
        "            self.get_vector(point)\n",
        "            for x in np.arange(-9, 9)\n",
        "            for y in np.arange(-5, 5)\n",
        "            for point in [x*RIGHT + y*UP]\n",
        "        ])\n",
        "        shading_list = list(result)\n",
        "        shading_list.sort(\n",
        "            key=lambda m: m1.get_length()\n",
        "        )\n",
        "        VGroup(*shading_list).set_color_by_gradient(*self.vector_field_colors)\n",
        "        result.set_fill(opacity = 0.75)\n",
        "        result.sort(get_norm)\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_vector(self, point):\n",
        "        return Vector(self.field_function(point)).shift(point)\n",
        "\n",
        "    def field_function(self, point):\n",
        "        x, y = point[:2]\n",
        "        result = y*RIGHT + np.sin(x)*UP\n",
        "        return self.normalized(result)\n",
        "\n",
        "    def normalized(self, vector):\n",
        "        norm = get_norm(vector) or 1\n",
        "        target_length = self.max_vector_length * sigmoid(0.1*norm)\n",
        "        return target_length * vector/norm\n",
        "\n",
        "class IntroduceMagneticField(IntroduceElectricField, ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"vector_field_colors\" : [YELLOW_C, YELLOW_D]\n",
        "    }\n",
        "    def setup(self):\n",
        "        IntroduceElectricField.setup(self)\n",
        "        self.remove(self.pi_creature)\n",
        "\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(0.1, -np.pi/2)\n",
        "        self.add_title()\n",
        "        self.add_vector_field()\n",
        "        self.introduce_moving_charge()\n",
        "        self.show_force()\n",
        "        # self.many_charges()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Magnetic\", \"field\")\n",
        "        title[0].set_color(YELLOW)\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.add_background_rectangle()\n",
        "\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def add_vector_field(self):\n",
        "        vector_field = self.get_vector_field()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, vector_field, run_time = 3),\n",
        "            Animation(self.title)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def introduce_moving_charge(self):\n",
        "        point = 3*RIGHT + UP\n",
        "        particle = self.get_particle()\n",
        "        particle.move_to(point)\n",
        "\n",
        "        velocity = Vector(2*RIGHT).shift(particle.get_right())\n",
        "        velocity.set_color(WHITE)\n",
        "        velocity_word = OldTexText(\"Velocity\")\n",
        "        velocity_word.set_color(velocity.get_color())\n",
        "        velocity_word.add_background_rectangle()\n",
        "        velocity_word.next_to(velocity, UP, 0, LEFT)\n",
        "\n",
        "        M_vect = self.get_vector(point)\n",
        "        M_vect.set_color(YELLOW)\n",
        "        M_vect.shift(SMALL_BUFF*M_vect.get_vector())\n",
        "\n",
        "        particle.save_state()\n",
        "        particle.shift(FRAME_WIDTH*LEFT)\n",
        "\n",
        "        self.play(\n",
        "            particle.restore,\n",
        "            run_time = 2,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.add(velocity)\n",
        "        self.play(Write(velocity_word, run_time = 0.5))\n",
        "        # self.play(ShowCreation(M_vect))\n",
        "        self.wait()\n",
        "\n",
        "        self.particle = particle\n",
        "\n",
        "    def show_force(self):\n",
        "        point = self.particle.get_center()\n",
        "        F_vect = Vector(\n",
        "            3*np.cross(self.field_function(point), RIGHT),\n",
        "            color = GREEN\n",
        "        )\n",
        "        F_vect.shift(point)\n",
        "        F_word = OldTexText(\"Force\")\n",
        "        F_word.rotate(np.pi/2, RIGHT)\n",
        "        F_word.next_to(F_vect, OUT)\n",
        "        F_word.set_color(F_vect.get_color())\n",
        "        F_eq = OldTex(\n",
        "            \"=\",\"q\", \"\\\\textbf{v}\", \"\\\\times\", \"\\\\textbf{B}\"\n",
        "        )\n",
        "        F_eq.set_color_by_tex_to_color_map({\n",
        "            \"q\" : RED,\n",
        "            \"B\" : YELLOW,\n",
        "        })\n",
        "        F_eq.rotate(np.pi/2, RIGHT)\n",
        "        F_eq.next_to(F_word, RIGHT)\n",
        "\n",
        "\n",
        "        self.move_camera(0.8*np.pi/2, -0.55*np.pi)\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.play(ShowCreation(F_vect))\n",
        "        self.play(Write(F_word))\n",
        "        self.wait()\n",
        "        self.play(Write(F_eq))\n",
        "        self.wait(8)\n",
        "\n",
        "    def many_charges(self):\n",
        "        charges = VGroup()\n",
        "        for y in range(2, 3):\n",
        "            charge = self.get_particle()\n",
        "            charge.move_to(3*LEFT + y*UP)\n",
        "            charge.velocity = (2*RIGHT).astype('float')\n",
        "            charges.add(charge)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.add_foreground_mobjects(*charges)\n",
        "        self.moving_particles = charges\n",
        "        self.wait(5)\n",
        "\n",
        "        \n",
        "    ###\n",
        "\n",
        "    def update_mobjects(self, *args, **kwargs):\n",
        "        Scene.update_mobjects(self, *args, **kwargs)\n",
        "        if hasattr(self, \"moving_particles\"):\n",
        "            dt = self.frame_duration\n",
        "            for p in self.moving_particles:\n",
        "                M_vect = self.field_function(p.get_center())\n",
        "                F_vect = 3*np.cross(p.velocity, M_vect)\n",
        "                p.velocity += F_vect*dt\n",
        "                p.shift(p.velocity*dt)\n",
        "\n",
        "    def field_function(self, point):\n",
        "        x, y = point[:2]\n",
        "        y += 0.5\n",
        "        gauss = lambda r : np.exp(-0.5*r**2)\n",
        "        result = (y**2 - 1)*RIGHT + x*(gauss(y+2) - gauss(y-2))*UP\n",
        "        return self.normalized(result)\n",
        "\n",
        "class CurlRelationBetweenFields(ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.loop_in_E()\n",
        "        self.loop_in_M()\n",
        "        self.second_loop_in_E()\n",
        "\n",
        "    def add_axes(self):\n",
        "        self.add(ThreeDAxes(x_axis_radius = FRAME_X_RADIUS))\n",
        "\n",
        "    def loop_in_E(self):\n",
        "        E_vects = VGroup(*[\n",
        "            Vector(0.5*rotate_vector(vect, np.pi/2)).shift(vect)\n",
        "            for vect in compass_directions(8)\n",
        "        ])\n",
        "        E_vects.set_color(E_COLOR)\n",
        "        point = 1.2*RIGHT + 2*UP + OUT\n",
        "        E_vects.shift(point)\n",
        "\n",
        "        M_vect = Vector(\n",
        "            IN, \n",
        "            normal_vector = DOWN,\n",
        "            color = M_COLOR\n",
        "        )\n",
        "        M_vect.shift(point)\n",
        "        M_vect.save_state()\n",
        "        M_vect.scale(0.01, about_point = M_vect.get_start())\n",
        "\n",
        "        self.play(ShowCreation(E_vects, run_time = 2))\n",
        "        self.wait()\n",
        "        self.move_camera(0.8*np.pi/2, -0.45*np.pi)\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.play(M_vect.restore, run_time = 3, rate_func=linear)\n",
        "        self.wait(3)\n",
        "\n",
        "        self.E_vects = E_vects\n",
        "        self.E_circle_center = point\n",
        "        self.M_vect = M_vect\n",
        "\n",
        "    def loop_in_M(self):\n",
        "        M_vects = VGroup(*[\n",
        "            Vector(\n",
        "                rotate_vector(vect, np.pi/2),\n",
        "                normal_vector = IN,\n",
        "                color = M_COLOR\n",
        "            ).shift(vect)\n",
        "            for vect in compass_directions(8, LEFT)[1:]\n",
        "        ])\n",
        "        M_vects.rotate(np.pi/2, RIGHT)\n",
        "        new_point = self.E_circle_center + RIGHT\n",
        "        M_vects.shift(new_point)\n",
        "\n",
        "        E_vect = self.E_vects[0]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(M_vects, run_time = 2),\n",
        "            *list(map(FadeOut, self.E_vects[1:]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            E_vect.rotate, np.pi, RIGHT, [], new_point,\n",
        "            E_vect.scale_about_point, 3, new_point,\n",
        "            run_time = 4,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.M_circle_center = new_point\n",
        "        M_vects.add(self.M_vect)\n",
        "        self.M_vects = M_vects\n",
        "        self.E_vect = E_vect\n",
        "\n",
        "    def second_loop_in_E(self):\n",
        "        E_vects = VGroup(*[\n",
        "            Vector(1.5*rotate_vector(vect, np.pi/2)).shift(vect)\n",
        "            for vect in compass_directions(8, LEFT)[1:]\n",
        "        ])\n",
        "        E_vects.set_color(E_COLOR)\n",
        "        point = self.M_circle_center + RIGHT\n",
        "        E_vects.shift(point)\n",
        "\n",
        "        M_vect = self.M_vects[3]\n",
        "        self.M_vects.remove(M_vect)\n",
        "\n",
        "        self.play(FadeOut(self.M_vects))\n",
        "        self.play(ShowCreation(E_vects), Animation(M_vect))\n",
        "        self.play(\n",
        "            M_vect.rotate, np.pi, RIGHT, [], point,\n",
        "            run_time = 5,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class WriteCurlEquations(Scene):\n",
        "    def construct(self):\n",
        "        eq1 = OldTex(\n",
        "            \"\\\\nabla \\\\times\", \"\\\\textbf{E}\", \"=\",\n",
        "            \"-\\\\frac{1}{c}\", \n",
        "            \"\\\\frac{\\\\partial \\\\textbf{B}}{\\\\partial t}\"\n",
        "        )\n",
        "        eq2 = OldTex(\n",
        "            \"\\\\nabla \\\\times\", \"\\\\textbf{B}\", \"=^*\",\n",
        "            \"\\\\frac{1}{c}\", \n",
        "            \"\\\\frac{\\\\partial \\\\textbf{E}}{\\\\partial t}\"\n",
        "        )\n",
        "        eqs = VGroup(eq1, eq2)\n",
        "        eqs.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        eqs.set_height(FRAME_HEIGHT - 1)\n",
        "        eqs.to_edge(LEFT)\n",
        "        for eq in eqs:\n",
        "            eq.set_color_by_tex_to_color_map({\n",
        "                \"E\" : E_COLOR,            \n",
        "                \"B\" : M_COLOR,\n",
        "            })\n",
        "        footnote = OldTexText(\"*Ignoring currents\")\n",
        "        footnote.next_to(eqs[1], RIGHT)\n",
        "        footnote.to_edge(RIGHT)\n",
        "\n",
        "        self.play(Write(eq1, run_time = 2))\n",
        "        self.wait(3)\n",
        "        self.play(Write(eq2, run_time = 2))\n",
        "        self.play(FadeIn(footnote))\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceEMWave(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"requires_start_up\" : True\n",
        "        }\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.axes = ThreeDAxes()\n",
        "        self.add(self.axes)\n",
        "        self.em_wave = EMWave(**self.EMWave_config)\n",
        "        self.add(self.em_wave)\n",
        "        self.set_camera_orientation(0.8*np.pi/2, -0.7*np.pi)\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Electro\", \"magnetic\", \" radiation\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.set_color_by_tex_to_color_map({\n",
        "            \"Electro\" : E_COLOR,\n",
        "            \"magnetic\" : M_COLOR,\n",
        "        })\n",
        "        words.next_to(ORIGIN, LEFT, MED_LARGE_BUFF)\n",
        "        words.to_edge(UP)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        self.wait(7)\n",
        "        self.play(Write(words, run_time = 2))\n",
        "        self.wait(20)\n",
        "\n",
        "    #####\n",
        "\n",
        "class SimpleEMWave(IntroduceEMWave):\n",
        "    def construct(self):\n",
        "        self.wait(30)\n",
        "\n",
        "class ListRelevantWaveIdeas(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Wave\",\"topics\")\n",
        "        title.to_corner(UP + LEFT, LARGE_BUFF)\n",
        "        title.set_color(BLUE)\n",
        "        h_line = Line(title.get_left(), title.get_right())\n",
        "        h_line.next_to(title, DOWN, SMALL_BUFF)\n",
        "\n",
        "        topics = VGroup(*list(map(TexText, [\n",
        "            \"- Superposition\",\n",
        "            \"- Amplitudes\",\n",
        "            \"- How phase influences addition\",\n",
        "        ])))\n",
        "        topics.scale(0.8)\n",
        "        topics.arrange(DOWN, aligned_edge = LEFT)\n",
        "        topics.next_to(h_line, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        quantum = OldTexText(\"Quantum\")\n",
        "        quantum.set_color(GREEN)\n",
        "        quantum.move_to(title[0], LEFT)\n",
        "\n",
        "        wave_point = self.teacher.get_corner(UP+LEFT) + 2*UP\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(wave_point)),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(title, run_time = 2),\n",
        "            ShowCreation(h_line)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            added_anims = [LaggedStartMap(\n",
        "                FadeIn, topics,\n",
        "                run_time = 3\n",
        "            )],\n",
        "            look_at = title\n",
        "        )\n",
        "        self.play(\n",
        "            Animation(title),\n",
        "            self.teacher.change, \"happy\"\n",
        "        )\n",
        "        self.play(\n",
        "            title[0].next_to, quantum.copy(), UP, MED_SMALL_BUFF, LEFT,\n",
        "            title[0].fade, 0.5,\n",
        "            title[1].next_to, quantum.copy(), RIGHT, 2*SMALL_BUFF,\n",
        "            Write(quantum),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "class DirectWaveOutOfScreen(IntroduceEMWave):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"requires_start_up\" : False,\n",
        "            \"amplitude\" : 2,\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "            \"A_vect\" : [0, 1, 0],\n",
        "            \"start_up_time\" : 0,\n",
        "        }\n",
        "    }\n",
        "    def setup(self):\n",
        "        IntroduceEMWave.setup(self)\n",
        "        self.remove(self.axes)\n",
        "        for ov in self.em_wave.continual_animations:\n",
        "            ov.vector.normal_vector = RIGHT\n",
        "        self.set_camera_orientation(0.9*np.pi/2, -0.3*np.pi)\n",
        "\n",
        "    def construct(self):\n",
        "        self.move_into_position()\n",
        "        self.fade_M_vects()\n",
        "        self.fade_all_but_last_E_vects()\n",
        "\n",
        "    def move_into_position(self):\n",
        "        self.wait(2)\n",
        "        self.update_mobjects()\n",
        "        faded_vectors = VGroup(*[\n",
        "            ov.vector\n",
        "            for ov in self.em_wave.continual_animations[:-2]\n",
        "        ])\n",
        "        self.move_camera(\n",
        "            0.99*np.pi/2, -0.01,\n",
        "            run_time = 2,\n",
        "            added_anims = [faded_vectors.set_fill, None, 0.5]\n",
        "        )\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            np.pi/2, 0,\n",
        "            added_anims = [faded_vectors.set_fill, None, 0.05],\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.faded_vectors = faded_vectors\n",
        "\n",
        "    def fade_M_vects(self):\n",
        "        self.play(\n",
        "            self.em_wave.M_vects.set_fill, None, 0\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def fade_all_but_last_E_vects(self):\n",
        "        self.play(self.faded_vectors.set_fill, None, 0)\n",
        "        self.wait(4)\n",
        "\n",
        "class ShowVectorEquation(Scene):\n",
        "    CONFIG = {\n",
        "        \"f_color\" : RED,\n",
        "        \"phi_color\" : MAROON_B,\n",
        "        \"A_color\" : GREEN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_vector()\n",
        "        self.add_plane()\n",
        "        self.write_horizontally_polarized()\n",
        "        self.write_components()\n",
        "        self.show_graph()\n",
        "        self.add_phi()\n",
        "        self.add_amplitude()\n",
        "        self.add_kets()\n",
        "        self.switch_to_vertically_polarized_light()\n",
        "\n",
        "    def add_vector(self):\n",
        "        self.vector = Vector(2*RIGHT, color = E_COLOR)\n",
        "        self.oscillating_vector = OscillatingVector(\n",
        "            self.vector,\n",
        "            A_vect = [2, 0, 0],\n",
        "            frequency = 0.25,\n",
        "        )\n",
        "        self.add(self.oscillating_vector)\n",
        "        self.wait(3)\n",
        "\n",
        "    def add_plane(self):\n",
        "        xy_plane = NumberPlane(\n",
        "            axes_color = GREY_B,\n",
        "            color = GREY_D,\n",
        "            secondary_color = GREY_D,\n",
        "            x_unit_size = 2,\n",
        "            y_unit_size = 2,\n",
        "        )\n",
        "        xy_plane.add_coordinates()\n",
        "        xy_plane.add(xy_plane.get_axis_labels())\n",
        "\n",
        "        self.play(\n",
        "            Write(xy_plane),\n",
        "            Animation(self.vector)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.xy_plane = xy_plane\n",
        "\n",
        "    def write_horizontally_polarized(self):\n",
        "        words = OldTexText(\n",
        "            \"``\", \"Horizontally\", \" polarized\", \"''\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.next_to(ORIGIN, LEFT)\n",
        "        words.to_edge(UP)\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        self.play(Write(words, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "        self.horizontally_polarized_words = words\n",
        "\n",
        "    def write_components(self):\n",
        "        x, y = components = VGroup(\n",
        "            OldTex(\"\\\\cos(\", \"2\\\\pi\", \"f_x\", \"t\", \"+ \", \"\\\\phi_x\", \")\"),\n",
        "            OldTex(\"0\", \"\")\n",
        "        )\n",
        "        components.arrange(DOWN)\n",
        "        lb, rb = brackets = OldTex(\"[]\")\n",
        "        brackets.set_height(components.get_height() + SMALL_BUFF)\n",
        "        lb.next_to(components, LEFT, buff = 0.3)\n",
        "        rb.next_to(components, RIGHT, buff = 0.3)\n",
        "        E, equals = E_equals = OldTex(\n",
        "            \"\\\\vec{\\\\textbf{E}}\", \"=\"\n",
        "        )\n",
        "        E.set_color(E_COLOR)\n",
        "        E_equals.next_to(brackets, LEFT)\n",
        "        E_equals.add_background_rectangle()\n",
        "        brackets.add_background_rectangle()\n",
        "        group = VGroup(E_equals, brackets, components)\n",
        "        group.next_to(\n",
        "            self.horizontally_polarized_words, \n",
        "            DOWN, MED_LARGE_BUFF, RIGHT\n",
        "        )\n",
        "\n",
        "        x_without_phi = OldTex(\"\\\\cos(\", \"2\\\\pi\", \"f_x\", \"t\", \")\")\n",
        "        x_without_phi.move_to(x)\n",
        "        for mob in x, x_without_phi:\n",
        "            mob.set_color_by_tex_to_color_map({\n",
        "                \"f_x\" : self.f_color,\n",
        "                \"phi_x\" : self.phi_color,\n",
        "            })\n",
        "\n",
        "        def update_brace(brace):\n",
        "            brace.stretch_to_fit_width(\n",
        "                max(self.vector.get_width(), 0.001)\n",
        "            )\n",
        "            brace.next_to(self.vector.get_center(), DOWN, SMALL_BUFF)\n",
        "            return brace\n",
        "        moving_brace = Mobject.add_updater(\n",
        "            Brace(Line(LEFT, RIGHT), DOWN), update_brace\n",
        "        )\n",
        "        moving_x_without_phi = Mobject.add_updater(\n",
        "            x_without_phi.copy().add_background_rectangle(),\n",
        "            lambda m : m.next_to(moving_brace.mobject, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.play(Write(E_equals), Write(brackets))\n",
        "        y.save_state()\n",
        "        y.move_to(self.horizontally_polarized_words)\n",
        "        y.set_fill(opacity = 0)\n",
        "        self.play(y.restore)\n",
        "        self.wait()\n",
        "        self.add(moving_brace, moving_x_without_phi)\n",
        "        self.play(\n",
        "            FadeIn(moving_brace.mobject),\n",
        "            FadeIn(x_without_phi),\n",
        "            FadeIn(moving_x_without_phi.mobject),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(moving_brace.mobject),\n",
        "            FadeOut(moving_x_without_phi.mobject),\n",
        "        )\n",
        "        self.remove(moving_brace, moving_x_without_phi)\n",
        "\n",
        "        self.E_equals = E_equals\n",
        "        self.brackets = brackets\n",
        "        self.x_without_phi = x_without_phi\n",
        "        self.components = components\n",
        "\n",
        "    def show_graph(self):\n",
        "        axes = Axes(\n",
        "            x_min = -0.5,\n",
        "            x_max = 5.2,\n",
        "            y_min = -1.5,\n",
        "            y_max = 1.5,\n",
        "        )\n",
        "        axes.x_axis.add_numbers(*list(range(1, 6)))\n",
        "        t = OldTex(\"t\")\n",
        "        t.next_to(axes.x_axis, UP, SMALL_BUFF, RIGHT)\n",
        "        cos = self.x_without_phi.copy()\n",
        "        cos.next_to(axes.y_axis, RIGHT, SMALL_BUFF, UP)\n",
        "        cos_arg = VGroup(*cos[1:-1])\n",
        "        fx_equals_1 = OldTex(\"f_x\", \"= 1\")\n",
        "        fx_equals_fourth = OldTex(\"f_x\", \"= 0.25\")\n",
        "        fx_group = VGroup(fx_equals_1, fx_equals_fourth)\n",
        "        for fx in fx_group:\n",
        "            fx[0].set_color(self.f_color)\n",
        "            fx.move_to(axes, UP+RIGHT)\n",
        "        high_f_graph, low_f_graph = graphs = VGroup(*[\n",
        "            FunctionGraph(\n",
        "                lambda x : np.cos(2*np.pi*f*x),\n",
        "                color = E_COLOR,\n",
        "                x_min = 0,\n",
        "                x_max = 4/f,\n",
        "                num_steps = 20/f,\n",
        "            )\n",
        "            for f in (1, 0.25,)\n",
        "        ])\n",
        "\n",
        "        group = VGroup(axes, t, cos, high_f_graph, *fx_group)\n",
        "        rect = SurroundingRectangle(\n",
        "            group,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 3,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.9\n",
        "        )\n",
        "        group.add_to_back(rect)\n",
        "        group.scale(0.8)\n",
        "        group.to_corner(UP+RIGHT, buff = -SMALL_BUFF)\n",
        "        group.remove(*it.chain(fx_group, graphs))\n",
        "        low_f_graph.scale(0.8)\n",
        "        low_f_graph.move_to(high_f_graph, LEFT)\n",
        "\n",
        "        cos_arg_rect = SurroundingRectangle(cos_arg)\n",
        "\n",
        "        new_ov = OscillatingVector(\n",
        "            Vector(RIGHT, color = E_COLOR),\n",
        "            A_vect = [2, 0, 0],\n",
        "            frequency = 1,\n",
        "            start_up_time = 0,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(group))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.components[0].get_part_by_tex(\"f_x\").copy(),\n",
        "                fx_equals_1\n",
        "            ),\n",
        "        )\n",
        "        self.wait(4 - (self.oscillating_vector.internal_time%4))\n",
        "        self.remove(self.oscillating_vector)\n",
        "        self.add(new_ov)\n",
        "        self.play(ShowCreation(\n",
        "            high_f_graph, run_time = 4,\n",
        "            rate_func=linear,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(new_ov.vector))\n",
        "        self.remove(new_ov)\n",
        "        self.add(self.oscillating_vector)\n",
        "        self.play(\n",
        "            ReplacementTransform(*fx_group),\n",
        "            ReplacementTransform(*graphs),\n",
        "            FadeOut(new_ov.vector),\n",
        "            FadeIn(self.vector)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(ShowCreation(cos_arg_rect))\n",
        "        self.play(FadeOut(cos_arg_rect))\n",
        "        self.wait(5)\n",
        "\n",
        "        self.corner_group = group\n",
        "        self.fx_equals_fourth = fx_equals_fourth\n",
        "        self.corner_cos = cos\n",
        "        self.low_f_graph = low_f_graph\n",
        "        self.graph_axes = axes\n",
        "\n",
        "    def add_phi(self):\n",
        "        corner_cos = self.corner_cos\n",
        "        corner_phi = OldTex(\"+\", \"\\\\phi_x\")\n",
        "        corner_phi.set_color_by_tex(\"phi\", self.phi_color)\n",
        "        corner_phi.scale(0.8)\n",
        "        corner_phi.next_to(corner_cos[-2], RIGHT, SMALL_BUFF)\n",
        "\n",
        "        x, y = self.components\n",
        "        x_without_phi = self.x_without_phi\n",
        "\n",
        "        words = OldTexText(\"``Phase shift''\")\n",
        "        words.next_to(ORIGIN, UP+LEFT)\n",
        "        words.set_color(self.phi_color)\n",
        "        words.add_background_rectangle()\n",
        "        arrow = Arrow(words.get_top(), x[-2])\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*x_without_phi[:-1]),\n",
        "                VGroup(*x[:-3]),\n",
        "            ),\n",
        "            ReplacementTransform(x_without_phi[-1], x[-1]),\n",
        "            Write(VGroup(*x[-3:-1])),\n",
        "            corner_cos[-1].next_to, corner_phi.copy(), RIGHT, SMALL_BUFF,\n",
        "            Write(corner_phi),\n",
        "            FadeOut(self.fx_equals_fourth),\n",
        "        )\n",
        "        self.play(self.low_f_graph.shift, MED_LARGE_BUFF*LEFT)\n",
        "        self.play(\n",
        "            Write(words, run_time = 1),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [words, arrow])))\n",
        "\n",
        "        self.corner_cos.add(corner_phi)\n",
        "\n",
        "    def add_amplitude(self):\n",
        "        x, y = self.components\n",
        "        corner_cos = self.corner_cos\n",
        "        graph = self.low_f_graph\n",
        "        graph_y_axis = self.graph_axes.y_axis\n",
        "\n",
        "        A = OldTex(\"A_x\")\n",
        "        A.set_color(self.A_color)\n",
        "        A.move_to(x.get_left())\n",
        "        corner_A = A.copy()\n",
        "        corner_A.scale(0.8)\n",
        "        corner_A.move_to(corner_cos, LEFT)\n",
        "\n",
        "        h_brace = Brace(Line(ORIGIN, 2*RIGHT), UP)\n",
        "        v_brace = Brace(Line(\n",
        "            graph_y_axis.number_to_point(0),\n",
        "            graph_y_axis.number_to_point(1),\n",
        "        ), LEFT, buff = SMALL_BUFF)\n",
        "        for brace in h_brace, v_brace:\n",
        "            brace.A = brace.get_tex(\"A_x\")\n",
        "            brace.A.set_color(self.A_color)\n",
        "        v_brace.A.scale(0.5, about_point = v_brace.get_center())\n",
        "        all_As = VGroup(A, corner_A, h_brace.A, v_brace.A)\n",
        "\n",
        "        def update_vect(vect):\n",
        "            self.oscillating_vector.A_vect[0] = h_brace.get_width()\n",
        "            return vect\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(h_brace),\n",
        "            GrowFromCenter(v_brace),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            x.next_to, A, RIGHT, SMALL_BUFF,\n",
        "            corner_cos.next_to, corner_A, RIGHT, SMALL_BUFF,\n",
        "            FadeIn(all_As)\n",
        "        )\n",
        "        x.add(A)\n",
        "        corner_cos.add(corner_A)\n",
        "        self.wait()\n",
        "        factor = 0.5\n",
        "        self.play(\n",
        "            v_brace.stretch_in_place, factor, 1,\n",
        "            v_brace.move_to, v_brace.copy(), DOWN,\n",
        "            MaintainPositionRelativeTo(v_brace.A, v_brace),\n",
        "            h_brace.stretch_in_place, factor, 0,\n",
        "            h_brace.move_to, h_brace.copy(), LEFT,\n",
        "            MaintainPositionRelativeTo(h_brace.A, h_brace),\n",
        "            UpdateFromFunc(self.vector, update_vect),\n",
        "            graph.stretch_in_place, factor, 1,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.h_brace = h_brace \n",
        "        self.v_brace = v_brace\n",
        "\n",
        "    def add_kets(self):\n",
        "        x, y = self.components\n",
        "        E_equals = self.E_equals\n",
        "        for mob in x, y, E_equals:\n",
        "            mob.add_background_rectangle()\n",
        "            mob.generate_target()\n",
        "\n",
        "        right_ket = OldTex(\"|\\\\rightarrow\\\\rangle\")\n",
        "        up_ket = OldTex(\"|\\\\uparrow\\\\rangle\")\n",
        "        kets = VGroup(right_ket, up_ket)\n",
        "        kets.set_color(YELLOW)\n",
        "        for ket in kets:\n",
        "            ket.add_background_rectangle()\n",
        "        plus = OldTexText(\"+\")\n",
        "        group = VGroup(\n",
        "            E_equals.target, \n",
        "            x.target, right_ket, plus,\n",
        "            y.target, up_ket,\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "        E_equals.target.shift(SMALL_BUFF*UP)\n",
        "        group.scale(0.8)\n",
        "        group.move_to(self.brackets, DOWN)\n",
        "        group.to_edge(LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        kets_word = OldTexText(\"``kets''\")\n",
        "        kets_word.next_to(kets, DOWN, buff = 0.8)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(kets_word.get_top(), ket, color = ket.get_color())\n",
        "            for ket in kets\n",
        "        ])\n",
        "        ket_rects = VGroup(*list(map(SurroundingRectangle, kets)))\n",
        "        ket_rects.set_color(WHITE)\n",
        "        unit_vectors = VGroup(*[Vector(2*vect) for vect in (RIGHT, UP)])\n",
        "        unit_vectors.set_fill(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.brackets),\n",
        "            *list(map(MoveToTarget, [E_equals, x, y]))\n",
        "        )\n",
        "        self.play(*list(map(Write, [right_ket, plus, up_ket])), run_time = 1)\n",
        "        self.play(\n",
        "            Write(kets_word),\n",
        "            LaggedStartMap(ShowCreation, arrows, lag_ratio = 0.7),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        for ket, ket_rect, unit_vect in zip(kets, ket_rects, unit_vectors):\n",
        "            self.play(ShowCreation(ket_rect))\n",
        "            self.play(FadeOut(ket_rect))\n",
        "            self.play(ReplacementTransform(ket[1][1].copy(), unit_vect))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(unit_vectors))\n",
        "        self.play(*list(map(FadeOut, [kets_word, arrows])))\n",
        "\n",
        "        self.kets = kets\n",
        "        self.plus = plus\n",
        "\n",
        "    def switch_to_vertically_polarized_light(self):\n",
        "        x, y = self.components\n",
        "        x_ket, y_ket = self.kets\n",
        "        plus = self.plus\n",
        "\n",
        "        x.target = OldTex(\"0\", \"\").add_background_rectangle()\n",
        "        y.target = OldTex(\n",
        "            \"A_y\", \"\\\\cos(\", \"2\\\\pi\", \"f_y\", \"t\", \"+\", \"\\\\phi_y\", \")\"\n",
        "        )\n",
        "        y.target.set_color_by_tex_to_color_map({\n",
        "            \"A\" : self.A_color,            \n",
        "            \"f\" : self.f_color,\n",
        "            \"phi\" : self.phi_color,\n",
        "        })\n",
        "        y.target.add_background_rectangle()\n",
        "        VGroup(x.target, y.target).scale(0.8)\n",
        "        for mob in [plus] + list(self.kets):\n",
        "            mob.generate_target()\n",
        "\n",
        "        movers = x, x_ket, plus, y, y_ket\n",
        "        group = VGroup(*[m.target for m in movers])\n",
        "        group.arrange(RIGHT)\n",
        "        group.move_to(x, LEFT)\n",
        "\n",
        "        vector_A_vect = np.array(self.oscillating_vector.A_vect)\n",
        "        def update_vect(vect, alpha):\n",
        "            self.oscillating_vector.A_vect = rotate_vector(\n",
        "                vector_A_vect, alpha*np.pi/2\n",
        "            )\n",
        "            return vect\n",
        "\n",
        "        new_h_brace = Brace(Line(ORIGIN, UP), RIGHT)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"``\", \"Vertically\", \" polarized\", \"''\",\n",
        "            arg_separator = \"\",\n",
        "        )\n",
        "        words.add_background_rectangle()\n",
        "        words.move_to(self.horizontally_polarized_words)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(self.vector, update_vect),\n",
        "            Transform(self.h_brace, new_h_brace),\n",
        "            self.h_brace.A.next_to, new_h_brace, RIGHT, SMALL_BUFF,\n",
        "            Transform(self.horizontally_polarized_words, words),\n",
        "            *list(map(FadeOut, [\n",
        "                self.corner_group, self.v_brace, \n",
        "                self.v_brace.A, self.low_f_graph,\n",
        "            ]))\n",
        "        )\n",
        "        self.play(*list(map(MoveToTarget, movers)))\n",
        "        self.wait(5)\n",
        "\n",
        "class ChangeFromHorizontalToVerticallyPolarized(DirectionOfPolarizationScene):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [],\n",
        "        \"EMWave_config\" : {\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "            \"A_vect\" : [0, 2, 0],\n",
        "        }\n",
        "    }\n",
        "    def setup(self):\n",
        "        DirectionOfPolarizationScene.setup(self)\n",
        "        self.axes.z_axis.rotate(np.pi/2, OUT)\n",
        "        self.axes.y_axis.rotate(np.pi/2, UP)\n",
        "        self.remove(self.pol_filter)\n",
        "        self.em_wave.M_vects.set_fill(opacity = 0)\n",
        "        for vect in self.em_wave.E_vects:\n",
        "            vect.normal_vector = RIGHT\n",
        "            vect.set_fill(opacity = 0.5)\n",
        "        self.em_wave.E_vects[-1].set_fill(opacity = 1)\n",
        "\n",
        "        self.set_camera_orientation(0.9*np.pi/2, -0.05*np.pi)        \n",
        "\n",
        "    def construct(self):\n",
        "        self.wait(3)\n",
        "        self.change_polarization_direction(np.pi/2)\n",
        "        self.wait(10)\n",
        "\n",
        "class SumOfTwoWaves(ChangeFromHorizontalToVerticallyPolarized):\n",
        "    CONFIG = {\n",
        "        \"axes_config\" : {\n",
        "            \"y_max\" : 1.5,\n",
        "            \"y_min\" : -1.5,\n",
        "            \"z_max\" : 1.5,\n",
        "            \"z_min\" : -1.5,\n",
        "        },\n",
        "        \"EMWave_config\" : {\n",
        "            \"A_vect\" : [0, 0, 1],\n",
        "        },\n",
        "        \"ambient_rotation_rate\" : 0,\n",
        "    }\n",
        "    def setup(self):\n",
        "        ChangeFromHorizontalToVerticallyPolarized.setup(self)\n",
        "        for vect in self.em_wave.E_vects[:-1]:\n",
        "            vect.set_fill(opacity = 0.3)\n",
        "        self.side_em_waves = []\n",
        "        for shift_vect, A_vect in (5*DOWN, [0, 1, 0]), (5*UP, [0, 1, 1]):\n",
        "            axes = self.axes.copy()\n",
        "            em_wave = copy.deepcopy(self.em_wave)\n",
        "            axes.shift(shift_vect)\n",
        "            em_wave.mobject.shift(shift_vect)\n",
        "            em_wave.start_point += shift_vect\n",
        "            for ov in em_wave.continual_animations:\n",
        "                ov.A_vect = np.array(A_vect)\n",
        "            self.add(axes, em_wave)\n",
        "            self.side_em_waves.append(em_wave)\n",
        "\n",
        "        self.set_camera_orientation(0.95*np.pi/2, -0.03*np.pi)\n",
        "\n",
        "    def construct(self):\n",
        "        plus, equals = pe = VGroup(*list(map(Tex, \"+=\")))\n",
        "        pe.scale(2)\n",
        "        pe.rotate(np.pi/2, RIGHT)\n",
        "        pe.rotate(np.pi/2, OUT)\n",
        "        plus.shift(2.5*DOWN)\n",
        "        equals.shift(2.5*UP)\n",
        "        self.add(pe)\n",
        "\n",
        "        self.wait(16)\n",
        "\n",
        "class ShowTipToTailSum(ShowVectorEquation):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_vector()\n",
        "        self.add_plane()\n",
        "        self.add_vertial_vector()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.add_kets()\n",
        "        self.show_vector_sum()\n",
        "        self.write_superposition()\n",
        "        self.add_amplitudes()\n",
        "        self.add_phase_shift()\n",
        "\n",
        "    def add_vertial_vector(self):\n",
        "        self.h_vector = self.vector\n",
        "        self.h_oscillating_vector = self.oscillating_vector\n",
        "        self.h_oscillating_vector.start_up_time = 0\n",
        "\n",
        "        self.v_oscillating_vector = self.h_oscillating_vector.copy()\n",
        "        self.v_vector = self.v_oscillating_vector.vector\n",
        "        self.v_oscillating_vector.A_vect = [0, 2, 0]\n",
        "        self.v_oscillating_vector.update(0)\n",
        "\n",
        "        self.d_oscillating_vector = Mobject.add_updater(\n",
        "            Vector(UP+RIGHT, color = E_COLOR),\n",
        "            lambda v : v.put_start_and_end_on(\n",
        "                ORIGIN,\n",
        "                self.v_vector.get_end()+ self.h_vector.get_end(),\n",
        "            )\n",
        "        )\n",
        "        self.d_vector = self.d_oscillating_vector.mobject\n",
        "        self.d_oscillating_vector.update(0)\n",
        "\n",
        "        self.add(self.v_oscillating_vector)\n",
        "        self.add_foreground_mobject(self.v_vector)\n",
        "\n",
        "    def add_kets(self):\n",
        "        h_ket, v_ket = kets = VGroup(*[\n",
        "            OldTex(\n",
        "                \"\\\\cos(\", \"2\\\\pi\", \"f\", \"t\", \")\",\n",
        "                \"|\\\\!\\\\%sarrow\\\\rangle\"%s\n",
        "            )\n",
        "            for s in (\"right\", \"up\")\n",
        "        ])\n",
        "        for ket in kets:\n",
        "            ket.set_color_by_tex_to_color_map({\n",
        "                \"f\" : self.f_color,    \n",
        "                \"rangle\" : YELLOW,\n",
        "            })\n",
        "            ket.add_background_rectangle(opacity = 1)\n",
        "            ket.scale(0.8)\n",
        "\n",
        "        h_ket.next_to(2*RIGHT, UP, SMALL_BUFF)\n",
        "        v_ket.next_to(2*UP, UP, SMALL_BUFF)\n",
        "        self.add_foreground_mobject(kets)\n",
        "\n",
        "        self.kets = kets\n",
        "\n",
        "    def show_vector_sum(self):\n",
        "        h_line = DashedLine(ORIGIN, 2*RIGHT)\n",
        "        v_line = DashedLine(ORIGIN, 2*UP)\n",
        "\n",
        "        h_line.update = self.generate_dashed_line_update(\n",
        "            self.h_vector, self.v_vector\n",
        "        )\n",
        "        v_line.update = self.generate_dashed_line_update(\n",
        "            self.v_vector, self.h_vector\n",
        "        )\n",
        "\n",
        "        h_ket, v_ket = self.kets\n",
        "        for ket in self.kets:\n",
        "            ket.generate_target()\n",
        "        plus = OldTex(\"+\")\n",
        "        ket_sum = VGroup(h_ket.target, plus, v_ket.target)\n",
        "        ket_sum.arrange(RIGHT)\n",
        "        ket_sum.next_to(3*RIGHT + 2*UP, UP, SMALL_BUFF)\n",
        "\n",
        "        self.wait(4)\n",
        "        self.remove(self.h_oscillating_vector, self.v_oscillating_vector)\n",
        "        self.add(self.h_vector, self.v_vector)\n",
        "        h_line.update(h_line)\n",
        "        v_line.update(v_line)\n",
        "        self.play(*it.chain(\n",
        "            list(map(MoveToTarget, self.kets)),\n",
        "            [Write(plus)],\n",
        "            list(map(ShowCreation, [h_line, v_line])),\n",
        "        ))\n",
        "        blue_black = average_color(BLUE, BLACK)\n",
        "        self.play(\n",
        "            GrowFromPoint(self.d_vector, ORIGIN),\n",
        "            self.h_vector.set_fill, blue_black,\n",
        "            self.v_vector.set_fill, blue_black,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(\n",
        "            self.h_oscillating_vector,\n",
        "            self.v_oscillating_vector,\n",
        "            self.d_oscillating_vector,\n",
        "            Mobject.add_updater(h_line, h_line.update),\n",
        "            Mobject.add_updater(v_line, v_line.update),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.ket_sum = VGroup(h_ket, plus, v_ket)\n",
        "\n",
        "    def write_superposition(self):\n",
        "        superposition_words = OldTexText(\n",
        "            \"``Superposition''\", \"of\",\n",
        "            \"$|\\\\!\\\\rightarrow\\\\rangle$\", \"and\", \n",
        "            \"$|\\\\!\\\\uparrow\\\\rangle$\",\n",
        "        )\n",
        "        superposition_words.scale(0.8)\n",
        "        superposition_words.set_color_by_tex(\"rangle\", YELLOW)\n",
        "        superposition_words.add_background_rectangle()\n",
        "        superposition_words.to_corner(UP+LEFT)\n",
        "        ket_sum = self.ket_sum\n",
        "        ket_sum.generate_target()\n",
        "        ket_sum.target.move_to(superposition_words)\n",
        "        ket_sum.target.align_to(ket_sum, UP)\n",
        "\n",
        "        sum_word = OldTexText(\"\", \"Sum\")\n",
        "        weighted_sum_word = OldTexText(\"Weighted\", \"sum\")\n",
        "        for word in sum_word, weighted_sum_word:\n",
        "            word.scale(0.8)\n",
        "            word.set_color(GREEN)\n",
        "            word.add_background_rectangle()\n",
        "            word.move_to(superposition_words.get_part_by_tex(\"Super\"))\n",
        "\n",
        "        self.play(\n",
        "            Write(superposition_words, run_time = 2),\n",
        "            MoveToTarget(ket_sum)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(sum_word),\n",
        "            superposition_words.shift, MED_LARGE_BUFF*DOWN,\n",
        "            ket_sum.shift, MED_LARGE_BUFF*DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            sum_word, weighted_sum_word\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def add_amplitudes(self):\n",
        "        h_ket, plus, r_ket = self.ket_sum\n",
        "        for mob in self.ket_sum:\n",
        "            mob.generate_target()\n",
        "        h_A, v_A = 2, 0.5\n",
        "        h_A_mob, v_A_mob = A_mobs = VGroup(*[\n",
        "            OldTex(str(A)).add_background_rectangle()\n",
        "            for A in [h_A, v_A]\n",
        "        ])\n",
        "        A_mobs.scale(0.8)\n",
        "        A_mobs.set_color(GREEN)\n",
        "        h_A_mob.move_to(h_ket, LEFT)\n",
        "        VGroup(h_ket.target, plus.target).next_to(\n",
        "            h_A_mob, RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        v_A_mob.next_to(plus.target, RIGHT, SMALL_BUFF)\n",
        "        r_ket.target.next_to(v_A_mob, RIGHT, SMALL_BUFF)\n",
        "        A_mobs.shift(0.4*SMALL_BUFF*UP)\n",
        "\n",
        "        h_ov = self.h_oscillating_vector\n",
        "        v_ov = self.v_oscillating_vector\n",
        "\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(MoveToTarget, self.ket_sum)),\n",
        "            list(map(Write, A_mobs)),\n",
        "            [\n",
        "                UpdateFromAlphaFunc(\n",
        "                    ov.vector,\n",
        "                    self.generate_A_update(\n",
        "                        ov, \n",
        "                        A*np.array(ov.A_vect), \n",
        "                        np.array(ov.A_vect)\n",
        "                    )\n",
        "                )\n",
        "                for ov, A in [(h_ov, h_A), (v_ov, v_A)]\n",
        "            ]\n",
        "        ))\n",
        "        self.wait(4)\n",
        "\n",
        "        self.A_mobs = A_mobs\n",
        "\n",
        "    def add_phase_shift(self):\n",
        "        h_ket, plus, v_ket = self.ket_sum\n",
        "\n",
        "        plus_phi = OldTex(\"+\", \"\\\\pi/2\")\n",
        "        plus_phi.set_color_by_tex(\"pi\", self.phi_color)\n",
        "        plus_phi.scale(0.8)\n",
        "        plus_phi.next_to(v_ket.get_part_by_tex(\"t\"), RIGHT, SMALL_BUFF)\n",
        "        v_ket.generate_target()\n",
        "        VGroup(*v_ket.target[1][-2:]).next_to(plus_phi, RIGHT, SMALL_BUFF)\n",
        "        v_ket.target[0].replace(v_ket.target[1])\n",
        "\n",
        "\n",
        "        h_ov = self.h_oscillating_vector\n",
        "        v_ov = self.v_oscillating_vector\n",
        "\n",
        "        ellipse = Circle()\n",
        "        ellipse.stretch_to_fit_height(2)\n",
        "        ellipse.stretch_to_fit_width(8)\n",
        "        ellipse.set_color(self.phi_color)\n",
        "\n",
        "        h_A_mob, v_A_mob = self.A_mobs\n",
        "        new_h_A_mob = v_A_mob.copy()\n",
        "        new_h_A_mob.move_to(h_A_mob, RIGHT)\n",
        "\n",
        "        self.add_foreground_mobject(plus_phi)\n",
        "        self.play(\n",
        "            MoveToTarget(v_ket),\n",
        "            Write(plus_phi),\n",
        "            UpdateFromAlphaFunc(\n",
        "                v_ov.vector,\n",
        "                self.generate_phi_update(\n",
        "                    v_ov, \n",
        "                    np.array([0, np.pi/2, 0]), \n",
        "                    np.array(v_ov.phi_vect)\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeIn(ellipse))\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                h_ov.vector,\n",
        "                self.generate_A_update(\n",
        "                    h_ov, \n",
        "                    0.25*np.array(h_ov.A_vect), \n",
        "                    np.array(h_ov.A_vect),\n",
        "                )\n",
        "            ),\n",
        "            ellipse.stretch, 0.25, 0,\n",
        "            Transform(h_A_mob, new_h_A_mob)\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def generate_A_update(self, ov, A_vect, prev_A_vect):\n",
        "        def update(vect, alpha):\n",
        "            ov.A_vect = interpolate(\n",
        "                np.array(prev_A_vect),\n",
        "                A_vect,\n",
        "                alpha\n",
        "            )\n",
        "            return vect\n",
        "        return update\n",
        "\n",
        "    def generate_phi_update(self, ov, phi_vect, prev_phi_vect):\n",
        "        def update(vect, alpha):\n",
        "            ov.phi_vect = interpolate(\n",
        "                prev_phi_vect, phi_vect, alpha\n",
        "            )\n",
        "            return vect\n",
        "        return update\n",
        "\n",
        "    def generate_dashed_line_update(self, v1, v2):\n",
        "        def update_line(line):\n",
        "            line.put_start_and_end_on_with_projection(\n",
        "                *v1.get_start_and_end()\n",
        "            )\n",
        "            line.shift(v2.get_end() - line.get_start())\n",
        "        return update_line\n",
        "\n",
        "class FromBracketFootnote(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"From, ``Bra\", \"ket\", \"''\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"ket\", YELLOW)\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        self.add(words)\n",
        "\n",
        "class Ay(Scene):\n",
        "    def construct(self):\n",
        "        sym = OldTex(\"A_y\").set_color(GREEN)\n",
        "        sym.scale(5)\n",
        "        self.add(sym)\n",
        "\n",
        "class CircularlyPolarizedLight(SumOfTwoWaves):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"phi_vect\" : [0, np.pi/2, 0],\n",
        "        },\n",
        "    }\n",
        "\n",
        "class AlternateBasis(ShowTipToTailSum):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_vector()\n",
        "        self.add_plane()\n",
        "        self.add_vertial_vector()\n",
        "        self.add_kets()\n",
        "        self.show_vector_sum()\n",
        "        self.remove(self.ket_sum, self.kets)\n",
        "        self.reset_amplitude()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.add_superposition_text()\n",
        "        self.rotate_plane()\n",
        "        self.show_vertically_polarized()\n",
        "\n",
        "    def reset_amplitude(self):\n",
        "        self.h_oscillating_vector.A_vect = np.array([1, 0, 0])\n",
        "\n",
        "    def add_superposition_text(self):\n",
        "        self.hv_superposition, self.da_superposition = superpositions = [\n",
        "            OldTex(\n",
        "                \"\\\\vec{\\\\textbf{E}}\", \"=\",\n",
        "                \"(\\\\dots)\",\n",
        "                \"|\\\\!\\\\%sarrow\\\\rangle\"%s1,\n",
        "                \"+\",\n",
        "                \"(\\\\dots)\",\n",
        "                \"|\\\\!\\\\%sarrow\\\\rangle\"%s2,\n",
        "            )\n",
        "            for s1, s2 in [(\"right\", \"up\"), (\"ne\", \"nw\")]\n",
        "        ]\n",
        "        for superposition in superpositions:\n",
        "            superposition.set_color_by_tex(\"rangle\", YELLOW)\n",
        "            superposition.set_color_by_tex(\"E\", E_COLOR)\n",
        "            superposition.add_background_rectangle(opacity = 1)\n",
        "            superposition.to_edge(UP)\n",
        "        self.add(self.hv_superposition)\n",
        "\n",
        "    def rotate_plane(self):\n",
        "        new_plane = NumberPlane(\n",
        "            x_unit_size = 2,\n",
        "            y_unit_size = 2,\n",
        "            y_radius = FRAME_X_RADIUS,\n",
        "            secondary_line_ratio = 0,\n",
        "        )\n",
        "        new_plane.add_coordinates()\n",
        "        new_plane.save_state()\n",
        "        new_plane.fade(1)\n",
        "\n",
        "        d = (RIGHT + UP)/np.sqrt(2)\n",
        "        a = (LEFT + UP)/np.sqrt(2)\n",
        "\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.xy_plane.fade, 0.5,\n",
        "            self.xy_plane.coordinate_labels.fade, 1,\n",
        "            new_plane.restore,\n",
        "            new_plane.rotate, np.pi/4,\n",
        "            UpdateFromAlphaFunc(\n",
        "                self.h_vector,\n",
        "                self.generate_A_update(\n",
        "                    self.h_oscillating_vector,\n",
        "                    2*d*np.dot(0.5*RIGHT + UP, d),\n",
        "                    np.array(self.h_oscillating_vector.A_vect)\n",
        "                )\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                self.v_vector,\n",
        "                self.generate_A_update(\n",
        "                    self.v_oscillating_vector,\n",
        "                    2*a*np.dot(0.5*RIGHT + UP, a),\n",
        "                    np.array(self.v_oscillating_vector.A_vect)\n",
        "                )\n",
        "            ),\n",
        "            Transform(self.hv_superposition, self.da_superposition),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def show_vertically_polarized(self):\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                self.h_vector,\n",
        "                self.generate_A_update(\n",
        "                    self.h_oscillating_vector,\n",
        "                    np.array([0.7, 0.7, 0]),\n",
        "                    np.array(self.h_oscillating_vector.A_vect)\n",
        "                )\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                self.v_vector,\n",
        "                self.generate_A_update(\n",
        "                    self.v_oscillating_vector,\n",
        "                    np.array([-0.7, 0.7, 0]),\n",
        "                    np.array(self.v_oscillating_vector.A_vect)\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "class WriteBasis(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Choice of ``basis''\")\n",
        "        words.set_width(FRAME_WIDTH-1)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class ShowPolarizingFilter(DirectionOfPolarizationScene):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "        },\n",
        "        \"apply_filter\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_rectangles()\n",
        "        self.fade_M_vects()\n",
        "        self.axes.fade(0.5)\n",
        "\n",
        "        self.initial_rotation()\n",
        "        self.mention_energy_absorption()\n",
        "        self.write_as_superposition()\n",
        "        self.diagonal_filter()\n",
        "\n",
        "    def setup_rectangles(self):\n",
        "        DirectionOfPolarizationScene.setup_rectangles(self)\n",
        "        self.rectangles[-1].fade(1)\n",
        "\n",
        "    def fade_M_vects(self):\n",
        "        self.em_wave.M_vects.set_fill(opacity = 0)\n",
        "\n",
        "    def initial_rotation(self):\n",
        "        self.wait()\n",
        "        self.play(FadeIn(self.rectangles))\n",
        "        self.wait()\n",
        "        self.change_polarization_direction(np.pi/2, run_time = 3)\n",
        "        self.move_camera(phi = 0.9*np.pi/2, theta = -0.05*np.pi)\n",
        "\n",
        "    def mention_energy_absorption(self):\n",
        "        words = OldTexText(\"Absorbs horizontal \\\\\\\\ energy\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(ORIGIN, UP+RIGHT, MED_LARGE_BUFF)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "        words.rotate(np.pi/2, OUT)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                np.sin(a)*RIGHT + np.cos(a)*UP,\n",
        "                np.sin(a)*LEFT + np.cos(a)*UP,\n",
        "                color = RED,\n",
        "                stroke_width = 2,\n",
        "            )\n",
        "            for a in np.linspace(0, np.pi, 15)\n",
        "        ])\n",
        "        lines.rotate(np.pi/2, RIGHT)\n",
        "        lines.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            *list(map(GrowFromCenter, lines))\n",
        "        )\n",
        "        self.wait(6)\n",
        "        self.play(FadeOut(lines))\n",
        "        self.play(FadeOut(words))\n",
        "\n",
        "    def write_as_superposition(self):\n",
        "        superposition, continual_updates = self.get_superposition_tex(0, \"right\", \"up\")\n",
        "        rect = superposition.rect\n",
        "\n",
        "        self.play(Write(superposition, run_time = 2))\n",
        "        self.add(*continual_updates)\n",
        "        for angle in np.pi/4, -np.pi/6:\n",
        "            self.change_polarization_direction(angle)\n",
        "            self.wait(3)\n",
        "\n",
        "        self.move_camera(\n",
        "            theta = -0.6*np.pi,\n",
        "            added_anims = [\n",
        "                Rotate(superposition, -0.6*np.pi, axis = OUT)\n",
        "            ]\n",
        "        )\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "        self.play(ShowCreation(rect))\n",
        "        arrow = Arrow(\n",
        "            rect.get_nadir(), 3*RIGHT + 0.5*OUT,\n",
        "            normal_vector = DOWN\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "\n",
        "        for angle in np.pi/3, -np.pi/3, np.pi/6:\n",
        "            self.change_polarization_direction(angle)\n",
        "            self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(superposition),\n",
        "            FadeOut(arrow),\n",
        "            *[\n",
        "                FadeOut(cu.mobject)\n",
        "                for cu in continual_updates\n",
        "            ]\n",
        "        )\n",
        "        self.move_camera(theta = -0.1*np.pi)\n",
        "\n",
        "    def diagonal_filter(self):\n",
        "        superposition, continual_updates = self.get_superposition_tex(-np.pi/4, \"nw\", \"ne\")\n",
        "\n",
        "        def update_filter_angle(pf, alpha):\n",
        "            pf.filter_angle = interpolate(0, -np.pi/4, alpha)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(self.pol_filter, np.pi/4, axis = LEFT),\n",
        "            UpdateFromAlphaFunc(self.pol_filter, update_filter_angle),\n",
        "            Animation(self.em_wave.mobject)\n",
        "        )\n",
        "        superposition.rect.set_stroke(YELLOW, 2)\n",
        "        self.play(Write(superposition, run_time = 2))\n",
        "        self.add(*continual_updates)\n",
        "        for angle in np.pi/4, -np.pi/3, -np.pi/6:\n",
        "            self.change_polarization_direction(np.pi/4)\n",
        "            self.wait(2)\n",
        "\n",
        "    #######\n",
        "\n",
        "    def get_superposition_tex(self, angle, s1, s2):\n",
        "        superposition = OldTex(\n",
        "            \"0.00\", \"\\\\cos(\", \"2\\\\pi\", \"f\", \"t\", \")\",\n",
        "            \"|\\\\! \\\\%sarrow \\\\rangle\"%s1,\n",
        "            \"+\",\n",
        "            \"1.00\", \"\\\\cos(\", \"2\\\\pi\", \"f\", \"t\", \")\",\n",
        "            \"|\\\\! \\\\%sarrow \\\\rangle\"%s2,\n",
        "        )\n",
        "\n",
        "        A_x = DecimalNumber(0)\n",
        "        A_y = DecimalNumber(1)\n",
        "        A_x.move_to(superposition[0])\n",
        "        A_y.move_to(superposition[8])\n",
        "        superposition.submobjects[0] = A_x\n",
        "        superposition.submobjects[8] = A_y\n",
        "        VGroup(A_x, A_y).set_color(GREEN)\n",
        "        superposition.set_color_by_tex(\"f\", RED)\n",
        "        superposition.set_color_by_tex(\"rangle\", YELLOW)\n",
        "        plus = superposition.get_part_by_tex(\"+\")\n",
        "        plus.add_to_back(BackgroundRectangle(plus))\n",
        "\n",
        "        v_part = VGroup(*superposition[8:])\n",
        "        rect = SurroundingRectangle(v_part)\n",
        "        rect.fade(1)\n",
        "        superposition.rect = rect\n",
        "        superposition.add(rect)\n",
        "\n",
        "        superposition.shift(3*UP + SMALL_BUFF*LEFT)\n",
        "        superposition.rotate(np.pi/2, RIGHT)\n",
        "        superposition.rotate(np.pi/2, OUT)\n",
        "\n",
        "        def generate_decimal_update(trig_func):\n",
        "            def update_decimal(decimal):\n",
        "                new_decimal = DecimalNumber(abs(trig_func(\n",
        "                    self.reference_line.get_angle() - angle\n",
        "                )))\n",
        "                new_decimal.rotate(np.pi/2, RIGHT)\n",
        "                new_decimal.rotate(np.pi/2, OUT)\n",
        "                new_decimal.rotate(self.camera.get_theta(), OUT)\n",
        "                new_decimal.set_depth(decimal.get_depth())\n",
        "                new_decimal.move_to(decimal, UP)\n",
        "                new_decimal.set_color(decimal.get_color())\n",
        "                decimal.align_data_and_family(new_decimal)\n",
        "                families = [\n",
        "                    mob.family_members_with_points()\n",
        "                    for mob in (decimal, new_decimal)\n",
        "                ]\n",
        "                for sm1, sm2 in zip(*families):\n",
        "                    sm1.interpolate(sm1, sm2, 1)\n",
        "                return decimal\n",
        "            return update_decimal\n",
        "\n",
        "        continual_updates = [\n",
        "            Mobject.add_updater(\n",
        "                A_x, generate_decimal_update(np.sin),\n",
        "            ),\n",
        "            Mobject.add_updater(\n",
        "                A_y, generate_decimal_update(np.cos),\n",
        "            ),\n",
        "        ]\n",
        "\n",
        "        return superposition, continual_updates\n",
        "\n",
        "class NamePolarizingFilter(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Polarizing filter\")\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class EnergyOfWavesWavePortion(DirectWaveOutOfScreen):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"A_vect\" : [0, 1, 1],\n",
        "            \"amplitude\" : 4,\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT + 2*DOWN,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.grow_arrows()\n",
        "        self.move_into_position()\n",
        "        self.fade_M_vects()\n",
        "        self.label_A()\n",
        "        self.add_components()\n",
        "        self.scale_up_and_down()\n",
        "\n",
        "    def grow_arrows(self):\n",
        "        for ov in self.em_wave.continual_animations:\n",
        "            ov.vector.rectangular_stem_width = 0.1\n",
        "            ov.vector.tip_length = 0.5\n",
        "\n",
        "    def label_A(self):\n",
        "        brace = Brace(Line(ORIGIN, 4*RIGHT))\n",
        "        brace.rotate(np.pi/4, OUT)\n",
        "        brace.A = brace.get_tex(\"A\", buff = MED_SMALL_BUFF)\n",
        "        brace.A.scale(2)\n",
        "        brace.A.set_color(GREEN)\n",
        "        brace_group = VGroup(brace, brace.A)\n",
        "        self.position_brace_group(brace_group)\n",
        "        self.play(Write(brace_group, run_time = 1))\n",
        "        self.wait(12)\n",
        "\n",
        "        self.brace = brace\n",
        "\n",
        "    def add_components(self):\n",
        "        h_wave = self.em_wave.copy()\n",
        "        h_wave.A_vect = [0, 1, 0]\n",
        "        v_wave = self.em_wave.copy()\n",
        "        v_wave.A_vect = [0, 0, 1]\n",
        "        length = 4/np.sqrt(2)\n",
        "        for wave in h_wave, v_wave:\n",
        "            for ov in wave.continual_animations:\n",
        "                ov.A_vect = length*np.array(wave.A_vect)\n",
        "\n",
        "        h_brace = Brace(Line(ORIGIN, length*RIGHT))\n",
        "        v_brace = Brace(Line(ORIGIN, length*UP), LEFT)\n",
        "        for brace, c in (h_brace, \"x\"), (v_brace, \"y\"):\n",
        "            brace.A = brace.get_tex(\"A_%s\"%c, buff = MED_LARGE_BUFF)\n",
        "            brace.A.scale(2)\n",
        "            brace.A.set_color(GREEN)\n",
        "        brace_group = VGroup(h_brace, h_brace.A, v_brace, v_brace.A)\n",
        "        self.position_brace_group(brace_group)\n",
        "\n",
        "        rhs = OldTex(\"= \\\\sqrt{A_x^2 + A_y^2}\")\n",
        "        rhs.scale(2)\n",
        "        for i in 3, 5, 7, 9:\n",
        "            rhs[i].set_color(GREEN)\n",
        "        rhs.rotate(np.pi/2, RIGHT)\n",
        "        rhs.rotate(np.pi/2, OUT)\n",
        "\n",
        "        period = 1./self.em_wave.frequency\n",
        "        self.add(h_wave, v_wave)\n",
        "        self.play(\n",
        "            FadeIn(h_wave.mobject),\n",
        "            FadeIn(v_wave.mobject),\n",
        "            self.brace.A.move_to, self.brace,\n",
        "            self.brace.A.shift, SMALL_BUFF*(2*UP+IN),\n",
        "            ReplacementTransform(self.brace, h_brace),\n",
        "            Write(h_brace.A)\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(h_brace.copy(), v_brace),\n",
        "            Write(v_brace.A)\n",
        "        )\n",
        "        self.wait(6)\n",
        "        rhs.next_to(self.brace.A, UP, SMALL_BUFF)\n",
        "        self.play(Write(rhs))\n",
        "        self.wait(2*period)\n",
        "\n",
        "        self.h_brace = h_brace\n",
        "        self.v_brace = v_brace\n",
        "        self.h_wave = h_wave\n",
        "        self.v_wave = v_wave\n",
        "\n",
        "    def scale_up_and_down(self):\n",
        "        for scale_factor in 1.25, 0.4, 1.5, 0.3, 2:\n",
        "            self.scale_wave(scale_factor)\n",
        "            self.wait()\n",
        "        self.wait(4)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def position_brace_group(self, brace_group):\n",
        "        brace_group.rotate(np.pi/2, RIGHT)\n",
        "        brace_group.rotate(np.pi/2, OUT)\n",
        "        brace_group.shift(2*DOWN)\n",
        "\n",
        "    def scale_wave(self, factor):\n",
        "        def generate_vect_update(ov):\n",
        "            prev_A = np.array(ov.A_vect)\n",
        "            new_A = factor*prev_A\n",
        "            def update(vect, alpha):\n",
        "                ov.A_vect = interpolate(\n",
        "                    prev_A, new_A, alpha\n",
        "                )\n",
        "                return vect\n",
        "            return update\n",
        "        h_brace = self.h_brace\n",
        "        v_brace = self.v_brace\n",
        "\n",
        "        h_brace.generate_target()\n",
        "        h_brace.target.stretch_about_point(\n",
        "            factor, 1, h_brace.get_bottom()\n",
        "        )\n",
        "        v_brace.generate_target()\n",
        "        v_brace.target.stretch_about_point(\n",
        "            factor, 2, v_brace.get_nadir()\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(h_brace),\n",
        "            MoveToTarget(v_brace),\n",
        "            *[\n",
        "                UpdateFromAlphaFunc(ov.vector, generate_vect_update(ov))\n",
        "                for ov in it.chain(\n",
        "                    self.em_wave.continual_animations,\n",
        "                    self.h_wave.continual_animations,\n",
        "                    self.v_wave.continual_animations,\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "\n",
        "class EnergyOfWavesTeacherPortion(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.show_energy_equation()\n",
        "        self.show_both_ways_of_thinking_about_it()\n",
        "\n",
        "    def show_energy_equation(self):\n",
        "        dot = Dot(self.teacher.get_top() + 2*(UP+LEFT))\n",
        "        dot.fade(1)\n",
        "        self.dot = dot\n",
        "\n",
        "        energy = OldTex(\n",
        "            \"\\\\frac{\\\\text{Energy}}{\\\\text{Volume}}\",\n",
        "            \"=\", \n",
        "            \"\\\\epsilon_0\", \"A\", \"^2\"\n",
        "        )\n",
        "        energy.set_color_by_tex(\"A\", GREEN)\n",
        "        energy.to_corner(UP+LEFT)\n",
        "\n",
        "        component_energy = OldTex(\n",
        "            \"=\", \"\\\\epsilon_0\", \"A_x\", \"^2\", \n",
        "            \"+\", \"\\\\epsilon_0\", \"A_y\", \"^2\", \n",
        "        )\n",
        "        for i in 2, 6:\n",
        "            component_energy[i][0].set_color(GREEN)\n",
        "            component_energy[i+1].set_color(GREEN)\n",
        "        component_energy.next_to(energy[1], DOWN, MED_LARGE_BUFF, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Animation(dot),\n",
        "            self.teacher.change, \"raise_right_hand\", dot,\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = dot\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(energy))\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*energy[-4:]).copy(),\n",
        "                VGroup(*component_energy[:4])\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                VGroup(*energy[-4:]).copy(),\n",
        "                VGroup(*component_energy[4:])\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3, look_at = energy)\n",
        "        self.wait()\n",
        "\n",
        "    def show_both_ways_of_thinking_about_it(self):\n",
        "        s1, s2 = self.get_students()[:2]\n",
        "        b1, b2 = [\n",
        "            ThoughtBubble(direction = v).scale(0.5)\n",
        "            for v in (LEFT, RIGHT)\n",
        "        ]\n",
        "        b1.pin_to(s1)\n",
        "        b2.pin_to(s2)\n",
        "\n",
        "        b1.write(\"Add \\\\\\\\ components\")\n",
        "        b2.write(\"Pythagorean \\\\\\\\ theorem\")\n",
        "\n",
        "        for b, s in (b1, s1), (b2, s2):\n",
        "            self.play(\n",
        "                ShowCreation(b),\n",
        "                Write(b.content, run_time = 2),\n",
        "                s.change, \"thinking\"\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            *[\"plain\"]*3,\n",
        "            look_at = self.dot,\n",
        "            added_anims = [\n",
        "                self.teacher.change, \"raise_right_hand\", self.dot\n",
        "            ]\n",
        "\n",
        "        )\n",
        "        self.play(self.teacher.look_at, self.dot)\n",
        "        self.wait(5)\n",
        "\n",
        "class DescribePhoton(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"x_color\" : RED,\n",
        "        \"y_color\" : GREEN,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.axes = ThreeDAxes()\n",
        "        self.add(self.axes)\n",
        "\n",
        "        self.set_camera_orientation(phi = 0.8*np.pi/2, theta = -np.pi/4)\n",
        "        em_wave = EMWave(\n",
        "            start_point = FRAME_X_RADIUS*LEFT,\n",
        "            A_vect = [0, 1, 1],\n",
        "            wave_number = 0,\n",
        "            amplitude = 3,\n",
        "        )\n",
        "        for ov in em_wave.continual_animations:\n",
        "            ov.vector.normal_vector = RIGHT\n",
        "            ov.vector.set_fill(opacity = 0.7)\n",
        "        for M_vect in em_wave.M_vects:\n",
        "            M_vect.set_fill(opacity = 0)\n",
        "        em_wave.update(0)\n",
        "        photon = WavePacket(\n",
        "            em_wave = em_wave,\n",
        "            run_time = 2,\n",
        "        )\n",
        "\n",
        "        self.photon = photon\n",
        "        self.em_wave = em_wave\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_ket_equation()\n",
        "        self.shoot_a_few_photons()\n",
        "        self.freeze_photon()\n",
        "        self.reposition_to_face_photon_head_on()\n",
        "        self.show_components()\n",
        "        self.show_amplitude_and_phase()\n",
        "        self.change_basis()\n",
        "        self.write_different_meaning()\n",
        "        self.write_components()\n",
        "        self.describe_via_energy()\n",
        "        self.components_not_possible_in_isolation()\n",
        "        self.ask_what_they_mean()\n",
        "        self.change_camera()\n",
        "\n",
        "    def add_ket_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"|\\\\!\\\\psi\\\\rangle\", \n",
        "            \"=\",\n",
        "            \"\\\\alpha\", \"|\\\\!\\\\rightarrow \\\\rangle\", \"+\",\n",
        "            \"\\\\beta\", \"|\\\\!\\\\uparrow \\\\rangle\",\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "        equation.set_color_by_tex(\"psi\", E_COLOR)\n",
        "        equation.set_color_by_tex(\"alpha\", self.x_color)\n",
        "        equation.set_color_by_tex(\"beta\", self.y_color)\n",
        "        rect = SurroundingRectangle(equation.get_part_by_tex(\"psi\"))\n",
        "        rect.set_color(E_COLOR)\n",
        "        words = OldTexText(\"Polarization\\\\\\\\\", \"state\")\n",
        "        words.next_to(rect, DOWN)\n",
        "        for part in words:\n",
        "            bg_rect = BackgroundRectangle(part)\n",
        "            bg_rect.stretch_in_place(2, 1)\n",
        "            part.add_to_back(bg_rect)\n",
        "        equation.rect = rect\n",
        "        equation.words = words\n",
        "        equation.add_background_rectangle()\n",
        "        equation.add(rect, words)\n",
        "        VGroup(rect, words).fade(1)\n",
        "\n",
        "        equation.rotate(np.pi/2, RIGHT)\n",
        "        equation.rotate(np.pi/2 + self.camera.get_theta(), OUT)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.equation = equation\n",
        "        self.superposition = VGroup(*equation[1][2:])\n",
        "\n",
        "    def shoot_a_few_photons(self):\n",
        "        for x in range(2):\n",
        "            self.play(self.photon)\n",
        "\n",
        "    def freeze_photon(self):\n",
        "        self.play(\n",
        "            self.photon,\n",
        "            rate_func = lambda x : 0.55*x,\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.add(self.photon.mobject)\n",
        "        self.photon.rate_func = lambda x : x\n",
        "        self.photon.run_time = 2\n",
        "\n",
        "    def reposition_to_face_photon_head_on(self):\n",
        "        plane = NumberPlane(\n",
        "            color = GREY_B,\n",
        "            secondary_color = GREY_D,\n",
        "            x_unit_size = 2,\n",
        "            y_unit_size = 2,\n",
        "            y_radius = FRAME_X_RADIUS,\n",
        "        )\n",
        "        plane.add_coordinates(x_vals = list(range(-3, 4)), y_vals = [])\n",
        "        plane.rotate(np.pi/2, RIGHT)\n",
        "        plane.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(self.em_wave.M_vects.set_fill, None, 0)\n",
        "        self.move_camera(\n",
        "            phi = np.pi/2, theta = 0,\n",
        "            added_anims = [\n",
        "                Rotate(self.equation, -self.camera.get_theta())\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            Write(plane, run_time = 1), \n",
        "            Animation(self.equation)\n",
        "        )\n",
        "\n",
        "        self.xy_plane = plane\n",
        "\n",
        "    def show_components(self):\n",
        "        h_arrow, v_arrow = [\n",
        "            Vector(\n",
        "                1.38*direction, \n",
        "                color = color,\n",
        "                normal_vector = RIGHT,\n",
        "            )\n",
        "            for color, direction in [(self.x_color, UP), (self.y_color, OUT)]\n",
        "        ]\n",
        "        v_arrow.move_to(h_arrow.get_end(), IN)\n",
        "        h_part = VGroup(*self.equation[1][2:4]).copy()\n",
        "        v_part = VGroup(*self.equation[1][5:7]).copy()\n",
        "\n",
        "        self.play(\n",
        "            self.equation.rect.set_stroke, BLUE, 4,\n",
        "            self.equation.words.set_fill, WHITE, 1,\n",
        "        )\n",
        "        for part, arrow, d in (h_part, h_arrow, IN), (v_part, v_arrow, UP):\n",
        "            self.play(\n",
        "                part.next_to, arrow.get_center(), d,\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "            part.rotate(np.pi/2, DOWN)\n",
        "            bg_rect = BackgroundRectangle(part)\n",
        "            bg_rect.stretch_in_place(1.3, 0)\n",
        "            part.add_to_back(bg_rect)\n",
        "            part.rotate(np.pi/2, UP)\n",
        "            self.add(part)\n",
        "        self.wait()\n",
        "\n",
        "        self.h_part_tex = h_part\n",
        "        self.h_arrow = h_arrow\n",
        "        self.v_part_tex = v_part\n",
        "        self.v_arrow = v_arrow\n",
        "\n",
        "    def show_amplitude_and_phase(self):\n",
        "        alpha = self.h_part_tex[1]\n",
        "        new_alpha = alpha.copy().shift(IN)\n",
        "        rhs = OldTex(\n",
        "            \"=\", \"A_x\", \"e\", \n",
        "            \"^{i\", \"(2\\\\pi\", \"f\", \"t\", \"+\", \"\\\\phi_x)}\"\n",
        "        )\n",
        "        A_rect = SurroundingRectangle(rhs.get_part_by_tex(\"A_x\"), buff = 0.5*SMALL_BUFF)\n",
        "        A_word = OldTexText(\"Amplitude\")\n",
        "        A_word.add_background_rectangle()\n",
        "        A_word.next_to(A_rect, DOWN, aligned_edge = LEFT)\n",
        "        A_group = VGroup(A_rect, A_word)\n",
        "        A_group.set_color(YELLOW)\n",
        "        phase_rect = SurroundingRectangle(VGroup(*rhs[4:]), buff = 0.5*SMALL_BUFF)\n",
        "        phase_word = OldTexText(\"Phase\")\n",
        "        phase_word.add_background_rectangle()\n",
        "        phase_word.next_to(phase_rect, UP)\n",
        "        phase_group = VGroup(phase_word, phase_rect)\n",
        "        phase_group.set_color(MAROON_B)\n",
        "        rhs.add_background_rectangle()\n",
        "\n",
        "        group = VGroup(rhs, A_group, phase_group)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "        group.next_to(new_alpha, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(alpha.copy(), new_alpha),\n",
        "            FadeIn(rhs)\n",
        "        )\n",
        "        for word, rect in A_group, phase_group:\n",
        "            self.play(\n",
        "                ShowCreation(rect),\n",
        "                Write(word, run_time = 1)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [new_alpha, group])))\n",
        "\n",
        "    def change_basis(self):\n",
        "        superposition = self.superposition\n",
        "        plane = self.xy_plane\n",
        "        h_arrow = self.h_arrow\n",
        "        v_arrow = self.v_arrow\n",
        "        h_part = self.h_part_tex\n",
        "        v_part = self.v_part_tex\n",
        "        axes = self.axes\n",
        "        movers = [\n",
        "            plane, axes,\n",
        "            h_arrow, v_arrow, \n",
        "            h_part, v_part, \n",
        "            self.equation,\n",
        "            superposition, \n",
        "        ]\n",
        "        for mob in movers:\n",
        "            mob.save_state()\n",
        "\n",
        "        superposition.target = OldTex(\n",
        "            \"\\\\gamma\", \"|\\\\! \\\\nearrow \\\\rangle\", \"+\",\n",
        "            \"\\\\delta\", \"|\\\\! \\\\nwarrow \\\\rangle\",\n",
        "        )\n",
        "        superposition.target.set_color_by_tex(\"gamma\", TEAL_D)\n",
        "        superposition.target.set_color_by_tex(\"delta\", MAROON)\n",
        "        for part in superposition.target.get_parts_by_tex(\"rangle\"):\n",
        "            part[1].rotate(-np.pi/12)\n",
        "        superposition.target.rotate(np.pi/2, RIGHT)\n",
        "        superposition.target.rotate(np.pi/2, OUT)\n",
        "        superposition.target.move_to(superposition)\n",
        "\n",
        "        for mob in plane, axes:\n",
        "            mob.generate_target()\n",
        "            mob.target.rotate(np.pi/6, RIGHT)\n",
        "\n",
        "        A = 1.9\n",
        "        h_arrow.target = Vector(\n",
        "            A*np.cos(np.pi/12)*rotate_vector(UP, np.pi/6, RIGHT),\n",
        "            normal_vector = RIGHT,\n",
        "            color = TEAL\n",
        "        )\n",
        "        v_arrow.target = Vector(\n",
        "            A*np.sin(np.pi/12)*rotate_vector(OUT, np.pi/6, RIGHT),\n",
        "            normal_vector = RIGHT,\n",
        "            color = MAROON\n",
        "        )\n",
        "        v_arrow.target.shift(h_arrow.target.get_vector())\n",
        "\n",
        "        h_part.target = VGroup(*superposition.target[:2]).copy()\n",
        "        v_part.target = VGroup(*superposition.target[3:]).copy()\n",
        "        h_part.target.next_to(\n",
        "            h_arrow.target.get_center(), IN+UP, SMALL_BUFF\n",
        "        )\n",
        "        v_part.target.next_to(\n",
        "            v_arrow.target.get_center(), UP, SMALL_BUFF\n",
        "        )\n",
        "        for part in h_part.target, v_part.target:\n",
        "            part.rotate(np.pi/2, DOWN)\n",
        "            part.add_to_back(BackgroundRectangle(part))\n",
        "            part.rotate(np.pi/2, UP)\n",
        "\n",
        "        self.equation.generate_target()\n",
        "\n",
        "        self.play(*list(map(MoveToTarget, movers)))\n",
        "        self.wait(2)\n",
        "        self.play(*[mob.restore for mob in movers])\n",
        "        self.wait()\n",
        "\n",
        "    def write_different_meaning(self):\n",
        "        superposition = self.superposition\n",
        "        superposition.rotate(np.pi/2, DOWN)\n",
        "        rect = SurroundingRectangle(superposition)\n",
        "        VGroup(superposition, rect).rotate(np.pi/2, UP)\n",
        "        morty = Mortimer(mode = \"confused\")\n",
        "        blinked = morty.copy().blink()\n",
        "        words = OldTexText(\"Means something \\\\\\\\ different...\")\n",
        "        for mob in morty, blinked, words:\n",
        "            mob.rotate(np.pi/2, RIGHT)\n",
        "            mob.rotate(np.pi/2, OUT)\n",
        "        words.next_to(rect, UP)\n",
        "        VGroup(morty, blinked).next_to(words, IN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(words, run_time = 2)\n",
        "        )\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(Transform(\n",
        "            morty, blinked, \n",
        "            rate_func = squish_rate_func(there_and_back)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            morty, words, rect,\n",
        "            self.equation.rect,\n",
        "            self.equation.words,\n",
        "        ])))\n",
        "\n",
        "    def write_components(self):\n",
        "        d_brace = Brace(Line(ORIGIN, 2*RIGHT), UP, buff = SMALL_BUFF)\n",
        "        h_brace = Brace(Line(ORIGIN, (2/np.sqrt(2))*RIGHT), DOWN, buff = SMALL_BUFF)\n",
        "        v_brace = Brace(Line(ORIGIN, (2/np.sqrt(2))*UP), RIGHT, buff = SMALL_BUFF)\n",
        "        d_brace.rotate(np.pi/4)\n",
        "        v_brace.shift((2/np.sqrt(2))*RIGHT)\n",
        "        braces = VGroup(d_brace, h_brace, v_brace)\n",
        "        group = VGroup(braces)\n",
        "\n",
        "        tex = [\"1\"] + 2*[\"\\\\sqrt{1/2}\"]\n",
        "        colors = BLUE, self.x_color, self.y_color\n",
        "        for brace, tex, color in zip(braces, tex, colors):\n",
        "            brace.label = brace.get_tex(tex, buff = SMALL_BUFF)\n",
        "            brace.label.add_background_rectangle()\n",
        "            brace.label.set_color(color)\n",
        "            group.add(brace.label)\n",
        "\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(d_brace),\n",
        "            Write(d_brace.label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(self.h_part_tex),\n",
        "            FadeOut(self.v_part_tex),\n",
        "            GrowFromCenter(h_brace),\n",
        "            GrowFromCenter(v_brace),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(h_brace.label),\n",
        "            Write(v_brace.label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.d_brace = d_brace\n",
        "        self.h_brace = h_brace\n",
        "        self.v_brace = v_brace\n",
        "\n",
        "    def describe_via_energy(self):\n",
        "        energy = OldTex(\n",
        "            \"&\\\\text{Energy}\", \n",
        "            \"=\", \"(hf)\", \"(\", \"1\", \")^2\\\\\\\\\",\n",
        "            \"&=\", \"(hf)\", \"\\\\left(\", \"\\\\sqrt{1/2}\", \"\\\\right)^2\", \n",
        "            \"+\", \"(hf)\", \"\\\\left(\", \"\\\\sqrt{1/2}\", \"\\\\right)^2\",\n",
        "        )\n",
        "        energy.scale(0.8)\n",
        "        one = energy.get_part_by_tex(\"1\", substring = False)\n",
        "        one.set_color(BLUE)\n",
        "        halves = energy.get_parts_by_tex(\"1/2\")\n",
        "        halves[0].set_color(self.x_color)\n",
        "        halves[1].set_color(self.y_color)\n",
        "        indices = [0, 3, 6, len(energy)]\n",
        "        parts = VGroup(*[\n",
        "            VGroup(*energy[i1:i2])\n",
        "            for i1, i2 in zip(indices, indices[1:])    \n",
        "        ])\n",
        "        for part in parts:\n",
        "            bg_rect = BackgroundRectangle(part)\n",
        "            bg_rect.stretch_in_place(1.5, 1)\n",
        "            part.add_to_back(bg_rect)\n",
        "\n",
        "        parts.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        parts.shift(DOWN)\n",
        "        parts.rotate(np.pi/2, RIGHT)\n",
        "        parts.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(Write(parts[0]), run_time = 2)\n",
        "        self.play(Indicate(energy.get_part_by_tex(\"hf\")))\n",
        "        self.play(\n",
        "            Transform(\n",
        "                self.d_brace.label.copy(),\n",
        "                one.copy(),\n",
        "                remover = True\n",
        "            ),\n",
        "            Write(parts[1], run_time = 1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                self.h_brace.label[1].copy(),\n",
        "                halves[0].copy(),\n",
        "                remover = True,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.75)\n",
        "            ),\n",
        "            Transform(\n",
        "                self.v_brace.label[1].copy(),\n",
        "                halves[1].copy(),\n",
        "                remover = True,\n",
        "                rate_func = squish_rate_func(smooth, 0.25, 1)\n",
        "            ),\n",
        "            Write(parts[2]),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.energy_equation_parts = parts\n",
        "\n",
        "    def components_not_possible_in_isolation(self):\n",
        "        half_hf = VGroup(*self.energy_equation_parts[2][1:6])\n",
        "        half_hf.rotate(np.pi/2, DOWN)\n",
        "        rect = SurroundingRectangle(half_hf)\n",
        "        VGroup(half_hf, rect).rotate(np.pi/2, UP)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.7)\n",
        "        randy.look(UP)\n",
        "        randy.rotate(np.pi/2, RIGHT)\n",
        "        randy.rotate(np.pi/2, OUT)\n",
        "        randy.next_to(rect, IN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(\n",
        "            randy.rotate, np.pi/2, IN,\n",
        "            randy.rotate, np.pi/2, LEFT,\n",
        "            randy.change, \"maybe\",\n",
        "            randy.rotate, np.pi/2, RIGHT,\n",
        "            randy.rotate, np.pi/2, OUT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def ask_what_they_mean(self):\n",
        "        morty = Mortimer(mode = \"confused\")\n",
        "        morty.scale(0.7)\n",
        "        morty.to_edge(LEFT)\n",
        "\n",
        "        bubble = morty.get_bubble()\n",
        "        bubble.write(\"?!?\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.add(bubble.content)\n",
        "        bubble.pin_to(morty)\n",
        "\n",
        "        group = VGroup(morty, bubble)\n",
        "        group.to_corner(DOWN+RIGHT)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "\n",
        "        component = VGroup(self.h_arrow, self.h_brace, self.h_brace.label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(morty),\n",
        "            component.next_to, morty, DOWN, OUT,\n",
        "            component.shift, MED_LARGE_BUFF*(DOWN + OUT),\n",
        "        )\n",
        "        component.rotate(np.pi/2, DOWN)\n",
        "        cross = Cross(component)\n",
        "        VGroup(component, cross).rotate(np.pi/2, UP)\n",
        "        cross.set_color(\"#ff0000\")\n",
        "        self.play(ShowCreation(cross))\n",
        "        bubble.remove(bubble.content)\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "            morty.look_at, component,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def change_camera(self):\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        everything.remove(self.photon.mobject)\n",
        "        everything.remove(self.axes)\n",
        "\n",
        "        self.play(*list(map(FadeOut, everything)))\n",
        "        self.move_camera(\n",
        "            phi = 0.8*np.pi/2,\n",
        "            theta = -0.3*np.pi, \n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            self.photon,\n",
        "            rate_func = lambda x : min(x + 0.55, 1),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.photon.rate_func = lambda x : x\n",
        "        self.play(self.photon)\n",
        "        self.wait()\n",
        "\n",
        "class SeeCommentInDescription(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            \\\\begin{flushleft}\n",
        "            $^*$See comment in the \\\\\\\\\n",
        "            description on single-headed \\\\\\\\\n",
        "            vs. double-headed arrows\n",
        "            \\\\end{flushleft}\n",
        "        \"\"\")\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_corner(DOWN+LEFT)\n",
        "        self.add(words)\n",
        "\n",
        "class SeeCommentInDescriptionAgain(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"$^*$Again, see description\")\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_corner(DOWN+LEFT)\n",
        "        self.add(words)\n",
        "\n",
        "class GetExperimental(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Get experimental!\", target_mode = \"hooray\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ShootPhotonThroughFilter(DirectionOfPolarizationScene):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"wave_number\" : 0,\n",
        "            \"A_vect\" : [0, 1, 1],\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "            \"amplitude\" : np.sqrt(2),\n",
        "        },\n",
        "        \"pol_filter_configs\" : [{\n",
        "            \"label_tex\" : \"\\\\text{Filter}\",\n",
        "            \"include_arrow_label\" : False,\n",
        "        }],\n",
        "        \"apply_filter\" : True,\n",
        "        \"quantum\" : True,\n",
        "        \"pre_filter_alpha\" : 0.35,\n",
        "        \"ambient_rotation_rate\" : 0,\n",
        "    }\n",
        "    def setup(self):\n",
        "        DirectionOfPolarizationScene.setup(self)\n",
        "        self.em_wave.update(0)\n",
        "        self.remove(self.em_wave)\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_superposition_tex()\n",
        "        self.ask_what_would_happen()\n",
        "        self.expect_half_energy_to_be_absorbed()\n",
        "        self.probabalistic_passing_and_blocking()\n",
        "        # self.note_change_in_polarization()\n",
        "\n",
        "    def add_superposition_tex(self):\n",
        "        superposition_tex = OldTex(\n",
        "            \"|\\\\!\\\\nearrow\\\\rangle\", \n",
        "            \"=\",\n",
        "            \"(\\\\sqrt{1/2})\", \"|\\\\!\\\\rightarrow \\\\rangle\", \"+\",\n",
        "            \"(\\\\sqrt{1/2})\", \"|\\\\!\\\\uparrow \\\\rangle\",\n",
        "        )\n",
        "        superposition_tex.scale(0.9)\n",
        "        superposition_tex[0].set_color(E_COLOR)\n",
        "        halves = superposition_tex.get_parts_by_tex(\"1/2\")\n",
        "        for half, color in zip(halves, [RED, GREEN]):\n",
        "            half.set_color(color)\n",
        "\n",
        "        h_rect = SurroundingRectangle(VGroup(*superposition_tex[2:4]))\n",
        "        v_rect = SurroundingRectangle(VGroup(*superposition_tex[5:7]))\n",
        "        VGroup(h_rect, v_rect).fade(1)\n",
        "        superposition_tex.h_rect = h_rect\n",
        "        superposition_tex.v_rect = v_rect\n",
        "        superposition_tex.add(h_rect, v_rect)\n",
        "\n",
        "        superposition_tex.next_to(ORIGIN, LEFT)\n",
        "        superposition_tex.to_edge(UP)\n",
        "        superposition_tex.rotate(np.pi/2, RIGHT)\n",
        "        self.superposition_tex = superposition_tex\n",
        "\n",
        "    def ask_what_would_happen(self):\n",
        "        photon = self.get_photon(\n",
        "            rate_func = lambda t : self.pre_filter_alpha*t,\n",
        "            remover = False,\n",
        "            run_time = 0.6,\n",
        "        )\n",
        "        question = OldTexText(\"What's going to happen?\")\n",
        "        question.add_background_rectangle()\n",
        "        question.set_color(YELLOW)\n",
        "        question.rotate(np.pi/2, RIGHT)\n",
        "        question.next_to(self.superposition_tex, IN)\n",
        "\n",
        "        self.pol_filter.add(\n",
        "            self.pol_filter.arrow.copy().rotate(np.pi/2, OUT)\n",
        "        )\n",
        "        self.pol_filter.save_state()\n",
        "        self.pol_filter.shift(5*OUT)\n",
        "\n",
        "        self.set_camera_orientation(theta = -0.9*np.pi)\n",
        "        self.play(self.pol_filter.restore)\n",
        "        self.move_camera(\n",
        "            theta = -0.6*np.pi,\n",
        "        )\n",
        "        self.play(\n",
        "            photon,\n",
        "            FadeIn(self.superposition_tex)\n",
        "        )\n",
        "        self.play(Write(question, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.pol_filter.label))\n",
        "        self.pol_filter.remove(self.pol_filter.label)\n",
        "        self.add(self.pol_filter)\n",
        "\n",
        "        self.question = question\n",
        "        self.frozen_photon = photon\n",
        "\n",
        "    def expect_half_energy_to_be_absorbed(self):\n",
        "        words = OldTexText(\"Absorbs horizontal \\\\\\\\ energy\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(ORIGIN, UP+RIGHT, MED_LARGE_BUFF)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "        words.rotate(np.pi/2, OUT)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                np.sin(a)*RIGHT + np.cos(a)*UP,\n",
        "                np.sin(a)*LEFT + np.cos(a)*UP,\n",
        "                color = RED,\n",
        "                stroke_width = 2,\n",
        "            )\n",
        "            for a in np.linspace(0, np.pi, 15)\n",
        "        ])\n",
        "        lines.rotate(np.pi/2, RIGHT)\n",
        "        lines.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi = np.pi/2, theta = 0, \n",
        "            added_anims = [\n",
        "                Rotate(self.superposition_tex, np.pi/2),\n",
        "            ] + [\n",
        "                ApplyMethod(\n",
        "                    v.rotate, \n",
        "                    -np.pi/2, \n",
        "                    method_kwargs = {\"axis\" : v.get_vector()}\n",
        "                )\n",
        "                for v in self.frozen_photon.mobject\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            self.superposition_tex.h_rect.set_stroke, RED, 3,\n",
        "            *list(map(GrowFromCenter, lines))+\\\n",
        "            [\n",
        "                Animation(self.pol_filter), \n",
        "                Animation(self.frozen_photon.mobject)\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.move_camera(\n",
        "            phi = 0.8*np.pi/2, theta = -0.7*np.pi,\n",
        "            added_anims = [\n",
        "                FadeOut(words),\n",
        "                Animation(lines),\n",
        "                Rotate(self.superposition_tex, -np.pi/2),\n",
        "            ] + [\n",
        "                ApplyMethod(\n",
        "                    v.rotate, \n",
        "                    np.pi/2, \n",
        "                    method_kwargs = {\"axis\" : v.get_vector()}\n",
        "                )\n",
        "                for v in self.frozen_photon.mobject\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines), \n",
        "            FadeOut(self.question),\n",
        "            self.superposition_tex.h_rect.fade, 1,\n",
        "            Animation(self.pol_filter)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.absorption_words = words\n",
        "\n",
        "    def probabalistic_passing_and_blocking(self):\n",
        "        absorption = self.get_filter_absorption_animation(\n",
        "            self.pol_filter, self.get_blocked_photon()\n",
        "        )\n",
        "        prob = OldTex(\"P(\", \"\\\\text{pass}\", \")\", \"=\", \"1/2\")\n",
        "        prob.set_color_by_tex(\"pass\", GREEN)\n",
        "        prob.rotate(np.pi/2, RIGHT)\n",
        "        prob.next_to(self.superposition_tex, IN, MED_SMALL_BUFF, RIGHT)\n",
        "\n",
        "        self.remove(self.frozen_photon.mobject)\n",
        "        self.play(\n",
        "            self.get_photon(),\n",
        "            rate_func = lambda t : min(t+self.pre_filter_alpha, 1),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(prob),\n",
        "            self.get_blocked_photon(),\n",
        "            absorption\n",
        "        )\n",
        "        bools = 6*[True] + 6*[False]\n",
        "        self.revert_to_original_skipping_status()\n",
        "        random.shuffle(bools)\n",
        "        for should_pass in bools:\n",
        "            if should_pass:\n",
        "                self.play(self.get_photon(), run_time = 1)\n",
        "            else:\n",
        "                self.play(\n",
        "                    self.get_blocked_photon(), \n",
        "                    Animation(self.axes),\n",
        "                    absorption,\n",
        "                    run_time = 1\n",
        "                )\n",
        "        self.play(FadeOut(prob))\n",
        "\n",
        "    def note_change_in_polarization(self):\n",
        "        words = OldTexText(\n",
        "            \"``Collapses'' \\\\\\\\ from\", \"$|\\\\!\\\\nearrow\\\\rangle$\",\n",
        "            \"to\", \"$|\\\\!\\\\uparrow\\\\rangle$\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"nearrow\", E_COLOR)\n",
        "        words.set_color_by_tex(\"uparrow\", GREEN)\n",
        "        words.next_to(ORIGIN, RIGHT, MED_LARGE_BUFF)\n",
        "        words.shift(2*UP)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "        photon = self.get_photon(run_time = 4)\n",
        "        for vect in photon.mobject:\n",
        "            if vect.get_center()[0] > 0:\n",
        "                vect.saved_state.set_fill(GREEN)\n",
        "\n",
        "        self.play(FadeIn(words), photon)\n",
        "        for x in range(3):\n",
        "            self.play(photon)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_photon(self, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 1)\n",
        "        kwargs[\"include_M_vects\"] = False\n",
        "        return WavePacket(em_wave = self.em_wave.copy(), **kwargs)\n",
        "\n",
        "    def get_blocked_photon(self, **kwargs):\n",
        "        kwargs[\"get_filtered\"] = True\n",
        "        return self.get_photon(self, **kwargs)\n",
        "\n",
        "class PhotonPassesCompletelyOrNotAtAllStub(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class YouCanSeeTheCollapse(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"You can literally \\\\\\\\ \\\\emph{see} the collapse\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"hooray\", \"erm\")\n",
        "        self.wait(3)\n",
        "\n",
        "class ThreeFilters(ShootPhotonThroughFilter):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [-4, 0, 4],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : 0},\n",
        "            {\"filter_angle\" : np.pi/4},\n",
        "            {\"filter_angle\" : np.pi/2},\n",
        "        ],\n",
        "        \"EMWave_config\" : {\n",
        "            \"A_vect\" : [0, 0, 1],\n",
        "            \"amplitude\" : 1.5,\n",
        "            \"n_vectors\" : 60,\n",
        "        },\n",
        "        \"line_start_length\" : 8,\n",
        "        \"line_end_length\" : 8,\n",
        "        \"n_lines\" : 20,\n",
        "        \"lines_depth\" : 1.8,\n",
        "        \"lines_shift_vect\" : SMALL_BUFF*OUT,\n",
        "        \"random_seed\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.axes)\n",
        "        self.setup_filters()\n",
        "        self.setup_lines()\n",
        "        self.setup_arrows()\n",
        "\n",
        "        self.fifty_percent_pass_second()\n",
        "        self.show_changed_to_diagonal()\n",
        "        self.fifty_percent_to_pass_third()\n",
        "        self.show_lines_with_middle()\n",
        "        self.remove_middle_then_put_back()\n",
        "\n",
        "    def setup_filters(self):\n",
        "        for pf in self.pol_filters:\n",
        "            pf.arrow_label.rotate(np.pi/2, OUT)\n",
        "            pf.arrow_label.next_to(pf.arrow, RIGHT)\n",
        "            pf.arrow_label.rotate(np.pi/2, LEFT)\n",
        "            pf.arrow_label.add_background_rectangle()\n",
        "            pf.arrow_label.rotate(np.pi/2, RIGHT)\n",
        "            self.add_foreground_mobject(pf.arrow_label)\n",
        "\n",
        "    def setup_lines(self):\n",
        "        lines_group = VGroup(*[\n",
        "            self.get_lines(pf1, pf2, ratio)\n",
        "            for pf1, pf2, ratio in zip(\n",
        "                [None] + list(self.pol_filters),\n",
        "                list(self.pol_filters) + [None],\n",
        "                [1, 1, 0.5, 0.25]\n",
        "            )\n",
        "        ])\n",
        "        lines = lines_group[0]\n",
        "        spacing = lines[1].get_start() - lines[0].get_start()\n",
        "        lines.add(lines.copy().shift(spacing/2))\n",
        "        self.lines_group = lines_group\n",
        "\n",
        "        self.A_to_C_lines = self.get_lines(\n",
        "            self.pol_filters[0], self.pol_filters[2],\n",
        "        )\n",
        "\n",
        "    def setup_arrows(self):\n",
        "        for E_vect in self.em_wave.E_vects:\n",
        "            E_vect.normal_vector = IN+DOWN\n",
        "        self.em_wave.update(0)\n",
        "\n",
        "    def fifty_percent_pass_second(self):\n",
        "        arrow = Arrow(\n",
        "            ORIGIN, 3*RIGHT,\n",
        "            use_rectangular_stem = False,\n",
        "            path_arc = -0.8*np.pi\n",
        "        )\n",
        "        label = OldTex(\"50\\\\%\")\n",
        "        label.next_to(arrow, UP)\n",
        "        group = VGroup(arrow, label)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.next_to(self.pol_filters[1], OUT, buff = 0)\n",
        "        group.set_color(BLUE)\n",
        "\n",
        "        l1, l2, l3 = self.lines_group[:3]\n",
        "        pf1, pf2, pf3 = self.pol_filters\n",
        "        kwargs = {\n",
        "            \"lag_ratio\" : 0,\n",
        "            \"rate_func\" : None,\n",
        "        }\n",
        "\n",
        "        self.play(ShowCreation(l1, run_time = 1, **kwargs))\n",
        "        self.play(\n",
        "            ShowCreation(l2, **kwargs),\n",
        "            Animation(VGroup(pf1, l1)),\n",
        "            ShowCreation(arrow),\n",
        "            run_time = 0.5,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(l3, **kwargs),\n",
        "            Animation(VGroup(pf2, l2, pf1, l1)),\n",
        "            FadeIn(label),\n",
        "            run_time = 0.5, \n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(l3),\n",
        "            Animation(pf2), \n",
        "            FadeOut(l2),\n",
        "            Animation(pf1),\n",
        "            FadeOut(l1)\n",
        "        )\n",
        "\n",
        "        self.fifty_percent_arrow_group = group\n",
        "\n",
        "    def show_changed_to_diagonal(self):\n",
        "        photon = self.get_photon(\n",
        "            run_time = 2,\n",
        "            rate_func = lambda x : 0.6*x,\n",
        "            remover = False,\n",
        "        )\n",
        "        brace = Brace(Line(1.5*LEFT, 1.5*RIGHT), DOWN)\n",
        "        label = brace.get_text(\n",
        "            \"Changed to\", \n",
        "            \"$|\\\\!\\\\nearrow\\\\rangle$\"\n",
        "        )\n",
        "        label.set_color_by_tex(\"rangle\", BLUE)\n",
        "        group = VGroup(brace, label)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.shift(2*RIGHT + 0.5*IN)\n",
        "\n",
        "        self.play(photon)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(label, run_time = 1)\n",
        "        )\n",
        "        kwargs = {\n",
        "            \"run_time\" : 3,\n",
        "            \"rate_func\" : there_and_back_with_pause,\n",
        "        }\n",
        "        self.move_camera(\n",
        "            phi = np.pi/2,\n",
        "            theta = 0,\n",
        "            added_anims = [\n",
        "                Animation(VGroup(*self.pol_filters[:2]))\n",
        "            ] + [\n",
        "                Rotate(\n",
        "                    v, np.pi/2, \n",
        "                    axis = v.get_vector(),\n",
        "                    in_place = True,\n",
        "                    **kwargs\n",
        "                )\n",
        "                for v in photon.mobject\n",
        "            ] + [\n",
        "                Animation(self.pol_filters[2]),\n",
        "                Rotate(\n",
        "                    label, np.pi/2, \n",
        "                    axis = OUT,\n",
        "                    in_place = True,\n",
        "                    **kwargs\n",
        "                ),\n",
        "            ],\n",
        "            **kwargs\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.photon = photon\n",
        "        self.brace_group = VGroup(brace, label)\n",
        "\n",
        "    def fifty_percent_to_pass_third(self):\n",
        "        arrow_group = self.fifty_percent_arrow_group.copy()\n",
        "        arrow_group.shift(4*RIGHT)\n",
        "        arrow, label = arrow_group\n",
        "\n",
        "        a = self.photon.rate_func(1)\n",
        "        new_photon = self.get_photon(\n",
        "            rate_func = lambda x : (1-a)*x + a,\n",
        "            run_time = 1\n",
        "        )\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(label, run_time = 1)\n",
        "        )\n",
        "        self.remove(self.photon.mobject)\n",
        "        self.play(new_photon)\n",
        "\n",
        "        self.second_fifty_percent_arrow_group = arrow_group\n",
        "\n",
        "    def show_lines_with_middle(self):\n",
        "        l1, l2, l3, l4 = self.lines_group\n",
        "        pf1, pf2, pf3 = self.pol_filters\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(l4),\n",
        "            Animation(pf3),\n",
        "            FadeIn(l3),\n",
        "            Animation(pf2),\n",
        "            FadeIn(l2),\n",
        "            Animation(pf1),\n",
        "            FadeIn(l1),\n",
        "            FadeOut(self.brace_group)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def remove_middle_then_put_back(self):\n",
        "        l1, l2, l3, l4 = self.lines_group\n",
        "        pf1, pf2, pf3 = self.pol_filters\n",
        "        mid_lines = self.A_to_C_lines\n",
        "        mover = VGroup(\n",
        "            pf2, \n",
        "            self.fifty_percent_arrow_group,\n",
        "            self.second_fifty_percent_arrow_group,\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(\n",
        "            ORIGIN, 7*RIGHT,\n",
        "            path_arc = 0.5*np.pi,\n",
        "        )\n",
        "        labels = VGroup(*list(map(Tex, [\"0\\\\%\", \"25\\\\%\"])))\n",
        "        labels.scale(1.5)\n",
        "        labels.next_to(arrow, DOWN)\n",
        "        group = VGroup(arrow, labels)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.shift(2*LEFT + IN)\n",
        "        group.set_color(GREEN)\n",
        "\n",
        "        self.remove(l2, l3)\n",
        "        self.play(\n",
        "            FadeOut(l4),\n",
        "            Animation(pf3),\n",
        "            FadeOut(l3),\n",
        "            ApplyMethod(\n",
        "                mover.shift, 3*OUT,\n",
        "                rate_func = running_start\n",
        "            ),\n",
        "            ReplacementTransform(l2.copy(), mid_lines),\n",
        "            Animation(pf1),\n",
        "            Animation(l1)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(labels[0], run_time = 1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(l4),\n",
        "            Animation(pf3),\n",
        "            FadeOut(mid_lines),\n",
        "            FadeIn(l3),\n",
        "            mover.shift, 3*IN,\n",
        "            FadeIn(l2),\n",
        "            Animation(pf1),\n",
        "            Animation(l1)\n",
        "        )\n",
        "        self.play(ReplacementTransform(*labels))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_photon(self, **kwargs):\n",
        "        return ShootPhotonThroughFilter.get_photon(self, width = 4, **kwargs)\n",
        "\n",
        "    def get_lines(self, filter1 = None, filter2 = None, ratio = 1.0):\n",
        "        n = self.n_lines\n",
        "        start, end = [\n",
        "            (f.point_from_proportion(0.75) if f is not None else None)\n",
        "            for f in (filter1, filter2)\n",
        "        ]\n",
        "        if start is None:\n",
        "            start = end + self.line_start_length*LEFT\n",
        "        if end is None:\n",
        "            end = start + self.line_end_length*RIGHT\n",
        "        nudge = (float(self.lines_depth)/self.n_lines)*OUT\n",
        "        lines = VGroup(*[\n",
        "            Line(start, end).shift(z*nudge)\n",
        "            for z in range(n)\n",
        "        ])\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "        lines.move_to(start, IN+LEFT)\n",
        "        lines.shift(self.lines_shift_vect)\n",
        "        n_to_block = int((1-ratio)*self.n_lines)\n",
        "        random.seed(self.random_seed)\n",
        "        indices_to_block = random.sample(\n",
        "            list(range(self.n_lines)), n_to_block\n",
        "        )\n",
        "        VGroup(*[lines[i] for i in indices_to_block]).set_stroke(width = 0)\n",
        "        return lines\n",
        "\n",
        "class PhotonAtSlightAngle(ThreeFilters):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [3],\n",
        "        \"pol_filter_configs\" : [{\n",
        "            \"label_tex\" : \"\",\n",
        "            \"include_arrow_label\" : False,\n",
        "            \"radius\" : 1.4,\n",
        "        }],\n",
        "        \"EMWave_config\" : {\n",
        "            \"wave_number\" : 0,\n",
        "            \"A_vect\" : [0, np.sin(np.pi/8), np.cos(np.pi/8)],\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT,\n",
        "            \"amplitude\" : 2,\n",
        "        },\n",
        "        \"axes_config\" : {\n",
        "            \"z_max\" : 2.5,\n",
        "        },\n",
        "        \"radius\" : 1.3,\n",
        "        \"lines_depth\" : 2.5,\n",
        "        \"line_start_length\" : 12,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.shoot_photon()\n",
        "        self.reposition_camera_to_head_on()\n",
        "        self.write_angle()\n",
        "        self.write_components()\n",
        "        self.classical_energy_conception()\n",
        "        self.reposition_camera_back()\n",
        "        self.rewrite_15_percent_meaning()\n",
        "        self.probabalistic_passing()\n",
        "\n",
        "    def shoot_photon(self):\n",
        "        photon = self.get_photon(\n",
        "            rate_func = lambda x : 0.5*x,\n",
        "            remover = False,\n",
        "        )\n",
        "        self.play(photon)\n",
        "        self.photon = photon\n",
        "\n",
        "    def reposition_camera_to_head_on(self):\n",
        "        self.move_camera(\n",
        "            phi = np.pi/2, theta = 0,\n",
        "            added_anims = list(it.chain(*[\n",
        "                [\n",
        "                    v.rotate, np.pi/2, v.get_vector(),\n",
        "                    v.set_fill, None, 0.7,\n",
        "                ]\n",
        "                for v in self.photon.mobject\n",
        "            ])) + [Animation(self.pol_filter)]\n",
        "        )\n",
        "\n",
        "    def write_angle(self):\n",
        "        arc = Arc(\n",
        "            start_angle = np.pi/2, angle = -np.pi/8,\n",
        "            radius = self.pol_filter.radius,\n",
        "        )\n",
        "        label = OldTex(\"22.5^\\\\circ\")\n",
        "        label.next_to(arc.get_center(), UP+RIGHT, SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(arc, label)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.pol_filter),\n",
        "            ShowCreation(arc),\n",
        "            Write(label, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.arc = arc\n",
        "        self.angle_label = label\n",
        "\n",
        "    def write_components(self):\n",
        "        d_brace = Brace(Line(ORIGIN, self.radius*RIGHT), UP, buff = SMALL_BUFF)\n",
        "        d_brace.rotate(np.pi/2 - np.pi/8)\n",
        "        d_brace.label = d_brace.get_tex(\"1\", buff = SMALL_BUFF)\n",
        "        d_brace.label.add_background_rectangle()\n",
        "\n",
        "        h_arrow = Vector(\n",
        "            self.radius*np.sin(np.pi/8)*RIGHT,\n",
        "            color = RED,\n",
        "        )\n",
        "        h_label = OldTex(\"\\\\sin(22.5^\\\\circ)\")\n",
        "        h_label.scale(0.7)\n",
        "        h_label.set_color(RED)\n",
        "        h_label.next_to(h_arrow.get_center(), DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        v_arrow = Vector(\n",
        "            self.radius*np.cos(np.pi/8)*UP,\n",
        "            color = GREEN\n",
        "        )\n",
        "        v_arrow.shift(h_arrow.get_vector())\n",
        "        v_label = OldTex(\"\\\\cos(22.5^\\\\circ)\")\n",
        "        v_label.scale(0.7)\n",
        "        v_label.set_color(GREEN)\n",
        "        v_label.next_to(v_arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        state = OldTex(\n",
        "            \"|\\\\!\\\\psi\\\\rangle\", \n",
        "            \"=\", \"\\\\sin(22.5^\\\\circ)\", \"|\\\\!\\\\rightarrow\\\\rangle\", \n",
        "            \"+\", \"\\\\cos(22.5^\\\\circ)\", \"|\\\\!\\\\uparrow\\\\rangle\",\n",
        "        )\n",
        "        state.set_color_by_tex_to_color_map({\n",
        "            \"psi\" : BLUE,\n",
        "            \"rightarrow\" : RED,\n",
        "            \"uparrow\" : GREEN,\n",
        "        })\n",
        "        # state.add_background_rectangle()\n",
        "        state.to_edge(UP)\n",
        "\n",
        "        sin_brace = Brace(state.get_part_by_tex(\"sin\"), DOWN, buff = SMALL_BUFF)\n",
        "        sin_brace.label = sin_brace.get_tex(\"%.2f\"%np.sin(np.pi/8), buff = SMALL_BUFF)\n",
        "        cos_brace = Brace(state.get_part_by_tex(\"cos\"), DOWN, buff = SMALL_BUFF)\n",
        "        cos_brace.label = cos_brace.get_tex(\"%.2f\"%np.cos(np.pi/8), buff = SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(\n",
        "            d_brace, d_brace.label, \n",
        "            h_arrow, h_label,\n",
        "            v_arrow, v_label,\n",
        "            state,\n",
        "            sin_brace, sin_brace.label,\n",
        "            cos_brace, cos_brace.label,\n",
        "        )\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(d_brace),\n",
        "            Write(d_brace.label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromPoint(h_arrow, ORIGIN),\n",
        "            Write(h_label, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(VGroup(*state[:2])),\n",
        "            ReplacementTransform(\n",
        "                h_label.copy(), \n",
        "                state.get_part_by_tex(\"sin\")\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                h_arrow.copy(), \n",
        "                state.get_part_by_tex(\"rightarrow\")\n",
        "            ),\n",
        "            Write(state.get_part_by_tex(\"+\"))\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(sin_brace),\n",
        "            Write(sin_brace.label, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromPoint(v_arrow, h_arrow.get_end()),\n",
        "            Write(v_label, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                v_label.copy(), \n",
        "                state.get_part_by_tex(\"cos\")\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                v_arrow.copy(), \n",
        "                state.get_part_by_tex(\"uparrow\")\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(cos_brace),\n",
        "            Write(cos_brace.label, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.d_brace = d_brace\n",
        "        self.state_equation = state\n",
        "        self.state_equation.add(\n",
        "            sin_brace, sin_brace.label,\n",
        "            cos_brace, cos_brace.label,\n",
        "        )\n",
        "        self.sin_brace = sin_brace\n",
        "        self.cos_brace = cos_brace\n",
        "        self.h_arrow = h_arrow\n",
        "        self.h_label = h_label\n",
        "        self.v_arrow = v_arrow\n",
        "        self.v_label = v_label\n",
        "\n",
        "    def classical_energy_conception(self):\n",
        "        randy = Randolph(mode = \"pondering\").flip()\n",
        "        randy.scale(0.7)\n",
        "        randy.next_to(ORIGIN, LEFT)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        bubble = ThoughtBubble(direction = RIGHT)\n",
        "        h_content = OldTex(\n",
        "            \"0.38\", \"^2\", \"= 0.15\", \"\\\\text{ energy}\\\\\\\\\",\n",
        "            \"\\\\text{in the }\", \"\\\\rightarrow\", \"\\\\text{ direction}\"\n",
        "        )\n",
        "        alt_h_content = OldTex(\n",
        "            \"0.38\", \"^2\", \"=& 15\\\\%\", \"\\\\text{ of energy}\\\\\\\\\",\n",
        "            \"&\\\\text{absorbed}\", \"\", \"\",\n",
        "        )\n",
        "        h_content.set_color_by_tex(\"rightarrow\", RED)\n",
        "        alt_h_content.set_color_by_tex(\"rightarrow\", RED)\n",
        "        alt_h_content.scale(0.8)\n",
        "        v_content = OldTex(\n",
        "            \"0.92\", \"^2\", \"= 0.85\", \"\\\\text{ energy}\\\\\\\\\",\n",
        "            \"\\\\text{in the }\", \"\\\\uparrow\", \"\\\\text{ direction}\"\n",
        "        )\n",
        "        v_content.set_color_by_tex(\"uparrow\", GREEN)\n",
        "\n",
        "        bubble.add_content(h_content)\n",
        "        bubble.resize_to_content()\n",
        "        v_content.move_to(h_content)\n",
        "        bubble_group = VGroup(bubble, h_content, v_content)\n",
        "        bubble_group.scale(0.8)\n",
        "        bubble_group.next_to(randy, UP+LEFT, SMALL_BUFF)\n",
        "\n",
        "        classically = OldTexText(\"Classically...\")\n",
        "        classically.next_to(bubble[-1], UP)\n",
        "        classically.set_color(YELLOW)\n",
        "        alt_h_content.next_to(classically, DOWN)\n",
        "\n",
        "        group = VGroup(randy, bubble_group, classically, alt_h_content)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/2, OUT)\n",
        "\n",
        "        filter_lines = self.get_filter_lines(self.pol_filter)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            FadeIn(classically),\n",
        "            ShowCreation(bubble),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.sin_brace.label.copy(),\n",
        "                h_content[0]\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.state_equation.get_part_by_tex(\"rightarrow\").copy(),\n",
        "                h_content.get_part_by_tex(\"rightarrow\")\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(VGroup(*h_content[1:5])),\n",
        "            Write(h_content.get_part_by_tex(\"direction\")),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(h_content.shift, 2*IN)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.cos_brace.label.copy(),\n",
        "                v_content[0]\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.state_equation.get_part_by_tex(\"uparrow\").copy(),\n",
        "                v_content.get_part_by_tex(\"uparrow\")\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(VGroup(*v_content[1:5])),\n",
        "            Write(v_content.get_part_by_tex(\"direction\")),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(v_content),\n",
        "            Transform(h_content, alt_h_content),\n",
        "            FadeIn(self.pol_filter),\n",
        "            Animation(self.arc)\n",
        "        )\n",
        "        self.play(ShowCreation(filter_lines, lag_ratio = 0))\n",
        "        self.play(FadeOut(filter_lines))\n",
        "        self.wait()\n",
        "\n",
        "        self.classically = VGroup(classically, h_content)\n",
        "\n",
        "    def reposition_camera_back(self):\n",
        "        self.move_camera(\n",
        "            phi = 0.8*np.pi/2, theta = -0.6*np.pi,\n",
        "            added_anims = [\n",
        "                FadeOut(self.h_arrow),\n",
        "                FadeOut(self.h_label),\n",
        "                FadeOut(self.v_arrow),\n",
        "                FadeOut(self.v_label),\n",
        "                FadeOut(self.d_brace),\n",
        "                FadeOut(self.d_brace.label),\n",
        "                FadeOut(self.arc),\n",
        "                FadeOut(self.angle_label),\n",
        "                Rotate(self.state_equation, np.pi/2, IN),\n",
        "                Rotate(self.classically, np.pi/2, IN),\n",
        "            ] + [\n",
        "                Rotate(\n",
        "                    v, np.pi/2, \n",
        "                    axis = v.get_vector(),\n",
        "                    in_place = True,\n",
        "                )\n",
        "                for v in self.photon.mobject\n",
        "            ],\n",
        "            run_time = 1.5\n",
        "        )\n",
        "\n",
        "    def rewrite_15_percent_meaning(self):\n",
        "        self.classically.rotate(np.pi/2, LEFT)\n",
        "        cross = Cross(self.classically)\n",
        "        cross.set_color(\"#ff0000\")\n",
        "        VGroup(self.classically, cross).rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        new_conception = OldTexText(\n",
        "            \"$0.38^2 = 15\\\\%$ chance of \\\\\\\\ getting blocked\"\n",
        "        )\n",
        "        new_conception.scale(0.8)\n",
        "        new_conception.rotate(np.pi/2, RIGHT)\n",
        "        new_conception.move_to(self.classically, OUT)\n",
        "\n",
        "        a = self.photon.rate_func(1)\n",
        "        finish_photon = self.get_blocked_photon(\n",
        "            rate_func = lambda t : a + (1-a)*t\n",
        "        )\n",
        "        finish_photon.mobject.set_fill(opacity = 0.7)\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.classically.add(cross)\n",
        "        self.play(\n",
        "            self.classically.shift, 4*IN,\n",
        "            FadeIn(new_conception),\n",
        "        )\n",
        "        self.remove(self.photon.mobject)\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(\n",
        "            finish_photon,\n",
        "            ApplyMethod(\n",
        "                self.pol_filter.set_color, RED,\n",
        "                rate_func = squish_rate_func(there_and_back, 0, 0.3),\n",
        "                run_time = finish_photon.run_time\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def probabalistic_passing(self):\n",
        "        # photons = [\n",
        "        #     self.get_photon()\n",
        "        #     for x in range(3)\n",
        "        # ] + [self.get_blocked_photon()]\n",
        "        # random.shuffle(photons)\n",
        "        # for photon in photons:\n",
        "        #     added_anims = []\n",
        "        #     if photon.get_filtered:\n",
        "        #         added_anims.append(\n",
        "        #             self.get_filter_absorption_animation(\n",
        "        #                 self.pol_filter, photon, \n",
        "        #             )\n",
        "        #         )\n",
        "        #     self.play(photon, *added_anims)\n",
        "        # self.wait()\n",
        "\n",
        "        l1 = self.get_lines(None, self.pol_filter)\n",
        "        l2 = self.get_lines(self.pol_filter, None, 0.85)\n",
        "        for line in it.chain(l1, l2):\n",
        "            if line.get_stroke_width() > 0:\n",
        "                line.set_stroke(width = 3)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            2*LEFT, 2*RIGHT, \n",
        "            path_arc = 0.8*np.pi,\n",
        "        )\n",
        "        label = OldTex(\"15\\\\% \\\\text{ absorbed}\")\n",
        "        label.next_to(arrow, DOWN)\n",
        "        group = VGroup(arrow, label)\n",
        "        group.set_color(RED)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.shift(3*RIGHT + 1.5*IN)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"lag_ratio\" : 0,\n",
        "        }\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(label, run_time = 1),\n",
        "            ShowCreation(l1, **kwargs)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(l2, run_time = 0.5, **kwargs),\n",
        "            Animation(self.pol_filter),\n",
        "            Animation(l1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_filter_lines(self, pol_filter):\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                np.sin(a)*RIGHT + np.cos(a)*UP,\n",
        "                np.sin(a)*LEFT + np.cos(a)*UP,\n",
        "                color = RED,\n",
        "                stroke_width = 2,\n",
        "            )\n",
        "            for a in np.linspace(0, np.pi, 15)\n",
        "        ])\n",
        "        lines.scale(pol_filter.radius)\n",
        "        lines.rotate(np.pi/2, RIGHT)\n",
        "        lines.rotate(np.pi/2, OUT)\n",
        "        lines.shift(pol_filter.get_center()[0]*RIGHT)\n",
        "        return lines\n",
        "\n",
        "    def get_blocked_photon(self, **kwargs):\n",
        "        return self.get_photon(\n",
        "            filter_distance = FRAME_X_RADIUS + 3, \n",
        "            get_filtered = True,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "class CompareWaveEquations(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_equation()\n",
        "        self.show_complex_plane()\n",
        "        self.show_interpretations()\n",
        "\n",
        "    def add_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"|\\\\!\\\\psi\\\\rangle\",\n",
        "            \"=\", \"\\\\alpha\", \"|\\\\!\\\\rightarrow\\\\rangle\",\n",
        "            \"+\", \"\\\\beta\", \"|\\\\!\\\\uparrow\\\\rangle\",\n",
        "        )\n",
        "        equation.set_color_by_tex_to_color_map({\n",
        "            \"psi\" : BLUE,\n",
        "            \"rightarrow\" : RED,\n",
        "            \"uparrow\" : GREEN,\n",
        "        })\n",
        "        equation.next_to(ORIGIN, LEFT)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        psi_rect = SurroundingRectangle(equation.get_part_by_tex(\"psi\"))\n",
        "        psi_rect.set_color(WHITE)\n",
        "        state_words = OldTexText(\"Polarization \\\\\\\\ state\")\n",
        "        state_words.set_color(BLUE)\n",
        "        state_words.scale(0.8)\n",
        "        state_words.next_to(psi_rect, DOWN)\n",
        "\n",
        "        equation.save_state()\n",
        "        equation.scale(0.01)\n",
        "        equation.fade(1)\n",
        "        equation.move_to(self.teacher.get_left())\n",
        "        equation.shift(SMALL_BUFF*UP)\n",
        "\n",
        "        self.play(\n",
        "            equation.restore,\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = psi_rect,\n",
        "            added_anims = [\n",
        "                ShowCreation(psi_rect),\n",
        "                Write(state_words, run_time = 1)\n",
        "            ],\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(FadeOut(psi_rect))\n",
        "\n",
        "        self.equation = equation\n",
        "        self.state_words = state_words\n",
        "\n",
        "    def show_complex_plane(self):\n",
        "        new_alpha, new_beta = terms = [\n",
        "            self.equation.get_part_by_tex(tex).copy()\n",
        "            for tex in (\"alpha\", \"beta\")\n",
        "        ]\n",
        "        for term in terms:\n",
        "            term.save_state()\n",
        "            term.generate_target()\n",
        "            term.target.scale(0.7)\n",
        "\n",
        "        plane = ComplexPlane(\n",
        "            x_radius = 1.5,\n",
        "            y_radius = 1.5,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        plane.scale(1.3)\n",
        "        plane.next_to(ORIGIN, RIGHT, MED_LARGE_BUFF)\n",
        "        plane.to_edge(UP)\n",
        "\n",
        "        alpha_dot, beta_dot = [\n",
        "            Dot(\n",
        "                plane.coords_to_point(x, 0.5), \n",
        "                radius = 0.05,\n",
        "                color = color\n",
        "            )\n",
        "            for x, color in [(-0.5, RED), (0.5, GREEN)]\n",
        "        ]\n",
        "        new_alpha.target.next_to(alpha_dot, UP+LEFT, 0.5*SMALL_BUFF)\n",
        "        new_alpha.target.set_color(RED)\n",
        "        new_beta.target.next_to(beta_dot, UP+RIGHT, 0.5*SMALL_BUFF)\n",
        "        new_beta.target.set_color(GREEN)\n",
        "\n",
        "        rhs = OldTex(\n",
        "            \"=\", \"A_y\", \"e\", \"^{i(\", \n",
        "            \"2\\\\pi\", \"f\", \"t\", \"+\", \"\\\\phi_y\", \")}\"\n",
        "        )\n",
        "        rhs.scale(0.7)\n",
        "        rhs.next_to(new_beta.target, RIGHT, SMALL_BUFF)\n",
        "        rhs.shift(0.5*SMALL_BUFF*UP)\n",
        "        rhs.set_color_by_tex_to_color_map({\n",
        "            \"A_y\" : GREEN,\n",
        "            \"phi\" : MAROON_B,\n",
        "        })\n",
        "        A_copy = rhs.get_part_by_tex(\"A_y\").copy()\n",
        "        phi_copy = rhs.get_part_by_tex(\"phi_y\").copy()\n",
        "        A_line = Line(\n",
        "            plane.coords_to_point(0, 0),\n",
        "            plane.coords_to_point(0.5, 0.5),\n",
        "            color = GREEN,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "\n",
        "        arc = Arc(angle = np.pi/4, radius = 0.5)\n",
        "        arc.shift(plane.get_center())\n",
        "\n",
        "        self.play(\n",
        "            Write(plane, run_time = 2),\n",
        "            MoveToTarget(new_alpha),\n",
        "            MoveToTarget(new_beta),\n",
        "            DrawBorderThenFill(alpha_dot, run_time = 1),\n",
        "            DrawBorderThenFill(beta_dot, run_time = 1),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(rhs),\n",
        "            ShowCreation(A_line),\n",
        "            ShowCreation(arc)\n",
        "        )\n",
        "        self.play(\n",
        "            phi_copy.next_to, arc, RIGHT, SMALL_BUFF,\n",
        "            phi_copy.shift, 0.5*SMALL_BUFF*UP\n",
        "        )\n",
        "        self.play(\n",
        "            A_copy.next_to, A_line.get_center(), \n",
        "                UP, SMALL_BUFF,\n",
        "            A_copy.shift, 0.5*SMALL_BUFF*(UP+LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_interpretations(self):\n",
        "        c_words = OldTex(\n",
        "            \"\\\\text{Classically: }\", \"&|\\\\beta|^2\",\n",
        "            \"\\\\rightarrow\",\n",
        "            \"\\\\text{Component of} \\\\\\\\\",\n",
        "            \"&\\\\text{energy in }\", \"|\\\\!\\\\uparrow\\\\rangle\", \n",
        "            \"\\\\text{ direction}\",\n",
        "        )\n",
        "        qm_words = OldTex(\n",
        "            \"\\\\text{Quantum: }\", \"&|\\\\beta|^2\",\n",
        "            \"\\\\rightarrow\",\n",
        "            \"\\\\text{Probability that}\", \"\\\\text{ \\\\emph{all}} \\\\\\\\\",\n",
        "            \"&\\\\text{energy is measured in }\", \"|\\\\!\\\\uparrow\\\\rangle\", \n",
        "            \"\\\\text{ direction}\",\n",
        "        )\n",
        "        for words in c_words, qm_words:\n",
        "            words.set_color_by_tex_to_color_map({\n",
        "                \"Classically\" : YELLOW,\n",
        "                \"Quantum\" : BLUE,\n",
        "                \"{all}\" : BLUE,\n",
        "                \"beta\" : GREEN,\n",
        "                \"uparrow\" : GREEN,\n",
        "            })\n",
        "            words.scale(0.7)\n",
        "        c_words.to_edge(LEFT)\n",
        "        c_words.shift(2*UP)\n",
        "        qm_words.next_to(c_words, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.state_words),\n",
        "            Write(c_words),\n",
        "            self.teacher.change, \"happy\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"happy\"]*3, look_at = c_words\n",
        "        )\n",
        "        self.play(Write(qm_words))\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"confused\", \"pondering\",\n",
        "            look_at = qm_words\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class CircularPhotons(ShootPhotonThroughFilter):\n",
        "    CONFIG = {\n",
        "        \"EMWave_config\" : {\n",
        "            \"phi_vect\" : [0, -np.pi/2, 0],\n",
        "            \"wave_number\" : 1,\n",
        "            \"start_point\" : 10*LEFT,\n",
        "            \"length\" : 20,\n",
        "            \"n_vectors\" : 60,\n",
        "        },\n",
        "        \"apply_filter\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(theta = -0.75*np.pi)\n",
        "        self.setup_filter()\n",
        "        self.show_phase_difference()\n",
        "        self.shoot_circular_photons()\n",
        "        self.show_filter()\n",
        "        self.show_vertically_polarized_light()\n",
        "\n",
        "    def setup_filter(self):\n",
        "        pf = self.pol_filter\n",
        "        pf.remove(pf.label)\n",
        "        pf.remove(pf.arrow)\n",
        "        self.remove(pf.label, pf.arrow)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                v1, v2,\n",
        "                color = WHITE,\n",
        "                path_arc = np.pi,\n",
        "            )\n",
        "            for v1, v2 in [(LEFT, RIGHT), (RIGHT, LEFT)]\n",
        "        ])\n",
        "        arrows.scale(0.7)\n",
        "        arrows.rotate(np.pi/2, RIGHT)\n",
        "        arrows.rotate(np.pi/2, OUT)\n",
        "        arrows.move_to(center_of_mass(pf.get_points()))\n",
        "\n",
        "        pf.label = arrows\n",
        "        pf.add(arrows)\n",
        "        self.remove(pf)\n",
        "\n",
        "    def show_phase_difference(self):\n",
        "        equation = OldTex(\n",
        "            \"|\\\\!\\\\circlearrowright\\\\rangle\", \n",
        "            \"=\", \"\\\\frac{1}{\\\\sqrt{2}}\", \"|\\\\!\\\\rightarrow\\\\rangle\",\n",
        "            \"+\", \"\\\\frac{i}{\\\\sqrt{2}}\", \"|\\\\!\\\\uparrow\\\\rangle\",\n",
        "        )\n",
        "        equation.set_color_by_tex_to_color_map({\n",
        "            \"circlearrowright\" : BLUE,\n",
        "            \"rightarrow\" : RED,\n",
        "            \"uparrow\" : GREEN,\n",
        "        })\n",
        "        equation.next_to(ORIGIN, LEFT, LARGE_BUFF)\n",
        "        equation.to_edge(UP)\n",
        "        rect = SurroundingRectangle(equation.get_part_by_tex(\"frac{i}\"))\n",
        "        words = OldTexText(\"Phase shift\")\n",
        "        words.next_to(rect, DOWN)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        group = VGroup(equation, rect, words)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/4, IN)\n",
        "\n",
        "        self.play(FadeIn(equation))\n",
        "        self.play(self.get_circular_photon())\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(words, run_time = 1)\n",
        "        )\n",
        "\n",
        "        self.circ_equation_group = group\n",
        "\n",
        "    def shoot_circular_photons(self):\n",
        "        for x in range(2):\n",
        "            self.play(self.get_circular_photon())\n",
        "\n",
        "    def show_filter(self):\n",
        "        pf = self.pol_filter\n",
        "        pf.save_state()\n",
        "        pf.shift(4*OUT)\n",
        "        pf.fade(1)\n",
        "\n",
        "        self.play(pf.restore)\n",
        "        self.play(\n",
        "            self.get_circular_photon(),\n",
        "            Animation(self.circ_equation_group)\n",
        "        )\n",
        "        self.play(FadeOut(self.circ_equation_group))\n",
        "\n",
        "    def show_vertically_polarized_light(self):\n",
        "        equation = OldTex(\n",
        "            \"|\\\\!\\\\uparrow \\\\rangle\", \n",
        "            \"=\", \"\\\\frac{i}{\\\\sqrt{2}}\", \"|\\\\!\\\\circlearrowleft \\\\rangle\",\n",
        "            \"+\", \"\\\\frac{-i}{\\\\sqrt{2}}\", \"|\\\\!\\\\circlearrowright \\\\rangle\",\n",
        "        )\n",
        "        equation.set_color_by_tex_to_color_map({\n",
        "            \"circlearrowright\" : BLUE,\n",
        "            \"frac{-i}\" : BLUE,\n",
        "            \"circlearrowleft\" : YELLOW,\n",
        "            \"frac{i}\" : YELLOW,\n",
        "            \"uparrow\" : GREEN,\n",
        "        })\n",
        "        equation.next_to(ORIGIN, LEFT, LARGE_BUFF)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        prob = OldTex(\n",
        "            \"P(\", \"\\\\text{passing}\", \")\",\n",
        "            \"=\", \"\\\\left(\", \"\\\\frac{-i}{\\\\sqrt{2}}\", \"\\\\right)^2\"\n",
        "        )\n",
        "        prob.set_color_by_tex(\"sqrt{2}\", BLUE)\n",
        "        prob.next_to(equation, DOWN)\n",
        "\n",
        "        group = VGroup(equation, prob)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.rotate(np.pi/4, IN)\n",
        "\n",
        "        em_wave = EMWave(\n",
        "            wave_number = 0,\n",
        "            amplitude = 2,\n",
        "            start_point = 10*LEFT,\n",
        "            length = 20,\n",
        "        )\n",
        "        v_photon = WavePacket(\n",
        "            em_wave = em_wave, \n",
        "            include_M_vects = False,\n",
        "            run_time = 2\n",
        "        )\n",
        "        c_photon = self.get_circular_photon()\n",
        "        for v_vect in v_photon.mobject:\n",
        "            v_vect.saved_state.set_fill(GREEN)\n",
        "            if v_vect.get_start()[0] > 0:\n",
        "                v_vect.saved_state.set_fill(opacity = 0)\n",
        "        for c_vect in c_photon.mobject:\n",
        "            if c_vect.get_start()[0] < 0:\n",
        "                c_vect.saved_state.set_fill(opacity = 0)\n",
        "        blocked_v_photon = copy.deepcopy(v_photon)\n",
        "        blocked_v_photon.get_filtered = True\n",
        "        blocked_v_photon.filter_distance = 10\n",
        "\n",
        "        self.play(Write(equation, run_time = 1))\n",
        "        self.play(v_photon, c_photon)\n",
        "        self.play(FadeIn(prob))\n",
        "        bools = 3*[True] + 3*[False]\n",
        "        random.shuffle(bools)\n",
        "        for should_pass in bools:\n",
        "            if should_pass:\n",
        "                self.play(v_photon, c_photon)\n",
        "            else:\n",
        "                self.play(\n",
        "                    blocked_v_photon,\n",
        "                    self.get_filter_absorption_animation(\n",
        "                        self.pol_filter, blocked_v_photon\n",
        "                    )\n",
        "                )\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_circular_photon(self, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        photon = ShootPhotonThroughFilter.get_photon(self, **kwargs)\n",
        "        photon.E_func = lambda x : np.exp(-0.25*(2*np.pi*x/photon.width)**2)\n",
        "        return photon\n",
        "\n",
        "class ClockwisePhotonInsert(Scene):\n",
        "    def construct(self):\n",
        "        eq = OldTex(\n",
        "            \"\\\\left| \\\\frac{-i}{\\\\sqrt{2}} \\\\right|^2\"\n",
        "        )\n",
        "        eq.set_color(BLUE)\n",
        "        VGroup(*it.chain(eq[:4], eq[-5:])).set_color(WHITE)\n",
        "        eq.set_height(FRAME_HEIGHT - 1)\n",
        "        eq.to_edge(LEFT)\n",
        "        self.add(eq)\n",
        "\n",
        "class OrClickHere(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Or click here\")\n",
        "        words.scale(3)\n",
        "        arrow = Vector(\n",
        "            2*UP + 2*RIGHT,\n",
        "            rectangular_stem_width = 0.1,\n",
        "            tip_length = 0.5\n",
        "        )\n",
        "        arrow.next_to(words, UP).shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class WavesPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Desmos\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Charlotte\",\n",
        "            \"Juan Batiz-Benet\",\n",
        "            \"Ali Yahya\",\n",
        "            \"William\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"James Park\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"dave nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Rose\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Harsev Singh\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Xueqi Li\",\n",
        "            \"David G. Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Michael McGuffin\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Footnote(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            \\\\begin{flushleft}\n",
        "            \\\\Large\n",
        "            By the way, in the quantum mechanical description\n",
        "            of polarization, states are written like \n",
        "            $|\\\\! \\\\leftrightarrow \\\\rangle$ with a double-headed\n",
        "            arrow, rather than $|\\\\! \\\\rightarrow \\\\rangle$ with\n",
        "            a single-headed arrow.  This conveys how there's no distinction\n",
        "            between left and right; they each have the same measurable \n",
        "            state: horizontal. \\\\\\\\\n",
        "            \\\\quad \\\\\\\\\n",
        "            Because of how I chose to motivate things with classical waves,\n",
        "            I'll stick with the single-headed $|\\\\! \\\\rightarrow \\\\rangle$\n",
        "            for this video, but just keep in mind that this differs\n",
        "            from quantum mechanics conventions.\n",
        "            \\\\end{flushleft}\n",
        "        \"\"\")\n",
        "        words.set_width(FRAME_WIDTH - 2)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}