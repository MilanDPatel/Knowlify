{
    "topic": "The mathematical concept being demonstrated is the relationship between the number of cases and the day of the week.",
    "code": [
        "from manim_imports_ext import *\n",
        "import scipy.stats\n",
        "\n",
        "\n",
        "CASE_DATA = [\n",
        "    9,\n",
        "    15,\n",
        "    30,\n",
        "    40,\n",
        "    56,\n",
        "    66,\n",
        "    84,\n",
        "    102,\n",
        "    131,\n",
        "    159,\n",
        "    173,\n",
        "    186,\n",
        "    190,\n",
        "    221,\n",
        "    248,\n",
        "    278,\n",
        "    330,\n",
        "    354,\n",
        "    382,\n",
        "    461,\n",
        "    481,\n",
        "    526,\n",
        "    587,\n",
        "    608,\n",
        "    697,\n",
        "    781,\n",
        "    896,\n",
        "    999,\n",
        "    1124,\n",
        "    1212,\n",
        "    1385,\n",
        "    1715,\n",
        "    2055,\n",
        "    2429,\n",
        "    2764,\n",
        "    3323,\n",
        "    4288,\n",
        "    5364,\n",
        "    6780,\n",
        "    8555,\n",
        "    10288,\n",
        "    12742,\n",
        "    14901,\n",
        "    17865,\n",
        "    21395,\n",
        "    # 25404,\n",
        "    # 29256,\n",
        "    # 33627,\n",
        "    # 38170,\n",
        "    # 45421,\n",
        "    # 53873,\n",
        "]\n",
        "SICKLY_GREEN = \"#9BBD37\"\n",
        "\n",
        "\n",
        "class IntroducePlot(Scene):\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        # Dots\n",
        "        dots = VGroup()\n",
        "        for day, nc in zip(it.count(1), CASE_DATA):\n",
        "            dot = Dot()\n",
        "            dot.set_height(0.075)\n",
        "            dot.x = day\n",
        "            dot.y = nc\n",
        "            dot.axes = axes\n",
        "            dot.add_updater(lambda d: d.move_to(d.axes.c2p(d.x, d.y)))\n",
        "            dots.add(dot)\n",
        "        dots.set_color(YELLOW)\n",
        "\n",
        "        # Rescale y axis\n",
        "        origin = axes.c2p(0, 0)\n",
        "        axes.y_axis.tick_marks.save_state()\n",
        "        for tick in axes.y_axis.tick_marks:\n",
        "            tick.match_width(axes.y_axis.tick_marks[0])\n",
        "        axes.y_axis.add(\n",
        "            axes.h_lines,\n",
        "            axes.small_h_lines,\n",
        "            axes.tiny_h_lines,\n",
        "            axes.tiny_ticks,\n",
        "        )\n",
        "        axes.y_axis.stretch(25, 1, about_point=origin)\n",
        "        dots.update()\n",
        "\n",
        "        self.add(axes.small_y_labels)\n",
        "        self.add(axes.tiny_y_labels)\n",
        "\n",
        "        # Add title\n",
        "        title = self.get_title(axes)\n",
        "        self.add(title)\n",
        "\n",
        "        # Introduce the data\n",
        "        day = 10\n",
        "        self.add(*dots[:day + 1])\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.match_style(dots[day])\n",
        "        dot.replace(dots[day])\n",
        "        count = Integer(CASE_DATA[day])\n",
        "        count.add_updater(lambda m: m.next_to(dot, UP))\n",
        "        count.add_updater(lambda m: m.set_stroke(BLACK, 5, background=True))\n",
        "\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.set_stroke(YELLOW, 1)\n",
        "        v_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                axes.c2p(\n",
        "                    axes.x_axis.p2n(dot.get_center()),\n",
        "                    0,\n",
        "                ),\n",
        "                dot.get_bottom(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(dot)\n",
        "        self.add(count)\n",
        "        self.add(v_line)\n",
        "\n",
        "        for new_day in range(day + 1, len(dots)):\n",
        "            new_dot = dots[new_day]\n",
        "            new_dot.update()\n",
        "            line = Line(dot.get_center(), new_dot.get_center())\n",
        "            line.set_stroke(PINK, 3)\n",
        "\n",
        "            self.add(line, dot)\n",
        "            self.play(\n",
        "                dot.move_to, new_dot.get_center(),\n",
        "                dot.set_color, RED,\n",
        "                ChangeDecimalToValue(count, CASE_DATA[new_day]),\n",
        "                ShowCreation(line),\n",
        "            )\n",
        "            line.rotate(PI)\n",
        "            self.play(\n",
        "                dot.set_color, YELLOW,\n",
        "                Uncreate(line),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.add(dots[new_day])\n",
        "\n",
        "            day = new_day\n",
        "\n",
        "            if day == 27:\n",
        "                self.add(\n",
        "                    axes.y_axis, axes.tiny_y_labels, axes.tiny_h_lines, axes.tiny_ticks,\n",
        "                    title\n",
        "                )\n",
        "                self.play(\n",
        "                    axes.y_axis.stretch, 0.2, 1, {\"about_point\": origin},\n",
        "                    VFadeOut(axes.tiny_y_labels),\n",
        "                    VFadeOut(axes.tiny_h_lines),\n",
        "                    VFadeOut(axes.tiny_ticks),\n",
        "                    MaintainPositionRelativeTo(dot, dots[new_day]),\n",
        "                    run_time=2,\n",
        "                )\n",
        "                self.add(axes, title, *dots[:new_day])\n",
        "            if day == 36:\n",
        "                self.add(axes.y_axis, axes.small_y_labels, axes.small_h_lines, title)\n",
        "                self.play(\n",
        "                    axes.y_axis.stretch, 0.2, 1, {\"about_point\": origin},\n",
        "                    VFadeOut(axes.small_y_labels),\n",
        "                    VFadeOut(axes.small_h_lines),\n",
        "                    MaintainPositionRelativeTo(dot, dots[new_day]),\n",
        "                    run_time=2,\n",
        "                )\n",
        "                self.add(axes, title, *dots[:new_day])\n",
        "\n",
        "        count.add_background_rectangle()\n",
        "        count.background_rectangle.stretch(1.1, 0)\n",
        "        self.add(count)\n",
        "\n",
        "        # Show multiplications\n",
        "        last_label = VectorizedPoint(dots[25].get_center())\n",
        "        last_line = VMobject()\n",
        "        for d1, d2 in zip(dots[25:], dots[26:]):\n",
        "            line = Line(\n",
        "                d1.get_top(),\n",
        "                d2.get_corner(UL),\n",
        "                path_arc=-90 * DEGREES,\n",
        "            )\n",
        "            line.set_stroke(PINK, 2)\n",
        "\n",
        "            label = VGroup(\n",
        "                OldTex(\"\\\\times\"),\n",
        "                DecimalNumber(\n",
        "                    axes.y_axis.p2n(d2.get_center()) /\n",
        "                    axes.y_axis.p2n(d1.get_center()),\n",
        "                )\n",
        "            )\n",
        "            label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            label.set_height(0.25)\n",
        "            label.next_to(line.point_from_proportion(0.5), UL, SMALL_BUFF)\n",
        "            label.match_color(line)\n",
        "            label.add_background_rectangle()\n",
        "            label.save_state()\n",
        "            label.move_to(last_label)\n",
        "            label.set_opacity(0)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Restore(label),\n",
        "                last_label.move_to, label.saved_state,\n",
        "                VFadeOut(last_label),\n",
        "                FadeOut(last_line),\n",
        "            )\n",
        "            last_line = line\n",
        "            last_label = label\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(last_label),\n",
        "            FadeOut(last_line),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_title(self, axes):\n",
        "        title = OldTexText(\n",
        "            \"Recorded COVID-19 cases\\\\\\\\outside mainland China\",\n",
        "            tex_to_color_map={\"COVID-19\": RED}\n",
        "        )\n",
        "        title.next_to(axes.c2p(0, 1e3), RIGHT, LARGE_BUFF)\n",
        "        title.to_edge(UP)\n",
        "        title.add_background_rectangle()\n",
        "        return title\n",
        "\n",
        "    def get_axes(self, width=12, height=6):\n",
        "        n_cases = len(CASE_DATA)\n",
        "        axes = Axes(\n",
        "            x_range=(0, n_cases),\n",
        "            y_range=(0, 25000, 1000),\n",
        "            width=width,\n",
        "            height=height,\n",
        "        )\n",
        "        axes.center()\n",
        "        axes.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        # Add dates\n",
        "        text_pos_pairs = [\n",
        "            (\"Mar 6\", 0),\n",
        "            (\"Feb 23\", -12),\n",
        "            (\"Feb 12\", -23),\n",
        "            (\"Feb 1\", -34),\n",
        "            (\"Jan 22\", -44),\n",
        "        ]\n",
        "        labels = VGroup()\n",
        "        extra_ticks = VGroup()\n",
        "        for text, pos in text_pos_pairs:\n",
        "            label = OldTexText(text)\n",
        "            label.set_height(0.2)\n",
        "            label.rotate(45 * DEGREES)\n",
        "            axis_point = axes.c2p(n_cases + pos, 0)\n",
        "            label.move_to(axis_point, UR)\n",
        "            label.shift(MED_SMALL_BUFF * DOWN)\n",
        "            label.shift(SMALL_BUFF * RIGHT)\n",
        "            labels.add(label)\n",
        "\n",
        "            tick = Line(UP, DOWN)\n",
        "            tick.set_stroke(GREEN, 3)\n",
        "            tick.set_height(0.25)\n",
        "            tick.move_to(axis_point)\n",
        "            extra_ticks.add(tick)\n",
        "\n",
        "        axes.x_labels = labels\n",
        "        axes.extra_x_ticks = extra_ticks\n",
        "        axes.add(labels, extra_ticks)\n",
        "\n",
        "        # Adjust y ticks\n",
        "        axes.y_axis.ticks.stretch(0.5, 0)\n",
        "        axes.y_axis.ticks[0::5].stretch(2, 0)\n",
        "\n",
        "        # Add y_axis_labels\n",
        "        def get_y_labels(axes, y_values):\n",
        "            labels = VGroup()\n",
        "            for y in y_values:\n",
        "                try:\n",
        "                    label = OldTexText(f\"{y}k\")\n",
        "                    label.set_height(0.25)\n",
        "                    tick = axes.y_axis.ticks[y]\n",
        "                    always(label.next_to, tick, LEFT, SMALL_BUFF)\n",
        "                    labels.add(label)\n",
        "                except IndexError:\n",
        "                    pass\n",
        "            return labels\n",
        "\n",
        "        main_labels = get_y_labels(axes, range(5, 30, 5))\n",
        "        axes.y_labels = main_labels\n",
        "        axes.add(main_labels)\n",
        "        axes.small_y_labels = get_y_labels(axes, range(1, 6))\n",
        "\n",
        "        tiny_labels = VGroup()\n",
        "        tiny_ticks = VGroup()\n",
        "        for y in range(200, 1000, 200):\n",
        "            tick = axes.y_axis.ticks[0].copy()\n",
        "            point = axes.c2p(0, y)\n",
        "            tick.move_to(point)\n",
        "            label = Integer(y)\n",
        "            label.set_height(0.25)\n",
        "            always(label.next_to, tick, LEFT, SMALL_BUFF)\n",
        "            tiny_labels.add(label)\n",
        "            tiny_ticks.add(tick)\n",
        "\n",
        "        axes.tiny_y_labels = tiny_labels\n",
        "        axes.tiny_ticks = tiny_ticks\n",
        "\n",
        "        # Horizontal lines\n",
        "        axes.h_lines = VGroup()\n",
        "        axes.small_h_lines = VGroup()\n",
        "        axes.tiny_h_lines = VGroup()\n",
        "        group_range_pairs = [\n",
        "            (axes.h_lines, 5e3 * np.arange(1, 6)),\n",
        "            (axes.small_h_lines, 1e3 * np.arange(1, 5)),\n",
        "            (axes.tiny_h_lines, 200 * np.arange(1, 5)),\n",
        "        ]\n",
        "        for group, _range in group_range_pairs:\n",
        "            for y in _range:\n",
        "                group.add(\n",
        "                    Line(\n",
        "                        axes.c2p(0, y),\n",
        "                        axes.c2p(n_cases, y),\n",
        "                    )\n",
        "                )\n",
        "            group.set_stroke(WHITE, 1, opacity=0.5)\n",
        "\n",
        "        return axes\n",
        "\n",
        "\n",
        "class Thumbnail(IntroducePlot):\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        dots = VGroup()\n",
        "        data = CASE_DATA\n",
        "        data.append(25398)\n",
        "        for day, nc in zip(it.count(1), CASE_DATA):\n",
        "            dot = Dot()\n",
        "            dot.set_height(0.2)\n",
        "            dot.x = day\n",
        "            dot.y = nc\n",
        "            dot.axes = axes\n",
        "            dot.add_updater(lambda d: d.move_to(d.axes.c2p(d.x, d.y)))\n",
        "            dots.add(dot)\n",
        "        dots.set_color(YELLOW)\n",
        "        dots.set_submobject_colors_by_gradient(BLUE, GREEN, RED)\n",
        "\n",
        "        self.add(dots)\n",
        "\n",
        "        title = OldTexText(\"COVID-19\")\n",
        "        title.set_height(1)\n",
        "        title.set_color(RED)\n",
        "        title.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        subtitle = OldTexText(\"and exponential growth\")\n",
        "        subtitle.match_width(title)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "\n",
        "        # self.add(title)\n",
        "        # self.add(subtitle)\n",
        "\n",
        "        title = OldTexText(\"The early warning\\\\\\\\of \", \"COVID-19\\\\\\\\\")\n",
        "        title.set_color_by_tex(\"COVID\", RED)\n",
        "        title.set_height(2.5)\n",
        "        title.to_edge(UP, buff=LARGE_BUFF)\n",
        "        self.add(title)\n",
        "\n",
        "        # self.remove(words)\n",
        "        # words = OldTexText(\"Exponential growth\")\n",
        "        # words.move_to(ORIGIN, DL)\n",
        "        # words.apply_function(\n",
        "        #     lambda p: [\n",
        "        #         p[0], p[1] + np.exp(0.2 * p[0]), p[2]\n",
        "        #     ]\n",
        "        # )\n",
        "        # self.add(words)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class IntroQuestion(Scene):\n",
        "    def construct(self):\n",
        "        questions = VGroup(\n",
        "            OldTexText(\"What is exponential growth?\"),\n",
        "            OldTexText(\"Where does it come from?\"),\n",
        "            OldTexText(\"What does it imply?\"),\n",
        "            OldTexText(\"When does it stop?\"),\n",
        "        )\n",
        "        questions.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        for question in questions:\n",
        "            self.play(FadeIn(question, RIGHT))\n",
        "            self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOutAndShift, questions,\n",
        "            lambda m: (m, DOWN),\n",
        "        ))\n",
        "\n",
        "\n",
        "class ViralSpreadModel(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_neighbors\": 5,\n",
        "        \"infection_probability\": 0.3,\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Init population\n",
        "        randys = self.get_randys()\n",
        "        self.add(*randys)\n",
        "\n",
        "        # Show the sicko\n",
        "        self.show_patient0(randys)\n",
        "\n",
        "        # Repeatedly spread\n",
        "        for x in range(20):\n",
        "            self.spread_infection(randys)\n",
        "\n",
        "    def get_randys(self):\n",
        "        randys = VGroup(*[\n",
        "            Randolph()\n",
        "            for x in range(150)\n",
        "        ])\n",
        "        for randy in randys:\n",
        "            randy.set_height(0.5)\n",
        "        randys.arrange_in_grid(10, 15, buff=0.5)\n",
        "        randys.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        for i in range(0, 10, 2):\n",
        "            randys[i * 15:(i + 1) * 15].shift(0.25 * RIGHT)\n",
        "        for randy in randys:\n",
        "            randy.shift(0.2 * random.random() * RIGHT)\n",
        "            randy.shift(0.2 * random.random() * UP)\n",
        "            randy.infected = False\n",
        "        randys.center()\n",
        "        return randys\n",
        "\n",
        "    def show_patient0(self, randys):\n",
        "        patient0 = random.choice(randys)\n",
        "        patient0.infected = True\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(SICKLY_GREEN)\n",
        "        circle.replace(patient0)\n",
        "        circle.scale(1.5)\n",
        "        self.play(\n",
        "            patient0.change, \"sick\",\n",
        "            patient0.set_color, SICKLY_GREEN,\n",
        "            ShowCreationThenFadeOut(circle),\n",
        "        )\n",
        "\n",
        "    def spread_infection(self, randys):\n",
        "        E = self.num_neighbors\n",
        "        inf_p = self.infection_probability\n",
        "\n",
        "        cough_anims = []\n",
        "        new_infection_anims = []\n",
        "\n",
        "        for randy in randys:\n",
        "            if randy.infected:\n",
        "                cough_anims.append(Flash(\n",
        "                    randy,\n",
        "                    color=SICKLY_GREEN,\n",
        "                    num_lines=16,\n",
        "                    line_stroke_width=1,\n",
        "                    flash_radius=0.5,\n",
        "                    line_length=0.1,\n",
        "                ))\n",
        "        random.shuffle(cough_anims)\n",
        "        self.play(LaggedStart(\n",
        "            *cough_anims,\n",
        "            run_time=1,\n",
        "            lag_ratio=1 / len(cough_anims),\n",
        "        ))\n",
        "\n",
        "        newly_infected = []\n",
        "        for randy in randys:\n",
        "            if randy.infected:\n",
        "                distances = [\n",
        "                    get_norm(r2.get_center() - randy.get_center())\n",
        "                    for r2 in randys\n",
        "                ]\n",
        "                for i in np.argsort(distances)[1:E + 1]:\n",
        "                    r2 = randys[i]\n",
        "                    if random.random() < inf_p and not r2.infected and r2 not in newly_infected:\n",
        "                        newly_infected.append(r2)\n",
        "                        r2.generate_target()\n",
        "                        r2.target.change(\"sick\")\n",
        "                        r2.target.set_color(SICKLY_GREEN)\n",
        "                        new_infection_anims.append(MoveToTarget(r2))\n",
        "        random.shuffle(new_infection_anims)\n",
        "        self.play(LaggedStart(*new_infection_anims, run_time=1))\n",
        "\n",
        "        for randy in newly_infected:\n",
        "            randy.infected = True\n",
        "\n",
        "\n",
        "class GrowthEquation(Scene):\n",
        "    def construct(self):\n",
        "        # Add labels\n",
        "        N_label = OldTexText(\"$N_d$\", \" = Number of cases on a given day\", )\n",
        "        E_label = OldTexText(\"$E$\", \" = Average number of people someone infected is exposed to each day\")\n",
        "        p_label = OldTexText(\"$p$\", \" = Probability of each exposure becoming an infection\")\n",
        "\n",
        "        N_label[0].set_color(YELLOW)\n",
        "        E_label[0].set_color(BLUE)\n",
        "        p_label[0].set_color(TEAL)\n",
        "\n",
        "        labels = VGroup(\n",
        "            N_label,\n",
        "            E_label,\n",
        "            p_label\n",
        "        )\n",
        "        labels.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        labels.set_width(FRAME_WIDTH - 1)\n",
        "        labels.to_edge(UP)\n",
        "\n",
        "        for label in labels:\n",
        "            self.play(FadeInFromDown(label))\n",
        "            self.wait()\n",
        "\n",
        "        delta_N = OldTex(\"\\\\Delta\", \"N_d\")\n",
        "        delta_N.set_color(YELLOW)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.center()\n",
        "        delta_N.next_to(eq, LEFT)\n",
        "\n",
        "        delta_N_brace = Brace(delta_N, DOWN)\n",
        "        delta_N_text = delta_N_brace.get_text(\"Change over a day\")\n",
        "\n",
        "        nep = OldTex(\"E\", \"\\\\cdot\", \"p\", \"\\\\cdot\", \"N_d\")\n",
        "        nep[4].match_color(N_label[0])\n",
        "        nep[0].match_color(E_label[0])\n",
        "        nep[2].match_color(p_label[0])\n",
        "        nep.next_to(eq, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(delta_N), FadeIn(eq))\n",
        "        self.play(\n",
        "            GrowFromCenter(delta_N_brace),\n",
        "            FadeIn(delta_N_text, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(N_label[0], nep[4]),\n",
        "            TransformFromCopy(E_label[0], nep[0]),\n",
        "            TransformFromCopy(p_label[0], nep[2]),\n",
        "            FadeIn(nep[1]),\n",
        "            FadeIn(nep[3]),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            nep[-1],\n",
        "            surrounding_rectangle_config={\"color\": RED},\n",
        "        ))\n",
        "\n",
        "        # Recursive equation\n",
        "        lhs = OldTex(\"N_{d + 1}\", \"=\")\n",
        "        lhs[0].set_color(YELLOW)\n",
        "        lhs.move_to(eq, RIGHT)\n",
        "        lhs.shift(DOWN)\n",
        "\n",
        "        rhs = VGroup(\n",
        "            nep[-1].copy(),\n",
        "            OldTex(\"+\"),\n",
        "            nep.copy(),\n",
        "        )\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(delta_N_brace),\n",
        "            FadeOut(delta_N_text),\n",
        "            FadeIn(lhs, UP),\n",
        "        )\n",
        "        self.play(FadeIn(rhs[:2]))\n",
        "        self.play(TransformFromCopy(nep, rhs[2]))\n",
        "        self.wait()\n",
        "\n",
        "        alt_rhs = OldTex(\n",
        "            \"(\", \"1\", \"+\", \"E\", \"\\\\cdot\", \"p\", \")\", \"N_d\",\n",
        "            tex_to_color_map={\n",
        "                \"E\": BLUE,\n",
        "                \"p\": TEAL,\n",
        "                \"N_d\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        new_lhs = lhs.copy()\n",
        "        new_lhs.shift(DOWN)\n",
        "        alt_rhs.next_to(new_lhs, RIGHT)\n",
        "        self.play(TransformFromCopy(lhs, new_lhs))\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs[0], alt_rhs[7].copy()),\n",
        "            TransformFromCopy(rhs[2][4], alt_rhs[7]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs[1][0], alt_rhs[2]),\n",
        "            TransformFromCopy(rhs[2][0], alt_rhs[3]),\n",
        "            TransformFromCopy(rhs[2][1], alt_rhs[4]),\n",
        "            TransformFromCopy(rhs[2][2], alt_rhs[5]),\n",
        "            TransformFromCopy(rhs[2][3], alt_rhs[6]),\n",
        "            FadeIn(alt_rhs[0]),\n",
        "            FadeIn(alt_rhs[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on factor\n",
        "        brace = Brace(alt_rhs[:7], DOWN)\n",
        "        text = OldTexText(\"For example, \", \"1.15\")\n",
        "        text.next_to(brace, DOWN)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(text, 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show exponential\n",
        "        eq_group = VGroup(\n",
        "            delta_N, eq, nep,\n",
        "            lhs, rhs,\n",
        "            new_lhs, alt_rhs,\n",
        "            brace,\n",
        "            text,\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(labels, eq_group)\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            VGroup(delta_N, eq, nep),\n",
        "            surrounding_rectangle_config={\"color\": RED},\n",
        "        ))\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            VGroup(new_lhs, alt_rhs, brace, text),\n",
        "            surrounding_rectangle_config={\"color\": RED},\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(eq_group.to_edge, LEFT, LARGE_BUFF)\n",
        "\n",
        "        exp_eq = OldTex(\n",
        "            \"N_d = (1 + E \\\\cdot p)^{d} \\\\cdot N_0\",\n",
        "            tex_to_color_map={\n",
        "                \"N_d\": YELLOW,\n",
        "                \"E\": BLUE,\n",
        "                \"p\": TEAL,\n",
        "                \"{d}\": YELLOW,\n",
        "                \"N_0\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        exp_eq.next_to(alt_rhs, RIGHT, buff=3)\n",
        "        arrow = Arrow(alt_rhs.get_right(), exp_eq.get_left())\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(exp_eq, 2 * LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Discuss factor in front of N\n",
        "        ep = nep[:3]\n",
        "        ep_rect = SurroundingRectangle(ep)\n",
        "        ep_rect.set_stroke(RED, 2)\n",
        "\n",
        "        ep_label = OldTexText(\"This factor will decrease\")\n",
        "        ep_label.next_to(ep_rect, UP, aligned_edge=LEFT)\n",
        "        ep_label.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ep_rect),\n",
        "            FadeIn(ep_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(ep_rect),\n",
        "            FadeOut(ep_label),\n",
        "        )\n",
        "\n",
        "        # Add carrying capacity factor to p\n",
        "        p_factors = OldTex(\n",
        "            \"\\\\left(1 - {N_d \\\\over \\\\text{pop. size}} \\\\right)\",\n",
        "            tex_to_color_map={\"N_d\": YELLOW},\n",
        "        )\n",
        "        p_factors.next_to(nep, RIGHT, buff=3)\n",
        "        p_factors_rect = SurroundingRectangle(p_factors)\n",
        "        p_factors_rect.set_stroke(TEAL, 2)\n",
        "        p_arrow = Arrow(\n",
        "            p_factors_rect.get_corner(UL),\n",
        "            nep[2].get_top(),\n",
        "            path_arc=75 * DEGREES,\n",
        "            color=TEAL,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(p_factors_rect),\n",
        "            ShowCreation(p_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(p_factors))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(p_factors),\n",
        "            FadeOut(p_arrow),\n",
        "            FadeOut(p_factors_rect),\n",
        "        )\n",
        "\n",
        "        # Ask about ep shrinking\n",
        "        ep_question = OldTexText(\"What makes this shrink?\")\n",
        "        ep_question.set_color(RED)\n",
        "        ep_question.next_to(ep_rect, UP, aligned_edge=LEFT)\n",
        "\n",
        "        E_line = Underline(E_label)\n",
        "        E_line.set_color(BLUE)\n",
        "        p_line = Underline(p_label)\n",
        "        p_line.set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ep_rect),\n",
        "            FadeIn(ep_question, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        for line in E_line, p_line:\n",
        "            self.play(ShowCreation(line))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(line))\n",
        "        self.wait()\n",
        "\n",
        "        # Show alternate projections\n",
        "        ep_value = DecimalNumber(0.15)\n",
        "        ep_value.next_to(ep_rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(ep_question),\n",
        "            FadeIn(ep_value),\n",
        "            FadeOut(text[0]),\n",
        "            text[1].next_to, brace, DOWN,\n",
        "        )\n",
        "\n",
        "        eq1 = OldTex(\"(\", \"1.15\", \")\", \"^{61}\", \"\\\\cdot\", \"21{,}000\", \"=\")\n",
        "        eq2 = OldTex(\"(\", \"1.05\", \")\", \"^{61}\", \"\\\\cdot\", \"21{,}000\", \"=\")\n",
        "        eq1_rhs = Integer((1.15**61) * (21000))\n",
        "        eq2_rhs = Integer((1.05**61) * (21000))\n",
        "\n",
        "        for eq, rhs in (eq1, eq1_rhs), (eq2, eq2_rhs):\n",
        "            eq[1].set_color(RED)\n",
        "            eq.move_to(nep)\n",
        "            eq.to_edge(RIGHT, buff=3)\n",
        "            rhs.next_to(eq, RIGHT)\n",
        "            rhs.align_to(eq[-2], UP)\n",
        "\n",
        "        self.play(FadeIn(eq1))\n",
        "        for tex in [\"21{,}000\", \"61\"]:\n",
        "            self.play(ShowCreationThenFadeOut(\n",
        "                Underline(\n",
        "                    eq1.get_part_by_tex(tex),\n",
        "                    stroke_color=YELLOW,\n",
        "                    stroke_width=2,\n",
        "                    buff=SMALL_BUFF,\n",
        "                ),\n",
        "                run_time=2,\n",
        "            ))\n",
        "        value = eq1_rhs.get_value()\n",
        "        eq1_rhs.set_value(0)\n",
        "        self.play(ChangeDecimalToValue(eq1_rhs, value))\n",
        "        self.wait()\n",
        "        eq1.add(eq1_rhs)\n",
        "        self.play(\n",
        "            eq1.shift, DOWN,\n",
        "            FadeIn(eq2),\n",
        "        )\n",
        "\n",
        "        new_text = OldTexText(\"1.05\")\n",
        "        new_text.move_to(text[1])\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(ep_value, 0.05),\n",
        "            FadeOut(text[1]),\n",
        "            FadeIn(new_text),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        eq2_rhs.align_to(eq1_rhs, RIGHT)\n",
        "        value = eq2_rhs.get_value()\n",
        "        eq2_rhs.set_value(0)\n",
        "        self.play(ChangeDecimalToValue(eq2_rhs, value))\n",
        "        self.wait()\n",
        "\n",
        "        # Pi creature quote\n",
        "        morty = Mortimer()\n",
        "        morty.set_height(1)\n",
        "        morty.next_to(eq2_rhs, UP)\n",
        "        bubble = SpeechBubble(\n",
        "            direction=RIGHT,\n",
        "            height=2.5,\n",
        "            width=5,\n",
        "        )\n",
        "        bubble.next_to(morty, UL, buff=0)\n",
        "        bubble.write(\"The only thing to fear\\\\\\\\is the lack of fear itself.\")\n",
        "\n",
        "        self.add(morty)\n",
        "        self.add(bubble)\n",
        "        self.add(bubble.content)\n",
        "\n",
        "        self.play(\n",
        "            labels.set_opacity, 0.5,\n",
        "            VFadeIn(morty),\n",
        "            morty.change, \"speaking\",\n",
        "            FadeIn(bubble),\n",
        "            Write(bubble.content),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RescaleToLogarithmic(IntroducePlot):\n",
        "    def construct(self):\n",
        "        # Setup axes\n",
        "        axes = self.get_axes(width=10)\n",
        "        title = self.get_title(axes)\n",
        "\n",
        "        dots = VGroup()\n",
        "        for day, nc in zip(it.count(1), CASE_DATA):\n",
        "            dot = Dot()\n",
        "            dot.set_height(0.075)\n",
        "            dot.move_to(axes.c2p(day, nc))\n",
        "            dots.add(dot)\n",
        "        dots.set_color(YELLOW)\n",
        "\n",
        "        self.add(axes, axes.h_lines, dots, title)\n",
        "\n",
        "        # Create logarithmic y axis\n",
        "        log_y_axis = NumberLine(\n",
        "            x_min=0,\n",
        "            x_max=9,\n",
        "        )\n",
        "        log_y_axis.rotate(90 * DEGREES)\n",
        "        log_y_axis.move_to(axes.c2p(0, 0), DOWN)\n",
        "\n",
        "        labels_text = [\n",
        "            \"10\", \"100\",\n",
        "            \"1k\", \"10k\", \"100k\",\n",
        "            \"1M\", \"10M\", \"100M\",\n",
        "            \"1B\",\n",
        "        ]\n",
        "        log_y_labels = VGroup()\n",
        "        for text, tick in zip(labels_text, log_y_axis.tick_marks[1:]):\n",
        "            label = OldTexText(text)\n",
        "            label.set_height(0.25)\n",
        "            always(label.next_to, tick, LEFT, SMALL_BUFF)\n",
        "            log_y_labels.add(label)\n",
        "\n",
        "        # Animate the rescaling to a logarithmic plot\n",
        "        logarithm_title = OldTexText(\"(Logarithmic scale)\")\n",
        "        logarithm_title.set_color(TEAL)\n",
        "        logarithm_title.next_to(title, DOWN)\n",
        "        logarithm_title.add_background_rectangle()\n",
        "\n",
        "        def scale_logarithmically(p):\n",
        "            result = np.array(p)\n",
        "            y = axes.y_axis.p2n(p)\n",
        "            result[1] = log_y_axis.n2p(np.log10(y))[1]\n",
        "            return result\n",
        "\n",
        "        log_h_lines = VGroup()\n",
        "        for exponent in range(0, 9):\n",
        "            for mult in range(2, 12, 2):\n",
        "                y = mult * 10**exponent\n",
        "                line = Line(\n",
        "                    axes.c2p(0, y),\n",
        "                    axes.c2p(axes.x_max, y),\n",
        "                )\n",
        "                log_h_lines.add(line)\n",
        "        log_h_lines.set_stroke(WHITE, 0.5, opacity=0.5)\n",
        "        log_h_lines[4::5].set_stroke(WHITE, 1, opacity=1)\n",
        "\n",
        "        movers = [dots, axes.y_axis.tick_marks, axes.h_lines, log_h_lines]\n",
        "        for group in movers:\n",
        "            group.generate_target()\n",
        "            for mob in group.target:\n",
        "                mob.move_to(scale_logarithmically(mob.get_center()))\n",
        "\n",
        "        log_y_labels.suspend_updating()\n",
        "        log_y_labels.save_state()\n",
        "        for exponent, label in zip(it.count(1), log_y_labels):\n",
        "            label.set_y(axes.y_axis.n2p(10**exponent)[1])\n",
        "            label.set_opacity(0)\n",
        "\n",
        "        self.add(log_y_axis)\n",
        "        log_y_axis.save_state()\n",
        "        log_y_axis.tick_marks.set_opacity(0)\n",
        "        log_h_lines.set_opacity(0)\n",
        "        self.wait()\n",
        "        self.add(log_h_lines, title, logarithm_title)\n",
        "        self.play(\n",
        "            MoveToTarget(dots),\n",
        "            MoveToTarget(axes.y_axis.tick_marks),\n",
        "            MoveToTarget(axes.h_lines),\n",
        "            MoveToTarget(log_h_lines),\n",
        "            VFadeOut(axes.y_labels),\n",
        "            VFadeOut(axes.y_axis.tick_marks),\n",
        "            VFadeOut(axes.h_lines),\n",
        "            Restore(log_y_labels),\n",
        "            FadeIn(logarithm_title),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Restore(log_y_axis))\n",
        "        self.wait()\n",
        "\n",
        "        # Walk up y axis\n",
        "        brace = Brace(\n",
        "            log_y_axis.tick_marks[1:3],\n",
        "            RIGHT,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        brace_label = brace.get_tex(\n",
        "            \"\\\\times 10\",\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "        VGroup(brace, brace_label).set_color(TEAL)\n",
        "        brace_label.set_stroke(BLACK, 8, background=True)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_label)\n",
        "        )\n",
        "        brace.add(brace_label)\n",
        "        for i in range(2, 5):\n",
        "            self.play(\n",
        "                brace.next_to,\n",
        "                log_y_axis.tick_marks[i:i + 2],\n",
        "                {\"buff\": SMALL_BUFF}\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(FadeOut(brace))\n",
        "        self.wait()\n",
        "\n",
        "        # Show order of magnitude jumps\n",
        "        remove_anims = []\n",
        "        for i, j in [(7, 27), (27, 40)]:\n",
        "            line = Line(dots[i].get_center(), dots[j].get_center())\n",
        "            rect = Rectangle()\n",
        "            rect.set_fill(TEAL, 0.5)\n",
        "            rect.set_stroke(width=0)\n",
        "            rect.replace(line, stretch=True)\n",
        "            label = OldTexText(f\"{j - i} days\")\n",
        "            label.next_to(rect, UP, SMALL_BUFF)\n",
        "            label.set_color(TEAL)\n",
        "\n",
        "            rect.save_state()\n",
        "            rect.stretch(0, 0, about_edge=LEFT)\n",
        "            self.play(\n",
        "                Restore(rect),\n",
        "                FadeIn(label, LEFT)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            remove_anims += [\n",
        "                ApplyMethod(\n",
        "                    rect.stretch, 0, 0, {\"about_edge\": RIGHT},\n",
        "                    remover=True,\n",
        "                ),\n",
        "                FadeOut(label, RIGHT),\n",
        "            ]\n",
        "        self.wait()\n",
        "\n",
        "        # Linear regression\n",
        "        def c2p(x, y):\n",
        "            xp = axes.x_axis.n2p(x)\n",
        "            yp = log_y_axis.n2p(np.log10(y))\n",
        "            return np.array([xp[0], yp[1], 0])\n",
        "\n",
        "        reg = scipy.stats.linregress(\n",
        "            range(7, len(CASE_DATA)),\n",
        "            np.log10(CASE_DATA[7:])\n",
        "        )\n",
        "        x_max = axes.x_max\n",
        "        axes.y_axis = log_y_axis\n",
        "        reg_line = Line(\n",
        "            c2p(0, 10**reg.intercept),\n",
        "            c2p(x_max, 10**(reg.intercept + reg.slope * x_max)),\n",
        "        )\n",
        "        reg_line.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.add(reg_line, dots)\n",
        "        dots.set_stroke(BLACK, 3, background=True)\n",
        "        self.play(\n",
        "            LaggedStart(*remove_anims),\n",
        "            ShowCreation(reg_line)\n",
        "        )\n",
        "\n",
        "        # Describe linear regression\n",
        "        reg_label = OldTexText(\"Linear regression\")\n",
        "        reg_label.move_to(c2p(25, 10), DOWN)\n",
        "        reg_arrows = VGroup()\n",
        "        for prop in [0.4, 0.6, 0.5]:\n",
        "            reg_arrows.add(\n",
        "                Arrow(\n",
        "                    reg_label.get_top(),\n",
        "                    reg_line.point_from_proportion(prop),\n",
        "                    buff=SMALL_BUFF,\n",
        "                )\n",
        "            )\n",
        "\n",
        "        reg_arrow = reg_arrows[0].copy()\n",
        "        self.play(\n",
        "            Write(reg_label, run_time=1),\n",
        "            Transform(reg_arrow, reg_arrows[1], run_time=2),\n",
        "            VFadeIn(reg_arrow),\n",
        "        )\n",
        "        self.play(Transform(reg_arrow, reg_arrows[2]))\n",
        "        self.wait()\n",
        "\n",
        "        # Label slope\n",
        "        slope_label = OldTexText(\"$\\\\times 10$ every $16$ days (on average)\")\n",
        "        slope_label.set_color(BLUE)\n",
        "        slope_label.set_stroke(BLACK, 8, background=True)\n",
        "        slope_label.rotate(reg_line.get_angle())\n",
        "        slope_label.move_to(reg_line.get_center())\n",
        "        slope_label.shift(MED_LARGE_BUFF * UP)\n",
        "\n",
        "        self.play(FadeIn(slope_label, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # R^2 label\n",
        "        R2_label = VGroup(\n",
        "            OldTex(\"R^2 = \"),\n",
        "            DecimalNumber(0, num_decimal_places=3)\n",
        "        )\n",
        "        R2_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        R2_label.next_to(reg_label[0][-1], RIGHT, LARGE_BUFF, aligned_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(R2_label[1], reg.rvalue**2, run_time=2),\n",
        "            UpdateFromAlphaFunc(\n",
        "                R2_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(R2_label, buff=0.15)\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "        rect.set_fill(BLACK, 0)\n",
        "        self.add(rect, R2_label)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            rect.set_stroke, WHITE, 2,\n",
        "            rect.set_fill, GREY_E, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            FadeOut(R2_label),\n",
        "            FadeOut(reg_label),\n",
        "            FadeOut(reg_arrow),\n",
        "        )\n",
        "\n",
        "        # Zoom out\n",
        "        extended_x_axis = NumberLine(\n",
        "            x_min=axes.x_axis.x_max,\n",
        "            x_max=axes.x_axis.x_max + 90,\n",
        "            unit_size=get_norm(\n",
        "                axes.x_axis.n2p(1) -\n",
        "                axes.x_axis.n2p(0)\n",
        "            ),\n",
        "            big_tick_numbers=[],\n",
        "        )\n",
        "        extended_x_axis.move_to(axes.x_axis.get_right(), LEFT)\n",
        "        self.play(\n",
        "            self.camera.frame.scale, 2, {\"about_edge\": DL},\n",
        "            self.camera.frame.shift, 2.5 * DOWN + RIGHT,\n",
        "            log_h_lines.stretch, 3, 0, {\"about_edge\": LEFT},\n",
        "            ShowCreation(extended_x_axis, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            reg_line.scale, 3, {\"about_point\": reg_line.get_start()}\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show future projections\n",
        "        target_ys = [1e6, 1e7, 1e8, 1e9]\n",
        "        last_point = dots[-1].get_center()\n",
        "        last_label = None\n",
        "        last_rect = None\n",
        "\n",
        "        date_labels_text = [\n",
        "            \"Apr 5\",\n",
        "            \"Apr 22\",\n",
        "            \"May 9\",\n",
        "            \"May 26\",\n",
        "        ]\n",
        "\n",
        "        for target_y, date_label_text in zip(target_ys, date_labels_text):\n",
        "            log_y = np.log10(target_y)\n",
        "            x = (log_y - reg.intercept) / reg.slope\n",
        "            line = Line(last_point, c2p(x, target_y))\n",
        "            rect = Rectangle().replace(line, stretch=True)\n",
        "            rect.set_stroke(width=0)\n",
        "            rect.set_fill(TEAL, 0.5)\n",
        "            label = OldTexText(f\"{int(x) - axes.x_max} days\")\n",
        "            label.scale(1.5)\n",
        "            label.next_to(rect, UP, SMALL_BUFF)\n",
        "\n",
        "            date_label = OldTexText(date_label_text)\n",
        "            date_label.set_height(0.25)\n",
        "            date_label.rotate(45 * DEGREES)\n",
        "            axis_point = axes.c2p(int(x), 0)\n",
        "            date_label.move_to(axis_point, UR)\n",
        "            date_label.shift(MED_SMALL_BUFF * DOWN)\n",
        "            date_label.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "            v_line = DashedLine(\n",
        "                axes.c2p(x, 0),\n",
        "                c2p(x, target_y),\n",
        "            )\n",
        "            v_line.set_stroke(WHITE, 2)\n",
        "\n",
        "            if target_y is target_ys[-1]:\n",
        "                self.play(self.camera.frame.scale, 1.1, {\"about_edge\": LEFT})\n",
        "\n",
        "            if last_label:\n",
        "                self.play(\n",
        "                    ReplacementTransform(last_label, label),\n",
        "                    ReplacementTransform(last_rect, rect),\n",
        "                )\n",
        "            else:\n",
        "                rect.save_state()\n",
        "                rect.stretch(0, 0, about_edge=LEFT)\n",
        "                self.play(Restore(rect), FadeIn(label, LEFT))\n",
        "            self.wait()\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(v_line),\n",
        "                FadeIn(date_label),\n",
        "            )\n",
        "\n",
        "            last_label = label\n",
        "            last_rect = rect\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(last_label, RIGHT),\n",
        "            ApplyMethod(\n",
        "                last_rect.stretch, 0, 0, {\"about_edge\": RIGHT},\n",
        "                remover=True\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Show alternate petering out possibilities\n",
        "        def get_dots_along_curve(curve):\n",
        "            x_min = int(axes.x_axis.p2n(curve.get_start()))\n",
        "            x_max = int(axes.x_axis.p2n(curve.get_end()))\n",
        "            result = VGroup()\n",
        "            for x in range(x_min, x_max):\n",
        "                prop = binary_search(\n",
        "                    lambda p: axes.x_axis.p2n(\n",
        "                        curve.point_from_proportion(p),\n",
        "                    ),\n",
        "                    x, 0, 1,\n",
        "                )\n",
        "                prop = prop or 0\n",
        "                point = curve.point_from_proportion(prop)\n",
        "                dot = Dot(point)\n",
        "                dot.shift(0.02 * (random.random() - 0.5))\n",
        "                dot.set_height(0.075)\n",
        "                dot.set_color(RED)\n",
        "                result.add(dot)\n",
        "            dots.remove(dots[0])\n",
        "            return result\n",
        "\n",
        "        def get_point_from_y(y):\n",
        "            log_y = np.log10(y)\n",
        "            x = (log_y - reg.intercept) / reg.slope\n",
        "            return c2p(x, 10**log_y)\n",
        "\n",
        "        p100k = get_point_from_y(1e5)\n",
        "        p100M = get_point_from_y(1e8)\n",
        "        curve1 = VMobject()\n",
        "        curve1.append_points([\n",
        "            dots[-1].get_center(),\n",
        "            p100k,\n",
        "            p100k + 5 * RIGHT,\n",
        "        ])\n",
        "        curve2 = VMobject()\n",
        "        curve2.append_points([\n",
        "            dots[-1].get_center(),\n",
        "            p100M,\n",
        "            p100M + 5 * RIGHT + 0.25 * UP,\n",
        "        ])\n",
        "\n",
        "        proj_dots1 = get_dots_along_curve(curve1)\n",
        "        proj_dots2 = get_dots_along_curve(curve2)\n",
        "\n",
        "        for proj_dots in [proj_dots1, proj_dots2]:\n",
        "            self.play(FadeIn(proj_dots, lag_ratio=0.1))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(proj_dots, lag_ratio=0.1))\n",
        "\n",
        "\n",
        "class LinRegNote(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"(Starting from when\\\\\\\\there were 100 cases)\")\n",
        "        text.set_stroke(BLACK, 8, background=True)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class CompareCountries(Scene):\n",
        "    def construct(self):\n",
        "        # Introduce\n",
        "        sk_flag = ImageMobject(os.path.join(\"flags\", \"kr\"))\n",
        "        au_flag = ImageMobject(os.path.join(\"flags\", \"au\"))\n",
        "        flags = Group(sk_flag, au_flag)\n",
        "        flags.set_height(3)\n",
        "        flags.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        flags.next_to(ORIGIN, UP)\n",
        "\n",
        "        labels = VGroup()\n",
        "        case_numbers = [6593, 64]\n",
        "        for flag, cn in zip(flags, case_numbers):\n",
        "            label = VGroup(Integer(cn), OldTexText(\"cases\"))\n",
        "            label.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            label[1].align_to(label[0][-1], DOWN)\n",
        "            label.scale(1.5)\n",
        "            label.next_to(flag, DOWN, MED_LARGE_BUFF)\n",
        "            label[0].set_value(0)\n",
        "            labels.add(label)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, flags, lag_ratio=0.25))\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(labels[0][0], case_numbers[0]),\n",
        "            ChangeDecimalToValue(labels[1][0], case_numbers[1]),\n",
        "            UpdateFromAlphaFunc(\n",
        "                labels,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Compare\n",
        "        arrow = Arrow(\n",
        "            labels[1][0].get_bottom(),\n",
        "            labels[0][0].get_bottom(),\n",
        "            path_arc=-90 * DEGREES,\n",
        "        )\n",
        "        arrow_label = OldTexText(\"100x better\")\n",
        "        arrow_label.set_color(YELLOW)\n",
        "        arrow_label.next_to(arrow, DOWN)\n",
        "\n",
        "        alt_arrow_label = OldTexText(\"1 month behind\")\n",
        "        alt_arrow_label.set_color(RED)\n",
        "        alt_arrow_label.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(FadeIn(arrow_label, 0.5 * UP))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(alt_arrow_label, 0.5 * UP),\n",
        "            FadeOut(arrow_label, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SARSvs1918(Scene):\n",
        "    def construct(self):\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"2002 SARS outbreak\"),\n",
        "            OldTexText(\"1918 Spanish flu\"),\n",
        "        )\n",
        "        images = Group(\n",
        "            ImageMobject(\"sars_icon\"),\n",
        "            ImageMobject(\"spanish_flu\"),\n",
        "        )\n",
        "        for title, vect, color, image in zip(titles, [LEFT, RIGHT], [YELLOW, RED], images):\n",
        "            image.set_height(4)\n",
        "            image.move_to(vect * FRAME_WIDTH / 4)\n",
        "            image.to_edge(UP)\n",
        "            title.scale(1.25)\n",
        "            title.next_to(image, DOWN, MED_LARGE_BUFF)\n",
        "            title.set_color(color)\n",
        "            title.underline = Underline(title)\n",
        "            title.underline.set_stroke(WHITE, 1)\n",
        "            title.add_to_back(title.underline)\n",
        "\n",
        "        titles[1].underline.match_y(titles[0].underline)\n",
        "\n",
        "        n_cases_labels = VGroup(\n",
        "            OldTexText(\"8,096 cases\"),\n",
        "            OldTexText(\"$\\\\sim$513{,}000{,}000 cases\"),\n",
        "        )\n",
        "\n",
        "        for n_cases_label, title in zip(n_cases_labels, titles):\n",
        "            n_cases_label.scale(1.25)\n",
        "            n_cases_label.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        for image, title, label in zip(images, titles, n_cases_labels):\n",
        "            self.play(\n",
        "                FadeIn(image, DOWN),\n",
        "                Write(title),\n",
        "                run_time=1,\n",
        "            )\n",
        "            self.play(FadeIn(label, UP))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ViralSpreadModelWithShuffling(ViralSpreadModel):\n",
        "    def construct(self):\n",
        "        # Init population\n",
        "        randys = self.get_randys()\n",
        "        self.add(*randys)\n",
        "\n",
        "        # Show the sicko\n",
        "        self.show_patient0(randys)\n",
        "\n",
        "        # Repeatedly spread\n",
        "        for x in range(15):\n",
        "            self.spread_infection(randys)\n",
        "            self.shuffle_randys(randys)\n",
        "\n",
        "    def shuffle_randys(self, randys):\n",
        "        indices = list(range(len(randys)))\n",
        "        np.random.shuffle(indices)\n",
        "\n",
        "        anims = []\n",
        "        for i, randy in zip(indices, randys):\n",
        "            randy.generate_target()\n",
        "            randy.target.move_to(randys[i])\n",
        "            anims.append(MoveToTarget(\n",
        "                randy, path_arc=30 * DEGREES,\n",
        "            ))\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *anims,\n",
        "            lag_ratio=1 / len(randys),\n",
        "            run_time=3\n",
        "        ))\n",
        "\n",
        "\n",
        "class SneezingOnNeighbors(Scene):\n",
        "    def construct(self):\n",
        "        randys = VGroup(*[PiCreature() for x in range(3)])\n",
        "        randys.set_height(1)\n",
        "        randys.arrange(RIGHT)\n",
        "\n",
        "        self.add(randys)\n",
        "        self.play(\n",
        "            randys[1].change, \"sick\",\n",
        "            randys[1].set_color, SICKLY_GREEN,\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(\n",
        "                randys[1],\n",
        "                color=SICKLY_GREEN,\n",
        "                flash_radius=0.8,\n",
        "            ),\n",
        "            randys[0].change, \"sassy\", randys[1],\n",
        "            randys[2].change, \"angry\", randys[1],\n",
        "        )\n",
        "        self.play(\n",
        "            randys[0].change, \"sick\",\n",
        "            randys[0].set_color, SICKLY_GREEN,\n",
        "            randys[2].change, \"sick\",\n",
        "            randys[2].set_color, SICKLY_GREEN,\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(\n",
        "                randys[1],\n",
        "                color=SICKLY_GREEN,\n",
        "                flash_radius=0.8,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            randys[0].change, \"sad\", randys[1],\n",
        "            randys[2].change, \"tired\", randys[1],\n",
        "        )\n",
        "        self.play(\n",
        "            Flash(\n",
        "                randys[1],\n",
        "                color=SICKLY_GREEN,\n",
        "                flash_radius=0.8,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            randys[0].change, \"angry\", randys[1],\n",
        "            randys[2].change, \"angry\", randys[1],\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ViralSpreadModelWithClusters(ViralSpreadModel):\n",
        "    def construct(self):\n",
        "        randys = self.get_randys()\n",
        "        self.add(*randys)\n",
        "        self.show_patient0(randys)\n",
        "\n",
        "        for x in range(6):\n",
        "            self.spread_infection(randys)\n",
        "\n",
        "    def get_randys(self):\n",
        "        cluster = VGroup(*[Randolph() for x in range(16)])\n",
        "        cluster.arrange_in_grid(4, 4)\n",
        "        cluster.set_height(1)\n",
        "        cluster.space_out_submobjects(1.3)\n",
        "\n",
        "        clusters = VGroup(*[cluster.copy() for x in range(12)])\n",
        "        clusters.arrange_in_grid(3, 4, buff=LARGE_BUFF)\n",
        "        clusters.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        for cluster in clusters:\n",
        "            for randy in cluster:\n",
        "                randy.infected = False\n",
        "\n",
        "        self.add(clusters)\n",
        "\n",
        "        self.clusters = clusters\n",
        "        return VGroup(*it.chain(*clusters))\n",
        "\n",
        "\n",
        "class ViralSpreadModelWithClustersAndTravel(ViralSpreadModelWithClusters):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        randys = self.get_randys()\n",
        "        self.add(*randys)\n",
        "        self.show_patient0(randys)\n",
        "\n",
        "        for x in range(20):\n",
        "            self.spread_infection(randys)\n",
        "            self.travel_between_clusters()\n",
        "            self.update_frame(ignore_skipping=True)\n",
        "\n",
        "    def travel_between_clusters(self):\n",
        "        reps = VGroup(*[\n",
        "            random.choice(cluster)\n",
        "            for cluster in self.clusters\n",
        "        ])\n",
        "        targets = list(reps)\n",
        "        random.shuffle(targets)\n",
        "\n",
        "        anims = []\n",
        "        for rep, target in zip(reps, targets):\n",
        "            rep.generate_target()\n",
        "            rep.target.move_to(target)\n",
        "            anims.append(MoveToTarget(\n",
        "                rep,\n",
        "                path_arc=30 * DEGREES,\n",
        "            ))\n",
        "        self.play(LaggedStart(*anims, run_time=3))\n",
        "\n",
        "\n",
        "class ShowLogisticCurve(Scene):\n",
        "    def construct(self):\n",
        "        # Init axes\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        # Add ODE\n",
        "        ode = OldTex(\n",
        "            \"{dN \\\\over dt} =\",\n",
        "            \"c\",\n",
        "            \"\\\\left(1 - {N \\\\over \\\\text{pop.}}\\\\right)\",\n",
        "            \"N\",\n",
        "            tex_to_color_map={\"N\": YELLOW}\n",
        "        )\n",
        "        ode.set_height(0.75)\n",
        "        ode.center()\n",
        "        ode.to_edge(RIGHT)\n",
        "        ode.shift(1.5 * UP)\n",
        "        self.add(ode)\n",
        "\n",
        "        # Show curve\n",
        "        curve = axes.get_graph(\n",
        "            lambda x: 8 * smooth(x / 10) + 0.2,\n",
        "        )\n",
        "        curve.set_stroke(YELLOW, 3)\n",
        "\n",
        "        curve_title = OldTexText(\"Logistic curve\")\n",
        "        curve_title.set_height(0.75)\n",
        "        curve_title.next_to(curve.get_end(), UL)\n",
        "\n",
        "        self.play(ShowCreation(curve, run_time=3))\n",
        "        self.play(FadeIn(curve_title, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Early part\n",
        "        line = Line(\n",
        "            curve.point_from_proportion(0),\n",
        "            curve.point_from_proportion(0.25),\n",
        "        )\n",
        "        rect = Rectangle()\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(TEAL, 0.5)\n",
        "        rect.replace(line, stretch=True)\n",
        "\n",
        "        exp_curve = axes.get_graph(\n",
        "            lambda x: 0.15 * np.exp(0.68 * x)\n",
        "        )\n",
        "        exp_curve.set_stroke(RED, 3)\n",
        "\n",
        "        rect.save_state()\n",
        "        rect.stretch(0, 0, about_edge=LEFT)\n",
        "        self.play(Restore(rect))\n",
        "        self.play(ShowCreation(exp_curve, run_time=4))\n",
        "\n",
        "        # Show capacity\n",
        "        line = DashedLine(\n",
        "            axes.c2p(0, 8.2),\n",
        "            axes.c2p(axes.x_max, 8.2),\n",
        "        )\n",
        "        line.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect), FadeOut(exp_curve))\n",
        "\n",
        "        # Show inflection point\n",
        "        infl_point = axes.input_to_graph_point(5, curve)\n",
        "        infl_dot = Dot(infl_point)\n",
        "        infl_dot.set_stroke(WHITE, 3)\n",
        "\n",
        "        curve_up_part = curve.copy()\n",
        "        curve_up_part.pointwise_become_partial(curve, 0, 0.4)\n",
        "        curve_up_part.set_stroke(GREEN)\n",
        "        curve_down_part = curve.copy()\n",
        "        curve_down_part.pointwise_become_partial(curve, 0.4, 1)\n",
        "        curve_down_part.set_stroke(RED)\n",
        "        for part in curve_up_part, curve_down_part:\n",
        "            part.save_state()\n",
        "            part.stretch(0, 1)\n",
        "            part.set_y(axes.c2p(0, 0)[1])\n",
        "\n",
        "        pre_dot = curve.copy()\n",
        "        pre_dot.pointwise_become_partial(curve, 0.375, 0.425)\n",
        "\n",
        "        infl_name = OldTexText(\"Inflection point\")\n",
        "        infl_name.next_to(infl_dot, LEFT)\n",
        "\n",
        "        self.play(ReplacementTransform(pre_dot, infl_dot, path_arc=90 * DEGREES))\n",
        "        self.add(curve_up_part, infl_dot)\n",
        "        self.play(Restore(curve_up_part))\n",
        "        self.add(curve_down_part, infl_dot)\n",
        "        self.play(Restore(curve_down_part))\n",
        "        self.wait()\n",
        "        self.play(Write(infl_name, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show tangent line\n",
        "        x_tracker = ValueTracker(0)\n",
        "        tan_line = Line(LEFT, RIGHT)\n",
        "        tan_line.set_width(5)\n",
        "        tan_line.set_stroke(YELLOW, 2)\n",
        "\n",
        "        def update_tan_line(line):\n",
        "            x1 = x_tracker.get_value()\n",
        "            x2 = x1 + 0.001\n",
        "            p1 = axes.input_to_graph_point(x1, curve)\n",
        "            p2 = axes.input_to_graph_point(x2, curve)\n",
        "            angle = angle_of_vector(p2 - p1)\n",
        "            line.rotate(angle - line.get_angle())\n",
        "            line.move_to(p1)\n",
        "\n",
        "        tan_line.add_updater(update_tan_line)\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.scale(0.75)\n",
        "        dot.set_fill(BLUE, 0.75)\n",
        "        dot.add_updater(\n",
        "            lambda m: m.move_to(axes.input_to_graph_point(\n",
        "                x_tracker.get_value(), curve\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(tan_line),\n",
        "            FadeInFromLarge(dot),\n",
        "        )\n",
        "        self.play(\n",
        "            x_tracker.set_value, 5,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x_tracker.set_value, 9.9,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Define growth factor\n",
        "        gf_label = OldTex(\n",
        "            \"\\\\text{Growth factor} =\",\n",
        "            \"{\\\\Delta N_d \\\\over \\\\Delta N_{d - 1}}\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\Delta\": WHITE,\n",
        "                \"N_d\": YELLOW,\n",
        "                \"N_{d - 1}\": BLUE,\n",
        "            }\n",
        "        )\n",
        "        gf_label.next_to(infl_dot, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        numer_label = OldTexText(\"New cases one day\")\n",
        "        denom_label = OldTexText(\"New cases the\\\\\\\\previous day\")\n",
        "\n",
        "        for label, tex, vect in (numer_label, \"N_d\", UL), (denom_label, \"N_{d - 1}\", DL):\n",
        "            part = gf_label.get_part_by_tex(tex)\n",
        "            label.match_color(part)\n",
        "            label.next_to(part, vect, LARGE_BUFF)\n",
        "            label.shift(2 * RIGHT)\n",
        "            arrow = Arrow(\n",
        "                label.get_corner(vect[1] * DOWN),\n",
        "                part.get_corner(vect[1] * UP) + 0.25 * LEFT,\n",
        "                buff=0.1,\n",
        "            )\n",
        "            arrow.match_color(part)\n",
        "            label.add_to_back(arrow)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(gf_label[0], RIGHT),\n",
        "            FadeIn(gf_label[1:], LEFT),\n",
        "            FadeOut(ode)\n",
        "        )\n",
        "        self.wait()\n",
        "        for label in numer_label, denom_label:\n",
        "            self.play(FadeIn(label, lag_ratio=0.1))\n",
        "            self.wait()\n",
        "\n",
        "        # Show example growth factors\n",
        "        self.play(x_tracker.set_value, 1)\n",
        "\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(gf_label, RIGHT)\n",
        "        gf = DecimalNumber(1.15)\n",
        "        gf.set_height(0.4)\n",
        "        gf.next_to(eq, RIGHT)\n",
        "\n",
        "        def get_growth_factor():\n",
        "            x1 = x_tracker.get_value()\n",
        "            x0 = x1 - 0.2\n",
        "            x2 = x1 + 0.2\n",
        "            p0, p1, p2 = [\n",
        "                axes.input_to_graph_point(x, curve)\n",
        "                for x in [x0, x1, x2]\n",
        "            ]\n",
        "            return (p2[1] - p1[1]) / (p1[1] - p0[1])\n",
        "\n",
        "        gf.add_updater(lambda m: m.set_value(get_growth_factor()))\n",
        "\n",
        "        self.add(eq, gf)\n",
        "        self.play(\n",
        "            x_tracker.set_value, 5,\n",
        "            run_time=6,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x_tracker.set_value, 9,\n",
        "            run_time=6,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=13,\n",
        "            y_min=0,\n",
        "            y_max=10,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.7,\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        )\n",
        "        axes.center()\n",
        "        axes.to_edge(DOWN)\n",
        "\n",
        "        x_label = OldTexText(\"Time\")\n",
        "        x_label.next_to(axes.x_axis, UP, aligned_edge=RIGHT)\n",
        "        y_label = OldTexText(\"N cases\")\n",
        "        y_label.next_to(axes.y_axis, RIGHT, aligned_edge=UP)\n",
        "        axes.add(x_label, y_label)\n",
        "        return axes\n",
        "\n",
        "\n",
        "class SubtltyOfGrowthFactorShift(Scene):\n",
        "    def construct(self):\n",
        "        # Set up totals\n",
        "        total_title = OldTexText(\"Totals\")\n",
        "        total_title.add(Underline(total_title))\n",
        "        total_title.to_edge(UP)\n",
        "        total_title.scale(1.25)\n",
        "        total_title.shift(LEFT)\n",
        "        total_title.set_color(YELLOW)\n",
        "        total_title.shift(LEFT)\n",
        "\n",
        "        data = CASE_DATA[-4:]\n",
        "        data.append(int(data[-1] + 1.15 * (data[-1] - data[-2])))\n",
        "        totals = VGroup(*[Integer(value) for value in data])\n",
        "        totals.scale(1.25)\n",
        "        totals.arrange(DOWN, buff=0.6, aligned_edge=LEFT)\n",
        "        totals.next_to(total_title, DOWN, buff=0.6)\n",
        "        totals[-1].set_color(BLUE)\n",
        "\n",
        "        # Set up dates\n",
        "        dates = VGroup(\n",
        "            OldTexText(\"March 3, 2020\"),\n",
        "            OldTexText(\"March 4, 2020\"),\n",
        "            OldTexText(\"March 5, 2020\"),\n",
        "            OldTexText(\"March 6, 2020\"),\n",
        "        )\n",
        "        for date, total in zip(dates, totals):\n",
        "            date.scale(0.75)\n",
        "            date.set_color(GREY_B)\n",
        "            date.next_to(total, LEFT, buff=0.75, aligned_edge=DOWN)\n",
        "\n",
        "        # Set up changes\n",
        "        change_arrows = VGroup()\n",
        "        change_labels = VGroup()\n",
        "        for t1, t2 in zip(totals, totals[1:]):\n",
        "            arrow = Arrow(\n",
        "                t1.get_right(),\n",
        "                t2.get_right(),\n",
        "                path_arc=-150 * DEGREES,\n",
        "                buff=0.1,\n",
        "                max_tip_length_to_length_ratio=0.15,\n",
        "            )\n",
        "            arrow.shift(MED_SMALL_BUFF * RIGHT)\n",
        "            arrow.set_stroke(width=3)\n",
        "            change_arrows.add(arrow)\n",
        "\n",
        "            diff = t2.get_value() - t1.get_value()\n",
        "            label = Integer(diff, include_sign=True)\n",
        "            label.set_color(GREEN)\n",
        "            label.next_to(arrow, RIGHT)\n",
        "            change_labels.add(label)\n",
        "\n",
        "        change_labels[-1].set_color(BLUE)\n",
        "\n",
        "        change_title = OldTexText(\"Changes\")\n",
        "        change_title.add(Underline(change_title).shift(0.128 * UP))\n",
        "        change_title.scale(1.25)\n",
        "        change_title.set_color(GREEN)\n",
        "        change_title.move_to(change_labels)\n",
        "        change_title.align_to(total_title, UP)\n",
        "\n",
        "        # Set up growth factors\n",
        "        gf_labels = VGroup()\n",
        "        gf_arrows = VGroup()\n",
        "        for c1, c2 in zip(change_labels, change_labels[1:]):\n",
        "            arrow = Arrow(\n",
        "                c1.get_right(),\n",
        "                c2.get_right(),\n",
        "                path_arc=-150 * DEGREES,\n",
        "                buff=0.1,\n",
        "                max_tip_length_to_length_ratio=0.15,\n",
        "            )\n",
        "            arrow.set_stroke(width=1)\n",
        "            gf_arrows.add(arrow)\n",
        "\n",
        "            line = Line(LEFT, RIGHT)\n",
        "            line.match_width(c2)\n",
        "            line.set_stroke(WHITE, 2)\n",
        "            numer = c2.deepcopy()\n",
        "            denom = c1.deepcopy()\n",
        "            frac = VGroup(numer, line, denom)\n",
        "            frac.arrange(DOWN, buff=SMALL_BUFF)\n",
        "            frac.scale(0.7)\n",
        "            frac.next_to(arrow, RIGHT)\n",
        "            eq = OldTex(\"=\")\n",
        "            eq.next_to(frac, RIGHT)\n",
        "            gf = DecimalNumber(c2.get_value() / c1.get_value())\n",
        "            gf.next_to(eq, RIGHT)\n",
        "            gf_labels.add(VGroup(frac, eq, gf))\n",
        "\n",
        "        gf_title = OldTexText(\"Growth factors\")\n",
        "        gf_title.add(Underline(gf_title))\n",
        "        gf_title.scale(1.25)\n",
        "        gf_title.move_to(gf_labels[0][-1])\n",
        "        gf_title.align_to(total_title, DOWN)\n",
        "\n",
        "        # Add things\n",
        "        self.add(dates, total_title)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, totals[:-1],\n",
        "                lambda m: (m, UP),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(change_arrows[:-1]),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, change_labels[:-1],\n",
        "                lambda m: (m, LEFT),\n",
        "            ),\n",
        "            FadeIn(change_title),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(gf_arrows[:-1]),\n",
        "            LaggedStartMap(FadeIn, gf_labels[:-1]),\n",
        "            FadeIn(gf_title),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show hypothetical new value\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(gf_labels[-1]),\n",
        "            FadeIn(gf_arrows[-1]),\n",
        "            FadeIn(change_labels[-1]),\n",
        "            FadeIn(change_arrows[-1]),\n",
        "            FadeIn(totals[-1]),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Change it\n",
        "        alt_change = data[-2] - data[-3]\n",
        "        alt_total = data[-2] + alt_change\n",
        "        alt_gf = 1\n",
        "\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(gf_labels[-1][-1], alt_gf),\n",
        "            ChangeDecimalToValue(gf_labels[-1][0][0], alt_change),\n",
        "            ChangeDecimalToValue(change_labels[-1], alt_change),\n",
        "            ChangeDecimalToValue(totals[-1], alt_total),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ContrastRandomShufflingWithClustersAndTravel(Scene):\n",
        "    def construct(self):\n",
        "        background = FullScreenFadeRectangle()\n",
        "        background.set_fill(GREY_E)\n",
        "        self.add(background)\n",
        "\n",
        "        squares = VGroup(*[Square() for x in range(2)])\n",
        "        squares.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        squares.arrange(RIGHT, buff=0.75)\n",
        "        squares.to_edge(DOWN)\n",
        "        squares.set_fill(BLACK, 1)\n",
        "        squares.stretch(0.8, 1)\n",
        "        self.add(squares)\n",
        "\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Random shuffling\"),\n",
        "            OldTexText(\"Clusters with travel\"),\n",
        "        )\n",
        "        for title, square in zip(titles, squares):\n",
        "            title.scale(1.4)\n",
        "            title.next_to(square, UP)\n",
        "        titles[1].align_to(titles[0], UP)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, titles,\n",
        "            lambda m: (m, 0.25 * DOWN),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowVaryingExpFactor(Scene):\n",
        "    def construct(self):\n",
        "        factor = DecimalNumber(0.15)\n",
        "        rect = BackgroundRectangle(factor, buff=SMALL_BUFF)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        arrow = Arrow(\n",
        "            factor.get_right(),\n",
        "            factor.get_right() + 4 * RIGHT + 0.5 * DOWN,\n",
        "        )\n",
        "\n",
        "        self.add(rect, factor, arrow)\n",
        "        for value in [0.05, 0.25, 0.15]:\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(factor, value),\n",
        "                run_time=3,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowVaryingBaseFactor(ShowLogisticCurve):\n",
        "    def construct(self):\n",
        "        factor = DecimalNumber(1.15)\n",
        "        rect = BackgroundRectangle(factor, buff=SMALL_BUFF)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "\n",
        "        self.add(rect, factor)\n",
        "        for value in [1.05, 1.25, 1.15]:\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(factor, value),\n",
        "                run_time=3,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowVaryingExpCurve(ShowLogisticCurve):\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        curve = axes.get_graph(lambda x: np.exp(0.15 * x))\n",
        "        curve.set_stroke([BLUE, YELLOW, RED])\n",
        "        curve.make_jagged()\n",
        "        self.add(curve)\n",
        "\n",
        "        self.camera.frame.scale(2, about_edge=DOWN)\n",
        "        self.camera.frame.shift(DOWN)\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_stroke(WHITE, 3)\n",
        "        rect.set_fill(opacity=0)\n",
        "        self.add(rect)\n",
        "\n",
        "        for value in [0.05, 0.25, 0.15]:\n",
        "            new_curve = axes.get_graph(lambda x: np.exp(value * x))\n",
        "            new_curve.set_stroke([BLUE, YELLOW, RED])\n",
        "            new_curve.make_jagged()\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                run_time=3,\n",
        "            )\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adam D\u0159\u00ednek\",\n",
        "            \"Aidan Shenkman\",\n",
        "            \"Alan Stein\",\n",
        "            \"Alex Mijalis\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Andrew Cary\",\n",
        "            \"Andrew R. Whalley\",\n",
        "            \"Aravind C V\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Austin Goodman\",\n",
        "            \"Avi Finkel\",\n",
        "            \"Awoo\",\n",
        "            \"AZsorcerer\",\n",
        "            \"Barry Fam\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Bradley Pirtle\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Britton Finley\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Calvin Lin\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Charlie N\",\n",
        "            \"Chenna Kautilya\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"cinterloper\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Colwyn Fritze-Moor\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Corey Ogburn\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Daniel Herrera C\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"dave nicponski\",\n",
        "            \"David B. Hill\",\n",
        "            \"David Clark\",\n",
        "            \"David Gow\",\n",
        "            \"Delton Ding\",\n",
        "            \"Dominik Wagner\",\n",
        "            \"Douglas Cantrell\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Frank R. Brown, Jr.\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"Ivan Sorokin\",\n",
        "            \"Jacob Baxter\",\n",
        "            \"Jacob Harmon\",\n",
        "            \"Jacob Hartmann\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jake Vartuli - Schonberg\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jayne Gabriele\",\n",
        "            \"Jean-Manuel Izaret\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"John C. Vesey\",\n",
        "            \"John Haley\",\n",
        "            \"John Le\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Heckerman\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Josh Kinnear\",\n",
        "            \"Joshua Claeys\",\n",
        "            \"Juan Benet\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Karl Niu\",\n",
        "            \"Kartik Cating-Subramanian\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Killian McGuinness\",\n",
        "            \"Kros Dai\",\n",
        "            \"L0j1k\",\n",
        "            \"Lambda GPU Workstations\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Manoj Rewatkar - RITEK SOLUTIONS\",\n",
        "            \"Mark Heising\",\n",
        "            \"Mark Mann\",\n",
        "            \"Martin Price\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Godbolt\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matt Russell\",\n",
        "            \"Matteo Delabre\",\n",
        "            \"Matthew Bouchard\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Mia Parent\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Michael W White\",\n",
        "            \"Mirik Gogri\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nicholas Cahill\",\n",
        "            \"Nikita Lesnikov\",\n",
        "            \"Oleg Leonov\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Patrick Lucas\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Pierre Lancien\",\n",
        "            \"Quantopian\",\n",
        "            \"Randy C. Will\",\n",
        "            \"rehmi post\",\n",
        "            \"Rex Godby\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Roman Sergeychik\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Samuel Judge\",\n",
        "            \"SansWord Huang\",\n",
        "            \"Scott Gray\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Sebastian Garcia\",\n",
        "            \"soekul\",\n",
        "            \"Solara570\",\n",
        "            \"Steve Huynh\",\n",
        "            \"Steve Sperandeo\",\n",
        "            \"Steven Braun\",\n",
        "            \"Steven Siddals\",\n",
        "            \"Stevie Metke\",\n",
        "            \"supershabam\",\n",
        "            \"Suteerth Vishnu\",\n",
        "            \"Suthen Thomas\",\n",
        "            \"Tal Einav\",\n",
        "            \"Tauba Auerbach\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Thomas J Sargent\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Tihan Seale\",\n",
        "            \"Tyler VanValkenburg\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Veritasium\",\n",
        "            \"Vinicius Reis\",\n",
        "            \"Xuanji Li\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yavor Ivanov\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Yu Jun\",\n",
        "            \"Yurii Monastyrshyn\",\n",
        "        ]\n",
        "    }\n"
    ]
}