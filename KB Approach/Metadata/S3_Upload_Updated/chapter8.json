{
    "topic": "is demonstrating the concept of the derivative of a function with respect to its input.",
    "code": [
        "import scipy\n",
        "from manim_imports_ext import *\n",
        "from _2017.eoc.chapter1 import Thumbnail as Chapter1Thumbnail\n",
        "from _2017.eoc.chapter2 import Car, MoveCar, ShowSpeedometer, \\\n",
        "    IncrementNumber, GraphCarTrajectory, SecantLineToTangentLine, \\\n",
        "    VELOCITY_COLOR, TIME_COLOR, DISTANCE_COLOR\n",
        "\n",
        "def v_rate_func(t):\n",
        "    return 4*t - 4*(t**2)\n",
        "\n",
        "def s_rate_func(t):\n",
        "    return 3*(t**2) - 2*(t**3)\n",
        "\n",
        "def v_func(t):\n",
        "    return t*(8-t)\n",
        "\n",
        "def s_func(t):\n",
        "    return 4*t**2 - (t**3)/3.\n",
        "\n",
        "\n",
        "class Chapter8OpeningQuote(OpeningQuote, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \" One should never try to prove anything that \\\\\\\\ is not \",\n",
        "            \"almost obvious\", \". \"\n",
        "        ],\n",
        "        \"quote_arg_separator\" : \"\",\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"almost obvious\" : BLUE,\n",
        "        },\n",
        "        \"author\" : \"Alexander Grothendieck\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        OpeningQuote.construct(self)\n",
        "\n",
        "        words_copy = self.quote.get_part_by_tex(\"obvious\").copy()\n",
        "        author = self.author\n",
        "        author.save_state()\n",
        "        formula = self.get_formula()\n",
        "        formula.next_to(author, DOWN, MED_LARGE_BUFF)\n",
        "        formula.to_edge(LEFT)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(FadeIn(self.pi_creature))\n",
        "        self.play(\n",
        "            author.next_to, self.pi_creature.get_corner(UP+LEFT), UP,\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            author.restore,\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(\n",
        "            words_copy.next_to, self.pi_creature, \n",
        "                LEFT, MED_SMALL_BUFF, UP,\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(formula),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_formula(self):\n",
        "        result = OldTex(\n",
        "            \"{d(\\\\sin(\\\\theta)) \\\\over \\\\,\", \"d\\\\theta}\", \"=\",\n",
        "            \"\\\\lim_{\", \"h\", \" \\\\to 0}\", \n",
        "            \"{\\\\sin(\\\\theta+\", \"h\", \") - \\\\sin(\\\\theta) \\\\over\", \" h}\", \"=\",\n",
        "            \"\\\\lim_{\", \"h\", \" \\\\to 0}\", \n",
        "            \"{\\\\big[ \\\\sin(\\\\theta)\\\\cos(\", \"h\", \") + \",\n",
        "            \"\\\\sin(\", \"h\", \")\\\\cos(\\\\theta)\\\\big] - \\\\sin(\\\\theta) \\\\over\", \"h}\",\n",
        "            \"= \\\\dots\"\n",
        "        )\n",
        "        result.set_color_by_tex(\"h\", GREEN, substring = False)\n",
        "        result.set_color_by_tex(\"d\\\\theta\", GREEN)\n",
        "\n",
        "        result.set_width(FRAME_WIDTH - 2*MED_SMALL_BUFF)\n",
        "        return result\n",
        "\n",
        "class ThisVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[7]\n",
        "        this_video.save_state()\n",
        "        next_video = series[8]\n",
        "\n",
        "        deriv, integral, v_t, dt, equals, v_T = formula = OldTex(\n",
        "            \"\\\\frac{d}{dT}\", \n",
        "            \"\\\\int_0^T\", \"v(t)\", \"\\\\,dt\", \n",
        "            \"=\", \"v(T)\"\n",
        "        )\n",
        "        formula.set_color_by_tex(\"v\", VELOCITY_COLOR)\n",
        "        formula.next_to(self.teacher.get_corner(UP+LEFT), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(series, lag_ratio = 0.5))\n",
        "        self.play(\n",
        "            this_video.shift, this_video.get_height()*DOWN/2,\n",
        "            this_video.set_color, YELLOW,\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(Write(VGroup(integral, v_t, dt)))\n",
        "        self.play_student_changes(*[\"erm\"]*3)\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(deriv, equals, v_T)), )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            this_video.restore,\n",
        "            next_video.shift, next_video.get_height()*DOWN/2,\n",
        "            next_video.set_color, YELLOW,\n",
        "            integral[0].copy().next_to, next_video, DOWN, MED_LARGE_BUFF,\n",
        "            FadeOut(formula),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"plain\", pi.look_at, next_video]\n",
        "                for pi in self.pi_creatures\n",
        "            ])\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class InCarRestrictedView(ShowSpeedometer):\n",
        "    CONFIG = {\n",
        "        \"speedometer_title_text\" : \"Your view\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        car.move_to(self.point_A)\n",
        "        self.car = car\n",
        "        car.randy.save_state()\n",
        "        Transform(car.randy, Randolph()).update(1)\n",
        "        car.randy.next_to(car, RIGHT, MED_LARGE_BUFF)\n",
        "        car.randy.look_at(car)\n",
        "\n",
        "        window = car[1][6].copy()\n",
        "        window.is_subpath = False\n",
        "        window.set_fill(BLACK, opacity = 0.75)\n",
        "        window.set_stroke(width = 0)\n",
        "\n",
        "        square = Square(stroke_color = WHITE)\n",
        "        square.replace(VGroup(self.speedometer, self.speedometer_title))\n",
        "        square.scale(1.5)\n",
        "        square.pointwise_become_partial(square, 0.25, 0.75)\n",
        "\n",
        "        time_label = OldTexText(\"Time (in seconds):\", \"0\")\n",
        "        time_label.shift(2*UP)\n",
        "\n",
        "        dots = VGroup(*list(map(Dot, [self.point_A, self.point_B])))\n",
        "        line = Line(*dots, buff = 0)\n",
        "        line.set_color(DISTANCE_COLOR)\n",
        "        brace = Brace(line, DOWN)\n",
        "        brace_text = brace.get_text(\"Distance traveled?\")\n",
        "\n",
        "\n",
        "        #Sit in car\n",
        "        self.add(car)\n",
        "        self.play(Blink(car.randy))\n",
        "        self.play(car.randy.restore, Animation(car))\n",
        "        self.play(ShowCreation(window, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        #Show speedometer\n",
        "        self.introduce_added_mobjects()\n",
        "        self.play(ShowCreation(square))\n",
        "        self.wait()\n",
        "\n",
        "        #Travel\n",
        "        self.play(FadeIn(time_label))\n",
        "        self.play(\n",
        "            MoveCar(car, self.point_B, rate_func = s_rate_func),\n",
        "            IncrementNumber(time_label[1], run_time = 8),\n",
        "            MaintainPositionRelativeTo(window, car),\n",
        "            *self.get_added_movement_anims(\n",
        "                rate_func = v_rate_func,\n",
        "                radians = -(16.0/70)*4*np.pi/3\n",
        "            ),\n",
        "            run_time = 8\n",
        "        )\n",
        "        eight = OldTex(\"8\").move_to(time_label[1])\n",
        "        self.play(Transform(\n",
        "            time_label[1], eight,\n",
        "            rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        #Ask about distance\n",
        "        self.play(*list(map(ShowCreation, dots)))\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class GraphDistanceVsTime(GraphCarTrajectory):\n",
        "    CONFIG = {\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 100,\n",
        "        \"y_axis_height\" : 6,\n",
        "        \"y_tick_frequency\" : 10,\n",
        "        \"y_labeled_nums\" : list(range(10, 100, 10)),\n",
        "        \"y_axis_label\" : \"Distance (in meters)\",\n",
        "        \"x_min\" : -1,\n",
        "        \"x_max\" : 9,\n",
        "        \"x_axis_width\" : 9,\n",
        "        \"x_tick_frequency\" : 1,\n",
        "        \"x_leftmost_tick\" : None, #Change if different from x_min\n",
        "        \"x_labeled_nums\" : list(range(1, 9)),\n",
        "        \"x_axis_label\" : \"$t$\",\n",
        "        \"time_of_journey\" : 8,\n",
        "        \"care_movement_rate_func\" : s_rate_func,\n",
        "        \"num_graph_anchor_points\" : 100\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(\n",
        "            s_func, \n",
        "            color = DISTANCE_COLOR,\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "        )\n",
        "        origin = self.coords_to_point(0, 0)\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, \"s(t)\", color = DISTANCE_COLOR\n",
        "        )\n",
        "        self.introduce_graph(graph, origin)\n",
        "\n",
        "class PlotVelocity(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -1,\n",
        "        \"x_max\" : 9,\n",
        "        \"x_axis_width\" : 9,\n",
        "        \"x_tick_frequency\" : 1,\n",
        "        \"x_labeled_nums\" : list(range(1, 9)),\n",
        "        \"x_axis_label\" : \"$t$\",\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 25,\n",
        "        \"y_axis_height\" : 6,\n",
        "        \"y_tick_frequency\" : 5,\n",
        "        \"y_labeled_nums\" : list(range(5, 30, 5)),\n",
        "        \"y_axis_label\" : \"Velocity in $\\\\frac{\\\\text{meters}}{\\\\text{second}}$\",\n",
        "        \"num_graph_anchor_points\" : 50,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_speedometer()\n",
        "        self.plot_points()\n",
        "        self.draw_curve()\n",
        "\n",
        "    def add_speedometer(self):\n",
        "        speedometer = Speedometer()\n",
        "        speedometer.next_to(self.y_axis_label_mob, RIGHT, LARGE_BUFF)\n",
        "        speedometer.to_edge(UP)\n",
        "\n",
        "        self.play(DrawBorderThenFill(\n",
        "            speedometer, \n",
        "            lag_ratio = 0.5,\n",
        "            rate_func=linear,\n",
        "        ))\n",
        "\n",
        "        self.speedometer = speedometer\n",
        "\n",
        "    def plot_points(self):\n",
        "        times = list(range(0, 9))\n",
        "        points = [\n",
        "            self.coords_to_point(t, v_func(t))\n",
        "            for t in times\n",
        "        ]\n",
        "        dots = VGroup(*[Dot(p, radius = 0.07) for p in points])\n",
        "        dots.set_color(VELOCITY_COLOR)\n",
        "\n",
        "        pre_dots = VGroup()\n",
        "        dot_intro_anims = []\n",
        "\n",
        "        for time, dot in zip(times, dots):\n",
        "            pre_dot = dot.copy()\n",
        "            self.speedometer.move_needle_to_velocity(v_func(time))\n",
        "            pre_dot.move_to(self.speedometer.get_needle_tip())\n",
        "            pre_dot.set_fill(opacity = 0)\n",
        "            pre_dots.add(pre_dot)\n",
        "            dot_intro_anims += [\n",
        "                ApplyMethod(\n",
        "                    pre_dot.set_fill, YELLOW, 1,\n",
        "                    run_time = 0.1,\n",
        "                ),\n",
        "                ReplacementTransform(\n",
        "                    pre_dot, dot,\n",
        "                    run_time = 0.9,\n",
        "                )\n",
        "            ]\n",
        "        self.speedometer.move_needle_to_velocity(0)\n",
        "\n",
        "        self.play(\n",
        "            Succession(\n",
        "                *dot_intro_anims, rate_func=linear\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                self.speedometer.move_needle_to_velocity,\n",
        "                v_func(4),\n",
        "                rate_func = squish_rate_func(\n",
        "                    lambda t : 1-v_rate_func(t),\n",
        "                    0, 0.95,\n",
        "                )\n",
        "            ),\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def draw_curve(self):\n",
        "        graph, label = self.get_v_graph_and_label()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(ShowCreation(graph, run_time = 3))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_v_graph_and_label(self):\n",
        "        graph = self.get_graph(\n",
        "            v_func, \n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "            color = VELOCITY_COLOR\n",
        "        )\n",
        "        graph_label = OldTex(\"v(t)\", \"=t(8-t)\")\n",
        "        graph_label.set_color_by_tex(\"v(t)\", VELOCITY_COLOR)\n",
        "        graph_label.next_to(\n",
        "            graph.point_from_proportion(7./8.),\n",
        "            UP+RIGHT\n",
        "        )\n",
        "        self.v_graph = graph\n",
        "        self.v_graph_label = graph_label\n",
        "        return graph, graph_label\n",
        "\n",
        "class Chapter2Wrapper(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Chapter 2: The paradox of the derivative\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(self.title)\n",
        "        title.to_edge(UP)\n",
        "        rect = Rectangle(width = 16, height = 9, color = WHITE)\n",
        "        rect.set_height(1.5*FRAME_Y_RADIUS)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class GivenDistanceWhatIsVelocity(GraphCarTrajectory):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.setup_axes()\n",
        "        graph = self.graph_sigmoid_trajectory_function()\n",
        "        origin = self.coords_to_point(0, 0)\n",
        "\n",
        "        self.introduce_graph(graph, origin)\n",
        "        self.comment_on_slope(graph, origin)\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.show_velocity_graph()\n",
        "\n",
        "class DerivativeOfDistance(SecantLineToTangentLine):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.remove(self.y_axis_label_mob, self.x_axis_label_mob)\n",
        "        self.add_derivative_definition(self.y_axis_label_mob)\n",
        "        self.add_graph()\n",
        "        self.draw_axes()\n",
        "        self.show_tangent_line()\n",
        "\n",
        "class AskAboutAntiderivative(PlotVelocity):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_v_graph()\n",
        "        self.write_s_formula()\n",
        "        self.write_antiderivative()\n",
        "\n",
        "\n",
        "    def add_v_graph(self):\n",
        "        graph, label = self.get_v_graph_and_label()\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(label))\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = label\n",
        "\n",
        "    def write_s_formula(self):\n",
        "        ds_dt = OldTex(\"ds\", \"\\\\over\\\\,\", \"dt\")\n",
        "        ds_dt.set_color_by_tex(\"ds\", DISTANCE_COLOR)\n",
        "        ds_dt.set_color_by_tex(\"dt\", TIME_COLOR)\n",
        "        ds_dt.next_to(self.graph_label, UP, LARGE_BUFF)\n",
        "\n",
        "        v_t = self.graph_label.get_part_by_tex(\"v(t)\")\n",
        "        arrow = Arrow(\n",
        "            ds_dt.get_bottom(), v_t.get_top(),\n",
        "            color = WHITE,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(ds_dt, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_antiderivative(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.shift(2*RIGHT)\n",
        "        words = OldTex(\n",
        "            \"{d(\", \"???\", \") \\\\over \\\\,\", \"dt}\", \"=\", \"t(8-t)\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"t(8-t)\", VELOCITY_COLOR)\n",
        "        words.set_color_by_tex(\"???\", DISTANCE_COLOR)\n",
        "        words.set_color_by_tex(\"dt\", TIME_COLOR)\n",
        "        words.scale(0.7)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, words, \n",
        "            target_mode = \"confused\",\n",
        "            bubble_config = {\"height\" : 3, \"width\" : 4},\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class Antiderivative(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        functions = self.get_functions(\"t^2\", \"2t\")\n",
        "        alt_functions = self.get_functions(\"???\", \"t(8-t)\")\n",
        "        top_arc, bottom_arc = arcs = self.get_arcs(functions)\n",
        "        derivative, antiderivative = self.get_arc_labels(arcs)\n",
        "        group = VGroup(functions, arcs, derivative, antiderivative)\n",
        "\n",
        "        self.add(functions, top_arc, derivative)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(bottom_arc),\n",
        "            Write(antiderivative),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for pair in reversed(list(zip(functions, alt_functions))):\n",
        "            self.play(\n",
        "                Transform(*pair),\n",
        "                self.pi_creature.change_mode, \"pondering\"\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.pi_creature_says(\n",
        "            \"But first!\", \n",
        "            target_mode = \"surprised\",\n",
        "            look_at = 50*OUT,\n",
        "            added_anims = [group.to_edge, LEFT],\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_functions(self, left_tex, right_tex):\n",
        "        left = OldTex(left_tex)\n",
        "        left.shift(2*LEFT)\n",
        "        left.set_color(DISTANCE_COLOR)\n",
        "        right = OldTex(right_tex)\n",
        "        right.shift(2*RIGHT)\n",
        "        right.set_color(VELOCITY_COLOR)\n",
        "        result = VGroup(left, right)\n",
        "        result.shift(UP)\n",
        "        return result\n",
        "\n",
        "    def get_arcs(self, functions):\n",
        "        f1, f2 = functions\n",
        "        top_line = Line(f1.get_corner(UP+RIGHT), f2.get_corner(UP+LEFT))\n",
        "        bottom_line = Line(f1.get_corner(DOWN+RIGHT), f2.get_corner(DOWN+LEFT))\n",
        "        top_arc = Arc(start_angle = 5*np.pi/6, angle = -2*np.pi/3)\n",
        "        bottom_arc = top_arc.copy()\n",
        "        bottom_arc.rotate(np.pi)\n",
        "        arcs = VGroup(top_arc, bottom_arc)\n",
        "        arcs.set_width(top_line.get_width())\n",
        "        for arc in arcs:\n",
        "            arc.add_tip()\n",
        "        top_arc.next_to(top_line, UP)\n",
        "        bottom_arc.next_to(bottom_line, DOWN)\n",
        "        bottom_arc.set_color(MAROON_B)\n",
        "\n",
        "        return arcs\n",
        "\n",
        "    def get_arc_labels(self, arcs):\n",
        "        top_arc, bottom_arc = arcs\n",
        "        derivative = OldTexText(\"Derivative\")\n",
        "        derivative.next_to(top_arc, UP)\n",
        "        antiderivative = OldTexText(\"``Antiderivative''\")\n",
        "        antiderivative.next_to(bottom_arc, DOWN)\n",
        "        antiderivative.set_color(bottom_arc.get_color())\n",
        "\n",
        "        return VGroup(derivative, antiderivative)\n",
        "\n",
        "class AreaUnderVGraph(PlotVelocity):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add(*self.get_v_graph_and_label())\n",
        "        self.show_rects()\n",
        "\n",
        "    def show_rects(self):\n",
        "        rect_list = self.get_riemann_rectangles_list(\n",
        "            self.v_graph, 7, \n",
        "            max_dx = 1.0,\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "        )\n",
        "        flat_graph = self.get_graph(lambda t : 0)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            flat_graph, x_min = 0, x_max = 8, dx = 1.0\n",
        "        )\n",
        "\n",
        "        for new_rects in rect_list:\n",
        "            new_rects.set_fill(opacity = 0.8)\n",
        "            rects.align_family(new_rects)\n",
        "            for alt_rect in rects[::2]:\n",
        "                alt_rect.set_fill(opacity = 0)\n",
        "            self.play(Transform(\n",
        "                rects, new_rects,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "class ConstantVelocityCar(Scene):\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        car.move_to(5*LEFT + 3*DOWN)\n",
        "\n",
        "        self.add(car)\n",
        "        self.wait()\n",
        "        self.play(MoveCar(\n",
        "            car, 7*RIGHT+3*DOWN,\n",
        "            run_time = 5,\n",
        "            rate_func=linear,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class ConstantVelocityPlot(PlotVelocity):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"Time\",\n",
        "        \"units_of_area_color\" : BLUE_E,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.x_axis_label_mob.shift(DOWN)\n",
        "        self.draw_graph()\n",
        "        self.show_product()\n",
        "        self.comment_on_area_wierdness()\n",
        "        self.note_units()\n",
        "\n",
        "    def draw_graph(self):\n",
        "        graph = self.get_graph(\n",
        "            lambda t : 10,\n",
        "            x_min = 0, \n",
        "            x_max = 8,\n",
        "            color = VELOCITY_COLOR\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(graph, rate_func=linear, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_product(self):\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = DISTANCE_COLOR,\n",
        "            fill_opacity = 0.5\n",
        "        )\n",
        "        rect.replace(\n",
        "            VGroup(self.graph, VectorizedPoint(self.graph_origin)),\n",
        "            stretch = True\n",
        "        )\n",
        "\n",
        "        right_brace = Brace(rect, RIGHT)\n",
        "        top_brace = Brace(rect, UP)\n",
        "        v_label = right_brace.get_text(\n",
        "            \"$10 \\\\frac{\\\\text{meters}}{\\\\text{second}}$\",\n",
        "        )\n",
        "        v_label.set_color(VELOCITY_COLOR)\n",
        "        t_label = top_brace.get_text(\n",
        "            \"8 seconds\"\n",
        "        )\n",
        "        t_label.set_color(TIME_COLOR)\n",
        "\n",
        "        s_label = OldTex(\"10\", \"\\\\times\",  \"8\", \"\\\\text{ meters}\")\n",
        "        s_label.set_color_by_tex(\"10\", VELOCITY_COLOR)\n",
        "        s_label.set_color_by_tex(\"8\", TIME_COLOR)\n",
        "        s_label.move_to(rect)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(right_brace),\n",
        "            Write(v_label),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(top_brace),\n",
        "            Write(t_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Write(s_label),\n",
        "            Animation(self.graph)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.area_rect = rect\n",
        "        self.s_label = s_label\n",
        "\n",
        "    def comment_on_area_wierdness(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        bubble = randy.get_bubble(\n",
        "            \"Distance \\\\\\\\ is area?\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            height = 3,\n",
        "            width = 4,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        bubble.content.scale(0.8)\n",
        "        bubble.content.shift(SMALL_BUFF*UP)\n",
        "        VGroup(bubble[-1], bubble.content).shift(1.5*LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.play(\n",
        "            self.area_rect.set_color, YELLOW,\n",
        "            *list(map(Animation, self.get_mobjects())),\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, randy.bubble,\n",
        "            ShowCreation(bubble), \n",
        "            Write(bubble.content),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "        )\n",
        "\n",
        "        self.randy = randy\n",
        "\n",
        "    def note_units(self):\n",
        "        x_line, y_line  = lines = VGroup(*[\n",
        "            axis.copy()\n",
        "            for axis in (self.x_axis, self.y_axis)\n",
        "        ])\n",
        "        lines.set_color(TIME_COLOR)\n",
        "        square = Square(\n",
        "            stroke_color = BLACK,\n",
        "            stroke_width = 1,\n",
        "            fill_color = self.units_of_area_color,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        square.replace(\n",
        "            VGroup(*[\n",
        "                VectorizedPoint(self.coords_to_point(i, i))\n",
        "                for i in (0, 1)\n",
        "            ]),\n",
        "            stretch = True\n",
        "        )\n",
        "        units_of_area = VGroup(*[\n",
        "            square.copy().move_to(\n",
        "                self.coords_to_point(x, y),\n",
        "                DOWN+LEFT\n",
        "            )\n",
        "            for x in range(8)\n",
        "            for y in range(10)\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(x_line))\n",
        "        self.play(Indicate(self.x_axis_label_mob))\n",
        "        self.play(FadeOut(x_line))\n",
        "        self.play(\n",
        "            ShowCreation(y_line),\n",
        "            self.randy.look_at, self.y_axis_label_mob\n",
        "        )\n",
        "        self.play(Indicate(self.y_axis_label_mob))\n",
        "        self.play(FadeOut(y_line))\n",
        "\n",
        "        for FadeClass in FadeIn, FadeOut:\n",
        "            self.play(\n",
        "                FadeClass(\n",
        "                    units_of_area, \n",
        "                    lag_ratio = 0.5,\n",
        "                    run_time = 3\n",
        "                ),\n",
        "                Animation(self.s_label),\n",
        "                self.randy.look_at, self.area_rect\n",
        "            )\n",
        "        self.play(Blink(self.randy))\n",
        "        self.wait()\n",
        "\n",
        "class PiecewiseConstantCar(Scene):\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        start_point = 5*LEFT\n",
        "        car.move_to(start_point)\n",
        "\n",
        "        self.add(car)\n",
        "        self.wait()\n",
        "        for shift in 2, 6, 12:\n",
        "            car.randy.rotate(np.pi/8)\n",
        "            anim = MoveCar(\n",
        "                car, start_point+shift*RIGHT,\n",
        "                rate_func=linear\n",
        "            )\n",
        "\n",
        "            anim.target_mobject[0].rotate(-np.pi/8)\n",
        "            # for mob in anim.starting_mobject, anim.mobject:\n",
        "            #     mob.randy.rotate(np.pi/6)\n",
        "            self.play(anim)\n",
        "        self.wait()\n",
        "\n",
        "class PiecewiseConstantPlot(PlotVelocity):\n",
        "    CONFIG = {\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"min_graph_proportion\" : 0.1,\n",
        "        \"max_graph_proportion\" : 0.8,\n",
        "        \"num_riemann_approximations\" : 7,\n",
        "        \"riemann_rect_fill_opacity\" : 0.75,\n",
        "        \"tick_size\" : 0.2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_graph()\n",
        "        self.always_changing()\n",
        "        self.show_piecewise_constant_graph()\n",
        "        self.compute_distance_on_each_interval()\n",
        "        self.approximate_original_curve()\n",
        "        self.revert_to_specific_approximation()\n",
        "        self.show_specific_rectangle()\n",
        "        self.show_v_dt_for_all_rectangles()\n",
        "        self.write_integral_symbol()\n",
        "        self.roles_of_dt()\n",
        "        self.what_does_sum_approach()\n",
        "        self.label_integral()\n",
        "\n",
        "    def setup_graph(self):\n",
        "        self.setup_axes()\n",
        "        self.add(*self.get_v_graph_and_label())\n",
        "\n",
        "    def always_changing(self):\n",
        "        dot = Dot()\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        words = OldTexText(\"Always changing\")\n",
        "        group = VGroup(dot, arrow, words)\n",
        "        def update_group(group, alpha):\n",
        "            dot, arrow, words = group\n",
        "            prop = interpolate(\n",
        "                self.min_graph_proportion,\n",
        "                self.max_graph_proportion,\n",
        "                alpha\n",
        "            )\n",
        "            graph_point = self.v_graph.point_from_proportion(prop)\n",
        "            dot.move_to(graph_point)\n",
        "            x_val = self.x_axis.point_to_number(graph_point)\n",
        "            angle = self.angle_of_tangent(x_val, self.v_graph)\n",
        "            angle += np.pi/2\n",
        "            vect = rotate_vector(RIGHT, angle)\n",
        "            arrow.rotate(angle - arrow.get_angle() + np.pi)\n",
        "            arrow.shift(\n",
        "                graph_point + MED_SMALL_BUFF*vect - arrow.get_end()\n",
        "            )\n",
        "            words.next_to(arrow.get_start(), UP)\n",
        "            return group\n",
        "        update_group(group, 0)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow),\n",
        "            DrawBorderThenFill(dot),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            group, update_group,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(group))\n",
        "\n",
        "    def show_piecewise_constant_graph(self):\n",
        "        pw_constant_graph = self.get_pw_constant_graph()\n",
        "        alt_lines = [\n",
        "            line.copy().set_color(YELLOW)\n",
        "            for line in pw_constant_graph[:4]\n",
        "        ]\n",
        "        for line in alt_lines:\n",
        "            line.start_dot = Dot(line.get_start())\n",
        "            line.end_dot = Dot(line.get_end())\n",
        "            VGroup(line.start_dot, line.end_dot).set_color(line.get_color())\n",
        "        line = alt_lines[0]\n",
        "\n",
        "        faders = [self.v_graph, self.v_graph_label]\n",
        "        for mob in faders:\n",
        "            mob.save_state()\n",
        "            mob.generate_target()\n",
        "            mob.target.fade(0.7)\n",
        "\n",
        "        self.play(*list(map(MoveToTarget, faders)))\n",
        "        self.play(ShowCreation(pw_constant_graph, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        for new_line in alt_lines[1:]:\n",
        "            for mob in line.end_dot, new_line.start_dot, new_line:\n",
        "                self.play(Transform(\n",
        "                    line, mob,\n",
        "                    run_time = 1./3\n",
        "                ))\n",
        "            self.remove(line)\n",
        "            self.add(new_line)\n",
        "            self.wait(2)\n",
        "            line = new_line\n",
        "        self.play(FadeOut(line))\n",
        "\n",
        "        self.pw_constant_graph = pw_constant_graph\n",
        "\n",
        "    def compute_distance_on_each_interval(self):\n",
        "        rect_list = self.get_riemann_rectangles_list(\n",
        "            self.v_graph, self.num_riemann_approximations, \n",
        "            max_dx = 1,\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "        )\n",
        "        for rects in rect_list:\n",
        "            rects.set_fill(opacity = self.riemann_rect_fill_opacity)\n",
        "        flat_rects = self.get_riemann_rectangles(\n",
        "            self.get_graph(lambda t : 0),\n",
        "            x_min = 0, x_max = 8, dx = 1\n",
        "        )\n",
        "        rects = rect_list[0]\n",
        "        rect = rects[1]\n",
        "        flat_rects.submobjects[1] = rect.copy()\n",
        "\n",
        "        right_brace = Brace(rect, RIGHT)\n",
        "        top_brace = Brace(rect, UP)\n",
        "        right_brace.label = right_brace.get_text(\"$7\\\\frac{\\\\text{m}}{\\\\text{s}}$\")\n",
        "        top_brace.label = top_brace.get_text(\"$1$s\")\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        for brace in right_brace, top_brace:\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(brace.label, run_time = 1),\n",
        "            )\n",
        "            brace.add(brace.label)\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                flat_rects, rects,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            Animation(right_brace)\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [top_brace, right_brace])))\n",
        "        self.wait()\n",
        "\n",
        "        self.rects = rects\n",
        "        self.rect_list = rect_list\n",
        "\n",
        "    def approximate_original_curve(self):\n",
        "        rects = self.rects\n",
        "        self.play(\n",
        "            FadeOut(self.pw_constant_graph),\n",
        "            *[\n",
        "                m.restore \n",
        "                for m in (self.v_graph, self.v_graph_label)\n",
        "            ]+[Animation(self.rects)]\n",
        "        )\n",
        "        for new_rects in self.rect_list[1:]:\n",
        "            self.transform_between_riemann_rects(rects, new_rects)\n",
        "            self.wait()\n",
        "\n",
        "    def revert_to_specific_approximation(self):\n",
        "        rects = self.rects\n",
        "        rects.save_state()\n",
        "        target_rects = self.rect_list[2]\n",
        "        target_rects.set_fill(opacity = 1)\n",
        "\n",
        "        ticks = self.get_ticks(target_rects)\n",
        "        tick_pair = VGroup(*ticks[4:6])\n",
        "        brace = Brace(tick_pair, DOWN, buff = 0)\n",
        "        dt_label = brace.get_text(\"$dt$\", buff = SMALL_BUFF)\n",
        "\n",
        "        example_text = OldTexText(\n",
        "            \"For example, \\\\\\\\\",\n",
        "            \"$dt$\", \"$=0.25$\"\n",
        "        )\n",
        "        example_text.to_corner(UP+RIGHT)\n",
        "        example_text.set_color_by_tex(\"dt\", YELLOW)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            rects, target_rects,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        rects.restore()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(ticks),\n",
        "            FadeOut(self.x_axis.numbers)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(dt_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                example_text, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                dt_label.copy(),\n",
        "                example_text.get_part_by_tex(\"dt\")\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.rects = rects = target_rects\n",
        "        self.ticks = ticks\n",
        "        self.dt_brace = brace\n",
        "        self.dt_label = dt_label\n",
        "        self.dt_example_text = example_text\n",
        "\n",
        "    def show_specific_rectangle(self):\n",
        "        rects = self.rects\n",
        "        rect = rects[4].copy()\n",
        "        rect_top = Line(\n",
        "            rect.get_corner(UP+LEFT),\n",
        "            rect.get_corner(UP+RIGHT),\n",
        "            color = self.v_graph.get_color()\n",
        "        )\n",
        "\n",
        "        t_vals = [1, 1.25]\n",
        "        t_labels = VGroup(*[\n",
        "            OldTex(\"t=%s\"%str(t))\n",
        "            for t in t_vals\n",
        "        ])\n",
        "        t_labels.scale(0.7)\n",
        "        t_labels.next_to(rect, DOWN)\n",
        "        for vect, label in zip([LEFT, RIGHT], t_labels):\n",
        "            label.shift(1.5*vect)\n",
        "            label.add(Arrow(\n",
        "                label.get_edge_center(-vect),\n",
        "                rect.get_corner(DOWN+vect),\n",
        "                buff = SMALL_BUFF,\n",
        "                tip_length = 0.15,\n",
        "                color = WHITE\n",
        "            ))\n",
        "\n",
        "        v_lines = VGroup()\n",
        "        h_lines = VGroup()\n",
        "        height_labels = VGroup()\n",
        "        for t in t_vals:\n",
        "            v_line = self.get_vertical_line_to_graph(\n",
        "                t, self.v_graph,\n",
        "                color = YELLOW\n",
        "            )\n",
        "            y_axis_point = self.graph_origin[0]*RIGHT\n",
        "            y_axis_point += v_line.get_end()[1]*UP\n",
        "            h_line = DashedLine(v_line.get_end(), y_axis_point)\n",
        "            label = OldTex(\"%.1f\"%v_func(t))\n",
        "            label.scale(0.5)\n",
        "            label.next_to(h_line, LEFT, SMALL_BUFF)\n",
        "            v_lines.add(v_line)\n",
        "            h_lines.add(h_line)\n",
        "            height_labels.add(label)\n",
        "\n",
        "        circle = Circle(radius = 0.25, color = WHITE)\n",
        "        circle.move_to(rect.get_top())\n",
        "\n",
        "        self.play(\n",
        "            rects.set_fill, None, 0.25,\n",
        "            Animation(rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        for label in t_labels:\n",
        "            self.play(FadeIn(label))\n",
        "        self.wait()\n",
        "        for v_line, h_line, label in zip(v_lines, h_lines, height_labels):\n",
        "            self.play(ShowCreation(v_line))\n",
        "            self.play(ShowCreation(h_line))\n",
        "            self.play(Write(label, run_time = 1))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        t_label_copy = t_labels[0].copy()\n",
        "        self.play(\n",
        "            t_label_copy.scale, 1./0.7,\n",
        "            t_label_copy.next_to, self.v_graph_label, DOWN+LEFT, 0\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(t_label_copy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(ShowCreation(rect_top))\n",
        "        self.play(FadeOut(circle))\n",
        "        rect.add(rect_top)\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                rect.stretch_to_fit_height, v_lines[1].get_height(),\n",
        "                rect.move_to, rect.get_bottom(), DOWN,\n",
        "                Animation(v_lines),\n",
        "                run_time = 4,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            group[1]\n",
        "            for group in (v_lines, h_lines, height_labels)\n",
        "        ])))\n",
        "        self.play(\n",
        "            v_lines[0].set_color, RED,\n",
        "            rate_func = there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        area = OldTexText(\n",
        "            \"7$\\\\frac{\\\\text{m}}{\\\\text{s}}$\",\n",
        "            \"$\\\\times$\",\n",
        "            \"0.25s\",\n",
        "            \"=\",\n",
        "            \"1.75m\"\n",
        "        )\n",
        "        area.next_to(rect, RIGHT, LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            area.get_left(), rect.get_center(), \n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "        area.shift(SMALL_BUFF*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(area),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            area, arrow, \n",
        "            v_lines[0], h_lines[0], height_labels[0],\n",
        "            rect, t_labels\n",
        "        ])))\n",
        "\n",
        "    def show_v_dt_for_all_rectangles(self):\n",
        "        dt_brace_group = VGroup(self.dt_brace, self.dt_label)\n",
        "        rects_subset = self.rects[10:20]\n",
        "\n",
        "        last_rect = None\n",
        "        for rect in rects_subset:\n",
        "            brace = Brace(rect, LEFT, buff = 0)\n",
        "            v_t = OldTex(\"v(t)\")\n",
        "            v_t.next_to(brace, LEFT, SMALL_BUFF)\n",
        "            anims = [\n",
        "                rect.set_fill, None, 1,\n",
        "                dt_brace_group.next_to, rect, DOWN, SMALL_BUFF\n",
        "            ]\n",
        "            if last_rect is not None:\n",
        "                anims += [\n",
        "                    last_rect.set_fill, None, 0.25,\n",
        "                    ReplacementTransform(last_brace, brace),\n",
        "                    ReplacementTransform(last_v_t, v_t),\n",
        "                ]\n",
        "            else:\n",
        "                anims += [\n",
        "                    GrowFromCenter(brace),\n",
        "                    Write(v_t)\n",
        "                ]\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "\n",
        "            last_rect = rect\n",
        "            last_brace = brace\n",
        "            last_v_t = v_t\n",
        "\n",
        "        self.v_t = last_v_t\n",
        "        self.v_t_brace = last_brace\n",
        "\n",
        "    def write_integral_symbol(self):\n",
        "        integral = OldTex(\n",
        "            \"\\\\int\", \"^8\", \"_0\", \"v(t)\", \"\\\\,dt\"\n",
        "        )\n",
        "        integral.to_corner(UP+RIGHT)\n",
        "        int_copy = integral.get_part_by_tex(\"int\").copy()\n",
        "        bounds = list(map(integral.get_part_by_tex, [\"0\", \"8\"]))\n",
        "\n",
        "        sum_word = OldTexText(\"``Sum''\")\n",
        "        sum_word.next_to(integral, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "        alt_sum_word = sum_word.copy()\n",
        "        int_symbol = OldTex(\"\\\\int\")\n",
        "        int_symbol.replace(alt_sum_word[1], dim_to_match = 1)\n",
        "        alt_sum_word.submobjects[1] = int_symbol\n",
        "\n",
        "        self.play(FadeOut(self.dt_example_text))\n",
        "        self.play(Write(integral.get_part_by_tex(\"int\")))\n",
        "        self.wait()\n",
        "        self.play(Transform(int_copy, int_symbol))\n",
        "        self.play(Write(alt_sum_word), Animation(int_copy))\n",
        "        self.remove(int_copy)\n",
        "        self.play(ReplacementTransform(alt_sum_word, sum_word))\n",
        "        self.wait()\n",
        "\n",
        "        for bound in bounds:\n",
        "            self.play(Write(bound))\n",
        "        self.wait()\n",
        "        for bound, num in zip(bounds, [0, 8]):\n",
        "            bound_copy = bound.copy()\n",
        "            point = self.coords_to_point(num, 0)\n",
        "            self.play(\n",
        "                bound_copy.scale, 1.5,\n",
        "                bound_copy.next_to, point, DOWN, MED_LARGE_BUFF\n",
        "            )\n",
        "        self.play(ApplyWave(self.ticks, direction = UP))\n",
        "        self.wait()\n",
        "\n",
        "        for mob, tex in (self.v_t, \"v(t)\"), (self.dt_label, \"dt\"):\n",
        "            self.play(ReplacementTransform(\n",
        "                mob.copy().set_color(YELLOW), \n",
        "                integral.get_part_by_tex(tex),\n",
        "                run_time = 2\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        self.integral = integral\n",
        "        self.sum_word = sum_word\n",
        "\n",
        "    def roles_of_dt(self):\n",
        "        rects = self.rects\n",
        "        next_rects = self.rect_list[3]\n",
        "\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        int_dt = self.integral.get_part_by_tex(\"dt\")\n",
        "        dt_copy = int_dt.copy()\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look, UP+RIGHT,\n",
        "            dt_copy.next_to, morty.get_corner(UP+RIGHT), UP,\n",
        "            dt_copy.set_color, YELLOW\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                dt_copy.copy(), int_dt,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            morty.look_at, int_dt\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(dt_copy.copy(), self.dt_label),\n",
        "            morty.look_at, self.dt_label\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                tick.shift, tick.get_height()*UP/2,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back,\n",
        "                    alpha, alpha+0.2,\n",
        "                )\n",
        "            )\n",
        "            for tick, alpha in zip(\n",
        "                self.ticks, \n",
        "                np.linspace(0, 0.8, len(self.ticks))\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        #Shrink dt just a bit\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            rects.set_fill, None, 0.75,\n",
        "            *list(map(FadeOut, [\n",
        "                dt_copy, self.v_t, self.v_t_brace\n",
        "            ]))\n",
        "        )\n",
        "        rects.align_family(next_rects)\n",
        "        for every_other_rect in rects[::2]:\n",
        "            every_other_rect.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            self.dt_brace.stretch, 0.5, 0,\n",
        "            self.dt_brace.move_to, self.dt_brace, LEFT,\n",
        "            ReplacementTransform(\n",
        "                rects, next_rects,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Transform(\n",
        "                self.ticks, self.get_ticks(next_rects),\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "        )\n",
        "        self.rects = rects = next_rects\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda r : r.shift(0.2*UP).set_fill(None, 1),\n",
        "                rect,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back,\n",
        "                    alpha, alpha+0.2,\n",
        "                )\n",
        "            )\n",
        "            for rect, alpha in zip(\n",
        "                rects, \n",
        "                np.linspace(0, 0.8, len(rects))\n",
        "            )\n",
        "        ]+[\n",
        "            morty.change_mode, \"thinking\",\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.morty = morty\n",
        "\n",
        "    def what_does_sum_approach(self):\n",
        "        morty = self.morty\n",
        "        rects = self.rects\n",
        "\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.replace(self.sum_word, stretch = True)\n",
        "        cross.set_color(RED)\n",
        "        brace = Brace(self.integral, DOWN)\n",
        "        dt_to_0 = brace.get_text(\"$dt \\\\to 0$\")\n",
        "\n",
        "        distance_words = OldTexText(\n",
        "            \"Area\", \"= Distance traveled\"\n",
        "        )\n",
        "        distance_words.next_to(rects, UP)\n",
        "        arrow = Arrow(\n",
        "            distance_words[0].get_bottom(),\n",
        "            rects.get_center(),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Why not $\\\\Sigma$?\",\n",
        "            target_mode = \"sassy\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(Write(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(morty, target_mode = \"plain\"),\n",
        "            *list(map(FadeOut, [\n",
        "                cross, self.sum_word, self.ticks,\n",
        "                self.dt_brace, self.dt_label,\n",
        "            ]))\n",
        "        )\n",
        "        self.play(FadeIn(brace), FadeIn(dt_to_0))\n",
        "        for new_rects in self.rect_list[4:]:\n",
        "            rects.align_family(new_rects)\n",
        "            for every_other_rect in rects[::2]:\n",
        "                every_other_rect.set_fill(opacity = 0)\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    rects, new_rects, \n",
        "                    run_time = 2,\n",
        "                    lag_ratio = 0.5\n",
        "                ),\n",
        "                morty.look_at, rects,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(distance_words),\n",
        "            ShowCreation(arrow),\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, distance_words,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        self.area_arrow = arrow\n",
        "\n",
        "    def label_integral(self):\n",
        "        words = OldTexText(\"``Integral of $v(t)$''\")\n",
        "        words.to_edge(UP)\n",
        "        arrow = Arrow(\n",
        "            words.get_right(),\n",
        "            self.integral.get_left()\n",
        "        )\n",
        "\n",
        "        self.play(Indicate(self.integral))\n",
        "        self.play(Write(words, run_time = 2))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda r : r.shift(0.2*UP).set_fill(None, 1),\n",
        "                rect,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back,\n",
        "                    alpha, alpha+0.2,\n",
        "                )\n",
        "            )\n",
        "            for rect, alpha in zip(\n",
        "                self.rects, \n",
        "                np.linspace(0, 0.8, len(self.rects))\n",
        "            )\n",
        "        ]+[\n",
        "            Animation(self.area_arrow),\n",
        "            self.morty.change_mode, \"happy\",\n",
        "            self.morty.look_at, self.rects,\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_pw_constant_graph(self):\n",
        "        result = VGroup()\n",
        "        for left_x in range(8):\n",
        "            xs = [left_x, left_x+1]\n",
        "            y = self.v_graph.underlying_function(left_x)\n",
        "            line = Line(*[\n",
        "                self.coords_to_point(x, y)\n",
        "                for x in xs\n",
        "            ])\n",
        "            line.set_color(self.v_graph.get_color())\n",
        "            result.add(line)\n",
        "        return result\n",
        "\n",
        "    def get_ticks(self, rects):\n",
        "        ticks = VGroup(*[\n",
        "            Line(\n",
        "                point+self.tick_size*UP/2, \n",
        "                point+self.tick_size*DOWN/2\n",
        "            )\n",
        "            for t in np.linspace(0, 8, len(rects)+1)\n",
        "            for point in [self.coords_to_point(t, 0)]\n",
        "        ])\n",
        "        ticks.set_color(YELLOW)\n",
        "        return ticks\n",
        "\n",
        "class DontKnowHowToHandleNonConstant(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"maybe\", UP)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "class CarJourneyApproximation(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_jumps\" : 5,\n",
        "        \"bottom_words\" : \"Approximated motion (5 jumps)\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        points = [5*LEFT + v for v in (UP, 2*DOWN)]\n",
        "        cars = [Car().move_to(point) for point in points]\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        words = [\n",
        "            OldTexText(\"Real motion (smooth)\").shift(3*UP),\n",
        "            OldTexText(self.bottom_words).shift(0.5*DOWN),\n",
        "        ]\n",
        "        words[1].set_color(GREEN)\n",
        "\n",
        "\n",
        "        self.add(h_line, *cars + words)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            MoveCar(\n",
        "                car, point+10*RIGHT,\n",
        "                run_time = 5,\n",
        "                rate_func = rf\n",
        "            )\n",
        "            for car, point, rf in zip(cars, points, [\n",
        "                s_rate_func,\n",
        "                self.get_approximated_rate_func(self.n_jumps)\n",
        "            ])\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def get_approximated_rate_func(self, n):\n",
        "        new_v_rate_func = lambda t : v_rate_func(np.floor(t*n)/n)\n",
        "        max_integral, err = scipy.integrate.quad(\n",
        "            v_rate_func, 0, 1\n",
        "        )\n",
        "        def result(t):\n",
        "            integral, err = scipy.integrate.quad(new_v_rate_func, 0, t)\n",
        "            return integral/max_integral\n",
        "        return result\n",
        "\n",
        "class LessWrongCarJourneyApproximation(CarJourneyApproximation):\n",
        "    CONFIG = {\n",
        "        \"n_jumps\" : 20,\n",
        "        \"bottom_words\" : \"Better approximation (20 jumps)\",\n",
        "    }\n",
        "\n",
        "class TellMeThatsNotSurprising(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Tell me that's \\\\\\\\ not surprising!\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class HowDoesThisHelp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"How does this help\\\\textinterrobang\",\n",
        "            target_mode = \"angry\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"angry\", \"confused\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"You're right.\",\n",
        "            target_mode = \"shruggie\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(*[\"sassy\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class AreaUnderACurve(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"y_max\" : 4,\n",
        "        \"y_min\" : 0,\n",
        "        \"num_iterations\" : 7\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(self.func)\n",
        "        rect_list = self.get_riemann_rectangles_list(\n",
        "            graph, self.num_iterations\n",
        "        )\n",
        "        VGroup(*rect_list).set_fill(opacity = 0.8)\n",
        "        rects = rect_list[0]\n",
        "\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(rects))\n",
        "        for new_rects in rect_list[1:]:\n",
        "            rects.align_family(new_rects)\n",
        "            for every_other_rect in rects[::2]:\n",
        "                every_other_rect.set_fill(opacity = 0)\n",
        "            self.play(Transform(\n",
        "                rects, new_rects,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def func(self, x):\n",
        "        return np.sin(x) + 1\n",
        "\n",
        "class AltAreaUnderCurve(AreaUnderACurve):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : 2*DOWN,\n",
        "        \"x_min\" : -3,\n",
        "        \"x_max\" : 3,\n",
        "        \"x_axis_width\" : 12,\n",
        "        \"y_max\" : 2,\n",
        "        \"y_axis_height\" : 4,\n",
        "    }\n",
        "    def func(self, x):\n",
        "        return np.exp(-x**2)\n",
        "\n",
        "class Chapter1Wrapper(Chapter2Wrapper):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Essence of calculus, chapter 1\",\n",
        "    }\n",
        "\n",
        "class AreaIsDerivative(PlotVelocity, ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"num_rects\" : 400,\n",
        "        \"dT\" : 0.25,\n",
        "        \"variable_point_label\" : \"T\",\n",
        "        \"area_opacity\" : 0.8,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PlotVelocity.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "        self.setup_axes()\n",
        "        self.add(*self.get_v_graph_and_label())\n",
        "        self.x_axis_label_mob.shift(MED_LARGE_BUFF*DOWN)\n",
        "        self.v_graph_label.shift(MED_LARGE_BUFF*DOWN)\n",
        "        self.foreground_mobjects = []\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_variable_area()\n",
        "        self.write_integral()\n",
        "        self.nudge_input()\n",
        "        self.show_rectangle_approximation()\n",
        "\n",
        "    def introduce_variable_area(self):\n",
        "        area = self.area = self.get_area(0, 6)\n",
        "        x_nums = self.x_axis.numbers\n",
        "\n",
        "        self.play(Write(area, run_time = 2))\n",
        "        self.play(FadeOut(self.x_axis.numbers))\n",
        "        self.add_T_label(6)\n",
        "        self.change_area_bounds(\n",
        "            new_t_max = 4,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_integral(self):\n",
        "        integral = OldTex(\"\\\\int\", \"^T\", \"_0\", \"v(t)\", \"\\\\,dt\")\n",
        "        integral.to_corner(UP+RIGHT)\n",
        "        integral.shift(2*LEFT)\n",
        "        top_T = integral.get_part_by_tex(\"T\")\n",
        "        moving_T = self.T_label_group[0]\n",
        "\n",
        "        s_T = OldTex(\"s(T)\", \"= \")\n",
        "        s_T.set_color_by_tex(\"s\", DISTANCE_COLOR)\n",
        "        s_T.next_to(integral, LEFT)\n",
        "\n",
        "        int_arrow, s_arrow = [\n",
        "            Arrow(\n",
        "                mob.get_left(), self.area.get_center(),\n",
        "                color = WHITE\n",
        "            )\n",
        "            for mob in (integral, s_T)\n",
        "        ]\n",
        "\n",
        "        distance_word = OldTexText(\"Distance\")\n",
        "        distance_word.move_to(self.area)\n",
        "\n",
        "        self.play(Write(integral))\n",
        "        self.play(ShowCreation(int_arrow))\n",
        "        self.foreground_mobjects.append(int_arrow)\n",
        "        self.wait()\n",
        "        self.change_area_bounds(\n",
        "            new_t_max = 8,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.play(Indicate(top_T))\n",
        "        self.play(ReplacementTransform(\n",
        "            top_T.copy(), moving_T\n",
        "        ))\n",
        "        self.change_area_bounds(\n",
        "            new_t_max = 3,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(distance_word, run_time = 2))\n",
        "        self.play(\n",
        "            ReplacementTransform(int_arrow, s_arrow),\n",
        "            FadeIn(s_T)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(distance_word))\n",
        "        self.change_area_bounds(new_t_max = 0, run_time = 2)\n",
        "        self.change_area_bounds(\n",
        "            new_t_max = 8, \n",
        "            rate_func=linear,\n",
        "            run_time = 7.9,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_area_bounds(new_t_max = 5)\n",
        "        self.wait()\n",
        "\n",
        "    def nudge_input(self):\n",
        "        dark_area = self.area.copy()\n",
        "        dark_area.set_fill(BLACK, opacity = 0.5)\n",
        "        curr_T = self.x_axis.point_to_number(self.area.get_right())\n",
        "        new_T = curr_T + self.dT\n",
        "\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.75\n",
        "        )\n",
        "        rect.replace(\n",
        "            VGroup(\n",
        "                VectorizedPoint(self.coords_to_point(new_T, 0)),\n",
        "                self.right_v_line,\n",
        "            ),\n",
        "            stretch = True\n",
        "        )\n",
        "\n",
        "        dT_brace = Brace(rect, DOWN, buff = 0)\n",
        "        dT_label = dT_brace.get_text(\"$dT$\", buff = SMALL_BUFF)\n",
        "        dT_label_group = VGroup(dT_label, dT_brace)\n",
        "\n",
        "        ds_label = OldTex(\"ds\")\n",
        "        ds_label.next_to(rect, RIGHT, LARGE_BUFF, UP)\n",
        "        ds_label.set_color(DISTANCE_COLOR)\n",
        "        ds_arrow = Arrow(ds_label.get_left(), rect.get_left())\n",
        "        ds_arrow.set_color(WHITE)\n",
        "\n",
        "        v_brace = Brace(rect, LEFT, buff = SMALL_BUFF)\n",
        "        v_T_label = v_brace.get_text(\"$v(T)$\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.change_area_bounds(new_t_max = new_T)\n",
        "        self.play(\n",
        "            FadeIn(dark_area),\n",
        "            *list(map(Animation, self.foreground_mobjects))\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.T_label_group),\n",
        "            FadeIn(dT_label_group)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(ds_label))\n",
        "        self.play(ShowCreation(ds_arrow))\n",
        "        self.wait(2)\n",
        "        self.play(GrowFromCenter(v_brace))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.v_graph_label.get_part_by_tex(\"v\").copy(),\n",
        "            v_T_label,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Indicate(dT_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.rect = rect\n",
        "        self.dT_label_group = dT_label_group\n",
        "        self.v_T_label_group = VGroup(v_T_label, v_brace)\n",
        "        self.dark_area = dark_area\n",
        "        self.ds_label = ds_label\n",
        "        self.ds_arrow = ds_arrow\n",
        "\n",
        "    def show_rectangle_approximation(self):\n",
        "        formula1 = OldTex(\"ds\", \"=\", \"v(T)\", \"dT\")\n",
        "        formula2 = OldTex(\"{ds\", \"\\\\over\\\\,\", \"dT}\", \"=\", \"v(T)\")\n",
        "        for formula in formula1, formula2:\n",
        "            formula.next_to(self.v_graph_label, UP, LARGE_BUFF)\n",
        "            formula.set_color_by_tex(\"ds\", DISTANCE_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(self.rect),\n",
        "            Animation(self.ds_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mob, formula1.get_part_by_tex(tex),\n",
        "                run_time = 2\n",
        "            )\n",
        "            for mob, tex in [\n",
        "                (self.ds_label, \"ds\"),\n",
        "                (self.ds_arrow, \"=\"),\n",
        "                (self.v_T_label_group[0].copy(), \"v(T)\"),\n",
        "                (self.dT_label_group[0].copy(), \"dT\"),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.transition_to_alt_config(\n",
        "            dT = self.dT/5.0,\n",
        "            transformation_kwargs = {\"run_time\" : 2},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                formula1.get_part_by_tex(tex),\n",
        "                formula2.get_part_by_tex(tex),\n",
        "            )\n",
        "            for tex in (\"ds\", \"=\", \"v(T)\", \"dT\")\n",
        "        ] + [\n",
        "            Write(formula2.get_part_by_tex(\"over\"))\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def add_T_label(self, x_val, **kwargs):\n",
        "        triangle = RegularPolygon(n=3, start_angle = np.pi/2)\n",
        "        triangle.set_height(MED_SMALL_BUFF)\n",
        "        triangle.move_to(self.coords_to_point(x_val, 0), UP)\n",
        "        triangle.set_fill(WHITE, 1)\n",
        "        triangle.set_stroke(width = 0)\n",
        "        T_label = OldTex(self.variable_point_label)\n",
        "        T_label.next_to(triangle, DOWN)\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            x_val, self.v_graph,\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(triangle),\n",
        "            ShowCreation(v_line),\n",
        "            Write(T_label, run_time = 1),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "        self.T_label_group = VGroup(T_label, triangle)\n",
        "        self.right_v_line = v_line\n",
        "\n",
        "    def get_area(self, t_min, t_max):\n",
        "        numerator = max(t_max - t_min, 0.01)\n",
        "        dx = float(numerator) / self.num_rects\n",
        "        return self.get_riemann_rectangles(\n",
        "            self.v_graph,\n",
        "            x_min = t_min,\n",
        "            x_max = t_max,\n",
        "            dx = dx,\n",
        "            stroke_width = 0,\n",
        "        ).set_fill(opacity = self.area_opacity)\n",
        "\n",
        "    def change_area_bounds(self, new_t_min = None, new_t_max = None, **kwargs):\n",
        "        curr_t_min = self.x_axis.point_to_number(self.area.get_left())\n",
        "        curr_t_max = self.x_axis.point_to_number(self.area.get_right())\n",
        "        if new_t_min is None:\n",
        "            new_t_min = curr_t_min\n",
        "        if new_t_max is None:\n",
        "            new_t_max = curr_t_max\n",
        "\n",
        "        group = VGroup(self.area, self.right_v_line, self.T_label_group)\n",
        "        def update_group(group, alpha):\n",
        "            area, v_line, T_label = group\n",
        "            t_min = interpolate(curr_t_min, new_t_min, alpha)\n",
        "            t_max = interpolate(curr_t_max, new_t_max, alpha)\n",
        "            new_area = self.get_area(t_min, t_max)\n",
        "            new_v_line = self.get_vertical_line_to_graph(\n",
        "                t_max, self.v_graph\n",
        "            )\n",
        "            new_v_line.set_color(v_line.get_color())\n",
        "            T_label.move_to(new_v_line.get_bottom(), UP)\n",
        "\n",
        "            #Fade close to 0\n",
        "            T_label[0].set_fill(opacity = min(1, t_max)) \n",
        "\n",
        "            Transform(area, new_area).update(1)\n",
        "            Transform(v_line, new_v_line).update(1)\n",
        "            return group\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(group, update_group),\n",
        "            *list(map(Animation, self.foreground_mobjects)),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "class DirectInterpretationOfDsDt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\"{ds\", \"\\\\over\\\\,\", \"dT}\", \"(T)\", \"=\", \"v(T)\")\n",
        "        ds, over, dt, of_T, equals, v = equation\n",
        "        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n",
        "        equation.shift(RIGHT)\n",
        "        v.set_color(VELOCITY_COLOR)\n",
        "\n",
        "        s_words = OldTexText(\"Tiny change in\", \"distance\")\n",
        "        s_words.next_to(ds, UP+LEFT, LARGE_BUFF)\n",
        "        s_words.shift_onto_screen()\n",
        "        s_arrow = Arrow(s_words[1].get_bottom(), ds.get_left())\n",
        "        s_words.add(s_arrow)\n",
        "        s_words.set_color(DISTANCE_COLOR)\n",
        "\n",
        "        t_words = OldTexText(\"Tiny change in\", \"time\")\n",
        "        t_words.next_to(dt, DOWN+LEFT)\n",
        "        t_words.to_edge(LEFT)\n",
        "        t_arrow = Arrow(t_words[1].get_top(), dt.get_left())\n",
        "        t_words.add(t_arrow)\n",
        "        t_words.set_color(TIME_COLOR)\n",
        "\n",
        "        self.add(ds, over, dt, of_T)\n",
        "        for words, part in (s_words, ds), (t_words, dt):\n",
        "            self.play(\n",
        "                FadeIn(\n",
        "                    words, \n",
        "                    run_time = 2,\n",
        "                    lag_ratio = 0.5,\n",
        "                ),\n",
        "                self.students[1].change_mode, \"raise_right_hand\"\n",
        "            )\n",
        "            self.play(part.set_color, words.get_color())\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(equals, v)))\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class FindAntiderivative(Antiderivative):\n",
        "    def construct(self):\n",
        "        self.introduce()\n",
        "        self.first_part()\n",
        "        self.second_part()\n",
        "        self.combine()\n",
        "        self.add_plus_C()\n",
        "\n",
        "    def introduce(self):\n",
        "        q_marks, rhs = functions = self.get_functions(\"???\", \"t(8-t)\")\n",
        "        expanded_rhs = OldTex(\"8t - t^2\")\n",
        "        expanded_rhs.move_to(rhs, LEFT)\n",
        "        expanded_rhs.set_color(rhs.get_color())\n",
        "        self.v_part1 = VGroup(*expanded_rhs[:2])\n",
        "        self.v_part2 = VGroup(*expanded_rhs[2:])\n",
        "        for part in self.v_part1, self.v_part2:\n",
        "            part.save_state()\n",
        "\n",
        "        top_arc, bottom_arc = arcs = self.get_arcs(functions)\n",
        "        derivative, antiderivative = words = self.get_arc_labels(arcs)\n",
        "\n",
        "        self.add(functions)\n",
        "        self.play(*list(map(ShowCreation, arcs)))\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word, lag_ratio = 0.5))\n",
        "        self.wait()\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                rhs[i], expanded_rhs[j],\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi\n",
        "            )\n",
        "            for i, j in enumerate([1, 4, 0, 2, 3, 4])\n",
        "        ]+[\n",
        "            self.pi_creature.change_mode, \"hesitant\"\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.q_marks = q_marks\n",
        "        self.arcs = arcs\n",
        "        self.words = words\n",
        "\n",
        "    def first_part(self):\n",
        "        four_t_squared, two_t = self.get_functions(\"4t^2\", \"2t\")\n",
        "        four = four_t_squared[0]\n",
        "        four.shift(UP)\n",
        "        four.set_fill(opacity = 0)\n",
        "        t_squared = VGroup(*four_t_squared[1:])\n",
        "        two_t.move_to(self.v_part1, LEFT)\n",
        "\n",
        "        self.play(self.v_part2.to_corner, UP+RIGHT)\n",
        "        self.play(\n",
        "            self.pi_creature.change, \"plain\", self.v_part1\n",
        "        )\n",
        "        self.play(ApplyWave(\n",
        "            self.q_marks, \n",
        "            direction = UP, \n",
        "            amplitude = SMALL_BUFF\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(self.q_marks),\n",
        "            FadeIn(t_squared),\n",
        "            self.v_part1.shift, DOWN+RIGHT,\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                t_squared[i].copy(), two_t[1-i],\n",
        "                run_time = 2,\n",
        "                path_arc = -np.pi/6.\n",
        "            )\n",
        "            for i in (0, 1)\n",
        "        ])\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.play(four.set_fill, YELLOW, 1)\n",
        "        self.play(four.shift, DOWN)\n",
        "        self.play(FadeOut(two_t))\n",
        "        self.play(self.v_part1.restore)\n",
        "        self.play(four.set_color, DISTANCE_COLOR)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.s_part1 = four_t_squared\n",
        "\n",
        "    def second_part(self):\n",
        "        self.arcs_copy = self.arcs.copy()\n",
        "        self.words_copy = self.words.copy()\n",
        "        part1_group = VGroup(\n",
        "            self.s_part1, self.v_part1, \n",
        "            self.arcs_copy, self.words_copy\n",
        "        )\n",
        "\n",
        "        neg_third_t_cubed, three_t_squared = self.get_functions(\n",
        "            \"- \\\\frac{1}{3} t^3\", \"3t^2\"\n",
        "        )\n",
        "        three_t_squared.move_to(self.v_part1, LEFT)\n",
        "        neg = neg_third_t_cubed[0]\n",
        "        third = VGroup(*neg_third_t_cubed[1:4])\n",
        "        t_cubed = VGroup(*neg_third_t_cubed[4:])\n",
        "        three = three_t_squared[0]\n",
        "        t_squared = VGroup(*three_t_squared[1:])\n",
        "\n",
        "        self.play(\n",
        "            part1_group.scale, 0.5,\n",
        "            part1_group.to_corner, UP+LEFT,\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(\n",
        "            self.v_part2.restore,\n",
        "            self.v_part2.shift, LEFT\n",
        "        )\n",
        "        self.play(FadeIn(self.q_marks))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.q_marks),\n",
        "            FadeIn(t_cubed),\n",
        "            self.v_part2.shift, DOWN+RIGHT\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                t_cubed[i].copy(), three_t_squared[j],\n",
        "                path_arc = -np.pi/6,\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for i, j in [(0, 1), (1, 0), (1, 2)]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(FadeIn(third))\n",
        "        self.play(FadeOut(three))\n",
        "        self.wait(2)\n",
        "        self.play(Write(neg))\n",
        "        self.play(\n",
        "            FadeOut(t_squared),\n",
        "            self.v_part2.shift, UP+LEFT\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.s_part2 = neg_third_t_cubed\n",
        "\n",
        "    def combine(self):\n",
        "        self.play(\n",
        "            self.v_part1.restore,\n",
        "            self.v_part2.restore,\n",
        "            self.s_part1.scale, 2,\n",
        "            self.s_part1.next_to, self.s_part2, LEFT,\n",
        "            FadeOut(self.arcs_copy),\n",
        "            FadeOut(self.words_copy),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def add_plus_C(self):\n",
        "        s_group = VGroup(self.s_part1, self.s_part2)\n",
        "        plus_Cs = [\n",
        "            OldTex(\"+%d\"%d)\n",
        "            for d in range(1, 8)\n",
        "        ]\n",
        "        for plus_C in plus_Cs:\n",
        "            plus_C.set_color(YELLOW)\n",
        "            plus_C.move_to(s_group, RIGHT)\n",
        "        plus_C = plus_Cs[0]\n",
        "\n",
        "        self.change_mode(\"sassy\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_group.next_to, plus_C.copy(), LEFT,\n",
        "            GrowFromCenter(plus_C),\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_plus_C in plus_Cs[1:]:\n",
        "            self.play(Transform(plus_C, new_plus_C))\n",
        "            self.wait()\n",
        "\n",
        "class GraphSPlusC(GraphDistanceVsTime):\n",
        "    CONFIG = {\n",
        "        \"y_axis_label\" : \"Distance\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(\n",
        "            s_func, \n",
        "            color = DISTANCE_COLOR,\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "        )\n",
        "        tangent = self.get_secant_slope_group(\n",
        "            6, graph, dx = 0.01\n",
        "        ).secant_line\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            6, graph, line_class = DashedLine\n",
        "        )\n",
        "        v_line.scale(2)\n",
        "        v_line.set_color(WHITE)\n",
        "        graph_label, plus_C = full_label = OldTex(\n",
        "            \"s(t) = 4t^2 - \\\\frac{1}{3}t^3\", \"+C\"\n",
        "        )\n",
        "        plus_C.set_color(YELLOW)\n",
        "        full_label.next_to(graph.get_points()[-1], DOWN)\n",
        "        full_label.to_edge(RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(FadeIn(graph_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            graph.shift, UP,\n",
        "            run_time = 2,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(ShowCreation(tangent))\n",
        "        graph.add(tangent)\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            graph.shift, 2*DOWN, \n",
        "            run_time = 4,\n",
        "            rate_func = there_and_back,\n",
        "        )\n",
        "        self.play(Write(plus_C))\n",
        "        self.play(\n",
        "            graph.shift, 2*UP,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class LowerBound(AreaIsDerivative):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : 2.5*DOWN + 6*LEFT\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_integral_and_area()\n",
        "        self.mention_lower_bound()\n",
        "        self.drag_right_endpoint_to_zero()\n",
        "        self.write_antiderivative_difference()\n",
        "        self.show_alternate_antiderivative_difference()\n",
        "        self.add_constant_to_antiderivative()\n",
        "\n",
        "    def add_integral_and_area(self):\n",
        "        self.area = self.get_area(0, 6)\n",
        "        self.integral = self.get_integral(\"0\", \"T\")\n",
        "        self.remove(self.x_axis.numbers)\n",
        "        self.add(self.area, self.integral)\n",
        "        self.add_T_label(6, run_time = 0)\n",
        "\n",
        "    def mention_lower_bound(self):\n",
        "        lower_bound = self.integral.get_part_by_tex(\"0\")\n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(lower_bound)\n",
        "        circle.scale(3)\n",
        "        zero_label = lower_bound.copy()\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(Indicate(lower_bound))\n",
        "        self.play(\n",
        "            zero_label.scale, 1.5,\n",
        "            zero_label.next_to, self.graph_origin, DOWN, MED_LARGE_BUFF,\n",
        "            FadeOut(circle)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.zero_label = zero_label\n",
        "\n",
        "    def drag_right_endpoint_to_zero(self):\n",
        "        zero_integral = self.get_integral(\"0\", \"0\")\n",
        "        zero_integral[1].set_color(YELLOW)\n",
        "        zero_int_bounds = list(reversed(\n",
        "            zero_integral.get_parts_by_tex(\"0\")\n",
        "        ))\n",
        "        for bound in zero_int_bounds:\n",
        "            circle = Circle(color = YELLOW)\n",
        "            circle.replace(bound)\n",
        "            circle.scale(3)\n",
        "            bound.circle = circle\n",
        "        self.integral.save_state()\n",
        "        equals_zero = OldTex(\"=0\")\n",
        "        equals_zero.next_to(zero_integral, RIGHT)\n",
        "        equals_zero.set_color(GREEN)\n",
        "\n",
        "        self.change_area_bounds(0, 0, run_time = 3)\n",
        "        self.play(ReplacementTransform(\n",
        "            self.zero_label.copy(), equals_zero\n",
        "        ))\n",
        "        self.play(Transform(self.integral, zero_integral))\n",
        "        self.wait(2)\n",
        "        for bound in zero_int_bounds:\n",
        "            self.play(ShowCreation(bound.circle))\n",
        "            self.play(FadeOut(bound.circle))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                bound.copy(), VGroup(equals_zero[1])\n",
        "            )\n",
        "            for bound in zero_int_bounds\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.change_area_bounds(0, 5)\n",
        "        self.play(\n",
        "            self.integral.restore,\n",
        "            FadeOut(equals_zero)\n",
        "        )\n",
        "\n",
        "        self.zero_integral = zero_integral\n",
        "\n",
        "    def write_antiderivative_difference(self):\n",
        "        antideriv_diff = self.get_antiderivative_difference(\"0\", \"T\")\n",
        "        equals, at_T, minus, at_zero = antideriv_diff\n",
        "        antideriv_diff_at_eight = self.get_antiderivative_difference(\"0\", \"8\")\n",
        "        at_eight = antideriv_diff_at_eight.left_part\n",
        "        integral_at_eight = self.get_integral(\"0\", \"8\")\n",
        "\n",
        "        for part in at_T, at_zero, at_eight:\n",
        "            part.brace = Brace(part, DOWN, buff = SMALL_BUFF)\n",
        "            part.brace.save_state()\n",
        "\n",
        "        antideriv_text = at_T.brace.get_text(\"Antiderivative\", buff = SMALL_BUFF)\n",
        "        antideriv_text.set_color(MAROON_B)\n",
        "        value_at_eight = at_eight.brace.get_text(\n",
        "            \"%.2f\"%s_func(8)\n",
        "        )\n",
        "        happens_to_be_zero = at_zero.brace.get_text(\"\"\"\n",
        "            Happens to\n",
        "            equal 0\n",
        "        \"\"\")\n",
        "\n",
        "        big_brace = Brace(VGroup(at_T, at_zero))\n",
        "        cancel_text = big_brace.get_text(\"Cancels when $T=0$\")\n",
        "\n",
        "        self.play(*list(map(Write, [equals, at_T])))\n",
        "        self.play(\n",
        "            GrowFromCenter(at_T.brace),\n",
        "            Write(antideriv_text, run_time = 2)\n",
        "        )\n",
        "        self.change_area_bounds(0, 5.5, rate_func = there_and_back)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(at_T.copy(), at_zero),\n",
        "            Write(minus)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(at_T.brace, big_brace),\n",
        "            ReplacementTransform(antideriv_text, cancel_text)\n",
        "        )\n",
        "        self.change_area_bounds(0, 0, run_time = 4)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(big_brace, at_zero.brace),\n",
        "            ReplacementTransform(cancel_text, happens_to_be_zero),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.change_area_bounds(0, 8, run_time = 2)\n",
        "        self.play(\n",
        "            Transform(self.integral, integral_at_eight),\n",
        "            Transform(antideriv_diff, antideriv_diff_at_eight),\n",
        "            MaintainPositionRelativeTo(at_zero.brace, at_zero),\n",
        "            MaintainPositionRelativeTo(happens_to_be_zero, at_zero.brace),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(at_eight.brace),\n",
        "            Write(value_at_eight)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            at_eight.brace, value_at_eight,\n",
        "            at_zero.brace, happens_to_be_zero,\n",
        "        ])))\n",
        "\n",
        "        self.antideriv_diff = antideriv_diff\n",
        "\n",
        "    def show_alternate_antiderivative_difference(self):\n",
        "        new_integral = self.get_integral(\"1\", \"7\")\n",
        "        new_antideriv_diff = self.get_antiderivative_difference(\"1\", \"7\")\n",
        "        numbers = [\n",
        "            OldTex(\"%d\"%d).next_to(\n",
        "                self.coords_to_point(d, 0), \n",
        "                DOWN, MED_LARGE_BUFF\n",
        "            )\n",
        "            for d in (1, 7)\n",
        "        ]\n",
        "        tex_mobs = [new_integral]+new_antideriv_diff[1::2]+numbers\n",
        "        for tex_mob in tex_mobs:\n",
        "            tex_mob.set_color_by_tex(\"1\", RED)\n",
        "            tex_mob.set_color_by_tex(\"7\", GREEN)\n",
        "            tex_mob.set_color_by_tex(\"\\\\frac{1}{3}\", WHITE)\n",
        "\n",
        "        self.change_area_bounds(1, 7, run_time = 2)\n",
        "        self.play(\n",
        "            self.T_label_group[0].set_fill, None, 0,\n",
        "            *list(map(FadeIn, numbers))\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(self.integral, new_integral),\n",
        "            Transform(self.antideriv_diff, new_antideriv_diff),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        for part in self.antideriv_diff[1::2]:\n",
        "            self.play(Indicate(part, scale_factor = 1.1))\n",
        "            self.wait()\n",
        "\n",
        "    def add_constant_to_antiderivative(self):\n",
        "        antideriv_diff = self.antideriv_diff\n",
        "        plus_fives = VGroup(*[Tex(\"+5\") for i in range(2)])\n",
        "        plus_fives.set_color(YELLOW)\n",
        "        for five, part in zip(plus_fives, antideriv_diff[1::2]):\n",
        "            five.next_to(part, DOWN)\n",
        "        group = VGroup(\n",
        "            plus_fives[0],\n",
        "            antideriv_diff[2].copy(),\n",
        "            plus_fives[1]\n",
        "        )\n",
        "\n",
        "        self.play(Write(plus_fives, run_time = 2))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            group.arrange,\n",
        "            group.next_to, antideriv_diff, DOWN, MED_LARGE_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(group, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_integral(self, lower_bound, upper_bound):\n",
        "        result = OldTex(\n",
        "            \"\\\\int\", \"^\"+upper_bound, \"_\"+lower_bound, \n",
        "            \"t(8-t)\", \"\\\\,dt\"\n",
        "        )\n",
        "        result.next_to(self.graph_origin, RIGHT, MED_LARGE_BUFF)\n",
        "        result.to_edge(UP)\n",
        "        return result\n",
        "\n",
        "    def get_antiderivative_difference(self, lower_bound, upper_bound):\n",
        "        strings = []\n",
        "        for bound in upper_bound, lower_bound:\n",
        "            try:\n",
        "                d = int(bound)\n",
        "                strings.append(\"(%d)\"%d)\n",
        "            except:\n",
        "                strings.append(bound)\n",
        "        parts = []\n",
        "        for s in strings:\n",
        "            part = OldTex(\n",
        "                \"\\\\left(\",\n",
        "                \"4\", s, \"^2\", \"-\", \"\\\\frac{1}{3}\", s, \"^3\"\n",
        "                \"\\\\right))\"\n",
        "            )\n",
        "            part.set_color_by_tex(s, YELLOW, substring = False)\n",
        "            parts.append(part)\n",
        "        result = VGroup(\n",
        "            OldTex(\"=\"), parts[0], \n",
        "            OldTex(\"-\"), parts[1],\n",
        "        )\n",
        "        result.left_part, result.right_part = parts\n",
        "        result.arrange(RIGHT)\n",
        "        result.scale(0.9)\n",
        "        result.next_to(self.integral, RIGHT)\n",
        "        return result\n",
        "\n",
        "class FundamentalTheorem(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"lower_bound\" : 1,\n",
        "        \"upper_bound\" : 7,\n",
        "        \"lower_bound_color\" : RED,\n",
        "        \"upper_bound_color\" : GREEN,\n",
        "        \"n_riemann_iterations\" : 6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_graph_and_integral()\n",
        "        self.show_f_dx_sum()\n",
        "        self.show_rects_approaching_area()\n",
        "        self.write_antiderivative()\n",
        "        self.write_fundamental_theorem_of_calculus()\n",
        "        self.show_integral_considering_continuum()\n",
        "        self.show_antiderivative_considering_bounds()\n",
        "\n",
        "    def add_graph_and_integral(self):\n",
        "        self.setup_axes()\n",
        "        integral = OldTex(\"\\\\int\", \"^b\", \"_a\", \"f(x)\", \"\\\\,dx\")\n",
        "        integral.next_to(ORIGIN, LEFT)\n",
        "        integral.to_edge(UP)\n",
        "        integral.set_color_by_tex(\"a\", self.lower_bound_color)\n",
        "        integral.set_color_by_tex(\"b\", self.upper_bound_color)\n",
        "        graph = self.get_graph(\n",
        "            lambda x : -0.01*x*(x-3)*(x-6)*(x-12) + 3,\n",
        "        )\n",
        "        self.add(integral, graph)\n",
        "        self.graph = graph\n",
        "        self.integral = integral\n",
        "\n",
        "        self.bound_labels = VGroup()\n",
        "        self.v_lines = VGroup()\n",
        "        for bound, tex in (self.lower_bound, \"a\"), (self.upper_bound, \"b\"):\n",
        "            label = integral.get_part_by_tex(tex).copy()\n",
        "            label.scale(1.5)\n",
        "            label.next_to(self.coords_to_point(bound, 0), DOWN)\n",
        "            v_line = self.get_vertical_line_to_graph(\n",
        "                bound, graph, color = label.get_color()\n",
        "            )\n",
        "\n",
        "            self.bound_labels.add(label)\n",
        "            self.v_lines.add(v_line)\n",
        "            self.add(label, v_line)\n",
        "\n",
        "    def show_f_dx_sum(self):\n",
        "        kwargs = {\n",
        "            \"x_min\" : self.lower_bound,\n",
        "            \"x_max\" : self.upper_bound,\n",
        "            \"fill_opacity\" : 0.75,\n",
        "            \"stroke_width\" : 0.25,\n",
        "        }\n",
        "        low_opacity = 0.25\n",
        "        start_rect_index = 3\n",
        "        num_shown_sum_steps = 5\n",
        "        last_rect_index = start_rect_index + num_shown_sum_steps + 1\n",
        "\n",
        "        self.rect_list = self.get_riemann_rectangles_list(\n",
        "            self.graph, self.n_riemann_iterations, **kwargs\n",
        "        )\n",
        "        rects = self.rects = self.rect_list[0]\n",
        "        rects.save_state()\n",
        "\n",
        "        start_rect = rects[start_rect_index]\n",
        "        f_brace = Brace(start_rect, LEFT, buff = 0)\n",
        "        dx_brace = Brace(start_rect, DOWN, buff = 0)\n",
        "        f_brace.label = f_brace.get_text(\"$f(x)$\")\n",
        "        dx_brace.label = dx_brace.get_text(\"$dx$\")\n",
        "\n",
        "        flat_rects = self.get_riemann_rectangles(\n",
        "            self.get_graph(lambda x : 0), dx = 0.5, **kwargs\n",
        "        )\n",
        "\n",
        "        self.transform_between_riemann_rects(\n",
        "            flat_rects, rects, \n",
        "            replace_mobject_with_target_in_scene = True,\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                rect.set_fill, None, \n",
        "                1 if rect is start_rect else low_opacity\n",
        "            )\n",
        "            for rect in rects\n",
        "        ])\n",
        "        self.play(*it.chain(\n",
        "            list(map(GrowFromCenter, [f_brace, dx_brace])),\n",
        "            list(map(Write, [f_brace.label, dx_brace.label])),\n",
        "        ))\n",
        "        self.wait()\n",
        "        for i in range(start_rect_index+1, last_rect_index):\n",
        "            self.play(\n",
        "                rects[i-1].set_fill, None, low_opacity,\n",
        "                rects[i].set_fill, None, 1,\n",
        "                f_brace.set_height, rects[i].get_height(),\n",
        "                f_brace.next_to, rects[i], LEFT, 0,\n",
        "                dx_brace.next_to, rects[i], DOWN, 0,\n",
        "                *[\n",
        "                    MaintainPositionRelativeTo(brace.label, brace)\n",
        "                    for brace in (f_brace, dx_brace)\n",
        "                ]\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeOut, [\n",
        "                f_brace, dx_brace, \n",
        "                f_brace.label, dx_brace.label\n",
        "            ])),\n",
        "            [rects.set_fill, None, kwargs[\"fill_opacity\"]]\n",
        "        ))\n",
        "\n",
        "    def show_rects_approaching_area(self):\n",
        "        for new_rects in self.rect_list:\n",
        "            self.transform_between_riemann_rects(\n",
        "                self.rects, new_rects\n",
        "            )\n",
        "\n",
        "    def write_antiderivative(self):\n",
        "        deriv = OldTex(\n",
        "            \"{d\", \"F\", \"\\\\over\\\\,\", \"dx}\", \"(x)\", \"=\", \"f(x)\"\n",
        "        )\n",
        "        deriv_F = deriv.get_part_by_tex(\"F\")\n",
        "        deriv.next_to(self.integral, DOWN, MED_LARGE_BUFF)\n",
        "        rhs = OldTex(*\"=F(b)-F(a)\")\n",
        "        rhs.set_color_by_tex(\"a\", self.lower_bound_color)\n",
        "        rhs.set_color_by_tex(\"b\", self.upper_bound_color)\n",
        "        rhs.next_to(self.integral, RIGHT)\n",
        "\n",
        "        self.play(Write(deriv))\n",
        "        self.wait(2)\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ReplacementTransform(deriv_F.copy(), part)\n",
        "                for part in rhs.get_parts_by_tex(\"F\")\n",
        "            ],\n",
        "            [\n",
        "                Write(VGroup(*rhs.get_parts_by_tex(tex)))\n",
        "                for tex in \"=()-\"\n",
        "            ]\n",
        "        ))\n",
        "        for tex in \"b\", \"a\":\n",
        "            self.play(ReplacementTransform(\n",
        "                self.integral.get_part_by_tex(tex).copy(),\n",
        "                rhs.get_part_by_tex(tex)\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "        self.deriv = deriv\n",
        "        self.rhs = rhs\n",
        "\n",
        "    def write_fundamental_theorem_of_calculus(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Fundamental \n",
        "            theorem of \n",
        "            calculus\n",
        "        \"\"\")\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "    def show_integral_considering_continuum(self):\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.set_fill, None, 0.2)\n",
        "            for mob in (self.deriv, self.rhs)\n",
        "        ])\n",
        "        self.play(\n",
        "            self.rects.restore,\n",
        "            run_time = 3,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(*[\n",
        "                ApplyFunction(\n",
        "                    lambda m : m.shift(MED_SMALL_BUFF*UP).set_fill(opacity = 1),\n",
        "                    rect,\n",
        "                    run_time = 3,\n",
        "                    rate_func = squish_rate_func(\n",
        "                        there_and_back,\n",
        "                        alpha, alpha+0.2\n",
        "                    )\n",
        "                )\n",
        "                for rect, alpha in zip(\n",
        "                    self.rects, \n",
        "                    np.linspace(0, 0.8, len(self.rects))\n",
        "                )\n",
        "            ])\n",
        "        self.wait()\n",
        "\n",
        "    def show_antiderivative_considering_bounds(self):\n",
        "        self.play(\n",
        "            self.integral.set_fill, None, 0.5,\n",
        "            self.deriv.set_fill, None, 1,\n",
        "            self.rhs.set_fill, None, 1,\n",
        "        )\n",
        "        for label, line in reversed(list(zip(self.bound_labels, self.v_lines))):\n",
        "            new_line = line.copy().set_color(YELLOW)\n",
        "            label.save_state()\n",
        "            self.play(label.set_color, YELLOW)\n",
        "            self.play(ShowCreation(new_line))\n",
        "            self.play(ShowCreation(line))\n",
        "            self.remove(new_line)\n",
        "            self.play(label.restore)\n",
        "        self.wait()\n",
        "        self.play(self.integral.set_fill, None, 1)\n",
        "        self.wait(3)\n",
        "\n",
        "class LetsRecap(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Let's recap\",\n",
        "            target_mode = \"hesitant\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class NegativeArea(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"Time\",\n",
        "        \"y_axis_label\" : \"Velocity\",\n",
        "        \"graph_origin\" : 1.5*DOWN + 5*LEFT,\n",
        "        \"y_min\" : -3,\n",
        "        \"y_max\" : 7,\n",
        "        \"small_dx\" : 0.01,\n",
        "        \"sample_input\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graph_and_area()\n",
        "        self.write_negative_area()\n",
        "        self.show_negative_point()\n",
        "        self.show_car_going_backwards()\n",
        "        self.write_v_dt()\n",
        "        self.show_rectangle()\n",
        "        self.write_signed_area()\n",
        "\n",
        "    def add_graph_and_area(self):\n",
        "        graph = self.get_graph(\n",
        "            lambda x : -0.02*(x+1)*(x-3)*(x-7)*(x-10),\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "            color = VELOCITY_COLOR\n",
        "        )\n",
        "        area = self.get_riemann_rectangles(\n",
        "            graph, \n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "            dx = self.small_dx,\n",
        "            start_color = BLUE_D,\n",
        "            end_color = BLUE_D,\n",
        "            fill_opacity = 0.75,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "\n",
        "        self .play(\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(\n",
        "                area, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.graph = graph\n",
        "        self.area = area\n",
        "\n",
        "    def write_negative_area(self):\n",
        "        words = OldTexText(\"Negative area\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(\n",
        "            self.coords_to_point(7, -2),\n",
        "            RIGHT,\n",
        "        )\n",
        "        arrow = Arrow(words, self.coords_to_point(\n",
        "            self.sample_input, -1,\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [self.area, arrow])))\n",
        "\n",
        "        self.negative_area_words = words\n",
        "\n",
        "    def show_negative_point(self):\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.sample_input, self.graph,\n",
        "            color = RED\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.v_line = v_line\n",
        "\n",
        "    def show_car_going_backwards(self):\n",
        "        car = Car()\n",
        "        start_point = 3*RIGHT + 2*UP\n",
        "        end_point = start_point + LEFT\n",
        "        nudged_end_point = end_point + MED_SMALL_BUFF*LEFT\n",
        "        car.move_to(start_point)\n",
        "        arrow = Arrow(RIGHT, LEFT, color = RED)\n",
        "        arrow.next_to(car, UP+LEFT)\n",
        "        arrow.shift(MED_LARGE_BUFF*RIGHT)\n",
        "\n",
        "        self.play(FadeIn(car))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(MoveCar(\n",
        "            car, end_point, \n",
        "            moving_forward = False,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "        ghost_car = car.copy().fade()\n",
        "        right_nose_line = self.get_car_nose_line(car)\n",
        "        self.play(ShowCreation(right_nose_line))\n",
        "        self.add(ghost_car)\n",
        "        self.play(MoveCar(\n",
        "            car, nudged_end_point,\n",
        "            moving_forward = False\n",
        "        ))\n",
        "        left_nose_line = self.get_car_nose_line(car)\n",
        "        self.play(ShowCreation(left_nose_line))\n",
        "\n",
        "        self.nose_lines = VGroup(left_nose_line, right_nose_line)\n",
        "        self.car = car\n",
        "        self.ghost_car = ghost_car\n",
        "\n",
        "    def write_v_dt(self):\n",
        "        brace = Brace(self.nose_lines, DOWN, buff = 0)\n",
        "        equation = OldTex(\"ds\", \"=\", \"v(t)\", \"dt\")\n",
        "        equation.next_to(brace, DOWN, SMALL_BUFF, LEFT)\n",
        "        equation.set_color_by_tex(\"ds\", DISTANCE_COLOR)\n",
        "        equation.set_color_by_tex(\"dt\", TIME_COLOR)\n",
        "\n",
        "        negative = OldTexText(\"Negative\")\n",
        "        negative.set_color(RED)\n",
        "        negative.next_to(equation.get_corner(UP+RIGHT), UP, LARGE_BUFF)\n",
        "        ds_arrow, v_arrow = arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                negative.get_bottom(),\n",
        "                equation.get_part_by_tex(tex).get_top(),\n",
        "                color = RED,\n",
        "            )\n",
        "            for tex in (\"ds\", \"v(t)\")\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(equation)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(negative))\n",
        "        self.play(ShowCreation(v_arrow))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            v_arrow.copy(),\n",
        "            ds_arrow\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.ds_equation = equation\n",
        "        self.negative_word = negative\n",
        "        self.negative_word_arrows = arrows\n",
        "\n",
        "    def show_rectangle(self):\n",
        "        rect_list = self.get_riemann_rectangles_list(\n",
        "            self.graph, x_min = 0, x_max = 8,\n",
        "            n_iterations = 6,\n",
        "            start_color = BLUE_D,\n",
        "            end_color = BLUE_D,\n",
        "            fill_opacity = 0.75,\n",
        "        )\n",
        "        rects = rect_list[0]\n",
        "        rect = rects[len(rects)*self.sample_input//8]\n",
        "\n",
        "        dt_brace = Brace(rect, UP, buff = 0)\n",
        "        v_brace = Brace(rect, LEFT, buff = 0)\n",
        "        dt_label = dt_brace.get_text(\"$dt$\", buff = SMALL_BUFF)\n",
        "        dt_label.set_color(YELLOW)\n",
        "        v_label = v_brace.get_text(\"$v(t)$\", buff = SMALL_BUFF)\n",
        "        v_label.add_background_rectangle()\n",
        "\n",
        "        self.play(FadeOut(self.v_line), FadeIn(rect))\n",
        "        self.play(\n",
        "            GrowFromCenter(dt_brace), \n",
        "            GrowFromCenter(v_brace), \n",
        "            Write(dt_label),\n",
        "            Write(v_label),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*it.chain(\n",
        "            [FadeIn(r) for r in rects if r is not rect],\n",
        "            list(map(FadeOut, [\n",
        "                dt_brace, v_brace, dt_label, v_label\n",
        "            ]))\n",
        "        ))\n",
        "        self.wait()\n",
        "        for new_rects in rect_list[1:]:\n",
        "            self.transform_between_riemann_rects(rects, new_rects)\n",
        "        self.wait()\n",
        "\n",
        "    def write_signed_area(self):\n",
        "        words = OldTexText(\"``Signed area''\")\n",
        "        words.next_to(self.coords_to_point(self.sample_input, 0), UP)\n",
        "        symbols = VGroup(*[\n",
        "            OldTex(sym).move_to(self.coords_to_point(*coords))\n",
        "            for sym, coords in [\n",
        "                (\"+\", (1, 2)),\n",
        "                (\"-\", (5, -1)),\n",
        "                (\"+\", (7.6, 0.5)),\n",
        "            ]\n",
        "        ])\n",
        "        self.play(Write(words))\n",
        "        self.play(Write(symbols))\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_car_nose_line(self, car):\n",
        "        line = DashedLine(car.get_top(), car.get_bottom())\n",
        "        line.move_to(car.get_right())\n",
        "        return line\n",
        "\n",
        "class NextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        next_video = series[8]\n",
        "        integral = OldTex(\"\\\\int\")\n",
        "        integral.next_to(next_video, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(series, lag_ratio = 0.5))\n",
        "        self.play(\n",
        "            next_video.set_color, YELLOW,\n",
        "            next_video.shift, next_video.get_height()*DOWN/2,\n",
        "            self.teacher.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(Write(integral))\n",
        "        self.wait(5)\n",
        "\n",
        "class Chapter8PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek Dai\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mark Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(Chapter1Thumbnail):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"graph_origin\" : 1.5*DOWN + 4*LEFT,\n",
        "        \"y_axis_height\" : 5,\n",
        "        \"x_max\" : 5,\n",
        "        \"x_axis_width\" : 11,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.remove(*self.x_axis.numbers)\n",
        "        self.remove(*self.y_axis.numbers)\n",
        "        graph = self.get_graph(self.func)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            graph,\n",
        "            x_min = 0,\n",
        "            x_max = 4,\n",
        "            dx = 0.25,\n",
        "        )\n",
        "        words = OldTexText(\"Integrals\")\n",
        "        words.set_width(8)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(graph, rects, words)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}