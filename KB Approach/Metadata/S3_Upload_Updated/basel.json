{
    "topic": "demonstrates the concept of updating an angle in real-time using a ContinualAnimation",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from once_useful_constructs.light import *\n",
        "\n",
        "import warnings\n",
        "warnings.warn(\"\"\"\n",
        "    Warning: This file makes use of\n",
        "    ContinualAnimation, which has since\n",
        "    been deprecated\n",
        "\"\"\")\n",
        "\n",
        "import types\n",
        "import functools\n",
        "\n",
        "LIGHT_COLOR = YELLOW\n",
        "INDICATOR_RADIUS = 0.7\n",
        "INDICATOR_STROKE_WIDTH = 1\n",
        "INDICATOR_STROKE_COLOR = WHITE\n",
        "INDICATOR_TEXT_COLOR = WHITE\n",
        "INDICATOR_UPDATE_TIME = 0.2\n",
        "FAST_INDICATOR_UPDATE_TIME = 0.1\n",
        "OPACITY_FOR_UNIT_INTENSITY = 0.2\n",
        "SWITCH_ON_RUN_TIME = 1.5\n",
        "FAST_SWITCH_ON_RUN_TIME = 0.1\n",
        "NUM_CONES = 7 # in first lighthouse scene\n",
        "NUM_VISIBLE_CONES = 5 # ibidem\n",
        "ARC_TIP_LENGTH = 0.2\n",
        "\n",
        "NUM_LEVELS = 15\n",
        "AMBIENT_FULL = 0.8\n",
        "AMBIENT_DIMMED = 0.5\n",
        "AMBIENT_SCALE = 2.0\n",
        "AMBIENT_RADIUS = 20.0\n",
        "SPOTLIGHT_FULL = 0.8\n",
        "SPOTLIGHT_DIMMED = 0.2\n",
        "SPOTLIGHT_SCALE = 1.0\n",
        "SPOTLIGHT_RADIUS = 20.0\n",
        "\n",
        "LIGHT_COLOR = YELLOW\n",
        "DEGREES = TAU/360\n",
        "\n",
        "\n",
        "BASELINE_YPOS = -2.5\n",
        "OBSERVER_POINT = np.array([0,BASELINE_YPOS,0])\n",
        "LAKE0_RADIUS = 1.5\n",
        "INDICATOR_RADIUS = 0.6\n",
        "TICK_SIZE = 0.5\n",
        "LIGHTHOUSE_HEIGHT = 0.5\n",
        "LAKE_COLOR = BLUE\n",
        "LAKE_OPACITY = 0.15\n",
        "LAKE_STROKE_WIDTH = 5.0\n",
        "LAKE_STROKE_COLOR = BLUE\n",
        "TEX_SCALE = 0.8\n",
        "DOT_COLOR = BLUE\n",
        "\n",
        "LIGHT_MAX_INT = 1\n",
        "LIGHT_SCALE = 2.5\n",
        "LIGHT_CUTOFF = 1\n",
        "\n",
        "RIGHT_ANGLE_SIZE = 0.3\n",
        "\n",
        "inverse_power_law = lambda maxint,scale,cutoff,exponent: \\\n",
        "    (lambda r: maxint * (cutoff/(r/scale+cutoff))**exponent)\n",
        "inverse_quadratic = lambda maxint,scale,cutoff: inverse_power_law(maxint,scale,cutoff,2)\n",
        "\n",
        "\n",
        "A = np.array([5.,-3.,0.])\n",
        "B = np.array([-5.,3.,0.])\n",
        "C = np.array([-5.,-3.,0.])\n",
        "xA = A[0]\n",
        "yA = A[1]\n",
        "xB = B[0]\n",
        "yB = B[1]\n",
        "xC = C[0]\n",
        "yC = C[1]\n",
        "\n",
        "# find the coords of the altitude point H\n",
        "# as the solution of a certain LSE\n",
        "prelim_matrix = np.array([[yA - yB, xB - xA], [xA - xB, yA - yB]]) # sic\n",
        "prelim_vector = np.array([xB * yA - xA * yB, xC * (xA - xB) + yC * (yA - yB)])\n",
        "H2 = np.linalg.solve(prelim_matrix,prelim_vector)\n",
        "H = np.append(H2, 0.)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class AngleUpdater(ContinualAnimation):\n",
        "    def __init__(self, angle_arc, spotlight, **kwargs):\n",
        "        self.angle_arc = angle_arc\n",
        "\n",
        "        self.spotlight = spotlight\n",
        "        ContinualAnimation.__init__(self, self.angle_arc, **kwargs)\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        new_arc = self.angle_arc.copy().set_bound_angles(\n",
        "            start = self.spotlight.start_angle(),\n",
        "            stop = self.spotlight.stop_angle()\n",
        "        )\n",
        "        new_arc.init_points()\n",
        "        new_arc.move_arc_center_to(self.spotlight.get_source_point())\n",
        "        self.angle_arc.set_points(new_arc.get_points())\n",
        "        self.angle_arc.add_tip(tip_length = ARC_TIP_LENGTH,\n",
        "            at_start = True, at_end = True)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class LightIndicator(VMobject):\n",
        "    CONFIG = {\n",
        "        \"radius\": 0.5,\n",
        "        \"intensity\": 0,\n",
        "        \"opacity_for_unit_intensity\": 1,\n",
        "        \"precision\": 3,\n",
        "        \"show_reading\": True,\n",
        "        \"measurement_point\": ORIGIN,\n",
        "        \"light_source\": None\n",
        "    }\n",
        "\n",
        "    def init_points(self):\n",
        "        self.background = Circle(color=BLACK, radius = self.radius)\n",
        "        self.background.set_fill(opacity=1.0)\n",
        "        self.foreground = Circle(color=self.color, radius = self.radius)\n",
        "        self.foreground.set_stroke(color=INDICATOR_STROKE_COLOR,width=INDICATOR_STROKE_WIDTH)\n",
        "\n",
        "        self.add(self.background, self.foreground)\n",
        "        self.reading = DecimalNumber(self.intensity,num_decimal_places = self.precision)\n",
        "        self.reading.set_fill(color=INDICATOR_TEXT_COLOR)\n",
        "        self.reading.move_to(self.get_center())\n",
        "        if self.show_reading:\n",
        "            self.add(self.reading)\n",
        "\n",
        "    def set_intensity(self, new_int):\n",
        "        self.intensity = new_int\n",
        "        new_opacity = min(1, new_int * self.opacity_for_unit_intensity)\n",
        "        self.foreground.set_fill(opacity=new_opacity)\n",
        "        ChangeDecimalToValue(self.reading, new_int).update(1)\n",
        "        return self\n",
        "\n",
        "    def get_measurement_point(self):\n",
        "        if self.measurement_point != None:\n",
        "            return self.measurement_point\n",
        "        else:\n",
        "            return self.get_center()\n",
        "\n",
        "\n",
        "    def measured_intensity(self):\n",
        "        distance = get_norm(self.get_measurement_point() - \n",
        "            self.light_source.get_source_point())\n",
        "        intensity = self.light_source.opacity_function(distance) / self.opacity_for_unit_intensity\n",
        "        return intensity\n",
        "\n",
        "    def update_mobjects(self):\n",
        "        if self.light_source == None:\n",
        "            print(\"Indicator cannot update, reason: no light source found\")\n",
        "        self.set_intensity(self.measured_intensity())\n",
        "\n",
        "        \n",
        "\n",
        "\n",
        "class UpdateLightIndicator(AnimationGroup):\n",
        "\n",
        "    def __init__(self, indicator, intensity, **kwargs):\n",
        "        if not isinstance(indicator,LightIndicator):\n",
        "            raise Exception(\"This transform applies only to LightIndicator\")\n",
        "        \n",
        "        target_foreground = indicator.copy().set_intensity(intensity).foreground\n",
        "        change_opacity = Transform(\n",
        "            indicator.foreground, target_foreground\n",
        "        )\n",
        "        changing_decimal = ChangeDecimalToValue(indicator.reading, intensity)\n",
        "        AnimationGroup.__init__(self, changing_decimal, change_opacity, **kwargs)\n",
        "        self.mobject = indicator\n",
        "\n",
        "\n",
        "class ContinualLightIndicatorUpdate(ContinualAnimation):\n",
        "\n",
        "    def update_mobject(self,dt):\n",
        "        self.mobject.update_mobjects()\n",
        "\n",
        "\n",
        "def copy_func(f):\n",
        "    \"\"\"Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)\"\"\"\n",
        "    g = types.FunctionType(f.__code__, f.__globals__, name=f.__name__,\n",
        "                           argdefs=f.__defaults__,\n",
        "                           closure=f.__closure__)\n",
        "    g = functools.update_wrapper(g, f)\n",
        "    return g\n",
        "\n",
        "class ScaleLightSources(Transform):\n",
        "\n",
        "    def __init__(self, light_sources_mob, factor, about_point = None, **kwargs):\n",
        "\n",
        "        if about_point == None:\n",
        "            about_point = light_sources_mob.get_center()\n",
        "\n",
        "        ls_target = light_sources_mob.copy()\n",
        "\n",
        "        for submob in ls_target:\n",
        "\n",
        "            if type(submob) == LightSource:\n",
        "\n",
        "                new_sp = submob.source_point.copy() # a mob\n",
        "                new_sp.scale(factor,about_point = about_point)\n",
        "                submob.move_source_to(new_sp.get_location())\n",
        "\n",
        "                # ambient_of = copy_func(submob.ambient_light.opacity_function)\n",
        "                # new_of = lambda r: ambient_of(r / factor)\n",
        "                # submob.ambient_light.change_opacity_function(new_of)\n",
        "\n",
        "                # spotlight_of = copy_func(submob.ambient_light.opacity_function)\n",
        "                # new_of = lambda r: spotlight_of(r / factor)\n",
        "                # submob.spotlight.change_opacity_function(new_of)\n",
        "\n",
        "                new_r = factor * submob.radius\n",
        "                submob.set_radius(new_r)\n",
        "\n",
        "                new_r = factor * submob.ambient_light.radius\n",
        "                submob.ambient_light.radius = new_r\n",
        "\n",
        "                new_r = factor * submob.spotlight.radius\n",
        "                submob.spotlight.radius = new_r\n",
        "\n",
        "                submob.ambient_light.scale_about_point(factor, new_sp.get_center())\n",
        "                submob.spotlight.scale_about_point(factor, new_sp.get_center())\n",
        "\n",
        "\n",
        "        Transform.__init__(self,light_sources_mob,ls_target,**kwargs)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class IntroScene(PiCreatureScene):\n",
        "\n",
        "    CONFIG = {\n",
        "        \"rect_height\" : 0.2,\n",
        "        \"duration\" : 0.5,\n",
        "        \"eq_spacing\" : 6 * MED_LARGE_BUFF\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy.scale(0.7).to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.build_up_euler_sum()\n",
        "        self.build_up_sum_on_number_line()\n",
        "        self.show_pi_answer()\n",
        "        self.other_pi_formulas()\n",
        "        self.refocus_on_euler_sum()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def build_up_euler_sum(self):\n",
        "\n",
        "        self.euler_sum = OldTex(\n",
        "           \"1\", \"+\", \n",
        "           \"{1 \\\\over 4}\", \"+\",\n",
        "           \"{1 \\\\over 9}\", \"+\",\n",
        "           \"{1 \\\\over 16}\", \"+\",\n",
        "           \"{1 \\\\over 25}\", \"+\",\n",
        "           \"\\\\cdots\", \"=\",\n",
        "            arg_separator = \" \\\\, \"\n",
        "        )\n",
        "\n",
        "        self.euler_sum.to_edge(UP)\n",
        "        self.euler_sum.shift(2*LEFT)\n",
        "       \n",
        "        terms = [1./n**2 for n in range(1,6)]\n",
        "        partial_results_values = np.cumsum(terms)\n",
        "\n",
        "        self.play(\n",
        "               FadeIn(self.euler_sum[0], run_time = self.duration)\n",
        "        )\n",
        "\n",
        "        equals_sign = self.euler_sum.get_part_by_tex(\"=\")\n",
        "\n",
        "        self.partial_sum_decimal = DecimalNumber(partial_results_values[1],\n",
        "                num_decimal_places = 2)\n",
        "        self.partial_sum_decimal.next_to(equals_sign, RIGHT)\n",
        "\n",
        "\n",
        "\n",
        "        for i in range(4):\n",
        "\n",
        "            FadeIn(self.partial_sum_decimal, run_time = self.duration)\n",
        "\n",
        "            if i == 0:\n",
        "\n",
        "                self.play(\n",
        "                    FadeIn(self.euler_sum[1], run_time = self.duration),\n",
        "                    FadeIn(self.euler_sum[2], run_time = self.duration),\n",
        "                    FadeIn(equals_sign, run_time = self.duration),\n",
        "                    FadeIn(self.partial_sum_decimal, run_time = self.duration)\n",
        "                )\n",
        "\n",
        "            else:\n",
        "                self.play(\n",
        "                    FadeIn(self.euler_sum[2*i+1], run_time = self.duration),\n",
        "                    FadeIn(self.euler_sum[2*i+2], run_time = self.duration),\n",
        "                    ChangeDecimalToValue(\n",
        "                        self.partial_sum_decimal,\n",
        "                        partial_results_values[i+1], \n",
        "                        run_time = self.duration,\n",
        "                        num_decimal_places = 6,\n",
        "                        show_ellipsis = True,\n",
        "                        position_update_func = lambda m: m.next_to(equals_sign, RIGHT)\n",
        "                    )\n",
        "                )\n",
        "                \n",
        "            self.wait()\n",
        "\n",
        "        self.q_marks = OldTexText(\"???\").set_color(LIGHT_COLOR)\n",
        "        self.q_marks.move_to(self.partial_sum_decimal)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(self.euler_sum[-3], run_time = self.duration), # +\n",
        "            FadeIn(self.euler_sum[-2], run_time = self.duration), # ...\n",
        "            ReplacementTransform(self.partial_sum_decimal, self.q_marks)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "    def build_up_sum_on_number_line(self):\n",
        "\n",
        "        self.number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            color = WHITE,\n",
        "            number_at_center = 1,\n",
        "            stroke_width = 1,\n",
        "            big_tick_numbers = [0,1,2,3],\n",
        "            numbers_to_show = np.arange(0,5),\n",
        "            unit_size = 5,\n",
        "            tick_frequency = 0.2,\n",
        "            line_to_number_buff = MED_LARGE_BUFF\n",
        "        ).shift(LEFT)\n",
        "\n",
        "        self.number_line_labels = self.number_line.get_number_mobjects()\n",
        "        self.play(\n",
        "            FadeIn(self.number_line),\n",
        "            FadeIn(self.number_line_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # create slabs for series terms\n",
        "\n",
        "        max_n1 = 10\n",
        "        max_n2 = 100\n",
        "\n",
        "        terms = [0] + [1./(n**2) for n in range(1, max_n2 + 1)]\n",
        "        series_terms = np.cumsum(terms)\n",
        "        lines = VGroup()\n",
        "        self.rects = VGroup()\n",
        "        slab_colors = [YELLOW, BLUE] * (max_n2 / 2)\n",
        "\n",
        "        for t1, t2, color in zip(series_terms, series_terms[1:], slab_colors):\n",
        "            line = Line(*list(map(self.number_line.number_to_point, [t1, t2])))\n",
        "            rect = Rectangle()\n",
        "            rect.stroke_width = 0\n",
        "            rect.fill_opacity = 1\n",
        "            rect.set_color(color)\n",
        "            rect.stretch_to_fit_height(\n",
        "                self.rect_height,\n",
        "            )\n",
        "            rect.stretch_to_fit_width(0.5 * line.get_width())\n",
        "            rect.move_to(line)\n",
        "\n",
        "            self.rects.add(rect)\n",
        "            lines.add(line)\n",
        "\n",
        "        #self.rects.set_colors_by_radial_gradient(ORIGIN, 5, YELLOW, BLUE)\n",
        "        \n",
        "        self.little_euler_terms = VGroup()\n",
        "        for i in range(1,7):\n",
        "            if i == 1:\n",
        "                term = OldTex(\"1\", fill_color = slab_colors[i-1])\n",
        "            else:\n",
        "                term = OldTex(\"{1\\over \" + str(i**2) + \"}\", fill_color = slab_colors[i-1])\n",
        "            term.scale(0.4)\n",
        "            self.little_euler_terms.add(term)\n",
        "\n",
        "\n",
        "        for i in range(5):\n",
        "            self.play(\n",
        "                GrowFromPoint(self.rects[i], self.euler_sum[2*i].get_center(),\n",
        "                    run_time = 1)\n",
        "            )\n",
        "            term = self.little_euler_terms.submobjects[i]\n",
        "            term.next_to(self.rects[i], UP)\n",
        "            self.play(FadeIn(term))\n",
        "\n",
        "        self.ellipsis = OldTex(\"\\cdots\")\n",
        "        self.ellipsis.scale(0.4)\n",
        "        for i in range(5, max_n1):\n",
        "            \n",
        "            if i == 5:\n",
        "                self.ellipsis.next_to(self.rects[i+3], UP)\n",
        "                self.play(\n",
        "                    FadeIn(self.ellipsis),\n",
        "                    GrowFromPoint(self.rects[i], self.euler_sum[10].get_center(),\n",
        "                    run_time = 0.5)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    GrowFromPoint(self.rects[i], self.euler_sum[10].get_center(),\n",
        "                    run_time = 0.5)\n",
        "                )\n",
        "        for i in range(max_n1, max_n2):\n",
        "            self.play(\n",
        "                    GrowFromPoint(self.rects[i], self.euler_sum[10].get_center(),\n",
        "                    run_time = 0.01)\n",
        "                )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        PI = TAU/2\n",
        "        P = self.q_marks.get_center() + 0.5 * DOWN + 0.5 * LEFT\n",
        "        Q = self.rects[-1].get_center() + 0.2 * UP\n",
        "        self.arrow = CurvedArrow(P, Q,\n",
        "            angle = TAU/12,\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(self.arrow))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def show_pi_answer(self):\n",
        "\n",
        "        self.pi_answer = OldTex(\"{\\\\pi^2 \\\\over 6}\").set_color(YELLOW)\n",
        "        self.pi_answer.move_to(self.partial_sum_decimal)\n",
        "        self.pi_answer.next_to(self.euler_sum[-1], RIGHT, buff = 1,\n",
        "            submobject_to_align = self.pi_answer[-2])\n",
        "        self.play(ReplacementTransform(self.q_marks, self.pi_answer))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def other_pi_formulas(self):\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.rects),\n",
        "            FadeOut(self.number_line_labels),\n",
        "            FadeOut(self.number_line),\n",
        "            FadeOut(self.little_euler_terms),\n",
        "            FadeOut(self.ellipsis),\n",
        "            FadeOut(self.arrow)\n",
        "        )\n",
        "\n",
        "        self.leibniz_sum = OldTex(\n",
        "            \"1-{1\\\\over 3}+{1\\\\over 5}-{1\\\\over 7}+{1\\\\over 9}-\\\\cdots\",\n",
        "            \"=\", \"\\quad\\,\\,{\\\\pi \\\\over 4}\", arg_separator = \" \\\\, \")\n",
        "\n",
        "        self.wallis_product = OldTex(\n",
        "            \"{2\\\\over 1} \\\\cdot {2\\\\over 3} \\\\cdot {4\\\\over 3} \\\\cdot {4\\\\over 5}\" +\n",
        "             \"\\\\cdot {6\\\\over 5} \\\\cdot {6\\\\over 7} \\\\cdots\",\n",
        "             \"=\", \"\\quad\\,\\, {\\\\pi \\\\over 2}\", arg_separator = \" \\\\, \")\n",
        "\n",
        "        self.leibniz_sum.next_to(self.euler_sum.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = 2,\n",
        "            submobject_to_align = self.leibniz_sum.get_part_by_tex(\"=\")\n",
        "        )\n",
        "\n",
        "        self.wallis_product.next_to(self.leibniz_sum.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = 2,\n",
        "            submobject_to_align = self.wallis_product.get_part_by_tex(\"=\")\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Write(self.leibniz_sum)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(self.wallis_product)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "    def refocus_on_euler_sum(self):\n",
        "\n",
        "        self.euler_sum.add(self.pi_answer)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.leibniz_sum),\n",
        "            FadeOut(self.wallis_product),\n",
        "            ApplyMethod(self.euler_sum.shift,\n",
        "                ORIGIN + 2*UP - self.euler_sum.get_center())\n",
        "        )\n",
        "\n",
        "        # focus on pi squared\n",
        "        pi_squared = self.euler_sum.get_part_by_tex(\"\\\\pi\")[-3]\n",
        "        self.play(\n",
        "            WiggleOutThenIn(pi_squared,\n",
        "                scale_value = 4,\n",
        "                angle = 0.003 * TAU,\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        # Morty thinks of a circle\n",
        "\n",
        "        q_circle = Circle(\n",
        "            stroke_color = YELLOW,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.25,\n",
        "            radius = 0.5, \n",
        "            stroke_width = 3.0\n",
        "        )\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.next_to(q_circle)\n",
        "\n",
        "        thought = Group(q_circle, q_mark)\n",
        "        q_mark.set_height(0.6 * q_circle.get_height())\n",
        "\n",
        "        self.look_at(pi_squared)\n",
        "        self.pi_creature_thinks(thought,target_mode = \"confused\",\n",
        "            bubble_config = { \"height\" : 2.5, \"width\" : 5 })\n",
        "        self.look_at(pi_squared)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class FirstLighthouseScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "        self.remove(self.get_primary_pi_creature())\n",
        "        self.show_lighthouses_on_number_line()\n",
        "\n",
        "\n",
        "\n",
        "    def show_lighthouses_on_number_line(self):\n",
        "\n",
        "        self.number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            color = WHITE,\n",
        "            number_at_center = 1.6,\n",
        "            stroke_width = 1,\n",
        "            big_tick_numbers = list(range(1,5)),\n",
        "            numbers_to_show = list(range(1,5)),\n",
        "            unit_size = 2,\n",
        "            tick_frequency = 0.2,\n",
        "            line_to_number_buff = LARGE_BUFF,\n",
        "            label_direction = UP,\n",
        "        )\n",
        "\n",
        "        self.number_line.label_direction = DOWN\n",
        "\n",
        "        self.number_line_labels = self.number_line.get_number_mobjects()\n",
        "        self.add(self.number_line,self.number_line_labels)\n",
        "        self.wait()\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "\n",
        "        self.default_pi_creature_class = Randolph\n",
        "        randy = self.get_primary_pi_creature()\n",
        "\n",
        "        randy.scale(0.5)\n",
        "        randy.flip()\n",
        "        right_pupil = randy.pupils[1]\n",
        "        randy.next_to(origin_point, LEFT, buff = 0, submobject_to_align = right_pupil)\n",
        "\n",
        "\n",
        "\n",
        "        light_indicator = LightIndicator(radius = INDICATOR_RADIUS,\n",
        "            opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "            color = LIGHT_COLOR)\n",
        "        light_indicator.reading.scale(0.8)\n",
        "\n",
        "        bubble = ThoughtBubble(direction = RIGHT,\n",
        "                            width = 2.5, height = 3.5)\n",
        "        bubble.next_to(randy,LEFT+UP)\n",
        "        bubble.add_content(light_indicator)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change, \"wave_2\",\n",
        "            ShowCreation(bubble),\n",
        "            FadeIn(light_indicator)\n",
        "        )\n",
        "\n",
        "        light_sources = []\n",
        "\n",
        "\n",
        "        euler_sum_above = OldTex(\"1\", \"+\", \"{1\\over 4}\", \n",
        "            \"+\", \"{1\\over 9}\", \"+\", \"{1\\over 16}\", \"+\", \"{1\\over 25}\", \"+\", \"{1\\over 36}\")\n",
        "\n",
        "        for (i,term) in zip(list(range(len(euler_sum_above))),euler_sum_above):\n",
        "            #horizontal alignment with tick marks\n",
        "            term.next_to(self.number_line.number_to_point(0.5*i+1),UP,buff = 2)\n",
        "            # vertical alignment with light indicator\n",
        "            old_y = term.get_center()[1]\n",
        "            new_y = light_indicator.get_center()[1]\n",
        "            term.shift([0,new_y - old_y,0])\n",
        "            \n",
        "\n",
        "\n",
        "        for i in range(1,NUM_CONES+1):\n",
        "            light_source = LightSource(\n",
        "                opacity_function = inverse_quadratic(1,AMBIENT_SCALE,1),\n",
        "                num_levels = NUM_LEVELS,\n",
        "                radius = AMBIENT_RADIUS,\n",
        "            )\n",
        "            point = self.number_line.number_to_point(i)\n",
        "            light_source.move_source_to(point)\n",
        "            light_sources.append(light_source)\n",
        "\n",
        "        self.wait()\n",
        "        for ls in light_sources:\n",
        "            self.add_foreground_mobject(ls.lighthouse)\n",
        "\n",
        "        light_indicator.set_intensity(0)\n",
        "\n",
        "        intensities = np.cumsum(np.array([1./n**2 for n in range(1,NUM_CONES+1)]))\n",
        "        opacities = intensities * light_indicator.opacity_for_unit_intensity\n",
        "\n",
        "        self.remove_foreground_mobjects(light_indicator)\n",
        "\n",
        "\n",
        "        # slowly switch on visible light cones and increment indicator\n",
        "        for (i,light_source) in zip(list(range(NUM_VISIBLE_CONES)),light_sources[:NUM_VISIBLE_CONES]):\n",
        "            indicator_start_time = 1.0 * (i+1) * SWITCH_ON_RUN_TIME/light_source.radius * self.number_line.unit_size\n",
        "            indicator_stop_time = indicator_start_time + INDICATOR_UPDATE_TIME\n",
        "            indicator_rate_func = squish_rate_func(\n",
        "                smooth,indicator_start_time,indicator_stop_time)\n",
        "            self.play(\n",
        "                SwitchOn(light_source.ambient_light),\n",
        "                FadeIn(euler_sum_above[2*i], run_time = SWITCH_ON_RUN_TIME,\n",
        "                    rate_func = indicator_rate_func),\n",
        "                FadeIn(euler_sum_above[2*i - 1], run_time = SWITCH_ON_RUN_TIME,\n",
        "                    rate_func = indicator_rate_func),\n",
        "                # this last line *technically* fades in the last term, but it is off-screen\n",
        "                ChangeDecimalToValue(light_indicator.reading,intensities[i],\n",
        "                    rate_func = indicator_rate_func, run_time = SWITCH_ON_RUN_TIME),\n",
        "                ApplyMethod(light_indicator.foreground.set_fill,None,opacities[i],\n",
        "                    rate_func = indicator_rate_func, run_time = SWITCH_ON_RUN_TIME)\n",
        "            )\n",
        "\n",
        "            if i == 0:\n",
        "                self.wait()\n",
        "                # move a copy out of the thought bubble for comparison\n",
        "                light_indicator_copy = light_indicator.copy()\n",
        "                old_y = light_indicator_copy.get_center()[1]\n",
        "                new_y = self.number_line.get_center()[1]\n",
        "                self.play(\n",
        "                    light_indicator_copy.shift,[0, new_y - old_y,0]\n",
        "                )\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # quickly switch on off-screen light cones and increment indicator\n",
        "        for (i,light_source) in zip(list(range(NUM_VISIBLE_CONES,NUM_CONES)),light_sources[NUM_VISIBLE_CONES:NUM_CONES]):\n",
        "            indicator_start_time = 0.5 * (i+1) * FAST_SWITCH_ON_RUN_TIME/light_source.radius * self.number_line.unit_size\n",
        "            indicator_stop_time = indicator_start_time + FAST_INDICATOR_UPDATE_TIME\n",
        "            indicator_rate_func = squish_rate_func(#smooth, 0.8, 0.9)\n",
        "                smooth,indicator_start_time,indicator_stop_time)\n",
        "            self.play(\n",
        "                SwitchOn(light_source.ambient_light, run_time = FAST_SWITCH_ON_RUN_TIME),\n",
        "                ChangeDecimalToValue(light_indicator.reading,intensities[i-1],\n",
        "                    rate_func = indicator_rate_func, run_time = FAST_SWITCH_ON_RUN_TIME),\n",
        "                ApplyMethod(light_indicator.foreground.set_fill,None,opacities[i-1])\n",
        "            )\n",
        "\n",
        "\n",
        "        # show limit value in light indicator and an equals sign\n",
        "        limit_reading = OldTex(\"{\\pi^2 \\over 6}\")\n",
        "        limit_reading.move_to(light_indicator.reading)\n",
        "\n",
        "        equals_sign = OldTex(\"=\")\n",
        "        equals_sign.next_to(randy, UP)\n",
        "        old_y = equals_sign.get_center()[1]\n",
        "        new_y = euler_sum_above.get_center()[1]\n",
        "        equals_sign.shift([0,new_y - old_y,0])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(light_indicator.reading),\n",
        "            FadeIn(limit_reading),\n",
        "            FadeIn(equals_sign),\n",
        "        )\n",
        "\n",
        "            \n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class SingleLighthouseScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        self.setup_elements()\n",
        "        self.setup_angle() # spotlight and angle msmt change when screen rotates\n",
        "        self.rotate_screen()\n",
        "        #self.morph_lighthouse_into_sun()\n",
        "\n",
        "\n",
        "    def setup_elements(self):\n",
        "\n",
        "        self.remove(self.get_primary_pi_creature())\n",
        "\n",
        "        SCREEN_SIZE = 3.0\n",
        "        DISTANCE_FROM_LIGHTHOUSE = 10.0\n",
        "        source_point = [-DISTANCE_FROM_LIGHTHOUSE/2,0,0]\n",
        "        observer_point = [DISTANCE_FROM_LIGHTHOUSE/2,0,0]\n",
        "\n",
        "        # Light source\n",
        "\n",
        "        self.light_source = LightSource(\n",
        "            opacity_function = inverse_quadratic(1,SPOTLIGHT_SCALE,1),\n",
        "            num_levels = NUM_LEVELS,\n",
        "            radius = 10,\n",
        "            max_opacity_ambient = AMBIENT_FULL,\n",
        "            max_opacity_spotlight = SPOTLIGHT_FULL,\n",
        "\n",
        "        )\n",
        "\n",
        "        self.light_source.move_source_to(source_point)\n",
        "\n",
        "\n",
        "        # Pi Creature\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        morty.scale(0.5)\n",
        "        morty.move_to(observer_point)\n",
        "        morty.shift(2*OUT)\n",
        "        self.add_foreground_mobject(morty)\n",
        "\n",
        "        self.add(self.light_source.lighthouse)\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(self.light_source.ambient_light)\n",
        "        )\n",
        "\n",
        "        # Screen\n",
        "\n",
        "        self.screen = Rectangle(\n",
        "            width = 0.06,\n",
        "            height = 2,\n",
        "            mark_paths_closed = True,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1.0,\n",
        "            stroke_width = 0.0\n",
        "        )\n",
        "\n",
        "        self.screen.rotate(-TAU/6)\n",
        "        self.screen.next_to(morty,LEFT)\n",
        "\n",
        "        self.light_source.set_screen(self.screen)\n",
        "\n",
        "        # Animations\n",
        "\n",
        "        self.play(FadeIn(self.screen))\n",
        "\n",
        "        #self.light_source.set_max_opacity_spotlight(0.001)\n",
        "        #self.play(SwitchOn(self.light_source.spotlight))\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        # just calling .dim_ambient via ApplyMethod does not work, why?\n",
        "        dimmed_ambient_light = self.light_source.ambient_light.deepcopy()\n",
        "        dimmed_ambient_light.dimming(AMBIENT_DIMMED)\n",
        "        self.light_source.update_shadow()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(self.light_source.shadow),\n",
        "        )\n",
        "        self.add_foreground_mobject(self.light_source.shadow)\n",
        "        self.add_foreground_mobject(morty)\n",
        "\n",
        "        self.play(\n",
        "            self.light_source.dim_ambient,\n",
        "            #Transform(self.light_source.ambient_light,dimmed_ambient_light),\n",
        "            #self.light_source.set_max_opacity_spotlight,1.0,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(self.light_source.spotlight)\n",
        "        )\n",
        "\n",
        "        self.screen_tracker = ScreenTracker(self.light_source)\n",
        "        self.add(self.screen_tracker)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def setup_angle(self):\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        \n",
        "        pointing_screen_at_source = Rotate(self.screen,TAU/6)\n",
        "        self.play(pointing_screen_at_source)\n",
        "\n",
        "        # angle msmt (arc)\n",
        "\n",
        "        arc_angle = self.light_source.spotlight.opening_angle()\n",
        "        # draw arc arrows to show the opening angle\n",
        "        self.angle_arc = Arc(radius = 5, start_angle = self.light_source.spotlight.start_angle(),\n",
        "            angle = self.light_source.spotlight.opening_angle(), tip_length = ARC_TIP_LENGTH)\n",
        "        #angle_arc.add_tip(at_start = True, at_end = True)\n",
        "        self.angle_arc.move_arc_center_to(self.light_source.get_source_point())\n",
        "        \n",
        "\n",
        "        # angle msmt (decimal number)\n",
        "\n",
        "        self.angle_indicator = DecimalNumber(arc_angle / DEGREES,\n",
        "            num_decimal_places = 0,\n",
        "            unit = \"^\\\\circ\",\n",
        "            fill_opacity = 1.0,\n",
        "            fill_color = WHITE)\n",
        "        self.angle_indicator.next_to(self.angle_arc,RIGHT)\n",
        "\n",
        "        angle_update_func = lambda x: self.light_source.spotlight.opening_angle() / DEGREES\n",
        "        self.angle_indicator.add_updater(\n",
        "            lambda d: d.set_value(angle_update_func())\n",
        "        )\n",
        "        self.add(self.angle_indicator)\n",
        "\n",
        "        ca2 = AngleUpdater(self.angle_arc, self.light_source.spotlight)\n",
        "        self.add(ca2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.angle_arc),\n",
        "            ShowCreation(self.angle_indicator)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def rotate_screen(self):\n",
        "\n",
        "\n",
        "\n",
        "        self.play(Rotate(self.light_source.spotlight.screen, TAU/8))\n",
        "        self.play(Rotate(self.light_source.spotlight.screen, -TAU/4))\n",
        "\n",
        "        self.play(Rotate(self.light_source.spotlight.screen, TAU/8))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Rotate(self.light_source.spotlight.screen, -TAU/4))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Rotate(self.light_source.spotlight.screen, TAU/4))\n",
        "\n",
        "### The following is supposed to morph the scene into the Earth scene,\n",
        "### but it doesn't work\n",
        "\n",
        "\n",
        "class MorphIntoSunScene(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.setup_elements()\n",
        "        self.morph_lighthouse_into_sun()\n",
        "\n",
        "    def setup_elements(self):\n",
        "        self.remove(self.get_primary_pi_creature())\n",
        "\n",
        "        SCREEN_SIZE = 3.0\n",
        "        DISTANCE_FROM_LIGHTHOUSE = 10.0\n",
        "        source_point = [-DISTANCE_FROM_LIGHTHOUSE/2,0,0]\n",
        "        observer_point = [DISTANCE_FROM_LIGHTHOUSE/2,0,0]\n",
        "\n",
        "        # Light source\n",
        "\n",
        "        self.light_source = LightSource(\n",
        "            opacity_function = inverse_quadratic(1,SPOTLIGHT_SCALE,1),\n",
        "            num_levels = NUM_LEVELS,\n",
        "            radius = 10,\n",
        "            max_opacity_ambient = AMBIENT_FULL,\n",
        "            max_opacity_spotlight = SPOTLIGHT_FULL,\n",
        "\n",
        "        )\n",
        "\n",
        "        self.light_source.move_source_to(source_point)\n",
        "\n",
        "\n",
        "        # Pi Creature\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        morty.scale(0.5)\n",
        "        morty.move_to(observer_point)\n",
        "        morty.shift(2*OUT)\n",
        "        self.add_foreground_mobject(morty)\n",
        "\n",
        "        self.add(self.light_source.lighthouse,self.light_source.ambient_light)\n",
        "        \n",
        "\n",
        "        # Screen\n",
        "\n",
        "        self.screen = Rectangle(\n",
        "            width = 0.06,\n",
        "            height = 2,\n",
        "            mark_paths_closed = True,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1.0,\n",
        "            stroke_width = 0.0\n",
        "        )\n",
        "\n",
        "        self.screen.next_to(morty,LEFT)\n",
        "\n",
        "        self.light_source.set_screen(self.screen)\n",
        "        self.add(self.screen,self.light_source.shadow)\n",
        "        \n",
        "        self.add_foreground_mobject(self.light_source.shadow)\n",
        "        self.add_foreground_mobject(morty)\n",
        "        self.light_source.dim_ambient\n",
        "        self.add(self.light_source.spotlight)\n",
        "        self.screen_tracker = ScreenTracker(self.light_source)\n",
        "        self.add(self.screen_tracker)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def morph_lighthouse_into_sun(self):\n",
        "\n",
        "        sun_position = np.array([-100,0,0])\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        # Why does none of this change the opacity function???\n",
        "\n",
        "        self.sun = self.light_source.copy()\n",
        "\n",
        "        self.sun.change_spotlight_opacity_function(lambda r: 0.1)\n",
        "        # self.sun.spotlight.opacity_function = lambda r: 0.1\n",
        "        # for submob in self.sun.spotlight.submobjects:\n",
        "        #     submob.set_fill(opacity = 0.1)\n",
        "\n",
        "        #self.sun.move_source_to(sun_position)\n",
        "        #self.sun.set_radius(120)\n",
        "\n",
        "        self.sun.spotlight.init_points()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "             Transform(self.light_source,self.sun)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        " \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class EarthScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        SCREEN_THICKNESS = 10\n",
        "\n",
        "        self.screen_height = 2.0\n",
        "        self.brightness_rect_height = 1.0\n",
        "\n",
        "        # screen\n",
        "        self.screen = VMobject(stroke_color = WHITE, stroke_width = SCREEN_THICKNESS)\n",
        "        self.screen.set_points_as_corners([\n",
        "            [0,-self.screen_height/2,0],\n",
        "            [0,self.screen_height/2,0]\n",
        "        ])\n",
        "\n",
        "        # Earth\n",
        "\n",
        "        earth_center_x = 2\n",
        "        earth_center = [earth_center_x,0,0]\n",
        "        earth_radius = 3\n",
        "        earth = Circle(radius = earth_radius)\n",
        "        earth.add(self.screen)\n",
        "        earth.move_to(earth_center)\n",
        "        #self.remove(self.screen_tracker)\n",
        "\n",
        "        theta0 = 70 * DEGREES\n",
        "        dtheta = 10 * DEGREES\n",
        "        theta1 = theta0 + dtheta\n",
        "        theta = (theta0 + theta1)/2\n",
        "\n",
        "        self.add_foreground_mobject(self.screen)\n",
        "\n",
        "        # background Earth\n",
        "        background_earth = SVGMobject(\n",
        "            file_name = \"earth\",\n",
        "            width = 2 * earth_radius,\n",
        "            fill_color = BLUE,\n",
        "        )\n",
        "        background_earth.move_to(earth_center)\n",
        "        # Morty\n",
        "\n",
        "        morty = Mortimer().scale(0.5).next_to(self.screen, RIGHT, buff = 1.5)\n",
        "        self.add_foreground_mobject(morty)\n",
        "\n",
        "\n",
        "        # Light source (far-away Sun)\n",
        "\n",
        "        sun_position = [-100,0,0]\n",
        "\n",
        "        self.sun = LightSource(\n",
        "            opacity_function = lambda r : 0.5,\n",
        "            max_opacity_ambient = 0,\n",
        "            max_opacity_spotlight = 0.5,\n",
        "            num_levels = NUM_LEVELS,\n",
        "            radius = 150,\n",
        "            screen = self.screen\n",
        "        )\n",
        "\n",
        "        self.sun.move_source_to(sun_position)\n",
        "\n",
        "\n",
        "        # Add elements to scene\n",
        "\n",
        "        self.add(self.sun,self.screen)\n",
        "        self.bring_to_back(self.sun.shadow)\n",
        "        screen_tracker = ScreenTracker(self.sun)\n",
        "\n",
        "        self.add(screen_tracker)\n",
        "        \n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(earth),\n",
        "            FadeIn(background_earth)\n",
        "        )\n",
        "        self.add_foreground_mobject(earth)\n",
        "        self.add_foreground_mobject(self.screen)\n",
        "\n",
        "\n",
        "        # move screen onto Earth\n",
        "        screen_on_earth = self.screen.deepcopy()\n",
        "        screen_on_earth.rotate(-theta)\n",
        "        screen_on_earth.scale(0.3)\n",
        "        screen_on_earth.move_to(np.array([\n",
        "            earth_center_x - earth_radius * np.cos(theta),\n",
        "            earth_radius * np.sin(theta),\n",
        "            0]))\n",
        "\n",
        "        polar_morty = morty.copy().scale(0.5).next_to(screen_on_earth,DOWN,buff = 0.5)\n",
        "        polar_morty.set_color(BLUE_C)\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.screen, screen_on_earth),\n",
        "            Transform(morty,polar_morty)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        tropical_morty = polar_morty.copy()\n",
        "        tropical_morty.move_to(np.array([0,0,0]))\n",
        "        tropical_morty.set_color(RED)\n",
        "\n",
        "        morty.target = tropical_morty\n",
        "\n",
        "        # move screen to equator\n",
        "\n",
        "        self.play(\n",
        "            Rotate(earth, theta0 + dtheta/2,run_time = 3),\n",
        "            MoveToTarget(morty, path_arc = 70*DEGREES, run_time = 3),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ScreenShapingScene(ThreeDScene):\n",
        "\n",
        "\n",
        "    # TODO: Morph from Earth Scene into this scene\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        #self.force_skipping()\n",
        "        self.setup_elements()\n",
        "        self.deform_screen()\n",
        "        self.create_brightness_rect()\n",
        "        self.slant_screen()\n",
        "        self.unslant_screen()\n",
        "        self.left_shift_screen_while_showing_light_indicator()\n",
        "        self.add_distance_arrow()\n",
        "        self.right_shift_screen_while_showing_light_indicator_and_distance_arrow()\n",
        "        self.left_shift_again()\n",
        "        #self.revert_to_original_skipping_status()\n",
        "        \n",
        "        self.morph_into_3d()\n",
        "        self.prove_inverse_square_law()\n",
        "\n",
        "\n",
        "    def setup_elements(self):\n",
        "\n",
        "        SCREEN_THICKNESS = 10\n",
        "\n",
        "        self.screen_height = 1.0\n",
        "        self.brightness_rect_height = 1.0\n",
        "\n",
        "        # screen\n",
        "        self.screen = Line([3,-self.screen_height/2,0],[3,self.screen_height/2,0],\n",
        "            path_arc = 0, num_arc_anchors = 10)\n",
        "        \n",
        "        # light source\n",
        "        self.light_source = LightSource(\n",
        "            opacity_function = inverse_quadratic(1,5,1),\n",
        "            num_levels = NUM_LEVELS,\n",
        "            radius = 10,\n",
        "            max_opacity = 0.2\n",
        "            #screen = self.screen\n",
        "        )\n",
        "        self.light_source.set_max_opacity_spotlight(0.2)\n",
        "\n",
        "        self.light_source.set_screen(self.screen)\n",
        "        self.light_source.move_source_to([-5,0,0])\n",
        "\n",
        "        # abbreviations\n",
        "        self.ambient_light = self.light_source.ambient_light\n",
        "        self.spotlight = self.light_source.spotlight\n",
        "        self.lighthouse = self.light_source.lighthouse\n",
        "\n",
        "        \n",
        "        #self.add_foreground_mobject(self.light_source.shadow)\n",
        "\n",
        "        # Morty\n",
        "        self.morty = Mortimer().scale(0.3).next_to(self.screen, RIGHT, buff = 0.5)\n",
        "\n",
        "        # Add everything to the scene\n",
        "        self.add(self.lighthouse)\n",
        "        \n",
        "        self.wait()\n",
        "        self.play(FadeIn(self.screen))\n",
        "        self.wait()\n",
        "\n",
        "        self.add_foreground_mobject(self.screen)\n",
        "        self.add_foreground_mobject(self.morty)\n",
        "\n",
        "        self.play(SwitchOn(self.ambient_light))\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(self.spotlight),\n",
        "            self.light_source.dim_ambient\n",
        "        )\n",
        "\n",
        "        screen_tracker = ScreenTracker(self.light_source)\n",
        "        self.add(screen_tracker)\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "    def deform_screen(self):\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ApplyMethod(self.screen.set_path_arc, 45 * DEGREES))\n",
        "        self.play(ApplyMethod(self.screen.set_path_arc, -90 * DEGREES))\n",
        "        self.play(ApplyMethod(self.screen.set_path_arc, 0))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def create_brightness_rect(self):\n",
        "\n",
        "        # in preparation for the slanting, create a rectangle that shows the brightness\n",
        "\n",
        "        # a rect a zero width overlaying the screen\n",
        "        # so we can morph it into the brightness rect above\n",
        "        brightness_rect0 = Rectangle(width = 0,\n",
        "            height = self.screen_height).move_to(self.screen.get_center())\n",
        "        self.add_foreground_mobject(brightness_rect0)\n",
        "\n",
        "        self.brightness_rect = Rectangle(width = self.brightness_rect_height,\n",
        "            height = self.brightness_rect_height, fill_color = YELLOW, fill_opacity = 0.5)\n",
        "\n",
        "        self.brightness_rect.next_to(self.screen, UP, buff = 1)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(brightness_rect0,self.brightness_rect)\n",
        "        )\n",
        "\n",
        "        self.unslanted_screen = self.screen.deepcopy()\n",
        "        self.unslanted_brightness_rect = self.brightness_rect.copy()\n",
        "        # for unslanting the screen later\n",
        "\n",
        "\n",
        "    def slant_screen(self):\n",
        "\n",
        "        SLANTING_AMOUNT = 0.1\n",
        "\n",
        "        lower_screen_point, upper_screen_point = self.screen.get_start_and_end()\n",
        "\n",
        "        lower_slanted_screen_point = interpolate(\n",
        "            lower_screen_point, self.spotlight.get_source_point(), SLANTING_AMOUNT\n",
        "        )\n",
        "        upper_slanted_screen_point = interpolate(\n",
        "            upper_screen_point, self.spotlight.get_source_point(), -SLANTING_AMOUNT\n",
        "        )\n",
        "\n",
        "        self.slanted_brightness_rect = self.brightness_rect.copy()\n",
        "        self.slanted_brightness_rect.width *= 2\n",
        "        self.slanted_brightness_rect.init_points()\n",
        "        self.slanted_brightness_rect.set_fill(opacity = 0.25)\n",
        "\n",
        "        self.slanted_screen = Line(lower_slanted_screen_point,upper_slanted_screen_point,\n",
        "            path_arc = 0, num_arc_anchors = 10)\n",
        "        self.slanted_brightness_rect.move_to(self.brightness_rect.get_center())\n",
        "\n",
        "        self.play(\n",
        "             Transform(self.screen,self.slanted_screen),\n",
        "             Transform(self.brightness_rect,self.slanted_brightness_rect),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "    def unslant_screen(self):\n",
        "\n",
        "        self.wait()        \n",
        "        self.play(\n",
        "            Transform(self.screen,self.unslanted_screen),\n",
        "            Transform(self.brightness_rect,self.unslanted_brightness_rect),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def left_shift_screen_while_showing_light_indicator(self):\n",
        "\n",
        "        # Scene 5: constant screen size, changing opening angle\n",
        "\n",
        "        OPACITY_FOR_UNIT_INTENSITY = 1\n",
        "\n",
        "        # let's use an actual light indicator instead of just rects\n",
        "\n",
        "        self.indicator_intensity = 0.25\n",
        "        indicator_height = 1.25 * self.screen_height\n",
        "\n",
        "        self.indicator = LightIndicator(radius = indicator_height/2,\n",
        "            opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "            color = LIGHT_COLOR,\n",
        "            precision = 2)\n",
        "        self.indicator.set_intensity(self.indicator_intensity)\n",
        "\n",
        "        self.indicator.move_to(self.brightness_rect.get_center())\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.brightness_rect),\n",
        "            FadeIn(self.indicator)\n",
        "        )\n",
        "\n",
        "        # Here some digits of the indicator disappear...\n",
        "\n",
        "        self.add_foreground_mobject(self.indicator.reading)\n",
        "\n",
        "\n",
        "        self.unit_indicator_intensity = 1.0 # intensity at distance 1\n",
        "                                            # (where we are about to move to)\n",
        "\n",
        "        self.left_shift = (self.screen.get_center()[0] - self.spotlight.get_source_point()[0])/2\n",
        "\n",
        "        self.play(\n",
        "            self.screen.shift,[-self.left_shift,0,0],\n",
        "            self.morty.shift,[-self.left_shift,0,0],\n",
        "            self.indicator.shift,[-self.left_shift,0,0],\n",
        "            self.indicator.set_intensity,self.unit_indicator_intensity,\n",
        "        )\n",
        "        \n",
        "\n",
        "\n",
        "    def add_distance_arrow(self):\n",
        "\n",
        "        # distance arrow (length 1)\n",
        "        left_x = self.spotlight.get_source_point()[0]\n",
        "        right_x = self.screen.get_center()[0]\n",
        "        arrow_y = -2\n",
        "        arrow1 = Arrow([left_x,arrow_y,0],[right_x,arrow_y,0])\n",
        "        arrow2 = Arrow([right_x,arrow_y,0],[left_x,arrow_y,0])\n",
        "        arrow1.set_fill(color = WHITE)\n",
        "        arrow2.set_fill(color = WHITE)\n",
        "        distance_decimal = Integer(1).next_to(arrow1,DOWN)\n",
        "        self.arrow = VGroup(arrow1, arrow2,distance_decimal)\n",
        "        self.add(self.arrow)\n",
        "\n",
        "\n",
        "        # distance arrow (length 2)\n",
        "        # will be morphed into\n",
        "        self.distance_to_source = right_x - left_x\n",
        "        new_right_x = left_x + 2 * self.distance_to_source\n",
        "        new_arrow1 = Arrow([left_x,arrow_y,0],[new_right_x,arrow_y,0])\n",
        "        new_arrow2 = Arrow([new_right_x,arrow_y,0],[left_x,arrow_y,0])\n",
        "        new_arrow1.set_fill(color = WHITE)\n",
        "        new_arrow2.set_fill(color = WHITE)\n",
        "        new_distance_decimal = Integer(2).next_to(new_arrow1,DOWN)\n",
        "        self.new_arrow = VGroup(new_arrow1, new_arrow2, new_distance_decimal)\n",
        "        # don't add it yet\n",
        "\n",
        "\n",
        "    def right_shift_screen_while_showing_light_indicator_and_distance_arrow(self):\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(self.arrow,self.new_arrow),\n",
        "            ApplyMethod(self.screen.shift,[self.distance_to_source,0,0]),\n",
        "            ApplyMethod(self.indicator.shift,[self.left_shift,0,0]),\n",
        "            \n",
        "            ApplyMethod(self.indicator.set_intensity,self.indicator_intensity),\n",
        "            # this should trigger ChangingDecimal, but it doesn't\n",
        "            # maybe bc it's an anim within an anim?\n",
        "\n",
        "            ApplyMethod(self.morty.shift,[self.distance_to_source,0,0]),\n",
        "        )\n",
        "\n",
        "\n",
        "    def left_shift_again(self):\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(self.new_arrow,self.arrow),\n",
        "            ApplyMethod(self.screen.shift,[-self.distance_to_source,0,0]),\n",
        "            #ApplyMethod(self.indicator.shift,[-self.left_shift,0,0]),\n",
        "            ApplyMethod(self.indicator.set_intensity,self.unit_indicator_intensity),\n",
        "            ApplyMethod(self.morty.shift,[-self.distance_to_source,0,0]),\n",
        "        )\n",
        "\n",
        "    def morph_into_3d(self):\n",
        "\n",
        "\n",
        "        self.play(FadeOut(self.morty))\n",
        "\n",
        "        axes = ThreeDAxes()\n",
        "        self.add(axes)\n",
        "\n",
        "        phi0 = self.camera.get_phi() # default is 0 degs\n",
        "        theta0 = self.camera.get_theta() # default is -90 degs\n",
        "        distance0 = self.camera.get_distance()\n",
        "\n",
        "        phi1 = 60 * DEGREES # angle from zenith (0 to 180)\n",
        "        theta1 = -135 * DEGREES # azimuth (0 to 360)\n",
        "        distance1 = distance0\n",
        "        target_point = self.camera.get_spherical_coords(phi1, theta1, distance1)\n",
        "\n",
        "        dphi = phi1 - phi0\n",
        "        dtheta = theta1 - theta0\n",
        "\n",
        "        camera_target_point = target_point # self.camera.get_spherical_coords(45 * DEGREES, -60 * DEGREES)\n",
        "        projection_direction = self.camera.spherical_coords_to_point(phi1,theta1, 1)\n",
        "\n",
        "        new_screen0 = Rectangle(height = self.screen_height,\n",
        "            width = 0.1, stroke_color = RED, fill_color = RED, fill_opacity = 1)\n",
        "        new_screen0.rotate(TAU/4,axis = DOWN)\n",
        "        new_screen0.move_to(self.screen.get_center())\n",
        "        self.add(new_screen0)\n",
        "        self.remove(self.screen)\n",
        "        self.light_source.set_screen(new_screen0)\n",
        "\n",
        "        self.light_source.set_camera(self.camera)\n",
        "\n",
        "\n",
        "        new_screen = Rectangle(height = self.screen_height,\n",
        "            width = self.screen_height, stroke_color = RED, fill_color = RED, fill_opacity = 1)\n",
        "        new_screen.rotate(TAU/4,axis = DOWN)\n",
        "        new_screen.move_to(self.screen.get_center())\n",
        "\n",
        "        self.add_foreground_mobject(self.ambient_light)\n",
        "        self.add_foreground_mobject(self.spotlight)\n",
        "        self.add_foreground_mobject(self.light_source.shadow)\n",
        "\n",
        "        self.play(\n",
        "             ApplyMethod(self.camera.rotation_mobject.move_to, camera_target_point),\n",
        "             \n",
        "        )\n",
        "        self.remove(self.spotlight)\n",
        "\n",
        "        self.play(Transform(new_screen0,new_screen))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.unit_screen = new_screen0 # better name\n",
        "\n",
        "\n",
        "\n",
        "    def prove_inverse_square_law(self):\n",
        "\n",
        "        def orientate(mob):\n",
        "            mob.move_to(self.unit_screen)\n",
        "            mob.rotate(TAU/4, axis = LEFT)\n",
        "            mob.rotate(TAU/4, axis = OUT)\n",
        "            mob.rotate(TAU/2, axis = LEFT)\n",
        "            return mob\n",
        "\n",
        "        unit_screen_copy = self.unit_screen.copy()\n",
        "        fourfold_screen = self.unit_screen.copy()\n",
        "        fourfold_screen.scale(2,about_point = self.light_source.get_source_point())\n",
        "\n",
        "        self.remove(self.spotlight)\n",
        "\n",
        "\n",
        "        reading1 = OldTex(\"1\")\n",
        "        orientate(reading1)\n",
        "\n",
        "        self.play(FadeIn(reading1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(reading1))\n",
        "        \n",
        "\n",
        "        self.play(\n",
        "            Transform(self.unit_screen, fourfold_screen)\n",
        "        )\n",
        "\n",
        "        reading21 = OldTex(\"{1\\over 4}\").scale(0.8)\n",
        "        orientate(reading21)\n",
        "        reading22 = reading21.deepcopy()\n",
        "        reading23 = reading21.deepcopy()\n",
        "        reading24 = reading21.deepcopy()\n",
        "        reading21.shift(0.5*OUT + 0.5*UP)\n",
        "        reading22.shift(0.5*OUT + 0.5*DOWN)\n",
        "        reading23.shift(0.5*IN + 0.5*UP)\n",
        "        reading24.shift(0.5*IN + 0.5*DOWN)\n",
        "\n",
        "\n",
        "        corners = fourfold_screen.get_anchors()\n",
        "        midpoint1 = (corners[0] + corners[1])/2\n",
        "        midpoint2 = (corners[1] + corners[2])/2\n",
        "        midpoint3 = (corners[2] + corners[3])/2\n",
        "        midpoint4 = (corners[3] + corners[0])/2\n",
        "        midline1 = Line(midpoint1, midpoint3)\n",
        "        midline2 = Line(midpoint2, midpoint4)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(midline1),\n",
        "            ShowCreation(midline2)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(reading21),\n",
        "            FadeIn(reading22),\n",
        "            FadeIn(reading23),\n",
        "            FadeIn(reading24),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(reading21),\n",
        "            FadeOut(reading22),\n",
        "            FadeOut(reading23),\n",
        "            FadeOut(reading24),\n",
        "            FadeOut(midline1),\n",
        "            FadeOut(midline2)\n",
        "        )\n",
        "\n",
        "        ninefold_screen = unit_screen_copy.copy()\n",
        "        ninefold_screen.scale(3,about_point = self.light_source.get_source_point())\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.unit_screen, ninefold_screen)\n",
        "        )\n",
        "\n",
        "        reading31 = OldTex(\"{1\\over 9}\").scale(0.8)\n",
        "        orientate(reading31)\n",
        "        reading32 = reading31.deepcopy()\n",
        "        reading33 = reading31.deepcopy()\n",
        "        reading34 = reading31.deepcopy()\n",
        "        reading35 = reading31.deepcopy()\n",
        "        reading36 = reading31.deepcopy()\n",
        "        reading37 = reading31.deepcopy()\n",
        "        reading38 = reading31.deepcopy()\n",
        "        reading39 = reading31.deepcopy()\n",
        "        reading31.shift(IN + UP)\n",
        "        reading32.shift(IN)\n",
        "        reading33.shift(IN + DOWN)\n",
        "        reading34.shift(UP)\n",
        "        reading35.shift(ORIGIN)\n",
        "        reading36.shift(DOWN)\n",
        "        reading37.shift(OUT + UP)\n",
        "        reading38.shift(OUT)\n",
        "        reading39.shift(OUT + DOWN)\n",
        "\n",
        "        corners = ninefold_screen.get_anchors()\n",
        "        midpoint11 = (2*corners[0] + corners[1])/3\n",
        "        midpoint12 = (corners[0] + 2*corners[1])/3\n",
        "        midpoint21 = (2*corners[1] + corners[2])/3\n",
        "        midpoint22 = (corners[1] + 2*corners[2])/3\n",
        "        midpoint31 = (2*corners[2] + corners[3])/3\n",
        "        midpoint32 = (corners[2] + 2*corners[3])/3\n",
        "        midpoint41 = (2*corners[3] + corners[0])/3\n",
        "        midpoint42 = (corners[3] + 2*corners[0])/3\n",
        "        midline11 = Line(midpoint11, midpoint32)\n",
        "        midline12 = Line(midpoint12, midpoint31)\n",
        "        midline21 = Line(midpoint21, midpoint42)\n",
        "        midline22 = Line(midpoint22, midpoint41)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(midline11),\n",
        "            ShowCreation(midline12),\n",
        "            ShowCreation(midline21),\n",
        "            ShowCreation(midline22),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(reading31),\n",
        "            FadeIn(reading32),\n",
        "            FadeIn(reading33),\n",
        "            FadeIn(reading34),\n",
        "            FadeIn(reading35),\n",
        "            FadeIn(reading36),\n",
        "            FadeIn(reading37),\n",
        "            FadeIn(reading38),\n",
        "            FadeIn(reading39),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class IndicatorScalingScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        unit_intensity = 0.6\n",
        "\n",
        "        indicator1 = LightIndicator(show_reading = False, color = LIGHT_COLOR)\n",
        "        indicator1.set_intensity(unit_intensity)\n",
        "        reading1 = OldTex(\"1\")\n",
        "        reading1.move_to(indicator1)\n",
        "        \n",
        "\n",
        "        indicator2 = LightIndicator(show_reading = False, color = LIGHT_COLOR)\n",
        "        indicator2.shift(2*RIGHT)\n",
        "        indicator2.set_intensity(unit_intensity/4)\n",
        "        reading2 = OldTex(\"{1\\over 4}\").scale(0.8)\n",
        "        reading2.move_to(indicator2)\n",
        "\n",
        "        indicator3 = LightIndicator(show_reading = False, color = LIGHT_COLOR)\n",
        "        indicator3.shift(4*RIGHT)\n",
        "        indicator3.set_intensity(unit_intensity/9)\n",
        "        reading3 = OldTex(\"{1\\over 9}\").scale(0.8)\n",
        "        reading3.move_to(indicator3)\n",
        "\n",
        "        \n",
        "        self.play(FadeIn(indicator1))\n",
        "        self.play(FadeIn(reading1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(reading1))\n",
        "        self.play(Transform(indicator1, indicator2))\n",
        "        self.play(FadeIn(reading2))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(reading2))\n",
        "        self.play(Transform(indicator1, indicator3))\n",
        "        self.play(FadeIn(reading3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class BackToEulerSumScene(PiCreatureScene):\n",
        "\n",
        "   \n",
        "    def construct(self):\n",
        "        self.remove(self.get_primary_pi_creature())\n",
        "\n",
        "        NUM_CONES = 7\n",
        "        NUM_VISIBLE_CONES = 6\n",
        "        INDICATOR_RADIUS = 0.5\n",
        "        OPACITY_FOR_UNIT_INTENSITY = 1.0\n",
        "\n",
        "        self.number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            color = WHITE,\n",
        "            number_at_center = 1.6,\n",
        "            stroke_width = 1,\n",
        "            big_tick_numbers = list(range(1,5)),\n",
        "            numbers_to_show = list(range(1,5)),\n",
        "            unit_size = 2,\n",
        "            tick_frequency = 0.2,\n",
        "            line_to_number_buff = LARGE_BUFF,\n",
        "            label_direction = UP,\n",
        "        )\n",
        "\n",
        "        self.number_line.label_direction = DOWN\n",
        "        #self.number_line.shift(3*UP)\n",
        "\n",
        "        self.number_line_labels = self.number_line.get_number_mobjects()\n",
        "        self.add(self.number_line,self.number_line_labels)\n",
        "        self.wait()\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "\n",
        "        self.default_pi_creature_class = Randolph\n",
        "        randy = self.get_primary_pi_creature()\n",
        "\n",
        "        randy.scale(0.5)\n",
        "        randy.flip()\n",
        "        right_pupil = randy.pupils[1]\n",
        "        randy.next_to(origin_point, LEFT, buff = 0, submobject_to_align = right_pupil)\n",
        "\n",
        "        randy_copy = randy.copy()\n",
        "        randy_copy.target = randy.copy().shift(DOWN)\n",
        "\n",
        "\n",
        "\n",
        "        bubble = ThoughtBubble(direction = RIGHT,\n",
        "                            width = 4, height = 3,\n",
        "                            file_name = \"Bubbles_thought.svg\")\n",
        "        bubble.next_to(randy,LEFT+UP)\n",
        "        bubble.set_fill(color = BLACK, opacity = 1)\n",
        "        \n",
        "        self.play(\n",
        "            randy.change, \"wave_2\",\n",
        "            ShowCreation(bubble),\n",
        "        )\n",
        "\n",
        "\n",
        "        euler_sum = OldTex(\"1\", \"+\", \"{1\\over 4}\", \n",
        "            \"+\", \"{1\\over 9}\", \"+\", \"{1\\over 16}\", \"+\", \"{1\\over 25}\", \"+\", \"\\cdots\", \" \")\n",
        "        # the last entry is a dummy element which makes looping easier\n",
        "        # used just for putting the fractions into the light indicators\n",
        "            \n",
        "        intensities = np.array([1./(n+1)**2 for n in range(NUM_CONES)])\n",
        "        opacities = intensities * OPACITY_FOR_UNIT_INTENSITY\n",
        "\n",
        "        # repeat:\n",
        "\n",
        "        # fade in lighthouse\n",
        "        # switch on / fade in ambient light\n",
        "        # show creation / write light indicator\n",
        "        # move indicator onto origin\n",
        "            # while morphing and dimming\n",
        "        # move indicator into thought bubble\n",
        "            # while indicators already inside shift to the back\n",
        "            # and while term appears in the series below\n",
        "\n",
        "        point = self.number_line.number_to_point(1)\n",
        "        v = point - self.number_line.number_to_point(0)\n",
        "        light_source = LightSource()\n",
        "        light_source.move_source_to(point)\n",
        "        #light_source.ambient_light.move_source_to(point)\n",
        "        #light_source.lighthouse.move_to(point)\n",
        "\n",
        "        self.play(FadeIn(light_source.lighthouse))\n",
        "        self.play(SwitchOn(light_source.ambient_light))\n",
        "\n",
        "\n",
        "        # create an indicator that will move along the number line\n",
        "        indicator = LightIndicator(color = LIGHT_COLOR,\n",
        "                radius = INDICATOR_RADIUS,\n",
        "                opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "                show_reading = False\n",
        "        )\n",
        "        indicator_reading = euler_sum[0]\n",
        "        indicator_reading.set_height(0.5 * indicator.get_height())\n",
        "        indicator_reading.move_to(indicator.get_center())\n",
        "        indicator.add(indicator_reading)\n",
        "        indicator.tex_reading = indicator_reading\n",
        "        # the TeX reading is too bright at full intensity\n",
        "        indicator.tex_reading.set_fill(color = BLACK)\n",
        "        indicator.foreground.set_fill(None,opacities[0])\n",
        "\n",
        "\n",
        "        indicator.move_to(point)\n",
        "        indicator.set_intensity(intensities[0])\n",
        "\n",
        "        self.play(FadeIn(indicator))\n",
        "        self.add_foreground_mobject(indicator)\n",
        "        \n",
        "        collection_point = np.array([-6.,2.,0.])\n",
        "        left_shift = 0.2*LEFT\n",
        "        collected_indicators = Mobject()\n",
        "\n",
        "\n",
        "        for i in range(2, NUM_VISIBLE_CONES + 1):\n",
        "\n",
        "            previous_point = self.number_line.number_to_point(i - 1)\n",
        "            point = self.number_line.number_to_point(i)\n",
        "\n",
        "\n",
        "            v = point - previous_point\n",
        "            #print v\n",
        "            # Create and position the target indicator (next on number line).\n",
        "            indicator_target = indicator.deepcopy()\n",
        "            indicator_target.shift(v)\n",
        "\n",
        "\n",
        "            # Here we make a copy that will move into the thought bubble.\n",
        "            bubble_indicator = indicator.deepcopy()\n",
        "            # And its target\n",
        "            bubble_indicator_target = bubble_indicator.deepcopy()\n",
        "            bubble_indicator_target.set_intensity(intensities[i - 2])\n",
        "\n",
        "            # give the target the appropriate reading\n",
        "            euler_sum[2*i-4].move_to(bubble_indicator_target)\n",
        "            bubble_indicator_target.remove(bubble_indicator_target.tex_reading)\n",
        "            bubble_indicator_target.tex_reading = euler_sum[2*i-4].copy()\n",
        "            bubble_indicator_target.add(bubble_indicator_target.tex_reading)\n",
        "            # center it in the indicator\n",
        "\n",
        "            if bubble_indicator_target.tex_reading.get_tex() != \"1\":\n",
        "                bubble_indicator_target.tex_reading.set_height(0.8*indicator.get_height())\n",
        "            # the target is less bright, possibly switch to a white text color\n",
        "            if bubble_indicator_target.intensity < 0.7:\n",
        "                bubble_indicator.tex_reading.set_fill(color = WHITE)\n",
        "\n",
        "            # position the target in the thought bubble\n",
        "            bubble_indicator_target.move_to(collection_point)\n",
        "\n",
        "\n",
        "            self.add_foreground_mobject(bubble_indicator)\n",
        "\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            self.play(\n",
        "                 Transform(bubble_indicator,bubble_indicator_target),\n",
        "                 collected_indicators.shift,left_shift,\n",
        "            )\n",
        "\n",
        "            collected_indicators.add(bubble_indicator)\n",
        "\n",
        "            new_light = light_source.deepcopy()\n",
        "            w = new_light.get_source_point()\n",
        "            new_light.move_source_to(w + (i-2)*v)\n",
        "            w2 = new_light.get_source_point()\n",
        "            \n",
        "            self.add(new_light.lighthouse)\n",
        "            self.play(\n",
        "                  Transform(indicator,indicator_target),\n",
        "                  new_light.lighthouse.shift,v,\n",
        "            )\n",
        "            new_light.move_source_to(w + (i-1)*v)\n",
        "            new_light.lighthouse.move_to(w + (i-1)*v)\n",
        "\n",
        "            self.play(SwitchOn(new_light.ambient_light),\n",
        "            )\n",
        "\n",
        "\n",
        "            \n",
        "\n",
        "        # quickly switch on off-screen light cones\n",
        "        for i in range(NUM_VISIBLE_CONES,NUM_CONES):\n",
        "            indicator_start_time = 0.5 * (i+1) * FAST_SWITCH_ON_RUN_TIME/light_source.ambient_light.radius * self.number_line.unit_size\n",
        "            indicator_stop_time = indicator_start_time + FAST_INDICATOR_UPDATE_TIME\n",
        "            indicator_rate_func = squish_rate_func(#smooth, 0.8, 0.9)\n",
        "                smooth,indicator_start_time,indicator_stop_time)\n",
        "            ls = LightSource()\n",
        "            point = point = self.number_line.number_to_point(i)\n",
        "            ls.move_source_to(point)\n",
        "            self.play(\n",
        "                SwitchOn(ls.ambient_light, run_time = FAST_SWITCH_ON_RUN_TIME),\n",
        "            )\n",
        "\n",
        "        # and morph indicator stack into limit value\n",
        "\n",
        "        sum_indicator = LightIndicator(color = LIGHT_COLOR,\n",
        "                radius = INDICATOR_RADIUS,\n",
        "                opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "                show_reading = False\n",
        "            )\n",
        "        sum_indicator.set_intensity(intensities[0] * np.pi**2/6)\n",
        "        sum_indicator_reading = OldTex(\"{\\pi^2 \\over 6}\")\n",
        "        sum_indicator_reading.set_fill(color = BLACK)\n",
        "        sum_indicator_reading.set_height(0.8 * sum_indicator.get_height())\n",
        "        sum_indicator.add(sum_indicator_reading)\n",
        "        sum_indicator.move_to(collection_point)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(collected_indicators),\n",
        "            FadeIn(sum_indicator)\n",
        "        )\n",
        "\n",
        "            \n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class TwoLightSourcesScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        MAX_OPACITY = 0.4\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        OPACITY_FOR_UNIT_INTENSITY = 0.5\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        morty.scale(0.3).flip()\n",
        "        right_pupil = morty.pupils[1]\n",
        "        morty.next_to(C, LEFT, buff = 0, submobject_to_align = right_pupil)\n",
        "\n",
        "        horizontal = VMobject(stroke_width = 1)\n",
        "        horizontal.set_points_as_corners([C,A])\n",
        "        vertical = VMobject(stroke_width = 1)\n",
        "        vertical.set_points_as_corners([C,B])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(horizontal),\n",
        "            ShowCreation(vertical)\n",
        "        )\n",
        "\n",
        "        indicator = LightIndicator(color = LIGHT_COLOR,\n",
        "                radius = INDICATOR_RADIUS,\n",
        "                opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "                show_reading = True,\n",
        "                precision = 2\n",
        "        )\n",
        "\n",
        "        indicator.next_to(morty,LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(indicator)\n",
        "        )\n",
        "\n",
        "\n",
        "        ls1 = LightSource(radius = 20, num_levels = 50)\n",
        "        ls2 = ls1.deepcopy()\n",
        "        ls1.move_source_to(A)\n",
        "        ls2.move_source_to(B)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ls1.lighthouse),\n",
        "            FadeIn(ls2.lighthouse),\n",
        "            SwitchOn(ls1.ambient_light),\n",
        "            SwitchOn(ls2.ambient_light)\n",
        "        )\n",
        "\n",
        "        distance1 = get_norm(C - ls1.get_source_point())\n",
        "        intensity = ls1.ambient_light.opacity_function(distance1) / indicator.opacity_for_unit_intensity\n",
        "        distance2 = get_norm(C - ls2.get_source_point())\n",
        "        intensity += ls2.ambient_light.opacity_function(distance2) / indicator.opacity_for_unit_intensity\n",
        "\n",
        "        self.play(\n",
        "            UpdateLightIndicator(indicator,intensity)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        ls3 = ls1.deepcopy()\n",
        "        ls3.move_to(np.array([6,3.5,0]))\n",
        "\n",
        "        new_indicator = indicator.copy()\n",
        "        new_indicator.light_source = ls3\n",
        "        new_indicator.measurement_point = C\n",
        "        self.add(new_indicator)\n",
        "        self.play(\n",
        "            indicator.shift, 2 * UP\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        #intensity = intensity_for_light_source(ls3)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            SwitchOff(ls1.ambient_light),\n",
        "            #FadeOut(ls1.lighthouse),\n",
        "            SwitchOff(ls2.ambient_light),\n",
        "            #FadeOut(ls2.lighthouse),\n",
        "            UpdateLightIndicator(new_indicator,0.0)\n",
        "        )\n",
        "\n",
        "        # create a *continual* animation for the replacement source\n",
        "        updater = ContinualLightIndicatorUpdate(new_indicator)\n",
        "        self.add(updater)\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ls3.ambient_light),\n",
        "            FadeIn(ls3.lighthouse),\n",
        "            \n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # move the light source around\n",
        "        # TODO: moving along a path arc\n",
        "\n",
        "        location = np.array([-3,-2.,0.])\n",
        "        self.play(ls3.move_source_to,location)\n",
        "        location = np.array([6.,1.,0.])\n",
        "        self.play(ls3.move_source_to,location)\n",
        "        location = np.array([5.,2.,0.])\n",
        "        self.play(ls3.move_source_to,location)\n",
        "        closer_location = interpolate(location, C, 0.5)\n",
        "        self.play(ls3.move_source_to,closer_location)\n",
        "        self.play(ls3.move_source_to,location)\n",
        "\n",
        "        # maybe move in a circle around C using a loop?\n",
        "\n",
        "\n",
        "\n",
        "        self.play(ls3.move_source_to,H)\n",
        "\n",
        "\n",
        "\n",
        "        # draw lines to complete the geometric picture\n",
        "        # and label the lengths\n",
        "\n",
        "        line_a = VMobject()\n",
        "        line_a.set_points_as_corners([B,C])\n",
        "        line_b = VMobject()\n",
        "        line_b.set_points_as_corners([A,C])\n",
        "        line_c = VMobject()\n",
        "        line_c.set_points_as_corners([A,B])\n",
        "        line_h = VMobject()\n",
        "        line_h.set_points_as_corners([H,C])\n",
        "\n",
        "        label_a = OldTex(\"a\")\n",
        "        label_a.next_to(line_a, LEFT, buff = 0.5)\n",
        "        label_b = OldTex(\"b\")\n",
        "        label_b.next_to(line_b, DOWN, buff = 0.5)\n",
        "        label_h = OldTex(\"h\")\n",
        "        label_h.next_to(line_h.get_center(), RIGHT, buff = 0.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_a),\n",
        "            Write(label_a)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_b),\n",
        "            Write(label_b)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_c),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_h),\n",
        "            Write(label_h)\n",
        "        )\n",
        "\n",
        "\n",
        "        # state the IPT\n",
        "        theorem_location = np.array([3.,2.,0.])\n",
        "        theorem = OldTex(\"{1\\over a^2} + {1\\over b^2} = {1\\over h^2}\")\n",
        "        theorem_name = OldTexText(\"Inverse Pythagorean Theorem\")\n",
        "        buffer = 1.2\n",
        "        theorem_box = Rectangle(width = buffer*theorem.get_width(),\n",
        "            height = buffer*theorem.get_height())\n",
        "\n",
        "        theorem.move_to(theorem_location)\n",
        "        theorem_box.move_to(theorem_location)\n",
        "        theorem_name.next_to(theorem_box,UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(theorem),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(theorem_box),\n",
        "            Write(theorem_name),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "class IPTScene1(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        show_detail = True\n",
        "\n",
        "        SCREEN_SCALE = 0.1\n",
        "        SCREEN_THICKNESS = 0.2\n",
        "\n",
        "\n",
        "        # use the following for the zoomed inset\n",
        "        if show_detail:\n",
        "            self.camera.frame_shape = (0.02 * FRAME_HEIGHT, 0.02 * FRAME_WIDTH)\n",
        "            self.camera.frame_center = C\n",
        "            SCREEN_SCALE = 0.01\n",
        "            SCREEN_THICKNESS = 0.02\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        self.remove(morty)\n",
        "        morty.scale(0.3).flip()\n",
        "        right_pupil = morty.pupils[1]\n",
        "        morty.next_to(C, LEFT, buff = 0, submobject_to_align = right_pupil)\n",
        "        \n",
        "        if not show_detail:\n",
        "            self.add_foreground_mobject(morty)\n",
        "\n",
        "        stroke_width = 6\n",
        "        line_a = Line(B,C,stroke_width = stroke_width)\n",
        "        line_b = Line(A,C,stroke_width = stroke_width)\n",
        "        line_c = Line(A,B,stroke_width = stroke_width)\n",
        "        line_h = Line(C,H,stroke_width = stroke_width)\n",
        "\n",
        "        length_a = line_a.get_length()\n",
        "        length_b = line_b.get_length()\n",
        "        length_c = line_c.get_length()\n",
        "        length_h = line_h.get_length()\n",
        "\n",
        "        label_a = OldTex(\"a\")\n",
        "        label_a.next_to(line_a, LEFT, buff = 0.5)\n",
        "        label_b = OldTex(\"b\")\n",
        "        label_b.next_to(line_b, DOWN, buff = 0.5)\n",
        "        label_h = OldTex(\"h\")\n",
        "        label_h.next_to(line_h.get_center(), RIGHT, buff = 0.5)\n",
        "\n",
        "        self.add_foreground_mobject(line_a)\n",
        "        self.add_foreground_mobject(line_b)\n",
        "        self.add_foreground_mobject(line_c)\n",
        "        self.add_foreground_mobject(line_h)\n",
        "        self.add_foreground_mobject(label_a)\n",
        "        self.add_foreground_mobject(label_b)\n",
        "        self.add_foreground_mobject(label_h)\n",
        "        \n",
        "        if not show_detail:\n",
        "            self.add_foreground_mobject(morty)\n",
        "\n",
        "        ls1 = LightSource(radius = 10)\n",
        "        ls1.move_source_to(B)\n",
        "\n",
        "        self.add(ls1.lighthouse)\n",
        "\n",
        "        if not show_detail:\n",
        "            self.play(\n",
        "                SwitchOn(ls1.ambient_light)\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # adding the first screen\n",
        "\n",
        "        screen_width_a = SCREEN_SCALE * length_a\n",
        "        screen_width_b = SCREEN_SCALE * length_b\n",
        "        screen_width_ap = screen_width_a * length_a / length_c\n",
        "        screen_width_bp = screen_width_b * length_b / length_c\n",
        "        screen_width_c = SCREEN_SCALE * length_c\n",
        "\n",
        "        screen_thickness_a = SCREEN_THICKNESS\n",
        "        screen_thickness_b = SCREEN_THICKNESS\n",
        "\n",
        "        screen1 = Rectangle(width = screen_width_b,\n",
        "            height = screen_thickness_b, \n",
        "            stroke_width = 0, \n",
        "            fill_opacity = 1.0)\n",
        "        screen1.move_to(C + screen_width_b/2 * RIGHT + screen_thickness_b/2 * DOWN)\n",
        "        \n",
        "        if not show_detail:\n",
        "            self.add_foreground_mobject(morty)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(screen1)\n",
        "        )\n",
        "        self.add_foreground_mobject(screen1)\n",
        "\n",
        "        ls1.set_screen(screen1)\n",
        "        screen_tracker = ScreenTracker(ls1)\n",
        "        self.add(screen_tracker)\n",
        "        #self.add(ls1.shadow)\n",
        "\n",
        "        if not show_detail:\n",
        "            self.play(\n",
        "                SwitchOn(ls1.ambient_light)\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ls1.spotlight),\n",
        "            SwitchOff(ls1.ambient_light)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        # now move the light source to the height point\n",
        "        # while shifting scaling the screen\n",
        "        screen1p = screen1.deepcopy()\n",
        "        screen1pp = screen1.deepcopy()\n",
        "        #self.add(screen1p)\n",
        "        angle = np.arccos(length_b / length_c)\n",
        "        \n",
        "        screen1p.stretch_to_fit_width(screen_width_bp)\n",
        "        screen1p.move_to(C + (screen_width_b - screen_width_bp/2) * RIGHT + SCREEN_THICKNESS/2 * DOWN)\n",
        "        screen1p.rotate(-angle, about_point = C + screen_width_b * RIGHT)\n",
        "        \n",
        "\n",
        "        self.play(\n",
        "            ls1.move_source_to,H,\n",
        "            Transform(screen1,screen1p)\n",
        "        )\n",
        "\n",
        "        # add and move the second light source and screen\n",
        "        ls2 = ls1.deepcopy()\n",
        "        ls2.move_source_to(A)\n",
        "        screen2 = Rectangle(width = screen_width_a,\n",
        "            height = screen_thickness_a, \n",
        "            stroke_width = 0, \n",
        "            fill_opacity = 1.0)\n",
        "        screen2.rotate(-TAU/4)\n",
        "        screen2.move_to(C + screen_width_a/2 * UP + screen_thickness_a/2 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(screen2)\n",
        "        )\n",
        "        self.add_foreground_mobject(screen2)\n",
        "\n",
        "        if not show_detail:\n",
        "            self.add_foreground_mobject(morty)\n",
        "\n",
        "        # the same scene adding sequence as before\n",
        "        ls2.set_screen(screen2)\n",
        "        screen_tracker2 = ScreenTracker(ls2)\n",
        "        self.add(screen_tracker2)\n",
        "\n",
        "        if not show_detail:\n",
        "            self.play(\n",
        "                SwitchOn(ls2.ambient_light)\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ls2.spotlight),\n",
        "            SwitchOff(ls2.ambient_light)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        # now move the light source to the height point\n",
        "        # while shifting scaling the screen\n",
        "        screen2p = screen2.deepcopy()\n",
        "        screen2pp = screen2.deepcopy()\n",
        "        angle = np.arccos(length_a / length_c)\n",
        "        screen2p.stretch_to_fit_height(screen_width_ap)\n",
        "        screen2p.move_to(C + (screen_width_a - screen_width_ap/2) * UP + screen_thickness_a/2 * LEFT)\n",
        "        screen2p.rotate(angle, about_point = C + screen_width_a * UP)\n",
        "        # we can reuse the translation vector\n",
        "        # screen2p.shift(vector)\n",
        "\n",
        "        self.play(\n",
        "            ls2.move_source_to,H,\n",
        "            SwitchOff(ls1.ambient_light),\n",
        "            Transform(screen2,screen2p)\n",
        "        )\n",
        "\n",
        "        # now transform both screens back\n",
        "        self.play(\n",
        "            Transform(screen1, screen1pp),\n",
        "            Transform(screen2, screen2pp),\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "class IPTScene2(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        intensity1 = 0.3\n",
        "        intensity2 = 0.2\n",
        "        formula_scale = 01.2\n",
        "        indy_radius = 1\n",
        "\n",
        "        indy1 = LightIndicator(color = LIGHT_COLOR, show_reading = False, radius = indy_radius)\n",
        "        indy1.set_intensity(intensity1)\n",
        "        reading1 = OldTex(\"{1\\over a^2}\").scale(formula_scale).move_to(indy1)\n",
        "        indy1.add(reading1)\n",
        "\n",
        "        indy2 = LightIndicator(color = LIGHT_COLOR, show_reading = False, radius = indy_radius)\n",
        "        indy2.set_intensity(intensity2)\n",
        "        reading2 = OldTex(\"{1\\over b^2}\").scale(formula_scale).move_to(indy2)\n",
        "        indy2.add(reading2)\n",
        "\n",
        "        indy3 = LightIndicator(color = LIGHT_COLOR, show_reading = False, radius = indy_radius)\n",
        "        indy3.set_intensity(intensity1 + intensity2)\n",
        "        reading3 = OldTex(\"{1\\over h^2}\").scale(formula_scale).move_to(indy3)\n",
        "        indy3.add(reading3)\n",
        "\n",
        "        plus_sign = OldTex(\"+\").scale(formula_scale)\n",
        "        equals_sign = OldTex(\"=\").scale(formula_scale)\n",
        "\n",
        "        plus_sign.next_to(indy1, RIGHT)\n",
        "        indy2.next_to(plus_sign, RIGHT)\n",
        "        equals_sign.next_to(indy2, RIGHT)\n",
        "        indy3.next_to(equals_sign, RIGHT)\n",
        "        \n",
        "\n",
        "        formula = VGroup(\n",
        "            indy1, plus_sign, indy2, equals_sign, indy3\n",
        "        )\n",
        "\n",
        "        formula.move_to(ORIGIN)\n",
        "\n",
        "        self.play(FadeIn(indy1))\n",
        "        self.play(FadeIn(plus_sign), FadeIn(indy2))\n",
        "        self.play(FadeIn(equals_sign), FadeIn(indy3))\n",
        "\n",
        "        buffer = 1.5\n",
        "        box = Rectangle(width = formula.get_width() * buffer,\n",
        "            height = formula.get_height() * buffer)\n",
        "        box.move_to(formula)\n",
        "        text = OldTexText(\"Inverse Pythagorean Theorem\").scale(formula_scale)\n",
        "        text.next_to(box,UP)\n",
        "        self.play(ShowCreation(box),Write(text))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class InscribedAngleScene(ThreeDScene):\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = [0,BASELINE_YPOS,0]\n",
        "        LAKE0_RADIUS = 1.5\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.3\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        LIGHT_MAX_INT = 1\n",
        "        LIGHT_SCALE = 5\n",
        "        LIGHT_CUTOFF = 1\n",
        "\n",
        "        self.cumulated_zoom_factor = 1\n",
        "\n",
        "\n",
        "        def zoom_out_scene(factor):\n",
        "\n",
        "\n",
        "            phi0 = self.camera.get_phi() # default is 0 degs\n",
        "            theta0 = self.camera.get_theta() # default is -90 degs\n",
        "            distance0 = self.camera.get_distance()\n",
        "\n",
        "            distance1 = 2 * distance0\n",
        "            camera_target_point = self.camera.get_spherical_coords(phi0, theta0, distance1)\n",
        "\n",
        "            self.play(\n",
        "                ApplyMethod(self.camera.rotation_mobject.move_to, camera_target_point),\n",
        "                self.zoomable_mobs.shift, self.obs_dot.get_center(),\n",
        "                self.unzoomable_mobs.scale,2,{\"about_point\" : ORIGIN},\n",
        "            )\n",
        "\n",
        "            self.cumulated_zoom_factor *= factor\n",
        "\n",
        "\n",
        "        def shift_scene(v):\n",
        "            self.play(\n",
        "                self.zoomable_mobs.shift,v,\n",
        "                self.unzoomable_mobs.shift,v\n",
        "            )\n",
        "\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.zoomable_mobs = VMobject()\n",
        "        self.unzoomable_mobs = VMobject()\n",
        "\n",
        "\n",
        "        baseline = VMobject()\n",
        "        baseline.set_points_as_corners([[-8,BASELINE_YPOS,0],[8,BASELINE_YPOS,0]])\n",
        "        baseline.set_stroke(width = 0) # in case it gets accidentally added to the scene\n",
        "        self.zoomable_mobs.add(baseline) # prob not necessary\n",
        "\n",
        "        self.obs_dot = Dot(OBSERVER_POINT, fill_color = DOT_COLOR)\n",
        "        self.ls0_dot = Dot(OBSERVER_POINT + 2 * LAKE0_RADIUS * UP, fill_color = WHITE)\n",
        "        self.unzoomable_mobs.add(self.obs_dot) #, self.ls0_dot)\n",
        "\n",
        "        # lake\n",
        "        lake0 = Circle(radius = LAKE0_RADIUS,\n",
        "            stroke_width = 0,\n",
        "            fill_color = LAKE_COLOR,\n",
        "            fill_opacity = LAKE_OPACITY\n",
        "        )\n",
        "        lake0.move_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "        self.zoomable_mobs.add(lake0)\n",
        "\n",
        "        # Morty and indicator\n",
        "        morty = Mortimer().scale(0.3)\n",
        "        morty.next_to(OBSERVER_POINT,DOWN)\n",
        "        indicator = LightIndicator(precision = 2,\n",
        "            radius = INDICATOR_RADIUS,\n",
        "            show_reading  = False,\n",
        "            color = LIGHT_COLOR\n",
        "        )\n",
        "        indicator.next_to(morty,LEFT)\n",
        "        self.unzoomable_mobs.add(morty, indicator)\n",
        "\n",
        "        # first lighthouse\n",
        "        original_op_func = inverse_quadratic(LIGHT_MAX_INT,AMBIENT_SCALE,LIGHT_CUTOFF)\n",
        "        ls0 = LightSource(opacity_function = original_op_func, num_levels = NUM_LEVELS)\n",
        "        ls0.move_source_to(OBSERVER_POINT + LAKE0_RADIUS * 2 * UP)\n",
        "        self.zoomable_mobs.add(ls0, ls0.lighthouse, ls0.ambient_light)\n",
        "\n",
        "        self.add(lake0,morty,self.obs_dot,self.ls0_dot, ls0.lighthouse)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # shore arcs\n",
        "        arc_left = Arc(-TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_left.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_left = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_left.next_to(arc_left,LEFT)\n",
        "        \n",
        "\n",
        "        arc_right = Arc(TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_right.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_right = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_right.next_to(arc_right,RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc_left),\n",
        "            Write(one_left),\n",
        "            ShowCreation(arc_right),\n",
        "            Write(one_right),\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ls0.ambient_light),\n",
        "            lake0.set_stroke,{\"color\": LAKE_STROKE_COLOR, \"width\" : LAKE_STROKE_WIDTH},\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(indicator))\n",
        "\n",
        "        self.play(\n",
        "            indicator.set_intensity,0.5\n",
        "        )\n",
        "\n",
        "        # diameter\n",
        "        diameter = DoubleArrow(OBSERVER_POINT,\n",
        "            ls0.get_source_point(),\n",
        "            buff = 0,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        diameter_text = OldTex(\"d\").scale(TEX_SCALE)\n",
        "        diameter_text.next_to(diameter,RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(diameter),\n",
        "            Write(diameter_text),\n",
        "            #FadeOut(self.obs_dot),\n",
        "            FadeOut(self.ls0_dot)\n",
        "        )\n",
        "\n",
        "        indicator_reading = OldTex(\"{1\\over d^2}\").scale(TEX_SCALE)\n",
        "        indicator_reading.move_to(indicator)\n",
        "        self.unzoomable_mobs.add(indicator_reading)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(indicator_reading)\n",
        "        )\n",
        "\n",
        "        # replace d with its value\n",
        "        new_diameter_text = OldTex(\"{2\\over \\pi}\").scale(TEX_SCALE)\n",
        "        new_diameter_text.color = LAKE_COLOR\n",
        "        new_diameter_text.move_to(diameter_text)\n",
        "        self.play(\n",
        "            Transform(diameter_text,new_diameter_text)\n",
        "        )\n",
        "\n",
        "        # insert into indicator reading\n",
        "        new_reading = OldTex(\"{\\pi^2 \\over 4}\").scale(TEX_SCALE)\n",
        "        new_reading.move_to(indicator)\n",
        "\n",
        "        self.play(\n",
        "            Transform(indicator_reading,new_reading)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(one_left),\n",
        "            FadeOut(one_right),\n",
        "            FadeOut(diameter_text),\n",
        "            FadeOut(arc_left),\n",
        "            FadeOut(arc_right)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        def indicator_wiggle():\n",
        "            INDICATOR_WIGGLE_FACTOR = 1.3\n",
        "\n",
        "            self.play(\n",
        "                ScaleInPlace(indicator, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle),\n",
        "                ScaleInPlace(indicator_reading, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle)\n",
        "            )\n",
        "\n",
        "\n",
        "        def angle_for_index(i,step):\n",
        "            return -TAU/4 + TAU/2**step * (i + 0.5)\n",
        "\n",
        "\n",
        "        def position_for_index(i, step, scaled_down = False):\n",
        "\n",
        "            theta = angle_for_index(i,step)\n",
        "            radial_vector = np.array([np.cos(theta),np.sin(theta),0])\n",
        "            position = self.lake_center + self.lake_radius * radial_vector\n",
        "\n",
        "            if scaled_down:\n",
        "                return position.scale_about_point(self.obs_dot.get_center(),0.5)\n",
        "            else:\n",
        "                return position\n",
        "\n",
        "\n",
        "        def split_light_source(i, step, show_steps = True, run_time = 1):\n",
        "\n",
        "            ls_new_loc1 = position_for_index(i,step + 1)\n",
        "            ls_new_loc2 = position_for_index(i + 2**step,step + 1)\n",
        "\n",
        "            hyp = VMobject()\n",
        "            hyp1 = Line(self.lake_center,ls_new_loc1)\n",
        "            hyp2 = Line(self.lake_center,ls_new_loc2)\n",
        "            hyp.add(hyp2,hyp1)\n",
        "            self.new_hypotenuses.append(hyp)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(hyp, run_time = run_time)\n",
        "                )\n",
        "\n",
        "            leg1 = Line(self.obs_dot.get_center(),ls_new_loc1)\n",
        "            leg2 = Line(self.obs_dot.get_center(),ls_new_loc2)\n",
        "            self.new_legs_1.append(leg1)\n",
        "            self.new_legs_2.append(leg2)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(leg1, run_time = run_time),\n",
        "                    ShowCreation(leg2, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            ls1 = self.light_sources_array[i]\n",
        "\n",
        "\n",
        "            ls2 = ls1.copy()\n",
        "            self.add(ls2)\n",
        "            self.additional_light_sources.append(ls2)\n",
        "\n",
        "            # check if the light sources are on screen\n",
        "            ls_old_loc = np.array(ls1.get_source_point())\n",
        "            onscreen_old = np.all(np.abs(ls_old_loc[:2]) < 10 ** 2**step)\n",
        "            onscreen_1 = np.all(np.abs(ls_new_loc1[:2][:2]) < 10 ** 2**step)\n",
        "            onscreen_2 = np.all(np.abs(ls_new_loc2[:2]) < 10 ** 2**step)\n",
        "            show_animation = (onscreen_old or onscreen_1 or onscreen_2)\n",
        "\n",
        "            if show_animation:\n",
        "                print(\"animating (\", i, \",\", step, \")\")\n",
        "                self.play(\n",
        "                    ApplyMethod(ls1.move_source_to,ls_new_loc1, run_time = run_time),\n",
        "                    ApplyMethod(ls2.move_source_to,ls_new_loc2, run_time = run_time),\n",
        "                )\n",
        "            else:\n",
        "                ls1.move_source_to(ls_new_loc1)\n",
        "                ls2.move_source_to(ls_new_loc1)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        def construction_step(n, show_steps = True, run_time = 1,\n",
        "            simultaneous_splitting = False):\n",
        "\n",
        "            # we assume that the scene contains:\n",
        "            # an inner lake, self.inner_lake\n",
        "            # an outer lake, self.outer_lake\n",
        "            # light sources, self.light_sources\n",
        "            # legs from the observer point to each light source\n",
        "            # self.legs\n",
        "            # altitudes from the observer point to the\n",
        "            # locations of the light sources in the previous step\n",
        "            # self.altitudes\n",
        "            # hypotenuses connecting antipodal light sources\n",
        "            # self.hypotenuses\n",
        "\n",
        "            # these are mobjects!\n",
        "\n",
        "\n",
        "            # first, fade out all of the hypotenuses and altitudes\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.zoomable_mobs.remove(self.hypotenuses, self.altitudes, self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.hypotenuses),\n",
        "                    FadeOut(self.altitudes),\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "            else:\n",
        "                self.zoomable_mobs.remove(self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "\n",
        "            # create a new, outer lake\n",
        "            self.lake_center = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "\n",
        "            new_outer_lake = Circle(radius = self.lake_radius,\n",
        "                stroke_width = LAKE_STROKE_WIDTH,\n",
        "                fill_color = LAKE_COLOR,\n",
        "                fill_opacity = LAKE_OPACITY,\n",
        "                stroke_color = LAKE_STROKE_COLOR\n",
        "            )\n",
        "            new_outer_lake.move_to(self.lake_center)\n",
        "\n",
        "            if show_steps == True: \n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                    FadeIn(self.ls0_dot)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            self.inner_lake = self.outer_lake\n",
        "            self.outer_lake = new_outer_lake\n",
        "            self.altitudes = self.legs\n",
        "            #self.lake_center = self.outer_lake.get_center()\n",
        "\n",
        "            self.additional_light_sources = []\n",
        "            self.new_legs_1 = []\n",
        "            self.new_legs_2 = []\n",
        "            self.new_hypotenuses = [] \n",
        "\n",
        "            for i in range(2**n):\n",
        "                split_light_source(i,\n",
        "                    step = n,\n",
        "                    show_steps = show_steps,\n",
        "                    run_time = run_time\n",
        "                )\n",
        "\n",
        "\n",
        "\n",
        "            # collect the newly created mobs (in arrays)\n",
        "            # into the appropriate Mobject containers\n",
        "\n",
        "            self.legs = VMobject()\n",
        "            for leg in self.new_legs_1:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "            for leg in self.new_legs_2:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "\n",
        "            for hyp in self.hypotenuses.submobjects:\n",
        "                self.zoomable_mobs.remove(hyp)\n",
        "\n",
        "            self.hypotenuses = VMobject()\n",
        "            for hyp in self.new_hypotenuses:\n",
        "                self.hypotenuses.add(hyp)\n",
        "                self.zoomable_mobs.add(hyp)\n",
        "\n",
        "            for ls in self.additional_light_sources:\n",
        "                self.light_sources.add(ls)\n",
        "                self.light_sources_array.append(ls)\n",
        "                self.zoomable_mobs.add(ls)\n",
        "\n",
        "            # update scene\n",
        "            self.add(\n",
        "                self.light_sources,\n",
        "                self.inner_lake,\n",
        "                self.outer_lake,\n",
        "            )\n",
        "            self.zoomable_mobs.add(self.light_sources, self.inner_lake, self.outer_lake)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.add(\n",
        "                    self.legs,\n",
        "                    self.hypotenuses,\n",
        "                    self.altitudes,\n",
        "                )\n",
        "                self.zoomable_mobs.add(self.legs, self.hypotenuses, self.altitudes)\n",
        "\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "            #self.lake_center = ls0_loc = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "            self.lake_radius *= 2\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.lake_center = ls0_loc = ls0.get_source_point()\n",
        "\n",
        "        self.inner_lake = VMobject()\n",
        "        self.outer_lake = lake0\n",
        "        self.legs = VMobject()\n",
        "        self.legs.add(Line(OBSERVER_POINT,self.lake_center))\n",
        "        self.altitudes = VMobject()\n",
        "        self.hypotenuses = VMobject()\n",
        "        self.light_sources_array = [ls0]\n",
        "        self.light_sources = VMobject()\n",
        "        self.light_sources.add(ls0)\n",
        "\n",
        "        self.lake_radius = 2 * LAKE0_RADIUS # don't ask...\n",
        "\n",
        "        self.zoomable_mobs.add(self.inner_lake, self.outer_lake, self.altitudes, self.light_sources)\n",
        "\n",
        "        self.add(self.inner_lake,\n",
        "            self.outer_lake,\n",
        "            self.legs,\n",
        "            self.altitudes,\n",
        "            self.hypotenuses\n",
        "        )\n",
        "\n",
        "        self.play(FadeOut(diameter))\n",
        "        \n",
        "        self.additional_light_sources = []\n",
        "        self.new_legs_1 = []\n",
        "        self.new_legs_2 = []\n",
        "        self.new_hypotenuses = []\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        construction_step(0)\n",
        "        indicator_wiggle()\n",
        "        self.play(FadeOut(self.ls0_dot))\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "        return\n",
        "\n",
        "        construction_step(1)\n",
        "        indicator_wiggle()\n",
        "        self.play(FadeOut(self.ls0_dot))\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "        construction_step(2)\n",
        "        indicator_wiggle()\n",
        "        self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "\n",
        "        ANGLE_COLOR1 = BLUE_C\n",
        "        ANGLE_COLOR2 = GREEN_D\n",
        "\n",
        "        \n",
        "        for mob in self.mobjects:\n",
        "            mob.fade(1.0)\n",
        "\n",
        "        for hyp in self.hypotenuses:\n",
        "            hyp.set_stroke(width = 0)\n",
        "        for alt in self.altitudes:\n",
        "            alt.set_stroke(width = 0)\n",
        "        for leg in self.legs:\n",
        "            leg.set_stroke(width = 0)\n",
        "        self.inner_lake.set_stroke(width = 0)\n",
        "        self.outer_lake.set_stroke(width = 0)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        inner_lake_center = self.inner_lake.get_center()\n",
        "        inner_lake_radius = self.lake_radius * 0.25\n",
        "        inner_ls = VGroup()\n",
        "        for i in range(4):\n",
        "            theta = -TAU/4 + (i+0.5) * TAU/4\n",
        "            point = inner_lake_center + inner_lake_radius * np.array([np.cos(theta), np.sin(theta),0])\n",
        "            dot = Dot(point, color = LAKE_STROKE_COLOR, radius = 0.3)\n",
        "            inner_ls.add(dot)\n",
        "\n",
        "        self.add(inner_ls)\n",
        "\n",
        "        inner_ls1 = inner_ls.submobjects[0]\n",
        "        inner_ls2 = inner_ls.submobjects[1]\n",
        "        inner_ls1_center = inner_ls1.get_center()\n",
        "        inner_ls2_center = inner_ls2.get_center()\n",
        "\n",
        "        outer_lake_center = self.outer_lake.get_center()\n",
        "        outer_lake_radius = self.lake_radius * 0.5\n",
        "        outer_ls = VGroup()\n",
        "        for i in range(8):\n",
        "            theta = -TAU/4 + (i+0.5) * TAU/8\n",
        "            point = outer_lake_center + outer_lake_radius * np.array([np.cos(theta), np.sin(theta),0])\n",
        "            dot = Dot(point, color = LAKE_STROKE_COLOR, radius = 0.3)\n",
        "            outer_ls.add(dot)\n",
        "\n",
        "        self.add(outer_ls)\n",
        "\n",
        "        outer_ls1 = outer_ls.submobjects[0]\n",
        "        outer_ls2 = outer_ls.submobjects[1]\n",
        "        outer_ls1_center = outer_ls1.get_center()\n",
        "        outer_ls2_center = outer_ls2.get_center()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        arc_radius = 2.0\n",
        "\n",
        "        line1 = Line(inner_lake_center, inner_ls1_center, color = WHITE)\n",
        "        line2 = Line(inner_lake_center, inner_ls2_center, color = WHITE)\n",
        "\n",
        "\n",
        "        #arc_point1 = interpolate(inner_lake_center, inner_ls1_center, 0.2)\n",
        "        #arc_point2 = interpolate(inner_lake_center, inner_ls2_center, 0.2)\n",
        "        #inner_angle_arc = ArcBetweenPoints(arc_point1, arc_point2, angle = TAU/4)\n",
        "        inner_angle_arc = Arc(angle = TAU/4, start_angle = -TAU/8, radius = arc_radius,\n",
        "            stroke_color = ANGLE_COLOR1)\n",
        "        inner_angle_arc.move_arc_center_to(inner_lake_center)\n",
        "\n",
        "        inner_label = OldTex(\"\\\\theta\", fill_color = ANGLE_COLOR1).scale(3).next_to(inner_angle_arc, LEFT, buff = -0.1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line1),\n",
        "            ShowCreation(line2),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(inner_angle_arc),\n",
        "            FadeIn(inner_label)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "        line3 = Line(outer_lake_center, inner_ls1_center, color = WHITE)\n",
        "        line4 = Line(outer_lake_center, inner_ls2_center, color = WHITE)\n",
        "        outer_angle_arc = Arc(angle = TAU/8, start_angle = -3*TAU/16, radius = arc_radius,\n",
        "            stroke_color = ANGLE_COLOR2)\n",
        "        outer_angle_arc.move_arc_center_to(outer_lake_center)\n",
        "\n",
        "        outer_label = OldTex(\"{\\\\theta \\over 2}\", color = ANGLE_COLOR2).scale(2.5).move_to(outer_angle_arc)\n",
        "        outer_label.shift([-2,-1,0])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line3),\n",
        "            ShowCreation(line4),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(outer_angle_arc),\n",
        "            FadeIn(outer_label)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "        line5 = Line(outer_lake_center, outer_ls1_center, color = WHITE)\n",
        "        line6 = Line(outer_lake_center, outer_ls2_center, color = WHITE)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line5),\n",
        "            ShowCreation(line6)\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(line1),\n",
        "            FadeOut(line2),\n",
        "            FadeOut(line3),\n",
        "            FadeOut(line4),\n",
        "            FadeOut(line5),\n",
        "            FadeOut(line6),\n",
        "            FadeOut(inner_angle_arc),\n",
        "            FadeOut(outer_angle_arc),\n",
        "            FadeOut(inner_label),\n",
        "            FadeOut(outer_label),\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        inner_lines = VGroup()\n",
        "        inner_arcs = VGroup()\n",
        "\n",
        "        for i in range(-2,2):\n",
        "\n",
        "            theta = -TAU/4 + (i+0.5)*TAU/4\n",
        "            ls_point = inner_lake_center + inner_lake_radius * np.array([\n",
        "                np.cos(theta), np.sin(theta),0])\n",
        "            line = Line(inner_lake_center, ls_point, color = WHITE)\n",
        "            inner_lines.add(line)\n",
        "\n",
        "            arc = Arc(angle = TAU/4, start_angle = theta, radius = arc_radius,\n",
        "                stroke_color = ANGLE_COLOR1)\n",
        "            arc.move_arc_center_to(inner_lake_center)\n",
        "            inner_arcs.add(arc)\n",
        "\n",
        "            if i == 1:\n",
        "                arc.set_stroke(width = 0)\n",
        "\n",
        "        for line in inner_lines.submobjects:\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "            )\n",
        "        self.add_foreground_mobject(inner_lines)\n",
        "        for arc in inner_arcs.submobjects:\n",
        "            self.play(\n",
        "                ShowCreation(arc)\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        outer_lines = VGroup()\n",
        "        outer_arcs = VGroup()\n",
        "\n",
        "        for i in range(-2,2):\n",
        "\n",
        "            theta = -TAU/4 + (i+0.5)*TAU/4\n",
        "\n",
        "            ls_point = inner_lake_center + inner_lake_radius * np.array([\n",
        "                np.cos(theta), np.sin(theta),0])\n",
        "            line = Line(outer_lake_center, ls_point, color = WHITE)\n",
        "            outer_lines.add(line)\n",
        "\n",
        "            theta = -TAU/4 + (i+0.5)*TAU/8\n",
        "            arc = Arc(angle = TAU/8, start_angle = theta, radius = arc_radius,\n",
        "                stroke_color = ANGLE_COLOR2)\n",
        "            arc.move_arc_center_to(outer_lake_center)\n",
        "            outer_arcs.add(arc)\n",
        "\n",
        "            if i == 1:\n",
        "                arc.set_stroke(width = 0)\n",
        "\n",
        "        \n",
        "        for line in outer_lines.submobjects:\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "            )\n",
        "        self.add_foreground_mobject(outer_lines)\n",
        "        for arc in outer_arcs.submobjects:\n",
        "            self.play(\n",
        "                ShowCreation(arc)\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(inner_lines),\n",
        "            FadeOut(inner_arcs)\n",
        "        )\n",
        "\n",
        "\n",
        "        outer_lines2 = VGroup()\n",
        "\n",
        "        for i in range(-2,2):\n",
        "\n",
        "            theta = -TAU/4 + (i+0.5)*TAU/8\n",
        "            ls_point = outer_lake_center + outer_lake_radius * np.array([\n",
        "                np.cos(theta), np.sin(theta),0])\n",
        "            line = Line(outer_lake_center, ls_point, color = WHITE)\n",
        "            outer_lines2.add(line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(outer_lines2),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        outer_lines3 = outer_lines2.copy().rotate(TAU/2, about_point = outer_lake_center)\n",
        "        outer_arcs3 = outer_arcs.copy().rotate(TAU/2, about_point = outer_lake_center)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(outer_lines3),\n",
        "        )\n",
        "        self.add_foreground_mobject(outer_lines3)\n",
        "        for arc in outer_arcs3.submobjects:\n",
        "            self.play(\n",
        "                ShowCreation(arc)\n",
        "            )\n",
        "\n",
        "        last_arc = outer_arcs3.submobjects[0].copy()\n",
        "        last_arc.rotate(-TAU/8, about_point = outer_lake_center)\n",
        "        last_arc2 = last_arc.copy()\n",
        "        last_arc2.rotate(TAU/2, about_point = outer_lake_center)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(last_arc),\n",
        "            ShowCreation(last_arc2),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(outer_lines2),\n",
        "            FadeOut(outer_lines3),\n",
        "            FadeOut(outer_arcs),\n",
        "            FadeOut(outer_arcs3),\n",
        "            FadeOut(last_arc),\n",
        "            FadeOut(last_arc2),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(inner_ls),\n",
        "            FadeOut(outer_ls),\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PondScene(ThreeDScene):\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = np.array([0,BASELINE_YPOS,0])\n",
        "        LAKE0_RADIUS = 1.5\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.5\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        LIGHT_MAX_INT = 1\n",
        "        LIGHT_SCALE = 2.5\n",
        "        LIGHT_CUTOFF = 1\n",
        "\n",
        "        RIGHT_ANGLE_SIZE = 0.3\n",
        "\n",
        "        self.cumulated_zoom_factor = 1\n",
        "\n",
        "        STEP_RUN_TIME = 0.5\n",
        "\n",
        "\n",
        "        #self.force_skipping()\n",
        "\n",
        "\n",
        "        def right_angle(pointA, pointB, pointC, size = 1):\n",
        "\n",
        "            v1 = pointA - pointB\n",
        "            v1 = size * v1/get_norm(v1)\n",
        "            v2 = pointC - pointB\n",
        "            v2 = size * v2/get_norm(v2)\n",
        "            \n",
        "            P = pointB\n",
        "            Q = pointB + v1\n",
        "            R = Q + v2\n",
        "            S = R - v1\n",
        "            angle_sign = VMobject()\n",
        "            angle_sign.set_points_as_corners([P,Q,R,S,P])\n",
        "            angle_sign.mark_paths_closed = True\n",
        "            angle_sign.set_fill(color = WHITE, opacity = 1)\n",
        "            angle_sign.set_stroke(width = 0)\n",
        "            return angle_sign\n",
        "\n",
        "\n",
        "        def triangle(pointA, pointB, pointC):\n",
        "\n",
        "            mob = VMobject()\n",
        "            mob.set_points_as_corners([pointA, pointB, pointC, pointA])\n",
        "            mob.mark_paths_closed = True\n",
        "            mob.set_fill(color = WHITE, opacity = 0.5)\n",
        "            mob.set_stroke(width = 0)\n",
        "            return mob\n",
        "\n",
        "\n",
        "        def zoom_out_scene(factor):\n",
        "\n",
        "            self.remove_foreground_mobject(self.ls0_dot)\n",
        "            self.remove(self.ls0_dot)\n",
        "\n",
        "            phi0 = self.camera.get_phi() # default is 0 degs\n",
        "            theta0 = self.camera.get_theta() # default is -90 degs\n",
        "            distance0 = self.camera.get_distance()\n",
        "\n",
        "            distance1 = 2 * distance0\n",
        "            camera_target_point = self.camera.get_spherical_coords(phi0, theta0, distance1)\n",
        "\n",
        "            self.play(\n",
        "                ApplyMethod(self.camera.rotation_mobject.move_to, camera_target_point),\n",
        "                self.zoomable_mobs.shift, self.obs_dot.get_center(),\n",
        "                self.unzoomable_mobs.scale,2,{\"about_point\" : ORIGIN},\n",
        "            )\n",
        "\n",
        "            self.cumulated_zoom_factor *= factor\n",
        "\n",
        "            # place ls0_dot by hand\n",
        "            #old_radius = self.ls0_dot.radius\n",
        "            #self.ls0_dot.radius = 2 * old_radius\n",
        "\n",
        "            #v = self.ls0_dot.get_center() - self.obs_dot.get_center()\n",
        "            #self.ls0_dot.shift(v)\n",
        "            #self.ls0_dot.move_to(self.outer_lake.get_center())\n",
        "            self.ls0_dot.scale(2, about_point = ORIGIN)\n",
        "                \n",
        "            #self.add_foreground_mobject(self.ls0_dot)\n",
        "\n",
        "\n",
        "        def shift_scene(v):\n",
        "            self.play(\n",
        "                self.zoomable_mobs.shift,v,\n",
        "                self.unzoomable_mobs.shift,v\n",
        "            )\n",
        "\n",
        "\n",
        "        self.zoomable_mobs = VMobject()\n",
        "        self.unzoomable_mobs = VMobject()\n",
        "\n",
        "\n",
        "        baseline = VMobject()\n",
        "        baseline.set_points_as_corners([[-8,BASELINE_YPOS,0],[8,BASELINE_YPOS,0]])\n",
        "        baseline.set_stroke(width = 0) # in case it gets accidentally added to the scene\n",
        "        self.zoomable_mobs.add(baseline) # prob not necessary\n",
        "\n",
        "        self.obs_dot = Dot(OBSERVER_POINT, fill_color = DOT_COLOR)\n",
        "        self.ls0_dot = Dot(OBSERVER_POINT + 2 * LAKE0_RADIUS * UP, fill_color = WHITE)\n",
        "        self.unzoomable_mobs.add(self.obs_dot)#, self.ls0_dot)\n",
        "\n",
        "        # lake\n",
        "        lake0 = Circle(radius = LAKE0_RADIUS,\n",
        "            stroke_width = 0,\n",
        "            fill_color = LAKE_COLOR,\n",
        "            fill_opacity = LAKE_OPACITY\n",
        "        )\n",
        "        lake0.move_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "        self.zoomable_mobs.add(lake0)\n",
        "\n",
        "        # Morty and indicator\n",
        "        morty = Randolph(color = MAROON_D).scale(0.3)\n",
        "        morty.next_to(OBSERVER_POINT,DOWN)\n",
        "        indicator = LightIndicator(precision = 2,\n",
        "            radius = INDICATOR_RADIUS,\n",
        "            show_reading  = False,\n",
        "            color = LIGHT_COLOR\n",
        "        )\n",
        "        indicator.next_to(morty,LEFT)\n",
        "        self.unzoomable_mobs.add(morty, indicator)\n",
        "\n",
        "        # first lighthouse\n",
        "        original_op_func = inverse_quadratic(LIGHT_MAX_INT,LIGHT_SCALE,LIGHT_CUTOFF)\n",
        "        ls0 = LightSource(opacity_function = original_op_func, radius = 15.0, num_levels = 15)\n",
        "        ls0.lighthouse.set_height(LIGHTHOUSE_HEIGHT)\n",
        "        ls0.lighthouse.height = LIGHTHOUSE_HEIGHT\n",
        "        ls0.move_source_to(OBSERVER_POINT + LAKE0_RADIUS * 2 * UP)\n",
        "        self.zoomable_mobs.add(ls0, ls0.lighthouse, ls0.ambient_light)\n",
        "\n",
        "        self.add(lake0,morty,self.obs_dot,self.ls0_dot, ls0.lighthouse)\n",
        "        self.add_foreground_mobject(morty)\n",
        "        self.add_foreground_mobject(self.obs_dot)\n",
        "        self.add_foreground_mobject(self.ls0_dot)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # shore arcs\n",
        "        arc_left = Arc(-TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_left.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_left = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_left.next_to(arc_left,LEFT)\n",
        "        \n",
        "\n",
        "        arc_right = Arc(TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_right.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_right = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_right.next_to(arc_right,RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc_left),\n",
        "            Write(one_left),\n",
        "            ShowCreation(arc_right),\n",
        "            Write(one_right),\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ls0.ambient_light),\n",
        "            lake0.set_stroke,{\"color\": LAKE_STROKE_COLOR, \"width\" : LAKE_STROKE_WIDTH},\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(indicator))\n",
        "        self.add_foreground_mobject(indicator)\n",
        "\n",
        "        self.play(\n",
        "            indicator.set_intensity,0.5\n",
        "        )\n",
        "\n",
        "        diameter_start = interpolate(OBSERVER_POINT,ls0.get_source_point(),0.02)\n",
        "        diameter_stop = interpolate(OBSERVER_POINT,ls0.get_source_point(),0.98)\n",
        "\n",
        "        # diameter\n",
        "        diameter = DoubleArrow(diameter_start,\n",
        "            diameter_stop,\n",
        "            buff = 0,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        diameter_text = OldTex(\"d\").scale(TEX_SCALE)\n",
        "        diameter_text.next_to(diameter,RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(diameter),\n",
        "            Write(diameter_text),\n",
        "            #FadeOut(self.obs_dot),\n",
        "            FadeOut(self.ls0_dot)\n",
        "        )\n",
        "\n",
        "        indicator_reading = OldTex(\"{1\\over d^2}\").scale(TEX_SCALE)\n",
        "        indicator_reading.move_to(indicator)\n",
        "        self.unzoomable_mobs.add(indicator_reading)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(indicator_reading)\n",
        "        )\n",
        "        self.add_foreground_mobject(indicator_reading)\n",
        "\n",
        "        # replace d with its value\n",
        "        new_diameter_text = OldTex(\"{2\\over \\pi}\").scale(TEX_SCALE)\n",
        "        new_diameter_text.color = LAKE_COLOR\n",
        "        new_diameter_text.move_to(diameter_text)\n",
        "        self.play(\n",
        "            Transform(diameter_text,new_diameter_text)\n",
        "        )\n",
        "\n",
        "        # insert into indicator reading\n",
        "        new_reading = OldTex(\"{\\pi^2 \\over 4}\").scale(TEX_SCALE)\n",
        "        new_reading.move_to(indicator)\n",
        "\n",
        "        self.play(\n",
        "            Transform(indicator_reading,new_reading)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(one_left),\n",
        "            FadeOut(one_right),\n",
        "            FadeOut(diameter_text),\n",
        "            FadeOut(arc_left),\n",
        "            FadeOut(arc_right)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        def indicator_wiggle():\n",
        "            INDICATOR_WIGGLE_FACTOR = 1.3\n",
        "\n",
        "            self.play(\n",
        "                ScaleInPlace(indicator, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle),\n",
        "                ScaleInPlace(indicator_reading, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle)\n",
        "            )\n",
        "\n",
        "\n",
        "        def angle_for_index(i,step):\n",
        "            return -TAU/4 + TAU/2**step * (i + 0.5)\n",
        "\n",
        "\n",
        "        def position_for_index(i, step, scaled_down = False):\n",
        "\n",
        "            theta = angle_for_index(i,step)\n",
        "            radial_vector = np.array([np.cos(theta),np.sin(theta),0])\n",
        "            position = self.lake_center + self.lake_radius * radial_vector\n",
        "\n",
        "            if scaled_down:\n",
        "                return position.scale_about_point(self.obs_dot.get_center(),0.5)\n",
        "            else:\n",
        "                return position\n",
        "\n",
        "\n",
        "        def split_light_source(i, step, show_steps = True, animate = True, run_time = 1):\n",
        "\n",
        "            ls_new_loc1 = position_for_index(i,step + 1)\n",
        "            ls_new_loc2 = position_for_index(i + 2**step,step + 1)\n",
        "\n",
        "            hyp = VMobject()\n",
        "            hyp1 = Line(self.lake_center,ls_new_loc1)\n",
        "            hyp2 = Line(self.lake_center,ls_new_loc2)\n",
        "            hyp.add(hyp2,hyp1)\n",
        "            self.new_hypotenuses.append(hyp)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(hyp, run_time = run_time)\n",
        "                )\n",
        "\n",
        "            leg1 = Line(self.obs_dot.get_center(),ls_new_loc1)\n",
        "            leg2 = Line(self.obs_dot.get_center(),ls_new_loc2)\n",
        "            self.new_legs_1.append(leg1)\n",
        "            self.new_legs_2.append(leg2)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(leg1, run_time = run_time),\n",
        "                    ShowCreation(leg2, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            ls1 = self.light_sources_array[i]\n",
        "\n",
        "\n",
        "            ls2 = ls1.copy()\n",
        "            if animate == True:\n",
        "                self.add(ls2)\n",
        "\n",
        "            self.additional_light_sources.append(ls2)\n",
        "\n",
        "            # check if the light sources are on screen\n",
        "            ls_old_loc = np.array(ls1.get_source_point())\n",
        "            onscreen_old = np.all(np.abs(ls_old_loc[:2]) < 10 * 2**3)\n",
        "            onscreen_1 = np.all(np.abs(ls_new_loc1[:2]) < 10 * 2**3)\n",
        "            onscreen_2 = np.all(np.abs(ls_new_loc2[:2]) < 10 * 2**3)\n",
        "            show_animation = (onscreen_old or onscreen_1 or onscreen_2)\n",
        "\n",
        "            if show_animation or animate:\n",
        "                print(\"animating (\", i, \",\", step, \")\")\n",
        "                self.play(\n",
        "                    ApplyMethod(ls1.move_source_to,ls_new_loc1, run_time = run_time),\n",
        "                    ApplyMethod(ls2.move_source_to,ls_new_loc2, run_time = run_time),\n",
        "                )\n",
        "            else:\n",
        "                ls1.move_source_to(ls_new_loc1)\n",
        "                ls2.move_source_to(ls_new_loc1)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        def construction_step(n, show_steps = True, run_time = 1,\n",
        "            simultaneous_splitting = False):\n",
        "\n",
        "            # we assume that the scene contains:\n",
        "            # an inner lake, self.inner_lake\n",
        "            # an outer lake, self.outer_lake\n",
        "            # light sources, self.light_sources\n",
        "            # legs from the observer point to each light source\n",
        "            # self.legs\n",
        "            # altitudes from the observer point to the\n",
        "            # locations of the light sources in the previous step\n",
        "            # self.altitudes\n",
        "            # hypotenuses connecting antipodal light sources\n",
        "            # self.hypotenuses\n",
        "\n",
        "            # these are mobjects!\n",
        "\n",
        "\n",
        "            # first, fade out all of the hypotenuses and altitudes\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.zoomable_mobs.remove(self.hypotenuses, self.altitudes, self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.hypotenuses),\n",
        "                    FadeOut(self.altitudes),\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "            else:\n",
        "                self.zoomable_mobs.remove(self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "\n",
        "            # create a new, outer lake\n",
        "            self.lake_center = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "\n",
        "            new_outer_lake = Circle(radius = self.lake_radius,\n",
        "                stroke_width = LAKE_STROKE_WIDTH,\n",
        "                fill_color = LAKE_COLOR,\n",
        "                fill_opacity = LAKE_OPACITY,\n",
        "                stroke_color = LAKE_STROKE_COLOR\n",
        "            )\n",
        "            new_outer_lake.move_to(self.lake_center)\n",
        "\n",
        "            if show_steps == True: \n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                    FadeIn(self.ls0_dot)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            self.inner_lake = self.outer_lake\n",
        "            self.outer_lake = new_outer_lake\n",
        "            self.altitudes = self.legs\n",
        "            #self.lake_center = self.outer_lake.get_center()\n",
        "\n",
        "            self.additional_light_sources = []\n",
        "            self.new_legs_1 = []\n",
        "            self.new_legs_2 = []\n",
        "            self.new_hypotenuses = []\n",
        "\n",
        "            # WE ALWAYS USE THIS CASE BRANCH\n",
        "            if simultaneous_splitting == False:\n",
        "\n",
        "                for i in range(2**n):\n",
        "                    \n",
        "                    split_light_source(i,\n",
        "                        step = n,\n",
        "                        show_steps = show_steps,\n",
        "                        run_time = run_time\n",
        "                    )\n",
        "\n",
        "                    if n == 1 and i == 0:\n",
        "                        # show again where the right angles are\n",
        "                        A = self.light_sources[0].get_center()\n",
        "                        B = self.additional_light_sources[0].get_center()\n",
        "                        C = self.obs_dot.get_center()\n",
        "\n",
        "                        triangle1 = triangle(\n",
        "                            A, C, B\n",
        "                        )\n",
        "                        right_angle1 = right_angle(\n",
        "                            A, C, B, size = 2 * RIGHT_ANGLE_SIZE\n",
        "                        )\n",
        "\n",
        "                        self.play(\n",
        "                            FadeIn(triangle1),\n",
        "                            FadeIn(right_angle1)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        self.play(\n",
        "                            FadeOut(triangle1),\n",
        "                            FadeOut(right_angle1)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        H = self.inner_lake.get_center() + self.lake_radius/2 * RIGHT\n",
        "                        L = self.outer_lake.get_center()\n",
        "                        triangle2 = triangle(\n",
        "                            L, H, C\n",
        "                        )\n",
        "\n",
        "                        right_angle2 = right_angle(\n",
        "                            L, H, C, size = 2 * RIGHT_ANGLE_SIZE\n",
        "                        )\n",
        "\n",
        "                        self.play(\n",
        "                            FadeIn(triangle2),\n",
        "                            FadeIn(right_angle2)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        self.play(\n",
        "                            FadeOut(triangle2),\n",
        "                            FadeOut(right_angle2)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "            # WE DON'T USE THIS CASE BRANCH ANYMORE\n",
        "            else: # simultaneous splitting\n",
        "\n",
        "                old_lake = self.outer_lake.copy()\n",
        "                old_ls = self.light_sources.copy()\n",
        "                old_ls2 = old_ls.copy()\n",
        "                for submob in old_ls2.submobjects:\n",
        "                    old_ls.add(submob)\n",
        "\n",
        "                self.remove(self.outer_lake, self.light_sources)\n",
        "                self.add(old_lake, old_ls)\n",
        "\n",
        "                for i in range(2**n):\n",
        "                    split_light_source(i,\n",
        "                        step = n,\n",
        "                        show_steps = show_steps,\n",
        "                        run_time = run_time,\n",
        "                        animate = False\n",
        "                    )\n",
        "\n",
        "                self.play(\n",
        "                    ReplacementTransform(old_ls, self.light_sources, run_time = run_time),\n",
        "                    ReplacementTransform(old_lake, self.outer_lake, run_time = run_time),\n",
        "                )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "            # collect the newly created mobs (in arrays)\n",
        "            # into the appropriate Mobject containers\n",
        "\n",
        "            self.legs = VMobject()\n",
        "            for leg in self.new_legs_1:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "            for leg in self.new_legs_2:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "\n",
        "            for hyp in self.hypotenuses.submobjects:\n",
        "                self.zoomable_mobs.remove(hyp)\n",
        "\n",
        "            self.hypotenuses = VMobject()\n",
        "            for hyp in self.new_hypotenuses:\n",
        "                self.hypotenuses.add(hyp)\n",
        "                self.zoomable_mobs.add(hyp)\n",
        "\n",
        "            for ls in self.additional_light_sources:\n",
        "                self.light_sources.add(ls)\n",
        "                self.light_sources_array.append(ls)\n",
        "                self.zoomable_mobs.add(ls)\n",
        "\n",
        "            # update scene\n",
        "            self.add(\n",
        "                self.light_sources,\n",
        "                self.inner_lake,\n",
        "                self.outer_lake,\n",
        "            )\n",
        "            self.zoomable_mobs.add(self.light_sources, self.inner_lake, self.outer_lake)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.add(\n",
        "                    self.legs,\n",
        "                    self.hypotenuses,\n",
        "                    self.altitudes,\n",
        "                )\n",
        "                self.zoomable_mobs.add(self.legs, self.hypotenuses, self.altitudes)\n",
        "\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "            #self.lake_center = ls0_loc = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "            self.lake_radius *= 2\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.lake_center = ls0_loc = ls0.get_source_point()\n",
        "\n",
        "        self.inner_lake = VMobject()\n",
        "        self.outer_lake = lake0\n",
        "        self.legs = VMobject()\n",
        "        self.legs.add(Line(OBSERVER_POINT,self.lake_center))\n",
        "        self.altitudes = VMobject()\n",
        "        self.hypotenuses = VMobject()\n",
        "        self.light_sources_array = [ls0]\n",
        "        self.light_sources = VMobject()\n",
        "        self.light_sources.add(ls0)\n",
        "\n",
        "        self.lake_radius = 2 * LAKE0_RADIUS # don't ask...\n",
        "\n",
        "        self.zoomable_mobs.add(self.inner_lake, self.outer_lake, self.altitudes, self.light_sources)\n",
        "\n",
        "        self.add(self.inner_lake,\n",
        "            self.outer_lake,\n",
        "            self.legs,\n",
        "            self.altitudes,\n",
        "            self.hypotenuses\n",
        "        )\n",
        "\n",
        "        self.play(FadeOut(diameter))\n",
        "        \n",
        "        self.additional_light_sources = []\n",
        "        self.new_legs_1 = []\n",
        "        self.new_legs_2 = []\n",
        "        self.new_hypotenuses = []\n",
        "\n",
        "\n",
        "        construction_step(0, run_time = STEP_RUN_TIME)\n",
        "\n",
        "        my_triangle = triangle(\n",
        "            self.light_sources[0].get_source_point(),\n",
        "            OBSERVER_POINT,\n",
        "            self.light_sources[1].get_source_point()\n",
        "        )\n",
        "\n",
        "        angle_sign1 = right_angle(\n",
        "            self.light_sources[0].get_source_point(),\n",
        "            OBSERVER_POINT,\n",
        "            self.light_sources[1].get_source_point(),\n",
        "            size = RIGHT_ANGLE_SIZE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(angle_sign1),\n",
        "            FadeIn(my_triangle)\n",
        "        )\n",
        "\n",
        "        angle_sign2 = right_angle(\n",
        "            self.light_sources[1].get_source_point(),\n",
        "            self.lake_center,\n",
        "            OBSERVER_POINT,\n",
        "            size = RIGHT_ANGLE_SIZE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(angle_sign2)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(angle_sign1),\n",
        "            FadeOut(angle_sign2),\n",
        "            FadeOut(my_triangle)\n",
        "        )\n",
        "\n",
        "        indicator_wiggle()\n",
        "        self.remove(self.ls0_dot)\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "        \n",
        "        construction_step(1, run_time = STEP_RUN_TIME)\n",
        "        indicator_wiggle()\n",
        "        #self.play(FadeOut(self.ls0_dot))\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "\n",
        "        construction_step(2, run_time = STEP_RUN_TIME)\n",
        "        indicator_wiggle()\n",
        "        self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.altitudes),\n",
        "            FadeOut(self.hypotenuses),\n",
        "            FadeOut(self.legs)\n",
        "        )\n",
        "\n",
        "        max_it = 10\n",
        "        scale = 2**(max_it - 5)\n",
        "        TEX_SCALE *= scale\n",
        "\n",
        "\n",
        "\n",
        "        # for i in range(3,max_it + 1):\n",
        "        #     construction_step(i, show_steps = False, run_time = 4.0/2**i,\n",
        "        #         simultaneous_splitting = True)\n",
        "\n",
        "\n",
        "        #print \"starting simultaneous expansion\"\n",
        "\n",
        "        # simultaneous expansion of light sources from now on\n",
        "        self.play(FadeOut(self.inner_lake))\n",
        "\n",
        "        for n in range(3,max_it + 1):\n",
        "            print(\"working on n = \", n, \"...\")\n",
        "            new_lake = self.outer_lake.copy().scale(2,about_point = self.obs_dot.get_center())\n",
        "            for (i,ls) in enumerate(self.light_sources_array[:2**n]):\n",
        "                #print i\n",
        "                lsp = ls.copy()\n",
        "                self.light_sources.add(lsp)\n",
        "                self.add(lsp)\n",
        "                self.light_sources_array.append(lsp)\n",
        "\n",
        "            new_lake_center = new_lake.get_center()\n",
        "            new_lake_radius = 0.5 * new_lake.get_width()\n",
        "\n",
        "            self.play(Transform(self.outer_lake,new_lake))\n",
        "            shift_list = []\n",
        "\n",
        "            for i in range(2**n):\n",
        "                #print \"===========\"\n",
        "                #print i\n",
        "                theta = -TAU/4 + (i + 0.5) * TAU / 2**(n+1)\n",
        "                v = np.array([np.cos(theta), np.sin(theta),0])\n",
        "                pos1 = new_lake_center + new_lake_radius * v\n",
        "                pos2 = new_lake_center - new_lake_radius * v\n",
        "                ls1 = self.light_sources.submobjects[i]\n",
        "                ls2 = self.light_sources.submobjects[i+2**n]\n",
        "\n",
        "                ls_old_loc = np.array(ls1.get_source_point())\n",
        "                onscreen_old = np.all(np.abs(ls_old_loc[:2]) < 10 * 2**2)\n",
        "                onscreen_1 = np.all(np.abs(pos1[:2]) < 10 * 2**2)\n",
        "                onscreen_2 = np.all(np.abs(pos2[:2]) < 10 * 2**2)\n",
        "                \n",
        "                if onscreen_old or onscreen_1:\n",
        "                    print(\"anim1 for step\", n, \"part\", i)\n",
        "                    print(\"------------------ moving from\", ls_old_loc[:2], \"to\", pos1[:2])\n",
        "                    shift_list.append(ApplyMethod(ls1.move_source_to, pos1, run_time = STEP_RUN_TIME))\n",
        "                else:\n",
        "                    ls1.move_source_to(pos1)\n",
        "                if onscreen_old or onscreen_2:\n",
        "                    print(\"anim2 for step\", n, \"part\", i)\n",
        "                    print(\"------------------ moving from\", ls_old_loc[:2], \"to\", pos2[:2])\n",
        "                    shift_list.append(ApplyMethod(ls2.move_source_to, pos2, run_time = STEP_RUN_TIME))\n",
        "                else:\n",
        "                    ls2.move_source_to(pos2)\n",
        "                \n",
        "\n",
        "                #print shift_list\n",
        "\n",
        "            self.play(*shift_list)\n",
        "            print(\"...done\")\n",
        "\n",
        "\n",
        "        #self.revert_to_original_skipping_status()\n",
        "\n",
        "        # Now create a straight number line and transform into it\n",
        "        MAX_N = 7\n",
        "\n",
        "        origin_point = self.obs_dot.get_center()\n",
        "\n",
        "        self.number_line = NumberLine(\n",
        "            x_min = -MAX_N,\n",
        "            x_max = MAX_N + 1,\n",
        "            color = WHITE,\n",
        "            number_at_center = 0,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            big_tick_numbers = [],\n",
        "            numbers_to_show = list(range(-MAX_N,MAX_N + 1)),#,2),\n",
        "            unit_size = LAKE0_RADIUS * TAU/4 / 2 * scale,\n",
        "            tick_frequency = 1,\n",
        "            tick_size = LAKE_STROKE_WIDTH,\n",
        "            number_scale_val = 3,\n",
        "            line_to_number_buff = LARGE_BUFF,\n",
        "            label_direction = UP,\n",
        "        ).shift(origin_point - self.number_line.number_to_point(0)) # .shift(scale * 2.5 * DOWN)\n",
        "\n",
        "        print(\"scale \", scale)\n",
        "        print(\"number line at\", self.number_line.get_center())\n",
        "        print(\"should be at\", origin_point, \"or\", OBSERVER_POINT)\n",
        "\n",
        "        self.number_line.tick_marks.fade(1)\n",
        "        self.number_line_labels = self.number_line.get_number_mobjects()\n",
        "        self.wait()\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "        nl_sources = VMobject()\n",
        "        pond_sources = VMobject()\n",
        "\n",
        "        for i in range(-MAX_N,MAX_N+1):\n",
        "            anchor = self.number_line.number_to_point(2*i + 1)\n",
        "            ls = self.light_sources_array[i].copy()\n",
        "            ls.move_source_to(anchor)\n",
        "            nl_sources.add(ls)\n",
        "            pond_sources.add(self.light_sources_array[i].copy())\n",
        "\n",
        "        self.add(pond_sources)\n",
        "        self.remove(self.light_sources)\n",
        "        for ls in self.light_sources_array:\n",
        "            self.remove(ls)\n",
        "\n",
        "        self.outer_lake.rotate(TAU/8)\n",
        "\n",
        "        # open sea\n",
        "        open_sea = Rectangle(\n",
        "            width = 200 * scale,\n",
        "            height = 100 * scale,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            fill_color = LAKE_COLOR,\n",
        "            fill_opacity = LAKE_OPACITY,\n",
        "        ).flip().next_to(self.obs_dot.get_center(),UP,buff = 0)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(pond_sources,nl_sources),\n",
        "            #FadeOut(pond_sources),\n",
        "            #FadeIn(nl_sources),\n",
        "            ReplacementTransform(self.outer_lake,open_sea),\n",
        "            #FadeOut(self.inner_lake)\n",
        "        )\n",
        "        self.play(FadeIn(self.number_line))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        v = 4 * scale * UP\n",
        "        self.play(\n",
        "            nl_sources.shift,v,\n",
        "            morty.shift,v,\n",
        "            self.number_line.shift,v,\n",
        "            indicator.shift,v,\n",
        "            indicator_reading.shift,v,\n",
        "            open_sea.shift,v,\n",
        "            self.obs_dot.shift,v,\n",
        "        )\n",
        "        self.number_line_labels.shift(v)\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "        #self.remove(self.obs_dot)\n",
        "        self.play(\n",
        "            indicator.move_to, origin_point + scale * UP + 2 * UP,\n",
        "            indicator_reading.move_to, origin_point + scale * UP + 2 * UP,\n",
        "            FadeOut(open_sea),\n",
        "            FadeOut(morty),\n",
        "            FadeIn(self.number_line_labels),\n",
        "            FadeIn(self.number_line.tick_marks),\n",
        "        )\n",
        "\n",
        "        two_sided_sum = OldTex(\"\\dots\", \"+\", \"{1\\over (-11)^2}\",\\\n",
        "         \"+\", \"{1\\over (-9)^2}\", \" + \", \"{1\\over (-7)^2}\", \" + \", \"{1\\over (-5)^2}\", \" + \", \\\n",
        "         \"{1\\over (-3)^2}\", \" + \", \"{1\\over (-1)^2}\", \" + \", \"{1\\over 1^2}\", \" + \", \\\n",
        "         \"{1\\over 3^2}\", \" + \", \"{1\\over 5^2}\", \" + \", \"{1\\over 7^2}\", \" + \", \\\n",
        "         \"{1\\over 9^2}\", \" + \", \"{1\\over 11^2}\", \" + \", \"\\dots\")\n",
        "\n",
        "        nb_symbols = len(two_sided_sum.submobjects)\n",
        "\n",
        "        two_sided_sum.scale(TEX_SCALE)\n",
        "        \n",
        "        for (i,submob) in zip(list(range(nb_symbols)),two_sided_sum.submobjects):\n",
        "            submob.next_to(self.number_line.number_to_point(i - 13),DOWN, buff = 2*scale)\n",
        "            if (i == 0 or i % 2 == 1 or i == nb_symbols - 1): # non-fractions\n",
        "                submob.shift(0.3 * scale * DOWN)\n",
        "\n",
        "        self.play(Write(two_sided_sum))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for ls in nl_sources.submobjects:\n",
        "            if ls.get_source_point()[0] < 0:\n",
        "                self.remove_foreground_mobject(ls.ambient_light)\n",
        "                self.remove(ls.ambient_light)\n",
        "            else:\n",
        "                self.add_foreground_mobject(ls.ambient_light)\n",
        "\n",
        "        for label in self.number_line_labels.submobjects:\n",
        "            if label.get_center()[0] <= 0:\n",
        "                self.remove(label)\n",
        "\n",
        "\n",
        "\n",
        "        covering_rectangle = Rectangle(\n",
        "            width = FRAME_X_RADIUS * scale,\n",
        "            height = 2 * FRAME_Y_RADIUS * scale,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        covering_rectangle.next_to(ORIGIN, LEFT, buff = 0)\n",
        "        #for i in range(10):\n",
        "        #    self.add_foreground_mobject(nl_sources.submobjects[i])\n",
        "\n",
        "        self.add_foreground_mobject(indicator)\n",
        "        self.add_foreground_mobject(indicator_reading)\n",
        "\n",
        "\n",
        "        half_indicator_reading = OldTex(\"{\\pi^2 \\over 8}\").scale(TEX_SCALE)\n",
        "        half_indicator_reading.move_to(indicator)\n",
        "\n",
        "        central_plus_sign = two_sided_sum[13]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(covering_rectangle),\n",
        "            Transform(indicator_reading, half_indicator_reading),\n",
        "            FadeOut(central_plus_sign)\n",
        "        )\n",
        "\n",
        "\n",
        "        equals_sign = OldTex(\"=\").scale(TEX_SCALE)\n",
        "        equals_sign.move_to(central_plus_sign)\n",
        "        p = 2 * scale * LEFT + central_plus_sign.get_center()[1] * UP\n",
        "\n",
        "        self.play(\n",
        "            indicator.move_to,p,\n",
        "            indicator_reading.move_to,p,\n",
        "            FadeIn(equals_sign),\n",
        "        )\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        # show Randy admiring the result\n",
        "        randy = Randolph(color = MAROON_D).scale(scale).move_to(2*scale*DOWN+5*scale*LEFT)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change,\"happy\")\n",
        "        self.play(randy.change,\"hooray\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class WaitScene(TeacherStudentsScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "\n",
        "        self.teacher_says(OldTex(\"{1\\over 1^2}+{1\\over 3^2}+{1\\over 5^2}+{1\\over 7^2}+\\dots = {\\pi^2 \\over 8}!\"))\n",
        "\n",
        "        student_q = OldTexText(\"What about\")\n",
        "        full_sum = OldTex(\"{1\\over 1^2}+{1\\over 2^2}+{1\\over 3^2}+{1\\over 4^2}+\\dots?\")\n",
        "        full_sum.next_to(student_q,RIGHT)\n",
        "        student_q.add(full_sum)\n",
        "\n",
        "\n",
        "        self.student_says(student_q, target_mode = \"angry\")\n",
        "\n",
        "\n",
        "class FinalSumManipulationScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "\n",
        "        LIGHT_COLOR2 = RED\n",
        "        LIGHT_COLOR3 = BLUE\n",
        "\n",
        "        unit_length = 1.5\n",
        "        vertical_spacing = 2.5 * DOWN\n",
        "        switch_on_time = 0.2\n",
        "\n",
        "        sum_vertical_spacing = 1.5\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy.set_color(MAROON_D)\n",
        "        randy.color = MAROON_D\n",
        "        randy.scale(0.7).flip().to_edge(DOWN + LEFT)\n",
        "        self.wait()\n",
        "\n",
        "        ls_template = LightSource(\n",
        "            radius = 1,\n",
        "            num_levels = 10,\n",
        "            max_opacity_ambient = 0.5,\n",
        "            opacity_function = inverse_quadratic(1,0.75,1)\n",
        "        )\n",
        "\n",
        "\n",
        "        odd_range = np.arange(1,9,2)\n",
        "        even_range = np.arange(2,16,2)\n",
        "        full_range = np.arange(1,8,1)\n",
        "\n",
        "        self.number_line1 = NumberLine(\n",
        "            x_min = 0,\n",
        "            x_max = 11,\n",
        "            color = LAKE_STROKE_COLOR,\n",
        "            number_at_center = 0,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            #numbers_to_show = full_range,\n",
        "            number_scale_val = 0.5,\n",
        "            big_tick_numbers = [],\n",
        "            unit_size = unit_length,\n",
        "            tick_frequency = 1,\n",
        "            line_to_number_buff = MED_SMALL_BUFF,\n",
        "            include_tip = True,\n",
        "            label_direction = UP,\n",
        "        )\n",
        "\n",
        "        self.number_line1.next_to(2.5 * UP + 3 * LEFT, RIGHT, buff = 0.3)\n",
        "        self.number_line1.add_numbers()\n",
        "\n",
        "        odd_lights = VMobject()\n",
        "        for i in odd_range:\n",
        "            pos = self.number_line1.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.move_source_to(pos)\n",
        "            odd_lights.add(ls)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.number_line1, run_time = 5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        odd_terms = VMobject()\n",
        "        for i in odd_range:\n",
        "            if i == 1:\n",
        "                term = OldTex(\"\\phantom{+\\,\\,\\,}{1\\over \" + str(i) + \"^2}\",\n",
        "                    fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "            else:\n",
        "                term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\",\n",
        "                    fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "\n",
        "            term.next_to(self.number_line1.number_to_point(i), DOWN, buff = 1.5)\n",
        "            odd_terms.add(term)\n",
        "\n",
        "\n",
        "        for (ls, term) in zip(odd_lights.submobjects, odd_terms.submobjects):\n",
        "            self.play(\n",
        "                FadeIn(ls.lighthouse, run_time = switch_on_time),\n",
        "                SwitchOn(ls.ambient_light, run_time = switch_on_time),\n",
        "                Write(term, run_time = switch_on_time)\n",
        "            )\n",
        "\n",
        "        result1 = OldTex(\"{\\pi^2\\over 8} =\", fill_color = LIGHT_COLOR,\n",
        "            stroke_color = LIGHT_COLOR)\n",
        "        result1.next_to(self.number_line1, LEFT, buff = 0.5)\n",
        "        result1.shift(0.87 * vertical_spacing)\n",
        "        self.play(Write(result1))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.number_line2 = self.number_line1.copy()\n",
        "        self.number_line2.numbers_to_show = full_range\n",
        "        self.number_line2.shift(2 * vertical_spacing)\n",
        "        self.number_line2.add_numbers()\n",
        "\n",
        "        full_lights = VMobject()\n",
        "\n",
        "        for i in full_range:\n",
        "            pos = self.number_line2.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.color = LIGHT_COLOR3\n",
        "            ls.move_source_to(pos)\n",
        "            full_lights.add(ls)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.number_line2, run_time = 5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        full_lighthouses = VMobject()\n",
        "        full_ambient_lights = VMobject()\n",
        "        for ls in full_lights:\n",
        "            full_lighthouses.add(ls.lighthouse)\n",
        "            full_ambient_lights.add(ls.ambient_light)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, full_lighthouses, lag_ratio = 0.2, run_time = 3),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(SwitchOn, full_ambient_lights, lag_ratio = 0.2, run_time = 3)\n",
        "        )\n",
        "\n",
        "        # for ls in full_lights.submobjects:\n",
        "        #     self.play(\n",
        "        #         FadeIn(ls.lighthouse, run_time = 0.1),#5 * switch_on_time),\n",
        "        #         SwitchOn(ls.ambient_light, run_time = 0.1)#5 * switch_on_time),\n",
        "        #     )\n",
        "\n",
        "\n",
        "\n",
        "        even_terms = VMobject()\n",
        "        for i in even_range:\n",
        "            term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR2, stroke_color = LIGHT_COLOR)\n",
        "            term.next_to(self.number_line1.number_to_point(i), DOWN, buff = sum_vertical_spacing)\n",
        "            even_terms.add(term)\n",
        "\n",
        "\n",
        "        even_lights = VMobject()\n",
        "\n",
        "        for i in even_range:\n",
        "            pos = self.number_line1.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.color = LIGHT_COLOR2\n",
        "            ls.move_source_to(pos)\n",
        "            even_lights.add(ls)\n",
        "\n",
        "        for (ls, term) in zip(even_lights.submobjects, even_terms.submobjects):\n",
        "            self.play(\n",
        "                SwitchOn(ls.ambient_light, run_time = switch_on_time),\n",
        "                Write(term)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "        # now morph the even lights into the full lights\n",
        "        full_lights_copy = full_lights.copy()\n",
        "        even_lights_copy = even_lights.copy()\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Transform(even_lights,full_lights, run_time = 2)\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for i in range(6):\n",
        "            self.play(\n",
        "                Transform(even_lights[i], even_lights_copy[i])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # draw arrows\n",
        "        P1 = self.number_line2.number_to_point(1)\n",
        "        P2 = even_terms.submobjects[0].get_center()\n",
        "        Q1 = interpolate(P1, P2, 0.2)\n",
        "        Q2 = interpolate(P1, P2, 0.8)\n",
        "        quarter_arrow = Arrow(Q1, Q2,\n",
        "            color = LIGHT_COLOR2)\n",
        "        quarter_label = OldTex(\"\\\\times {1\\over 4}\", fill_color = LIGHT_COLOR2, stroke_color = LIGHT_COLOR2)\n",
        "        quarter_label.scale(0.7)\n",
        "        quarter_label.next_to(quarter_arrow.get_center(), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(quarter_arrow),\n",
        "            Write(quarter_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        P3 = odd_terms.submobjects[0].get_center()\n",
        "        R1 = interpolate(P1, P3, 0.2)\n",
        "        R2 = interpolate(P1, P3, 0.8)\n",
        "        three_quarters_arrow = Arrow(R1, R2,\n",
        "            color = LIGHT_COLOR)\n",
        "        three_quarters_label = OldTex(\"\\\\times {3\\over 4}\", fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "        three_quarters_label.scale(0.7)\n",
        "        three_quarters_label.next_to(three_quarters_arrow.get_center(), LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(three_quarters_arrow),\n",
        "            Write(three_quarters_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        four_thirds_arrow = Arrow(R2, R1, color = LIGHT_COLOR)\n",
        "        four_thirds_label = OldTex(\"\\\\times {4\\over 3}\", fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "        four_thirds_label.scale(0.7)\n",
        "        four_thirds_label.next_to(four_thirds_arrow.get_center(), LEFT)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(quarter_label),\n",
        "            FadeOut(quarter_arrow),\n",
        "            FadeOut(even_lights),\n",
        "            FadeOut(even_terms)\n",
        "\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(three_quarters_arrow, four_thirds_arrow),\n",
        "            ReplacementTransform(three_quarters_label, four_thirds_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        full_terms = VMobject()\n",
        "        for i in range(1,8): #full_range:\n",
        "            if i == 1:\n",
        "                term = OldTex(\"\\phantom{+\\,\\,\\,}{1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "            elif i == 7:\n",
        "                term = OldTex(\"+\\,\\,\\,\\dots\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "            else:\n",
        "                term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "\n",
        "            term.move_to(self.number_line2.number_to_point(i))\n",
        "            full_terms.add(term)\n",
        "\n",
        "        #return\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.number_line1),\n",
        "            FadeOut(odd_lights),\n",
        "            FadeOut(self.number_line2),\n",
        "            FadeOut(full_lights),\n",
        "            FadeIn(full_terms)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        v = (sum_vertical_spacing + 0.5) * UP\n",
        "        self.play(\n",
        "            odd_terms.shift, v,\n",
        "            result1.shift, v,\n",
        "            four_thirds_arrow.shift, v,\n",
        "            four_thirds_label.shift, v,\n",
        "            odd_terms.shift, v,\n",
        "            full_terms.shift, v\n",
        "        )\n",
        "\n",
        "        arrow_copy = four_thirds_arrow.copy()\n",
        "        label_copy = four_thirds_label.copy()\n",
        "        arrow_copy.shift(2.5 * LEFT)\n",
        "        label_copy.shift(2.5 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(arrow_copy),\n",
        "            FadeIn(label_copy)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        final_result = OldTex(\"{\\pi^2 \\over 6}=\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "        final_result.next_to(arrow_copy, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(final_result),\n",
        "            randy.change_mode,\"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        equation = VMobject()\n",
        "        equation.add(final_result)\n",
        "        equation.add(full_terms)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(result1),\n",
        "            FadeOut(odd_terms),\n",
        "            FadeOut(arrow_copy),\n",
        "            FadeOut(label_copy),\n",
        "            FadeOut(four_thirds_arrow),\n",
        "            FadeOut(four_thirds_label),\n",
        "            full_terms.shift,LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(equation.shift, -equation.get_center()[1] * UP + UP + 1.5 * LEFT)\n",
        "\n",
        "        result_box = Rectangle(width = 1.1 * equation.get_width(),\n",
        "            height = 2 * equation.get_height(), color = LIGHT_COLOR3)\n",
        "        result_box.move_to(equation)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(result_box)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class LabeledArc(Arc):\n",
        "    CONFIG = {\n",
        "        \"length\" : 1\n",
        "    }\n",
        "\n",
        "    def __init__(self, angle, **kwargs):\n",
        "\n",
        "        BUFFER = 1.3\n",
        "\n",
        "        Arc.__init__(self,angle,**kwargs)\n",
        "\n",
        "        label = DecimalNumber(self.length, num_decimal_places = 0)\n",
        "        r = BUFFER * self.radius\n",
        "        theta = self.start_angle + self.angle/2\n",
        "        label_pos = r * np.array([np.cos(theta), np.sin(theta), 0])\n",
        "\n",
        "        label.move_to(label_pos)\n",
        "        self.add(label)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ArcHighlightOverlayScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = [0,BASELINE_YPOS,0]\n",
        "        LAKE0_RADIUS = 1.5\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.2\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        FLASH_TIME = 0.25\n",
        "\n",
        "        def flash_arcs(n):\n",
        "\n",
        "            angle = TAU/2**n\n",
        "            arcs = []\n",
        "            arcs.append(LabeledArc(angle/2, start_angle = -TAU/4, radius = LAKE0_RADIUS, length = 1))\n",
        "\n",
        "            for i in range(1,2**n):\n",
        "                arcs.append(LabeledArc(angle, start_angle = -TAU/4 + (i-0.5)*angle, radius = LAKE0_RADIUS, length = 2))\n",
        "        \n",
        "            arcs.append(LabeledArc(angle/2, start_angle = -TAU/4 - angle/2, radius = LAKE0_RADIUS, length = 1))\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(arcs[0], run_time = FLASH_TIME)\n",
        "            )\n",
        "\n",
        "            for i in range(1,2**n + 1):\n",
        "                self.play(\n",
        "                    FadeOut(arcs[i-1], run_time = FLASH_TIME),\n",
        "                    FadeIn(arcs[i], run_time = FLASH_TIME)\n",
        "                )\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(arcs[2**n], run_time = FLASH_TIME),\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "class ThumbnailScene(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        equation = OldTex(\"1+{1\\over 4}+{1\\over 9}+{1\\over 16}+{1\\over 25}+\\dots\")\n",
        "        equation.scale(1.5)\n",
        "        equation.move_to(1.5 * UP)\n",
        "        q_mark = OldTex(\"=?\", color = LIGHT_COLOR).scale(5)\n",
        "        q_mark.next_to(equation, DOWN, buff = 1.5)\n",
        "        #equation.move_to(2 * UP)\n",
        "        #q_mark = OldTex(\"={\\pi^2\\over 6}\", color = LIGHT_COLOR).scale(3)\n",
        "        #q_mark.next_to(equation, DOWN, buff = 1)\n",
        "\n",
        "        lake_radius = 6\n",
        "        lake_center = ORIGIN\n",
        "        op_scale = 0.4\n",
        "\n",
        "        lake = Circle(\n",
        "            fill_color = LAKE_COLOR, \n",
        "            fill_opacity = LAKE_OPACITY, \n",
        "            radius = lake_radius,\n",
        "            stroke_color = LAKE_STROKE_COLOR, \n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "        )\n",
        "        lake.move_to(lake_center)\n",
        "\n",
        "        for i in range(16):\n",
        "            theta = -TAU/4 + (i + 0.5) * TAU/16\n",
        "            pos = lake_center + lake_radius * np.array([np.cos(theta), np.sin(theta), 0])\n",
        "            ls = LightSource(\n",
        "                radius = 15.0, \n",
        "                num_levels = 150,\n",
        "                max_opacity_ambient = 1.0,\n",
        "                opacity_function = inverse_quadratic(1,op_scale,1)\n",
        "            )\n",
        "            ls.move_source_to(pos)\n",
        "            lake.add(ls.ambient_light, ls.lighthouse)\n",
        "\n",
        "        self.add(lake)\n",
        "\n",
        "        self.add(equation, q_mark)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class InfiniteCircleScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        morty.set_color(MAROON_D).flip()\n",
        "        morty.color = MAROON_D\n",
        "        morty.scale(0.5).move_to(ORIGIN)\n",
        "\n",
        "        arrow = Arrow(ORIGIN, 2.4 * RIGHT)\n",
        "        dot = Dot(color = BLUE).next_to(arrow)\n",
        "        ellipsis = OldTex(\"\\dots\")\n",
        "\n",
        "        infsum = VGroup()\n",
        "        infsum.add(ellipsis.copy())\n",
        "\n",
        "        for i in range(3):\n",
        "            infsum.add(arrow.copy().next_to(infsum.submobjects[-1]))\n",
        "            infsum.add(dot.copy().next_to(infsum.submobjects[-1]))\n",
        "\n",
        "        infsum.add(arrow.copy().next_to(infsum.submobjects[-1]))\n",
        "        infsum.add(ellipsis.copy().next_to(infsum.submobjects[-1]))\n",
        "\n",
        "        infsum.next_to(morty,DOWN, buff = 1)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn,infsum,lag_ratio = 0.2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        A = infsum.submobjects[-1].get_center() + 0.5 * RIGHT\n",
        "        B = A + RIGHT + 1.3 * UP + 0.025 * LEFT\n",
        "        right_arc = DashedLine(TAU/4*UP, ORIGIN, stroke_color = YELLOW,\n",
        "            stroke_width = 8).apply_complex_function(np.exp)\n",
        "        right_arc.rotate(-TAU/4).next_to(infsum, RIGHT).shift(0.5 * UP)\n",
        "        right_tip_line = Arrow(B - UP, B, color = WHITE)\n",
        "        right_tip_line.add_tip()\n",
        "        right_tip = right_tip_line.get_tip()\n",
        "        right_tip.set_fill(color = YELLOW)\n",
        "        right_arc.add(right_tip)\n",
        "        \n",
        "\n",
        "        C = B + 3.2 * UP\n",
        "        right_line = DashedLine(B + 0.2 * DOWN,C + 0.2 * UP, stroke_color = YELLOW,\n",
        "            stroke_width = 8)\n",
        "\n",
        "        ru_arc = right_arc.copy().rotate(angle = TAU/4)\n",
        "        ru_arc.remove(ru_arc.submobjects[-1])\n",
        "        ru_arc.to_edge(UP+RIGHT, buff = 0.15)\n",
        "\n",
        "        D = np.array([5.85, 3.85,0])\n",
        "        E = np.array([-D[0],D[1],0])\n",
        "        up_line = DashedLine(D, E, stroke_color = YELLOW,\n",
        "            stroke_width = 8)\n",
        "\n",
        "        lu_arc = ru_arc.copy().flip().to_edge(LEFT + UP, buff = 0.15)\n",
        "        left_line = right_line.copy().flip(axis = RIGHT).to_edge(LEFT, buff = 0.15)\n",
        "\n",
        "        left_arc = right_arc.copy().rotate(-TAU/4)\n",
        "        left_arc.next_to(infsum, LEFT).shift(0.5 * UP + 0.1 * LEFT)\n",
        "\n",
        "        right_arc.shift(0.2 * RIGHT)\n",
        "        right_line.shift(0.2 * RIGHT)\n",
        "\n",
        "        self.play(FadeIn(right_arc))\n",
        "        self.play(ShowCreation(right_line))\n",
        "        self.play(FadeIn(ru_arc))\n",
        "        self.play(ShowCreation(up_line))\n",
        "        self.play(FadeIn(lu_arc))\n",
        "        self.play(ShowCreation(left_line))\n",
        "        self.play(FadeIn(left_arc))\n",
        "\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class RightAnglesOverlay(Scene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = [0,BASELINE_YPOS,0]\n",
        "        LAKE0_RADIUS = 1.5 * 2\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.2\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        RIGHT_ANGLE_SIZE = 0.3\n",
        "\n",
        "\n",
        "        def right_angle(pointA, pointB, pointC, size = 1):\n",
        "\n",
        "            v1 = pointA - pointB\n",
        "            v1 = size * v1/get_norm(v1)\n",
        "            v2 = pointC - pointB\n",
        "            v2 = size * v2/get_norm(v2)\n",
        "            \n",
        "            P = pointB\n",
        "            Q = pointB + v1\n",
        "            R = Q + v2\n",
        "            S = R - v1\n",
        "            angle_sign = VMobject()\n",
        "            angle_sign.set_points_as_corners([P,Q,R,S,P])\n",
        "            angle_sign.mark_paths_closed = True\n",
        "            angle_sign.set_fill(color = WHITE, opacity = 1)\n",
        "            angle_sign.set_stroke(width = 0)\n",
        "            return angle_sign\n",
        "\n",
        "\n",
        "        lake_center = OBSERVER_POINT + LAKE0_RADIUS * UP\n",
        "        points = []\n",
        "        lines = VGroup()\n",
        "        for i in range(4):\n",
        "            theta = -TAU/4 + (i+0.5)*TAU/4\n",
        "            v = np.array([np.cos(theta), np.sin(theta), 0])\n",
        "            P = lake_center + LAKE0_RADIUS * v\n",
        "            points.append(P)\n",
        "            lines.add(Line(lake_center, P, stroke_width = 8))\n",
        "\n",
        "        self.play(FadeIn(lines))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for i in range(4):\n",
        "            sign = right_angle(points[i-1], lake_center, points[i],RIGHT_ANGLE_SIZE)\n",
        "            self.play(FadeIn(sign))\n",
        "            self.play(FadeOut(sign))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(lines))\n",
        "\n",
        "        flash_arcs(3)\n"
    ]
}