{
    "topic": "The mathematical concept being demonstrated is the visualization of a graph using Manim animation software.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2017.eoc.chapter2 import Car, MoveCar\n",
        "\n",
        "\n",
        "class Eoc1Thumbnail(GraphScene):\n",
        "    CONFIG = {\n",
        "\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"The Essence of\\\\\\\\Calculus\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\emph{you}\": YELLOW,\n",
        "            },\n",
        "        )\n",
        "        subtitle = OldTexText(\"Chapter 1\")\n",
        "        subtitle.match_width(title)\n",
        "        subtitle.scale(0.75)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        # title.add(subtitle)\n",
        "        title.set_width(FRAME_WIDTH - 2)\n",
        "        title.to_edge(UP)\n",
        "        title.set_stroke(BLACK, 8, background=True)\n",
        "        # answer = OldTexText(\"...yes\")\n",
        "        # answer.to_edge(DOWN)\n",
        "\n",
        "        axes = Axes(\n",
        "            x_range=(-1, 5),\n",
        "            y_range=(-1, 5),\n",
        "            y_axis_config={\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            x_axis_config={\n",
        "                \"unit_size\": 2,\n",
        "            },\n",
        "        )\n",
        "        axes.set_width(FRAME_WIDTH - 1)\n",
        "        axes.center().to_edge(DOWN)\n",
        "        axes.shift(DOWN)\n",
        "        self.x_axis = axes.x_axis\n",
        "        self.y_axis = axes.y_axis\n",
        "        self.axes = axes\n",
        "\n",
        "        graph = self.get_graph(self.func)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            graph,\n",
        "            x_min=0, x_max=4,\n",
        "            dx=0.2,\n",
        "        )\n",
        "        rects.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        rects.set_opacity(1)\n",
        "        rects.set_stroke(BLACK, 1)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph)\n",
        "        self.add(rects)\n",
        "        # self.add(title)\n",
        "        # self.add(answer)\n",
        "\n",
        "    def func(self, x):\n",
        "        return 0.35 * ((x - 2)**3 - 2 * (x - 2) + 6)\n",
        "\n",
        "\n",
        "class CircleScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 1.5,\n",
        "        \"stroke_color\" : WHITE,\n",
        "        \"fill_color\" : BLUE_E,\n",
        "        \"fill_opacity\" : 0.75,\n",
        "        \"radial_line_color\" : MAROON_B,\n",
        "        \"outer_ring_color\" : GREEN_E,\n",
        "        \"ring_colors\" : [BLUE, GREEN],\n",
        "        \"dR\" : 0.1,\n",
        "        \"dR_color\" : YELLOW,\n",
        "        \"unwrapped_tip\" : ORIGIN,\n",
        "        \"include_pi_creature\" : False,\n",
        "        \"circle_corner\" : UP+LEFT,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.circle = Circle(\n",
        "            radius = self.radius,\n",
        "            stroke_color = self.stroke_color,\n",
        "            fill_color = self.fill_color,\n",
        "            fill_opacity = self.fill_opacity,\n",
        "        )\n",
        "        self.circle.to_corner(self.circle_corner, buff = MED_LARGE_BUFF)\n",
        "        self.radius_line = Line(\n",
        "            self.circle.get_center(),\n",
        "            self.circle.get_right(),\n",
        "            color = self.radial_line_color\n",
        "        )\n",
        "        self.radius_brace = Brace(self.radius_line, buff = SMALL_BUFF)\n",
        "        self.radius_label = self.radius_brace.get_text(\"$R$\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.radius_group = VGroup(\n",
        "            self.radius_line, self.radius_brace, self.radius_label\n",
        "        )\n",
        "        self.add(self.circle, *self.radius_group)\n",
        "\n",
        "        if not self.include_pi_creature:\n",
        "            self.remove(self.get_primary_pi_creature())\n",
        "\n",
        "    def introduce_circle(self, added_anims = []):\n",
        "        self.remove(self.circle)\n",
        "        self.play(\n",
        "            ShowCreation(self.radius_line),\n",
        "            GrowFromCenter(self.radius_brace),\n",
        "            Write(self.radius_label),\n",
        "        )\n",
        "        self.circle.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                self.radius_line, 2*np.pi-0.001, \n",
        "                about_point = self.circle.get_center(),\n",
        "            ),\n",
        "            ShowCreation(self.circle),\n",
        "            *added_anims,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            self.circle.set_fill, self.fill_color, self.fill_opacity,\n",
        "            Animation(self.radius_line),\n",
        "            Animation(self.radius_brace),\n",
        "            Animation(self.radius_label),\n",
        "        )\n",
        "\n",
        "    def increase_radius(self, numerical_dr = True, run_time = 2):\n",
        "        radius_mobs = VGroup(\n",
        "            self.radius_line, self.radius_brace, self.radius_label\n",
        "        )\n",
        "        nudge_line = Line(\n",
        "            self.radius_line.get_right(),\n",
        "            self.radius_line.get_right() + self.dR*RIGHT,\n",
        "            color = self.dR_color\n",
        "        )\n",
        "        nudge_arrow = Arrow(\n",
        "            nudge_line.get_center() + 0.5*RIGHT+DOWN,\n",
        "            nudge_line.get_center(),\n",
        "            color = YELLOW,\n",
        "            buff = SMALL_BUFF,\n",
        "            tip_length = 0.2,\n",
        "        )\n",
        "        if numerical_dr:\n",
        "            nudge_label = OldTex(\"%.01f\"%self.dR)\n",
        "        else:\n",
        "            nudge_label = OldTex(\"dr\")\n",
        "        nudge_label.set_color(self.dR_color)\n",
        "        nudge_label.scale(0.75)\n",
        "        nudge_label.next_to(nudge_arrow.get_start(), DOWN)\n",
        "\n",
        "        radius_mobs.add(nudge_line, nudge_arrow, nudge_label)\n",
        "\n",
        "        outer_ring = self.get_outer_ring()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(outer_ring),            \n",
        "            ShowCreation(nudge_line),\n",
        "            ShowCreation(nudge_arrow),\n",
        "            Write(nudge_label),\n",
        "            run_time = run_time/2.\n",
        "        )\n",
        "        self.wait(run_time/2.)\n",
        "        self.nudge_line = nudge_line\n",
        "        self.nudge_arrow = nudge_arrow\n",
        "        self.nudge_label = nudge_label\n",
        "        self.outer_ring = outer_ring\n",
        "        return outer_ring\n",
        "\n",
        "    def get_ring(self, radius, dR, color = GREEN):\n",
        "        ring = Circle(radius = radius + dR).center()\n",
        "        inner_ring = Circle(radius = radius)\n",
        "        inner_ring.rotate(np.pi, RIGHT)\n",
        "        ring.append_vectorized_mobject(inner_ring)\n",
        "        ring.set_stroke(width = 0)\n",
        "        ring.set_fill(color)\n",
        "        ring.move_to(self.circle)\n",
        "        ring.R = radius \n",
        "        ring.dR = dR\n",
        "        return ring\n",
        "\n",
        "    def get_rings(self, **kwargs):\n",
        "        dR = kwargs.get(\"dR\", self.dR)\n",
        "        colors = kwargs.get(\"colors\", self.ring_colors)\n",
        "        radii = np.arange(0, self.radius, dR)\n",
        "        colors = color_gradient(colors, len(radii))\n",
        "\n",
        "        rings = VGroup(*[\n",
        "            self.get_ring(radius, dR = dR, color = color)\n",
        "            for radius, color in zip(radii, colors)\n",
        "        ])\n",
        "        return rings\n",
        "\n",
        "    def get_outer_ring(self):\n",
        "        return self.get_ring(\n",
        "            radius = self.radius, dR = self.dR,\n",
        "            color = self.outer_ring_color\n",
        "        )\n",
        "\n",
        "    def unwrap_ring(self, ring, **kwargs):\n",
        "        self.unwrap_rings(ring, **kwargs)\n",
        "\n",
        "    def unwrap_rings(self, *rings, **kwargs):\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        rings = VGroup(*rings)\n",
        "        unwrapped = VGroup(*[\n",
        "            self.get_unwrapped(ring, **kwargs)\n",
        "            for ring in rings\n",
        "        ])\n",
        "        self.play(\n",
        "            rings.rotate, np.pi/2,\n",
        "            rings.next_to, unwrapped.get_bottom(), UP,\n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2,\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(rings, unwrapped, run_time = 3),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def get_unwrapped(self, ring, to_edge = LEFT, **kwargs):\n",
        "        R = ring.R\n",
        "        R_plus_dr = ring.R + ring.dR\n",
        "        n_anchors = ring.get_num_curves()\n",
        "        result = VMobject()\n",
        "        result.set_points_as_corners([\n",
        "            interpolate(np.pi*R_plus_dr*LEFT,  np.pi*R_plus_dr*RIGHT, a)\n",
        "            for a in np.linspace(0, 1, n_anchors/2)\n",
        "        ]+[\n",
        "            interpolate(np.pi*R*RIGHT+ring.dR*UP,  np.pi*R*LEFT+ring.dR*UP, a)\n",
        "            for a in np.linspace(0, 1, n_anchors/2)\n",
        "        ])\n",
        "        result.set_style_data(\n",
        "            stroke_color = ring.get_stroke_color(),\n",
        "            stroke_width = ring.get_stroke_width(),\n",
        "            fill_color = ring.get_fill_color(),\n",
        "            fill_opacity = ring.get_fill_opacity(),\n",
        "        )\n",
        "        result.move_to(self.unwrapped_tip, aligned_edge = DOWN)\n",
        "        result.shift(R_plus_dr*DOWN)\n",
        "        if to_edge is not None:\n",
        "            result.to_edge(to_edge)\n",
        "\n",
        "        return result\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Randolph(color = BLUE_C)\n",
        "        self.pi_creature.to_corner(DOWN+LEFT)\n",
        "        return self.pi_creature\n",
        "\n",
        "\n",
        "#############\n",
        "\n",
        "class Chapter1OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"\"\"The art of doing mathematics is finding\n",
        "            that \"\"\", \"special case\", \n",
        "            \"\"\"that contains all the \n",
        "            germs of generality.\"\"\"\n",
        "        ],\n",
        "        \"quote_arg_separator\" : \" \",\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"special case\" : BLUE\n",
        "        },\n",
        "        \"author\" : \"David Hilbert\",\n",
        "    }\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.show_series()\n",
        "        self.show_many_facts()\n",
        "        self.invent_calculus()\n",
        "\n",
        "    def show_series(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[0]\n",
        "        this_video.set_color(YELLOW)\n",
        "        this_video.save_state()\n",
        "        this_video.set_fill(opacity = 0)\n",
        "        this_video.center()\n",
        "        this_video.set_height(FRAME_HEIGHT)\n",
        "        self.this_video = this_video\n",
        "\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Welcome to \\\\\\\\\",\n",
        "            \"Essence of calculus\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Essence of calculus\", YELLOW)\n",
        "\n",
        "        self.teacher.change_mode(\"happy\")\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                series,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Blink(self.get_teacher())\n",
        "        )\n",
        "        self.teacher_says(words, target_mode = \"hooray\")\n",
        "        self.play_student_changes(\n",
        "            *[\"hooray\"]*3,\n",
        "            look_at = series[1].get_left(),\n",
        "            added_anims = [\n",
        "                ApplyMethod(this_video.restore, run_time = 3),\n",
        "            ]\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                video.shift, 0.5*video.get_height()*DOWN,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back, alpha, alpha+0.3\n",
        "                )\n",
        "            )\n",
        "            for video, alpha in zip(series, np.linspace(0, 0.7, len(series)))\n",
        "        ]+[\n",
        "            Animation(self.teacher.bubble),\n",
        "            Animation(self.teacher.bubble.content),\n",
        "        ])\n",
        "\n",
        "        essence_words = words.get_part_by_tex(\"Essence\").copy()\n",
        "        self.play(\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            FadeOut(self.teacher.bubble.content),\n",
        "            essence_words.next_to, series, DOWN,\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"pondering\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.series = series\n",
        "        self.essence_words = essence_words\n",
        "\n",
        "    def show_many_facts(self):\n",
        "        rules = list(it.starmap(Tex, [\n",
        "            (\"{d(\", \"x\", \"^2)\", \"\\\\over \\\\,\", \"dx}\", \"=\", \"2\", \"x\"),\n",
        "            (\n",
        "                \"d(\", \"f\", \"g\", \")\", \"=\", \n",
        "                \"f\", \"dg\", \"+\", \"g\", \"df\",\n",
        "            ),\n",
        "            (\n",
        "                \"F(x)\", \"=\", \"\\\\int_0^x\", \n",
        "                \"\\\\frac{dF}{dg}(t)\\\\,\", \"dt\"\n",
        "            ),\n",
        "            (\n",
        "                \"f(x)\", \"=\", \"\\\\sum_{n = 0}^\\\\infty\",\n",
        "                \"f^{(n)}(a)\", \"\\\\frac{(x-a)^n}{n!}\"\n",
        "            ),\n",
        "        ]))\n",
        "        video_indices = [2, 3, 7, 10]\n",
        "        tex_to_color = [\n",
        "            (\"x\", BLUE),\n",
        "            (\"f\", BLUE),\n",
        "            (\"df\", BLUE),\n",
        "            (\"g\", YELLOW),\n",
        "            (\"dg\", YELLOW),\n",
        "            (\"f(x)\", BLUE),\n",
        "            ( \"f^{(n)}(a)\", BLUE),\n",
        "        ]\n",
        "\n",
        "        for rule in rules:\n",
        "            for tex, color in tex_to_color:\n",
        "                rule.set_color_by_tex(tex, color, substring = False)\n",
        "            rule.next_to(self.teacher.get_corner(UP+LEFT), UP)\n",
        "            rule.shift_onto_screen()\n",
        "\n",
        "        index = 1\n",
        "        student = self.get_students()[index]\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"sassy\", \"pondering\",\n",
        "            look_at = self.teacher.eyes,\n",
        "            added_anims = [\n",
        "                self.teacher.change_mode, \"plain\"\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(rules[0]),\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "        alt_rules_list = list(rules[1:]) + [VectorizedPoint(self.teacher.eyes.get_top())]\n",
        "        for last_rule, rule, video_index in zip(rules, alt_rules_list, video_indices):\n",
        "            video = self.series[video_index]\n",
        "            self.play(\n",
        "                last_rule.replace, video,\n",
        "                FadeIn(rule),\n",
        "            )\n",
        "            self.play(Animation(rule))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change_mode, \"happy\",\n",
        "            self.teacher.look_at, student.eyes\n",
        "        )\n",
        "\n",
        "    def invent_calculus(self):\n",
        "        student = self.get_students()[1]\n",
        "        creatures = self.get_pi_creatures()\n",
        "        creatures.remove(student)\n",
        "        creature_copies = creatures.copy()\n",
        "        self.remove(creatures)\n",
        "        self.add(creature_copies)\n",
        "\n",
        "        calculus = VGroup(*self.essence_words[-len(\"calculus\"):])\n",
        "        calculus.generate_target()\n",
        "        invent = OldTexText(\"Invent\")\n",
        "        invent_calculus = VGroup(invent, calculus.target)\n",
        "        invent_calculus.arrange(RIGHT, buff = MED_SMALL_BUFF)\n",
        "        invent_calculus.next_to(student, UP, 1.5*LARGE_BUFF)\n",
        "        invent_calculus.shift(RIGHT)\n",
        "        arrow = Arrow(invent_calculus, student)\n",
        "\n",
        "        fader = Rectangle(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = FRAME_HEIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fader),\n",
        "            Animation(student),\n",
        "            Animation(calculus)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(invent),\n",
        "            MoveToTarget(calculus),\n",
        "            student.change_mode, \"erm\",\n",
        "            student.look_at, calculus\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait(2)\n",
        "\n",
        "class PreviewFrame(Scene):\n",
        "    def construct(self):\n",
        "        frame = Rectangle(height = 9, width = 16, color = WHITE)\n",
        "        frame.set_height(1.5*FRAME_Y_RADIUS)\n",
        "\n",
        "        colors = iter(color_gradient([BLUE, YELLOW], 3))\n",
        "        titles = [\n",
        "            OldTexText(\"Chapter %d:\"%d, s).to_edge(UP).set_color(next(colors))\n",
        "            for d, s in [\n",
        "                (3, \"Derivative formulas through geometry\"),\n",
        "                (4, \"Chain rule, product rule, etc.\"),\n",
        "                (7, \"Limits\"),\n",
        "            ]\n",
        "        ]\n",
        "        title = titles[0]\n",
        "\n",
        "        frame.next_to(title, DOWN)\n",
        "\n",
        "        self.add(frame, title)\n",
        "        self.wait(3)\n",
        "        for next_title in titles[1:]:\n",
        "            self.play(Transform(title, next_title))\n",
        "            self.wait(3)\n",
        "\n",
        "class ProductRuleDiagram(Scene):\n",
        "    def construct(self):\n",
        "        df = 0.4\n",
        "        dg = 0.2\n",
        "        rect_kwargs = {\n",
        "            \"stroke_width\" : 0,\n",
        "            \"fill_color\" : BLUE,\n",
        "            \"fill_opacity\" : 0.6,\n",
        "        }\n",
        "\n",
        "        rect = Rectangle(width = 4, height = 3, **rect_kwargs)\n",
        "        rect.shift(DOWN)\n",
        "        df_rect = Rectangle(\n",
        "            height = rect.get_height(),\n",
        "            width = df,\n",
        "            **rect_kwargs\n",
        "        )\n",
        "        dg_rect = Rectangle(\n",
        "            height = dg,\n",
        "            width = rect.get_width(),\n",
        "            **rect_kwargs\n",
        "        )\n",
        "        corner_rect = Rectangle(\n",
        "            height = dg, \n",
        "            width = df,\n",
        "            **rect_kwargs\n",
        "        )\n",
        "        d_rects = VGroup(df_rect, dg_rect, corner_rect)\n",
        "        for d_rect, direction in zip(d_rects, [RIGHT, DOWN, RIGHT+DOWN]):\n",
        "            d_rect.next_to(rect, direction, buff = 0)\n",
        "            d_rect.set_fill(YELLOW, 0.75)\n",
        "\n",
        "        corner_pairs = [\n",
        "            (DOWN+RIGHT, UP+RIGHT),\n",
        "            (DOWN+RIGHT, DOWN+LEFT),\n",
        "            (DOWN+RIGHT, DOWN+RIGHT),\n",
        "        ]\n",
        "        for d_rect, corner_pair in zip(d_rects, corner_pairs):\n",
        "            line = Line(*[\n",
        "                rect.get_corner(corner)\n",
        "                for corner in corner_pair\n",
        "            ])\n",
        "            d_rect.line = d_rect.copy().replace(line, stretch = True)\n",
        "            d_rect.line.set_color(d_rect.get_color())\n",
        "\n",
        "        f_brace = Brace(rect, UP)\n",
        "        g_brace = Brace(rect, LEFT)\n",
        "        df_brace = Brace(df_rect, UP)\n",
        "        dg_brace = Brace(dg_rect, LEFT)\n",
        "\n",
        "        f_label = f_brace.get_text(\"$f$\")\n",
        "        g_label = g_brace.get_text(\"$g$\")\n",
        "        df_label = df_brace.get_text(\"$df$\")\n",
        "        dg_label = dg_brace.get_text(\"$dg$\")\n",
        "\n",
        "        VGroup(f_label, df_label).set_color(GREEN)\n",
        "        VGroup(g_label, dg_label).set_color(RED)\n",
        "\n",
        "        f_label.generate_target()\n",
        "        g_label.generate_target()\n",
        "        fg_group = VGroup(f_label.target, g_label.target)\n",
        "        fg_group.generate_target()\n",
        "        fg_group.target.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        fg_group.target.move_to(rect.get_center())\n",
        "\n",
        "        for mob in df_brace, df_label, dg_brace, dg_label:\n",
        "            mob.save_state()\n",
        "            mob.scale(0.01, about_point = rect.get_corner(\n",
        "                mob.get_center() - rect.get_center()\n",
        "            ))\n",
        "\n",
        "        self.add(rect)\n",
        "        self.play(\n",
        "            GrowFromCenter(f_brace),\n",
        "            GrowFromCenter(g_brace),\n",
        "            Write(f_label),\n",
        "            Write(g_label),\n",
        "        )\n",
        "        self.play(MoveToTarget(fg_group))\n",
        "        self.play(*[\n",
        "            mob.restore\n",
        "            for mob in (df_brace, df_label, dg_brace, dg_label)\n",
        "        ] + [\n",
        "            ReplacementTransform(d_rect.line, d_rect)\n",
        "            for d_rect in d_rects\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            d_rects.space_out_submobjects, 1.2,\n",
        "            MaintainPositionRelativeTo(\n",
        "                VGroup(df_brace, df_label),\n",
        "                df_rect\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(\n",
        "                VGroup(dg_brace, dg_label),\n",
        "                dg_rect\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        deriv = OldTex(\n",
        "            \"d(\", \"fg\", \")\", \"=\", \n",
        "            \"f\", \"\\\\cdot\", \"dg\", \"+\", \"g\", \"\\\\cdot\", \"df\"\n",
        "        )\n",
        "        deriv.to_edge(UP)\n",
        "        alpha_iter = iter(np.linspace(0, 0.5, 5))\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                mob.copy().move_to,\n",
        "                deriv.get_part_by_tex(tex, substring = False),\n",
        "                rate_func = squish_rate_func(smooth, alpha, alpha+0.5)\n",
        "            )\n",
        "            for mob, tex in [\n",
        "                (fg_group, \"fg\"),\n",
        "                (f_label, \"f\"),\n",
        "                (dg_label, \"dg\"),\n",
        "                (g_label, \"g\"),\n",
        "                (df_label, \"df\"),\n",
        "            ]\n",
        "            for alpha in [next(alpha_iter)]\n",
        "        ]+[\n",
        "            Write(VGroup(*it.chain(*[\n",
        "                deriv.get_parts_by_tex(tex, substring = False)\n",
        "                for tex in (\"d(\", \")\", \"=\", \"\\\\cdot\", \"+\")\n",
        "            ])))\n",
        "        ], run_time = 3)\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceCircle(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"include_pi_creature\" : True,\n",
        "        \"unwrapped_tip\" : 2*RIGHT\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.introduce_area()\n",
        "        self.question_area()\n",
        "        self.show_calculus_symbols()\n",
        "\n",
        "    def introduce_area(self):\n",
        "        area = OldTex(\"\\\\text{Area}\", \"=\", \"\\\\pi\", \"R\", \"^2\")\n",
        "        area.next_to(self.pi_creature.get_corner(UP+RIGHT), UP+RIGHT)\n",
        "\n",
        "        self.remove(self.circle, self.radius_group)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look_at, self.circle\n",
        "        )\n",
        "        self.introduce_circle()\n",
        "        self.wait()\n",
        "        R_copy = self.radius_label.copy()\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "            self.pi_creature.look_at, area,\n",
        "            Transform(R_copy, area.get_part_by_tex(\"R\"))\n",
        "        )\n",
        "        self.play(Write(area))\n",
        "        self.remove(R_copy)\n",
        "        self.wait()\n",
        "\n",
        "        self.area = area\n",
        "\n",
        "    def question_area(self):\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(self.pi_creature, UP)\n",
        "        rings = VGroup(*reversed(self.get_rings()))\n",
        "        unwrapped_rings = VGroup(*[\n",
        "            self.get_unwrapped(ring, to_edge = None)\n",
        "            for ring in rings\n",
        "        ])\n",
        "        unwrapped_rings.arrange(UP, buff = SMALL_BUFF)\n",
        "        unwrapped_rings.move_to(self.unwrapped_tip, UP)\n",
        "        ring_anim_kwargs = {\n",
        "            \"run_time\" : 3,\n",
        "            \"lag_ratio\" : 0.5\n",
        "        }\n",
        "\n",
        "        self.play(\n",
        "            Animation(self.area),\n",
        "            Write(q_marks),\n",
        "            self.pi_creature.change_mode, \"confused\",\n",
        "            self.pi_creature.look_at, self.area,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rings, **ring_anim_kwargs),\n",
        "            Animation(self.radius_group),\n",
        "            FadeOut(q_marks),\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rings.rotate, np.pi/2,\n",
        "            rings.move_to, unwrapped_rings.get_top(),\n",
        "            Animation(self.radius_group),\n",
        "            path_arc = np.pi/2,\n",
        "            **ring_anim_kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(rings, unwrapped_rings, **ring_anim_kwargs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_calculus_symbols(self):\n",
        "        ftc = OldTex(\n",
        "            \"\\\\int_0^R\", \"\\\\frac{dA}{dr}\", \"\\\\,dr\",\n",
        "            \"=\", \"A(R)\"\n",
        "        )\n",
        "        ftc.shift(2*UP)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.area.get_part_by_tex(\"R\").copy(),\n",
        "                ftc.get_part_by_tex(\"int\")\n",
        "            ),\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.area.get_part_by_tex(\"Area\").copy(),\n",
        "                ftc.get_part_by_tex(\"frac\")\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.area.get_part_by_tex(\"R\").copy(),\n",
        "                ftc.get_part_by_tex(\"\\\\,dr\")\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(*ftc[-2:])))\n",
        "        self.wait(2)\n",
        "\n",
        "class ApproximateOneRing(CircleScene, ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"num_lines\" : 24,\n",
        "        \"ring_index_proportion\" : 0.6,\n",
        "        \"ring_shift_val\" : 6*RIGHT,\n",
        "        \"ring_colors\" : [BLUE, GREEN_E],\n",
        "        \"unwrapped_tip\" : 2*RIGHT+0.5*UP,\n",
        "    }\n",
        "    def setup(self):\n",
        "        CircleScene.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.write_radius_three()\n",
        "        self.try_to_understand_area()\n",
        "        self.slice_into_rings()\n",
        "        self.isolate_one_ring()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.straighten_ring_out()\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.approximate_as_rectangle()\n",
        "\n",
        "    def write_radius_three(self):\n",
        "        three = OldTex(\"3\")\n",
        "        three.move_to(self.radius_label)\n",
        "\n",
        "        self.look_at(self.circle)\n",
        "        self.play(Transform(\n",
        "            self.radius_label, three,\n",
        "            path_arc = np.pi\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def try_to_understand_area(self):\n",
        "        line_sets = [\n",
        "            VGroup(*[\n",
        "                Line(\n",
        "                    self.circle.point_from_proportion(alpha),\n",
        "                    self.circle.point_from_proportion(func(alpha)),\n",
        "                )\n",
        "                for alpha in np.linspace(0, 1, self.num_lines)\n",
        "            ])\n",
        "            for func in [\n",
        "                lambda alpha : 1-alpha,\n",
        "                lambda alpha : (0.5-alpha)%1,\n",
        "                lambda alpha : (alpha + 0.4)%1,\n",
        "                lambda alpha : (alpha + 0.5)%1,\n",
        "            ]\n",
        "        ]\n",
        "        for lines in line_sets:\n",
        "            lines.set_stroke(BLACK, 2)\n",
        "        lines = line_sets[0]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                lines, \n",
        "                run_time = 2, \n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Animation(self.radius_group),\n",
        "            self.pi_creature.change_mode, \"maybe\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for new_lines in line_sets[1:]:\n",
        "            self.play(\n",
        "                Transform(lines, new_lines),\n",
        "                Animation(self.radius_group)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(FadeOut(lines), Animation(self.radius_group))\n",
        "\n",
        "    def slice_into_rings(self):\n",
        "        rings = self.get_rings()\n",
        "        rings.set_stroke(BLACK, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                rings,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3\n",
        "            ),\n",
        "            Animation(self.radius_group),\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look_at, self.circle\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                Rotate(rings, np.pi, in_place = True, run_time = 2),\n",
        "                Animation(self.radius_group),\n",
        "                self.pi_creature.change_mode, \"happy\"\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.rings = rings\n",
        "\n",
        "    def isolate_one_ring(self):\n",
        "        rings = self.rings\n",
        "        index = int(self.ring_index_proportion*len(rings))\n",
        "        original_ring = rings[index]\n",
        "        ring = original_ring.copy()\n",
        "\n",
        "        radius = Line(ORIGIN, ring.R*RIGHT, color = WHITE)\n",
        "        radius.rotate(np.pi/4)\n",
        "        r_label = OldTex(\"r\")\n",
        "        r_label.next_to(radius.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "        area_q = OldTexText(\"Area\", \"?\", arg_separator = \"\")\n",
        "        area_q.set_color(YELLOW)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            ring.shift, self.ring_shift_val,\n",
        "            original_ring.set_fill, None, 0.25,\n",
        "            Animation(self.radius_group),\n",
        "        )\n",
        "\n",
        "        VGroup(radius, r_label).shift(ring.get_center())\n",
        "        area_q.next_to(ring, RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(Write(r_label))\n",
        "        self.wait()\n",
        "        self.play(Write(area_q))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                r.set_fill, YELLOW, \n",
        "                rate_func = squish_rate_func(there_and_back, alpha, alpha+0.15),\n",
        "                run_time = 3\n",
        "            )\n",
        "            for r, alpha in zip(rings, np.linspace(0, 0.85, len(rings)))\n",
        "        ]+[\n",
        "            Animation(self.radius_group)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "\n",
        "        self.original_ring = original_ring\n",
        "        self.ring = ring\n",
        "        self.ring_radius_group = VGroup(radius, r_label)\n",
        "        self.area_q = area_q\n",
        "\n",
        "    def straighten_ring_out(self):\n",
        "        ring = self.ring.copy()\n",
        "        trapezoid = OldTexText(\"Trapezoid?\")\n",
        "        rectangle_ish = OldTexText(\"Rectangle-ish\")\n",
        "        for text in trapezoid, rectangle_ish:\n",
        "            text.next_to(\n",
        "                self.pi_creature.get_corner(UP+RIGHT), \n",
        "                DOWN+RIGHT, buff = MED_LARGE_BUFF\n",
        "            )\n",
        "\n",
        "        self.unwrap_ring(ring, to_edge = RIGHT)\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "        self.play(Write(trapezoid))\n",
        "        self.wait()\n",
        "        self.play(trapezoid.shift, DOWN)\n",
        "        strike = Line(\n",
        "            trapezoid.get_left(), trapezoid.get_right(),\n",
        "            stroke_color = RED,\n",
        "            stroke_width = 8\n",
        "        )\n",
        "        self.play(\n",
        "            Write(rectangle_ish),\n",
        "            ShowCreation(strike),\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [trapezoid, strike])))\n",
        "\n",
        "        self.unwrapped_ring = ring\n",
        "\n",
        "    def approximate_as_rectangle(self):\n",
        "        top_brace, side_brace = [\n",
        "            Brace(\n",
        "                self.unwrapped_ring, vect, buff = SMALL_BUFF,\n",
        "                min_num_quads = 2,\n",
        "            )\n",
        "            for vect in (UP, LEFT)\n",
        "        ]\n",
        "        top_brace.scale(self.ring.R/(self.ring.R+self.dR))\n",
        "        side_brace.set_stroke(WHITE, 0.5)\n",
        "\n",
        "\n",
        "        width_label = OldTex(\"2\\\\pi\", \"r\")\n",
        "        width_label.next_to(top_brace, UP, SMALL_BUFF)\n",
        "        dr_label = OldTex(\"dr\")\n",
        "        q_marks = OldTex(\"???\")\n",
        "        concrete_dr = OldTex(\"=0.1\")\n",
        "        concrete_dr.submobjects.reverse()\n",
        "        for mob in dr_label, q_marks, concrete_dr:\n",
        "            mob.next_to(side_brace, LEFT, SMALL_BUFF)\n",
        "        dr_label.save_state()\n",
        "\n",
        "        alt_side_brace = side_brace.copy()\n",
        "        alt_side_brace.move_to(ORIGIN, UP+RIGHT)\n",
        "        alt_side_brace.rotate(-np.pi/2)\n",
        "        alt_side_brace.shift(\n",
        "            self.original_ring.get_boundary_point(RIGHT)\n",
        "        )\n",
        "        alt_dr_label = dr_label.copy()\n",
        "        alt_dr_label.next_to(alt_side_brace, UP, SMALL_BUFF)\n",
        "\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.next_to(\n",
        "            self.area_q.get_part_by_tex(\"Area\"), \n",
        "            RIGHT,\n",
        "            align_using_submobjects = True,\n",
        "        )\n",
        "        two_pi_r_dr = VGroup(width_label, dr_label).copy()\n",
        "        two_pi_r_dr.generate_target()\n",
        "        two_pi_r_dr.target.arrange(\n",
        "            RIGHT, buff = SMALL_BUFF, aligned_edge = DOWN\n",
        "        )\n",
        "        two_pi_r_dr.target.next_to(approx, RIGHT, aligned_edge = DOWN)\n",
        "\n",
        "        self.play(GrowFromCenter(top_brace))\n",
        "        self.play(\n",
        "            Write(width_label.get_part_by_tex(\"pi\")),\n",
        "            ReplacementTransform(\n",
        "                self.ring_radius_group[1].copy(),\n",
        "                width_label.get_part_by_tex(\"r\")\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(side_brace),\n",
        "            Write(q_marks)\n",
        "        )\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "        for num_rings in 20, 7:\n",
        "            self.show_alternate_width(num_rings)\n",
        "        self.play(ReplacementTransform(q_marks, dr_label))\n",
        "        self.play(\n",
        "            ReplacementTransform(side_brace.copy(), alt_side_brace),\n",
        "            ReplacementTransform(dr_label.copy(), alt_dr_label),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dr_label.next_to, concrete_dr.copy(), LEFT, SMALL_BUFF, DOWN,\n",
        "            Write(concrete_dr, run_time = 2),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            MoveToTarget(two_pi_r_dr),\n",
        "            FadeIn(approx),\n",
        "            self.area_q.get_part_by_tex(\"?\").fade, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(concrete_dr),\n",
        "            dr_label.restore\n",
        "        )\n",
        "        self.show_alternate_width(\n",
        "            40, \n",
        "            transformation_kwargs = {\"run_time\" : 4},\n",
        "            return_to_original_configuration = False,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.look_at(self.circle)\n",
        "        self.play(\n",
        "            ApplyWave(self.rings, amplitude = 0.1),\n",
        "            Animation(self.radius_group),\n",
        "            Animation(alt_side_brace),\n",
        "            Animation(alt_dr_label),\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_alternate_width(self, num_rings, **kwargs):\n",
        "        self.transition_to_alt_config(\n",
        "            dR = self.radius/num_rings, **kwargs\n",
        "        )\n",
        "\n",
        "class MoveForwardWithApproximation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Move forward with \\\\\\\\\",\n",
        "            \"the\", \"approximation\"\n",
        "        )\n",
        "        self.play_student_changes(\"hesitant\", \"erm\", \"sassy\")\n",
        "        self.wait()\n",
        "        words = OldTexText(\n",
        "            \"It gets better\", \n",
        "            \"\\\\\\\\ for smaller \",\n",
        "            \"$dr$\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"dr\", BLUE)\n",
        "        self.teacher_says(words, target_mode = \"shruggie\")\n",
        "        self.wait(3)\n",
        "\n",
        "class GraphRectangles(CircleScene, GraphScene):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : 3.25*LEFT+2.5*DOWN,\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 4,\n",
        "        \"x_axis_width\" : 7,\n",
        "        \"x_labeled_nums\" : list(range(5)),\n",
        "        \"x_axis_label\" : \"$r$\",\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 20,\n",
        "        \"y_tick_frequency\" : 2.5,\n",
        "        \"y_labeled_nums\" : list(range(5, 25, 5)),\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"exclude_zero_label\" : False,\n",
        "        \"num_rings_in_ring_sum_start\" : 3,\n",
        "        \"tick_height\" : 0.2,\n",
        "    }\n",
        "    def setup(self):\n",
        "        CircleScene.setup(self)\n",
        "        GraphScene.setup(self)\n",
        "        self.setup_axes()\n",
        "        self.remove(self.axes)\n",
        "\n",
        "        # self.pi_creature.change_mode(\"pondering\")\n",
        "        # self.pi_creature.look_at(self.circle)\n",
        "        # self.add(self.pi_creature)\n",
        "\n",
        "        three = OldTex(\"3\")\n",
        "        three.move_to(self.radius_label)\n",
        "        self.radius_label.save_state()\n",
        "        Transform(self.radius_label, three).update(1)\n",
        "\n",
        "    def construct(self):\n",
        "        self.draw_ring_sum()\n",
        "        self.draw_r_values()\n",
        "        self.unwrap_rings_onto_graph()\n",
        "        self.draw_graph()\n",
        "        self.point_out_approximation()\n",
        "        self.let_dr_approah_zero()\n",
        "        self.compute_area_under_graph()\n",
        "        self.show_circle_unwrapping()\n",
        "\n",
        "    def draw_ring_sum(self):\n",
        "        rings = self.get_rings()\n",
        "        rings.set_stroke(BLACK, 1)\n",
        "        ring_sum, draw_ring_sum_anims = self.get_ring_sum(rings)\n",
        "        area_label = OldTex(\n",
        "            \"\\\\text{Area}\", \"\\\\approx\", \n",
        "            \"2\\\\pi\", \"r\", \"\\\\,dr\"\n",
        "        )\n",
        "        area_label.set_color_by_tex(\"r\", YELLOW, substring = False)\n",
        "        area_label.next_to(ring_sum, RIGHT, aligned_edge = UP)\n",
        "        area = area_label.get_part_by_tex(\"Area\")\n",
        "        arrow_start = area.get_corner(DOWN+LEFT)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                arrow_start,\n",
        "                ring.target.get_boundary_point(\n",
        "                    arrow_start - ring.target.get_center()\n",
        "                ),\n",
        "                color = ring.get_color()\n",
        "            )\n",
        "            for ring in rings\n",
        "            if ring.target.get_fill_opacity() > 0\n",
        "        ])\n",
        "        \n",
        "        self.add(rings, self.radius_group)\n",
        "        self.remove(self.circle)\n",
        "        self.wait()\n",
        "        self.play(*draw_ring_sum_anims)\n",
        "        self.play(Write(area_label, run_time = 2))\n",
        "        self.play(ShowCreation(arrows))\n",
        "        self.wait()\n",
        "\n",
        "        self.ring_sum = ring_sum\n",
        "        area_label.add(arrows)\n",
        "        self.area_label = area_label\n",
        "        self.rings = rings\n",
        "\n",
        "    def draw_r_values(self):\n",
        "        values_of_r = OldTexText(\"Values of \", \"$r$\")\n",
        "        values_of_r.set_color_by_tex(\"r\", YELLOW)\n",
        "        values_of_r.next_to(\n",
        "            self.x_axis, UP, \n",
        "            buff = 2*LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        r_ticks = VGroup(*[\n",
        "            Line(\n",
        "                self.coords_to_point(r, -self.tick_height),\n",
        "                self.coords_to_point(r, self.tick_height),\n",
        "                color = YELLOW\n",
        "            )\n",
        "            for r in np.arange(0, 3, 0.1)\n",
        "        ])\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                values_of_r.get_part_by_tex(\"r\").get_bottom(),\n",
        "                tick.get_top(),\n",
        "                buff = SMALL_BUFF,\n",
        "                color = YELLOW,\n",
        "                tip_length = 0.15\n",
        "            )\n",
        "            for tick in (r_ticks[0], r_ticks[-1])\n",
        "        ])\n",
        "        first_tick = r_ticks[0].copy()\n",
        "        moving_arrow = arrows[0].copy()\n",
        "\n",
        "        index = 2\n",
        "        dr_brace = Brace(\n",
        "            VGroup(*r_ticks[index:index+2]), \n",
        "            DOWN, buff = SMALL_BUFF\n",
        "        )\n",
        "        dr_label = OldTex(\"dr\")\n",
        "        dr_label.next_to(\n",
        "            dr_brace, DOWN, \n",
        "            buff = SMALL_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        dr_group = VGroup(dr_brace, dr_label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(values_of_r),\n",
        "            FadeIn(self.x_axis),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(moving_arrow),\n",
        "            ShowCreation(first_tick),\n",
        "        )\n",
        "        self.play(Indicate(self.rings[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(moving_arrow, arrows[-1]),\n",
        "            ShowCreation(r_ticks, lag_ratio = 0.5),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Indicate(self.rings[-1]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(dr_group))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [moving_arrow, values_of_r])))\n",
        "\n",
        "        self.x_axis.add(r_ticks)\n",
        "        self.r_ticks = r_ticks\n",
        "        self.dr_group = dr_group\n",
        "        \n",
        "    def unwrap_rings_onto_graph(self):\n",
        "        rings = self.rings\n",
        "        graph = self.get_graph(lambda r : 2*np.pi*r)\n",
        "        flat_graph = self.get_graph(lambda r : 0)\n",
        "        rects, flat_rects = [\n",
        "            self.get_riemann_rectangles(\n",
        "                g, x_min = 0, x_max = 3, dx = self.dR,\n",
        "                start_color = self.rings[0].get_fill_color(),\n",
        "                end_color = self.rings[-1].get_fill_color(),\n",
        "            )\n",
        "            for g in (graph, flat_graph)\n",
        "        ]\n",
        "        self.graph, self.flat_rects = graph, flat_rects\n",
        "\n",
        "        transformed_rings = VGroup()\n",
        "        self.ghost_rings = VGroup()        \n",
        "        for index, rect, r in zip(it.count(), rects, np.arange(0, 3, 0.1)):\n",
        "            proportion = float(index)/len(rects)\n",
        "            ring_index = int(len(rings)*proportion**0.6)\n",
        "            ring = rings[ring_index]\n",
        "            if ring in transformed_rings:\n",
        "                ring = ring.copy()\n",
        "            transformed_rings.add(ring)\n",
        "            if ring.get_fill_opacity() > 0:\n",
        "                ghost_ring = ring.copy()\n",
        "                ghost_ring.set_fill(opacity = 0.25)\n",
        "                self.add(ghost_ring, ring)\n",
        "                self.ghost_rings.add(ghost_ring)\n",
        "\n",
        "            ring.rect = rect\n",
        "\n",
        "            n_anchors = ring.get_num_curves()            \n",
        "            target = VMobject()\n",
        "            target.set_points_as_corners([\n",
        "                interpolate(ORIGIN,  DOWN, a)\n",
        "                for a in np.linspace(0, 1, n_anchors/2)\n",
        "            ]+[\n",
        "                interpolate(DOWN+RIGHT, RIGHT, a)\n",
        "                for a in np.linspace(0, 1, n_anchors/2)\n",
        "            ])\n",
        "            target.replace(rect, stretch = True)\n",
        "            target.stretch_to_fit_height(2*np.pi*r)\n",
        "            target.move_to(rect, DOWN)\n",
        "            target.set_stroke(BLACK, 1)\n",
        "            target.set_fill(ring.get_fill_color(), 1)\n",
        "            ring.target = target\n",
        "            ring.original_ring = ring.copy()\n",
        "\n",
        "        foreground_animations = list(map(Animation, [self.x_axis, self.area_label]))\n",
        "        example_ring = transformed_rings[2]\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                example_ring,\n",
        "                path_arc = -np.pi/2,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Animation(self.x_axis),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            MoveToTarget(\n",
        "                ring,\n",
        "                path_arc = -np.pi/2,\n",
        "                run_time = 4,\n",
        "                rate_func = squish_rate_func(smooth, alpha, alpha+0.25)\n",
        "            )\n",
        "            for ring, alpha in zip(\n",
        "                transformed_rings, \n",
        "                np.linspace(0, 0.75, len(transformed_rings))\n",
        "            )\n",
        "        ] + foreground_animations)\n",
        "        self.wait()\n",
        "\n",
        "        ##Demonstrate height of one rect\n",
        "        highlighted_ring = transformed_rings[6].copy()\n",
        "        original_ring = transformed_rings[6].original_ring\n",
        "        original_ring.move_to(highlighted_ring, RIGHT)\n",
        "        original_ring.set_fill(opacity = 1)\n",
        "        highlighted_ring.save_state()\n",
        "\n",
        "        side_brace = Brace(highlighted_ring, RIGHT)\n",
        "        height_label = side_brace.get_text(\"2\\\\pi\", \"r\")\n",
        "        height_label.set_color_by_tex(\"r\", YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            transformed_rings.set_fill, None, 0.2,\n",
        "            Animation(highlighted_ring),\n",
        "            *foreground_animations\n",
        "        )\n",
        "        self.play(\n",
        "            self.dr_group.arrange, DOWN,\n",
        "            self.dr_group.next_to, highlighted_ring, \n",
        "            DOWN, SMALL_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(side_brace),\n",
        "            Write(height_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(highlighted_ring, original_ring))\n",
        "        self.wait()\n",
        "        self.play(highlighted_ring.restore)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            transformed_rings.set_fill, None, 1,\n",
        "            FadeOut(side_brace),\n",
        "            FadeOut(height_label),\n",
        "            *foreground_animations\n",
        "        )\n",
        "        self.remove(highlighted_ring)\n",
        "        self.wait()\n",
        "\n",
        "        ##Rescale\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                ring.replace, ring.rect, \n",
        "                method_kwargs = {\"stretch\" : True}\n",
        "            )\n",
        "            for ring in transformed_rings\n",
        "        ] + [\n",
        "            Write(self.y_axis),\n",
        "            FadeOut(self.area_label),\n",
        "        ] + foreground_animations)\n",
        "        self.remove(transformed_rings)\n",
        "        self.add(rects)\n",
        "        self.wait()\n",
        "\n",
        "        self.rects = rects\n",
        "\n",
        "    def draw_graph(self):\n",
        "        graph_label = self.get_graph_label(\n",
        "            self.graph, \"2\\\\pi r\", \n",
        "            direction = UP+LEFT,\n",
        "            x_val = 2.5,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(self.graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                rect, flat_rect,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(\n",
        "                    lambda t : 0.1*there_and_back(t), \n",
        "                    alpha, alpha+0.5\n",
        "                ),\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "            for rect, flat_rect, alpha in zip(\n",
        "                self.rects, self.flat_rects,\n",
        "                np.linspace(0, 0.5, len(self.rects))\n",
        "            )\n",
        "        ] + list(map(Animation, [self.x_axis, self.graph]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def point_out_approximation(self):\n",
        "        rect = self.rects[10]\n",
        "        rect.generate_target()\n",
        "        rect.save_state()\n",
        "        approximation = OldTexText(\"= Approximation\")\n",
        "        approximation.scale(0.8)\n",
        "        group = VGroup(rect.target, approximation)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rect),\n",
        "            Write(approximation),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            rect.restore,\n",
        "            FadeOut(approximation)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def let_dr_approah_zero(self):\n",
        "        thinner_rects_list = [\n",
        "            self.get_riemann_rectangles(\n",
        "                self.graph,\n",
        "                x_min = 0, \n",
        "                x_max = 3,\n",
        "                dx = 1./(10*2**n),\n",
        "                stroke_width = 1./(2**n),\n",
        "                start_color = self.rects[0].get_fill_color(),\n",
        "                end_color = self.rects[-1].get_fill_color(),\n",
        "            )\n",
        "            for n in range(1, 5)\n",
        "        ]\n",
        "\n",
        "        self.play(*list(map(FadeOut, [self.r_ticks, self.dr_group])))\n",
        "        self.x_axis.remove(self.r_ticks, *self.r_ticks)\n",
        "        for new_rects in thinner_rects_list:\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    self.rects, new_rects, \n",
        "                    lag_ratio = 0.5,\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                Animation(self.axes),\n",
        "                Animation(self.graph),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(ApplyWave(\n",
        "            self.rects,\n",
        "            direction = RIGHT,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def compute_area_under_graph(self):\n",
        "        formula, formula_with_R = formulas = [\n",
        "            self.get_area_formula(R)\n",
        "            for R in (\"3\", \"R\")\n",
        "        ]\n",
        "        for mob in formulas:\n",
        "            mob.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        brace = Brace(self.rects, RIGHT)\n",
        "        height_label = brace.get_text(\"$2\\\\pi \\\\cdot 3$\")\n",
        "        height_label_with_R = brace.get_text(\"$2\\\\pi \\\\cdot R$\")\n",
        "        base_line = Line(\n",
        "            self.coords_to_point(0, 0),\n",
        "            self.coords_to_point(3, 0),\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        fresh_rings = self.get_rings(dR = 0.025)\n",
        "        fresh_rings.set_stroke(width = 0)\n",
        "        self.radius_label.restore()\n",
        "        VGroup(\n",
        "            fresh_rings, self.radius_group\n",
        "        ).to_corner(UP+LEFT, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(formula.top_line, run_time = 2))\n",
        "        self.play(FocusOn(base_line))\n",
        "        self.play(ShowCreation(base_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(height_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FocusOn(formula))\n",
        "        self.play(Write(formula.mid_line))\n",
        "        self.wait()\n",
        "        self.play(Write(formula.bottom_line))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.ghost_rings,\n",
        "            self.ring_sum.tex_mobs\n",
        "        ])))\n",
        "        self.play(*list(map(FadeIn, [fresh_rings, self.radius_group])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(formula, formula_with_R),\n",
        "            Transform(height_label, height_label_with_R),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.fresh_rings = fresh_rings\n",
        "\n",
        "    def show_circle_unwrapping(self):\n",
        "        rings = self.fresh_rings\n",
        "        rings.rotate(np.pi)\n",
        "        rings.submobjects.reverse()\n",
        "        ghost_rings = rings.copy()\n",
        "        ghost_rings.set_fill(opacity = 0.25)\n",
        "        self.add(ghost_rings, rings, self.radius_group)\n",
        "\n",
        "        unwrapped = VGroup(*[\n",
        "            self.get_unwrapped(ring, to_edge = None)\n",
        "            for ring in rings\n",
        "        ])\n",
        "        unwrapped.stretch_to_fit_height(1)\n",
        "        unwrapped.stretch_to_fit_width(2)\n",
        "        unwrapped.move_to(ORIGIN, DOWN)\n",
        "        unwrapped.apply_function(\n",
        "            lambda p : np.dot(p, \n",
        "                np.array([[1, 0, 0], [-1, 1, 0], [0, 0, 1]])\n",
        "            ),\n",
        "            maintain_smoothness = False\n",
        "        )\n",
        "        unwrapped.rotate(np.pi/2)\n",
        "        unwrapped.replace(self.rects, stretch = True)\n",
        "\n",
        "        self.play(self.rects.fade, 0.8)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                rings, unwrapped,\n",
        "                run_time = 5,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            Animation(self.radius_group)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_ring_sum(self, rings):\n",
        "        arranged_group = VGroup()\n",
        "        tex_mobs = VGroup()\n",
        "        for ring in rings:\n",
        "            ring.generate_target()\n",
        "            ring.target.set_stroke(width = 0)\n",
        "\n",
        "        for ring in rings[:self.num_rings_in_ring_sum_start]:\n",
        "            plus = OldTex(\"+\")\n",
        "            arranged_group.add(ring.target)\n",
        "            arranged_group.add(plus)\n",
        "            tex_mobs.add(plus)\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        plus = OldTex(\"+\")\n",
        "        arranged_group.add(dots, plus)\n",
        "        tex_mobs.add(dots, plus)\n",
        "        last_ring = rings[-1]\n",
        "\n",
        "        arranged_group.add(last_ring.target)\n",
        "        arranged_group.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        arranged_group.set_height(FRAME_HEIGHT-1)\n",
        "        arranged_group.to_corner(DOWN+LEFT, buff = MED_SMALL_BUFF)\n",
        "        for mob in tex_mobs:\n",
        "            mob.scale(0.7)\n",
        "\n",
        "        middle_rings = rings[self.num_rings_in_ring_sum_start:-1]\n",
        "        alphas = np.linspace(0, 1, len(middle_rings))\n",
        "        for ring, alpha in zip(middle_rings, alphas):\n",
        "            ring.target.set_fill(opacity = 0)\n",
        "            ring.target.move_to(interpolate(\n",
        "                dots.get_left(), last_ring.target.get_center(), alpha\n",
        "            ))\n",
        "\n",
        "        draw_ring_sum_anims = [Write(tex_mobs)]\n",
        "        draw_ring_sum_anims += [\n",
        "            MoveToTarget(\n",
        "                ring,\n",
        "                run_time = 3,\n",
        "                path_arc = -np.pi/3,\n",
        "                rate_func = squish_rate_func(smooth, alpha, alpha+0.8)\n",
        "            )\n",
        "            for ring, alpha in zip(rings, np.linspace(0, 0.2, len(rings)))\n",
        "        ]\n",
        "        draw_ring_sum_anims.append(FadeOut(self.radius_group))\n",
        "        \n",
        "        ring_sum = VGroup(rings, tex_mobs)\n",
        "        ring_sum.rings = VGroup(*[r.target for r in rings])\n",
        "        ring_sum.tex_mobs = tex_mobs\n",
        "        \n",
        "        return ring_sum, draw_ring_sum_anims\n",
        "\n",
        "    def get_area_formula(self, R):\n",
        "        formula = OldTex(\n",
        "            \"\\\\text{Area}\", \"&= \\\\frac{1}{2}\", \"b\", \"h\",\n",
        "            \"\\\\\\\\ &=\", \"\\\\frac{1}{2}\", \"(%s)\"%R, \"(2\\\\pi \\\\cdot %s)\"%R,\n",
        "            \"\\\\\\\\ &=\", \"\\\\pi \", \"%s\"%R, \"^2\"\n",
        "            \n",
        "        )\n",
        "        formula.set_color_by_tex(\"b\", GREEN, substring = False)\n",
        "        formula.set_color_by_tex(\"h\", RED, substring = False)\n",
        "        formula.set_color_by_tex(\"%s\"%R, GREEN)\n",
        "        formula.set_color_by_tex(\"(2\\\\pi \", RED)\n",
        "        formula.set_color_by_tex(\"(2\\\\pi \", RED)\n",
        "        formula.scale(0.8)\n",
        "\n",
        "        formula.top_line = VGroup(*formula[:4])\n",
        "        formula.mid_line = VGroup(*formula[4:8])\n",
        "        formula.bottom_line = VGroup(*formula[8:])\n",
        "        return formula\n",
        "\n",
        "class ThinkLikeAMathematician(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        pi_R_squraed = OldTex(\"\\\\pi\", \"R\", \"^2\")\n",
        "        pi_R_squraed.set_color_by_tex(\"R\", YELLOW)\n",
        "        pi_R_squraed.move_to(self.get_students(), UP)\n",
        "        pi_R_squraed.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            pi_R_squraed.shift, 2*UP,\n",
        "            pi_R_squraed.set_fill, None, 1\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = self.teacher.eyes,\n",
        "            added_anims = [PiCreatureSays(\n",
        "                self.teacher, \"But why did \\\\\\\\ that work?\"\n",
        "            )]\n",
        "        )\n",
        "        self.play(FadeOut(pi_R_squraed))\n",
        "        self.look_at(2*UP+4*LEFT)\n",
        "        self.wait(5)\n",
        "\n",
        "class TwoThingsToNotice(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Two things to \\\\\\\\ note about\",\n",
        "            \"$dr$\",\n",
        "        )\n",
        "        words.set_color_by_tex(\"dr\", GREEN)\n",
        "        self.teacher_says(words, run_time = 1)\n",
        "        self.wait(3)\n",
        "\n",
        "class RecapCircleSolution(GraphRectangles, ReconfigurableScene):\n",
        "    def setup(self):\n",
        "        GraphRectangles.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.break_up_circle()\n",
        "        self.show_sum()\n",
        "        self.dr_indicates_spacing()\n",
        "        self.smaller_dr()\n",
        "        self.show_riemann_sum()\n",
        "        self.limiting_riemann_sum()\n",
        "        self.full_precision()\n",
        "\n",
        "    def break_up_circle(self):\n",
        "        self.remove(self.circle)\n",
        "        rings = self.get_rings()\n",
        "        rings.set_stroke(BLACK, 1)\n",
        "        ring_sum, draw_ring_sum_anims = self.get_ring_sum(rings)\n",
        "\n",
        "        hard_problem = OldTexText(\"Hard problem\")\n",
        "        down_arrow = OldTex(\"\\\\Downarrow\")\n",
        "        sum_words = OldTexText(\"Sum of many \\\\\\\\ small values\")\n",
        "        integral_condition = VGroup(hard_problem, down_arrow, sum_words)\n",
        "        integral_condition.arrange(DOWN)\n",
        "        integral_condition.scale(0.8)\n",
        "        integral_condition.to_corner(UP+RIGHT)\n",
        "        \n",
        "        self.add(rings, self.radius_group)\n",
        "        self.play(FadeIn(\n",
        "            integral_condition, \n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*draw_ring_sum_anims)\n",
        "\n",
        "        self.rings = rings\n",
        "        self.integral_condition = integral_condition\n",
        "\n",
        "    def show_sum(self):\n",
        "        visible_rings = [ring for ring in self.rings if ring.get_fill_opacity() > 0]\n",
        "        radii = self.dR*np.arange(len(visible_rings))\n",
        "        radii[-1] = 3-self.dR\n",
        "\n",
        "        radial_lines = VGroup()\n",
        "        for ring in visible_rings:\n",
        "            radius_line = Line(ORIGIN, ring.R*RIGHT, color = YELLOW)\n",
        "            radius_line.rotate(np.pi/4)\n",
        "            radius_line.shift(ring.get_center())\n",
        "            radial_lines.add(radius_line)\n",
        "\n",
        "        approximations = VGroup()\n",
        "        for ring, radius in zip(visible_rings, radii):\n",
        "            label = OldTex(\n",
        "                \"\\\\approx\", \"2\\\\pi\", \n",
        "                \"(%s)\"%str(radius), \"(%s)\"%str(self.dR)\n",
        "            )\n",
        "            label[2].set_color(YELLOW)\n",
        "            label[3].set_color(GREEN)\n",
        "            label.scale(0.75)\n",
        "            label.next_to(ring, RIGHT)\n",
        "            approximations.add(label)\n",
        "        approximations[-1].shift(UP+0.5*LEFT)\n",
        "        area_label = OldTex(\"2\\\\pi\", \"r\", \"\\\\, dr\")\n",
        "        area_label.set_color_by_tex(\"r\", YELLOW)\n",
        "        area_label.set_color_by_tex(\"dr\", GREEN)\n",
        "        area_label.next_to(approximations, RIGHT, buff = 2*LARGE_BUFF)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                area_label.get_left(),\n",
        "                approximation.get_right(),\n",
        "                color = WHITE\n",
        "            )\n",
        "            for approximation in approximations\n",
        "        ])\n",
        "\n",
        "        self.play(Write(area_label))\n",
        "        self.play(\n",
        "            ShowCreation(arrows, lag_ratio = 0),\n",
        "            FadeIn(radial_lines),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    area_label.copy(),\n",
        "                    VGroup(*approximation[1:])\n",
        "                )\n",
        "                for approximation in approximations\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(*[\n",
        "            approximation[0]\n",
        "            for approximation in approximations\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "        self.area_label = area_label\n",
        "        self.area_arrows = arrows\n",
        "        self.approximations = approximations\n",
        "\n",
        "    def dr_indicates_spacing(self):\n",
        "        r_ticks = VGroup(*[\n",
        "            Line(\n",
        "                self.coords_to_point(r, -self.tick_height),\n",
        "                self.coords_to_point(r, self.tick_height),\n",
        "                color = YELLOW\n",
        "            )\n",
        "            for r in np.arange(0, 3, self.dR)\n",
        "        ])\n",
        "\n",
        "        index = int(0.75*len(r_ticks))\n",
        "        brace_ticks = VGroup(*r_ticks[index:index+2])\n",
        "        dr_brace = Brace(brace_ticks, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        dr = self.area_label.get_part_by_tex(\"dr\")\n",
        "        dr_copy = dr.copy()\n",
        "        circle = Circle().replace(dr)\n",
        "        circle.scale(1.3)\n",
        "\n",
        "        dr_num = self.approximations[0][-1]\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(FadeOut(circle))\n",
        "        self.play(ReplacementTransform(\n",
        "            dr.copy(), dr_num,\n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(self.x_axis))\n",
        "        self.play(Write(r_ticks, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(dr_brace),\n",
        "            dr_copy.next_to, dr_brace.copy(), UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.r_ticks = r_ticks\n",
        "        self.dr_brace_group = VGroup(dr_brace, dr_copy)\n",
        "\n",
        "    def smaller_dr(self):\n",
        "        self.transition_to_alt_config(dR = 0.05)\n",
        "\n",
        "    def show_riemann_sum(self):\n",
        "        graph = self.get_graph(lambda r : 2*np.pi*r)\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, \"2\\\\pi r\",\n",
        "            x_val = 2.5,\n",
        "            direction = UP+LEFT\n",
        "        )\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            graph,\n",
        "            x_min = 0, \n",
        "            x_max = 3,\n",
        "            dx = self.dR\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(self.y_axis, run_time = 2),\n",
        "            *list(map(FadeOut, [\n",
        "                self.approximations,\n",
        "                self.area_label,\n",
        "                self.area_arrows,\n",
        "                self.dr_brace_group,\n",
        "                self.r_ticks,\n",
        "            ]))\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.rings.copy(), rects,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Animation(self.x_axis),\n",
        "        )\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "        self.rects = rects\n",
        "\n",
        "    def limiting_riemann_sum(self):\n",
        "        thinner_rects_list = [\n",
        "            self.get_riemann_rectangles(\n",
        "                self.graph,\n",
        "                x_min = 0, \n",
        "                x_max = 3,\n",
        "                dx = 1./(10*2**n),\n",
        "                stroke_width = 1./(2**n),\n",
        "                start_color = self.rects[0].get_fill_color(),\n",
        "                end_color = self.rects[-1].get_fill_color(),\n",
        "            )\n",
        "            for n in range(1, 4)\n",
        "        ]\n",
        "\n",
        "        for new_rects in thinner_rects_list:\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    self.rects, new_rects, \n",
        "                    lag_ratio = 0.5,\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                Animation(self.axes),\n",
        "                Animation(self.graph),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def full_precision(self):\n",
        "        words = OldTexText(\"Area under \\\\\\\\ a graph\")\n",
        "        group = VGroup(OldTex(\"\\\\Downarrow\"), words)\n",
        "        group.arrange(DOWN)\n",
        "        group.set_color(YELLOW)\n",
        "        group.scale(0.8)\n",
        "        group.next_to(self.integral_condition, DOWN)\n",
        "\n",
        "        arc = Arc(start_angle = 2*np.pi/3, angle = 2*np.pi/3)\n",
        "        arc.scale(2)\n",
        "        arc.add_tip()\n",
        "        arc.add(arc[1].copy().rotate(np.pi, RIGHT))\n",
        "        arc_next_to_group = VGroup(\n",
        "            self.integral_condition[0][0],\n",
        "            words[0]\n",
        "        )\n",
        "        arc.set_height(\n",
        "            arc_next_to_group.get_height()-MED_LARGE_BUFF\n",
        "        )\n",
        "        arc.next_to(arc_next_to_group, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(group))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arc))\n",
        "        self.wait()\n",
        "\n",
        "class ExampleIntegralProblems(PiCreatureScene, GraphScene):\n",
        "    CONFIG = {\n",
        "        \"dt\" : 0.2,\n",
        "        \"t_max\" : 7,\n",
        "        \"x_max\" : 8,\n",
        "        \"y_axis_height\" : 5.5,\n",
        "        \"x_axis_label\" : \"$t$\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"graph_origin\" : 3*DOWN + 4.5*LEFT\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.write_integral_condition()\n",
        "        self.show_car()\n",
        "        self.show_graph()\n",
        "        self.let_dt_approach_zero()\n",
        "        self.show_confusion()\n",
        "\n",
        "    def write_integral_condition(self):\n",
        "        words = OldTexText(\n",
        "            \"Hard problem $\\\\Rightarrow$ Sum of many small values\"\n",
        "        )\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.words = words\n",
        "\n",
        "    def show_car(self):\n",
        "        car = Car()\n",
        "        start, end = 3*LEFT+UP, 5*RIGHT+UP\n",
        "        car.move_to(start)\n",
        "\n",
        "        line = Line(start, end)\n",
        "        tick_height = MED_SMALL_BUFF\n",
        "        ticks = VGroup(*[\n",
        "            Line(\n",
        "                p+tick_height*UP/2,\n",
        "                p+tick_height*DOWN/2,\n",
        "                color = YELLOW,\n",
        "                stroke_width = 2\n",
        "            )\n",
        "            for t in np.arange(0, self.t_max, self.dt)\n",
        "            for p in [\n",
        "                line.point_from_proportion(smooth(t/self.t_max))\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        index = int(len(ticks)/2)\n",
        "        brace_ticks = VGroup(*ticks[index:index+2])\n",
        "        brace = Brace(brace_ticks, UP)\n",
        "        v_dt = OldTex(\"v(t)\", \"dt\")\n",
        "        v_dt.next_to(brace, UP, SMALL_BUFF)\n",
        "        v_dt.set_color(YELLOW)\n",
        "        v_dt_brace_group = VGroup(brace, v_dt)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(car),\n",
        "            self.pi_creature.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(\n",
        "            MoveCar(car, end),\n",
        "            FadeIn(\n",
        "                ticks, \n",
        "                lag_ratio=1,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            ShowCreation(line),\n",
        "            FadeIn(\n",
        "                v_dt_brace_group,\n",
        "                rate_func = squish_rate_func(smooth, 0.6, 0.8)\n",
        "            ),\n",
        "            run_time = self.t_max\n",
        "        )\n",
        "        self.wait()\n",
        "        for mob in v_dt:\n",
        "            self.play(Indicate(mob))\n",
        "            self.wait(2)\n",
        "\n",
        "        self.v_dt_brace_group = v_dt_brace_group\n",
        "        self.line = line\n",
        "        self.ticks = ticks\n",
        "        self.car = car\n",
        "\n",
        "    def show_graph(self):\n",
        "        self.setup_axes()\n",
        "        self.remove(self.axes)\n",
        "        s_graph = self.get_graph(\n",
        "            lambda t : 1.8*self.y_max*smooth(t/self.t_max)\n",
        "        )\n",
        "        v_graph = self.get_derivative_graph(s_graph)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            v_graph,\n",
        "            x_min = 0, \n",
        "            x_max = self.t_max,\n",
        "            dx = self.dt\n",
        "        )\n",
        "        rects.set_fill(opacity = 0.5)\n",
        "        pre_rects = rects.copy()\n",
        "        pre_rects.rotate(-np.pi/2)\n",
        "        for index, pre_rect in enumerate(pre_rects):\n",
        "            ti1 = len(self.ticks)*index/len(pre_rects)\n",
        "            ti2 = min(ti1+1, len(self.ticks)-1)\n",
        "            tick_pair = VGroup(self.ticks[ti1], self.ticks[ti2])\n",
        "            pre_rect.stretch_to_fit_width(tick_pair.get_width())\n",
        "            pre_rect.move_to(tick_pair)\n",
        "\n",
        "        special_rect = rects[int(0.6*len(rects))]\n",
        "        brace = Brace(special_rect, LEFT, buff = 0)\n",
        "\n",
        "        v_dt_brace_group_copy = self.v_dt_brace_group.copy()\n",
        "        start_brace, (v_t, dt) = v_dt_brace_group_copy\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                pre_rects, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Animation(self.ticks)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                pre_rects, rects,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Animation(self.ticks),\n",
        "            Write(self.axes, run_time = 1)\n",
        "        )\n",
        "        self.play(ShowCreation(v_graph))\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            v_t.next_to, brace, LEFT, SMALL_BUFF,\n",
        "            dt.next_to, special_rect, DOWN,\n",
        "            special_rect.set_fill, None, 1,\n",
        "            ReplacementTransform(start_brace, brace),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.v_graph = v_graph\n",
        "        self.rects = rects\n",
        "        self.v_dt_brace_group_copy = v_dt_brace_group_copy\n",
        "\n",
        "    def let_dt_approach_zero(self):\n",
        "        thinner_rects_list = [\n",
        "            self.get_riemann_rectangles(\n",
        "                self.v_graph,\n",
        "                x_min = 0,\n",
        "                x_max = self.t_max,\n",
        "                dx = self.dt/(2**n),\n",
        "                stroke_width = 1./(2**n)\n",
        "            )\n",
        "            for n in range(1, 4)\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            self.rects.set_fill, None, 1,\n",
        "            Animation(self.x_axis),\n",
        "            FadeOut(self.v_dt_brace_group_copy),\n",
        "        )\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        for thinner_rects in thinner_rects_list:\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    self.rects, thinner_rects,\n",
        "                    run_time = 2,\n",
        "                    lag_ratio = 0.5\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_confusion(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.to_edge(LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, self.rects\n",
        "        )\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"confused\",\n",
        "            self.pi_creature.look_at, randy.eyes\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class MathematicianPonderingAreaUnderDifferentCurves(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_left_hand\",\n",
        "            self.pi_creature.look, UP+LEFT\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "            self.pi_creature.look, UP+RIGHT\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look, UP+LEFT\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Randolph(color = BLUE_C)\n",
        "        self.pi_creature.to_edge(DOWN)\n",
        "        return self.pi_creature\n",
        "\n",
        "class AreaUnderParabola(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_max\" : 4,\n",
        "        \"x_labeled_nums\" : list(range(-1, 5)),\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 15,\n",
        "        \"y_tick_frequency\" : 2.5,\n",
        "        \"y_labeled_nums\" : list(range(5, 20, 5)),\n",
        "        \"n_rect_iterations\" : 6,\n",
        "        \"default_right_x\" : 3,\n",
        "        \"func\" : lambda x : x**2,\n",
        "        \"graph_label_tex\" : \"x^2\",\n",
        "        \"graph_label_x_val\" : 3.8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.show_graph()\n",
        "        self.show_area()\n",
        "        self.ask_about_area()\n",
        "        self.show_confusion()\n",
        "        self.show_variable_endpoint()\n",
        "        self.name_integral()\n",
        "\n",
        "    def show_graph(self):\n",
        "        graph = self.get_graph(self.func)\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, self.graph_label_tex, \n",
        "            direction = LEFT,\n",
        "            x_val = self.graph_label_x_val,\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "\n",
        "    def show_area(self):\n",
        "        dx_list = [0.25/(2**n) for n in range(self.n_rect_iterations)]\n",
        "        rect_lists = [\n",
        "            self.get_riemann_rectangles(\n",
        "                self.graph,\n",
        "                x_min = 0,\n",
        "                x_max = self.default_right_x,\n",
        "                dx = dx,\n",
        "                stroke_width = 4*dx,\n",
        "            )\n",
        "            for dx in dx_list\n",
        "        ]\n",
        "        rects = rect_lists[0]\n",
        "        foreground_mobjects = [self.axes, self.graph]\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(\n",
        "                rects,\n",
        "                run_time = 2,\n",
        "                rate_func = smooth,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            *list(map(Animation, foreground_mobjects))\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_rects in rect_lists[1:]:\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    rects, new_rects,\n",
        "                    lag_ratio = 0.5,\n",
        "                ), \n",
        "                *list(map(Animation, foreground_mobjects))\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.rects = rects\n",
        "        self.dx = dx_list[-1]\n",
        "        self.foreground_mobjects = foreground_mobjects\n",
        "\n",
        "    def ask_about_area(self):\n",
        "        rects = self.rects\n",
        "        question = OldTexText(\"Area?\")\n",
        "        question.move_to(rects.get_top(), DOWN)\n",
        "        mid_rect = rects[2*len(rects)/3]\n",
        "        arrow = Arrow(question.get_bottom(), mid_rect.get_center())\n",
        "\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                FRAME_HEIGHT*UP, ORIGIN,\n",
        "                color = RED\n",
        "            ).move_to(self.coords_to_point(x, 0), DOWN)\n",
        "            for x in (0, self.default_right_x)\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_lines, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.foreground_mobjects += [question, arrow]\n",
        "        self.question = question\n",
        "        self.question_arrow = arrow\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def show_confusion(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"confused\",\n",
        "            morty.look_at, self.question,\n",
        "        )\n",
        "        self.play(morty.look_at, self.rects.get_bottom())\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.look_at, self.question)\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.play(FadeOut(morty))\n",
        "\n",
        "    def show_variable_endpoint(self):\n",
        "        triangle = RegularPolygon(\n",
        "            n = 3,\n",
        "            start_angle = np.pi/2,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        triangle.set_height(0.25)\n",
        "        triangle.move_to(self.v_lines[1].get_bottom(), UP)\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label.next_to(triangle, DOWN)\n",
        "        self.right_point_slider = VGroup(triangle, x_label)\n",
        "\n",
        "        A_func = OldTex(\"A(x)\")\n",
        "        A_func.move_to(self.question, DOWN)\n",
        "\n",
        "        self.play(FadeOut(self.x_axis.numbers))\n",
        "        self.x_axis.remove(*self.x_axis.numbers)\n",
        "        self.foreground_mobjects.remove(self.axes)\n",
        "        self.play(DrawBorderThenFill(self.right_point_slider))\n",
        "        self.move_right_point_to(2)\n",
        "        self.wait()\n",
        "        self.move_right_point_to(self.default_right_x)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(self.question, A_func))\n",
        "        self.wait()\n",
        "\n",
        "        self.A_func = A_func\n",
        "\n",
        "    def name_integral(self):\n",
        "        f_tex = \"$%s$\"%self.graph_label_tex\n",
        "        words = OldTexText(\"``Integral'' of \", f_tex)\n",
        "        words.set_color_by_tex(f_tex, self.graph_label.get_color())\n",
        "        brace = Brace(self.A_func, UP)\n",
        "        words.next_to(brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in 4, 2, self.default_right_x:\n",
        "            self.move_right_point_to(x, run_time = 2)\n",
        "\n",
        "        self.integral_words_group = VGroup(brace, words)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def move_right_point_to(self, target_x, **kwargs):\n",
        "        v_line = self.v_lines[1]\n",
        "        slider = self.right_point_slider\n",
        "        rects = self.rects\n",
        "        curr_x = self.x_axis.point_to_number(v_line.get_bottom())\n",
        "\n",
        "        group = VGroup(rects, v_line, slider)\n",
        "        def update_group(group, alpha):\n",
        "            rects, v_line, slider = group\n",
        "            new_x = interpolate(curr_x, target_x, alpha)\n",
        "            new_rects = self.get_riemann_rectangles(\n",
        "                self.graph,\n",
        "                x_min = 0,\n",
        "                x_max = new_x,\n",
        "                dx = self.dx*new_x/3.0,\n",
        "                stroke_width = rects[0].get_stroke_width(),\n",
        "            )\n",
        "            point = self.coords_to_point(new_x, 0)\n",
        "            v_line.move_to(point, DOWN)\n",
        "            slider.move_to(point, UP)\n",
        "            Transform(rects, new_rects).update(1)\n",
        "            return VGroup(rects, v_line, slider)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                group, update_group,\n",
        "                **kwargs\n",
        "            ),\n",
        "            *list(map(Animation, self.foreground_mobjects))\n",
        "        )\n",
        "\n",
        "class WhoCaresAboutArea(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        point = 2*RIGHT+3*UP\n",
        "\n",
        "        self.student_says(\n",
        "            \"Who cares!?!\", target_mode = \"angry\",\n",
        "        )\n",
        "        self.play(self.teacher.change_mode, \"guilty\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            self.teacher.look_at, point\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3, \n",
        "            look_at = point,\n",
        "            added_anims = [self.teacher.look_at, point]\n",
        "\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class PlayWithThisIdea(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Play with\", \"the\", \"thought!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait()\n",
        "        equation = OldTex(\"A(x)\", \"\\\\leftrightarrow\", \"x^2\")\n",
        "        equation.set_color_by_tex(\"x^2\", BLUE)\n",
        "        self.teacher_says(equation, target_mode = \"sassy\")\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class PlayingTowardsDADX(AreaUnderParabola, ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"n_rect_iterations\" : 6,\n",
        "        \"deriv_dx\" : 0.2,\n",
        "        \"graph_origin\" : 2.5*DOWN + 6*LEFT,\n",
        "    }\n",
        "    def setup(self):\n",
        "        AreaUnderParabola.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.fast_forward_to_end_of_previous_scene()\n",
        "\n",
        "        self.nudge_x()\n",
        "        self.describe_sliver()\n",
        "        self.shrink_dx()\n",
        "        self.write_dA_dx()\n",
        "        self.dA_remains_a_mystery()\n",
        "        self.write_example_inputs()\n",
        "        self.show_dA_dx_in_detail()\n",
        "        self.show_smaller_x()\n",
        "\n",
        "    def fast_forward_to_end_of_previous_scene(self):\n",
        "        self.force_skipping()\n",
        "        AreaUnderParabola.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def nudge_x(self):\n",
        "        shadow_rects = self.rects.copy()\n",
        "        shadow_rects.set_fill(BLACK, opacity = 0.5)\n",
        "\n",
        "        original_v_line = self.v_lines[1].copy()\n",
        "        right_v_lines = VGroup(original_v_line, self.v_lines[1])\n",
        "        curr_x = self.x_axis.point_to_number(original_v_line.get_bottom())\n",
        "\n",
        "        self.add(original_v_line)\n",
        "        self.foreground_mobjects.append(original_v_line)\n",
        "        self.move_right_point_to(curr_x + self.deriv_dx)\n",
        "        self.play(\n",
        "            FadeIn(shadow_rects), \n",
        "            *list(map(Animation, self.foreground_mobjects))\n",
        "        )\n",
        "\n",
        "        self.shadow_rects = shadow_rects\n",
        "        self.right_v_lines = right_v_lines\n",
        "\n",
        "    def describe_sliver(self):\n",
        "        dx_brace = Brace(self.right_v_lines, DOWN, buff = 0)\n",
        "        dx_label = dx_brace.get_text(\"$dx$\")\n",
        "        dx_group = VGroup(dx_brace, dx_label)\n",
        "\n",
        "        dA_rect = Rectangle(\n",
        "            width = self.right_v_lines.get_width(),\n",
        "            height = self.shadow_rects[-1].get_height(),\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.5,\n",
        "        ).move_to(self.right_v_lines, DOWN)\n",
        "        dA_label = OldTex(\"d\", \"A\")\n",
        "        dA_label.next_to(dA_rect, RIGHT, MED_LARGE_BUFF, UP)\n",
        "        dA_label.set_color(GREEN)\n",
        "        dA_arrow = Arrow(\n",
        "            dA_label.get_bottom()+MED_SMALL_BUFF*DOWN, \n",
        "            dA_rect.get_center(),\n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        difference_in_area = OldTexText(\n",
        "            \"d\", \"ifference in \", \"A\", \"rea\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        difference_in_area.set_color_by_tex(\"d\", GREEN)\n",
        "        difference_in_area.set_color_by_tex(\"A\", GREEN)\n",
        "        difference_in_area.scale(0.7)\n",
        "        difference_in_area.next_to(dA_label, UP, MED_SMALL_BUFF, LEFT)\n",
        "\n",
        "        side_brace = Brace(dA_rect, LEFT, buff = 0)\n",
        "        graph_label_copy = self.graph_label.copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.right_point_slider),\n",
        "            FadeIn(dx_group)\n",
        "        )\n",
        "        self.play(Indicate(dx_label))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(dA_arrow))\n",
        "        self.wait()\n",
        "        self.play(Write(dA_label, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(dA_label[0].copy(), difference_in_area[0]),\n",
        "            ReplacementTransform(dA_label[1].copy(), difference_in_area[2]),\n",
        "            *list(map(FadeIn, [difference_in_area[1], difference_in_area[3]]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(dA_rect), Animation(dA_arrow))\n",
        "        self.play(GrowFromCenter(side_brace))\n",
        "        self.play(\n",
        "            graph_label_copy.set_color, WHITE,\n",
        "            graph_label_copy.next_to, side_brace, LEFT, SMALL_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Indicate(dx_group))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(difference_in_area))\n",
        "\n",
        "        self.dx_group = dx_group\n",
        "        self.dA_rect = dA_rect\n",
        "        self.dA_label = dA_label\n",
        "        self.graph_label_copy = graph_label_copy\n",
        "\n",
        "    def shrink_dx(self, **kwargs):\n",
        "        self.transition_to_alt_config(\n",
        "            deriv_dx = 0.05,\n",
        "            transformation_kwargs = {\"run_time\" : 2},\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def write_dA_dx(self):\n",
        "        f_tex = self.graph_label_tex\n",
        "        equation = OldTex(\"dA\", \"\\\\approx\", f_tex, \"dx\")\n",
        "        equation.to_edge(RIGHT).shift(3*UP)\n",
        "        deriv_equation = OldTex(\n",
        "            \"{dA\", \"\\\\over \\\\,\", \"dx}\", \"\\\\approx\", f_tex\n",
        "        )\n",
        "        deriv_equation.move_to(equation, UP+LEFT)\n",
        "\n",
        "        for tex_mob in equation, deriv_equation:\n",
        "            tex_mob.set_color_by_tex(\n",
        "                \"dA\", self.dA_label.get_color()\n",
        "            )\n",
        "\n",
        "        dA = VGroup(self.dA_label[0][0], self.dA_label[1][0])\n",
        "        x_squared = self.graph_label_copy\n",
        "        dx = self.dx_group[1]\n",
        "\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mob.copy(),\n",
        "                equation.get_part_by_tex(tex),\n",
        "                run_time = 2\n",
        "            )\n",
        "            for mob, tex in [(x_squared, f_tex), (dx, \"dx\"), (dA, \"dA\")]\n",
        "        ])\n",
        "        self.play(Write(equation.get_part_by_tex(\"approx\")))\n",
        "        self.wait()\n",
        "        for tex, mob in (f_tex, x_squared), (\"dx\", dx):\n",
        "            self.play(*list(map(Indicate, [\n",
        "                equation.get_part_by_tex(tex),\n",
        "                mob\n",
        "            ])))\n",
        "            self.wait(2)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                equation.get_part_by_tex(tex),\n",
        "                deriv_equation.get_part_by_tex(tex),\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for tex in (\"dA\", \"approx\", f_tex, \"dx\")\n",
        "        ] + [\n",
        "            Write(deriv_equation.get_part_by_tex(\"over\"))\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.shrink_dx(return_to_original_configuration = False)\n",
        "        self.wait()\n",
        "\n",
        "        self.deriv_equation = deriv_equation\n",
        "\n",
        "    def dA_remains_a_mystery(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.look_at(self.A_func)\n",
        "\n",
        "        A_circle, dA_circle = [\n",
        "            Circle(color = color).replace(\n",
        "                mob, stretch = True\n",
        "            ).scale(1.5)\n",
        "            for mob, color in [(self.A_func, RED), (self.deriv_equation, GREEN)]\n",
        "        ]\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(A_circle, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.integral_words_group),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(A_circle),\n",
        "            randy.change_mode, \"confused\"\n",
        "        )\n",
        "        self.play(Write(q_marks, run_time = 2))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change_mode, \"surprised\",\n",
        "            randy.look_at, dA_circle,\n",
        "            ReplacementTransform(A_circle, dA_circle)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [randy, q_marks, dA_circle])))\n",
        "\n",
        "    def write_example_inputs(self):\n",
        "        d = self.default_right_x\n",
        "        three = OldTex(\"x =\", \"%d\"%d)\n",
        "        three_plus_dx = OldTex(\"x = \", \"%d.001\"%d)\n",
        "        labels_lines_vects = list(zip(\n",
        "            [three, three_plus_dx],\n",
        "            self.right_v_lines,\n",
        "            [LEFT, RIGHT]\n",
        "        ))\n",
        "\n",
        "        for label, line, vect in labels_lines_vects:\n",
        "            point = line.get_bottom()\n",
        "            label.next_to(point, DOWN+vect, MED_SMALL_BUFF)\n",
        "            label.shift(LARGE_BUFF*vect)\n",
        "            label.arrow = Arrow(\n",
        "                label, point,\n",
        "                buff = SMALL_BUFF,\n",
        "                color = WHITE,\n",
        "                tip_length = 0.15\n",
        "            )\n",
        "            line_copy = line.copy()\n",
        "            line_copy.set_color(YELLOW)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(label),\n",
        "                FadeIn(label.arrow),\n",
        "                ShowCreation(line_copy)\n",
        "            )\n",
        "            self.play(FadeOut(line_copy))\n",
        "        self.wait()\n",
        "\n",
        "        self.three = three \n",
        "        self.three_plus_dx = three_plus_dx\n",
        "\n",
        "    def show_dA_dx_in_detail(self):\n",
        "        d = self.default_right_x\n",
        "        expression = OldTex(\n",
        "            \"{A(\", \"%d.001\"%d, \") \", \"-A(\", \"%d\"%d, \")\", \n",
        "            \"\\\\over \\\\,\", \"0.001}\", \n",
        "            \"\\\\approx\", \"%d\"%d, \"^2\"\n",
        "        )\n",
        "        expression.scale(0.9)\n",
        "        expression.next_to(\n",
        "            self.deriv_equation, DOWN, MED_LARGE_BUFF\n",
        "        )\n",
        "        expression.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.three_plus_dx.get_part_by_tex(\"%d.001\"%d).copy(),\n",
        "                expression.get_part_by_tex(\"%d.001\"%d)\n",
        "            ),\n",
        "            Write(VGroup(\n",
        "                expression.get_part_by_tex(\"A(\"),\n",
        "                expression.get_part_by_tex(\")\"),\n",
        "            )),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.three.get_part_by_tex(\"%d\"%d).copy(),\n",
        "                expression.get_part_by_tex(\"%d\"%d, substring = False)\n",
        "            ),\n",
        "            Write(VGroup(\n",
        "                expression.get_part_by_tex(\"-A(\"),\n",
        "                expression.get_parts_by_tex(\")\")[1],\n",
        "            )),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(expression.get_part_by_tex(\"over\")),\n",
        "            ReplacementTransform(\n",
        "                expression.get_part_by_tex(\"%d.001\"%d).copy(),\n",
        "                expression.get_part_by_tex(\"0.001\"),\n",
        "            )\n",
        "            \n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(expression.get_part_by_tex(\"approx\")),\n",
        "            ReplacementTransform(\n",
        "                self.graph_label_copy.copy(),\n",
        "                VGroup(*expression[-2:]),\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_smaller_x(self):\n",
        "        self.transition_to_alt_config(\n",
        "            default_right_x = 2,\n",
        "            deriv_dx = 0.04,\n",
        "            transformation_kwargs = {\"run_time\" : 2}\n",
        "        )\n",
        "\n",
        "class AlternateAreaUnderCurve(PlayingTowardsDADX):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda x : (x-2)**3 - 3*(x-2) + 6,\n",
        "        \"graph_label_tex\" : \"f(x)\",\n",
        "        \"deriv_dx\" : 0.1,\n",
        "        \"x_max\" : 5,\n",
        "        \"x_axis_width\" : 11,\n",
        "        \"graph_label_x_val\" : 4.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        #Superclass parts to skip\n",
        "        self.force_skipping()\n",
        "        self.setup_axes()\n",
        "        self.show_graph()\n",
        "        self.show_area()\n",
        "        self.ask_about_area()\n",
        "        self.show_confusion()\n",
        "\n",
        "        #Superclass parts to show\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.show_variable_endpoint()\n",
        "        self.name_integral()\n",
        "        self.nudge_x()\n",
        "        self.describe_sliver()\n",
        "        self.write_dA_dx()\n",
        "\n",
        "        #New animations\n",
        "        self.approximation_improves_for_smaller_dx()\n",
        "        self.name_derivative()\n",
        "\n",
        "    def approximation_improves_for_smaller_dx(self):\n",
        "        color = YELLOW\n",
        "        approx = self.deriv_equation.get_part_by_tex(\"approx\")\n",
        "        dx_to_zero_words = OldTexText(\n",
        "            \"Gets better \\\\\\\\ as\", \n",
        "            \"$dx \\\\to 0$\"\n",
        "        )\n",
        "        dx_to_zero_words.set_color_by_tex(\"dx\", color)\n",
        "        dx_to_zero_words.next_to(approx, DOWN, 1.5*LARGE_BUFF)\n",
        "        arrow = Arrow(dx_to_zero_words, approx, color = color)\n",
        "\n",
        "        self.play(\n",
        "            approx.set_color, color,\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(dx_to_zero_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.transition_to_alt_config(\n",
        "            deriv_dx = self.deriv_dx/4.0,\n",
        "            transformation_kwargs = {\"run_time\" : 2}\n",
        "        )\n",
        "\n",
        "        self.dx_to_zero_words = dx_to_zero_words\n",
        "        self.dx_to_zero_words_arrow = arrow\n",
        "\n",
        "    def name_derivative(self):\n",
        "        deriv_words = OldTexText(\"``Derivative'' of $A$\")\n",
        "        deriv_words.scale(0.9)\n",
        "        deriv_words.to_edge(UP+RIGHT)\n",
        "        moving_group = VGroup(\n",
        "            self.deriv_equation, \n",
        "            self.dx_to_zero_words,\n",
        "            self.dx_to_zero_words_arrow,\n",
        "        )\n",
        "        moving_group.generate_target()\n",
        "        moving_group.target.next_to(deriv_words, DOWN, LARGE_BUFF)\n",
        "        moving_group.target.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(deriv_words),\n",
        "            MoveToTarget(moving_group)\n",
        "        )\n",
        "\n",
        "        dA_dx = VGroup(*self.deriv_equation[:3])\n",
        "        box = Rectangle(color = GREEN)\n",
        "        box.replace(dA_dx, stretch = True)\n",
        "        box.scale(1.3)\n",
        "        brace = Brace(box, UP)\n",
        "        faders = VGroup(\n",
        "            self.dx_to_zero_words[0],\n",
        "            self.dx_to_zero_words_arrow\n",
        "        )\n",
        "        dx_to_zero = self.dx_to_zero_words[1]\n",
        "\n",
        "        self.play(*list(map(FadeIn, [box, brace])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(faders),\n",
        "            dx_to_zero.next_to, box, DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ########\n",
        "    def show_smaller_x(self):\n",
        "        return\n",
        "\n",
        "    def shrink_dx(self, **kwargs):\n",
        "        return\n",
        "\n",
        "class NextVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(1.5*FRAME_Y_RADIUS)\n",
        "        titles = [\n",
        "            OldTexText(\"Chapter %d:\"%d, s)\n",
        "            for d, s in [\n",
        "                (2, \"The paradox of the derivative\"),\n",
        "                (3, \"Derivative formulas through geometry\"),\n",
        "            ]\n",
        "        ]\n",
        "        for title in titles:\n",
        "            title.to_edge(UP)\n",
        "        rect.next_to(VGroup(*titles), DOWN)\n",
        "\n",
        "        self.add(titles[0])\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(3)\n",
        "        self.play(Transform(*titles))\n",
        "        self.wait(3)\n",
        "\n",
        "class ProblemSolvingTool(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            The derivative is a\n",
        "            problem-solving tool\n",
        "        \"\"\")\n",
        "        self.wait(3)\n",
        "\n",
        "class FundamentalTheorem(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Fundamental theorem of calculus\n",
        "        \"\"\")\n",
        "        words.to_edge(UP)\n",
        "        arrow = DoubleArrow(LEFT, RIGHT).shift(2*RIGHT)\n",
        "        deriv = OldTex(\n",
        "            \"{dA\", \"\\\\over \\\\,\", \"dx}\", \"=\", \"x^2\"\n",
        "        )\n",
        "        deriv.set_color_by_tex(\"dA\", GREEN)\n",
        "        deriv.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(Write(deriv))\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class NextVideos(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[0]\n",
        "        this_video.set_color(YELLOW)\n",
        "\n",
        "        self.add(series)\n",
        "        self.teacher_says(\n",
        "            \"That's a high-level view\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode = \"raise_right_hand\",\n",
        "                look_at = this_video,\n",
        "            ),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"pondering\", pi.look_at, this_video]\n",
        "                for pi in self.get_students()\n",
        "            ])\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look_at, series)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                video.shift, 0.5*video.get_height()*DOWN,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back, alpha, alpha+0.3\n",
        "                )\n",
        "            )\n",
        "            for video, alpha in zip(series, np.linspace(0, 0.7, len(series)))\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        student = self.get_students()[1]\n",
        "        self.remove(student)\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        self.add(student)\n",
        "        words = OldTexText(\"\"\"\n",
        "            You could have\n",
        "            invented this.\n",
        "        \"\"\")\n",
        "        words.next_to(student, UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(self.teacher.change_mode, \"plain\")\n",
        "        self.play(\n",
        "            everything.fade, 0.75,\n",
        "            student.change_mode, \"plain\"\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            student.look_at, words,\n",
        "        )\n",
        "        self.play(\n",
        "            student.change_mode, \"confused\",\n",
        "            student.look_at, words\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(student.change_mode, \"thinking\")\n",
        "        self.wait(4)\n",
        "\n",
        "class Chapter1PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Einar Johansen\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ],\n",
        "        \"patron_scale_val\" : 0.9\n",
        "    }\n",
        "\n",
        "class EndScreen(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Clicky stuffs\")\n",
        "        words.scale(1.5)\n",
        "        words.next_to(self.pi_creature, UP)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                words, \n",
        "                run_time = 2, \n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            self.pi_creature.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        mode_point_pairs = [\n",
        "            (\"raise_left_hand\", 5*LEFT+3*UP),\n",
        "            (\"raise_right_hand\", 5*RIGHT+3*UP),\n",
        "            (\"thinking\", 5*LEFT+2*DOWN),\n",
        "            (\"thinking\", 5*RIGHT+2*DOWN),\n",
        "            (\"thinking\", 5*RIGHT+2*DOWN),\n",
        "            (\"happy\", 5*LEFT+3*UP),\n",
        "            (\"raise_right_hand\", 5*RIGHT+3*UP),\n",
        "        ]\n",
        "        for mode, point in mode_point_pairs:\n",
        "            self.play(self.pi_creature.change, mode, point)\n",
        "            self.wait()\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Randolph()\n",
        "        self.pi_creature.shift(2*DOWN + 1.5*LEFT)\n",
        "        return self.pi_creature\n",
        "\n",
        "class Thumbnail(AlternateAreaUnderCurve):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"graph_origin\" : 2.4 * DOWN + 3 * LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.remove(*self.x_axis.numbers)\n",
        "        self.remove(*self.y_axis.numbers)\n",
        "        graph = self.get_graph(self.func)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            graph,\n",
        "            x_min = 0,\n",
        "            x_max = 4,\n",
        "            dx = 0.25,\n",
        "            start_color = BLUE_E,\n",
        "        )\n",
        "        words = OldTexText(\"\"\"\n",
        "            Could \\\\emph{you} invent\n",
        "            calculus?\n",
        "        \"\"\")\n",
        "        words.set_width(9)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(graph, rects, words)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}