{
    "topic": "The mathematical concept being demonstrated is the visualization of a pendulum's motion, specifically",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part1.shared_constructs import *\n",
        "from _2019.diffyq.part1.pendulum import Pendulum\n",
        "\n",
        "\n",
        "# TODO: Arguably separate the part showing many\n",
        "# configurations with the part showing just one.\n",
        "class VisualizeStates(Scene):\n",
        "    CONFIG = {\n",
        "        \"coordinate_plane_config\": {\n",
        "            \"y_line_frequency\": PI / 2,\n",
        "            # \"x_line_frequency\": PI / 2,\n",
        "            \"x_line_frequency\": 1,\n",
        "            \"y_axis_config\": {\n",
        "                # \"unit_size\": 1.75,\n",
        "                \"unit_size\": 1,\n",
        "            },\n",
        "            \"y_max\": 4,\n",
        "            \"faded_line_ratio\": 4,\n",
        "            \"background_line_style\": {\n",
        "                \"stroke_width\": 1,\n",
        "            },\n",
        "        },\n",
        "        \"little_pendulum_config\": {\n",
        "            \"length\": 1,\n",
        "            \"gravity\": 4.9,\n",
        "            \"weight_diameter\": 0.3,\n",
        "            \"include_theta_label\": False,\n",
        "            \"include_velocity_vector\": True,\n",
        "            \"angle_arc_config\": {\n",
        "                \"radius\": 0.2,\n",
        "            },\n",
        "            \"velocity_vector_config\": {\n",
        "                \"max_tip_length_to_length_ratio\": 0.35,\n",
        "                \"max_stroke_width_to_length_ratio\": 6,\n",
        "            },\n",
        "            \"velocity_vector_multiple\": 0.25,\n",
        "            \"max_velocity_vector_length_to_length_ratio\": 0.8,\n",
        "        },\n",
        "        \"big_pendulum_config\": {\n",
        "            \"length\": 1.6,\n",
        "            \"gravity\": 4.9,\n",
        "            \"damping\": 0.2,\n",
        "            \"weight_diameter\": 0.3,\n",
        "            \"include_velocity_vector\": True,\n",
        "            \"angle_arc_config\": {\n",
        "                \"radius\": 0.5,\n",
        "            },\n",
        "            \"initial_theta\": 80 * DEGREES,\n",
        "            \"omega\": -1,\n",
        "            \"set_theta_label_height_cap\": True,\n",
        "        },\n",
        "        \"n_thetas\": 11,\n",
        "        \"n_omegas\": 7,\n",
        "        # \"n_thetas\": 5,\n",
        "        # \"n_omegas\": 3,\n",
        "        \"initial_grid_wait_time\": 15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane()\n",
        "\n",
        "        simple = False\n",
        "        if simple:\n",
        "            self.add(self.plane)\n",
        "        else:\n",
        "            self.initialize_grid_of_states()\n",
        "            self.show_all_states_evolving()\n",
        "            self.show_grid_of_states_creation()\n",
        "            self.collapse_grid_into_points()\n",
        "        self.show_state_with_pair_of_numbers()\n",
        "        self.show_acceleration_dependence()\n",
        "        self.show_evolution_from_a_start_state()\n",
        "\n",
        "    def initialize_grid_of_states(self):\n",
        "        pendulums = VGroup()\n",
        "        rects = VGroup()\n",
        "        state_grid = VGroup()\n",
        "        thetas = self.get_initial_thetas()\n",
        "        omegas = self.get_initial_omegas()\n",
        "        for omega in omegas:\n",
        "            row = VGroup()\n",
        "            for theta in thetas:\n",
        "                rect = Rectangle(\n",
        "                    height=3,\n",
        "                    width=3,\n",
        "                    stroke_color=WHITE,\n",
        "                    stroke_width=2,\n",
        "                    fill_color=GREY_E,\n",
        "                    fill_opacity=1,\n",
        "                )\n",
        "                pendulum = Pendulum(\n",
        "                    initial_theta=theta,\n",
        "                    omega=omega,\n",
        "                    top_point=rect.get_center(),\n",
        "                    **self.little_pendulum_config,\n",
        "                )\n",
        "                pendulum.add_velocity_vector()\n",
        "                pendulums.add(pendulum)\n",
        "                rects.add(rect)\n",
        "                state = VGroup(rect, pendulum)\n",
        "                state.rect = rect\n",
        "                state.pendulum = pendulum\n",
        "                row.add(state)\n",
        "            row.arrange(RIGHT, buff=0)\n",
        "            state_grid.add(row)\n",
        "        state_grid.arrange(UP, buff=0)\n",
        "\n",
        "        state_grid.set_height(FRAME_HEIGHT)\n",
        "        state_grid.center()\n",
        "        state_grid.save_state(use_deepcopy=True)\n",
        "\n",
        "        self.state_grid = state_grid\n",
        "        self.pendulums = pendulums\n",
        "\n",
        "    def initialize_plane(self):\n",
        "        plane = self.plane = NumberPlane(\n",
        "            **self.coordinate_plane_config\n",
        "        )\n",
        "        plane.axis_labels = VGroup(\n",
        "            plane.get_x_axis_label(\n",
        "                \"\\\\theta\", RIGHT, UL, buff=SMALL_BUFF\n",
        "            ),\n",
        "            plane.get_y_axis_label(\n",
        "                \"\\\\dot \\\\theta\", UP, DR, buff=SMALL_BUFF\n",
        "            ).set_color(YELLOW),\n",
        "        )\n",
        "        for label in plane.axis_labels:\n",
        "            label.add_background_rectangle()\n",
        "        plane.add(plane.axis_labels)\n",
        "\n",
        "        plane.y_axis.add_numbers(direction=DL)\n",
        "\n",
        "        x_axis = plane.x_axis\n",
        "        label_texs = [\"\\\\pi \\\\over 2\", \"\\\\pi\", \"3\\\\pi \\\\over 2\", \"\\\\tau\"]\n",
        "        values = [PI / 2, PI, 3 * PI / 2, TAU]\n",
        "        x_axis.coordinate_labels = VGroup()\n",
        "        x_axis.add(x_axis.coordinate_labels)\n",
        "        for value, label_tex in zip(values, label_texs):\n",
        "            for u in [-1, 1]:\n",
        "                tex = label_tex\n",
        "                if u < 0:\n",
        "                    tex = \"-\" + tex\n",
        "                label = OldTex(tex)\n",
        "                label.scale(0.5)\n",
        "                if label.get_height() > 0.4:\n",
        "                    label.set_height(0.4)\n",
        "                point = x_axis.number_to_point(u * value)\n",
        "                label.next_to(point, DR, SMALL_BUFF)\n",
        "                x_axis.coordinate_labels.add(label)\n",
        "        return plane\n",
        "\n",
        "    def show_all_states_evolving(self):\n",
        "        state_grid = self.state_grid\n",
        "        pendulums = self.pendulums\n",
        "\n",
        "        for pendulum in pendulums:\n",
        "            pendulum.start_swinging()\n",
        "\n",
        "        self.add(state_grid)\n",
        "        self.wait(self.initial_grid_wait_time)\n",
        "\n",
        "    def show_grid_of_states_creation(self):\n",
        "        self.remove(self.state_grid)\n",
        "        self.initialize_grid_of_states()  # Again\n",
        "        state_grid = self.state_grid\n",
        "\n",
        "        title = OldTexText(\"All states\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.all_states_title = title\n",
        "\n",
        "        state_grid.set_height(\n",
        "            FRAME_HEIGHT - title.get_height() - 2 * MED_SMALL_BUFF\n",
        "        )\n",
        "        state_grid.to_edge(DOWN, buff=0)\n",
        "\n",
        "        def place_at_top(state):\n",
        "            state.set_height(3)\n",
        "            state.center()\n",
        "            state.next_to(title, DOWN)\n",
        "\n",
        "        middle_row = state_grid[len(state_grid) // 2]\n",
        "        middle_row_copy = middle_row.deepcopy()\n",
        "        right_column_copy = VGroup(*[\n",
        "            row[-1] for row in state_grid\n",
        "        ]).deepcopy()\n",
        "\n",
        "        for state in it.chain(middle_row_copy, right_column_copy):\n",
        "            place_at_top(state)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(middle_row),\n",
        "            ShowIncreasingSubsets(middle_row_copy),\n",
        "            run_time=2,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(state_grid),\n",
        "            ShowIncreasingSubsets(right_column_copy),\n",
        "            run_time=2,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.remove(middle_row_copy)\n",
        "        self.remove(middle_row)\n",
        "        self.add(state_grid)\n",
        "        self.remove(right_column_copy)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                right_column_copy[-1],\n",
        "                state_grid[-1][-1],\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def collapse_grid_into_points(self):\n",
        "        state_grid = self.state_grid\n",
        "        plane = self.plane\n",
        "\n",
        "        dots = VGroup()\n",
        "        for row in state_grid:\n",
        "            for state in row:\n",
        "                dot = Dot(\n",
        "                    self.get_state_point(state.pendulum),\n",
        "                    radius=0.05,\n",
        "                    color=YELLOW,\n",
        "                    background_stroke_width=3,\n",
        "                    background_stroke_color=BLACK,\n",
        "                )\n",
        "                dot.state = state\n",
        "                dots.add(dot)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.remove(state_grid)\n",
        "        flat_state_group = VGroup(*it.chain(*state_grid))\n",
        "        flat_dot_group = VGroup(*it.chain(*dots))\n",
        "        self.clear()  # The nuclear option\n",
        "        self.play(\n",
        "            ShowCreation(plane),\n",
        "            FadeOut(self.all_states_title),\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(m1, m2)\n",
        "                for m1, m2 in zip(flat_state_group, flat_dot_group)\n",
        "            ], lag_ratio=0.1, run_time=4)\n",
        "        )\n",
        "        self.clear()  # Again, not sure why I need this\n",
        "        self.add(plane, dots)\n",
        "        self.wait()\n",
        "\n",
        "        self.state_dots = dots\n",
        "\n",
        "    def show_state_with_pair_of_numbers(self):\n",
        "        axis_labels = self.plane.axis_labels\n",
        "\n",
        "        state = self.get_flexible_state_picture()\n",
        "        dot = self.get_state_controlling_dot(state)\n",
        "        h_line = always_redraw(\n",
        "            lambda: self.get_tracking_h_line(dot.get_center())\n",
        "        )\n",
        "        v_line = always_redraw(\n",
        "            lambda: self.get_tracking_v_line(dot.get_center())\n",
        "        )\n",
        "\n",
        "        self.add(dot)\n",
        "        anims = [GrowFromPoint(state, dot.get_center())]\n",
        "        if hasattr(self, \"state_dots\"):\n",
        "            anims.append(FadeOut(self.state_dots))\n",
        "        self.play(*anims)\n",
        "\n",
        "        for line, label in zip([h_line, v_line], axis_labels):\n",
        "            # self.add(line, dot)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                ShowCreationThenFadeAround(label),\n",
        "                run_time=1\n",
        "            )\n",
        "        for vect in LEFT, 3 * UP:\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    dot.shift, vect,\n",
        "                    rate_func=there_and_back,\n",
        "                    run_time=2,\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "        for vect in 2 * LEFT, 3 * UP, 2 * RIGHT, 2 * DOWN:\n",
        "            self.play(dot.shift, vect, run_time=1.5)\n",
        "        self.wait()\n",
        "\n",
        "        self.state = state\n",
        "        self.state_dot = dot\n",
        "        self.h_line = h_line\n",
        "        self.v_line = v_line\n",
        "\n",
        "    def show_acceleration_dependence(self):\n",
        "        ode = get_ode()\n",
        "        thetas = ode.get_parts_by_tex(\"\\\\theta\")\n",
        "        thetas[0].set_color(RED)\n",
        "        thetas[1].set_color(YELLOW)\n",
        "        ode.move_to(\n",
        "            FRAME_WIDTH * RIGHT / 4 +\n",
        "            FRAME_HEIGHT * UP / 4,\n",
        "        )\n",
        "        ode.add_background_rectangle_to_submobjects()\n",
        "\n",
        "        self.play(Write(ode))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(ode))\n",
        "\n",
        "    def show_evolution_from_a_start_state(self):\n",
        "        state = self.state\n",
        "        dot = self.state_dot\n",
        "\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                dot,\n",
        "                about_point=dot.get_center() + UR,\n",
        "                rate_func=smooth,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show initial trajectory\n",
        "        state.pendulum.clear_updaters(recurse=False)\n",
        "        self.tie_dot_position_to_state(dot, state)\n",
        "        state.pendulum.start_swinging()\n",
        "        trajectory = self.get_evolving_trajectory(dot)\n",
        "        self.add(trajectory)\n",
        "        for x in range(20):\n",
        "            self.wait()\n",
        "\n",
        "        # Talk through start\n",
        "        trajectory.suspend_updating()\n",
        "        state.pendulum.end_swinging()\n",
        "        dot.clear_updaters()\n",
        "        self.tie_state_to_dot_position(state, dot)\n",
        "\n",
        "        alphas = np.linspace(0, 0.1, 1000)\n",
        "        index = np.argmin([\n",
        "            trajectory.point_from_proportion(a)[1]\n",
        "            for a in alphas\n",
        "        ])\n",
        "        alpha = alphas[index]\n",
        "        sub_traj = trajectory.copy()\n",
        "        sub_traj.suspend_updating()\n",
        "        sub_traj.pointwise_become_partial(trajectory, 0, alpha)\n",
        "        sub_traj.match_style(trajectory)\n",
        "        sub_traj.set_stroke(width=3)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(dot.move_to, sub_traj.get_start())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(sub_traj),\n",
        "            UpdateFromFunc(\n",
        "                dot, lambda d: d.move_to(sub_traj.get_end())\n",
        "            ),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on physical velocity vs. space position\n",
        "        v_vect = state.pendulum.velocity_vector\n",
        "        v_line_copy = self.v_line.copy()\n",
        "        v_line_copy.clear_updaters()\n",
        "        v_line_copy.set_stroke(PINK, 5)\n",
        "        td_label = self.plane.axis_labels[1]\n",
        "        y_axis_copy = self.plane.y_axis.copy()\n",
        "        y_axis_copy.submobjects = []\n",
        "        y_axis_copy.match_style(v_line_copy)\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(v_vect))\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(td_label),\n",
        "            ShowCreationThenFadeOut(y_axis_copy)\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeOut(v_line_copy))\n",
        "        self.wait()\n",
        "\n",
        "        # Abstract vs. physical\n",
        "        abstract = OldTexText(\"Abstract\")\n",
        "        abstract.add_background_rectangle()\n",
        "        abstract.scale(2)\n",
        "        abstract.to_corner(UR)\n",
        "        physical = OldTexText(\"Physical\")\n",
        "        physical.next_to(state.get_top(), DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.plane.set_stroke, YELLOW, 0.5,\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.2,\n",
        "            ),\n",
        "            FadeInFromDown(abstract),\n",
        "            Animation(state),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(physical))\n",
        "        self.wait()\n",
        "\n",
        "        # Continue on spiral\n",
        "        sub_traj.resume_updating()\n",
        "        state.pendulum.clear_updaters(recurse=False)\n",
        "        state.pendulum.start_swinging()\n",
        "        dot.clear_updaters()\n",
        "        self.tie_dot_position_to_state(dot, state)\n",
        "        self.wait(20)\n",
        "\n",
        "    #\n",
        "    def get_initial_thetas(self):\n",
        "        angle = 3 * PI / 4\n",
        "        return np.linspace(-angle, angle, self.n_thetas)\n",
        "\n",
        "    def get_initial_omegas(self):\n",
        "        return np.linspace(-1.5, 1.5, self.n_omegas)\n",
        "\n",
        "    def get_state(self, pendulum):\n",
        "        return (pendulum.get_theta(), pendulum.get_omega())\n",
        "\n",
        "    def get_state_point(self, pendulum):\n",
        "        return self.plane.coords_to_point(\n",
        "            *self.get_state(pendulum)\n",
        "        )\n",
        "\n",
        "    def get_flexible_state_picture(self):\n",
        "        buff = MED_SMALL_BUFF\n",
        "        height = FRAME_HEIGHT / 2 - buff\n",
        "        rect = Square(\n",
        "            side_length=height,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=2,\n",
        "            fill_color=\"#111111\",\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        rect.to_corner(UL, buff=buff / 2)\n",
        "        pendulum = Pendulum(\n",
        "            top_point=rect.get_center(),\n",
        "            **self.big_pendulum_config\n",
        "        )\n",
        "        pendulum.fixed_point_tracker.add_updater(\n",
        "            lambda m: m.move_to(rect.get_center())\n",
        "        )\n",
        "\n",
        "        state = VGroup(rect, pendulum)\n",
        "        state.rect = rect\n",
        "        state.pendulum = pendulum\n",
        "        return state\n",
        "\n",
        "    def get_state_dot(self, state):\n",
        "        dot = Dot(color=PINK)\n",
        "        dot.move_to(self.get_state_point(state.pendulum))\n",
        "        return dot\n",
        "\n",
        "    def get_state_controlling_dot(self, state):\n",
        "        dot = self.get_state_dot(state)\n",
        "        self.tie_state_to_dot_position(state, dot)\n",
        "        return dot\n",
        "\n",
        "    def tie_state_to_dot_position(self, state, dot):\n",
        "        def update_pendulum(pend):\n",
        "            theta, omega = self.plane.point_to_coords(\n",
        "                dot.get_center()\n",
        "            )\n",
        "            pend.set_theta(theta)\n",
        "            pend.set_omega(omega)\n",
        "            return pend\n",
        "        state.pendulum.add_updater(update_pendulum)\n",
        "        state.pendulum.get_arc_angle_theta = \\\n",
        "            lambda: self.plane.x_axis.point_to_number(dot.get_center())\n",
        "        return self\n",
        "\n",
        "    def tie_dot_position_to_state(self, dot, state):\n",
        "        dot.add_updater(lambda d: d.move_to(\n",
        "            self.get_state_point(state.pendulum)\n",
        "        ))\n",
        "        return dot\n",
        "\n",
        "    def get_tracking_line(self, point, axis, color=WHITE):\n",
        "        number = axis.point_to_number(point)\n",
        "        axis_point = axis.number_to_point(number)\n",
        "        return DashedLine(\n",
        "            axis_point, point,\n",
        "            dash_length=0.025,\n",
        "            color=color,\n",
        "        )\n",
        "\n",
        "    def get_tracking_h_line(self, point):\n",
        "        return self.get_tracking_line(\n",
        "            point, self.plane.y_axis, WHITE,\n",
        "        )\n",
        "\n",
        "    def get_tracking_v_line(self, point):\n",
        "        return self.get_tracking_line(\n",
        "            point, self.plane.x_axis, YELLOW,\n",
        "        )\n",
        "\n",
        "    def get_evolving_trajectory(self, mobject):\n",
        "        trajectory = VMobject()\n",
        "        trajectory.start_new_path(mobject.get_center())\n",
        "        trajectory.set_stroke(RED, 1)\n",
        "\n",
        "        def update_trajectory(traj):\n",
        "            point = mobject.get_center()\n",
        "            if get_norm(trajectory.get_points()[-1] == point) > 0.05:\n",
        "                traj.add_smooth_curve_to(point)\n",
        "        trajectory.add_updater(update_trajectory)\n",
        "        return trajectory\n",
        "\n",
        "\n",
        "class IntroduceVectorField(VisualizeStates):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            \"max_magnitude\": 3,\n",
        "            # \"delta_x\": 2,\n",
        "            # \"delta_y\": 2,\n",
        "        },\n",
        "        \"big_pendulum_config\": {\n",
        "            \"initial_theta\": -80 * DEGREES,\n",
        "            \"omega\": 1,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane()\n",
        "        self.add_flexible_state()\n",
        "        self.initialize_vector_field()\n",
        "        self.add_equation()\n",
        "        self.preview_vector_field()\n",
        "        self.write_vector_derivative()\n",
        "        self.interpret_first_coordinate()\n",
        "        self.interpret_second_coordinate()\n",
        "        self.show_full_vector_field()\n",
        "        self.show_trajectory()\n",
        "\n",
        "    def initialize_plane(self):\n",
        "        super().initialize_plane()\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def initialize_vector_field(self):\n",
        "        self.vector_field = VectorField(\n",
        "            self.vector_field_func,\n",
        "            **self.vector_field_config,\n",
        "        )\n",
        "        self.vector_field.sort(get_norm)\n",
        "\n",
        "    def add_flexible_state(self):\n",
        "        self.state = self.get_flexible_state_picture()\n",
        "        self.add(self.state)\n",
        "\n",
        "    def add_equation(self):\n",
        "        ode = get_ode()\n",
        "        ode.set_width(self.state.get_width() - MED_LARGE_BUFF)\n",
        "        ode.next_to(self.state.get_top(), DOWN, SMALL_BUFF)\n",
        "        thetas = ode.get_parts_by_tex(\"\\\\theta\")\n",
        "        thetas[0].set_color(RED)\n",
        "        thetas[1].set_color(YELLOW)\n",
        "        ode_word = OldTexText(\"Differential equation\")\n",
        "        ode_word.match_width(ode)\n",
        "        ode_word.next_to(ode, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ode, 0.5 * DOWN),\n",
        "            FadeIn(ode_word, 0.5 * UP),\n",
        "        )\n",
        "\n",
        "        self.ode = ode\n",
        "        self.ode_word = ode_word\n",
        "\n",
        "    def preview_vector_field(self):\n",
        "        vector_field = self.vector_field\n",
        "\n",
        "        growth = LaggedStartMap(\n",
        "            GrowArrow, vector_field,\n",
        "            run_time=3,\n",
        "            lag_ratio=0.01,\n",
        "        )\n",
        "        self.add(\n",
        "            growth.mobject,\n",
        "            vector_field,\n",
        "            self.state, self.ode, self.ode_word\n",
        "        )\n",
        "\n",
        "        self.play(growth)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(vector_field))\n",
        "        self.remove(growth.mobject)\n",
        "\n",
        "    def write_vector_derivative(self):\n",
        "        state = self.state\n",
        "        plane = self.plane\n",
        "\n",
        "        dot = self.get_state_dot(state)\n",
        "\n",
        "        # Vector\n",
        "        vect = Arrow(\n",
        "            plane.coords_to_point(0, 0),\n",
        "            dot.get_center(),\n",
        "            buff=0,\n",
        "            color=dot.get_color()\n",
        "        )\n",
        "        vect_sym, d_vect_sym = [\n",
        "            self.get_vector_symbol(\n",
        "                \"{\" + a + \"\\\\theta}(t)\",\n",
        "                \"{\" + b + \"\\\\theta}(t)\",\n",
        "            )\n",
        "            for a, b in [(\"\", \"\\\\dot\"), (\"\\\\dot\", \"\\\\ddot\")]\n",
        "        ]\n",
        "        # vect_sym.get_entries()[1][0][1].set_color(YELLOW)\n",
        "        # d_vect_sym.get_entries()[0][0][1].set_color(YELLOW)\n",
        "        # d_vect_sym.get_entries()[1][0][1].set_color(RED)\n",
        "        vect_sym.next_to(vect.get_end(), UP, MED_LARGE_BUFF)\n",
        "        time_inputs = VGroup(*[\n",
        "            e[-1][-2] for e in vect_sym.get_entries()\n",
        "        ])\n",
        "\n",
        "        # Derivative\n",
        "        ddt = OldTex(\"d \\\\over dt\")\n",
        "        ddt.set_height(0.9 * vect_sym.get_height())\n",
        "        ddt.next_to(vect_sym, LEFT)\n",
        "        ddt.set_stroke(BLACK, 5, background=True)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.add_background_rectangle()\n",
        "        equals.next_to(vect_sym, RIGHT, SMALL_BUFF)\n",
        "        d_vect_sym.next_to(equals, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        # Little vector\n",
        "        angle_tracker = ValueTracker(0)\n",
        "        mag_tracker = ValueTracker(0.75)\n",
        "        d_vect = always_redraw(\n",
        "            lambda: Vector(\n",
        "                rotate_vector(\n",
        "                    mag_tracker.get_value() * RIGHT,\n",
        "                    angle_tracker.get_value(),\n",
        "                ),\n",
        "                color=WHITE\n",
        "            ).shift(dot.get_center()),\n",
        "        )\n",
        "        d_vect_magnitude_factor_tracker = ValueTracker(2)\n",
        "        real_d_vect = always_redraw(\n",
        "            lambda: self.vector_field.get_vector(\n",
        "                dot.get_center()\n",
        "            ).scale(\n",
        "                d_vect_magnitude_factor_tracker.get_value(),\n",
        "                about_point=dot.get_center()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Show vector\n",
        "        self.play(TransformFromCopy(state[1], vect))\n",
        "        self.play(FadeInFromDown(vect_sym))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(vect, dot))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeAround, time_inputs,\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Write Derivative\n",
        "        self.play(Write(ddt))\n",
        "        self.play(\n",
        "            plane.y_axis.numbers.fade, 1,\n",
        "            FadeIn(equals, LEFT),\n",
        "            TransformFromCopy(vect_sym, d_vect_sym)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show as little vector\n",
        "        equation_group = VGroup(\n",
        "            ddt, vect_sym, equals, d_vect_sym\n",
        "        )\n",
        "        self.play(\n",
        "            # equation_group.shift, 4 * DOWN,\n",
        "            equation_group.to_edge, RIGHT, LARGE_BUFF,\n",
        "            GrowArrow(d_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(angle_tracker.set_value, 120 * DEGREES)\n",
        "        self.play(mag_tracker.set_value, 1.5)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight new vector\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(d_vect_sym),\n",
        "            FadeOut(d_vect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(d_vect_sym, real_d_vect),\n",
        "            dot.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Take a walk\n",
        "        trajectory = VMobject()\n",
        "        trajectory.start_new_path(dot.get_center())\n",
        "        dt = 0.01\n",
        "        for x in range(130):\n",
        "            p = trajectory.get_points()[-1]\n",
        "            dp_dt = self.vector_field_func(p)\n",
        "            trajectory.add_smooth_curve_to(p + dp_dt * dt)\n",
        "        self.tie_state_to_dot_position(state, dot)\n",
        "        self.play(\n",
        "            MoveAlongPath(dot, trajectory),\n",
        "            run_time=5,\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "        )\n",
        "\n",
        "        self.state_dot = dot\n",
        "        self.d_vect = real_d_vect\n",
        "        self.equation_group = equation_group\n",
        "        self.d_vect_magnitude_factor_tracker = d_vect_magnitude_factor_tracker\n",
        "\n",
        "    def interpret_first_coordinate(self):\n",
        "        equation = self.equation_group\n",
        "        ddt, vect_sym, equals, d_vect_sym = equation\n",
        "        dot = self.state_dot\n",
        "\n",
        "        first_components_copy = VGroup(\n",
        "            vect_sym.get_entries()[0],\n",
        "            d_vect_sym.get_entries()[0],\n",
        "        ).copy()\n",
        "        rect = SurroundingRectangle(first_components_copy)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        equation.save_state()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            equation.fade, 0.5,\n",
        "            Animation(first_components_copy),\n",
        "        )\n",
        "        self.wait()\n",
        "        dot.save_state()\n",
        "        self.play(dot.shift, 2 * UP)\n",
        "        self.wait()\n",
        "        self.play(dot.shift, 6 * DOWN)\n",
        "        self.wait()\n",
        "        self.play(dot.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            equation.restore,\n",
        "            FadeOut(rect),\n",
        "        )\n",
        "        self.remove(first_components_copy)\n",
        "\n",
        "    def interpret_second_coordinate(self):\n",
        "        equation = self.equation_group\n",
        "        ddt, vect_sym, equals, d_vect_sym = equation\n",
        "\n",
        "        second_components = VGroup(\n",
        "            vect_sym.get_entries()[1],\n",
        "            d_vect_sym.get_entries()[1],\n",
        "        )\n",
        "        rect = SurroundingRectangle(second_components)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        expanded_derivative = self.get_vector_symbol(\n",
        "            \"{\\\\dot\\\\theta}(t)\",\n",
        "            \"-\\\\mu {\\\\dot\\\\theta}(t)\" +\n",
        "            \"-(g / L) \\\\sin\\\\big({\\\\theta}(t)\\\\big)\",\n",
        "        )\n",
        "        expanded_derivative.move_to(d_vect_sym)\n",
        "        expanded_derivative.to_edge(RIGHT, MED_SMALL_BUFF)\n",
        "        equals2 = OldTex(\"=\")\n",
        "        equals2.next_to(expanded_derivative, LEFT, SMALL_BUFF)\n",
        "\n",
        "        equation.save_state()\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(expanded_derivative, LEFT),\n",
        "            FadeIn(equals2),\n",
        "            equation.next_to, equals2, LEFT, SMALL_BUFF,\n",
        "            MaintainPositionRelativeTo(rect, equation),\n",
        "            VFadeOut(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.full_equation = VGroup(\n",
        "            *equation, equals2, expanded_derivative,\n",
        "        )\n",
        "\n",
        "    def show_full_vector_field(self):\n",
        "        vector_field = self.vector_field\n",
        "        state = self.state\n",
        "        ode = self.ode\n",
        "        ode_word = self.ode_word\n",
        "        equation = self.full_equation\n",
        "        d_vect = self.d_vect\n",
        "        dot = self.state_dot\n",
        "\n",
        "        equation.generate_target()\n",
        "        equation.target.scale(0.7)\n",
        "        equation.target.to_edge(DOWN, LARGE_BUFF)\n",
        "        equation.target.to_edge(LEFT, MED_SMALL_BUFF)\n",
        "        equation_rect = BackgroundRectangle(equation.target)\n",
        "\n",
        "        growth = LaggedStartMap(\n",
        "            GrowArrow, vector_field,\n",
        "            run_time=3,\n",
        "            lag_ratio=0.01,\n",
        "        )\n",
        "        self.add(\n",
        "            growth.mobject,\n",
        "            state, ode, ode_word,\n",
        "            equation_rect, equation, dot,\n",
        "            d_vect,\n",
        "        )\n",
        "        self.play(\n",
        "            growth,\n",
        "            FadeIn(equation_rect),\n",
        "            MoveToTarget(equation),\n",
        "            self.d_vect_magnitude_factor_tracker.set_value, 1,\n",
        "        )\n",
        "\n",
        "    def show_trajectory(self):\n",
        "        state = self.state\n",
        "        dot = self.state_dot\n",
        "\n",
        "        state.pendulum.clear_updaters(recurse=False)\n",
        "        self.tie_dot_position_to_state(dot, state)\n",
        "        state.pendulum.start_swinging()\n",
        "\n",
        "        trajectory = self.get_evolving_trajectory(dot)\n",
        "        trajectory.set_stroke(WHITE, 3)\n",
        "\n",
        "        self.add(trajectory, dot)\n",
        "        self.wait(25)\n",
        "\n",
        "    #\n",
        "    def get_vector_symbol(self, tex1, tex2):\n",
        "        t2c = {\n",
        "            \"{\\\\theta}\": BLUE,\n",
        "            \"{\\\\dot\\\\theta}\": YELLOW,\n",
        "            \"{\\\\omega}\": YELLOW,\n",
        "            \"{\\\\ddot\\\\theta}\": RED,\n",
        "        }\n",
        "        return get_vector_symbol(\n",
        "            tex1, tex2,\n",
        "            element_to_mobject_config={\n",
        "                \"tex_to_color_map\": t2c,\n",
        "            }\n",
        "        ).scale(0.9)\n",
        "\n",
        "    def vector_field_func(self, point):\n",
        "        x, y = self.plane.point_to_coords(point)\n",
        "        mu, g, L = [\n",
        "            self.big_pendulum_config.get(key)\n",
        "            for key in [\"damping\", \"gravity\", \"length\"]\n",
        "        ]\n",
        "        return pendulum_vector_field_func(\n",
        "            x * RIGHT + y * UP,\n",
        "            mu=mu, g=g, L=L\n",
        "        )\n",
        "\n",
        "    def ask_about_change(self):\n",
        "        state = self.state\n",
        "\n",
        "        dot = self.get_state_dot(state)\n",
        "        d_vect = Vector(0.75 * RIGHT, color=WHITE)\n",
        "        d_vect.shift(dot.get_center())\n",
        "        q_mark = always_redraw(\n",
        "            lambda: OldTex(\"?\").move_to(\n",
        "                d_vect.get_end() + 0.4 * rotate_vector(\n",
        "                    d_vect.get_vector(), 90 * DEGREES,\n",
        "                ),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.play(TransformFromCopy(state[1], dot))\n",
        "        self.tie_state_to_dot_position(state, dot)\n",
        "        self.play(\n",
        "            GrowArrow(d_vect),\n",
        "            FadeInFromDown(q_mark)\n",
        "        )\n",
        "        for x in range(4):\n",
        "            angle = 90 * DEGREES\n",
        "            self.play(\n",
        "                Rotate(\n",
        "                    d_vect, angle,\n",
        "                    about_point=d_vect.get_start(),\n",
        "                )\n",
        "            )\n",
        "            self.play(\n",
        "                dot.shift,\n",
        "                0.3 * d_vect.get_vector(),\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "\n",
        "\n",
        "class ShowPendulumPhaseFlow(IntroduceVectorField):\n",
        "    CONFIG = {\n",
        "        \"coordinate_plane_config\": {\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 0.8,\n",
        "            },\n",
        "            \"x_max\": 9,\n",
        "            \"x_min\": -9,\n",
        "        },\n",
        "        \"flow_time\": 20,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane()\n",
        "        self.initialize_vector_field()\n",
        "        plane = self.plane\n",
        "        field = self.vector_field\n",
        "        self.add(plane, field)\n",
        "\n",
        "        stream_lines = StreamLines(\n",
        "            field.func,\n",
        "            delta_x=0.3,\n",
        "            delta_y=0.3,\n",
        "        )\n",
        "        animated_stream_lines = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            line_anim_class=ShowPassingFlashWithThinningStrokeWidth,\n",
        "        )\n",
        "\n",
        "        self.add(animated_stream_lines)\n",
        "        self.wait(self.flow_time)\n",
        "\n",
        "\n",
        "class ShowHighVelocityCase(ShowPendulumPhaseFlow, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"coordinate_plane_config\": {\n",
        "            \"x_max\": 15,\n",
        "            \"x_min\": -15,\n",
        "        },\n",
        "        \"vector_field_config\": {\n",
        "            \"x_max\": 15,\n",
        "        },\n",
        "        \"big_pendulum_config\": {\n",
        "            \"max_velocity_vector_length_to_length_ratio\": 1,\n",
        "        },\n",
        "        \"run_time\": 25,\n",
        "        \"initial_theta\": 0,\n",
        "        \"initial_theta_dot\": 4,\n",
        "        \"frame_shift_vect\": TAU * RIGHT,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.add_flexible_state()\n",
        "        self.show_high_vector()\n",
        "        self.show_trajectory()\n",
        "\n",
        "    def initialize_plane_and_field(self):\n",
        "        self.initialize_plane()\n",
        "        self.add(self.plane)\n",
        "        self.initialize_vector_field()\n",
        "        self.add(self.vector_field)\n",
        "\n",
        "    def add_flexible_state(self):\n",
        "        super().add_flexible_state()\n",
        "        state = self.state\n",
        "        plane = self.plane\n",
        "\n",
        "        state.to_edge(DOWN, buff=SMALL_BUFF),\n",
        "        start_point = plane.coords_to_point(\n",
        "            self.initial_theta,\n",
        "            self.initial_theta_dot,\n",
        "        )\n",
        "        dot = self.get_state_controlling_dot(state)\n",
        "        dot.move_to(start_point)\n",
        "        state.update()\n",
        "\n",
        "        self.dot = dot\n",
        "        self.start_point = start_point\n",
        "\n",
        "    def show_high_vector(self):\n",
        "        field = self.vector_field\n",
        "        top_vectors = VGroup(*filter(\n",
        "            lambda a: np.all(a.get_center() > [-10, 1.5, -10]),\n",
        "            field\n",
        "        )).copy()\n",
        "        top_vectors.set_stroke(PINK, 3)\n",
        "        top_vectors.sort(lambda p: p[0])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(\n",
        "                top_vectors,\n",
        "                run_time=2,\n",
        "                lag_ratio=0.01,\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def show_trajectory(self):\n",
        "        state = self.state\n",
        "        frame = self.camera_frame\n",
        "        dot = self.dot\n",
        "        start_point = self.start_point\n",
        "\n",
        "        traj = self.get_trajectory(start_point, self.run_time)\n",
        "\n",
        "        self.add(traj, dot)\n",
        "        anims = [\n",
        "            ShowCreation(\n",
        "                traj,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                dot, lambda d: d.move_to(traj.get_points()[-1])\n",
        "            ),\n",
        "        ]\n",
        "        if get_norm(self.frame_shift_vect) > 0:\n",
        "            anims += [\n",
        "                ApplyMethod(\n",
        "                    frame.shift, self.frame_shift_vect,\n",
        "                    rate_func=squish_rate_func(\n",
        "                        smooth, 0, 0.3,\n",
        "                    )\n",
        "                ),\n",
        "                MaintainPositionRelativeTo(state.rect, frame),\n",
        "            ]\n",
        "        self.play(*anims, run_time=total_time)\n",
        "\n",
        "    def get_trajectory(self, start_point, time, dt=0.1, added_steps=100):\n",
        "        field = self.vector_field\n",
        "        traj = VMobject()\n",
        "        traj.start_new_path(start_point)\n",
        "        for x in range(int(time / dt)):\n",
        "            last_point = traj.get_points()[-1]\n",
        "            for y in range(added_steps):\n",
        "                dp_dt = field.func(last_point)\n",
        "                last_point += dp_dt * dt / added_steps\n",
        "            traj.add_smooth_curve_to(last_point)\n",
        "        traj.make_smooth()\n",
        "        traj.set_stroke(WHITE, 2)\n",
        "        return traj\n",
        "\n",
        "\n",
        "class TweakMuInFormula(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenFadeRectangle(\n",
        "            opacity=0.75,\n",
        "        ))\n",
        "\n",
        "        ode = get_ode()\n",
        "        ode.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        mu = ode.get_part_by_tex(\"\\\\mu\")\n",
        "        lil_rect = SurroundingRectangle(mu, buff=0.5 * SMALL_BUFF)\n",
        "        lil_rect.stretch(1.2, 1, about_edge=DOWN)\n",
        "        lil_rect.set_stroke(PINK, 2)\n",
        "\n",
        "        interval = UnitInterval()\n",
        "        interval.add_numbers(\n",
        "            *np.arange(0, 1.2, 0.2)\n",
        "        )\n",
        "        interval.next_to(ode, UP, LARGE_BUFF)\n",
        "        big_rect_seed = SurroundingRectangle(interval, buff=MED_SMALL_BUFF)\n",
        "        big_rect_seed.stretch(1.5, 1, about_edge=DOWN)\n",
        "        big_rect_seed.stretch(1.2, 0)\n",
        "        big_rect = VGroup(*[\n",
        "            DashedLine(v1, v2)\n",
        "            for v1, v2 in adjacent_pairs(big_rect_seed.get_vertices())\n",
        "        ])\n",
        "        big_rect.set_stroke(PINK, 2)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            lil_rect.get_top(),\n",
        "            big_rect_seed.point_from_proportion(0.65),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        arrow.match_color(lil_rect)\n",
        "\n",
        "        mu_tracker = ValueTracker(0.1)\n",
        "        get_mu = mu_tracker.get_value\n",
        "\n",
        "        triangle = Triangle(\n",
        "            start_angle=-90 * DEGREES,\n",
        "            stroke_width=0,\n",
        "            fill_opacity=1,\n",
        "            fill_color=WHITE,\n",
        "        )\n",
        "        triangle.set_height(0.2)\n",
        "        triangle.add_updater(lambda t: t.next_to(\n",
        "            interval.number_to_point(get_mu()),\n",
        "            UP, buff=0,\n",
        "        ))\n",
        "\n",
        "        equation = VGroup(\n",
        "            OldTex(\"\\\\mu = \"),\n",
        "            DecimalNumber(),\n",
        "        )\n",
        "        equation.add_updater(\n",
        "            lambda e: e.arrange(RIGHT).next_to(\n",
        "                triangle, UP, SMALL_BUFF,\n",
        "            ).shift(0.4 * RIGHT)\n",
        "        )\n",
        "        equation[-1].add_updater(\n",
        "            lambda d: d.set_value(get_mu()).shift(0.05 * UL)\n",
        "        )\n",
        "\n",
        "        self.add(ode)\n",
        "        self.play(ShowCreation(lil_rect))\n",
        "        self.play(\n",
        "            GrowFromPoint(interval, mu.get_center()),\n",
        "            GrowFromPoint(triangle, mu.get_center()),\n",
        "            GrowFromPoint(equation, mu.get_center()),\n",
        "            TransformFromCopy(lil_rect, big_rect),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(mu_tracker.set_value, 0.9, run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TweakMuInVectorField(ShowPendulumPhaseFlow):\n",
        "    def construct(self):\n",
        "        self.initialize_plane()\n",
        "        plane = self.plane\n",
        "        self.add(plane)\n",
        "\n",
        "        mu_tracker = ValueTracker(0.1)\n",
        "        get_mu = mu_tracker.get_value\n",
        "\n",
        "        def vector_field_func(p):\n",
        "            x, y = plane.point_to_coords(p)\n",
        "            mu = get_mu()\n",
        "            g = self.big_pendulum_config.get(\"gravity\")\n",
        "            L = self.big_pendulum_config.get(\"length\")\n",
        "            return pendulum_vector_field_func(\n",
        "                x * RIGHT + y * UP,\n",
        "                mu=mu, g=g, L=L\n",
        "            )\n",
        "\n",
        "        def get_vector_field():\n",
        "            return VectorField(\n",
        "                vector_field_func,\n",
        "                **self.vector_field_config,\n",
        "            )\n",
        "\n",
        "        field = always_redraw(get_vector_field)\n",
        "        self.add(field)\n",
        "\n",
        "        self.play(\n",
        "            mu_tracker.set_value, 0.9,\n",
        "            run_time=5,\n",
        "        )\n",
        "        field.suspend_updating()\n",
        "\n",
        "        stream_lines = StreamLines(\n",
        "            field.func,\n",
        "            delta_x=0.3,\n",
        "            delta_y=0.3,\n",
        "        )\n",
        "        animated_stream_lines = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            line_anim_class=ShowPassingFlashWithThinningStrokeWidth,\n",
        "        )\n",
        "        self.add(animated_stream_lines)\n",
        "        self.wait(self.flow_time)\n",
        "\n",
        "\n",
        "class HighAmplitudePendulum(ShowHighVelocityCase):\n",
        "    CONFIG = {\n",
        "        \"big_pendulum_config\": {\n",
        "            \"damping\": 0.02,\n",
        "        },\n",
        "        \"initial_theta\": 175 * DEGREES,\n",
        "        \"initial_theta_dot\": 0,\n",
        "        \"frame_shift_vect\": 0 * RIGHT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.add_flexible_state()\n",
        "        self.show_trajectory()\n",
        "\n",
        "\n",
        "class SpectrumOfStartingStates(ShowHighVelocityCase):\n",
        "    CONFIG = {\n",
        "        \"run_time\": 15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.vector_field.set_opacity(0.5)\n",
        "        self.show_many_trajectories()\n",
        "\n",
        "    def show_many_trajectories(self):\n",
        "        plane = self.plane\n",
        "\n",
        "        delta_x = 0.5\n",
        "        delta_y = 0.5\n",
        "        n = 20\n",
        "\n",
        "        start_points = [\n",
        "            plane.coords_to_point(x, y)\n",
        "            for x in np.linspace(PI - delta_x, PI + delta_x, n)\n",
        "            for y in np.linspace(-delta_y, delta_y, n)\n",
        "        ]\n",
        "        start_points.sort(\n",
        "            key=lambda p: np.dot(p, UL)\n",
        "        )\n",
        "        time = self.run_time\n",
        "\n",
        "        # Count points\n",
        "        dots = VGroup(*[\n",
        "            Dot(sp, radius=0.025)\n",
        "            for sp in start_points\n",
        "        ])\n",
        "        dots.set_color_by_gradient(PINK, BLUE, YELLOW)\n",
        "        words = OldTexText(\n",
        "            \"Spectrum of\\\\\\\\\", \"initial conditions\"\n",
        "        )\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        words.next_to(dots, UP)\n",
        "\n",
        "        self.play(\n",
        "            # ShowIncreasingSubsets(dots, run_time=2),\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, dots,\n",
        "                lambda m: (m, 10),\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeInFromDown(words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        trajs = VGroup()\n",
        "        for sp in start_points:\n",
        "            trajs.add(\n",
        "                self.get_trajectory(\n",
        "                    sp, time,\n",
        "                    added_steps=10,\n",
        "                )\n",
        "            )\n",
        "        for traj, dot in zip(trajs, dots):\n",
        "            traj.set_stroke(dot.get_color(), 1)\n",
        "\n",
        "        def update_dots(ds):\n",
        "            for d, t in zip(ds, trajs):\n",
        "                d.move_to(t.get_points()[-1])\n",
        "            return ds\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        self.add(dots, trajs, words)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                trajs,\n",
        "                lag_ratio=0,\n",
        "            ),\n",
        "            rate_func=linear,\n",
        "            run_time=time,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutStability(ShowHighVelocityCase):\n",
        "    CONFIG = {\n",
        "        \"initial_theta\": 60 * DEGREES,\n",
        "        \"initial_theta_dot\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.add_flexible_state()\n",
        "        self.show_fixed_points()\n",
        "        self.label_fixed_points()\n",
        "        self.ask_about_stability()\n",
        "        self.show_nudges()\n",
        "\n",
        "    def show_fixed_points(self):\n",
        "        state1 = self.state\n",
        "        plane = self.plane\n",
        "        dot1 = self.dot\n",
        "\n",
        "        state2 = self.get_flexible_state_picture()\n",
        "        state2.to_corner(DR, buff=SMALL_BUFF)\n",
        "        dot2 = self.get_state_controlling_dot(state2)\n",
        "        dot2.set_color(BLUE)\n",
        "\n",
        "        fp1 = plane.coords_to_point(0, 0)\n",
        "        fp2 = plane.coords_to_point(PI, 0)\n",
        "\n",
        "        self.play(\n",
        "            dot1.move_to, fp1,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(state2))\n",
        "        self.play(\n",
        "            dot2.move_to, fp2,\n",
        "            path_arc=-30 * DEGREES,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.state1 = state1\n",
        "        self.state2 = state2\n",
        "        self.dot1 = dot1\n",
        "        self.dot2 = dot2\n",
        "\n",
        "    def label_fixed_points(self):\n",
        "        dots = VGroup(self.dot1, self.dot2)\n",
        "\n",
        "        label = OldTexText(\"Fixed points\")\n",
        "        label.scale(1.5)\n",
        "        label.set_stroke(BLACK, 5, background=True)\n",
        "        label.next_to(dots, UP, buff=2)\n",
        "        label.shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                label.get_bottom(), dot.get_center(),\n",
        "                color=dot.get_color(),\n",
        "            )\n",
        "            for dot in dots\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            self.vector_field.set_opacity, 0.5,\n",
        "            FadeInFromDown(label)\n",
        "        )\n",
        "        self.play(ShowCreation(arrows))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.to_fade = VGroup(label, arrows)\n",
        "\n",
        "    def ask_about_stability(self):\n",
        "        question = OldTexText(\"Stable?\")\n",
        "        question.scale(2)\n",
        "        question.shift(FRAME_WIDTH * RIGHT / 4)\n",
        "        question.to_edge(UP)\n",
        "        question.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(Write(question))\n",
        "        self.play(FadeOut(self.to_fade))\n",
        "\n",
        "    def show_nudges(self):\n",
        "        dots = VGroup(self.dot1, self.dot2)\n",
        "        time = 20\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                dot.shift, 0.1 * UL,\n",
        "                rate_func=rush_from,\n",
        "            )\n",
        "            for dot in dots\n",
        "        ])\n",
        "\n",
        "        trajs = VGroup()\n",
        "        for dot in dots:\n",
        "            traj = self.get_trajectory(\n",
        "                dot.get_center(),\n",
        "                time,\n",
        "            )\n",
        "            traj.set_stroke(dot.get_color(), 2)\n",
        "            trajs.add(traj)\n",
        "\n",
        "        def update_dots(ds):\n",
        "            for t, d in zip(trajs, ds):\n",
        "                d.move_to(t.get_points()[-1])\n",
        "        dots.add_updater(update_dots)\n",
        "        self.add(trajs, dots)\n",
        "        self.play(\n",
        "            ShowCreation(trajs, lag_ratio=0),\n",
        "            rate_func=linear,\n",
        "            run_time=time\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LovePhaseSpace(ShowHighVelocityCase):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            \"max_magnitude\": 4,\n",
        "            # \"delta_x\": 2,\n",
        "            # \"delta_y\": 2,\n",
        "        },\n",
        "        \"a\": 0.5,\n",
        "        \"b\": 0.3,\n",
        "        \"mu\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_equations()\n",
        "        self.show_vector_field()\n",
        "        self.show_example_trajectories()\n",
        "        self.add_resistance_term()\n",
        "        self.show_new_trajectories()\n",
        "\n",
        "    def setup_plane(self):\n",
        "        plane = self.plane = NumberPlane()\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "\n",
        "        h1, h2 = hearts = VGroup(*[\n",
        "            get_heart_var(i)\n",
        "            for i in (1, 2)\n",
        "        ])\n",
        "        hearts.scale(0.5)\n",
        "        hearts.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        h1.next_to(plane.x_axis.get_right(), UL, SMALL_BUFF)\n",
        "        h2.next_to(plane.y_axis.get_top(), DR, SMALL_BUFF)\n",
        "        for h in hearts:\n",
        "            h.shift_onto_screen(buff=MED_SMALL_BUFF)\n",
        "        plane.add(hearts)\n",
        "\n",
        "        self.axis_hearts = hearts\n",
        "\n",
        "    def add_equations(self):\n",
        "        equations = VGroup(\n",
        "            get_love_equation1(),\n",
        "            get_love_equation2(),\n",
        "        )\n",
        "        equations.scale(0.5)\n",
        "        equations.arrange(\n",
        "            DOWN,\n",
        "            aligned_edge=LEFT,\n",
        "            buff=MED_LARGE_BUFF\n",
        "        )\n",
        "        equations.to_corner(UL)\n",
        "        equations.add_background_rectangle_to_submobjects()\n",
        "        # for eq in equations:\n",
        "        #     eq.add_background_rectangle_to_submobjects()\n",
        "\n",
        "        self.add(equations)\n",
        "        self.equations = equations\n",
        "\n",
        "    def show_vector_field(self):\n",
        "        field = VectorField(\n",
        "            lambda p: np.array([\n",
        "                self.a * p[1], -self.b * p[0], 0\n",
        "            ]),\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        field.sort(get_norm)\n",
        "        x_range = np.arange(-7, 7.5, 0.5)\n",
        "        y_range = np.arange(-4, 4.5, 0.5)\n",
        "        x_axis_arrows = VGroup(*[\n",
        "            field.get_vector([x, 0, 0])\n",
        "            for x in x_range\n",
        "        ])\n",
        "        y_axis_arrows = VGroup(*[\n",
        "            field.get_vector([0, y, 0])\n",
        "            for y in y_range\n",
        "        ])\n",
        "        axis_arrows = VGroup(*x_axis_arrows, *y_axis_arrows)\n",
        "\n",
        "        axis_arrows.save_state()\n",
        "        for arrow in axis_arrows:\n",
        "            real_len = get_norm(field.func(arrow.get_start()))\n",
        "            arrow.scale(\n",
        "                0.5 * real_len / arrow.get_length(),\n",
        "                about_point=arrow.get_start()\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, x_axis_arrows),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, y_axis_arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(field, self.equations, self.axis_hearts)\n",
        "        self.play(\n",
        "            axis_arrows.restore,\n",
        "            # axis_arrows.fade, 1,\n",
        "            ShowCreation(field),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.remove(axis_arrows)\n",
        "        self.wait()\n",
        "\n",
        "        self.field = self.vector_field = field\n",
        "\n",
        "    def show_example_trajectories(self):\n",
        "        n_points = 20\n",
        "        total_time = 30\n",
        "\n",
        "        start_points = self.start_points = [\n",
        "            2.5 * np.random.random() * rotate_vector(\n",
        "                RIGHT,\n",
        "                TAU * np.random.random()\n",
        "            )\n",
        "            for x in range(n_points)\n",
        "        ]\n",
        "        dots = VGroup(*[Dot(sp) for sp in start_points])\n",
        "        dots.set_color_by_gradient(BLUE, WHITE)\n",
        "\n",
        "        words = OldTexText(\"Possible initial\\\\\\\\\", \"conditions\")\n",
        "        words.scale(1.5)\n",
        "        words.add_background_rectangle_to_submobjects()\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        words.shift(FRAME_WIDTH * RIGHT / 4)\n",
        "        words.to_edge(UP)\n",
        "        self.possibility_words = words\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, dots,\n",
        "                lambda m: (m, 5)\n",
        "            ),\n",
        "            FadeInFromDown(words)\n",
        "        )\n",
        "\n",
        "        trajs = VGroup(*[\n",
        "            self.get_trajectory(\n",
        "                sp, total_time,\n",
        "                added_steps=10,\n",
        "            )\n",
        "            for sp in start_points\n",
        "        ])\n",
        "        trajs.set_color_by_gradient(BLUE, WHITE)\n",
        "\n",
        "        dots.trajs = trajs\n",
        "\n",
        "        def update_dots(ds):\n",
        "            for d, t in zip(ds, ds.trajs):\n",
        "                d.move_to(t.get_points()[-1])\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        self.add(trajs, dots)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                trajs,\n",
        "                lag_ratio=0,\n",
        "                run_time=10,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.trajs = trajs\n",
        "        self.dots = dots\n",
        "\n",
        "    def add_resistance_term(self):\n",
        "        added_term = VGroup(\n",
        "            OldTex(\"-\\\\mu\"),\n",
        "            get_heart_var(2).scale(0.5),\n",
        "        )\n",
        "        added_term.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation2 = self.equations[1]\n",
        "        equation2.generate_target()\n",
        "        br, deriv, eq, neg_b, h1 = equation2.target\n",
        "        added_term.next_to(eq, RIGHT, SMALL_BUFF)\n",
        "        added_term.align_to(h1, DOWN)\n",
        "        VGroup(neg_b, h1).next_to(\n",
        "            added_term, RIGHT, SMALL_BUFF,\n",
        "            aligned_edge=DOWN,\n",
        "        )\n",
        "        br.stretch(1.2, 0, about_edge=LEFT)\n",
        "\n",
        "        brace = Brace(added_term, DOWN, buff=SMALL_BUFF)\n",
        "        words = brace.get_text(\n",
        "            \"``Resistance'' term\"\n",
        "        )\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        self.add(equation2, added_term)\n",
        "        self.play(\n",
        "            MoveToTarget(equation2),\n",
        "            FadeInFromDown(added_term),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(added_term))\n",
        "\n",
        "        equation2.add(added_term, brace, words)\n",
        "\n",
        "    def show_new_trajectories(self):\n",
        "        dots = self.dots\n",
        "        trajs = self.trajs\n",
        "        field = self.field\n",
        "\n",
        "        new_field = VectorField(\n",
        "            lambda p: np.array([\n",
        "                self.a * p[1],\n",
        "                -self.mu * p[1] - self.b * p[0],\n",
        "                0\n",
        "            ]),\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        new_field.sort(get_norm)\n",
        "\n",
        "        field.generate_target()\n",
        "        for vect in field.target:\n",
        "            vect.become(new_field.get_vector(vect.get_start()))\n",
        "\n",
        "        self.play(*map(\n",
        "            FadeOut,\n",
        "            [trajs, dots, self.possibility_words]\n",
        "        ))\n",
        "        self.play(MoveToTarget(field))\n",
        "        self.vector_field = new_field\n",
        "\n",
        "        total_time = 30\n",
        "        new_trajs = VGroup(*[\n",
        "            self.get_trajectory(\n",
        "                sp, total_time,\n",
        "                added_steps=10,\n",
        "            )\n",
        "            for sp in self.start_points\n",
        "        ])\n",
        "        new_trajs.set_color_by_gradient(BLUE, WHITE)\n",
        "        dots.trajs = new_trajs\n",
        "\n",
        "        self.add(new_trajs, dots)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                new_trajs,\n",
        "                lag_ratio=0,\n",
        "                run_time=10,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TakeManyTinySteps(IntroduceVectorField):\n",
        "    CONFIG = {\n",
        "        \"initial_theta\": 60 * DEGREES,\n",
        "        \"initial_theta_dot\": 0,\n",
        "        \"initial_theta_tex\": \"\\\\pi / 3\",\n",
        "        \"initial_theta_dot_tex\": \"0\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.take_many_time_steps()\n",
        "\n",
        "    def initialize_plane_and_field(self):\n",
        "        self.initialize_plane()\n",
        "        self.initialize_vector_field()\n",
        "        field = self.vector_field\n",
        "        field.set_opacity(0.35)\n",
        "        self.add(self.plane, field)\n",
        "\n",
        "    def take_many_time_steps(self):\n",
        "        self.setup_trackers()\n",
        "        delta_t_tracker = self.delta_t_tracker\n",
        "        get_delta_t = delta_t_tracker.get_value\n",
        "        time_tracker = self.time_tracker\n",
        "        get_t = time_tracker.get_value\n",
        "\n",
        "        traj = always_redraw(\n",
        "            lambda: self.get_time_step_trajectory(\n",
        "                get_delta_t(),\n",
        "                get_t(),\n",
        "                self.initial_theta,\n",
        "                self.initial_theta_dot,\n",
        "            )\n",
        "        )\n",
        "        vectors = always_redraw(\n",
        "            lambda: self.get_path_vectors(\n",
        "                get_delta_t(),\n",
        "                get_t(),\n",
        "                self.initial_theta,\n",
        "                self.initial_theta_dot,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Labels\n",
        "        labels, init_labels = self.get_labels(get_t, get_delta_t)\n",
        "        t_label, dt_label = labels\n",
        "\n",
        "        theta_t_label = OldTex(\"\\\\theta(t)...\\\\text{ish}\")\n",
        "        theta_t_label.scale(0.75)\n",
        "        theta_t_label.add_updater(lambda m: m.next_to(\n",
        "            vectors[-1].get_end(),\n",
        "            vectors[-1].get_vector(),\n",
        "            SMALL_BUFF,\n",
        "        ))\n",
        "\n",
        "        self.add(traj, vectors, init_labels, labels)\n",
        "        time_tracker.set_value(0)\n",
        "        target_time = 10\n",
        "        self.play(\n",
        "            VFadeIn(theta_t_label),\n",
        "            ApplyMethod(\n",
        "                time_tracker.set_value, target_time,\n",
        "                run_time=5,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        t_label[-1].clear_updaters()\n",
        "        self.remove(theta_t_label)\n",
        "        target_delta_t = 0.01\n",
        "        self.play(\n",
        "            delta_t_tracker.set_value, target_delta_t,\n",
        "            run_time=7,\n",
        "        )\n",
        "        self.wait()\n",
        "        traj.clear_updaters()\n",
        "        vectors.clear_updaters()\n",
        "\n",
        "        # Show steps\n",
        "        count_tracker = ValueTracker(0)\n",
        "        count = Integer()\n",
        "        count.scale(1.5)\n",
        "        count.to_edge(LEFT)\n",
        "        count.shift(UP + MED_SMALL_BUFF * UR)\n",
        "        count.add_updater(lambda c: c.set_value(\n",
        "            count_tracker.get_value()\n",
        "        ))\n",
        "        count_label = OldTexText(\"steps\")\n",
        "        count_label.scale(1.5)\n",
        "        count_label.add_updater(\n",
        "            lambda m: m.next_to(\n",
        "                count[-1], RIGHT,\n",
        "                submobject_to_align=m[0][0],\n",
        "                aligned_edge=DOWN\n",
        "            )\n",
        "        )\n",
        "\n",
        "        scaled_vectors = vectors.copy()\n",
        "        scaled_vectors.clear_updaters()\n",
        "        for vector in scaled_vectors:\n",
        "            vector.scale(\n",
        "                1 / vector.get_length(),\n",
        "                about_point=vector.get_start()\n",
        "            )\n",
        "            vector.set_color(YELLOW)\n",
        "\n",
        "        def update_scaled_vectors(group):\n",
        "            group.set_opacity(0)\n",
        "            group[min(\n",
        "                int(count.get_value()),\n",
        "                len(group) - 1,\n",
        "            )].set_opacity(1)\n",
        "\n",
        "        scaled_vectors.add_updater(update_scaled_vectors)\n",
        "\n",
        "        self.add(count, count_label, scaled_vectors)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                count_tracker.set_value,\n",
        "                int(target_time / target_delta_t),\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(FadeOut(scaled_vectors))\n",
        "        self.wait()\n",
        "\n",
        "    def setup_trackers(self):\n",
        "        self.delta_t_tracker = ValueTracker(0.5)\n",
        "        self.time_tracker = ValueTracker(10)\n",
        "\n",
        "    def get_labels(self, get_t, get_delta_t):\n",
        "        t_label, dt_label = labels = VGroup(*[\n",
        "            VGroup(\n",
        "                OldTex(\"{} = \".format(s)),\n",
        "                DecimalNumber(0)\n",
        "            ).arrange(RIGHT, aligned_edge=DOWN)\n",
        "            for s in (\"t\", \"{\\\\Delta t}\")\n",
        "        ])\n",
        "\n",
        "        dt_label[-1].add_updater(\n",
        "            lambda d: d.set_value(get_delta_t())\n",
        "        )\n",
        "        t_label[-1].add_updater(\n",
        "            lambda d: d.set_value(\n",
        "                int(np.ceil(get_t() / get_delta_t())) * get_delta_t()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        init_labels = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\theta_0\", \"=\", self.initial_theta_tex,\n",
        "                tex_to_color_map={\"\\\\theta\": BLUE},\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"{\\\\dot\\\\theta}_0 =\", self.initial_theta_dot_tex,\n",
        "                tex_to_color_map={\"{\\\\dot\\\\theta}\": YELLOW},\n",
        "            ),\n",
        "        )\n",
        "        for group in labels, init_labels:\n",
        "            for label in group:\n",
        "                label.scale(1.25)\n",
        "                label.add_background_rectangle()\n",
        "            group.arrange(DOWN)\n",
        "            group.shift(FRAME_WIDTH * RIGHT / 4)\n",
        "        labels.to_edge(UP)\n",
        "        init_labels.shift(2 * DOWN)\n",
        "\n",
        "        return labels, init_labels\n",
        "\n",
        "    #\n",
        "    def get_time_step_points(self, delta_t, total_time, theta_0, theta_dot_0):\n",
        "        plane = self.plane\n",
        "        field = self.vector_field\n",
        "        curr_point = plane.coords_to_point(\n",
        "            theta_0,\n",
        "            theta_dot_0,\n",
        "        )\n",
        "        points = [curr_point]\n",
        "        t = 0\n",
        "        while t < total_time:\n",
        "            new_point = curr_point + field.func(curr_point) * delta_t\n",
        "            points.append(new_point)\n",
        "            curr_point = new_point\n",
        "            t += delta_t\n",
        "        return points\n",
        "\n",
        "    def get_time_step_trajectory(self, delta_t, total_time, theta_0, theta_dot_0):\n",
        "        traj = VMobject()\n",
        "        traj.set_points_as_corners(\n",
        "            self.get_time_step_points(\n",
        "                delta_t, total_time,\n",
        "                theta_0, theta_dot_0,\n",
        "            )\n",
        "        )\n",
        "        traj.set_stroke(WHITE, 2)\n",
        "        return traj\n",
        "\n",
        "    def get_path_vectors(self, delta_t, total_time, theta_0, theta_dot_0):\n",
        "        corners = self.get_time_step_points(\n",
        "            delta_t, total_time,\n",
        "            theta_0, theta_dot_0,\n",
        "        )\n",
        "        result = VGroup()\n",
        "        for a1, a2 in zip(corners, corners[1:]):\n",
        "            vector = Arrow(\n",
        "                a1, a2, buff=0,\n",
        "            )\n",
        "            vector.match_style(\n",
        "                self.vector_field.get_vector(a1)\n",
        "            )\n",
        "            result.add(vector)\n",
        "        return result\n",
        "\n",
        "\n",
        "class SetupToTakingManyTinySteps(TakeManyTinySteps):\n",
        "    CONFIG = {\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.show_step()\n",
        "\n",
        "    def show_step(self):\n",
        "        self.setup_trackers()\n",
        "        get_delta_t = self.delta_t_tracker.get_value\n",
        "        get_t = self.time_tracker.get_value\n",
        "\n",
        "        labels, init_labels = self.get_labels(get_t, get_delta_t)\n",
        "        t_label, dt_label = labels\n",
        "\n",
        "        dt_part = dt_label[1][0][:-1].copy()\n",
        "\n",
        "        init_labels_rect = SurroundingRectangle(init_labels)\n",
        "        init_labels_rect.set_color(PINK)\n",
        "\n",
        "        field = self.vector_field\n",
        "        point = self.plane.coords_to_point(\n",
        "            self.initial_theta,\n",
        "            self.initial_theta_dot,\n",
        "        )\n",
        "        dot = Dot(point, color=init_labels_rect.get_color())\n",
        "\n",
        "        vector_value = field.func(point)\n",
        "        vector = field.get_vector(point)\n",
        "        vector.scale(\n",
        "            get_norm(vector_value) / vector.get_length(),\n",
        "            about_point=vector.get_start()\n",
        "        )\n",
        "        scaled_vector = vector.copy()\n",
        "        scaled_vector.scale(\n",
        "            get_delta_t(),\n",
        "            about_point=scaled_vector.get_start()\n",
        "        )\n",
        "\n",
        "        v_label = OldTex(\"\\\\vec{\\\\textbf{v}}\")\n",
        "        v_label.set_stroke(BLACK, 5, background=True)\n",
        "        v_label.next_to(vector, LEFT, SMALL_BUFF)\n",
        "\n",
        "        real_field = field.copy()\n",
        "        for v in real_field:\n",
        "            p = v.get_start()\n",
        "            v.scale(\n",
        "                get_norm(field.func(p)) / v.get_length(),\n",
        "                about_point=p\n",
        "            )\n",
        "\n",
        "        self.add(init_labels)\n",
        "        self.play(ShowCreation(init_labels_rect))\n",
        "        self.play(ReplacementTransform(\n",
        "            init_labels_rect,\n",
        "            dot,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.add(vector, dot)\n",
        "        self.play(\n",
        "            ShowCreation(vector),\n",
        "            FadeIn(v_label, RIGHT),\n",
        "        )\n",
        "        self.play(FadeInFromDown(dt_label))\n",
        "        self.wait()\n",
        "\n",
        "        #\n",
        "        v_label.generate_target()\n",
        "        dt_part.generate_target()\n",
        "        dt_part.target.next_to(scaled_vector, LEFT, SMALL_BUFF)\n",
        "        v_label.target.next_to(dt_part.target, LEFT, SMALL_BUFF)\n",
        "        rect = BackgroundRectangle(\n",
        "            VGroup(v_label.target, dt_part.target)\n",
        "        )\n",
        "\n",
        "        self.add(rect, v_label, dt_part)\n",
        "        self.play(\n",
        "            ReplacementTransform(vector, scaled_vector),\n",
        "            FadeIn(rect),\n",
        "            MoveToTarget(v_label),\n",
        "            MoveToTarget(dt_part),\n",
        "        )\n",
        "        self.add(scaled_vector, dot)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                Transform(\n",
        "                    sm1, sm2,\n",
        "                    rate_func=there_and_back_with_pause,\n",
        "                )\n",
        "                for sm1, sm2 in zip(field, real_field)\n",
        "            ], lag_ratio=0.001, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowClutterPrevention(SetupToTakingManyTinySteps):\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "\n",
        "        # Copied from above scene\n",
        "        field = self.vector_field\n",
        "        real_field = field.copy()\n",
        "        for v in real_field:\n",
        "            p = v.get_start()\n",
        "            v.scale(\n",
        "                get_norm(field.func(p)) / v.get_length(),\n",
        "                about_point=p\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                Transform(\n",
        "                    sm1, sm2,\n",
        "                    rate_func=there_and_back_with_pause,\n",
        "                )\n",
        "                for sm1, sm2 in zip(field, real_field)\n",
        "            ], lag_ratio=0.001, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ManyStepsFromDifferentStartingPoints(TakeManyTinySteps):\n",
        "    CONFIG = {\n",
        "        \"initial_thetas\": np.linspace(0.1, PI - 0.1, 10),\n",
        "        \"initial_theta_dot\": 0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane_and_field()\n",
        "        self.take_many_time_steps()\n",
        "\n",
        "    def take_many_time_steps(self):\n",
        "        delta_t_tracker = ValueTracker(0.2)\n",
        "        get_delta_t = delta_t_tracker.get_value\n",
        "\n",
        "        time_tracker = ValueTracker(10)\n",
        "        get_t = time_tracker.get_value\n",
        "        # traj = always_redraw(\n",
        "        #     lambda: VGroup(*[\n",
        "        #         self.get_time_step_trajectory(\n",
        "        #             get_delta_t(),\n",
        "        #             get_t(),\n",
        "        #             theta,\n",
        "        #             self.initial_theta_dot,\n",
        "        #         )\n",
        "        #         for theta in self.initial_thetas\n",
        "        #     ])\n",
        "        # )\n",
        "        vectors = always_redraw(\n",
        "            lambda: VGroup(*[\n",
        "                self.get_path_vectors(\n",
        "                    get_delta_t(),\n",
        "                    get_t(),\n",
        "                    theta,\n",
        "                    self.initial_theta_dot,\n",
        "                )\n",
        "                for theta in self.initial_thetas\n",
        "            ])\n",
        "        )\n",
        "\n",
        "        self.add(vectors)\n",
        "        time_tracker.set_value(0)\n",
        "        self.play(\n",
        "            time_tracker.set_value, 5,\n",
        "            run_time=5,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "\n",
        "class Thumbnail(IntroduceVectorField):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            # \"delta_x\": 0.5,\n",
        "            # \"delta_y\": 0.5,\n",
        "            # \"max_magnitude\": 5,\n",
        "            # \"length_func\": lambda norm: 0.5 * sigmoid(norm),\n",
        "            \"delta_x\": 1,\n",
        "            \"delta_y\": 1,\n",
        "            \"max_magnitude\": 5,\n",
        "            \"length_func\": lambda norm: 0.9 * sigmoid(norm),\n",
        "        },\n",
        "        \"big_pendulum_config\": {\n",
        "            \"damping\": 0.4,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_plane()\n",
        "        self.plane.axes.set_stroke(width=0.5)\n",
        "        self.initialize_vector_field()\n",
        "\n",
        "        field = self.vector_field\n",
        "        field.set_stroke(width=5)\n",
        "        for vector in field:\n",
        "            vector.set_stroke(width=8)\n",
        "            vector.tip.set_stroke(width=0)\n",
        "            vector.tip.scale(1.5, about_point=vector.get_last_point())\n",
        "            vector.set_opacity(1)\n",
        "\n",
        "        title = OldTexText(\"Differential\\\\\\\\\", \"equations\")\n",
        "        title.space_out_submobjects(0.8)\n",
        "        # title.scale(3)\n",
        "        title.set_width(FRAME_WIDTH - 3)\n",
        "        # title.to_edge(UP)\n",
        "        # title[1].to_edge(DOWN)\n",
        "\n",
        "        subtitle = OldTexText(\"Studying the unsolvable\")\n",
        "        subtitle.set_width(FRAME_WIDTH - 1)\n",
        "        subtitle.set_color(WHITE)\n",
        "        subtitle.to_edge(DOWN, buff=1)\n",
        "\n",
        "        # title.center()\n",
        "        title.to_edge(UP, buff=1)\n",
        "        title.add(subtitle)\n",
        "        # title.set_stroke(BLACK, 15, background=True)\n",
        "        # title.add_background_rectangle_to_submobjects(opacity=0.5)\n",
        "        title.set_stroke(BLACK, 15, background=True)\n",
        "        subtitle.set_stroke(RED, 2, background=True)\n",
        "        # for part in title:\n",
        "        #     part[0].set_fill(opacity=0.25)\n",
        "        #     part[0].set_stroke(width=0)\n",
        "        black_parts = VGroup()\n",
        "        for mob in title.family_members_with_points():\n",
        "            for sp in mob.get_subpaths():\n",
        "                new_mob = VMobject()\n",
        "                new_mob.set_points(sp)\n",
        "                new_mob.set_fill(BLACK, 0.25)\n",
        "                new_mob.set_stroke(width=0)\n",
        "                black_parts.add(new_mob)\n",
        "\n",
        "        # for vect in field:\n",
        "        #     for mob in title.family_members_with_points():\n",
        "        #         for p in [vect.get_start(), vect.get_end()]:\n",
        "        #             x, y = p[:2]\n",
        "        #             x0, y0 = mob.get_corner(DL)[:2]\n",
        "        #             x1, y1 = mob.get_corner(UR)[:2]\n",
        "        #             if x0 < x < x1 and y0 < y < y1:\n",
        "        #                 vect.set_opacity(0.25)\n",
        "        #                 vect.tip.set_stroke(width=0)\n",
        "\n",
        "        self.add(self.plane)\n",
        "        self.add(field)\n",
        "        # self.add(black_parts)\n",
        "        # self.add(title)\n",
        "\n",
        "        self.add_line(self.plane)\n",
        "\n",
        "    def add_line(self, axes):\n",
        "        func = self.vector_field_func\n",
        "\n",
        "        line = VMobject()\n",
        "        line.start_new_path(axes.c2p(-TAU, 3.5))\n",
        "\n",
        "        dt = 0.1\n",
        "        t = 0\n",
        "        total_time = 40\n",
        "\n",
        "        while t < total_time:\n",
        "            t += dt\n",
        "            last_point = line.get_last_point()\n",
        "            new_point = last_point + dt * func(last_point)\n",
        "            if new_point[0] > FRAME_WIDTH / 2:\n",
        "                new_point = last_point + FRAME_WIDTH * LEFT\n",
        "                line.start_new_path(new_point)\n",
        "            else:\n",
        "                line.add_smooth_curve_to(new_point)\n",
        "\n",
        "        line.set_stroke(WHITE, 6)\n",
        "        line.make_smooth()\n",
        "        self.add(line)\n"
    ]
}