{
    "topic": "demonstrates the concept of stereographic projection, which is a mathematical technique used to project",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def q_mult(q1, q2):\n",
        "    w1, x1, y1, z1 = q1\n",
        "    w2, x2, y2, z2 = q2\n",
        "    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n",
        "    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n",
        "    y = w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2\n",
        "    z = w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2\n",
        "    return np.array([w, x, y, z])\n",
        "\n",
        "\n",
        "def stereo_project_point(point, axis=0, r=1, max_norm=10000):\n",
        "    point = fdiv(point * r, point[axis] + r)\n",
        "    point[axis] = 0\n",
        "    norm = get_norm(point)\n",
        "    if norm > max_norm:\n",
        "        point *= max_norm / norm\n",
        "    return point\n",
        "\n",
        "\n",
        "def stereo_project(mobject, axis=0, r=1, outer_r=10, **kwargs):\n",
        "    epsilon = 1\n",
        "    for submob in mobject.family_members_with_points():\n",
        "        points = submob.get_points()\n",
        "        n = len(points)\n",
        "        for i in range(n):\n",
        "            if points[i, axis] == -r:\n",
        "                js = it.chain(\n",
        "                    range(i + 1, n),\n",
        "                    range(i - 1, -1, -1)\n",
        "                )\n",
        "                for j in js:\n",
        "                    if points[j, axis] == -r:\n",
        "                        continue\n",
        "                    else:\n",
        "                        vect = points[j] - points[i]\n",
        "                        points[i] += epsilon * vect\n",
        "                        break\n",
        "        submob.apply_function(\n",
        "            lambda p: stereo_project_point(p, axis, r, **kwargs)\n",
        "        )\n",
        "\n",
        "        # If all points are outside a certain range, this\n",
        "        # shouldn't be displayed\n",
        "        norms = np.apply_along_axis(get_norm, 1, submob.get_points())\n",
        "        if np.all(norms > outer_r):\n",
        "            # TODO, instead set opacity?\n",
        "            # submob.get_points()[:, :] = 0\n",
        "            submob.set_fill(opacity=0)\n",
        "            submob.set_stroke(opacity=0)\n",
        "\n",
        "    return mobject\n",
        "\n",
        "\n",
        "class Linus(VGroup):\n",
        "    CONFIG = {\n",
        "        \"body_config\": {\n",
        "            \"stroke_width\": 15,\n",
        "            \"stroke_color\": GREY_B,\n",
        "            \"sheen\": 0.4,\n",
        "        },\n",
        "        \"height\": 2,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        self.body = self.get_body_line()\n",
        "        self.eyes = Eyes(self.body)\n",
        "\n",
        "        self.add(self.body, self.eyes)\n",
        "        self.set_height(self.height)\n",
        "        self.center()\n",
        "\n",
        "    def change_mode(self, mode, thing_to_look_at=None):\n",
        "        self.eyes.change_mode(mode, thing_to_look_at)\n",
        "        if mode == \"sad\":\n",
        "            self.become_squiggle()\n",
        "        elif mode == \"confused\":\n",
        "            self.become_squiggle(factor=-0.1)\n",
        "        elif mode == \"pleading\":\n",
        "            self.become_squiggle(factor=0.3)\n",
        "        else:\n",
        "            self.become_line()\n",
        "        return self\n",
        "\n",
        "    def change(self, *args, **kwargs):\n",
        "        self.change_mode(*args, **kwargs)\n",
        "        return self\n",
        "\n",
        "    def look_at(self, thing_to_look_at=None):\n",
        "        self.eyes.look_at(thing_to_look_at)\n",
        "        return self\n",
        "\n",
        "    def blink(self):\n",
        "        self.eyes.blink()\n",
        "        return self\n",
        "\n",
        "    def get_squiggle(self, factor=0.2):\n",
        "        sine_curve = FunctionGraph(\n",
        "            lambda x: factor * np.sin(x),\n",
        "            x_min=0, x_max=TAU,\n",
        "        )\n",
        "        sine_curve.rotate(TAU / 4)\n",
        "        sine_curve.match_style(self.body)\n",
        "        sine_curve.match_height(self.body)\n",
        "        sine_curve.move_to(self.body, UP)\n",
        "        return sine_curve\n",
        "\n",
        "    def get_body_line(self, **kwargs):\n",
        "        config = dict(self.body_config)\n",
        "        config.update(kwargs)\n",
        "        line = Line(ORIGIN, 1.5 * UP, **config)\n",
        "        if hasattr(self, \"body\"):\n",
        "            line.match_style(self.body)\n",
        "            line.match_height(self.body)\n",
        "            line.move_to(self.body, UP)\n",
        "        return line\n",
        "\n",
        "    def become_squiggle(self, **kwargs):\n",
        "        self.body.become(self.get_squiggle(**kwargs))\n",
        "        return self\n",
        "\n",
        "    def become_line(self, **kwargs):\n",
        "        self.body.become(self.get_body_line(**kwargs))\n",
        "        return self\n",
        "\n",
        "    def copy(self):\n",
        "        return self.deepcopy()\n",
        "\n",
        "\n",
        "class Felix(PiCreature):\n",
        "    CONFIG = {\n",
        "        \"color\": GREEN_D\n",
        "    }\n",
        "\n",
        "\n",
        "class PushPin(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"push_pin\",\n",
        "        \"height\": 0.5,\n",
        "        \"sheen\": 0.7,\n",
        "        \"fill_color\": GREY,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.rotate(20 * DEGREES)\n",
        "\n",
        "    def pin_to(self, point):\n",
        "        self.move_to(point, DR)\n",
        "\n",
        "\n",
        "class Hand(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"pinch_hand\",\n",
        "        \"height\": 0.5,\n",
        "        \"sheen\": 0.2,\n",
        "        \"fill_color\": ORANGE,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        # self.rotate(30 * DEGREES)\n",
        "        self.add(VectorizedPoint().next_to(self, UP, buff=0.17))\n",
        "\n",
        "\n",
        "class CheckeredCircle(Circle):\n",
        "    CONFIG = {\n",
        "        \"n_pieces\": 16,\n",
        "        \"colors\": [BLUE_E, BLUE_C],\n",
        "        \"stroke_width\": 5,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        Circle.__init__(self, **kwargs)\n",
        "        pieces = self.get_pieces(self.n_pieces)\n",
        "        self.set_points(np.zeros((0, 3)))\n",
        "        self.add(*pieces)\n",
        "        n_colors = len(self.colors)\n",
        "        for i, color in enumerate(self.colors):\n",
        "            self[i::n_colors].set_color(color)\n",
        "\n",
        "\n",
        "class StereoProjectedSphere(Sphere):\n",
        "    CONFIG = {\n",
        "        \"stereo_project_config\": {\n",
        "            \"axis\": 2,\n",
        "        },\n",
        "        \"max_r\": 32,\n",
        "        \"max_width\": FRAME_WIDTH,\n",
        "        \"max_height\": FRAME_WIDTH,\n",
        "        \"max_depth\": FRAME_WIDTH,\n",
        "        \"radius\": 1,\n",
        "    }\n",
        "\n",
        "    def __init__(self, rotation_matrix=None, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        if rotation_matrix is None:\n",
        "            rotation_matrix = np.identity(3)\n",
        "        self.rotation_matrix = rotation_matrix\n",
        "\n",
        "        self.stereo_project_config[\"r\"] = self.radius\n",
        "        ParametricSurface.__init__(\n",
        "            self, self.post_projection_func, **kwargs\n",
        "        )\n",
        "        self.submobjects.sort(\n",
        "            key=lambda m: -m.get_width()\n",
        "        )\n",
        "        self.fade_far_out_submobjects()\n",
        "\n",
        "    def post_projection_func(self, u, v):\n",
        "        point = self.radius * Sphere.func(self, u, v)\n",
        "        rot_point = np.dot(point, self.rotation_matrix.T)\n",
        "        result = stereo_project_point(\n",
        "            rot_point, **self.stereo_project_config\n",
        "        )\n",
        "        epsilon = 1e-4\n",
        "        if np.any(np.abs(result) == np.inf) or np.any(np.isnan(result)):\n",
        "            return self.func(u + epsilon, v)\n",
        "        return result\n",
        "\n",
        "    def fade_far_out_submobjects(self, **kwargs):\n",
        "        max_r = kwargs.get(\"max_r\", self.max_r)\n",
        "        max_width = kwargs.get(\"max_width\", self.max_width)\n",
        "        max_height = kwargs.get(\"max_height\", self.max_height)\n",
        "        max_depth = kwargs.get(\"max_depth\", self.max_depth)\n",
        "        for submob in self.submobjects:\n",
        "            violations = [\n",
        "                np.any(np.apply_along_axis(get_norm, 1, submob.get_anchors()) > max_r),\n",
        "                submob.get_width() > max_width,\n",
        "                submob.get_height() > max_height,\n",
        "                submob.get_depth() > max_depth\n",
        "            ]\n",
        "            if any(violations):\n",
        "                # self.remove(submob)\n",
        "                submob.fade(1)\n",
        "        return self\n",
        "\n",
        "\n",
        "class StereoProjectedSphereFromHypersphere(StereoProjectedSphere):\n",
        "    CONFIG = {\n",
        "        \"stereo_project_config\": {\n",
        "            \"axis\": 0,\n",
        "        },\n",
        "        \"radius\": 2,\n",
        "        \"multiply_from_right\": False,\n",
        "    }\n",
        "\n",
        "    def __init__(self, quaternion=None, null_axis=0, **kwargs):\n",
        "        if quaternion is None:\n",
        "            quaternion = np.array([1, 0, 0, 0])\n",
        "        self.quaternion = quaternion\n",
        "        self.null_axis = null_axis\n",
        "        ParametricSurface.__init__(self, self.q_mult_projection_func, **kwargs)\n",
        "        self.fade_far_out_submobjects()\n",
        "\n",
        "    def q_mult_projection_func(self, u, v):\n",
        "        point = list(Sphere.func(self, u, v))\n",
        "        point.insert(self.null_axis, 0)\n",
        "        if self.multiply_from_right:\n",
        "            post_q_mult = q_mult(point, self.quaternion)\n",
        "        else:\n",
        "            post_q_mult = q_mult(self.quaternion, point)\n",
        "        projected = list(self.radius * stereo_project_point(\n",
        "            post_q_mult, **self.stereo_project_config\n",
        "        ))\n",
        "        if np.any(np.abs(projected) == np.inf):\n",
        "            return self.func(u + 0.001, v)\n",
        "        ignored_axis = self.stereo_project_config[\"axis\"]\n",
        "        projected.pop(ignored_axis)\n",
        "        return np.array(projected)\n",
        "\n",
        "\n",
        "class StereoProjectedCircleFromHypersphere(CheckeredCircle):\n",
        "    CONFIG = {\n",
        "        \"n_pieces\": 48,\n",
        "        \"radius\": 2,\n",
        "        \"max_length\": 3 * FRAME_WIDTH,\n",
        "        \"max_r\": 50,\n",
        "        \"basis_vectors\": [\n",
        "            [1, 0, 0, 0],\n",
        "            [0, 1, 0, 0],\n",
        "        ],\n",
        "        \"multiply_from_right\": False,\n",
        "    }\n",
        "\n",
        "    def __init__(self, quaternion=None, **kwargs):\n",
        "        CheckeredCircle.__init__(self, **kwargs)\n",
        "        if quaternion is None:\n",
        "            quaternion = [1, 0, 0, 0]\n",
        "        self.quaternion = quaternion\n",
        "        self.pre_positioning_matrix = self.get_pre_positioning_matrix()\n",
        "        self.apply_function(self.projection)\n",
        "        self.remove_large_pieces()\n",
        "        self.set_shade_in_3d(True)\n",
        "\n",
        "    def get_pre_positioning_matrix(self):\n",
        "        v1, v2 = [np.array(v) for v in self.basis_vectors]\n",
        "        v1 = normalize(v1)\n",
        "        v2 = v2 - np.dot(v1, v2) * v1\n",
        "        v2 = normalize(v2)\n",
        "        return np.array([v1, v2]).T\n",
        "\n",
        "    def projection(self, point):\n",
        "        q1 = self.quaternion\n",
        "        q2 = np.dot(self.pre_positioning_matrix, point[:2]).flatten()\n",
        "        if self.multiply_from_right:\n",
        "            new_q = q_mult(q2, q1)\n",
        "        else:\n",
        "            new_q = q_mult(q1, q2)\n",
        "        projected = stereo_project_point(\n",
        "            new_q, axis=0, r=self.radius,\n",
        "        )\n",
        "        if np.any(projected == np.inf) or np.any(np.isnan(projected)):\n",
        "            epsilon = 1e-6\n",
        "            return self.projection(rotate_vector(point, epsilon))\n",
        "        return projected[1:]\n",
        "\n",
        "    def remove_large_pieces(self):\n",
        "        for piece in self:\n",
        "            length = get_norm(piece.get_points()[0] - piece.get_points()[-1])\n",
        "            violations = [\n",
        "                length > self.max_length,\n",
        "                get_norm(piece.get_center()) > self.max_r,\n",
        "            ]\n",
        "            if any(violations):\n",
        "                piece.fade(1)\n",
        "\n",
        "\n",
        "class QuaternionTracker(ValueTracker):\n",
        "    CONFIG = {\n",
        "        \"force_unit\": True,\n",
        "        \"dim\": 4,\n",
        "    }\n",
        "\n",
        "    def __init__(self, four_vector=None, **kwargs):\n",
        "        Mobject.__init__(self, **kwargs)\n",
        "        if four_vector is None:\n",
        "            four_vector = np.array([1, 0, 0, 0])\n",
        "        self.set_value(four_vector)\n",
        "        if self.force_unit:\n",
        "            self.add_updater(lambda q: q.normalize())\n",
        "\n",
        "    def set_value(self, vector):\n",
        "        self.set_points(np.array(vector).reshape((1, 4)))\n",
        "        return self\n",
        "\n",
        "    def get_value(self):\n",
        "        return self.get_points()[0]\n",
        "\n",
        "    def normalize(self):\n",
        "        self.set_value(normalize(\n",
        "            self.get_value(),\n",
        "            fall_back=np.array([1, 0, 0, 0])\n",
        "        ))\n",
        "        return self\n",
        "\n",
        "\n",
        "class RubiksCube(VGroup):\n",
        "    CONFIG = {\n",
        "        \"colors\": [\n",
        "            \"#FFD500\",  # Yellow\n",
        "            \"#C41E3A\",  # Orange\n",
        "            \"#009E60\",  # Green\n",
        "            \"#FF5800\",  # Red\n",
        "            \"#0051BA\",  # Blue\n",
        "            \"#FFFFFF\"   # White\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        vectors = [OUT, RIGHT, UP, LEFT, DOWN, IN]\n",
        "        faces = [\n",
        "            self.create_face(color, vector)\n",
        "            for color, vector in zip(self.colors, vectors)\n",
        "        ]\n",
        "        VGroup.__init__(self, *it.chain(*faces), **kwargs)\n",
        "        self.set_shade_in_3d(True)\n",
        "\n",
        "    def create_face(self, color, vector):\n",
        "        squares = VGroup(*[\n",
        "            self.create_square(color)\n",
        "            for x in range(9)\n",
        "        ])\n",
        "        squares.arrange_in_grid(\n",
        "            3, 3,\n",
        "            buff=0\n",
        "        )\n",
        "        squares.set_width(2)\n",
        "        squares.move_to(OUT, OUT)\n",
        "        squares.apply_matrix(z_to_vector(vector))\n",
        "        return squares\n",
        "\n",
        "    def create_square(self, color):\n",
        "        square = Square(\n",
        "            stroke_width=3,\n",
        "            stroke_color=BLACK,\n",
        "            fill_color=color,\n",
        "            fill_opacity=1,\n",
        "            side_length=1,\n",
        "        )\n",
        "        square.flip()\n",
        "        return square\n",
        "        # back = square.copy()\n",
        "        # back.set_fill(BLACK, 0.85)\n",
        "        # back.set_stroke(width=0)\n",
        "        # back.shift(0.5 * IN)\n",
        "        # return VGroup(square, back)\n",
        "\n",
        "    def get_face(self, vect):\n",
        "        self.sort(lambda p: np.dot(p, vect))\n",
        "        return self[-(12 + 9):]\n",
        "\n",
        "\n",
        "# Abstract scenes\n",
        "\n",
        "\n",
        "class ManyNumberSystems(Scene):\n",
        "    def construct(self):\n",
        "        # Too much dumb manually positioning in here...\n",
        "        title = Title(\"Number systems\")\n",
        "        name_location_color_example_tuples = [\n",
        "            (\"Reals\", [-4, 2, 0], YELLOW, \"1.414\"),\n",
        "            (\"Complex numbers\", [4, 0, 0], BLUE, \"2 + i\"),\n",
        "            (\"Quaternions\", [0, 2, 0], PINK, \"2 + 7i + 1j + 8k\"),\n",
        "            (\"Rationals\", [3, -2, 0], RED, \"1 \\\\over 3\"),\n",
        "            (\"p-adic numbers\", [-2, -2, 0], GREEN, \"\\\\overline{142857}2\"),\n",
        "            (\"Octonions\", [-3, 0, 0], GREY_B, \"3e_1 - 2.3e_2 + \\\\dots + 1.6e_8\"),\n",
        "        ]\n",
        "        systems = VGroup()\n",
        "        for name, location, color, ex in name_location_color_example_tuples:\n",
        "            system = OldTexText(name)\n",
        "            system.set_color(color)\n",
        "            system.move_to(location)\n",
        "            example = OldTex(ex)\n",
        "            example.next_to(system, DOWN)\n",
        "            system.add(example)\n",
        "            systems.add(system)\n",
        "        R_label, C_label, H_label = systems[:3]\n",
        "\n",
        "        number_line = NumberLine(x_min=-3, x_max=3)\n",
        "        number_line.add_numbers()\n",
        "        number_line.shift(0.25 * FRAME_WIDTH * LEFT)\n",
        "        number_line.shift(0.5 * DOWN)\n",
        "        R_example_dot = Dot(number_line.number_to_point(1.414))\n",
        "        plane = ComplexPlane(x_radius=3.5, y_radius=2.5)\n",
        "        plane.add_coordinates()\n",
        "        plane.shift(0.25 * FRAME_WIDTH * RIGHT)\n",
        "        plane.shift(0.5 * DOWN)\n",
        "        C_example_dot = Dot(plane.coords_to_point(2, 1))\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(FadeInFromLarge(H_label))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, VGroup(*it.chain(systems[:2], systems[3:])),\n",
        "            lambda m: (m, 4)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.add(number_line, plane, systems)\n",
        "        self.play(\n",
        "            R_label.move_to, 0.25 * FRAME_WIDTH * LEFT + 2 * UP,\n",
        "            C_label.move_to, 0.25 * FRAME_WIDTH * RIGHT + 2 * UP,\n",
        "            H_label.move_to, 0.75 * FRAME_WIDTH * RIGHT + 2 * UP,\n",
        "            FadeOut(systems[3:], 2 * DOWN),\n",
        "            Write(number_line),\n",
        "            Write(plane),\n",
        "            GrowFromCenter(R_example_dot),\n",
        "            R_label[-1].next_to, R_example_dot, UP,\n",
        "            GrowFromCenter(C_example_dot),\n",
        "            C_label[-1].next_to, C_example_dot, UR, SMALL_BUFF,\n",
        "            C_label[-1].shift, 0.4 * LEFT,\n",
        "        )\n",
        "        number_line.add(R_example_dot)\n",
        "        plane.add(C_example_dot)\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod,\n",
        "            VGroup(\n",
        "                H_label,\n",
        "                VGroup(plane, C_label),\n",
        "                VGroup(number_line, R_label),\n",
        "            ),\n",
        "            lambda m: (m.shift, 0.5 * FRAME_WIDTH * LEFT),\n",
        "            lag_ratio=0.8,\n",
        "        ))\n",
        "        randy = Randolph(height=1.5)\n",
        "        randy.next_to(plane, RIGHT)\n",
        "        randy.to_edge(DOWN)\n",
        "        self.play(\n",
        "            randy.change, \"maybe\", H_label,\n",
        "            VFadeIn(randy),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"confused\", H_label.get_top())\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotationsIn3d(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(**self.get_default_camera_position())\n",
        "        self.begin_ambient_camera_rotation(rate=0.02)\n",
        "        sphere = self.get_sphere()\n",
        "        vectors = VGroup(*[\n",
        "            Vector(u * v, color=color).next_to(sphere, u * v, buff=0)\n",
        "            for v, color in zip(\n",
        "                [RIGHT, UP, OUT],\n",
        "                [GREEN, RED, BLUE],\n",
        "            )\n",
        "            for u in [-1, 1]\n",
        "        ])\n",
        "        vectors.set_shade_in_3d(True)\n",
        "        sphere.add(vectors)\n",
        "\n",
        "        self.add(self.get_axes())\n",
        "        self.add(sphere)\n",
        "        angle_axis_pairs = [\n",
        "            (90 * DEGREES, RIGHT),\n",
        "            (120 * DEGREES, UR),\n",
        "            (-45 * DEGREES, OUT),\n",
        "            (60 * DEGREES, IN + DOWN),\n",
        "            (90 * DEGREES, UP),\n",
        "            (30 * DEGREES, UP + OUT + RIGHT),\n",
        "        ]\n",
        "        for angle, axis in angle_axis_pairs:\n",
        "            self.play(Rotate(\n",
        "                sphere, angle,\n",
        "                axis=axis,\n",
        "                run_time=2,\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class IntroduceHamilton(Scene):\n",
        "    def construct(self):\n",
        "        hamilton = ImageMobject(\"Hamilton\", height=6)\n",
        "        hamilton.to_corner(UL)\n",
        "        shamrock = SVGMobject(file_name=\"shamrock\")\n",
        "        shamrock.set_height(1)\n",
        "        shamrock.set_color(\"#009a49\")\n",
        "        shamrock.set_fill(opacity=0.25)\n",
        "        shamrock.next_to(hamilton.get_corner(UL), DR)\n",
        "        shamrock.align_to(hamilton, UP)\n",
        "        hamilton_name = OldTexText(\n",
        "            \"William Rowan Hamilton\"\n",
        "        )\n",
        "        hamilton_name.match_width(hamilton)\n",
        "        hamilton_name.next_to(hamilton, DOWN)\n",
        "\n",
        "        quote = OldTexText(\n",
        "            \"\"\"\\\\huge ...Every morning in the early part of the above-cited\n",
        "            month, on my coming down to breakfast, your (then)\n",
        "            little brother William Edwin, and yourself, used to\n",
        "            ask me,\"\"\",\n",
        "            \"``Well, Papa, can you multiply triplets''?\",\n",
        "            \"\"\"Whereto I was always obliged to reply, with a sad\n",
        "            shake of the head: ``No, I can only add and subtract\n",
        "            them.''...\"\"\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        quote.set_color_by_tex(\"Papa\", YELLOW)\n",
        "        quote = VGroup(*it.chain(*quote))\n",
        "        quote.set_width(FRAME_WIDTH - hamilton.get_width() - 2)\n",
        "        quote.to_edge(RIGHT)\n",
        "        quote_rect = SurroundingRectangle(quote, buff=MED_SMALL_BUFF)\n",
        "        quote_rect.set_stroke(WHITE, 2)\n",
        "        quote_rect.stretch(1.1, 1)\n",
        "        quote_label = OldTexText(\n",
        "            \"August 5, 1865 Letter\\\\\\\\from Hamilton to his son\"\n",
        "        )\n",
        "        quote_label.next_to(quote_rect, UP)\n",
        "        quote_label.set_color(BLUE)\n",
        "        VGroup(quote, quote_rect, quote_label).to_edge(UP)\n",
        "\n",
        "        plaque = ImageMobject(\"BroomBridgePlaque\")\n",
        "        plaque.set_width(FRAME_WIDTH / 2)\n",
        "        plaque.to_edge(LEFT)\n",
        "        plaque.shift(UP)\n",
        "        equation = OldTex(\n",
        "            \"i^2 = j^2 = k^2 = ijk = -1\",\n",
        "            tex_to_color_map={\"i\": GREEN, \"j\": RED, \"k\": BLUE}\n",
        "        )\n",
        "        equation_rect = Rectangle(width=3.25, height=0.7)\n",
        "        equation_rect.move_to(3.15 * LEFT + 0.25 * DOWN)\n",
        "        equation_rect.set_color(WHITE)\n",
        "        equation_arrow = Vector(DOWN)\n",
        "        equation_arrow.match_color(equation_rect)\n",
        "        equation_arrow.next_to(equation_rect, DOWN)\n",
        "        equation.next_to(equation_arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(hamilton),\n",
        "            Write(hamilton_name),\n",
        "        )\n",
        "        self.play(DrawBorderThenFill(shamrock))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, quote,\n",
        "                lag_ratio=0.2,\n",
        "                run_time=4\n",
        "            ),\n",
        "            FadeInFromDown(quote_label),\n",
        "            ShowCreation(quote_rect)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VGroup(hamilton, shamrock, hamilton_name).to_edge, RIGHT,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShiftDown, VGroup(*it.chain(\n",
        "                    quote, quote_rect, quote_label\n",
        "                ))\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(plaque))\n",
        "        self.play(\n",
        "            ShowCreation(equation_rect),\n",
        "            GrowArrow(equation_arrow)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            equation.copy().replace(equation_rect).fade(1),\n",
        "            equation\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class QuaternionHistory(Scene):\n",
        "    CONFIG = {\n",
        "        \"names_and_quotes\": [\n",
        "            (\n",
        "                \"Oliver Heaviside\",\n",
        "                \"\"\"\\\\huge ``As far as the vector analysis I required was\n",
        "                concerned, the quaternion was not only not\n",
        "                required, but was a positive evil of no\n",
        "                inconsiderable magnitude.''\"\"\"\n",
        "            ),\n",
        "            (\n",
        "                \"Lord Kelvin\",\n",
        "                \"\"\"\\\\huge ``Quaternions... though beautifully \\\\\\\\ ingenious,\n",
        "                have been an unmixed evil to those who have\n",
        "                touched them in any way, including Clerk Maxwell.''\"\"\"\n",
        "            ),\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_dot_product_and_cross_product()\n",
        "        self.teaching_students_quaternions()\n",
        "        self.show_anti_quaternion_quote()\n",
        "        self.mad_hatter()\n",
        "\n",
        "    def show_dot_product_and_cross_product(self):\n",
        "        date = OldTex(\"1843\")\n",
        "        date.scale(2)\n",
        "        date.to_edge(UP)\n",
        "\n",
        "        t2c = self.t2c = {\n",
        "            \"x_1\": GREEN,\n",
        "            \"x_2\": GREEN,\n",
        "            \"y_1\": RED,\n",
        "            \"y_2\": RED,\n",
        "            \"z_1\": BLUE,\n",
        "            \"z_2\": BLUE,\n",
        "        }\n",
        "\n",
        "        def get_colored_tex_mobject(tex):\n",
        "            return OldTex(tex, tex_to_color_map=t2c)\n",
        "\n",
        "        v1, v2 = [\n",
        "            Matrix([\n",
        "                [\"{}_{}\".format(c, i)]\n",
        "                for c in \"xyz\"\n",
        "            ], element_to_mobject=get_colored_tex_mobject)\n",
        "            for i in (1, 2)\n",
        "        ]\n",
        "        dot_rhs = get_colored_tex_mobject(\n",
        "            \"x_1 x_2 + y_1 y_2 + z_1 z_2\",\n",
        "        )\n",
        "        cross_rhs = Matrix([\n",
        "            [\"y_1 z_2 - z_1 y_2\"],\n",
        "            [\"z_1 x_2 - x_1 z_2\"],\n",
        "            [\"x_1 y_2 - y_1 x_2\"],\n",
        "        ], element_to_mobject=get_colored_tex_mobject)\n",
        "\n",
        "        dot_product = VGroup(\n",
        "            v1.copy(), OldTex(\"\\\\cdot\").scale(2),\n",
        "            v2.copy(), OldTex(\"=\"),\n",
        "            dot_rhs\n",
        "        )\n",
        "        cross_product = VGroup(\n",
        "            v1.copy(), OldTex(\"\\\\times\"),\n",
        "            v2.copy(), OldTex(\"=\"),\n",
        "            cross_rhs\n",
        "        )\n",
        "        for product in dot_product, cross_product:\n",
        "            product.arrange(RIGHT, buff=2 * SMALL_BUFF)\n",
        "            product.set_height(1.5)\n",
        "        dot_product.next_to(date, DOWN, buff=MED_LARGE_BUFF)\n",
        "        dot_product.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        cross_product.next_to(\n",
        "            dot_product, DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(dot_product, 2 * RIGHT))\n",
        "        self.play(FadeIn(cross_product, 2 * LEFT))\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(date))\n",
        "        self.play(ApplyMethod(dot_product.fade, 0.7))\n",
        "        self.play(ApplyMethod(cross_product.fade, 0.7))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dot_product, 2 * LEFT),\n",
        "            FadeOut(cross_product, 2 * RIGHT),\n",
        "        )\n",
        "\n",
        "        self.date = date\n",
        "\n",
        "    def teaching_students_quaternions(self):\n",
        "        hamilton = ImageMobject(\"Hamilton\")\n",
        "        hamilton.set_height(4)\n",
        "        hamilton.pixel_array = hamilton.pixel_array[:, ::-1, :]\n",
        "        hamilton.to_corner(UR)\n",
        "        hamilton.shift(MED_SMALL_BUFF * DOWN)\n",
        "\n",
        "        colors = color_gradient([BLUE_E, GREY_BROWN, BLUE_B], 7)\n",
        "        random.shuffle(colors)\n",
        "        students = VGroup(*[\n",
        "            PiCreature(color=color)\n",
        "            for color in colors\n",
        "        ])\n",
        "        students.set_height(2)\n",
        "        students.arrange(RIGHT)\n",
        "        students.set_width(FRAME_WIDTH - hamilton.get_width() - 1)\n",
        "        students.to_corner(DL)\n",
        "\n",
        "        equation = OldTex(\"\"\"\n",
        "            (x_1 i + y_1 j + z_1 k)\n",
        "            (x_2 i + y_2 j + z_2 k)\n",
        "            =\n",
        "            (-x_1 x_2 - y_1 y_2 - z_1 z_2) +\n",
        "            (y_1 z_2 - z_1 y_2)i +\n",
        "            (z_1 x_2 - x_1 z_2)j +\n",
        "            (x_1 y_2 - y_1 x_2)k\n",
        "        \"\"\", tex_to_color_map=self.t2c)\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        images = Group()\n",
        "        image_labels = VGroup()\n",
        "        images_with_labels = Group()\n",
        "        names = [\"Peter Tait\", \"Robert Ball\", \"Macfarlane Alexander\"]\n",
        "        for name in names:\n",
        "            image = ImageMobject(name)\n",
        "            image.set_height(3)\n",
        "            label = OldTexText(name)\n",
        "            label.scale(0.5)\n",
        "            label.next_to(image, DOWN)\n",
        "            image.label = label\n",
        "            image_labels.add(label)\n",
        "            images.add(image)\n",
        "            images_with_labels.add(Group(image, label))\n",
        "        images_with_labels.arrange(RIGHT)\n",
        "        images_with_labels.next_to(hamilton, LEFT, LARGE_BUFF)\n",
        "        images_with_labels.shift(MED_LARGE_BUFF * DOWN)\n",
        "        society_title = OldTexText(\"Quaternion society\")\n",
        "        society_title.next_to(images, UP, MED_LARGE_BUFF, UP)\n",
        "\n",
        "        def blink_wait(n_loops):\n",
        "            for x in range(n_loops):\n",
        "                self.play(Blink(random.choice(students)))\n",
        "                self.wait(random.random())\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(hamilton),\n",
        "            Write(\n",
        "                self.date,\n",
        "                rate_func=lambda t: smooth(1 - t),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, students,\n",
        "            lambda m: (m, LEFT),\n",
        "        ))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, students,\n",
        "                lambda pi: (\n",
        "                    pi.change,\n",
        "                    random.choice([\"confused\", \"maybe\", \"erm\"]),\n",
        "                    3 * LEFT + 2 * UP,\n",
        "                ),\n",
        "            ),\n",
        "            Write(equation),\n",
        "        )\n",
        "        blink_wait(3)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, images),\n",
        "            LaggedStartMap(FadeInFromLarge, image_labels),\n",
        "            Write(society_title)\n",
        "        )\n",
        "        blink_wait(3)\n",
        "        self.play(\n",
        "            FadeOut(hamilton, RIGHT),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShift, images_with_labels,\n",
        "                lambda m: (m, UP)\n",
        "            ),\n",
        "            FadeOut(students, DOWN),\n",
        "            FadeOut(society_title),\n",
        "            run_time=1\n",
        "        )\n",
        "\n",
        "        self.equation = equation\n",
        "\n",
        "    def show_anti_quaternion_quote(self):\n",
        "        group = self.get_dissenter_images_quotes_and_names()\n",
        "        images, quotes, names = group\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, images),\n",
        "            LaggedStartMap(FadeInFromLarge, names),\n",
        "            lag_ratio=0.75,\n",
        "            run_time=2,\n",
        "        )\n",
        "        for quote in quotes:\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, VGroup(*quote.family_members_with_points()),\n",
        "                lag_ratio=0.3\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(images_with_quotes))\n",
        "\n",
        "    def mad_hatter(self):\n",
        "        title = OldTexText(\n",
        "            \"Lewis Carroll's\", \"``Alice in wonderland''\"\n",
        "        )\n",
        "        title.to_edge(UP, buff=LARGE_BUFF)\n",
        "        author_brace = Brace(title[0], DOWN)\n",
        "        aka = OldTexText(\"a.k.a. Mathematician Charles Dodgson\")\n",
        "        aka.scale(0.8)\n",
        "        aka.set_color(BLUE)\n",
        "        aka.next_to(author_brace, DOWN)\n",
        "\n",
        "        quote = OldTexText(\n",
        "            \"\"\"\n",
        "                ``Why, you might just as well say that\\\\\\\\\n",
        "                \u2018I see what I eat\u2019 is the same thing as\\\\\\\\\n",
        "                \u2018I eat what I see\u2019!''\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"I see what I eat\": BLUE,\n",
        "                \"I eat what I see\": YELLOW,\n",
        "            },\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        quote.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        hatter = PiCreature(color=RED, mode=\"surprised\")\n",
        "        hat = SVGMobject(file_name=\"hat\")\n",
        "        hat_back = hat.copy()\n",
        "        hat_back[0].remove(*[\n",
        "            sm for sm in hat_back[0] if sm.is_subpath\n",
        "        ])\n",
        "        hat_back.set_fill(GREY_D)\n",
        "        hat.add_to_back(hat_back)\n",
        "        hat.set_height(1.25)\n",
        "        hat.next_to(hatter.body, UP, buff=-MED_SMALL_BUFF)\n",
        "        hatter.add(hat)\n",
        "        hatter.look(DL)\n",
        "        hatter.pupils[1].save_state()\n",
        "        hatter.look(UL)\n",
        "        hatter.pupils[1].restore()\n",
        "        hatter.set_height(2)\n",
        "\n",
        "        hare = SVGMobject(file_name=\"bunny\")\n",
        "        mouse = SVGMobject(file_name=\"mouse\")\n",
        "        for mob in hare, mouse:\n",
        "            mob.set_color(GREY_B)\n",
        "            mob.set_sheen(0.2, UL)\n",
        "            mob.set_height(1.5)\n",
        "\n",
        "        characters = VGroup(hatter, hare, mouse)\n",
        "        for mob, p in zip(characters, [UP, DL, DR]):\n",
        "            mob.move_to(p)\n",
        "        hare.shift(MED_SMALL_BUFF * LEFT)\n",
        "\n",
        "        characters.space_out_submobjects(1.5)\n",
        "        characters.to_edge(DOWN)\n",
        "\n",
        "        def change_single_place(char, **kwargs):\n",
        "            i = characters.submobjects.index(char)\n",
        "            target = characters[(i + 1) % 3]\n",
        "            return ApplyMethod(\n",
        "                char.move_to, target,\n",
        "                path_arc=-90 * DEGREES,\n",
        "                **kwargs\n",
        "            )\n",
        "\n",
        "        def get_change_places():\n",
        "            return LaggedStartMap(\n",
        "                change_single_place, characters,\n",
        "                lag_ratio=0.6\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            LaggedStartMap(FadeInFromDown, characters)\n",
        "        )\n",
        "        self.play(\n",
        "            get_change_places(),\n",
        "            GrowFromCenter(author_brace),\n",
        "            FadeIn(aka)\n",
        "        )\n",
        "        for x in range(4):\n",
        "            self.play(get_change_places())\n",
        "        self.play(\n",
        "            FadeOut(VGroup(title, author_brace, aka)),\n",
        "            FadeInFromDown(quote),\n",
        "        )\n",
        "        self.play(get_change_places())\n",
        "        self.play(\n",
        "            get_change_places(),\n",
        "            VFadeOut(characters, run_time=2)\n",
        "        )\n",
        "        self.remove(characters)\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_dissenter_images_quotes_and_names(self):\n",
        "        names_and_quotes = self.names_and_quotes\n",
        "        images = Group()\n",
        "        quotes = VGroup()\n",
        "        names = VGroup()\n",
        "        images_with_quotes = Group()\n",
        "        for name, quote_text in names_and_quotes:\n",
        "            image = Group(ImageMobject(name))\n",
        "            image.set_height(4)\n",
        "            label = OldTexText(name)\n",
        "            label.next_to(image, DOWN)\n",
        "            names.add(label)\n",
        "            quote = OldTexText(\n",
        "                quote_text,\n",
        "                tex_to_color_map={\n",
        "                    \"positive evil\": RED,\n",
        "                    \"unmixed evil\": RED,\n",
        "                },\n",
        "                alignment=\"\"\n",
        "            )\n",
        "            quote.scale(0.3)\n",
        "            quote.next_to(image, UP)\n",
        "            images.add(image)\n",
        "            quotes.add(quote)\n",
        "            images_with_quotes.add(Group(image, label, quote))\n",
        "\n",
        "        images_with_quotes.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        images_with_quotes.to_edge(DOWN, MED_LARGE_BUFF)\n",
        "        return Group(images, quotes, names)\n",
        "\n",
        "\n",
        "class QuaternionRotationOverlay(Scene):\n",
        "    def construct(self):\n",
        "        equations = VGroup(\n",
        "            OldTex(\n",
        "                \"p\", \"\\\\rightarrow\",\n",
        "                \"{}\",\n",
        "                \"{}\",\n",
        "                \"\\\\left(q_1\",\n",
        "                \"p\",\n",
        "                \"q_1^{-1}\\\\right)\",\n",
        "                \"{}\",\n",
        "                \"{}\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"p\", \"\\\\rightarrow\",\n",
        "                \"{}\",\n",
        "                \"\\\\left(q_2\",\n",
        "                \"\\\\left(q_1\",\n",
        "                \"p\",\n",
        "                \"q_1^{-1}\\\\right)\",\n",
        "                \"q_2^{-1}\\\\right)\",\n",
        "                \"{}\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"p\", \"\\\\rightarrow\",\n",
        "                \"\\\\left(q_3\",\n",
        "                \"\\\\left(q_2\",\n",
        "                \"\\\\left(q_1\",\n",
        "                \"p\",\n",
        "                \"q_1^{-1}\\\\right)\",\n",
        "                \"q_2^{-1}\\\\right)\",\n",
        "                \"q_3^{-1}\\\\right)\",\n",
        "            ),\n",
        "        )\n",
        "        for equation in equations:\n",
        "            equation.set_color_by_tex_to_color_map({\n",
        "                \"1\": GREEN, \"2\": RED, \"3\": BLUE,\n",
        "            })\n",
        "            equation.set_color_by_tex(\"rightarrow\", WHITE)\n",
        "            equation.to_corner(UL)\n",
        "\n",
        "        equation = equations[0].copy()\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "        for new_equation in equations[1:]:\n",
        "            self.play(\n",
        "                Transform(equation, new_equation)\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class RotateCubeThreeTimes(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        cube = RubiksCube()\n",
        "        cube.set_fill(opacity=0.8)\n",
        "        cube.set_stroke(width=1)\n",
        "        randy = Randolph(mode=\"pondering\")\n",
        "        randy.set_height(cube.get_height() - 2 * SMALL_BUFF)\n",
        "        randy.move_to(cube.get_edge_center(OUT))\n",
        "        randy.set_fill(opacity=0.8)\n",
        "        # randy.set_shade_in_3d(True)\n",
        "        cube.add(randy)\n",
        "        axes = self.get_axes()\n",
        "\n",
        "        self.add(axes, cube)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-140 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.02)\n",
        "        self.wait(2)\n",
        "        self.play(Rotate(cube, TAU / 4, RIGHT, run_time=3))\n",
        "        self.wait(2)\n",
        "        self.play(Rotate(cube, TAU / 4, UP, run_time=3))\n",
        "        self.wait(2)\n",
        "        self.play(Rotate(cube, -TAU / 3, np.ones(3), run_time=3))\n",
        "        self.wait(7)\n",
        "\n",
        "\n",
        "class QuantumSpin(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\"Two-state system\")\n",
        "\n",
        "        electron = Dot(color=BLUE)\n",
        "        electron.set_height(1)\n",
        "        electron.set_sheen(0.3, UL)\n",
        "        electron.set_fill(opacity=0.8)\n",
        "        kwargs = {\n",
        "            \"path_arc\": PI,\n",
        "        }\n",
        "        curved_arrows = VGroup(\n",
        "            Arrow(RIGHT, LEFT, **kwargs),\n",
        "            Arrow(LEFT, RIGHT, **kwargs),\n",
        "        )\n",
        "        curved_arrows.set_color(GREY_B)\n",
        "        curved_arrows.set_stroke(width=2)\n",
        "\n",
        "        y_arrow = Vector(UP)\n",
        "        y_arrow.set_color(RED)\n",
        "\n",
        "        y_ca = curved_arrows.copy()\n",
        "        y_ca.rotate(70 * DEGREES, LEFT)\n",
        "        y_group = VGroup(y_ca[0], y_arrow, electron.copy(), y_ca[1])\n",
        "\n",
        "        x_arrow = y_arrow.copy().rotate(90 * DEGREES, IN, about_point=ORIGIN)\n",
        "        x_arrow.set_color(GREEN)\n",
        "        x_ca = curved_arrows.copy()\n",
        "        x_ca.rotate(70 * DEGREES, UP)\n",
        "        x_group = VGroup(x_ca[0], x_arrow, electron.copy(), x_ca[1])\n",
        "\n",
        "        z_ca = curved_arrows.copy()\n",
        "        z_group = VGroup(electron.copy(), z_ca, Dot(color=BLUE))\n",
        "\n",
        "        groups = VGroup(x_group, y_group, z_group)\n",
        "        groups.arrange(RIGHT, buff=1.5)\n",
        "        groups.move_to(UP)\n",
        "\n",
        "        y_ca.rotation = Rotating(\n",
        "            y_ca, axis=rotate_vector(OUT, 70 * DEGREES, LEFT)\n",
        "        )\n",
        "        x_ca.rotation = Rotating(\n",
        "            x_ca, axis=rotate_vector(OUT, 70 * DEGREES, UP)\n",
        "        )\n",
        "        z_ca.rotation = Rotating(z_ca, axis=OUT)\n",
        "        rotations = [ca.rotation for ca in [x_ca, y_ca, z_ca]]\n",
        "\n",
        "        matrices = VGroup(\n",
        "            Matrix([[\"0\", \"1\"], [\"1\", \"0\"]]),\n",
        "            Matrix([[\"0\", \"-i\"], [\"i\", \"0\"]]),\n",
        "            Matrix([[\"1\", \"0\"], [\"0\", \"-1\"]]),\n",
        "        )\n",
        "        for matrix, group in zip(matrices, groups):\n",
        "            matrix.next_to(group, DOWN)\n",
        "        for matrix in matrices[1:]:\n",
        "            matrix.align_to(matrices[0], DOWN)\n",
        "\n",
        "        self.add(title, groups)\n",
        "        self.play()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, matrices, run_time=3),\n",
        "            *rotations\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(*rotations)\n",
        "\n",
        "\n",
        "class HereWeTackle4d(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        titles = VGroup(\n",
        "            OldTexText(\n",
        "                \"This video:\\\\\\\\\",\n",
        "                \"Quaternions in 4d\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"Next video:\\\\\\\\\",\n",
        "                \"Quaternions acting on 3d\"\n",
        "            )\n",
        "        )\n",
        "        for title in titles:\n",
        "            title.move_to(self.hold_up_spot, DOWN)\n",
        "        titles[0].set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(titles[0]),\n",
        "            self.change_students(\"confused\", \"horrified\", \"sad\")\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait()\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"thinking\", \"pondering\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"confused\", \"happy\"\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            self.teacher.change, \"hooray\",\n",
        "            FadeIn(titles[1]),\n",
        "            ApplyMethod(\n",
        "                titles[0].shift, 2 * UP,\n",
        "                rate_func=squish_rate_func(smooth, 0.2, 1)\n",
        "            )\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "        self.play_student_changes(\"pondering\", \"happy\", \"thinking\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TableOfContents(Scene):\n",
        "    def construct(self):\n",
        "        chapters = VGroup(\n",
        "            OldTexText(\n",
        "                \"\\\\underline{Chapter 1}\\\\\\\\\", \"Linus the Linelander\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"\\\\underline{Chapter 2}\\\\\\\\\", \"Felix the Flatlander\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"\\\\underline{Chapter 3}\\\\\\\\\", \" You, the 3d-lander\"\n",
        "            ),\n",
        "        )\n",
        "        for chapter in chapters:\n",
        "            chapter.space_out_submobjects(1.5)\n",
        "        chapters.arrange(\n",
        "            DOWN, buff=1.5, aligned_edge=LEFT\n",
        "        )\n",
        "        chapters.to_edge(LEFT)\n",
        "\n",
        "        for chapter in chapters:\n",
        "            self.play(FadeInFromDown(chapter))\n",
        "            self.wait(2)\n",
        "        for chapter in chapters:\n",
        "            chapters.save_state()\n",
        "            other_chapters = VGroup(*[\n",
        "                c for c in chapters if c is not chapter\n",
        "            ])\n",
        "            self.play(\n",
        "                chapter.set_width, 0.5 * FRAME_WIDTH,\n",
        "                chapter.center,\n",
        "                other_chapters.fade, 1\n",
        "            )\n",
        "            self.wait(3)\n",
        "            self.play(chapters.restore)\n",
        "\n",
        "\n",
        "class IntroduceLinusTheLinelander(Scene):\n",
        "    def construct(self):\n",
        "        self.introduce_linus()\n",
        "        self.show_real_number_line()\n",
        "        self.look_at_complex_plane()\n",
        "\n",
        "    def introduce_linus(self):\n",
        "        linus = Linus()\n",
        "        linus.move_to(3 * LEFT)\n",
        "        name = OldTexText(\"Linus the Linelander\")\n",
        "        name.next_to(linus, DR, buff=MED_LARGE_BUFF)\n",
        "        arrow = Arrow(name.get_top(), linus.get_right())\n",
        "\n",
        "        self.play(FadeInFromDown(linus))\n",
        "        self.play(\n",
        "            Write(name),\n",
        "            GrowArrow(arrow),\n",
        "            linus.change, \"gracious\", name,\n",
        "        )\n",
        "        self.play(\n",
        "            linus.become_squiggle, {\"factor\": -0.1},\n",
        "        )\n",
        "        self.play(Blink(linus))\n",
        "        self.wait()\n",
        "\n",
        "        self.name_text = name\n",
        "        self.name_arrow = arrow\n",
        "        self.linus = linus\n",
        "\n",
        "    def show_real_number_line(self):\n",
        "        linus = self.linus\n",
        "        number_line = NumberLine()\n",
        "        number_line.add_numbers()\n",
        "        number_line.to_edge(UP)\n",
        "\n",
        "        algebra = VGroup(\n",
        "            OldTex(\"3 \\\\cdot 4 = 12\"),\n",
        "            OldTex(\"3 + 4 = 7\"),\n",
        "            OldTex(\"(-2) \\\\cdot 3 = -6\"),\n",
        "        )\n",
        "        algebra.arrange(DOWN)\n",
        "        algebra.next_to(number_line, DOWN, LARGE_BUFF)\n",
        "        algebra.shift(3 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(number_line),\n",
        "            linus.look_at, number_line\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, number_line.numbers),\n",
        "            LaggedStartMap(ShowCreation, number_line.tick_marks),\n",
        "            linus.change, \"happy\"\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, algebra),\n",
        "            linus.look_at, algebra\n",
        "        )\n",
        "        self.play(Blink(linus))\n",
        "        self.wait()\n",
        "\n",
        "        self.algebra = algebra\n",
        "\n",
        "    def look_at_complex_plane(self):\n",
        "        linus = self.linus\n",
        "        to_fade = VGroup(\n",
        "            self.name_text,\n",
        "            self.name_arrow,\n",
        "            self.algebra,\n",
        "        )\n",
        "        frame = ScreenRectangle()\n",
        "        frame.set_width(8)\n",
        "        frame.to_corner(DR)\n",
        "\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"?\").shift(\n",
        "                random.random() * RIGHT,\n",
        "                random.random() * UP,\n",
        "            )\n",
        "            for x in range(50)\n",
        "        ])\n",
        "        q_marks.next_to(linus.body, UP, buff=0)\n",
        "        q_marks.set_color_by_gradient(BLUE, GREEN, YELLOW)\n",
        "        random.shuffle(q_marks.submobjects)\n",
        "        q_marks_anim = LaggedStartMap(\n",
        "            FadeIn, q_marks,\n",
        "            run_time=15,\n",
        "            rate_func=there_and_back,\n",
        "            lag_ratio=0.1\n",
        "        )\n",
        "        q_marks_continual = turn_animation_into_updater(q_marks_anim)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            ShowCreation(frame),\n",
        "            linus.look_at, frame\n",
        "        )\n",
        "        self.add(q_marks_continual)\n",
        "        self.play(linus.change_mode, \"confused\")\n",
        "        self.wait()\n",
        "        self.play(Blink(linus))\n",
        "        self.play(linus.change, \"confused\", frame.get_bottom())\n",
        "        self.wait()\n",
        "        self.play(linus.change, \"sad\", frame.get_center())\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ShowComplexMultiplicationExamples(Scene):\n",
        "    CONFIG = {\n",
        "        \"plane_config\": {\n",
        "            \"x_radius\": 9,\n",
        "            \"y_radius\": 9,\n",
        "            \"stroke_width\": 3,\n",
        "        },\n",
        "        \"background_plane_config\": {\n",
        "            \"color\": GREY_B,\n",
        "            \"secondary_color\": GREY_D,\n",
        "            \"stroke_width\": 0.5,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "            \"secondary_line_ratio\": 0,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_planes()\n",
        "        z_tuples = [\n",
        "            (complex(2, 1), \"2 + i\", UP),\n",
        "            (complex(5, 2), \"5 + 2i\", LEFT),\n",
        "            (\n",
        "                complex(-np.sqrt(2) / 2, np.sqrt(2) / 2),\n",
        "                \"-\\\\frac{\\\\sqrt{2}}{2} + \\\\frac{\\\\sqrt{2}}{2} i\",\n",
        "                LEFT,\n",
        "            ),\n",
        "            (complex(-4, 1.5), \"-4 + 1.5i\", RIGHT),\n",
        "            (complex(3, 0), \"3 + 0i\", UP),\n",
        "            (complex(4, -3), \"4 + -3i\", UP),\n",
        "        ]\n",
        "\n",
        "        for z, z_tex, label_vect in z_tuples:\n",
        "            self.show_multiplication(z, z_tex, label_vect)\n",
        "\n",
        "    def add_planes(self, include_title=True):\n",
        "        plane = ComplexPlane(**self.plane_config)\n",
        "        self.plane = plane\n",
        "        background_plane = ComplexPlane(**self.background_plane_config)\n",
        "        background_plane.add_coordinates()\n",
        "        self.background_plane = background_plane\n",
        "\n",
        "        self.add(background_plane)\n",
        "        self.add(plane)\n",
        "\n",
        "        if include_title:\n",
        "            title = OldTexText(\"Complex plane\")\n",
        "            title.scale(1.5)\n",
        "            title.to_corner(UL, buff=MED_LARGE_BUFF)\n",
        "            title.shift(SMALL_BUFF * UR)\n",
        "            self.title = title\n",
        "            self.add_foreground_mobjects(title)\n",
        "\n",
        "    def show_multiplication(self, z, z_tex, label_vect):\n",
        "        z_color = WHITE\n",
        "        plane = self.plane\n",
        "        new_plane = plane.deepcopy()\n",
        "        real_tex, imag_tex = z_tex.split(\"+\")\n",
        "        label = OldTex(\n",
        "            \"\\\\text{Multiply by}\\\\\\\\\",\n",
        "            real_tex, \"+\", imag_tex,\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        label[1].set_color(GREEN)\n",
        "        label[3].set_color(RED)\n",
        "        label.scale(1.2)\n",
        "\n",
        "        h_line = Line(\n",
        "            plane.number_to_point(0),\n",
        "            plane.number_to_point(z.real),\n",
        "            color=GREEN,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "        v_line = Line(\n",
        "            plane.number_to_point(z.real),\n",
        "            plane.number_to_point(z),\n",
        "            color=RED,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "        lines = VGroup(h_line, v_line)\n",
        "\n",
        "        z_point = plane.number_to_point(z)\n",
        "        z_dot = Dot(z_point)\n",
        "        z_dot.set_color(z_color)\n",
        "        label[1:].next_to(z_dot, label_vect)\n",
        "        label[0].next_to(label[1:], UP)\n",
        "        for mob in label:\n",
        "            label.add_to_back(BackgroundRectangle(mob))\n",
        "\n",
        "        one_dot = Dot(plane.number_to_point(1))\n",
        "        one_dot.set_color(YELLOW)\n",
        "        for dot in z_dot, one_dot:\n",
        "            dot.save_state()\n",
        "            dot.scale(5)\n",
        "            dot.set_fill(opacity=0)\n",
        "            dot.set_stroke(width=1, opacity=0.5)\n",
        "        to_fade_out = VGroup(\n",
        "            plane, label, lines, z_dot, one_dot\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lines),\n",
        "            FadeInFromDown(label),\n",
        "            Restore(z_dot),\n",
        "        )\n",
        "        self.play(Restore(one_dot))\n",
        "        angle = np.log(z).imag\n",
        "        self.play(\n",
        "            one_dot.move_to, z_dot,\n",
        "            plane.apply_complex_function, lambda w: z * w,\n",
        "            path_arc=angle,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(to_fade_out),\n",
        "            FadeIn(new_plane),\n",
        "        )\n",
        "        self.plane = new_plane\n",
        "\n",
        "\n",
        "class DefineComplexNumbersPurelyAlgebraically(Scene):\n",
        "    def construct(self):\n",
        "        self.add_linus()\n",
        "        self.add_title()\n",
        "        self.show_example_number()\n",
        "        self.show_multiplication()\n",
        "        self.emphsize_result_has_same_form()\n",
        "\n",
        "    def add_linus(self):\n",
        "        linus = self.linus = Linus()\n",
        "        linus.move_to(3 * LEFT)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = Title(\n",
        "            \"No spatial reasoning, just symbols\"\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(title[:-1]),\n",
        "            ShowCreation(title[-1]),\n",
        "            self.linus.look_at, title\n",
        "        )\n",
        "\n",
        "    def show_example_number(self):\n",
        "        linus = self.linus\n",
        "\n",
        "        number = OldTex(\"2.35\", \"+\", \"3.14\", \"i\")\n",
        "        number.next_to(self.title, DOWN, buff=1.5)\n",
        "        number.shift(3 * RIGHT)\n",
        "        real, imag = number[0], number[2]\n",
        "        real_brace = Brace(real, UP)\n",
        "        imag_brace = Brace(imag, DOWN)\n",
        "        real_label = real_brace.get_text(\"Some real number\")\n",
        "        imag_label = imag_brace.get_text(\"Some other real number\")\n",
        "        VGroup(real, real_label).set_color(GREEN)\n",
        "        VGroup(imag, imag_label).set_color(RED)\n",
        "\n",
        "        i = number[-1]\n",
        "        i_def = OldTex(\"i\", \"^2\", \"=\", \"-1\")\n",
        "        i_def.next_to(\n",
        "            self.title, DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        i_def_rect = SurroundingRectangle(i_def, color=YELLOW, buff=MED_SMALL_BUFF)\n",
        "        definition_label = OldTexText(\"Definition\")\n",
        "        definition_label.next_to(i_def_rect, DOWN)\n",
        "        definition_label.match_color(i_def_rect)\n",
        "\n",
        "        self.play(Write(number, run_time=1))\n",
        "        self.play(\n",
        "            GrowFromCenter(real_brace),\n",
        "            LaggedStartMap(FadeIn, real_label),\n",
        "            linus.change, \"confused\", number,\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(imag_brace),\n",
        "            LaggedStartMap(FadeIn, imag_label),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(Blink(linus))\n",
        "        self.play(\n",
        "            linus.change, \"erm\", i_def,\n",
        "            ReplacementTransform(\n",
        "                i.copy(), i_def[0],\n",
        "                path_arc=-30 * DEGREES\n",
        "            ),\n",
        "            FadeIn(i_def_rect),\n",
        "            FadeIn(definition_label),\n",
        "        )\n",
        "        self.play(Write(i_def[1:]))\n",
        "        self.wait()\n",
        "        self.play(Blink(linus))\n",
        "\n",
        "        self.to_fade = VGroup(\n",
        "            real_brace, real_label,\n",
        "            imag_brace, imag_label,\n",
        "        )\n",
        "        self.number = number\n",
        "\n",
        "    def show_multiplication(self):\n",
        "        linus = self.linus\n",
        "        to_fade = self.to_fade\n",
        "        z1 = self.number\n",
        "\n",
        "        z2 = OldTex(\"4\", \"+\", \"5\", \"i\")\n",
        "        z2.match_style(z1)\n",
        "\n",
        "        for z in z1, z2:\n",
        "            lp, rp = z.parens = OldTex(\"()\")\n",
        "            lp.next_to(z, LEFT, SMALL_BUFF)\n",
        "            rp.next_to(z, RIGHT, SMALL_BUFF)\n",
        "            z.real = z[0]\n",
        "            z.imag = z[2:]\n",
        "            for part in z.real, z.imag:\n",
        "                part.targets = [part.copy(), part.copy()]\n",
        "\n",
        "        z1.generate_target()\n",
        "        product = VGroup(\n",
        "            VGroup(z1.target, z1.parens),\n",
        "            VGroup(z2, z2.parens),\n",
        "        )\n",
        "        product.arrange(RIGHT, SMALL_BUFF)\n",
        "        product.move_to(2 * RIGHT + 2 * UP)\n",
        "\n",
        "        foil = VGroup(*map(TexText, [\n",
        "            \"First\", \"Outside\", \"Inside\", \"Last\",\n",
        "        ]))\n",
        "        foil.arrange(\n",
        "            DOWN, buff=MED_SMALL_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        foil.scale(1.25)\n",
        "        for word in foil:\n",
        "            word[0].set_color(BLUE)\n",
        "        foil.move_to(product).to_edge(DOWN, LARGE_BUFF)\n",
        "\n",
        "        def get_cdot():\n",
        "            return OldTex(\"\\\\cdot\")\n",
        "\n",
        "        def get_lp():\n",
        "            return OldTex(\"(\")\n",
        "\n",
        "        def get_rp():\n",
        "            return OldTex(\")\")\n",
        "\n",
        "        def get_plus():\n",
        "            return OldTex(\"+\")\n",
        "\n",
        "        expansion = VGroup(\n",
        "            z1.real.targets[0], get_cdot(), z2.real.targets[0], get_plus(),\n",
        "            z1.real.targets[1], get_cdot(), z2.imag.targets[0], get_plus(),\n",
        "            z1.imag.targets[0], get_cdot(), z2.real.targets[1], get_plus(),\n",
        "            z1.imag.targets[1], get_cdot(), z2.imag.targets[1],\n",
        "        )\n",
        "        expansion.arrange(RIGHT, buff=0.15)\n",
        "        expansion.next_to(product, DOWN, buff=LARGE_BUFF)\n",
        "        expansion_parts = VGroup(*[\n",
        "            expansion[4 * i: 4 * i + 3]\n",
        "            for i in range(4)\n",
        "        ])\n",
        "        expansion_part_braces = VGroup(*[\n",
        "            Brace(part, DOWN) for part in expansion_parts\n",
        "        ])\n",
        "        for word, brace in zip(foil, expansion_part_braces):\n",
        "            word.next_to(brace, DOWN)\n",
        "\n",
        "        final_prouct = VGroup(\n",
        "            get_lp(),\n",
        "            z1[0].copy(), get_cdot(), z2[0].copy(),\n",
        "            OldTex(\"-\"),\n",
        "            z1[2].copy(), get_cdot(), z2[2].copy(),\n",
        "            get_rp(), get_plus(),\n",
        "            get_lp(),\n",
        "            z1[0].copy(), get_cdot(), z2[2].copy(),\n",
        "            get_plus(),\n",
        "            z1[2].copy(), get_cdot(), z2[0].copy(),\n",
        "            get_rp(), OldTex(\"i\")\n",
        "        )\n",
        "        final_prouct.arrange(RIGHT, buff=0.15)\n",
        "        final_prouct.next_to(expansion, DOWN, buff=2)\n",
        "        final_arrows = VGroup()\n",
        "        for i, brace in zip([1, 11, 15, 5], expansion_part_braces):\n",
        "            target = final_prouct[i:i + 3]\n",
        "            if i == 5:\n",
        "                arrow = Line(\n",
        "                    brace.get_bottom() + SMALL_BUFF * DOWN,\n",
        "                    target.get_top() + MED_SMALL_BUFF * UP,\n",
        "                )\n",
        "                arrow.get_points()[1] = arrow.get_points()[0] + DOWN\n",
        "                arrow.get_points()[2] = arrow.get_points()[3] + UP\n",
        "                tip = RegularPolygon(3, start_angle=-100 * DEGREES)\n",
        "                tip.set_height(0.2)\n",
        "                tip.set_stroke(width=0)\n",
        "                tip.set_fill(WHITE, opacity=1)\n",
        "                tip.move_to(arrow.get_end())\n",
        "                arrow.add(tip)\n",
        "            else:\n",
        "                arrow = Arrow(\n",
        "                    brace.get_bottom(),\n",
        "                    target.get_top(),\n",
        "                )\n",
        "            final_arrows.add(arrow)\n",
        "        final_arrows.set_stroke(BLACK, width=6, background=True)\n",
        "\n",
        "        # Move example number into product\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            MoveToTarget(z1),\n",
        "            FadeIn(z1.parens),\n",
        "            FadeInFromDown(z2),\n",
        "            FadeIn(z2.parens),\n",
        "            linus.change, \"happy\", product,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show distribution\n",
        "        pairs = list(it.product([z1.real, z1.imag], [z2.real, z2.imag]))\n",
        "        for i in range(4):\n",
        "            left, right = pair = VGroup(*pairs[i])\n",
        "            word = foil[i]\n",
        "            dot = expansion[4 * i + 1]\n",
        "            plus = expansion[4 * i + 3] if i < 3 else VMobject()\n",
        "            brace = expansion_part_braces[i]\n",
        "\n",
        "            self.play(pair.shift, 0.5 * DOWN)\n",
        "            self.play(\n",
        "                FadeIn(dot),\n",
        "                GrowFromCenter(brace),\n",
        "                FadeInFromDown(word),\n",
        "                linus.move_to, 4 * LEFT + DOWN,\n",
        "                *[\n",
        "                    ReplacementTransform(\n",
        "                        part.copy(),\n",
        "                        part.targets.pop(0)\n",
        "                    )\n",
        "                    for part in pair\n",
        "                ]\n",
        "            )\n",
        "            self.play(\n",
        "                pair.shift, 0.5 * UP,\n",
        "                FadeIn(plus)\n",
        "            )\n",
        "        self.play(Blink(linus))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(foil),\n",
        "            FadeInFromDown(final_prouct),\n",
        "            linus.look_at, final_prouct,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, final_arrows),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(linus.change, \"confused\")\n",
        "        self.wait()\n",
        "\n",
        "        self.final_prouct = final_prouct\n",
        "\n",
        "    def emphsize_result_has_same_form(self):\n",
        "        final_product = self.final_prouct\n",
        "        real = final_product[1:1 + 7]\n",
        "        imag = final_product[11:11 + 7]\n",
        "\n",
        "        real_brace = Brace(real, DOWN)\n",
        "        real_label = real_brace.get_text(\"Some real number\")\n",
        "        real_label.set_color(GREEN)\n",
        "        imag_brace = Brace(imag, DOWN)\n",
        "        imag_label = imag_brace.get_text(\n",
        "            \"Some other \\\\\\\\ real number\"\n",
        "        )\n",
        "        imag_label.set_color(RED)\n",
        "        braces = VGroup(real_brace, imag_brace)\n",
        "        labels = VGroup(real_label, imag_label)\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces),\n",
        "            LaggedStartMap(Write, labels),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TextbookQuaternionDefinition(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"\"\"\n",
        "            (w_1 + x_1 i + y_1 j + z_1 k)\n",
        "            (w_2 + x_2 i + y_2 j + z_2 k) =\n",
        "            &(w_1 w_2 - x_1 x_2 - y_1 y_2 - z_1 z_2) \\\\, +\\\\\\\\\n",
        "            &(w_1 x_2 + x_1 w_2 + y_1 z_2 - z_1 y_2)i \\\\, +\\\\\\\\\n",
        "            &(w_1 y_2 + y_1 w_2 + z_1 x_2 - x_1 z_2)j \\\\, +\\\\\\\\\n",
        "            &(w_1 z_2 + z_1 w_2 + x_1 y_2 - y_1 x_2)k \\\\\\\\\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"w_1\": YELLOW,\n",
        "                \"w_2\": YELLOW,\n",
        "                \"x_1\": GREEN,\n",
        "                \"x_2\": GREEN,\n",
        "                \"y_1\": RED,\n",
        "                \"y_2\": RED,\n",
        "                \"z_1\": BLUE,\n",
        "                \"z_2\": BLUE,\n",
        "            }\n",
        "        )\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        defining_products = VGroup(*[\n",
        "            OldTex(\n",
        "                tex,\n",
        "                tex_to_color_map={\n",
        "                    \"i\": GREEN,\n",
        "                    \"j\": RED,\n",
        "                    \"k\": BLUE,\n",
        "                }\n",
        "            )\n",
        "            for tex in [\n",
        "                \"i^2 = j^2 = k^2 = -1\",\n",
        "                \"ij = -ji = k\",\n",
        "                \"ki = -ik = j\",\n",
        "                \"jk = -kj = i\",\n",
        "            ]\n",
        "        ])\n",
        "        defining_products.arrange(DOWN)\n",
        "        defining_products.next_to(self.students, UP, LARGE_BUFF)\n",
        "        def_rect = SurroundingRectangle(defining_products)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, defining_products),\n",
        "            self.change_students(*3 * [\"confused\"]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(ShowCreation(def_rect))\n",
        "        self.play(\n",
        "            Write(equation, run_time=4, lag_ratio=0.2),\n",
        "            self.change_students(\n",
        "                \"horrified\", \"pleading\", \"sick\",\n",
        "                equation\n",
        "            ),\n",
        "            self.teacher.change, \"erm\", equation,\n",
        "        )\n",
        "        self.blink()\n",
        "        self.look_at(equation.get_corner(UL))\n",
        "        self.blink()\n",
        "        self.look_at(equation.get_corner(UR))\n",
        "        self.play(self.teacher.change, \"sassy\", equation)\n",
        "        self.wait(2)\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.look_at(equation)\n",
        "        self.wait()\n",
        "        self.play(self.teacher.change, \"thinking\", equation)\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class ProblemsWhereComplexNumbersArise(Scene):\n",
        "    def construct(self):\n",
        "        text = \"Problems where complex numbers are surprisingly useful\"\n",
        "        title = OldTexText(*text.split(\" \"))\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(BLUE)\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.set_width(title.get_width() + 0.5)\n",
        "        underline.next_to(title, DOWN)\n",
        "\n",
        "        problems = VGroup(\n",
        "            OldTexText(\n",
        "                \"Integer solutions to\\\\\\\\ $a^2 + b^2 = c^2$\",\n",
        "                alignment=\"\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"Understanding\\\\\\\\\",\n",
        "                \"$1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\" +\n",
        "                \"=\\\\frac{\\\\pi}{4}$\",\n",
        "                alignment=\"\",\n",
        "            ),\n",
        "            OldTexText(\"Frequency analysis\")\n",
        "        )\n",
        "        problems.arrange(\n",
        "            DOWN, buff=LARGE_BUFF, aligned_edge=LEFT\n",
        "        )\n",
        "        for problem in problems:\n",
        "            problems.add(Dot().next_to(problem[0], LEFT))\n",
        "        problems.next_to(underline, DOWN, buff=MED_LARGE_BUFF)\n",
        "        problems.to_edge(LEFT)\n",
        "        v_dots = OldTex(\"\\\\vdots\")\n",
        "        v_dots.scale(2)\n",
        "        v_dots.next_to(problems, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(problems, v_dots)\n",
        "        self.play(\n",
        "            ShowCreation(underline),\n",
        "            LaggedStartMap(FadeInFromDown, title, lag_ratio=0.5),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WalkThroughComplexMultiplication(ShowComplexMultiplicationExamples):\n",
        "    CONFIG = {\n",
        "        \"z\": complex(2, 3),\n",
        "        \"w\": complex(1, -1),\n",
        "        \"z_color\": YELLOW,\n",
        "        \"w_color\": PINK,\n",
        "        \"product_color\": RED,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_planes(include_title=False)\n",
        "        self.introduce_z_and_w()\n",
        "        self.show_action_on_all_complex_numbers()\n",
        "\n",
        "    def introduce_z_and_w(self):\n",
        "        # Tolerating code repetition here in case I want\n",
        "        # to specialize behavior for z or w...\n",
        "        plane = self.plane\n",
        "        origin = plane.number_to_point(0)\n",
        "\n",
        "        z_point = plane.number_to_point(self.z)\n",
        "        z_dot = Dot(z_point)\n",
        "        z_line = Line(origin, z_point)\n",
        "        z_label = VGroup(\n",
        "            OldTex(\"z=\"),\n",
        "            DecimalNumber(self.z, num_decimal_places=0)\n",
        "        )\n",
        "        z_label.arrange(\n",
        "            RIGHT, buff=SMALL_BUFF,\n",
        "        )\n",
        "        z_label.next_to(z_dot, UP, buff=SMALL_BUFF)\n",
        "        z_label.set_color(self.z_color)\n",
        "        z_label.add_background_rectangle()\n",
        "        VGroup(z_line, z_dot).set_color(self.z_color)\n",
        "\n",
        "        w_point = plane.number_to_point(self.w)\n",
        "        w_dot = Dot(w_point)\n",
        "        w_line = Line(origin, w_point)\n",
        "        w_label = VGroup(\n",
        "            OldTex(\"w=\"),\n",
        "            DecimalNumber(self.w, num_decimal_places=0)\n",
        "        )\n",
        "        w_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        w_label.next_to(w_dot, DOWN, buff=SMALL_BUFF)\n",
        "        w_label.set_color(self.w_color)\n",
        "        w_label.add_background_rectangle()\n",
        "        VGroup(w_line, w_dot).set_color(self.w_color)\n",
        "\n",
        "        VGroup(\n",
        "            z_label[1], w_label[1]\n",
        "        ).shift(0.25 * SMALL_BUFF * DOWN)\n",
        "\n",
        "        product = OldTex(\"z\", \"\\\\cdot\", \"w\")\n",
        "        z_sym, w_sym = product[0], product[2]\n",
        "        z_sym.set_color(self.z_color)\n",
        "        w_sym.set_color(self.w_color)\n",
        "        product.scale(2)\n",
        "        product.to_corner(UL)\n",
        "        product.add_background_rectangle()\n",
        "\n",
        "        self.add(\n",
        "            z_line, z_label,\n",
        "            w_line, w_label,\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, VGroup(z_dot, w_dot),\n",
        "            lambda m: (m, 5),\n",
        "            lag_ratio=0.8,\n",
        "            run_time=1.5\n",
        "        ))\n",
        "        self.play(\n",
        "            ReplacementTransform(z_label[1][0].copy(), z_sym)\n",
        "        )\n",
        "        self.add(product[:-1])\n",
        "        self.play(\n",
        "            ReplacementTransform(w_label[1][0].copy(), w_sym),\n",
        "            FadeIn(product[2], LEFT),\n",
        "            FadeIn(product[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            product,\n",
        "            z_point, w_point,\n",
        "            z_dot, w_dot,\n",
        "            z_line, w_line,\n",
        "        )\n",
        "\n",
        "    def show_action_on_all_complex_numbers(self):\n",
        "        plane = self.plane\n",
        "        plane.save_state()\n",
        "        origin = plane.number_to_point(0)\n",
        "        z = self.z\n",
        "        angle = np.log(z).imag\n",
        "        product_tex = self.product[1:]\n",
        "        z_sym, cdot, w_sym = product_tex\n",
        "\n",
        "        product = self.z * self.w\n",
        "        product_point = plane.number_to_point(product)\n",
        "        product_dot = Dot(product_point)\n",
        "        product_line = Line(origin, product_point)\n",
        "        for mob in product_line, product_dot:\n",
        "            mob.set_color(self.product_color)\n",
        "\n",
        "        rect = SurroundingRectangle(VGroup(z_sym, cdot))\n",
        "        rect.set_fill(BLACK, opacity=1)\n",
        "        func_words = OldTexText(\"Function on the plane\")\n",
        "        func_words.next_to(\n",
        "            rect, DOWN,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        func_words.set_color(self.z_color)\n",
        "\n",
        "        sparkly_plane = VGroup()\n",
        "        for line in plane.family_members_with_points():\n",
        "            if self.camera.is_in_frame(line):\n",
        "                for piece in line.get_pieces(10):\n",
        "                    p1, p2 = piece.get_pieces(2)\n",
        "                    p1.rotate(PI)\n",
        "                    pair = VGroup(p1, p2)\n",
        "                    pair.scale(0.3)\n",
        "                    sparkly_plane.add(pair)\n",
        "        sparkly_plane.sort(\n",
        "            lambda p: 0.1 * get_norm(p) + random.random()\n",
        "        )\n",
        "        sparkly_plane.set_color_by_gradient(YELLOW, RED, PINK, BLUE)\n",
        "        sparkly_plane.set_stroke(width=4)\n",
        "\n",
        "        pin = PushPin()\n",
        "        pin.move_to(origin, DR)\n",
        "\n",
        "        one_dot = Dot(plane.number_to_point(1))\n",
        "        one_dot.set_fill(WHITE)\n",
        "        one_dot.set_stroke(BLACK, 1)\n",
        "        hand = Hand()\n",
        "        hand.move_to(plane.number_to_point(1), LEFT)\n",
        "\n",
        "        zero_eq = OldTex(\"z \\\\cdot 0 = 0\")\n",
        "        one_eq = OldTex(\"z \\\\cdot 1 = z\")\n",
        "        equations = VGroup(zero_eq, one_eq)\n",
        "        equations.arrange(DOWN)\n",
        "        equations.scale(1.5)\n",
        "        for eq in equations:\n",
        "            eq.add_background_rectangle()\n",
        "        equations.next_to(func_words, DOWN)\n",
        "        equations.to_edge(LEFT)\n",
        "\n",
        "        product_label = VGroup(\n",
        "            OldTex(\"z \\\\cdot w =\"),\n",
        "            DecimalNumber(product, num_decimal_places=0)\n",
        "        )\n",
        "        product_label.arrange(RIGHT)\n",
        "        product_label[0].shift(0.025 * DOWN)\n",
        "        product_label.next_to(product_dot, UP, SMALL_BUFF)\n",
        "        product_label.add_background_rectangle()\n",
        "\n",
        "        big_rect = Rectangle(\n",
        "            height=4,\n",
        "            width=6,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=0.9,\n",
        "            stroke_width=0,\n",
        "        )\n",
        "        big_rect.to_corner(UL, buff=0)\n",
        "\n",
        "        self.add(big_rect, product_tex, rect, z_sym, cdot)\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            ShowCreation(rect),\n",
        "            Write(func_words),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.w_line.copy(), product_line,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.w_dot.copy(), product_dot,\n",
        "            ),\n",
        "            path_arc=angle,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(product_line, product_dot)))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, sparkly_plane,\n",
        "            lag_ratio=0.5,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.play(\n",
        "            plane.apply_complex_function, lambda w: z * w,\n",
        "            Transform(self.w_line, product_line),\n",
        "            Transform(self.w_dot, product_dot),\n",
        "            path_arc=angle,\n",
        "            run_time=9,\n",
        "            rate_func=lambda t: there_and_back_with_pause(t, 2 / 9)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(pin, UL))\n",
        "        self.play(Write(zero_eq))\n",
        "        self.play(\n",
        "            FadeInFromLarge(one_dot),\n",
        "            FadeIn(hand, UR)\n",
        "        )\n",
        "        self.play(Write(one_eq))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            plane.apply_complex_function, lambda w: z * w,\n",
        "            ReplacementTransform(self.w_line.copy(), product_line),\n",
        "            ReplacementTransform(self.w_dot.copy(), product_dot),\n",
        "            one_dot.move_to, self.z_point,\n",
        "            hand.move_to, self.z_point, LEFT,\n",
        "            path_arc=angle,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(Write(product_label))\n",
        "\n",
        "\n",
        "class ShowUnitCircleActions(ShowComplexMultiplicationExamples):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 0,\n",
        "        \"plane_config\": {\n",
        "            \"secondary_line_ratio\": 0,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_planes(include_title=False)\n",
        "        self.show_unit_circle_actions()\n",
        "\n",
        "    def show_unit_circle_actions(self):\n",
        "        plane = self.plane\n",
        "        origin = plane.number_to_point(0)\n",
        "        one_point = plane.number_to_point(1)\n",
        "        one_dot = Dot(one_point)\n",
        "        one_dot.set_fill(WHITE)\n",
        "        one_dot.set_stroke(BLACK, 1)\n",
        "        plane.add(one_dot)\n",
        "\n",
        "        pin = PushPin()\n",
        "        pin.move_to(origin, DR)\n",
        "        hand = Hand()\n",
        "        update_hand = UpdateFromFunc(\n",
        "            hand, lambda m: m.move_to(one_dot.get_center(), LEFT)\n",
        "        )\n",
        "\n",
        "        circle = Circle(\n",
        "            color=YELLOW,\n",
        "            radius=get_norm(one_point - origin)\n",
        "        )\n",
        "\n",
        "        self.add(circle)\n",
        "        self.add(pin, one_dot)\n",
        "        self.add_foreground_mobjects(hand)\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"Numbers on the unit circle\",\n",
        "            \"$\\\\rightarrow$\", \"pure rotation.\"\n",
        "        )\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        title.add_background_rectangle(buff=SMALL_BUFF)\n",
        "        self.add_foreground_mobjects(title)\n",
        "        self.background_plane.coordinate_labels.submobjects.pop(-1)\n",
        "\n",
        "        n_angles = 12\n",
        "        angles = list(np.linspace(-PI, PI, n_angles + 2)[1:-1])\n",
        "        random.shuffle(angles)\n",
        "\n",
        "        for angle in angles:\n",
        "            plane.save_state()\n",
        "            temp_plane = plane.copy()\n",
        "\n",
        "            z = np.exp(complex(0, angle))\n",
        "            if angle is angles[0]:\n",
        "                z_label = DecimalNumber(\n",
        "                    z, num_decimal_places=2,\n",
        "                )\n",
        "                z_label.set_stroke(BLACK, width=11, background=True)\n",
        "                z_label_rect = BackgroundRectangle(z_label)\n",
        "                z_label_rect.set_fill(opacity=0)\n",
        "            z_point = plane.number_to_point(z)\n",
        "            z_arrow = Arrow(2.5 * z_point, z_point, buff=SMALL_BUFF)\n",
        "            z_dot = Dot(z_point)\n",
        "            z_label_start_center = z_label.get_center()\n",
        "            z_label.next_to(\n",
        "                z_arrow.get_start(),\n",
        "                np.sign(z_arrow.get_start()[1]) * UP,\n",
        "            )\n",
        "            z_label_end_center = z_label.get_center()\n",
        "            z_group = VGroup(z_arrow, z_dot, z_label)\n",
        "            z_group.set_color(GREEN)\n",
        "            z_group.add_to_back(z_label_rect)\n",
        "            z_arrow.set_stroke(BLACK, 1)\n",
        "            z_dot.set_stroke(BLACK, 1)\n",
        "\n",
        "            if angle is angles[0]:\n",
        "                self.play(\n",
        "                    FadeInFromDown(z_label_rect),\n",
        "                    FadeInFromDown(z_label),\n",
        "                    GrowArrow(z_arrow),\n",
        "                    FadeInFromLarge(z_dot),\n",
        "                )\n",
        "            else:\n",
        "                alpha_tracker = ValueTracker(0)\n",
        "                self.play(\n",
        "                    ReplacementTransform(old_z_dot, z_dot),\n",
        "                    ReplacementTransform(old_z_arrow, z_arrow),\n",
        "                    UpdateFromFunc(\n",
        "                        z_label_rect,\n",
        "                        lambda m: m.replace(z_label)\n",
        "                    ),\n",
        "                    ChangeDecimalToValue(\n",
        "                        z_label, z,\n",
        "                        position_update_func=lambda m: m.move_to(\n",
        "                            interpolate(\n",
        "                                z_label_start_center,\n",
        "                                z_label_end_center,\n",
        "                                alpha_tracker.get_value()\n",
        "                            )\n",
        "                        )\n",
        "                    ),\n",
        "                    alpha_tracker.set_value, 1,\n",
        "                    # hand.move_to, one_point, LEFT\n",
        "                )\n",
        "            old_z_dot = z_dot\n",
        "            old_z_arrow = z_arrow\n",
        "            VGroup(old_z_arrow, old_z_dot)\n",
        "            self.play(\n",
        "                Rotate(plane, angle, run_time=2),\n",
        "                update_hand,\n",
        "                Animation(z_group),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.add(temp_plane, z_group)\n",
        "            self.play(\n",
        "                FadeOut(plane),\n",
        "                FadeOut(hand),\n",
        "                FadeIn(temp_plane),\n",
        "            )\n",
        "            plane.restore()\n",
        "            self.remove(temp_plane)\n",
        "            self.add(plane, *z_group)\n",
        "\n",
        "\n",
        "class IfYouNeedAWarmUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        screen = self.screen\n",
        "        screen.set_height(4)\n",
        "        screen.to_corner(UL)\n",
        "        self.add(screen)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"If you need \\\\\\\\ a warm up\",\n",
        "            bubble_config={\"width\": 3.5, \"height\": 3},\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\", look_at=screen,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(RemovePiCreatureBubble(self.teacher))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class LinusThinksAboutStretching(Scene):\n",
        "    def construct(self):\n",
        "        linus = Linus()\n",
        "        top_line = NumberLine(color=GREY)\n",
        "        top_line.to_edge(UP)\n",
        "        top_line.add_numbers()\n",
        "\n",
        "        linus.move_to(3 * LEFT + DOWN)\n",
        "\n",
        "        self.add(linus, top_line)\n",
        "\n",
        "        scalars = [3, 0.5, 2]\n",
        "\n",
        "        for scalar in scalars:\n",
        "            lower_line = NumberLine(\n",
        "                x_min=-14,\n",
        "                x_max=14,\n",
        "                color=BLUE\n",
        "            )\n",
        "            lower_line.next_to(top_line, DOWN, MED_LARGE_BUFF)\n",
        "            lower_line.numbers = lower_line.get_number_mobjects()\n",
        "            for number in lower_line.numbers:\n",
        "                number.add_updater(lambda m: m.next_to(\n",
        "                    lower_line.number_to_point(m.get_value()),\n",
        "                    DOWN, MED_SMALL_BUFF,\n",
        "                ))\n",
        "            lower_line.save_state()\n",
        "            lower_line.numbers.save_state()\n",
        "            self.add(lower_line, *lower_line.numbers)\n",
        "\n",
        "            words = OldTexText(\"Multiply by {}\".format(scalar))\n",
        "            words.next_to(lower_line.numbers, DOWN)\n",
        "\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    lower_line.stretch, scalar, 0,\n",
        "                    run_time=2\n",
        "                ),\n",
        "                # LaggedStartMap(FadeIn, words, run_time=1),\n",
        "                FadeInFromLarge(words, 1.0 / scalar),\n",
        "                linus.look_at, top_line.number_to_point(scalar)\n",
        "            )\n",
        "            self.play(Blink(linus))\n",
        "            self.play(\n",
        "                FadeOut(lower_line),\n",
        "                FadeOut(lower_line.numbers),\n",
        "                FadeOut(words),\n",
        "                FadeIn(lower_line.saved_state, remover=True),\n",
        "                FadeIn(lower_line.numbers.saved_state, remover=True),\n",
        "                linus.look_at, top_line.number_to_point(0)\n",
        "            )\n",
        "        self.play(linus.change, \"confused\", DOWN + RIGHT)\n",
        "        self.wait(2)\n",
        "        self.play(Blink(linus))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class LinusReactions(Scene):\n",
        "    def construct(self):\n",
        "        linus = Linus()\n",
        "        for mode in \"confused\", \"sad\", \"erm\", \"angry\", \"pleading\":\n",
        "            self.play(linus.change, mode, 2 * RIGHT)\n",
        "            self.wait()\n",
        "            self.play(Blink(linus))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class OneDegreeOfFreedomForRotation(Scene):\n",
        "    def construct(self):\n",
        "        circle = CheckeredCircle(radius=2, stroke_width=10)\n",
        "        r_line = Line(circle.get_center(), circle.get_right())\n",
        "        moving_r_line = r_line.copy()\n",
        "        right_dot = Dot(color=WHITE)\n",
        "        right_dot.move_to(circle.get_right())\n",
        "        circle.add(moving_r_line, right_dot)\n",
        "        center_dot = Dot(color=WHITE)\n",
        "\n",
        "        def get_angle():\n",
        "            return moving_r_line.get_angle() % TAU\n",
        "\n",
        "        angle_label = Integer(0, unit=\"^\\\\circ\")\n",
        "        angle_label.scale(2)\n",
        "        angle_label.add_updater(\n",
        "            lambda m: m.set_value(get_angle() / DEGREES)\n",
        "        )\n",
        "        angle_label.add_updater(\n",
        "            lambda m: m.next_to(circle, UP, MED_LARGE_BUFF)\n",
        "        )\n",
        "\n",
        "        def get_arc():\n",
        "            return Arc(\n",
        "                angle=get_angle(),\n",
        "                radius=0.5,\n",
        "                color=GREY_B,\n",
        "            )\n",
        "\n",
        "        arc = get_arc()\n",
        "        arc.add_updater(lambda m: m.become(get_arc()))\n",
        "\n",
        "        self.add(circle, center_dot, r_line, angle_label, arc)\n",
        "        angles = IntroduceStereographicProjection.CONFIG.get(\n",
        "            \"example_angles\"\n",
        "        )\n",
        "        for angle in angles:\n",
        "            self.play(Rotate(circle, angle, run_time=4))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class StereographicProjectionTitle(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Stereographic projection\")\n",
        "        final_title = title.copy()\n",
        "        final_title.set_width(10)\n",
        "        final_title.to_edge(UP)\n",
        "\n",
        "        title.rotate(-90 * DEGREES)\n",
        "        title.next_to(RIGHT, RIGHT, SMALL_BUFF)\n",
        "        title.apply_complex_function(np.exp)\n",
        "        title.rotate(90 * DEGREES)\n",
        "        title.set_height(6)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.play(Transform(title, final_title, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceStereographicProjection(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"n_sample_points\": 16,\n",
        "        \"circle_config\": {\n",
        "            \"n_pieces\": 16,\n",
        "            \"radius\": 2,\n",
        "            \"stroke_width\": 7,\n",
        "        },\n",
        "        \"example_angles\": [\n",
        "            30 * DEGREES,\n",
        "            120 * DEGREES,\n",
        "            240 * DEGREES,\n",
        "            80 * DEGREES,\n",
        "            -60 * DEGREES,\n",
        "            135 * DEGREES,\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.draw_lines()\n",
        "        self.describe_individual_points()\n",
        "        self.remind_that_most_points_are_not_projected()\n",
        "\n",
        "    def setup_plane(self):\n",
        "        self.plane = self.get_plane()\n",
        "        self.circle = self.get_circle()\n",
        "        self.circle_shadow = self.get_circle_shadow()\n",
        "\n",
        "        self.add(self.plane)\n",
        "        self.add(self.circle_shadow)\n",
        "        self.add(self.circle)\n",
        "\n",
        "    def draw_lines(self):\n",
        "        plane = self.plane\n",
        "        circle = self.circle\n",
        "        circle.save_state()\n",
        "        circle.generate_target()\n",
        "        self.project_mobject(circle.target)\n",
        "\n",
        "        circle_points = self.get_sample_circle_points()\n",
        "        dots = VGroup(*[Dot(p) for p in circle_points])\n",
        "        dots.set_sheen(-0.2, DR)\n",
        "        dots.set_stroke(GREY_D, 2, background=True)\n",
        "        arrows = VGroup()\n",
        "        for dot in dots:\n",
        "            dot.scale(0.75)\n",
        "            dot.generate_target()\n",
        "            dot.target.move_to(\n",
        "                self.project(dot.get_center())\n",
        "            )\n",
        "            arrow = Arrow(\n",
        "                dot.get_center(),\n",
        "                dot.target.get_center(),\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "        neg_one_point = plane.number_to_point(-1)\n",
        "        neg_one_dot = Dot(neg_one_point)\n",
        "        neg_one_dot.set_fill(YELLOW)\n",
        "\n",
        "        lines = self.get_lines()\n",
        "\n",
        "        special_index = self.n_sample_points // 2 + 1\n",
        "        line = lines[special_index]\n",
        "        dot = dots[special_index]\n",
        "        arrow = arrows[special_index]\n",
        "        dot_target_outline = dot.target.copy()\n",
        "        dot_target_outline.set_stroke(RED, 2)\n",
        "        dot_target_outline.set_fill(opacity=0)\n",
        "        dot_target_outline.scale(1.5)\n",
        "\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(RED, 5)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromLarge, dots))\n",
        "        self.play(FadeInFromLarge(neg_one_dot))\n",
        "        self.add(lines, neg_one_dot, dots)\n",
        "        self.play(LaggedStartMap(ShowCreation, lines))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lines.set_stroke, {\"width\": 0.5},\n",
        "            line.set_stroke, {\"width\": 4},\n",
        "        )\n",
        "        self.play(ShowCreation(dot_target_outline))\n",
        "        self.play(ShowCreationThenDestruction(v_line))\n",
        "        self.play(MoveToTarget(dot))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lines.set_stroke, {\"width\": 1},\n",
        "            FadeOut(dot_target_outline),\n",
        "            MoveToTarget(circle),\n",
        "            *map(MoveToTarget, dots),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.lines = lines\n",
        "        self.dots = dots\n",
        "\n",
        "    def describe_individual_points(self):\n",
        "        plane = self.plane\n",
        "        one_point, zero_point, i_point, neg_i_point, neg_one_point = [\n",
        "            plane.number_to_point(n)\n",
        "            for n in [1, 0, complex(0, 1), complex(0, -1), -1]\n",
        "        ]\n",
        "        i_pin = PushPin()\n",
        "        i_pin.pin_to(i_point)\n",
        "        neg_i_pin = PushPin()\n",
        "        neg_i_pin.pin_to(neg_i_point)\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.set_stroke(RED, 3)\n",
        "        dot.set_fill(opacity=0)\n",
        "        dot.scale(1.5)\n",
        "        dot.move_to(one_point)\n",
        "\n",
        "        arc1 = Arc(angle=TAU / 4, radius=2)\n",
        "        arc2 = Arc(\n",
        "            angle=85 * DEGREES, radius=2,\n",
        "            start_angle=TAU / 4,\n",
        "        )\n",
        "        arc3 = Arc(\n",
        "            angle=-85 * DEGREES, radius=2,\n",
        "            start_angle=-TAU / 4,\n",
        "        )\n",
        "        VGroup(arc1, arc2, arc3).set_stroke(RED)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        frame_height_tracker = ValueTracker(frame.get_height())\n",
        "        frame_height_growth = frame_height_tracker.add_updater(\n",
        "            lambda m, dt: m.set_value(m.get_value + 0.5 * dt)\n",
        "        )\n",
        "\n",
        "        neg_one_tangent = VGroup(\n",
        "            Line(ORIGIN, UP),\n",
        "            Line(ORIGIN, DOWN),\n",
        "        )\n",
        "        neg_one_tangent.set_height(25)\n",
        "        neg_one_tangent.set_stroke(YELLOW, 5)\n",
        "        neg_one_tangent.move_to(neg_one_point)\n",
        "\n",
        "        self.play(ShowCreation(dot))\n",
        "        self.wait()\n",
        "        self.play(dot.move_to, zero_point)\n",
        "        self.wait()\n",
        "        dot.move_to(i_point)\n",
        "        self.play(ShowCreation(dot))\n",
        "        self.play(FadeIn(i_pin, UL))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dot.move_to, neg_i_point,\n",
        "            path_arc=-60 * DEGREES\n",
        "        )\n",
        "        self.play(FadeIn(neg_i_pin, UL))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dot.move_to, one_point,\n",
        "            path_arc=-60 * DEGREES\n",
        "        )\n",
        "        frame.add_updater(\n",
        "            lambda m: m.set_height(frame_height_tracker.get_value())\n",
        "        )\n",
        "\n",
        "        triplets = [\n",
        "            (arc1, i_point, TAU / 4),\n",
        "            (arc2, neg_one_point, TAU / 4),\n",
        "            (arc3, neg_one_point, -TAU / 4),\n",
        "        ]\n",
        "        for arc, point, path_arc in triplets:\n",
        "            self.play(\n",
        "                ShowCreation(arc),\n",
        "                dot.move_to, point, path_arc=path_arc,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ApplyFunction(self.project_mobject, arc, run_time=2)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(FadeOut(arc))\n",
        "            self.wait()\n",
        "            if arc is arc1:\n",
        "                self.add(frame, frame_height_growth)\n",
        "            elif arc is arc2:\n",
        "                self.play(dot.move_to, neg_i_point)\n",
        "        self.wait(2)\n",
        "        self.play(*map(ShowCreation, neg_one_tangent))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(neg_one_tangent))\n",
        "        self.wait(2)\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            frame.set_height, FRAME_HEIGHT,\n",
        "            self.lines.set_stroke, {\"width\": 0.5},\n",
        "            FadeOut(self.dots),\n",
        "            FadeOut(dot),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "    def remind_that_most_points_are_not_projected(self):\n",
        "        plane = self.plane\n",
        "        circle = self.circle\n",
        "\n",
        "        sample_values = [0, complex(1, 1), complex(-2, -1)]\n",
        "        sample_points = [\n",
        "            plane.number_to_point(value)\n",
        "            for value in sample_values\n",
        "        ]\n",
        "        sample_dots = VGroup(*[Dot(p) for p in sample_points])\n",
        "        sample_dots.set_fill(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.lines),\n",
        "            Restore(circle),\n",
        "        )\n",
        "\n",
        "        for value, dot in zip(sample_values, sample_dots):\n",
        "            cross = Cross(dot)\n",
        "            cross.scale(2)\n",
        "            label = Integer(value)\n",
        "            if value is sample_values[1]:\n",
        "                label.next_to(dot, UL, SMALL_BUFF)\n",
        "            else:\n",
        "                label.next_to(dot, UR, SMALL_BUFF)\n",
        "            self.play(\n",
        "                FadeInFromLarge(dot, 3),\n",
        "                FadeInFromDown(label)\n",
        "            )\n",
        "            self.play(ShowCreation(cross))\n",
        "            self.play(*map(FadeOut, [dot, cross, label]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(self.lines),\n",
        "            MoveToTarget(circle, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "    def get_plane(self):\n",
        "        plane = ComplexPlane(\n",
        "            unit_size=2,\n",
        "            color=GREY,\n",
        "            secondary_color=GREY_D,\n",
        "            x_radius=FRAME_WIDTH,\n",
        "            y_radius=FRAME_HEIGHT,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        return plane\n",
        "\n",
        "    def get_circle(self):\n",
        "        circle = CheckeredCircle(\n",
        "            **self.circle_config\n",
        "        )\n",
        "        circle.set_stroke(width=7)\n",
        "        return circle\n",
        "\n",
        "    def get_circle_shadow(self):\n",
        "        circle_shadow = CheckeredCircle(\n",
        "            **self.circle_config\n",
        "        )\n",
        "        circle_shadow.set_stroke(opacity=0.65)\n",
        "        return circle_shadow\n",
        "\n",
        "    def get_sample_circle_points(self):\n",
        "        plane = self.plane\n",
        "        n = self.n_sample_points\n",
        "        rotater = 1\n",
        "        if hasattr(self, \"circle_shadow\"):\n",
        "            point = self.circle_shadow[0].get_points()[0]\n",
        "            rotater = complex(*point[:2])\n",
        "            rotater /= abs(rotater)\n",
        "        numbers = [\n",
        "            rotater * np.exp(complex(0, TAU * x / n))\n",
        "            for x in range(-(n // 2) + 1, n // 2)\n",
        "        ]\n",
        "        return [\n",
        "            plane.number_to_point(number)\n",
        "            for number in numbers\n",
        "        ]\n",
        "\n",
        "    def get_lines(self):\n",
        "        plane = self.plane\n",
        "        neg_one_point = plane.number_to_point(-1)\n",
        "        circle_points = self.get_sample_circle_points()\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(neg_one_point, point)\n",
        "            for point in circle_points\n",
        "        ])\n",
        "        for line in lines:\n",
        "            length = line.get_length()\n",
        "            line.scale(20 / length, about_point=neg_one_point)\n",
        "            line.set_stroke(YELLOW, np.clip(length, 0, 1))\n",
        "        return lines\n",
        "\n",
        "    def project(self, point):\n",
        "        return stereo_project_point(point, axis=0, r=2)\n",
        "\n",
        "    def project_mobject(self, mobject):\n",
        "        return stereo_project(mobject, axis=0, r=2, outer_r=6)\n",
        "\n",
        "\n",
        "class IntroduceStereographicProjectionLinusView(IntroduceStereographicProjection):\n",
        "    def construct(self):\n",
        "        self.describe_individual_points()\n",
        "        self.point_at_infinity()\n",
        "        self.show_90_degree_rotation()\n",
        "        self.talk_through_90_degree_rotation()\n",
        "        self.show_four_rotations()\n",
        "        self.show_example_angles()\n",
        "\n",
        "    def describe_individual_points(self):\n",
        "        plane = self.plane = self.get_plane()\n",
        "        circle = self.circle = self.get_circle()\n",
        "        linus = self.linus = self.get_linus()\n",
        "\n",
        "        angles = np.arange(-135, 180, 45) * DEGREES\n",
        "        sample_numbers = [\n",
        "            np.exp(complex(0, angle))\n",
        "            for angle in angles\n",
        "        ]\n",
        "        sample_points = [\n",
        "            plane.number_to_point(number)\n",
        "            for number in sample_numbers\n",
        "        ]\n",
        "        projected_sample_points = [\n",
        "            self.project(point)\n",
        "            for point in sample_points\n",
        "        ]\n",
        "        dots = VGroup(*[Dot() for x in range(8)])\n",
        "        dots.set_fill(WHITE)\n",
        "        dots.set_stroke(BLACK, 1)\n",
        "\n",
        "        def generate_dot_updater(circle_piece):\n",
        "            return lambda d: d.move_to(circle_piece.get_points()[0])\n",
        "\n",
        "        for dot, piece in zip(dots, circle[::(len(circle) // 8)]):\n",
        "            dot.add_updater(generate_dot_updater(piece))\n",
        "\n",
        "        stot = \"(\\\\sqrt{2} / 2)\"\n",
        "        labels_tex = [\n",
        "            \"-{}-{}i\".format(stot, stot),\n",
        "            \"-i\",\n",
        "            \"{}-{}i\".format(stot, stot),\n",
        "            \"1\",\n",
        "            \"{}+{}i\".format(stot, stot),\n",
        "            \"i\",\n",
        "            \"-{}+{}i\".format(stot, stot),\n",
        "        ]\n",
        "        labels = VGroup(*[Tex(tex) for tex in labels_tex])\n",
        "        vects = it.cycle([RIGHT, RIGHT])\n",
        "        arrows = VGroup()\n",
        "        for label, point, vect in zip(labels, projected_sample_points, vects):\n",
        "            arrow = Arrow(vect, ORIGIN)\n",
        "            arrow.next_to(point, vect, 2 * SMALL_BUFF)\n",
        "            arrows.add(arrow)\n",
        "            label.set_stroke(width=0, background=True)\n",
        "            if stot in label.get_tex():\n",
        "                label.set_height(0.5)\n",
        "            else:\n",
        "                label.set_height(0.5)\n",
        "                label.set_stroke(WHITE, 2, background=True)\n",
        "            label.next_to(arrow, vect, SMALL_BUFF)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        frame.set_height(12)\n",
        "\n",
        "        self.add(linus)\n",
        "        self.add(circle, *dots)\n",
        "        self.play(\n",
        "            ApplyFunction(self.project_mobject, circle),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(linus.change, \"confused\")\n",
        "        self.wait()\n",
        "        for i in [1, 0]:\n",
        "            self.play(\n",
        "                LaggedStartMap(GrowArrow, arrows[i::2]),\n",
        "                LaggedStartMap(Write, labels[i::2])\n",
        "            )\n",
        "            self.play(Blink(linus))\n",
        "\n",
        "        self.dots = dots\n",
        "\n",
        "    def point_at_infinity(self):\n",
        "        circle = self.circle\n",
        "        linus = self.linus\n",
        "\n",
        "        label = OldTexText(\n",
        "            \"$-1$ is \\\\\\\\ at $\\\\pm \\\\infty$\"\n",
        "        )\n",
        "        label.scale(1.5)\n",
        "        label.next_to(circle, LEFT, buff=1.25)\n",
        "        arrows = VGroup(*[\n",
        "            Vector(3 * v + 0.0 * RIGHT).next_to(label, v, buff=MED_LARGE_BUFF)\n",
        "            for v in [UP, DOWN]\n",
        "        ])\n",
        "        arrows.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            linus.change, \"awe\", label,\n",
        "            *map(GrowArrow, arrows)\n",
        "        )\n",
        "\n",
        "        self.neg_one_label = VGroup(label, arrows)\n",
        "\n",
        "    def show_90_degree_rotation(self):\n",
        "        angle_tracker = ValueTracker(0)\n",
        "        circle = self.circle\n",
        "        linus = self.linus\n",
        "        hand = Hand()\n",
        "        hand.flip()\n",
        "        one_dot = self.dots[0]\n",
        "        hand.add_updater(\n",
        "            lambda h: h.move_to(one_dot.get_center(), RIGHT)\n",
        "        )\n",
        "\n",
        "        def update_circle(circle):\n",
        "            angle = angle_tracker.get_value()\n",
        "            new_circle = self.get_circle()\n",
        "            new_circle.rotate(angle)\n",
        "            self.project_mobject(new_circle)\n",
        "            circle.become(new_circle)\n",
        "\n",
        "        circle.add_updater(update_circle)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(hand),\n",
        "            one_dot.set_fill, RED,\n",
        "        )\n",
        "        for angle in 90 * DEGREES, 0:\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    angle_tracker.set_value, angle,\n",
        "                    run_time=3,\n",
        "                ),\n",
        "                linus.change, \"confused\", hand\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(Blink(linus))\n",
        "\n",
        "        self.hand = hand\n",
        "        self.angle_tracker = angle_tracker\n",
        "\n",
        "    def talk_through_90_degree_rotation(self):\n",
        "        linus = self.linus\n",
        "        dots = self.dots\n",
        "        one_dot = dots[0]\n",
        "        i_dot = dots[2]\n",
        "        neg_i_dot = dots[-2]\n",
        "\n",
        "        kwargs1 = {\n",
        "            \"path_arc\": -90 * DEGREES,\n",
        "            \"buff\": SMALL_BUFF,\n",
        "        }\n",
        "        kwargs2 = dict(kwargs1)\n",
        "        kwargs2[\"path_arc\"] = -40 * DEGREES\n",
        "        arrows = VGroup(\n",
        "            Arrow(one_dot, i_dot, **kwargs1),\n",
        "            Arrow(i_dot, 6 * UP + LEFT, **kwargs2),\n",
        "            Arrow(6 * DOWN + LEFT, neg_i_dot, **kwargs2),\n",
        "            Arrow(neg_i_dot, one_dot, **kwargs1)\n",
        "        )\n",
        "        arrows.set_stroke(WHITE, 3)\n",
        "        one_to_i, i_to_neg_1, neg_one_to_neg_i, neg_i_to_one = arrows\n",
        "\n",
        "        for arrow in arrows:\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                linus.look_at, arrow\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        self.arrows = arrows\n",
        "\n",
        "    def show_four_rotations(self):\n",
        "        angle_tracker = self.angle_tracker\n",
        "        linus = self.linus\n",
        "        hand = self.hand\n",
        "        linus.add_updater(lambda l: l.look_at(hand))\n",
        "        linus.add_updater(lambda l: l.eyes.next_to(l.body, UP, 0))\n",
        "\n",
        "        for angle in np.arange(TAU / 4, 5 * TAU / 4, TAU / 4):\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    angle_tracker.set_value, angle,\n",
        "                    run_time=3,\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(self.arrows))\n",
        "\n",
        "    def show_example_angles(self):\n",
        "        angle_tracker = self.angle_tracker\n",
        "        angle_tracker.set_value(0)\n",
        "\n",
        "        for angle in self.example_angles:\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    angle_tracker.set_value, angle,\n",
        "                    run_time=4,\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    #\n",
        "    def get_linus(self):\n",
        "        linus = Linus()\n",
        "        linus.move_to(3 * RIGHT)\n",
        "        linus.to_edge(DOWN)\n",
        "        linus.look_at(ORIGIN)\n",
        "        return linus\n",
        "\n",
        "\n",
        "class ShowRotationUnderStereographicProjection(IntroduceStereographicProjection):\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.apply_projection()\n",
        "        self.show_90_degree_rotation()\n",
        "        self.talk_through_90_degree_rotation()\n",
        "        self.show_four_rotations()\n",
        "        self.show_example_angles()\n",
        "\n",
        "    def apply_projection(self):\n",
        "        plane = self.plane\n",
        "        circle = self.circle\n",
        "        neg_one_point = plane.number_to_point(-1)\n",
        "        neg_one_dot = Dot(neg_one_point)\n",
        "        neg_one_dot.set_fill(YELLOW)\n",
        "\n",
        "        lines = always_redraw(self.get_lines)\n",
        "\n",
        "        def generate_dot_updater(circle_piece):\n",
        "            return lambda d: d.move_to(circle_piece.get_points()[0])\n",
        "\n",
        "        for circ, color in [(self.circle_shadow, RED), (self.circle, WHITE)]:\n",
        "            for piece in circ[::(len(circ) // 8)]:\n",
        "                dot = Dot(color=color)\n",
        "                dot.set_fill(opacity=circ.get_stroke_opacity())\n",
        "                dot.add_updater(generate_dot_updater(piece))\n",
        "                self.add(dot)\n",
        "\n",
        "        self.add(lines, neg_one_dot)\n",
        "        self.play(*map(ShowCreation, lines))\n",
        "        self.play(\n",
        "            ApplyFunction(self.project_mobject, circle),\n",
        "            lines.set_stroke, {\"width\": 0.5},\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            self.camera_frame.set_height, 12,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_90_degree_rotation(self):\n",
        "        circle = self.circle\n",
        "        circle_shadow = self.circle_shadow\n",
        "\n",
        "        def get_rotated_one_point():\n",
        "            return circle_shadow[0].get_points()[0]\n",
        "\n",
        "        def get_angle():\n",
        "            return angle_of_vector(get_rotated_one_point())\n",
        "\n",
        "        self.get_angle = get_angle\n",
        "\n",
        "        one_dot = Dot(color=RED)\n",
        "        one_dot.add_updater(\n",
        "            lambda m: m.move_to(get_rotated_one_point())\n",
        "        )\n",
        "        hand = Hand()\n",
        "        hand.move_to(one_dot.get_center(), LEFT)\n",
        "\n",
        "        def update_circle(circle):\n",
        "            new_circle = self.get_circle()\n",
        "            new_circle.rotate(get_angle())\n",
        "            self.project_mobject(new_circle)\n",
        "            circle.become(new_circle)\n",
        "\n",
        "        circle.add_updater(update_circle)\n",
        "\n",
        "        self.add(one_dot, hand)\n",
        "        hand.add_updater(\n",
        "            lambda h: h.move_to(one_dot.get_center(), LEFT)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(hand, RIGHT),\n",
        "            FadeInFromLarge(one_dot, 3),\n",
        "        )\n",
        "        for angle in 90 * DEGREES, -90 * DEGREES:\n",
        "            self.play(\n",
        "                Rotate(circle_shadow, angle, run_time=3),\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "    def talk_through_90_degree_rotation(self):\n",
        "        plane = self.plane\n",
        "        points = [\n",
        "            plane.number_to_point(z)\n",
        "            for z in [1, complex(0, 1), -1, complex(0, -1)]\n",
        "        ]\n",
        "        arrows = VGroup()\n",
        "        for p1, p2 in adjacent_pairs(points):\n",
        "            arrow = Arrow(\n",
        "                p1, p2, path_arc=180 * DEGREES,\n",
        "            )\n",
        "            arrow.set_stroke(GREY_B, width=3)\n",
        "            arrow.tip.set_fill(GREY_B)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        for arrow in arrows:\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.wait(2)\n",
        "\n",
        "        self.arrows = arrows\n",
        "\n",
        "    def show_four_rotations(self):\n",
        "        circle_shadow = self.circle_shadow\n",
        "        for x in range(4):\n",
        "            self.play(\n",
        "                Rotate(circle_shadow, TAU / 4, run_time=3)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(self.arrows))\n",
        "\n",
        "    def show_example_angles(self):\n",
        "        circle_shadow = self.circle_shadow\n",
        "        angle_label = Integer(0, unit=\"^\\\\circ\")\n",
        "        angle_label.scale(1.5)\n",
        "        angle_label.next_to(\n",
        "            circle_shadow.get_top(), UR,\n",
        "        )\n",
        "\n",
        "        self.play(FadeInFromDown(angle_label))\n",
        "        self.add(angle_label)\n",
        "        for angle in self.example_angles:\n",
        "            d_angle = angle - self.get_angle()\n",
        "            self.play(\n",
        "                Rotate(circle_shadow, d_angle),\n",
        "                ChangingDecimal(\n",
        "                    angle_label,\n",
        "                    lambda a: (self.get_angle() % TAU) / DEGREES\n",
        "                ),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class WriteITimesW(Scene):\n",
        "    def construct(self):\n",
        "        mob = OldTex(\"i\", \"\\\\cdot\", \"w\")\n",
        "        mob[0].set_color(GREEN)\n",
        "        mob.scale(3)\n",
        "        self.play(Write(mob))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceFelix(PiCreatureScene, SpecialThreeDScene):\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        SpecialThreeDScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_felix()\n",
        "        self.add_plane()\n",
        "        self.show_in_three_d()\n",
        "\n",
        "    def introduce_felix(self):\n",
        "        felix = self.felix = self.pi_creature\n",
        "\n",
        "        arrow = Vector(DL, color=WHITE)\n",
        "        arrow.next_to(felix, UR)\n",
        "\n",
        "        label = OldTexText(\"Felix the Flatlander\")\n",
        "        label.next_to(arrow.get_start(), UP)\n",
        "\n",
        "        self.add(felix)\n",
        "        self.play(\n",
        "            felix.change, \"wave_1\", label,\n",
        "            Write(label),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.play(Blink(felix))\n",
        "        self.play(felix.change, \"thinking\", label)\n",
        "\n",
        "        self.to_fade = VGroup(label, arrow)\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = NumberPlane(y_radius=10)\n",
        "        axes = self.get_axes()\n",
        "        to_fade = self.to_fade\n",
        "        felix = self.felix\n",
        "\n",
        "        self.add(axes, plane, felix)\n",
        "        self.play(\n",
        "            ShowCreation(axes),\n",
        "            ShowCreation(plane),\n",
        "            FadeOut(to_fade),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.plane = plane\n",
        "        self.axes = axes\n",
        "\n",
        "    def show_in_three_d(self):\n",
        "        felix = self.pi_creature\n",
        "        plane = self.plane\n",
        "        axes = self.axes\n",
        "\n",
        "        # back_plane = Rectangle().replace(plane, stretch=True)\n",
        "        # back_plane.shade_in_3d = True\n",
        "        # back_plane.set_fill(GREY_B, opacity=0.5)\n",
        "        # back_plane.set_sheen(1, UL)\n",
        "        # back_plane.shift(SMALL_BUFF * IN)\n",
        "        # back_plane.set_stroke(width=0)\n",
        "        # back_plane = ParametricSurface(\n",
        "        #     lambda u, v: u * RIGHT + v * UP\n",
        "        # )\n",
        "        # back_plane.replace(plane, stretch=True)\n",
        "        # back_plane.set_stroke(width=0)\n",
        "        # back_plane.set_fill(GREY_B, opacity=0.5)\n",
        "\n",
        "        sphere = self.get_sphere()\n",
        "        # sphere.set_fill(BLUE_E, 0.5)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-110 * DEGREES,\n",
        "            added_anims=[FadeOut(plane)],\n",
        "            run_time=2\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.add(axes, sphere)\n",
        "        self.play(\n",
        "            Write(sphere),\n",
        "            felix.change, \"confused\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        axis_angle_pairs = [\n",
        "            (RIGHT, 90 * DEGREES),\n",
        "            (OUT, 45 * DEGREES),\n",
        "            (UR + OUT, 120 * DEGREES),\n",
        "            (RIGHT, 90 * DEGREES),\n",
        "        ]\n",
        "        for axis, angle in axis_angle_pairs:\n",
        "            self.play(Rotate(\n",
        "                sphere, angle=angle, axis=axis,\n",
        "                run_time=2,\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "    #\n",
        "    def create_pi_creature(self):\n",
        "        return Felix().move_to(4 * LEFT + 2 * DOWN)\n",
        "\n",
        "\n",
        "class IntroduceThreeDNumbers(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"exponential_projection\": False,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_third_axis()\n",
        "        self.reorient_axes()\n",
        "        self.show_example_number()\n",
        "\n",
        "    def add_third_axis(self):\n",
        "        plane = ComplexPlane(\n",
        "            y_radius=FRAME_WIDTH / 4,\n",
        "            unit_size=2,\n",
        "            secondary_line_ratio=1,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        title = OldTexText(\"Complex Plane\")\n",
        "        title.scale(1.8)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        real_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        imag_line = Line(DOWN, UP).set_height(FRAME_HEIGHT)\n",
        "        real_line.set_color(YELLOW)\n",
        "        imag_line.set_color(RED)\n",
        "\n",
        "        for label in plane.coordinate_labels:\n",
        "            label.remove(label.background_rectangle)\n",
        "            label.shift(SMALL_BUFF * IN)\n",
        "            self.add_fixed_orientation_mobjects(label)\n",
        "        reals = plane.coordinate_labels[:7]\n",
        "        imags = plane.coordinate_labels[7:]\n",
        "\n",
        "        self.add(plane, title)\n",
        "        for line, group in (real_line, reals), (imag_line, imags):\n",
        "            line.set_stroke(width=5)\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(line),\n",
        "                LaggedStartMap(\n",
        "                    Indicate, group,\n",
        "                    rate_func=there_and_back,\n",
        "                    color=line.get_color(),\n",
        "                ),\n",
        "                run_time=2,\n",
        "            )\n",
        "\n",
        "        self.plane = plane\n",
        "        self.title = title\n",
        "\n",
        "    def reorient_axes(self):\n",
        "        z_axis = NumberLine(unit_size=2)\n",
        "        z_axis.rotate(90 * DEGREES, axis=DOWN)\n",
        "        z_axis.rotate(90 * DEGREES, axis=OUT)\n",
        "        z_axis.set_color(WHITE)\n",
        "        z_axis_top = Line(\n",
        "            z_axis.number_to_point(0),\n",
        "            z_axis.get_end(),\n",
        "        )\n",
        "        z_axis_top.match_style(z_axis)\n",
        "\n",
        "        z_unit_line = Line(\n",
        "            z_axis.number_to_point(0),\n",
        "            z_axis.number_to_point(1),\n",
        "            color=RED,\n",
        "            stroke_width=5\n",
        "        )\n",
        "\n",
        "        j_labels = VGroup(\n",
        "            OldTex(\"-2j\"),\n",
        "            OldTex(\"-j\"),\n",
        "            OldTex(\"j\"),\n",
        "            OldTex(\"2j\"),\n",
        "        )\n",
        "        for label, num in zip(j_labels, [-2, -1, 1, 2]):\n",
        "            label.next_to(z_axis.number_to_point(num), RIGHT, MED_SMALL_BUFF)\n",
        "            self.add_fixed_orientation_mobjects(label)\n",
        "\n",
        "        plane = self.plane\n",
        "\n",
        "        colored_ = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        y_line = Line(DOWN, UP).set_height(FRAME_WIDTH)\n",
        "        z_line = Line(IN, OUT).set_depth(FRAME_WIDTH)\n",
        "        colored_.set_stroke(GREEN, 5)\n",
        "        y_line.set_stroke(RED, 5)\n",
        "        z_line.set_stroke(YELLOW, 5)\n",
        "        colored_coord_lines = VGroup(colored_, y_line, z_line)\n",
        "\n",
        "        coord_lines = VGroup(\n",
        "            plane.axes[0], plane.axes[1], z_axis,\n",
        "        )\n",
        "        for i1, i2 in [(0, 2), (1, 0), (2, 1)]:\n",
        "            coord_lines[i1].target = coord_lines[i2].copy()\n",
        "\n",
        "        new_title = OldTexText(\"Imaginary plane\")\n",
        "        new_title.replace(self.title)\n",
        "        new_title.move_to(self.title)\n",
        "\n",
        "        self.add(z_axis, plane, z_axis_top)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "            added_anims=[\n",
        "                plane.set_stroke, {\"opacity\": 0.5},\n",
        "            ],\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.02)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(j_labels, IN))\n",
        "        z_axis.add(j_labels)\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(z_unit_line),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        group = VGroup(*it.chain(plane.coordinate_labels, j_labels))\n",
        "        for label in group:\n",
        "            label.generate_target()\n",
        "            axis = np.ones(3)\n",
        "            label.target.rotate_about_origin(-120 * DEGREES, axis=axis)\n",
        "            label.target.rotate(120 * DEGREES, axis=axis)\n",
        "        for y, label in zip([-2, -1, 1, 2], j_labels):\n",
        "            label.target.scale(0.65)\n",
        "            label.target.next_to(\n",
        "                2 * y * UP, RIGHT, 2 * SMALL_BUFF\n",
        "            )\n",
        "        self.remove(z_axis_top)\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, group, lag_ratio=0.8),\n",
        "            LaggedStartMap(MoveToTarget, coord_lines, lag_ratio=0.8),\n",
        "            FadeOut(self.title),\n",
        "            FadeIn(new_title),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(z_axis_top)\n",
        "        self.wait(3)\n",
        "        for line, wait in zip(colored_coord_lines, [False, True, True]):\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(line),\n",
        "                run_time=2\n",
        "            )\n",
        "            if wait:\n",
        "                self.wait()\n",
        "\n",
        "    def show_example_number(self):\n",
        "        x, y, z = coords = 2 * np.array([1.5, -1, 1.25])\n",
        "        dot = Sphere(radius=0.05)\n",
        "        dot.set_fill(GREY_B)\n",
        "        dot.move_to(coords)\n",
        "        point_line = Line(ORIGIN, coords)\n",
        "        point_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        z_line = Line(ORIGIN, z * OUT)\n",
        "        x_line = Line(z_line.get_end(), z_line.get_end() + x * RIGHT)\n",
        "        y_line = Line(x_line.get_end(), x_line.get_end() + y * UP)\n",
        "\n",
        "        x_line.set_stroke(GREEN, 5)\n",
        "        y_line.set_stroke(RED, 5)\n",
        "        z_line.set_stroke(YELLOW, 5)\n",
        "        lines = VGroup(z_line, x_line, y_line)\n",
        "\n",
        "        number_label = OldTex(\n",
        "            str(z / 2), \"+\", str(x / 2), \"i\", \"+\", str(y / 2), \"j\",\n",
        "            tex_to_color_map={\n",
        "                str(z / 2): YELLOW,\n",
        "                str(x / 2): GREEN,\n",
        "                str(y / 2): RED,\n",
        "            }\n",
        "        )\n",
        "        number_label.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        number_label.to_edge(UP)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(number_label)\n",
        "        self.play(\n",
        "            ShowCreation(point_line),\n",
        "            FadeIn(dot, -coords),\n",
        "            FadeInFromDown(number_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        for num, line in zip([z, x, y], lines):\n",
        "            tex = number_label.get_part_by_tex(str(num / 2))\n",
        "            rect = SurroundingRectangle(tex)\n",
        "            rect.set_color(WHITE)\n",
        "\n",
        "            self.add_fixed_in_frame_mobjects(rect)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                ShowCreationThenDestruction(rect),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.remove_fixed_in_frame_mobjects(rect)\n",
        "            self.wait()\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class MentionImpossibilityOf3dNumbers(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        equations = VGroup(\n",
        "            OldTex(\"ij = ?\"),\n",
        "            OldTex(\"ji = ?\"),\n",
        "        )\n",
        "        equations.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        equations.scale(1.5)\n",
        "        equations.to_edge(UP)\n",
        "        self.add(equations)\n",
        "\n",
        "        why = OldTexText(\"Why not?\")\n",
        "        why.next_to(self.students[1], UP)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"Such 3d numbers \\\\\\\\ have no good \\\\\\\\ multiplication rule\",\n",
        "            bubble_config={\"width\": 4, \"height\": 3},\n",
        "        )\n",
        "        self.play_all_student_changes(\"confused\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.students[1].change, \"maybe\",\n",
        "            FadeInFromLarge(why),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SphereExamplePointsDecimal(Scene):\n",
        "    CONFIG = {\n",
        "        \"point_rotation_angle_axis_pairs\": [\n",
        "            (45 * DEGREES, DOWN),\n",
        "            (120 * DEGREES, OUT),\n",
        "            (35 * DEGREES, rotate_vector(RIGHT, 30 * DEGREES)),\n",
        "            (90 * DEGREES, IN),\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        decimals = VGroup(*[\n",
        "            DecimalNumber(\n",
        "                0,\n",
        "                num_decimal_places=3,\n",
        "                color=color,\n",
        "                include_sign=True,\n",
        "                edge_to_fix=RIGHT,\n",
        "            )\n",
        "            for color in [YELLOW, GREEN, RED]\n",
        "        ])\n",
        "        number_label = VGroup(\n",
        "            decimals[0], OldTex(\"+\"),\n",
        "            decimals[1], OldTex(\"i\"), OldTex(\"+\"),\n",
        "            decimals[2], OldTex(\"j\"),\n",
        "        )\n",
        "        number_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        number_label.to_corner(UL)\n",
        "\n",
        "        point = VectorizedPoint(OUT)\n",
        "\n",
        "        def generate_decimal_updater(decimal, index):\n",
        "            shifted_i = (index - 1) % 3\n",
        "            decimal.add_updater(lambda d: d.set_value(\n",
        "                point.get_location()[shifted_i]\n",
        "            ))\n",
        "            return decimal\n",
        "\n",
        "        for i, decimal in enumerate(decimals):\n",
        "            self.add(generate_decimal_updater(decimal, i))\n",
        "\n",
        "        decimal_braces = VGroup()\n",
        "        for decimal, char in zip(decimals, \"wxy\"):\n",
        "            brace = Brace(decimal, DOWN, buff=SMALL_BUFF)\n",
        "            label = brace.get_tex(char, buff=SMALL_BUFF)\n",
        "            label.match_color(decimal)\n",
        "            brace.add(label)\n",
        "            decimal_braces.add(brace)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"w^2 + x^2 + y^2 = 1\",\n",
        "            tex_to_color_map={\n",
        "                \"w\": YELLOW,\n",
        "                \"x\": GREEN,\n",
        "                \"y\": RED,\n",
        "            }\n",
        "        )\n",
        "        equation.next_to(decimal_braces, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(number_label)\n",
        "        self.add(decimal_braces)\n",
        "        self.add(equation)\n",
        "\n",
        "        pairs = self.point_rotation_angle_axis_pairs\n",
        "        for angle, axis in pairs:\n",
        "            self.play(\n",
        "                Rotate(point, angle, axis=axis, about_point=ORIGIN),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class TwoDStereographicProjection(IntroduceFelix):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"exponential_projection\": False,\n",
        "        },\n",
        "        \"sphere_sample_point_u_range\": np.arange(\n",
        "            0, PI, PI / 16,\n",
        "        ),\n",
        "        \"sphere_sample_point_v_range\": np.arange(\n",
        "            0, TAU, TAU / 16,\n",
        "        ),\n",
        "        \"n_sample_rotation_cycles\": 2,\n",
        "        \"lift_labels\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_parts()\n",
        "        self.talk_through_sphere()\n",
        "        self.draw_projection_lines()\n",
        "        self.show_point_at_infinity()\n",
        "        self.show_a_few_rotations()\n",
        "\n",
        "    def add_parts(self, run_time=1):\n",
        "        felix = self.felix = self.pi_creature\n",
        "        felix.shift(1.5 * DL)\n",
        "        axes = self.axes = self.get_axes()\n",
        "        sphere = self.sphere = self.get_sphere()\n",
        "\n",
        "        c2p = axes.coords_to_point\n",
        "        labels = self.labels = VGroup(\n",
        "            OldTex(\"i\").next_to(c2p(1, 0, 0), DR, SMALL_BUFF),\n",
        "            OldTex(\"-i\").next_to(c2p(-1, 0, 0), DL, SMALL_BUFF),\n",
        "            OldTex(\"j\").next_to(c2p(0, 1, 0), UL, SMALL_BUFF),\n",
        "            OldTex(\"-j\").next_to(c2p(0, -1, 0), DL, SMALL_BUFF),\n",
        "            OldTex(\"1\").rotate(\n",
        "                90 * DEGREES, RIGHT,\n",
        "            ).next_to(c2p(0, 0, 1), RIGHT + OUT, SMALL_BUFF),\n",
        "            OldTex(\"-1\").rotate(\n",
        "                90 * DEGREES, RIGHT,\n",
        "            ).next_to(c2p(0, 0, -1), RIGHT + IN, SMALL_BUFF),\n",
        "        )\n",
        "        if self.lift_labels:\n",
        "            for sm in labels[:4].family_members_with_points():\n",
        "                sm.add(VectorizedPoint(\n",
        "                    0.25 * DOWN + 0.25 * OUT\n",
        "                ))\n",
        "        labels.set_stroke(width=0, background=True)\n",
        "        for submob in labels.get_family():\n",
        "            submob.shade_in_3d = True\n",
        "\n",
        "        self.add(felix, axes, sphere, labels)\n",
        "        self.move_camera(\n",
        "            **self.get_default_camera_position(),\n",
        "            run_time=run_time\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "        self.play(\n",
        "            felix.change, \"pondering\", sphere,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "\n",
        "    def talk_through_sphere(self):\n",
        "        point = VectorizedPoint(OUT)\n",
        "        arrow = Vector(IN, shade_in_3d=True)\n",
        "        arrow.set_fill(PINK)\n",
        "        arrow.set_stroke(BLACK, 1)\n",
        "\n",
        "        def get_dot():\n",
        "            dot = Sphere(radius=0.05, u_max=PI / 2)\n",
        "            dot.set_fill(PINK)\n",
        "            dot.set_stroke(width=0)\n",
        "            dot.move_to(2.05 * OUT)\n",
        "            dot.apply_matrix(\n",
        "                z_to_vector(normalize(point.get_location())),\n",
        "                about_point=ORIGIN\n",
        "            )\n",
        "            return dot\n",
        "\n",
        "        dot = get_dot()\n",
        "        dot.add_updater(\n",
        "            lambda d: d.become(get_dot())\n",
        "        )\n",
        "\n",
        "        def update_arrow(arrow):\n",
        "            target_point = 2.1 * point.get_location()\n",
        "            rot_matrix = np.dot(\n",
        "                z_to_vector(normalize(target_point)),\n",
        "                np.linalg.inv(\n",
        "                    z_to_vector(normalize(-arrow.get_vector()))\n",
        "                )\n",
        "            )\n",
        "            arrow.apply_matrix(rot_matrix)\n",
        "            arrow.shift(target_point - arrow.get_end())\n",
        "            return arrow\n",
        "        arrow.add_updater(update_arrow)\n",
        "\n",
        "        self.add(self.sphere, dot, arrow)\n",
        "        pairs = SphereExamplePointsDecimal.CONFIG.get(\n",
        "            \"point_rotation_angle_axis_pairs\"\n",
        "        )\n",
        "        for angle, axis in pairs:\n",
        "            self.play(\n",
        "                Rotate(point, angle, axis=axis, about_point=ORIGIN),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(dot), FadeOut(arrow))\n",
        "\n",
        "    def draw_projection_lines(self):\n",
        "        sphere = self.sphere\n",
        "        axes = self.axes\n",
        "        radius = sphere.get_width() / 2\n",
        "\n",
        "        neg_one_point = axes.coords_to_point(0, 0, -1)\n",
        "        neg_one_dot = Dot(\n",
        "            neg_one_point,\n",
        "            color=YELLOW,\n",
        "            shade_in_3d=True\n",
        "        )\n",
        "\n",
        "        xy_plane = StereoProjectedSphere(\n",
        "            u_max=15 * PI / 16,\n",
        "            **self.sphere_config\n",
        "        )\n",
        "        xy_plane.set_fill(WHITE, 0.25)\n",
        "        xy_plane.set_stroke(width=0)\n",
        "\n",
        "        point_mob = VectorizedPoint(2 * OUT)\n",
        "        point_mob.add_updater(\n",
        "            lambda m: m.move_to(radius * normalize(m.get_center()))\n",
        "        )\n",
        "        point_mob.move_to([1, -1, 1])\n",
        "        point_mob.update(0)\n",
        "\n",
        "        def get_projection_line(sphere_point):\n",
        "            to_sphere = Line(neg_one_point, sphere_point)\n",
        "            to_plane = Line(\n",
        "                sphere_point,\n",
        "                self.project_point(sphere_point)\n",
        "            )\n",
        "            line = VGroup(to_sphere, to_plane)\n",
        "            line.set_stroke(YELLOW, 3)\n",
        "            for submob in line:\n",
        "                submob.shade_in_3d = True\n",
        "            return line\n",
        "\n",
        "        def get_sphere_dot(sphere_point):\n",
        "            dot = Dot()\n",
        "            dot.set_shade_in_3d(True)\n",
        "            dot.set_fill(PINK)\n",
        "            dot.shift(OUT)\n",
        "            dot.apply_matrix(\n",
        "                z_to_vector(sphere_point),\n",
        "                about_point=ORIGIN,\n",
        "            )\n",
        "            dot.move_to(1.01 * sphere_point)\n",
        "            dot.add(VectorizedPoint(5 * sphere_point))\n",
        "            return dot\n",
        "\n",
        "        def get_projection_dot(sphere_point):\n",
        "            projection = self.project_point(sphere_point)\n",
        "            dot = Dot(projection, shade_in_3d=True)\n",
        "            dot.add(VectorizedPoint(dot.get_center() + 0.1 * OUT))\n",
        "            dot.set_fill(WHITE)\n",
        "            return dot\n",
        "\n",
        "        point = point_mob.get_location()\n",
        "        dot = get_sphere_dot(point)\n",
        "        line = get_projection_line(point)\n",
        "        projection_dot = get_projection_dot(point)\n",
        "\n",
        "        sample_points = [\n",
        "            radius * sphere.func(u, v)\n",
        "            for u in self.sphere_sample_point_u_range\n",
        "            for v in self.sphere_sample_point_v_range\n",
        "        ]\n",
        "\n",
        "        lines = VGroup(*[get_projection_line(p) for p in sample_points])\n",
        "        lines.set_stroke(width=1)\n",
        "        north_lines = lines[:len(lines) // 2]\n",
        "        south_lines = lines[len(lines) // 2:]\n",
        "\n",
        "        self.add(xy_plane, sphere)\n",
        "        self.play(Write(xy_plane))\n",
        "        self.wait(2)\n",
        "        self.play(sphere.set_fill, BLUE_E, 0.5)\n",
        "        self.play(FadeInFromLarge(dot))\n",
        "        self.play(\n",
        "            FadeIn(neg_one_dot),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            dot.copy(), projection_dot\n",
        "        ))\n",
        "\n",
        "        def get_point():\n",
        "            return 2 * normalize(point_mob.get_location())\n",
        "\n",
        "        dot.add_updater(\n",
        "            lambda d: d.become(get_sphere_dot(get_point()))\n",
        "        )\n",
        "        line.add_updater(\n",
        "            lambda l: l.become(get_projection_line(get_point()))\n",
        "        )\n",
        "        projection_dot.add_updater(\n",
        "            lambda d: d.become(get_projection_dot(get_point()))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            point_mob.move_to,\n",
        "            radius * normalize(np.array([1, -1, -1])),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.move_camera(\n",
        "            theta=-150 * DEGREES,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(axes, sphere, xy_plane, dot, line)\n",
        "        for point in np.array([-2, 1, -0.5]), np.array([-0.01, -0.01, 1]):\n",
        "            self.play(\n",
        "                point_mob.move_to,\n",
        "                radius * normalize(point),\n",
        "                run_time=3\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Project norther hemisphere\n",
        "        north_hemisphere = self.get_sphere()\n",
        "        n = len(north_hemisphere)\n",
        "        north_hemisphere.remove(*north_hemisphere[n // 2:])\n",
        "        north_hemisphere.generate_target()\n",
        "        self.project_mobject(north_hemisphere.target)\n",
        "        north_hemisphere.set_fill(opacity=0.8)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, north_lines),\n",
        "            FadeIn(north_hemisphere)\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(north_hemisphere),\n",
        "            run_time=3,\n",
        "            rate_func=lambda t: smooth(0.99 * t)\n",
        "        )\n",
        "        self.play(FadeOut(north_lines))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Unit circle\n",
        "        circle = Sphere(\n",
        "            radius=2.01,\n",
        "            u_min=PI / 2 - 0.01,\n",
        "            u_max=PI / 2 + 0.01,\n",
        "            resolution=(1, 24),\n",
        "        )\n",
        "        for submob in circle:\n",
        "            submob.add(VectorizedPoint(1.5 * submob.get_center()))\n",
        "        circle.set_fill(YELLOW)\n",
        "        circle_path = Circle(radius=2)\n",
        "        circle_path.rotate(-90 * DEGREES)\n",
        "\n",
        "        self.play(FadeInFromLarge(circle))\n",
        "        self.play(point_mob.move_to, circle_path.get_points()[0])\n",
        "        self.play(MoveAlongPath(point_mob, circle_path, run_time=6))\n",
        "        self.move_camera(\n",
        "            phi=0,\n",
        "            theta=-90 * DEGREES,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.play(point_mob.move_to, OUT)\n",
        "        self.wait()\n",
        "\n",
        "        # Southern hemisphere\n",
        "        south_hemisphere = self.get_sphere()\n",
        "        n = len(south_hemisphere)\n",
        "        south_hemisphere.remove(*south_hemisphere[:n // 2])\n",
        "        south_hemisphere.remove(\n",
        "            *south_hemisphere[-sphere.resolution[1]:]\n",
        "        )\n",
        "        south_hemisphere.generate_target()\n",
        "        self.project_mobject(south_hemisphere.target)\n",
        "        south_hemisphere.set_fill(opacity=0.8)\n",
        "        south_hemisphere.target[-sphere.resolution[1] // 2:].set_fill(\n",
        "            opacity=0\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, south_lines),\n",
        "            FadeIn(south_hemisphere)\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(south_hemisphere),\n",
        "            FadeOut(south_lines),\n",
        "            FadeOut(xy_plane),\n",
        "            run_time=3,\n",
        "            rate_func=lambda t: smooth(0.99 * t)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.projected_sphere = VGroup(\n",
        "            north_hemisphere,\n",
        "            south_hemisphere,\n",
        "        )\n",
        "        self.equator = circle\n",
        "        self.point_mob = point_mob\n",
        "\n",
        "    def show_point_at_infinity(self):\n",
        "        points = list(compass_directions(\n",
        "            12, start_vect=rotate_vector(RIGHT, 3.25 * DEGREES)\n",
        "        ))\n",
        "        points.pop(7)\n",
        "        points.pop(2)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(6 * p, 11 * p)\n",
        "            for p in points\n",
        "        ])\n",
        "        arrows.set_fill(RED)\n",
        "        arrows.set_stroke(RED, 5)\n",
        "        neg_ones = VGroup(*[\n",
        "            OldTex(\"-1\").next_to(arrow.get_start(), -p)\n",
        "            for p, arrow in zip(points, arrows)\n",
        "        ])\n",
        "        neg_ones.set_stroke(width=0, background=True)\n",
        "\n",
        "        sphere_arcs = VGroup()\n",
        "        for angle in np.arange(0, TAU, TAU / 12):\n",
        "            arc = Arc(PI, radius=2)\n",
        "            arc.set_stroke(RED)\n",
        "            arc.rotate(PI / 2, axis=DOWN, about_point=ORIGIN)\n",
        "            arc.rotate(angle, axis=OUT, about_point=ORIGIN)\n",
        "            sphere_arcs.add(arc)\n",
        "        sphere_arcs.set_stroke(RED)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "            LaggedStartMap(Write, neg_ones)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(self.projected_sphere),\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(neg_ones),\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(\n",
        "                    sphere_arcs,\n",
        "                    lag_ratio=0,\n",
        "                    run_time=3,\n",
        "                )\n",
        "            )\n",
        "\n",
        "    def show_a_few_rotations(self):\n",
        "        sphere = self.sphere\n",
        "        felix = self.felix\n",
        "        point_mob = self.point_mob\n",
        "        point_mob.add_updater(\n",
        "            lambda m: m.move_to(sphere.get_all_points()[0])\n",
        "        )\n",
        "        coord_point_mobs = VGroup(\n",
        "            VectorizedPoint(RIGHT),\n",
        "            VectorizedPoint(UP),\n",
        "            VectorizedPoint(OUT),\n",
        "        )\n",
        "        for pm in coord_point_mobs:\n",
        "            pm.shade_in_3d = True\n",
        "\n",
        "        def get_rot_matrix():\n",
        "            return np.array([\n",
        "                pm.get_location()\n",
        "                for pm in coord_point_mobs\n",
        "            ]).T\n",
        "\n",
        "        def get_projected_sphere():\n",
        "            result = StereoProjectedSphere(\n",
        "                get_rot_matrix(),\n",
        "                max_r=10,\n",
        "                **self.sphere_config,\n",
        "            )\n",
        "            result.set_fill(opacity=0.2)\n",
        "            result.fade_far_out_submobjects(max_r=32)\n",
        "            for submob in result:\n",
        "                if submob.get_center()[1] < -11:\n",
        "                    submob.fade(1)\n",
        "            return result\n",
        "\n",
        "        projected_sphere = get_projected_sphere()\n",
        "        projected_sphere.add_updater(\n",
        "            lambda m: m.become(get_projected_sphere())\n",
        "        )\n",
        "\n",
        "        def get_projected_equator():\n",
        "            equator = CheckeredCircle(\n",
        "                n_pieces=24,\n",
        "                radius=2,\n",
        "            )\n",
        "            for submob in equator.get_family():\n",
        "                submob.shade_in_3d = True\n",
        "            equator.set_stroke(YELLOW, 5)\n",
        "            equator.apply_matrix(get_rot_matrix())\n",
        "            self.project_mobject(equator)\n",
        "            return equator\n",
        "\n",
        "        projected_equator = get_projected_equator()\n",
        "        projected_equator.add_updater(\n",
        "            lambda m: m.become(get_projected_equator())\n",
        "        )\n",
        "\n",
        "        self.add(sphere, projected_sphere)\n",
        "        self.move_camera(phi=60 * DEGREES)\n",
        "        self.play(\n",
        "            sphere.set_fill_by_checkerboard,\n",
        "            BLUE_E, BLUE_D, {\"opacity\": 0.8},\n",
        "            FadeIn(projected_sphere)\n",
        "        )\n",
        "        sphere.add(coord_point_mobs)\n",
        "        sphere.add(self.equator)\n",
        "        self.add(projected_equator)\n",
        "        pairs = self.get_sample_rotation_angle_axis_pairs()\n",
        "        for x in range(self.n_sample_rotation_cycles):\n",
        "            for angle, axis in pairs:\n",
        "                self.play(\n",
        "                    Rotate(\n",
        "                        sphere, angle=angle, axis=axis,\n",
        "                        about_point=ORIGIN,\n",
        "                        run_time=3,\n",
        "                    ),\n",
        "                    felix.change, \"confused\",\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "        self.projected_sphere = projected_sphere\n",
        "\n",
        "    #\n",
        "    def project_mobject(self, mobject):\n",
        "        return stereo_project(mobject, axis=2, r=2, outer_r=20)\n",
        "\n",
        "    def project_point(self, point):\n",
        "        return stereo_project_point(point, axis=2, r=2)\n",
        "\n",
        "    def get_sample_rotation_angle_axis_pairs(self):\n",
        "        return SphereExamplePointsDecimal.CONFIG.get(\n",
        "            \"point_rotation_angle_axis_pairs\"\n",
        "        )\n",
        "\n",
        "\n",
        "class FelixViewOfProjection(TwoDStereographicProjection):\n",
        "    CONFIG = {}\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.show_a_few_rotations()\n",
        "\n",
        "    def add_axes(self):\n",
        "        axes = Axes(\n",
        "            axis_config={\n",
        "                \"unit_size\": 2,\n",
        "                \"color\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        labels = VGroup(\n",
        "            OldTex(\"i\"),\n",
        "            OldTex(\"-i\"),\n",
        "            OldTex(\"j\"),\n",
        "            OldTex(\"-j\"),\n",
        "            OldTex(\"1\"),\n",
        "        )\n",
        "        coords = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 0)]\n",
        "        vects = [DOWN, DOWN, RIGHT, RIGHT, 0.25 * DR]\n",
        "        for label, coords, vect in zip(labels, coords, vects):\n",
        "            point = axes.coords_to_point(*coords)\n",
        "            label.next_to(point, vect, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(axes, labels)\n",
        "        self.pi_creature.change(\"confused\")\n",
        "\n",
        "    def show_a_few_rotations(self):\n",
        "        felix = self.pi_creature\n",
        "        coord_point_mobs = VGroup([\n",
        "            VectorizedPoint(point)\n",
        "            for point in [RIGHT, UP, OUT]\n",
        "        ])\n",
        "\n",
        "        def get_rot_matrix():\n",
        "            return np.array([\n",
        "                pm.get_location()\n",
        "                for pm in coord_point_mobs\n",
        "            ]).T\n",
        "\n",
        "        def get_projected_sphere():\n",
        "            return StereoProjectedSphere(\n",
        "                get_rot_matrix(),\n",
        "                **self.sphere_config,\n",
        "            )\n",
        "\n",
        "        def get_projected_equator():\n",
        "            equator = Circle(radius=2, num_anchors=24)\n",
        "            equator.set_stroke(YELLOW, 5)\n",
        "            equator.apply_matrix(get_rot_matrix())\n",
        "            self.project_mobject(equator)\n",
        "            return equator\n",
        "\n",
        "        projected_sphere = get_projected_sphere()\n",
        "        projected_sphere.add_updater(\n",
        "            lambda m: m.become(get_projected_sphere())\n",
        "        )\n",
        "\n",
        "        equator = get_projected_equator()\n",
        "        equator.add_updater(\n",
        "            lambda m: m.become(get_projected_equator())\n",
        "        )\n",
        "\n",
        "        dot = Dot(color=PINK)\n",
        "        dot.add_updater(\n",
        "            lambda d: d.move_to(\n",
        "                self.project_point(\n",
        "                    np.dot(2 * OUT, get_rot_matrix().T)\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        hand = Hand()\n",
        "        hand.add_updater(\n",
        "            lambda h: h.move_to(dot.get_center(), LEFT)\n",
        "        )\n",
        "        felix.add_updater(lambda f: f.look_at(dot))\n",
        "\n",
        "        self.add(projected_sphere)\n",
        "        self.add(equator)\n",
        "        self.add(dot)\n",
        "        self.add(hand)\n",
        "\n",
        "        pairs = self.get_sample_rotation_angle_axis_pairs()\n",
        "        for x in range(self.n_sample_rotation_cycles):\n",
        "            for angle, axis in pairs:\n",
        "                self.play(\n",
        "                    Rotate(\n",
        "                        coord_point_mobs, angle=angle, axis=axis,\n",
        "                        about_point=ORIGIN,\n",
        "                        run_time=3,\n",
        "                    ),\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "\n",
        "class ShowRotationsJustWithReferenceCircles(TwoDStereographicProjection):\n",
        "    CONFIG = {\n",
        "        \"flat_view\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_parts(run_time=1)\n",
        "        self.begin_ambient_camera_rotation(rate=0.03)\n",
        "        self.edit_parts()\n",
        "        self.show_1i_circle()\n",
        "        self.show_1j_circle()\n",
        "        self.show_random_circle()\n",
        "        self.show_rotations()\n",
        "\n",
        "    def edit_parts(self):\n",
        "        sphere = self.sphere\n",
        "        axes = self.axes\n",
        "        axes.set_stroke(width=1)\n",
        "        xy_plane = StereoProjectedSphere(u_max=15 * PI / 16)\n",
        "        xy_plane.set_fill(WHITE, 0.2)\n",
        "        xy_plane.set_stroke(width=0, opacity=0)\n",
        "\n",
        "        self.add(xy_plane, sphere)\n",
        "        self.play(\n",
        "            FadeIn(xy_plane),\n",
        "            sphere.set_fill, BLUE_E, {\"opacity\": 0.2},\n",
        "            sphere.set_stroke, {\"width\": 0.1, \"opacity\": 0.5}\n",
        "        )\n",
        "\n",
        "    def show_1i_circle(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        circle = self.get_circle(GREEN_E, GREEN)\n",
        "        circle.rotate(TAU / 4, RIGHT)\n",
        "        circle.rotate(TAU / 4, DOWN)\n",
        "\n",
        "        projected = self.get_projected_circle(circle)\n",
        "\n",
        "        labels = VGroup(*map(Tex, [\"0\", \"2i\", \"3i\"]))\n",
        "        labels.set_shade_in_3d(True)\n",
        "        if self.flat_view:\n",
        "            labels.fade(1)\n",
        "        for label, x in zip(labels, [0, 2, 3]):\n",
        "            label.next_to(\n",
        "                axes.coords_to_point(x, 0, 0), DR, SMALL_BUFF\n",
        "            )\n",
        "\n",
        "        self.play(ShowCreation(circle, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            circle.copy(), projected,\n",
        "            run_time=3\n",
        "        ))\n",
        "        # self.axes.x_axis.pieces.set_stroke(width=0)\n",
        "        self.wait(7)\n",
        "        self.move_camera(\n",
        "            phi=60 * DEGREES,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, labels,\n",
        "                lambda m: (m, UP)\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(labels))\n",
        "\n",
        "        self.one_i_circle = circle\n",
        "        self.projected_one_i_circle = projected\n",
        "\n",
        "    def show_1j_circle(self):\n",
        "        circle = self.get_circle(RED_E, RED)\n",
        "        circle.rotate(TAU / 4, DOWN)\n",
        "\n",
        "        projected = self.get_projected_circle(circle)\n",
        "\n",
        "        self.move_camera(theta=-170 * DEGREES)\n",
        "        self.play(ShowCreation(circle, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            circle.copy(), projected, run_time=3\n",
        "        ))\n",
        "        # self.axes.y_axis.pieces.set_stroke(width=0)\n",
        "        self.wait(3)\n",
        "\n",
        "        self.one_j_circle = circle\n",
        "        self.projected_one_j_circle = projected\n",
        "\n",
        "    def show_random_circle(self):\n",
        "        sphere = self.sphere\n",
        "\n",
        "        circle = self.get_circle(BLUE_E, BLUE)\n",
        "        circle.set_width(2 * sphere.radius * np.sin(30 * DEGREES))\n",
        "        circle.shift(sphere.radius * np.cos(30 * DEGREES) * OUT)\n",
        "        circle.rotate(150 * DEGREES, UP, about_point=ORIGIN)\n",
        "\n",
        "        projected = self.get_projected_circle(circle)\n",
        "\n",
        "        self.play(ShowCreation(circle, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            circle.copy(), projected,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(circle),\n",
        "            FadeOut(projected),\n",
        "        )\n",
        "\n",
        "    def show_rotations(self):\n",
        "        sphere = self.sphere\n",
        "        c1i = self.one_i_circle\n",
        "        pc1i = self.projected_one_i_circle\n",
        "        c1j = self.one_j_circle\n",
        "        pc1j = self.projected_one_j_circle\n",
        "        cij = self.get_circle(YELLOW_E, YELLOW)\n",
        "        pcij = self.get_projected_circle(cij)\n",
        "\n",
        "        circles = VGroup(c1i, c1j, cij)\n",
        "        x_axis = self.axes.x_axis\n",
        "        y_axis = self.axes.y_axis\n",
        "\n",
        "        arrow = Arrow(\n",
        "            2 * RIGHT, 2 * UP,\n",
        "            buff=SMALL_BUFF,\n",
        "            path_arc=PI,\n",
        "        )\n",
        "        arrow.set_stroke(GREY_B, 3)\n",
        "        arrow.tip.set_fill(GREY_B)\n",
        "        arrows = VGroup(arrow, *[\n",
        "            arrow.copy().rotate(angle, about_point=ORIGIN)\n",
        "            for angle in np.arange(TAU / 4, TAU, TAU / 4)\n",
        "        ])\n",
        "        arrows.rotate(TAU / 4, RIGHT, about_point=ORIGIN)\n",
        "        arrows.rotate(TAU / 2, OUT, about_point=ORIGIN)\n",
        "        arrows.rotate(TAU / 4, UP, about_point=ORIGIN)\n",
        "        arrows.space_out_submobjects(1.2)\n",
        "\n",
        "        self.play(FadeInFromLarge(cij))\n",
        "        sphere.add(circles)\n",
        "\n",
        "        pc1i.add_updater(\n",
        "            lambda c: c.become(self.get_projected_circle(c1i))\n",
        "        )\n",
        "        pc1j.add_updater(\n",
        "            lambda c: c.become(self.get_projected_circle(c1j))\n",
        "        )\n",
        "        pcij.add_updater(\n",
        "            lambda c: c.become(self.get_projected_circle(cij))\n",
        "        )\n",
        "        self.add(pcij)\n",
        "\n",
        "        # About j-axis\n",
        "        self.play(ShowCreation(arrows, run_time=3, rate_func=linear))\n",
        "        self.wait(3)\n",
        "        for x in range(2):\n",
        "            y_axis.pieces.set_stroke(width=1)\n",
        "            self.play(\n",
        "                Rotate(sphere, 90 * DEGREES, axis=UP),\n",
        "                run_time=4,\n",
        "            )\n",
        "            y_axis.pieces.set_stroke(width=0)\n",
        "            self.wait(2)\n",
        "\n",
        "        # About i axis\n",
        "        self.move_camera(theta=-45 * DEGREES)\n",
        "        self.play(Rotate(arrows, TAU / 4, axis=OUT))\n",
        "        self.wait(2)\n",
        "        for x in range(2):\n",
        "            x_axis.pieces.set_stroke(width=1)\n",
        "            self.play(\n",
        "                Rotate(sphere, -90 * DEGREES, axis=RIGHT),\n",
        "                run_time=4,\n",
        "            )\n",
        "            x_axis.pieces.set_stroke(width=0)\n",
        "            self.wait(2)\n",
        "        self.wait(2)\n",
        "\n",
        "        # About real axis\n",
        "        self.move_camera(\n",
        "            theta=-135 * DEGREES,\n",
        "            added_anims=[FadeOut(arrows)]\n",
        "        )\n",
        "        self.ambient_camera_rotation.rate = 0.01\n",
        "        for x in range(2):\n",
        "            x_axis.pieces.set_stroke(width=1)\n",
        "            y_axis.pieces.set_stroke(width=1)\n",
        "            self.play(\n",
        "                Rotate(sphere, 90 * DEGREES, axis=OUT),\n",
        "                run_time=4,\n",
        "            )\n",
        "            # x_axis.pieces.set_stroke(width=0)\n",
        "            # y_axis.pieces.set_stroke(width=0)\n",
        "            self.wait(2)\n",
        "\n",
        "    #\n",
        "    def get_circle(self, *colors):\n",
        "        sphere = self.sphere\n",
        "        circle = CheckeredCircle(colors=colors, n_pieces=48)\n",
        "        circle.set_shade_in_3d(True)\n",
        "        circle.match_width(sphere)\n",
        "        if self.flat_view:\n",
        "            circle[::2].fade(1)\n",
        "\n",
        "        return circle\n",
        "\n",
        "    def get_projected_circle(self, circle):\n",
        "        result = circle.deepcopy()\n",
        "        self.project_mobject(result)\n",
        "        result[::2].fade(1)\n",
        "        for sm in result:\n",
        "            if sm.get_width() > FRAME_WIDTH:\n",
        "                sm.fade(1)\n",
        "            if sm.get_height() > FRAME_HEIGHT:\n",
        "                sm.fade(1)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ReferernceSpheresFelixView(ShowRotationsJustWithReferenceCircles):\n",
        "    CONFIG = {\n",
        "        \"flat_view\": True,\n",
        "        \"lift_labels\": False,\n",
        "    }\n",
        "\n",
        "    def add_parts(self, **kwargs):\n",
        "        ShowRotationsJustWithReferenceCircles.add_parts(self, **kwargs)\n",
        "        one = OldTex(\"1\")\n",
        "        one.next_to(ORIGIN, DR, SMALL_BUFF)\n",
        "        self.add(one)\n",
        "\n",
        "    def get_default_camera_position(self):\n",
        "        return {}\n",
        "\n",
        "    def move_camera(self, **kwargs):\n",
        "        kwargs[\"phi\"] = 0\n",
        "        kwargs[\"theta\"] = -90 * DEGREES\n",
        "        ShowRotationsJustWithReferenceCircles.move_camera(self, **kwargs)\n",
        "\n",
        "    def begin_ambient_camera_rotation(self, rate):\n",
        "        self.ambient_camera_rotation = VectorizedPoint()\n",
        "\n",
        "    def capture_mobjects_in_camera(self, mobjects, **kwargs):\n",
        "        mobs_on_xy = [\n",
        "            sm\n",
        "            for sm in self.camera.extract_mobject_family_members(\n",
        "                mobjects, only_those_with_points=True\n",
        "            )\n",
        "            if abs(sm.get_center()[2]) < 0.001\n",
        "        ]\n",
        "        return Scene.capture_mobjects_in_camera(self, mobs_on_xy, **kwargs)\n",
        "\n",
        "\n",
        "class IntroduceQuaternions(Scene):\n",
        "    def construct(self):\n",
        "        self.compare_three_number_systems()\n",
        "        self.mention_four_perpendicular_axes()\n",
        "        self.bring_back_complex()\n",
        "        self.show_components_of_quaternion()\n",
        "\n",
        "    def compare_three_number_systems(self):\n",
        "        numbers = self.get_example_numbers()\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"Complex number\"),\n",
        "            OldTexText(\"Not-actually-a-number-system 3d number\"),\n",
        "            OldTexText(\"Quaternion\"),\n",
        "        )\n",
        "\n",
        "        for number, label in zip(numbers, labels):\n",
        "            label.next_to(number, UP, aligned_edge=LEFT)\n",
        "\n",
        "            self.play(\n",
        "                FadeInFromDown(number),\n",
        "                Write(label),\n",
        "            )\n",
        "            self.play(ShowCreationThenFadeAround(\n",
        "                number[2:],\n",
        "                surrounding_rectangle_config={\"color\": BLUE}\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        shift_size = FRAME_HEIGHT / 2 - labels[2].get_top()[1] - MED_LARGE_BUFF\n",
        "        self.play(\n",
        "            numbers.shift, shift_size * UP,\n",
        "            labels.shift, shift_size * UP,\n",
        "        )\n",
        "\n",
        "        self.numbers = numbers\n",
        "        self.labels = labels\n",
        "\n",
        "    def mention_four_perpendicular_axes(self):\n",
        "        number = self.numbers[2]\n",
        "        three_axes = VGroup(*[\n",
        "            self.get_simple_axes(label, color)\n",
        "            for label, color in zip(\n",
        "                [\"i\", \"j\", \"k\"],\n",
        "                [GREEN, RED, BLUE],\n",
        "            )\n",
        "        ])\n",
        "        three_axes.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        three_axes.next_to(number, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromLarge, three_axes))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.three_axes = three_axes\n",
        "\n",
        "    def bring_back_complex(self):\n",
        "        numbers = self.numbers\n",
        "        labels = self.labels\n",
        "        numbers[0].move_to(numbers[1], LEFT)\n",
        "        labels[0].move_to(labels[1], LEFT)\n",
        "        numbers.remove(numbers[1])\n",
        "        labels.remove(labels[1])\n",
        "\n",
        "        group = VGroup(numbers, labels)\n",
        "        self.play(\n",
        "            group.to_edge, UP,\n",
        "            FadeOut(self.three_axes, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_components_of_quaternion(self):\n",
        "        quat = self.numbers[-1]\n",
        "        real_part = quat[0]\n",
        "        imag_part = quat[2:]\n",
        "        real_brace = Brace(real_part, DOWN)\n",
        "        imag_brace = Brace(imag_part, DOWN)\n",
        "        real_word = OldTexText(\"Real \\\\\\\\ part\")\n",
        "        imag_word = OldTexText(\"Imaginary \\\\\\\\ part\")\n",
        "        scalar_word = OldTexText(\"Scalar \\\\\\\\ part\")\n",
        "        vector_word = OldTexText(\"``Vector'' \\\\\\\\ part\")\n",
        "        for word in real_word, scalar_word:\n",
        "            word.next_to(real_brace, DOWN, SMALL_BUFF)\n",
        "        for word in imag_word, vector_word:\n",
        "            word.next_to(imag_brace, DOWN, SMALL_BUFF)\n",
        "        braces = VGroup(real_brace, imag_brace)\n",
        "        VGroup(scalar_word, vector_word).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, VGroup(real_word, imag_word),\n",
        "                lambda m: (m, UP)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(real_word, DOWN),\n",
        "            FadeIn(scalar_word, DOWN),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ChangeDecimalToValue(real_part, 0))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(imag_word, DOWN),\n",
        "            FadeIn(vector_word, DOWN)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    #\n",
        "    def get_example_numbers(self):\n",
        "        number_2d = VGroup(\n",
        "            DecimalNumber(3.14),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(1.59),\n",
        "            OldTex(\"i\")\n",
        "        )\n",
        "        number_3d = VGroup(\n",
        "            DecimalNumber(2.65),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(3.58),\n",
        "            OldTex(\"i\"),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(9.79),\n",
        "            OldTex(\"j\"),\n",
        "        )\n",
        "        number_4d = VGroup(\n",
        "            DecimalNumber(3.23),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(8.46),\n",
        "            OldTex(\"i\"),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(2.64),\n",
        "            OldTex(\"j\"),\n",
        "            OldTex(\"+\"),\n",
        "            DecimalNumber(3.38),\n",
        "            OldTex(\"k\"),\n",
        "        )\n",
        "        numbers = VGroup(number_2d, number_3d, number_4d)\n",
        "        for number in numbers:\n",
        "            number.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            for part in number:\n",
        "                if isinstance(part, Tex):\n",
        "                    # part.set_color_by_tex_to_color_map({\n",
        "                    #     \"i\": GREEN,\n",
        "                    #     \"j\": RED,\n",
        "                    #     \"k\": BLUE,\n",
        "                    # })\n",
        "                    if part.get_tex() == \"j\":\n",
        "                        part.shift(0.5 * SMALL_BUFF * DL)\n",
        "            number[2].set_color(GREEN)\n",
        "            if len(number) > 5:\n",
        "                number[5].set_color(RED)\n",
        "            if len(number) > 8:\n",
        "                number[8].set_color(BLUE)\n",
        "        numbers.arrange(\n",
        "            DOWN, buff=2, aligned_edge=LEFT\n",
        "        )\n",
        "        numbers.center()\n",
        "        numbers.shift(LEFT)\n",
        "        return numbers\n",
        "\n",
        "    def get_simple_axes(self, label, color):\n",
        "        axes = Axes(\n",
        "            x_min=-2.5,\n",
        "            x_max=2.5,\n",
        "            y_min=-2.5,\n",
        "            y_max=2.5,\n",
        "        )\n",
        "        axes.set_height(2.5)\n",
        "        label_mob = OldTex(label)\n",
        "        label_mob.set_color(color)\n",
        "        label_mob.next_to(axes.coords_to_point(0, 1.5), RIGHT, SMALL_BUFF)\n",
        "        reals_label_mob = OldTexText(\"Reals\")\n",
        "        reals_label_mob.next_to(\n",
        "            axes.coords_to_point(1, 0), DR, SMALL_BUFF\n",
        "        )\n",
        "        axes.add(label_mob, reals_label_mob)\n",
        "        return axes\n",
        "\n",
        "\n",
        "class SimpleImaginaryQuaternionAxes(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        self.three_d_axes_config.update({\n",
        "            \"axis_config\": {\"unit_size\": 2},\n",
        "            \"x_min\": -2,\n",
        "            \"x_max\": 2,\n",
        "            \"y_min\": -2,\n",
        "            \"y_max\": 2,\n",
        "            \"z_min\": -1.25,\n",
        "            \"z_max\": 1.25,\n",
        "        })\n",
        "        axes = self.get_axes()\n",
        "        labels = VGroup(*[\n",
        "            OldTex(tex).set_color(color)\n",
        "            for tex, color in zip(\n",
        "                [\"i\", \"j\", \"k\"],\n",
        "                [GREEN, RED, BLUE]\n",
        "            )\n",
        "        ])\n",
        "        labels[0].next_to(axes.coords_to_point(1, 0, 0), DOWN + IN, SMALL_BUFF)\n",
        "        labels[1].next_to(axes.coords_to_point(0, 1, 0), RIGHT, SMALL_BUFF)\n",
        "        labels[2].next_to(axes.coords_to_point(0, 0, 1), RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(labels)\n",
        "        for label in labels:\n",
        "            self.add_fixed_orientation_mobjects(label)\n",
        "\n",
        "        self.move_camera(**self.get_default_camera_position())\n",
        "        self.begin_ambient_camera_rotation(rate=0.05)\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class ShowDotProductCrossProductFromOfQMult(Scene):\n",
        "    def construct(self):\n",
        "        v_tex = \"\\\\vec{\\\\textbf{v}}\"\n",
        "        product = OldTex(\n",
        "            \"(\", \"w_1\", \"+\",\n",
        "            \"x_1\", \"i\", \"+\", \"y_1\", \"j\", \"+\", \"z_1\", \"k\", \")\"\n",
        "            \"(\", \"w_2\", \"+\",\n",
        "            \"x_2\", \"i\", \"+\", \"y_2\", \"j\", \"+\", \"z_2\", \"k\", \")\",\n",
        "            \"=\",\n",
        "            \"(w_1\", \",\", v_tex + \"_1\", \")\",\n",
        "            \"(w_2\", \",\", v_tex + \"_2\", \")\",\n",
        "            \"=\"\n",
        "        )\n",
        "        product.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        i1 = product.index_of_part_by_tex(\"x_1\")\n",
        "        i2 = product.index_of_part_by_tex(\")\")\n",
        "        i3 = product.index_of_part_by_tex(\"x_2\")\n",
        "        i4 = product.index_of_part_by_tex(\"z_2\") + 2\n",
        "        vector_parts = [product[i1:i2], product[i3:i4]]\n",
        "\n",
        "        vector_defs = VGroup()\n",
        "        braces = VGroup()\n",
        "        for i, vp in zip(it.count(1), vector_parts):\n",
        "            brace = Brace(vp, UP)\n",
        "            vector = Matrix([\n",
        "                [\"x_\" + str(i)],\n",
        "                [\"y_\" + str(i)],\n",
        "                [\"z_\" + str(i)],\n",
        "            ])\n",
        "            colors = [GREEN, RED, BLUE]\n",
        "            for mob, color in zip(vector.get_entries(), colors):\n",
        "                mob.set_color(color)\n",
        "            group = VGroup(\n",
        "                OldTex(\"{}_{} = \".format(v_tex, i)),\n",
        "                vector,\n",
        "            )\n",
        "            group.arrange(RIGHT, SMALL_BUFF)\n",
        "            group.next_to(brace, UP)\n",
        "\n",
        "            braces.add(brace)\n",
        "            vector_defs.add(group)\n",
        "\n",
        "        result = OldTex(\n",
        "            \"\\\\left(\", \"w_1\", \"w_2\",\n",
        "            \"-\", v_tex + \"_1\", \"\\\\cdot\", v_tex, \"_2\", \",\\\\,\",\n",
        "            \"w_1\", v_tex + \"_2\", \"+\", \"w_2\", v_tex + \"_1\",\n",
        "            \"+\", \"{}_1 \\\\times {}_2\".format(v_tex, v_tex),\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        result.match_width(product)\n",
        "        result.next_to(product, DOWN, LARGE_BUFF)\n",
        "        for mob in product, result:\n",
        "            mob.set_color_by_tex_to_color_map({\n",
        "                \"w\": YELLOW,\n",
        "                \"x\": GREEN,\n",
        "                \"y\": RED,\n",
        "                \"z\": BLUE,\n",
        "            })\n",
        "            mob.set_color_by_tex(v_tex, WHITE)\n",
        "\n",
        "        self.add(product)\n",
        "        self.add(braces)\n",
        "        self.add(vector_defs)\n",
        "        self.play(LaggedStartMap(FadeInFromLarge, result))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowComplexMagnitude(ShowComplexMultiplicationExamples):\n",
        "    def construct(self):\n",
        "        self.add_planes()\n",
        "        plane = self.plane\n",
        "        tex_to_color_map = {\n",
        "            \"a\": YELLOW,\n",
        "            \"b\": GREEN,\n",
        "        }\n",
        "\n",
        "        z = complex(3, 2)\n",
        "        z_point = plane.number_to_point(z)\n",
        "        z_dot = Dot(z_point)\n",
        "        z_dot.set_color(PINK)\n",
        "        z_line = Line(plane.number_to_point(0), z_point)\n",
        "        z_line.set_stroke(WHITE, 2)\n",
        "        z_label = OldTex(\n",
        "            \"z\", \"=\", \"a\", \"+\", \"b\", \"i\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        z_label.add_background_rectangle()\n",
        "        z_label.next_to(z_dot, UR, buff=SMALL_BUFF)\n",
        "        z_norm_label = OldTex(\"||z||\")\n",
        "        z_norm_label.add_background_rectangle()\n",
        "        z_norm_label.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "        z_norm_label.rotate(z_line.get_angle(), about_point=ORIGIN)\n",
        "        z_norm_label.shift(z_line.get_center())\n",
        "\n",
        "        h_line = Line(\n",
        "            plane.number_to_point(0),\n",
        "            plane.number_to_point(z.real),\n",
        "            stroke_color=YELLOW,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "        v_line = Line(\n",
        "            plane.number_to_point(z.real),\n",
        "            plane.number_to_point(z),\n",
        "            stroke_color=GREEN,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "\n",
        "        z_norm_equation = OldTex(\n",
        "            \"||z||\", \"=\", \"\\\\sqrt\", \"{a^2\", \"+\", \"b^2\", \"}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        z_norm_equation.set_background_stroke(width=0)\n",
        "        z_norm_equation.add_background_rectangle()\n",
        "        z_norm_equation.next_to(z_label, UP)\n",
        "\n",
        "        self.add(z_line, h_line, v_line, z_dot, z_label)\n",
        "        self.play(ShowCreation(z_line))\n",
        "        self.play(FadeInFromDown(z_norm_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(z_norm_equation[0]),\n",
        "            FadeIn(z_norm_equation[2:]),\n",
        "            TransformFromCopy(\n",
        "                z_norm_label[1:],\n",
        "                VGroup(z_norm_equation[1]),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BreakUpQuaternionMultiplicationInParts(Scene):\n",
        "    def construct(self):\n",
        "        q1_color = MAROON_B\n",
        "        q2_color = YELLOW\n",
        "\n",
        "        product = OldTex(\n",
        "            \"q_1\", \"\\\\cdot\", \"q_2\", \"=\",\n",
        "            \"\\\\left(\", \"{q_1\", \"\\\\over\", \"||\", \"q_1\", \"||}\", \"\\\\right)\",\n",
        "            \"||\", \"q_1\", \"||\", \"\\\\cdot\", \"q_2\",\n",
        "        )\n",
        "        product.set_color_by_tex(\"q_1\", q1_color)\n",
        "        product.set_color_by_tex(\"q_2\", q2_color)\n",
        "        lhs = product[:3]\n",
        "        scale_part = product[-5:]\n",
        "        rotate_part = product[4:-5]\n",
        "        lhs_rect = SurroundingRectangle(lhs)\n",
        "        lhs_rect.set_color(YELLOW)\n",
        "        lhs_words = OldTexText(\"Quaternion \\\\\\\\ multiplication\")\n",
        "        lhs_words.next_to(lhs_rect, UP, LARGE_BUFF)\n",
        "        scale_brace = Brace(scale_part, UP)\n",
        "        rotate_brace = Brace(rotate_part, DOWN)\n",
        "        scale_words = OldTexText(\"Scale\", \"$q_2$\")\n",
        "        scale_words.set_color_by_tex(\"q_2\", q2_color)\n",
        "        scale_words.next_to(scale_brace, UP)\n",
        "        rotate_words = OldTexText(\"Apply special \\\\\\\\ 4d rotation\")\n",
        "        rotate_words.next_to(rotate_brace, DOWN)\n",
        "\n",
        "        norm_equation = OldTex(\n",
        "            \"||\", \"q_1\", \"||\", \"=\",\n",
        "            \"||\", \"w_1\", \"+\",\n",
        "            \"x_1\", \"i\", \"+\",\n",
        "            \"y_1\", \"j\", \"+\",\n",
        "            \"z_1\", \"k\", \"||\", \"=\",\n",
        "            \"\\\\sqrt\",\n",
        "            \"{w_1^2\", \"+\",\n",
        "            \"x_1^2\", \"+\",\n",
        "            \"y_1^2\", \"+\",\n",
        "            \"z_1^2\", \"}\",\n",
        "        )\n",
        "        # norm_equation.set_color_by_tex_to_color_map({\n",
        "        #     \"w\": YELLOW,\n",
        "        #     \"x\": GREEN,\n",
        "        #     \"y\": RED,\n",
        "        #     \"z\": BLUE,\n",
        "        # })\n",
        "        norm_equation.set_color_by_tex(\"q_1\", q1_color)\n",
        "        norm_equation.to_edge(UP)\n",
        "        norm_equation.set_background_stroke(width=0)\n",
        "\n",
        "        line1 = Line(ORIGIN, 0.5 * LEFT + 3 * UP)\n",
        "        line2 = Line(ORIGIN, UR)\n",
        "        zero_dot = Dot()\n",
        "        zero_label = OldTex(\"0\")\n",
        "        zero_label.next_to(zero_dot, DOWN, SMALL_BUFF)\n",
        "        q1_dot = Dot(line1.get_end())\n",
        "        q2_dot = Dot(line2.get_end())\n",
        "        q1_label = OldTex(\"q_1\").next_to(q1_dot, UP, SMALL_BUFF)\n",
        "        q2_label = OldTex(\"q_2\").next_to(q2_dot, UR, SMALL_BUFF)\n",
        "        VGroup(q1_dot, q1_label).set_color(q1_color)\n",
        "        VGroup(q2_dot, q2_label).set_color(q2_color)\n",
        "        dot_group = VGroup(\n",
        "            line1, line2, q1_dot, q2_dot, q1_label, q2_label,\n",
        "            zero_dot, zero_label,\n",
        "        )\n",
        "        dot_group.set_height(3)\n",
        "        dot_group.center()\n",
        "        dot_group.to_edge(LEFT)\n",
        "\n",
        "        q1_dot.add_updater(lambda d: d.move_to(line1.get_end()))\n",
        "        q1_label.add_updater(lambda l: l.next_to(q1_dot, UP, SMALL_BUFF))\n",
        "        q2_dot.add_updater(lambda d: d.move_to(line2.get_end()))\n",
        "        q2_label.add_updater(lambda l: l.next_to(q2_dot, UR, SMALL_BUFF))\n",
        "\n",
        "        self.add(norm_equation)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(lhs),\n",
        "            Write(dot_group),\n",
        "        )\n",
        "        self.add(*dot_group)\n",
        "        self.add(\n",
        "            VGroup(line2, q2_dot, q2_label).copy().fade(0.5)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lhs_rect),\n",
        "            FadeIn(lhs_words)\n",
        "        )\n",
        "        self.play(FadeOut(lhs_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(lhs, product[3:]),\n",
        "            # FadeOut(lhs_words)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(scale_brace),\n",
        "            Write(scale_words),\n",
        "        )\n",
        "        self.play(\n",
        "            line2.scale, 2, {\"about_point\": line2.get_start()}\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(rotate_brace),\n",
        "            FadeIn(rotate_words, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                line2, -line1.get_angle(),\n",
        "                about_point=line2.get_start(),\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask\n",
        "        randy = Randolph(height=2)\n",
        "        randy.flip()\n",
        "        randy.next_to(rotate_words, RIGHT)\n",
        "        randy.to_edge(DOWN)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        random.shuffle(q_marks.submobjects)\n",
        "        q_marks.next_to(randy, UP)\n",
        "        self.play(\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change, \"confused\", rotate_words,\n",
        "            ShowCreationThenFadeAround(rotate_words),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, q_marks,\n",
        "            lambda m: (m, LEFT),\n",
        "            lag_ratio=0.8,\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SphereProjectionsWrapper(Scene):\n",
        "    def construct(self):\n",
        "        rect_rows = VGroup(*[\n",
        "            VGroup(*[\n",
        "                ScreenRectangle(height=3)\n",
        "                for x in range(3)\n",
        "            ]).arrange(RIGHT, buff=LARGE_BUFF)\n",
        "            for y in range(2)\n",
        "        ]).arrange(DOWN, buff=2 * LARGE_BUFF)\n",
        "        rect_rows.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        sphere_labels = VGroup(\n",
        "            OldTexText(\"Circle in 2d\"),\n",
        "            OldTexText(\"Sphere in 3d\"),\n",
        "            OldTexText(\"Hypersphere in 4d\"),\n",
        "        )\n",
        "        for label, rect in zip(sphere_labels, rect_rows[0]):\n",
        "            label.next_to(rect, UP)\n",
        "\n",
        "        projected_labels = VGroup(\n",
        "            OldTexText(\"Sterographically projected \\\\\\\\ circle in 1d\"),\n",
        "            OldTexText(\"Sterographically projected \\\\\\\\ sphere in 2d\"),\n",
        "            OldTexText(\"Sterographically projected \\\\\\\\ hypersphere in 3d\"),\n",
        "        )\n",
        "        for label, rect in zip(projected_labels, rect_rows[1]):\n",
        "            label.match_width(rect)\n",
        "            label.next_to(rect, UP)\n",
        "\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.scale(2)\n",
        "        q_marks.move_to(rect_rows[0][2])\n",
        "\n",
        "        self.add(rect_rows)\n",
        "        for l1, l2 in zip(sphere_labels, projected_labels):\n",
        "            added_anims = []\n",
        "            if l1 is sphere_labels[2]:\n",
        "                added_anims.append(FadeIn(q_marks))\n",
        "            self.play(FadeIn(l1), *added_anims)\n",
        "            self.play(FadeIn(l2))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class HypersphereStereographicProjection(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        # \"fancy_dot\": False,\n",
        "        \"fancy_dot\": True,\n",
        "        \"initial_quaternion_sample_values\": [\n",
        "            [0, 1, 0, 0],\n",
        "            [-1, 1, 0, 0],\n",
        "            [0, 0, 1, 1],\n",
        "            [0, 1, -1, 1],\n",
        "        ],\n",
        "        \"unit_labels_scale_factor\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.introduce_quaternion_label()\n",
        "        self.show_one()\n",
        "        self.show_unit_sphere()\n",
        "        self.show_quaternions_with_nonzero_real_part()\n",
        "        self.emphasize_only_units()\n",
        "        self.show_reference_spheres()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.axes = self.get_axes()\n",
        "        axes.set_stroke(width=1)\n",
        "        self.add(axes)\n",
        "        self.move_camera(\n",
        "            **self.get_default_camera_position(),\n",
        "            run_time=0\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "\n",
        "    def introduce_quaternion_label(self):\n",
        "        q_tracker = QuaternionTracker()\n",
        "        coords = [\n",
        "            DecimalNumber(0, color=color, include_sign=sign, edge_to_fix=RIGHT)\n",
        "            for color, sign in zip(\n",
        "                [YELLOW, GREEN, RED, BLUE],\n",
        "                [False, True, True, True],\n",
        "            )\n",
        "        ]\n",
        "        label = VGroup(\n",
        "            coords[0], VectorizedPoint(),\n",
        "            coords[1], OldTex(\"i\"),\n",
        "            coords[2], OldTex(\"j\"),\n",
        "            coords[3], OldTex(\"k\"),\n",
        "        )\n",
        "        label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        label.to_corner(UR)\n",
        "\n",
        "        def update_label(label):\n",
        "            self.remove_fixed_in_frame_mobjects(label)\n",
        "            quat = q_tracker.get_value()\n",
        "            for value, coord in zip(quat, label[::2]):\n",
        "                coord.set_value(value)\n",
        "            self.add_fixed_in_frame_mobjects(label)\n",
        "            return label\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "        self.pink_dot_label = label\n",
        "\n",
        "        def get_pq_point():\n",
        "            point = self.project_quaternion(q_tracker.get_value())\n",
        "            if get_norm(point) > 100:\n",
        "                return point * 100 / get_norm(point)\n",
        "            return point\n",
        "\n",
        "        pq_dot = self.get_dot()\n",
        "        pq_dot.add_updater(lambda d: d.move_to(get_pq_point()))\n",
        "        dot_radius = pq_dot.get_width() / 2\n",
        "\n",
        "        def get_pq_line():\n",
        "            point = get_pq_point()\n",
        "            norm = get_norm(point)\n",
        "            origin = self.axes.coords_to_point(0, 0, 0)\n",
        "            if norm > dot_radius:\n",
        "                point -= origin\n",
        "                point *= (norm - dot_radius) / norm\n",
        "                point += origin\n",
        "            result = Line(origin, point)\n",
        "            result.set_stroke(width=1)\n",
        "            return result\n",
        "\n",
        "        pq_line = get_pq_line()\n",
        "        pq_line.add_updater(lambda cl: cl.become(get_pq_line()))\n",
        "\n",
        "        self.add(q_tracker, label, pq_line, pq_dot)\n",
        "\n",
        "        self.q_tracker = q_tracker\n",
        "        self.q_label = label\n",
        "        self.pq_line = pq_line\n",
        "        self.pq_dot = pq_dot\n",
        "\n",
        "        rect = SurroundingRectangle(label, color=WHITE)\n",
        "        self.add_fixed_in_frame_mobjects(rect)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.remove_fixed_orientation_mobjects(rect)\n",
        "\n",
        "        for value in self.initial_quaternion_sample_values:\n",
        "            self.set_quat(value)\n",
        "            self.wait()\n",
        "\n",
        "    def show_one(self):\n",
        "        q_tracker = self.q_tracker\n",
        "\n",
        "        one_label = OldTex(\"1\")\n",
        "        one_label.rotate(TAU / 4, RIGHT)\n",
        "        one_label.next_to(ORIGIN, IN + RIGHT, SMALL_BUFF)\n",
        "        one_label.set_shade_in_3d(True)\n",
        "        one_label.set_background_stroke(width=0)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                q_tracker.set_value, [1, 0, 0, 0],\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeInFromDown(one_label)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def show_unit_sphere(self):\n",
        "        sphere = self.sphere = self.get_projected_sphere(\n",
        "            quaternion=[1, 0, 0, 0], null_axis=0,\n",
        "            solid=False,\n",
        "            stroke_width=0.5\n",
        "        )\n",
        "        self.specially_color_sphere(sphere)\n",
        "        labels = self.get_unit_labels()\n",
        "        labels.remove(labels[3])\n",
        "\n",
        "        real_part = self.q_label[0]\n",
        "        brace = Brace(real_part, DOWN)\n",
        "        words = OldTexText(\"Real part zero\")\n",
        "        words.next_to(brace, DOWN, SMALL_BUFF, LEFT)\n",
        "\n",
        "        self.play(Write(sphere))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, labels,\n",
        "            lambda m: (m, IN)\n",
        "        ))\n",
        "        self.add_fixed_in_frame_mobjects(brace, words)\n",
        "        self.set_quat(\n",
        "            [0, 1, 0, 0],\n",
        "            added_anims=[\n",
        "                GrowFromCenter(brace),\n",
        "                Write(words),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.set_quat([0, 1, -1, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([0, -1, -1, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([0, 0, 0, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([0, 0, -1, 0])\n",
        "        self.wait(2)\n",
        "        self.set_quat([0, 1, 0, 0])\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(words))\n",
        "        self.remove_fixed_in_frame_mobjects(words)\n",
        "\n",
        "        self.real_part_brace = brace\n",
        "\n",
        "    def show_quaternions_with_nonzero_real_part(self):\n",
        "        # Positive real part\n",
        "        self.set_quat(\n",
        "            [1, 1, 2, 0],\n",
        "            added_anims=[\n",
        "                ApplyMethod(\n",
        "                    self.sphere.copy().scale, 0,\n",
        "                    remover=True\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.set_quat([4, 0, -1, -1])\n",
        "        self.wait(2)\n",
        "        # Negative real part\n",
        "        self.set_quat(\n",
        "            [-1, 1, 2, 0],\n",
        "            added_anims=[\n",
        "                ApplyFunction(\n",
        "                    lambda s: s.scale(10).fade(1),\n",
        "                    self.sphere.copy(),\n",
        "                    remover=True\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.set_quat([-2, 0, -1, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([-1, 1, 0, 0])\n",
        "        self.move_camera(theta=-160 * DEGREES, run_time=3)\n",
        "        self.set_quat([-1, 0.001, 0, 0])\n",
        "        self.wait(2)\n",
        "\n",
        "    def emphasize_only_units(self):\n",
        "        q_label = self.q_label\n",
        "        brace = self.real_part_brace\n",
        "\n",
        "        brace.target = Brace(q_label, DOWN, buff=SMALL_BUFF)\n",
        "        words = OldTexText(\n",
        "            \"Only those where \\\\\\\\\",\n",
        "            \"$w^2 + x^2 + y^2 + z^2 = 1$\"\n",
        "        )\n",
        "        words.next_to(brace.target, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(words)\n",
        "        self.play(\n",
        "            MoveToTarget(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.set_quat([1, 1, 1, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([1, 1, -1, 1])\n",
        "        self.wait(2)\n",
        "        self.set_quat([-1, 1, -1, 1])\n",
        "        self.wait(8)\n",
        "        self.play(FadeOut(brace), FadeOut(words))\n",
        "        self.remove_fixed_in_frame_mobjects(brace, words)\n",
        "\n",
        "    # TODO\n",
        "    def show_reference_spheres(self):\n",
        "        sphere = self.sphere\n",
        "        self.move_camera(\n",
        "            phi=60 * DEGREES,\n",
        "            theta=-150 * DEGREES,\n",
        "            added_anims=[\n",
        "                self.q_tracker.set_value, [1, 0, 0, 0]\n",
        "            ]\n",
        "        )\n",
        "        sphere_ijk = self.get_projected_sphere(null_axis=0)\n",
        "        sphere_1jk = self.get_projected_sphere(null_axis=1)\n",
        "        sphere_1ik = self.get_projected_sphere(null_axis=2)\n",
        "        sphere_1ij = self.get_projected_sphere(null_axis=3)\n",
        "        circle = StereoProjectedCircleFromHypersphere(axes=[0, 1])\n",
        "\n",
        "        circle_words = OldTexText(\n",
        "            \"Circle through\\\\\\\\\", \"$1, i, -1, -i$\"\n",
        "        )\n",
        "        sphere_1ij_words = OldTexText(\n",
        "            \"Sphere through\\\\\\\\\", \"$1, i, j, -1, -i, -j$\"\n",
        "        )\n",
        "        sphere_1jk_words = OldTexText(\n",
        "            \"Sphere through\\\\\\\\\", \"$1, j, k, -1, -j, -k$\"\n",
        "        )\n",
        "        sphere_1ik_words = OldTexText(\n",
        "            \"Sphere through\\\\\\\\\", \"$1, i, k, -1, -i, -k$\"\n",
        "        )\n",
        "        for words in [circle_words, sphere_1ij_words, sphere_1jk_words, sphere_1ik_words]:\n",
        "            words.to_corner(UL)\n",
        "            self.add_fixed_in_frame_mobjects(words)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Write(circle_words),\n",
        "        )\n",
        "        self.set_quat([0, 1, 0, 0])\n",
        "        self.set_quat([1, 0, 0, 0])\n",
        "        self.remove(sphere)\n",
        "        sphere_ijk.match_style(sphere)\n",
        "        self.add(sphere_ijk)\n",
        "\n",
        "        # Show xy plane\n",
        "        self.play(\n",
        "            FadeOut(circle_words, DOWN),\n",
        "            FadeInFromDown(sphere_1ij_words),\n",
        "            FadeOut(circle),\n",
        "            sphere_ijk.set_stroke, {\"width\": 0.0}\n",
        "        )\n",
        "        self.play(Write(sphere_1ij))\n",
        "        self.wait(10)\n",
        "        return\n",
        "\n",
        "        # Show yz plane\n",
        "        self.play(\n",
        "            FadeOut(sphere_1ij_words, DOWN),\n",
        "            FadeInFromDown(sphere_1jk_words),\n",
        "            sphere_1ij.set_fill, BLUE_E, 0.25,\n",
        "            sphere_1ij.set_stroke, {\"width\": 0.0},\n",
        "            Write(sphere_1jk)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show xz plane\n",
        "        self.play(\n",
        "            FadeOut(sphere_1jk_words, DOWN),\n",
        "            FadeInFromDown(sphere_1ik_words),\n",
        "            sphere_1jk.set_fill, GREEN_E, 0.25,\n",
        "            sphere_1jk.set_stroke, {\"width\": 0.0},\n",
        "            Write(sphere_1ik)\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            sphere_1ik.set_fill, RED_E, 0.25,\n",
        "            sphere_1ik.set_stroke, {\"width\": 0.0},\n",
        "            FadeOut(sphere_1ik_words)\n",
        "        )\n",
        "\n",
        "        # Start applying quaternion multiplication\n",
        "        kwargs = {\"solid\": False, \"stroke_width\": 0}\n",
        "        sphere_ijk.add_updater(\n",
        "            lambda s: s.become(self.get_projected_sphere(0, **kwargs))\n",
        "        )\n",
        "        sphere_1jk.add_updater(\n",
        "            lambda s: s.become(self.get_projected_sphere(1, **kwargs))\n",
        "        )\n",
        "        sphere_1ik.add_updater(\n",
        "            lambda s: s.become(self.get_projected_sphere(2, **kwargs))\n",
        "        )\n",
        "        sphere_1ij.add_updater(\n",
        "            lambda s: s.become(self.get_projected_sphere(3, **kwargs))\n",
        "        )\n",
        "\n",
        "        self.set_quat([0, 1, 1, 1])\n",
        "\n",
        "    #\n",
        "    def project_quaternion(self, quat):\n",
        "        return self.axes.coords_to_point(\n",
        "            *stereo_project_point(quat, axis=0, r=1)[1:]\n",
        "        )\n",
        "\n",
        "    def get_dot(self):\n",
        "        if self.fancy_dot:\n",
        "            sphere = self.get_sphere()\n",
        "            sphere.set_width(0.2)\n",
        "            sphere.set_stroke(width=0)\n",
        "            sphere.set_fill(PINK)\n",
        "            return sphere\n",
        "        else:\n",
        "            return VGroup(\n",
        "                Dot(color=PINK),\n",
        "                Dot(color=PINK).rotate(TAU / 4, RIGHT),\n",
        "            )\n",
        "\n",
        "    def get_unit_labels(self):\n",
        "        c2p = self.axes.coords_to_point\n",
        "        tex_coords_vects = [\n",
        "            (\"i\", [1, 0, 0], IN + RIGHT),\n",
        "            (\"-i\", [-1, 0, 0], IN + LEFT),\n",
        "            (\"j\", [0, 1, 0], UP + OUT + RIGHT),\n",
        "            (\"-j\", [0, -1, 0], RIGHT + DOWN),\n",
        "            (\"k\", [0, 0, 1], OUT + RIGHT),\n",
        "            (\"-k\", [0, 0, -1], IN + RIGHT),\n",
        "        ]\n",
        "        labels = VGroup()\n",
        "        for tex, coords, vect in tex_coords_vects:\n",
        "            label = OldTex(tex)\n",
        "            label.scale(self.unit_labels_scale_factor)\n",
        "            label.rotate(90 * DEGREES, RIGHT)\n",
        "            label.next_to(c2p(*coords), vect, SMALL_BUFF)\n",
        "            labels.add(label)\n",
        "        labels.set_shade_in_3d(True)\n",
        "        labels.set_background_stroke(width=0)\n",
        "        return labels\n",
        "\n",
        "    def set_quat(self, value, run_time=3, added_anims=None):\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "        self.play(\n",
        "            self.q_tracker.set_value, value,\n",
        "            *added_anims,\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "    def get_projected_sphere(self, null_axis, quaternion=None, solid=True, **kwargs):\n",
        "        if quaternion is None:\n",
        "            quaternion = self.get_multiplier()\n",
        "        axes_to_color = {\n",
        "            0: interpolate_color(YELLOW, BLACK, 0.5),\n",
        "            1: GREEN_E,\n",
        "            2: RED_D,\n",
        "            3: BLUE_E,\n",
        "        }\n",
        "        color = axes_to_color[null_axis]\n",
        "        config = dict(self.sphere_config)\n",
        "        config.update({\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 0.5,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "            \"max_r\": 24,\n",
        "        })\n",
        "        if solid:\n",
        "            config.update({\n",
        "                \"checkerboard_colors\": [\n",
        "                    color, interpolate_color(color, BLACK, 0.5)\n",
        "                ],\n",
        "                \"fill_opacity\": 1,\n",
        "            })\n",
        "        else:\n",
        "            config.update({\n",
        "                \"checkerboard_colors\": [],\n",
        "                \"fill_color\": color,\n",
        "                \"fill_opacity\": 0.25,\n",
        "            })\n",
        "        config.update(kwargs)\n",
        "        sphere = StereoProjectedSphereFromHypersphere(\n",
        "            quaternion=quaternion,\n",
        "            null_axis=null_axis,\n",
        "            **config\n",
        "        )\n",
        "        sphere.set_shade_in_3d(True)\n",
        "        return sphere\n",
        "\n",
        "    def get_projected_circle(self, quaternion=None, **kwargs):\n",
        "        if quaternion is None:\n",
        "            quaternion = self.get_multiplier()\n",
        "        return StereoProjectedCircleFromHypersphere(quaternion, **kwargs)\n",
        "\n",
        "    def get_multiplier(self):\n",
        "        return self.q_tracker.get_value()\n",
        "\n",
        "    def specially_color_sphere(self, sphere):\n",
        "        sphere.set_color_by_gradient(BLUE, GREEN, PINK)\n",
        "        return sphere\n",
        "        # for submob in sphere:\n",
        "        #     u, v = submob.u1, submob.v1\n",
        "        #     x = np.cos(v) * np.sin(u)\n",
        "        #     y = np.sin(v) * np.sin(u)\n",
        "        #     z = np.cos(u)\n",
        "        #     # rgb = sum([\n",
        "        #     #     (x**2) * hex_to_rgb(GREEN),\n",
        "        #     #     (y**2) * hex_to_rgb(RED),\n",
        "        #     #     (z**2) * hex_to_rgb(BLUE),\n",
        "        #     # ])\n",
        "        #     # clip_in_place(rgb, 0, 1)\n",
        "        #     # color = rgb_to_hex(rgb)\n",
        "        #     color = interpolate_color(BLUE, RED, ((z**3) + 1) / 2)\n",
        "        #     submob.set_fill(color)\n",
        "        # return sphere\n",
        "\n",
        "\n",
        "class MissingLabels(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(\n",
        "            OldTex(\"i\").move_to(UR),\n",
        "            OldTex(\"1\").move_to(0.3 * DOWN),\n",
        "            OldTex(\"-i\").move_to(DOWN + 1.2 * LEFT),\n",
        "            OldTex(\"-j\").move_to(1.7 * RIGHT + 0.8 * DOWN),\n",
        "        )\n",
        "        labels.set_background_stroke(width=0)\n",
        "        self.add(labels)\n",
        "\n",
        "\n",
        "class RuleOfQuaternionMultiplicationOverlay(Scene):\n",
        "    def construct(self):\n",
        "        q_mob, times_mob, p_mob = q_times_p = OldTex(\n",
        "            \"q\", \"\\\\cdot\", \"p\"\n",
        "        )\n",
        "        q_times_p.scale(2)\n",
        "        q_mob.set_color(MAROON_B)\n",
        "        p_mob.set_color(YELLOW)\n",
        "        q_arrow = Vector(DOWN, color=WHITE)\n",
        "        q_arrow.next_to(q_mob, UP)\n",
        "        p_arrow = Vector(UP, color=WHITE)\n",
        "        p_arrow.next_to(p_mob, DOWN)\n",
        "\n",
        "        q_words = OldTexText(\"Think of as\\\\\\\\ an action\")\n",
        "        q_words.next_to(q_arrow, UP)\n",
        "        p_words = OldTexText(\"Think of as\\\\\\\\ a point\")\n",
        "        p_words.next_to(p_arrow, DOWN)\n",
        "\n",
        "        i_mob = OldTex(\"i\")[0]\n",
        "        i_mob.scale(2)\n",
        "        i_mob.move_to(q_mob, RIGHT)\n",
        "        i_mob.set_color(GREEN)\n",
        "\n",
        "        self.add(q_times_p)\n",
        "        self.play(\n",
        "            FadeIn(q_words, UP),\n",
        "            GrowArrow(q_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(p_words, DOWN),\n",
        "            GrowArrow(p_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [\n",
        "            q_words, q_arrow,\n",
        "            p_words, p_arrow,\n",
        "        ]))\n",
        "        self.play(\n",
        "            FadeInFromDown(i_mob),\n",
        "            FadeOut(q_mob, UP)\n",
        "        )\n",
        "        product = VGroup(i_mob, times_mob, p_mob)\n",
        "        self.play(product.to_edge, UP)\n",
        "\n",
        "        # Show i products\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.set_width(product.get_width() + MED_SMALL_BUFF)\n",
        "        underline.next_to(product, DOWN)\n",
        "\n",
        "        kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"i\": GREEN,\n",
        "                \"j\": RED,\n",
        "                \"k\": BLUE\n",
        "            }\n",
        "        }\n",
        "        i_products = VGroup(\n",
        "            OldTex(\"i\", \"\\\\cdot\", \"1\", \"=\", \"i\", **kwargs),\n",
        "            OldTex(\"i\", \"\\\\cdot\", \"i\", \"=\", \"-1\", **kwargs),\n",
        "            OldTex(\"i\", \"\\\\cdot\", \"j\", \"=\", \"k\", **kwargs),\n",
        "            OldTex(\"i\", \"\\\\cdot\", \"k\", \"=\", \"-j\", **kwargs),\n",
        "        )\n",
        "        i_products.scale(2)\n",
        "        i_products.arrange(\n",
        "            DOWN, buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        i_products.next_to(underline, DOWN, LARGE_BUFF)\n",
        "        i_products.align_to(i_mob, LEFT)\n",
        "\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.wait()\n",
        "        for i_product in i_products:\n",
        "            self.play(TransformFromCopy(\n",
        "                product, i_product[:3]\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.play(TransformFromCopy(\n",
        "                i_product[:3], i_product[3:],\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(product, i_products),\n",
        "            buff=0.4\n",
        "        )\n",
        "        rect.set_stroke(WHITE, width=5)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class RuleOfQuaternionMultiplication(HypersphereStereographicProjection):\n",
        "    CONFIG = {\n",
        "        \"fancy_dot\": True,\n",
        "        \"initial_quaternion_sample_values\": [],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_all_trackers()\n",
        "        self.show_multiplication_by_i_on_circle_1i()\n",
        "        self.show_multiplication_by_i_on_circle_jk()\n",
        "        self.show_multiplication_by_i_on_ijk_sphere()\n",
        "\n",
        "    def setup_all_trackers(self):\n",
        "        self.setup_multiplier_tracker()\n",
        "        self.force_skipping()\n",
        "        self.setup_axes()\n",
        "        self.introduce_quaternion_label()\n",
        "        self.add_unit_labels()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def setup_multiplier_tracker(self):\n",
        "        self.multiplier_tracker = QuaternionTracker([1, 0, 0, 0])\n",
        "        self.multiplier_tracker.add_updater(\n",
        "            lambda m: m.set_value(normalize(\n",
        "                m.get_value(),\n",
        "                fall_back=[1, 0, 0, 0]\n",
        "            ))\n",
        "        )\n",
        "        self.add(self.multiplier_tracker)\n",
        "\n",
        "    def add_unit_labels(self):\n",
        "        labels = self.unit_labels = self.get_unit_labels()\n",
        "        one_label = OldTex(\"1\")\n",
        "        one_label.scale(self.unit_labels_scale_factor)\n",
        "        one_label.set_shade_in_3d(True)\n",
        "        one_label.rotate(90 * DEGREES, RIGHT)\n",
        "        one_label.next_to(ORIGIN, IN + RIGHT, SMALL_BUFF)\n",
        "        labels.add(one_label)\n",
        "        self.add(labels)\n",
        "\n",
        "    def show_multiplication_by_i_on_circle_1i(self):\n",
        "        m_tracker = self.multiplier_tracker\n",
        "\n",
        "        def get_circle_1i():\n",
        "            return self.get_projected_circle(\n",
        "                basis_vectors=[\n",
        "                    [1, 0, 0, 0],\n",
        "                    [1, 1, 0, 0],\n",
        "                ],\n",
        "                colors=[GREEN, YELLOW],\n",
        "                quaternion=m_tracker.get_value(),\n",
        "            )\n",
        "        circle = get_circle_1i()\n",
        "        arrows = self.get_i_circle_arrows()\n",
        "\n",
        "        def set_to_q_value(mt):\n",
        "            mt.set_value(self.q_tracker.get_value())\n",
        "\n",
        "        self.play(ShowCreation(circle, run_time=2))\n",
        "        self.play(LaggedStartMap(ShowCreation, arrows, lag_ratio=0.25))\n",
        "        self.wait()\n",
        "        circle.add_updater(lambda c: c.become(get_circle_1i()))\n",
        "        m_tracker.add_updater(set_to_q_value)\n",
        "        self.add(m_tracker)\n",
        "        self.set_quat([0, 1, 0, 0])\n",
        "        self.wait()\n",
        "        self.set_quat([-1, 0.001, 0, 0])\n",
        "        self.wait()\n",
        "        self.q_tracker.set_value([-1, -0.001, 0, 0])\n",
        "        self.set_quat([0, -1, 0, 0])\n",
        "        self.wait()\n",
        "        self.set_quat([1, 0, 0, 0])\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(arrows))\n",
        "\n",
        "        m_tracker.remove_updater(set_to_q_value)\n",
        "        self.circle_1i = circle\n",
        "\n",
        "    def show_multiplication_by_i_on_circle_jk(self):\n",
        "        def get_circle_jk():\n",
        "            return self.get_projected_circle(\n",
        "                basis_vectors=[\n",
        "                    [0, 0, 1, 0],\n",
        "                    [0, 0, 0, 1],\n",
        "                ],\n",
        "                colors=[RED, BLUE_E]\n",
        "            )\n",
        "        circle = get_circle_jk()\n",
        "        arrows = self.get_jk_circle_arrows()\n",
        "        m_tracker = self.multiplier_tracker\n",
        "        q_tracker = self.q_tracker\n",
        "\n",
        "        def set_q_to_mj(qt):\n",
        "            qt.set_value(q_mult(\n",
        "                m_tracker.get_value(), [0, 0, 1, 0]\n",
        "            ))\n",
        "\n",
        "        self.move_camera(theta=-50 * DEGREES)\n",
        "        self.play(ShowCreation(circle, run_time=2))\n",
        "        circle.add_updater(lambda c: c.become(get_circle_jk()))\n",
        "        self.wait(10)\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.begin_ambient_camera_rotation(rate=-0.01)\n",
        "        self.play(*map(ShowCreation, arrows))\n",
        "        self.wait()\n",
        "        self.set_quat([0, 0, 1, 0], run_time=1)\n",
        "        q_tracker.insert_updater(set_q_to_mj, index=0)\n",
        "        self.add(self.circle_1i)\n",
        "        self.play(\n",
        "            m_tracker.set_value, [0, 1, 0, 0],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            m_tracker.set_value, [-1, 0.001, 0, 0],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        m_tracker.set_value([-1, 0.001, 0, 0])\n",
        "        self.play(\n",
        "            m_tracker.set_value, [0, -1, 0, 0],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            m_tracker.set_value, [1, 0, 0, 0],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        q_tracker.remove_updater(set_q_to_mj)\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            q_tracker.set_value, [1, 0, 0, 0],\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "        self.circle_jk = circle\n",
        "\n",
        "    def show_multiplication_by_i_on_ijk_sphere(self):\n",
        "        m_tracker = self.multiplier_tracker\n",
        "        q_tracker = self.q_tracker\n",
        "        m_tracker.add_updater(lambda m: m.set_value(q_tracker.get_value()))\n",
        "\n",
        "        def get_sphere():\n",
        "            result = self.get_projected_sphere(null_axis=0, solid=False)\n",
        "            self.specially_color_sphere(result)\n",
        "            return result\n",
        "\n",
        "        sphere = get_sphere()\n",
        "\n",
        "        self.play(Write(sphere))\n",
        "        sphere.add_updater(lambda s: s.become(get_sphere()))\n",
        "\n",
        "        self.set_quat([0, 1, 0, 0])\n",
        "        self.wait()\n",
        "        self.set_quat([-1, 0.001, 0, 0])\n",
        "        self.wait()\n",
        "        self.q_tracker.set_value([-1, -0.001, 0, 0])\n",
        "        self.set_quat([0, -1, 0, 0])\n",
        "        self.wait()\n",
        "        self.set_quat([1, 0, 0, 0])\n",
        "        self.wait(3)\n",
        "\n",
        "    #\n",
        "    def get_multiplier(self):\n",
        "        return self.multiplier_tracker.get_value()\n",
        "\n",
        "    def get_i_circle_arrows(self):\n",
        "        c2p = self.axes.coords_to_point\n",
        "        i_arrow = Arrow(\n",
        "            ORIGIN, 2 * RIGHT, path_arc=-120 * DEGREES,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        neg_one_arrow = Arrow(\n",
        "            ORIGIN, 5.5 * RIGHT + UP,\n",
        "            path_arc=-30 * DEGREES,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        neg_i_arrow = Arrow(\n",
        "            4.5 * LEFT + 1.5 * UP, ORIGIN,\n",
        "            path_arc=-30 * DEGREES,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        one_arrow = i_arrow.copy()\n",
        "        result = VGroup(i_arrow, neg_one_arrow, neg_i_arrow, one_arrow)\n",
        "        for arrow in result:\n",
        "            arrow.set_color(GREY_B)\n",
        "            arrow.set_stroke(width=3)\n",
        "            arrow.rotate(90 * DEGREES, RIGHT)\n",
        "        i_arrow.next_to(c2p(0, 0, 0), OUT + RIGHT, SMALL_BUFF)\n",
        "        neg_one_arrow.next_to(c2p(1, 0, 0), OUT + RIGHT, SMALL_BUFF)\n",
        "        neg_i_arrow.next_to(c2p(-1, 0, 0), OUT + LEFT, SMALL_BUFF)\n",
        "        one_arrow.next_to(c2p(0, 0, 0), OUT + LEFT, SMALL_BUFF)\n",
        "        return result\n",
        "\n",
        "    def get_jk_circle_arrows(self):\n",
        "        arrow = Arrow(\n",
        "            1.5 * RIGHT, 1.5 * UP,\n",
        "            path_arc=90 * DEGREES,\n",
        "            buff=SMALL_BUFF,\n",
        "            use_rectangular_stem=False\n",
        "        )\n",
        "        arrow.set_color(GREY_B)\n",
        "        arrow.set_stroke(width=3)\n",
        "        arrows = VGroup(*[\n",
        "            arrow.copy().rotate(angle, about_point=ORIGIN)\n",
        "            for angle in np.arange(0, TAU, TAU / 4)\n",
        "        ])\n",
        "        arrows.rotate(90 * DEGREES, RIGHT)\n",
        "        arrows.rotate(90 * DEGREES, OUT)\n",
        "        return arrows\n",
        "\n",
        "\n",
        "class ShowDistributionOfI(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        tex_to_color_map = {\n",
        "            \"q\": PINK,\n",
        "            \"w\": YELLOW,\n",
        "            \"x\": GREEN,\n",
        "            \"y\": RED,\n",
        "            \"z\": BLUE,\n",
        "        }\n",
        "        top_product = OldTex(\n",
        "            \"q\", \"\\\\cdot\", \"\\\\left(\",\n",
        "            \"w\", \"1\", \"+\", \"x\", \"i\", \"+\", \"y\", \"j\", \"+\", \"z\", \"k\",\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        top_product.to_edge(UP)\n",
        "        self.add(top_product)\n",
        "        bottom_product = OldTex(\n",
        "            \"w\", \"q\", \"\\\\cdot\", \"1\",\n",
        "            \"+\", \"x\", \"q\", \"\\\\cdot\", \"i\",\n",
        "            \"+\", \"y\", \"q\", \"\\\\cdot\", \"j\",\n",
        "            \"+\", \"z\", \"q\", \"\\\\cdot\", \"k\",\n",
        "        )\n",
        "        bottom_product.next_to(top_product, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        for product in [top_product, bottom_product]:\n",
        "            for tex, color in tex_to_color_map.items():\n",
        "                product.set_color_by_tex(tex, color, substring=False)\n",
        "\n",
        "        self.student_says(\n",
        "            \"What does it do \\\\\\\\ to other quaternions?\",\n",
        "            target_mode=\"raise_left_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"raise_left_hand\", \"erm\",\n",
        "            look_at=top_product,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            RemovePiCreatureBubble(self.students[1], target_mode=\"pondering\"),\n",
        "            *[\n",
        "                TransformFromCopy(\n",
        "                    top_product.get_parts_by_tex(tex, substring=False),\n",
        "                    bottom_product.get_parts_by_tex(tex, substring=False),\n",
        "                    run_time=2\n",
        "                )\n",
        "                for tex in [\"1\", \"w\", \"x\", \"i\", \"y\", \"j\", \"z\", \"k\", \"+\"]\n",
        "            ]\n",
        "        )\n",
        "        self.play(*[\n",
        "            TransformFromCopy(\n",
        "                top_product.get_parts_by_tex(tex, substring=False),\n",
        "                bottom_product.get_parts_by_tex(tex, substring=False),\n",
        "                run_time=2\n",
        "            )\n",
        "            for tex in [\"q\", \"\\\\cdot\"]\n",
        "        ])\n",
        "        self.play_all_student_changes(\"thinking\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ComplexPlane135(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(unit_size=2)\n",
        "        plane.add_coordinates()\n",
        "        for mob in plane.coordinate_labels:\n",
        "            mob.scale(2, about_edge=UR)\n",
        "\n",
        "        angle = 3 * TAU / 8\n",
        "        circle = Circle(radius=2, color=YELLOW)\n",
        "        arc = Arc(angle, radius=0.5)\n",
        "        angle_label = Integer(0, unit=\"^\\\\circ\")\n",
        "        angle_label.next_to(arc.point_from_proportion(0.5), UR, SMALL_BUFF)\n",
        "        line = Line(ORIGIN, 2 * RIGHT)\n",
        "\n",
        "        point = circle.point_from_proportion(angle / TAU)\n",
        "        dot = Dot(point, color=PINK)\n",
        "        arrow = Vector(DR)\n",
        "        arrow.next_to(dot, UL, SMALL_BUFF)\n",
        "        arrow.match_color(dot)\n",
        "        label = OldTex(\"-\\\\frac{\\\\sqrt{2}}{2} + \\\\frac{\\\\sqrt{2}}{2} i\")\n",
        "        label.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "        label.set_background_stroke(width=0)\n",
        "\n",
        "        self.add(plane, circle, line, dot, label, arrow)\n",
        "        self.play(\n",
        "            Rotate(line, angle, about_point=ORIGIN),\n",
        "            ShowCreation(arc),\n",
        "            ChangeDecimalToValue(angle_label, 135),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowMultiplicationBy135Example(RuleOfQuaternionMultiplication):\n",
        "    CONFIG = {\n",
        "        \"fancy_dot\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_all_trackers()\n",
        "        self.add_circles()\n",
        "        self.add_ijk_sphere()\n",
        "        self.show_multiplication()\n",
        "\n",
        "    def add_circles(self):\n",
        "        self.circle_1i = self.add_auto_updating_circle(\n",
        "            basis_vectors=[\n",
        "                [1, 0, 0, 0],\n",
        "                [0, 1, 0, 0],\n",
        "            ],\n",
        "            colors=[YELLOW, GREEN_E]\n",
        "        )\n",
        "        self.circle_jk = self.add_auto_updating_circle(\n",
        "            basis_vectors=[\n",
        "                [0, 0, 1, 0],\n",
        "                [0, 0, 0, 1],\n",
        "            ],\n",
        "            colors=[RED, BLUE_E]\n",
        "\n",
        "        )\n",
        "\n",
        "    def add_auto_updating_circle(self, **circle_config):\n",
        "        circle = self.get_projected_circle(**circle_config)\n",
        "        circle.add_updater(\n",
        "            lambda c: c.become(self.get_projected_circle(**circle_config))\n",
        "        )\n",
        "        self.add(circle)\n",
        "        return circle\n",
        "\n",
        "    def add_ijk_sphere(self):\n",
        "        def get_sphere():\n",
        "            result = self.get_projected_sphere(\n",
        "                null_axis=0,\n",
        "                solid=False,\n",
        "                stroke_width=0.5,\n",
        "                stroke_opacity=0.2,\n",
        "                fill_opacity=0.2,\n",
        "            )\n",
        "            self.specially_color_sphere(result)\n",
        "            return result\n",
        "        sphere = get_sphere()\n",
        "        sphere.add_updater(lambda s: s.become(get_sphere()))\n",
        "        self.add(sphere)\n",
        "        self.sphere = sphere\n",
        "\n",
        "    def show_multiplication(self):\n",
        "        m_tracker = self.multiplier_tracker\n",
        "\n",
        "        quat = normalize(np.array([-1, 1, 0, 0]))\n",
        "        point = self.project_quaternion(quat)\n",
        "        arrow = Vector(DR)\n",
        "        arrow.next_to(point, UL, MED_SMALL_BUFF)\n",
        "        arrow.set_color(PINK)\n",
        "        label = OldTex(\n",
        "            \"-{\\\\sqrt{2} \\\\over 2}\", \"+\",\n",
        "            \"{\\\\sqrt{2} \\\\over 2}\", \"i\",\n",
        "        )\n",
        "        label.next_to(arrow.get_start(), UP)\n",
        "        label.set_background_stroke(width=0)\n",
        "\n",
        "        def get_one_point():\n",
        "            return self.circle_1i[0].get_points()[0]\n",
        "\n",
        "        def get_j_point():\n",
        "            return self.circle_jk[0].get_points()[0]\n",
        "\n",
        "        one_point = VectorizedPoint()\n",
        "        one_point.add_updater(lambda v: v.set_location(get_one_point()))\n",
        "        self.add(one_point)\n",
        "\n",
        "        hand = Hand()\n",
        "        hand.rotate(45 * DEGREES, RIGHT)\n",
        "        hand.add_updater(\n",
        "            lambda h: h.move_to(get_one_point(), LEFT)\n",
        "        )\n",
        "\n",
        "        j_line = Line(ORIGIN, get_j_point())\n",
        "        moving_j_line = j_line.deepcopy()\n",
        "        moving_j_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(ORIGIN, get_j_point())\n",
        "        )\n",
        "\n",
        "        self.add(j_line, moving_j_line)\n",
        "        self.set_camera_orientation(\n",
        "            phi=60 * DEGREES, theta=-70 * DEGREES\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromLarge(label, 3),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.set_quat(quat)\n",
        "        self.wait(5)\n",
        "        self.play(FadeInFromLarge(hand))\n",
        "        self.add(m_tracker)\n",
        "        for q in [quat, [1, 0, 0, 0], quat]:\n",
        "            self.play(\n",
        "                m_tracker.set_value, q,\n",
        "                UpdateFromFunc(\n",
        "                    m_tracker,\n",
        "                    lambda m: m.set_value(normalize(m.get_value()))\n",
        "                ),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class JMultiplicationChart(Scene):\n",
        "    def construct(self):\n",
        "        # Largely copy-pasted....what are you gonna do about it?\n",
        "        product = OldTex(\"j\", \"\\\\cdot\", \"p\")\n",
        "        product[0].set_color(RED)\n",
        "        product.scale(2)\n",
        "        product.to_edge(UP)\n",
        "\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.set_width(product.get_width() + MED_SMALL_BUFF)\n",
        "        underline.next_to(product, DOWN)\n",
        "\n",
        "        kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"i\": GREEN,\n",
        "                \"j\": RED,\n",
        "                \"k\": BLUE\n",
        "            }\n",
        "        }\n",
        "        j_products = VGroup(\n",
        "            OldTex(\"j\", \"\\\\cdot\", \"1\", \"=\", \"j\", **kwargs),\n",
        "            OldTex(\"j\", \"\\\\cdot\", \"j\", \"=\", \"-1\", **kwargs),\n",
        "            OldTex(\"j\", \"\\\\cdot\", \"i\", \"=\", \"-k\", **kwargs),\n",
        "            OldTex(\"j\", \"\\\\cdot\", \"k\", \"=\", \"i\", **kwargs),\n",
        "        )\n",
        "        j_products.scale(2)\n",
        "        j_products.arrange(\n",
        "            DOWN, buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        j_products.next_to(underline, DOWN, LARGE_BUFF)\n",
        "        j_products.align_to(product, LEFT)\n",
        "\n",
        "        self.play(FadeInFromDown(product))\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.wait()\n",
        "        for j_product in j_products:\n",
        "            self.play(TransformFromCopy(\n",
        "                product, j_product[:3]\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.play(TransformFromCopy(\n",
        "                j_product[:3], j_product[3:],\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(product, j_products),\n",
        "            buff=MED_SMALL_BUFF\n",
        "        )\n",
        "        rect.set_stroke(WHITE, width=5)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class ShowJMultiplication(ShowMultiplicationBy135Example):\n",
        "    CONFIG = {\n",
        "        \"fancy_dot\": True,\n",
        "        \"run_time_per_rotation\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_all_trackers()\n",
        "        self.add_circles()\n",
        "        self.add_ijk_sphere()\n",
        "        self.show_multiplication()\n",
        "\n",
        "    def add_circles(self):\n",
        "        self.circle_1j = self.add_auto_updating_circle(\n",
        "            basis_vectors=[\n",
        "                [1, 0, 0, 0],\n",
        "                [0, 0, 1, 0],\n",
        "            ],\n",
        "            colors=[YELLOW, RED]\n",
        "        )\n",
        "        self.circle_ik = self.add_auto_updating_circle(\n",
        "            basis_vectors=[\n",
        "                [0, 1, 0, 0],\n",
        "                [0, 0, 0, 1],\n",
        "            ],\n",
        "            colors=[GREEN, BLUE_E]\n",
        "        )\n",
        "\n",
        "    def show_multiplication(self):\n",
        "        self.set_camera_orientation(theta=-80 * DEGREES)\n",
        "\n",
        "        q_tracker = self.q_tracker\n",
        "        m_tracker = self.multiplier_tracker\n",
        "\n",
        "        def normalize_tracker(t):\n",
        "            t.set_value(normalize(t.get_value()))\n",
        "\n",
        "        updates = [\n",
        "            UpdateFromFunc(tracker, normalize_tracker)\n",
        "            for tracker in (q_tracker, m_tracker)\n",
        "        ]\n",
        "\n",
        "        run_time = self.run_time_per_rotation\n",
        "        self.play(\n",
        "            m_tracker.set_value, [0, 0, 1, 0],\n",
        "            q_tracker.set_value, [0, 0, 1, 0],\n",
        "            *updates,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            m_tracker.set_value, [-1, 0, 1e-3, 0],\n",
        "            q_tracker.set_value, [-1, 0, 1e-3, 0],\n",
        "            *updates,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show ik circle\n",
        "        circle = self.circle_ik.deepcopy()\n",
        "        circle.clear_updaters()\n",
        "        self.play(FadeInFromLarge(circle, remover=True))\n",
        "        m_tracker.set_value([-1, 0, 0, 0])\n",
        "        q_tracker.set_value([0, 1, 0, 0])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            m_tracker.set_value, [0, 0, -1, 0],\n",
        "            q_tracker.set_value, [0, 0, 0, -1],\n",
        "            *updates,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            m_tracker.set_value, [1, 0, -1e-3, 0],\n",
        "            q_tracker.set_value, [0, -1, 0, 0],\n",
        "            *updates,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ShowArbitraryMultiplication(ShowMultiplicationBy135Example):\n",
        "    CONFIG = {\n",
        "        \"fancy_dot\": True,\n",
        "        \"run_time_per_rotation\": 4,\n",
        "        \"special_quaternion\": [-0.5, 0.5, 0.5, 0.5],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_all_trackers()\n",
        "        self.add_circles()\n",
        "        self.add_ijk_sphere()\n",
        "        self.show_multiplication()\n",
        "\n",
        "    def add_circles(self):\n",
        "        self.circle1 = self.add_auto_updating_circle(\n",
        "            basis_vectors=[\n",
        "                [1, 0, 0, 0],\n",
        "                [0, 1, 1, 1],\n",
        "            ],\n",
        "            colors=[YELLOW_E, YELLOW]\n",
        "        )\n",
        "        bv1 = normalize([0, -1, -1, 2])\n",
        "        bv2 = [0] + list(normalize(np.cross([1, 1, 1], bv1[1:])))\n",
        "        self.circle2 = self.add_auto_updating_circle(\n",
        "            basis_vectors=[bv1, bv2],\n",
        "            colors=[WHITE, GREY]\n",
        "        )\n",
        "\n",
        "    def show_multiplication(self):\n",
        "        q_tracker = self.q_tracker\n",
        "        m_tracker = self.multiplier_tracker\n",
        "        run_time = self.run_time_per_rotation\n",
        "\n",
        "        def normalize_tracker(t):\n",
        "            t.set_value(normalize(t.get_value()))\n",
        "\n",
        "        # for tracker in q_tracker, m_tracker:\n",
        "        #     self.add(Mobject.add_updater(tracker, normalize_tracker))\n",
        "        updates = [\n",
        "            UpdateFromFunc(tracker, normalize_tracker)\n",
        "            for tracker in (q_tracker, m_tracker)\n",
        "        ]\n",
        "\n",
        "        special_q = self.special_quaternion\n",
        "        pq_point = self.project_quaternion(special_q)\n",
        "        label = OldTexText(\"Some unit quaternion\")\n",
        "        label.set_color(PINK)\n",
        "        label.rotate(90 * DEGREES, RIGHT)\n",
        "        label.next_to(pq_point, IN + RIGHT, SMALL_BUFF)\n",
        "\n",
        "        circle1, circle2 = self.circle1, self.circle2\n",
        "        for circle in [circle1, circle2]:\n",
        "            circle.tucked_away_updaters = circle.updaters\n",
        "            circle.clear_updaters()\n",
        "            self.remove(circle)\n",
        "\n",
        "        hand = Hand()\n",
        "        hand.rotate(90 * DEGREES, RIGHT)\n",
        "        hand.move_to(ORIGIN, LEFT)\n",
        "        hand.set_shade_in_3d(True)\n",
        "        one_dot = self.get_dot()\n",
        "        one_dot.set_color(YELLOW_E)\n",
        "        one_dot.move_to(ORIGIN)\n",
        "        one_dot.add_updater(\n",
        "            lambda m: m.move_to(circle1[0].get_points()[0])\n",
        "        )\n",
        "        self.add(one_dot)\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.begin_ambient_camera_rotation(rate=0.02)\n",
        "        self.set_quat(special_q)\n",
        "        self.play(FadeIn(label, IN))\n",
        "        self.wait(3)\n",
        "        for circle in [circle1, circle2]:\n",
        "            self.play(ShowCreation(circle, run_time=3))\n",
        "            circle.updaters = circle.tucked_away_updaters\n",
        "            self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(hand, 2 * IN + 2 * RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        hand.add_updater(\n",
        "            lambda h: h.move_to(circle1[0].get_points()[0], LEFT)\n",
        "        )\n",
        "\n",
        "        for quat in [special_q, [1, 0, 0, 0], special_q]:\n",
        "            self.play(\n",
        "                m_tracker.set_value, special_q,\n",
        "                *updates,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MentionCommutativity(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"q\": MAROON_B,\n",
        "                \"p\": YELLOW,\n",
        "                \"i\": GREEN,\n",
        "                \"j\": RED,\n",
        "                \"k\": BLUE,\n",
        "            }\n",
        "        }\n",
        "        general_eq = OldTex(\"q \\\\cdot p \\\\ne p \\\\cdot q\", **kwargs)\n",
        "        general_eq.get_part_by_tex(\"\\\\ne\").submobjects.reverse()\n",
        "        ij_eq = OldTex(\"i \\\\cdot j = k\", **kwargs)\n",
        "        ji_eq = OldTex(\"j \\\\cdot i = -k\", **kwargs)\n",
        "\n",
        "        for mob in [general_eq, ij_eq, ji_eq]:\n",
        "            mob.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        words = OldTexText(\"Multiplication doesn't \\\\\\\\ commute\")\n",
        "        words.next_to(general_eq, UP, MED_LARGE_BUFF)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        joke = OldTexText(\"Quaternions work from home\")\n",
        "        joke.scale(0.75)\n",
        "        joke.to_corner(UL, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(general_eq),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\"erm\", \"confused\", \"sassy\")\n",
        "        )\n",
        "        self.play(FadeIn(words, RIGHT))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(words, joke),\n",
        "            general_eq.shift, UP,\n",
        "            FadeInFromDown(ij_eq),\n",
        "            self.change_students(*[\"pondering\"] * 3)\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeIn(ji_eq),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, VGroup(ij_eq, general_eq),\n",
        "                lambda m: (m.shift, UP),\n",
        "                lag_ratio=0.8,\n",
        "            )\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class RubuiksCubeOperations(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(**self.get_default_camera_position())\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        cube = RubiksCube()\n",
        "        cube.shift(2.5 * RIGHT)\n",
        "        cube2 = cube.copy()\n",
        "\n",
        "        self.add(cube)\n",
        "        self.play(\n",
        "            Rotate(cube.get_face(RIGHT), 90 * DEGREES, RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube.get_face(DOWN), 90 * DEGREES, UP),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            cube.shift, 5 * LEFT,\n",
        "            FadeIn(cube2)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube2.get_face(DOWN), 90 * DEGREES, UP),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube2.get_face(RIGHT), 90 * DEGREES, RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class RotationsOfCube(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(**self.get_default_camera_position())\n",
        "        self.begin_ambient_camera_rotation(0.0001)\n",
        "        cube = RubiksCube()\n",
        "        cube2 = cube.copy()\n",
        "        axes = self.get_axes()\n",
        "        axes.scale(0.75)\n",
        "\n",
        "        label1 = OldTexText(\n",
        "            \"z-axis\\\\\\\\\",\n",
        "            \"then x-axis\"\n",
        "        )\n",
        "        label2 = OldTexText(\n",
        "            \"x-axis\\\\\\\\\",\n",
        "            \"then z-axis\"\n",
        "        )\n",
        "        for label in [label1, label2]:\n",
        "            for part in label:\n",
        "                part.add_background_rectangle()\n",
        "            label.rotate(90 * DEGREES, RIGHT)\n",
        "            label.move_to(3 * OUT + 0.5 * IN)\n",
        "\n",
        "        self.add(axes, cube)\n",
        "        self.play(\n",
        "            Rotate(cube, 90 * DEGREES, OUT, run_time=2),\n",
        "            FadeIn(label1[0], IN),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube, 90 * DEGREES, RIGHT, run_time=2),\n",
        "            FadeIn(label1[1], IN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            cube.shift, 5 * RIGHT,\n",
        "            label1.shift, 5 * RIGHT,\n",
        "            Write(cube2, run_time=1)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube2, 90 * DEGREES, RIGHT, run_time=2),\n",
        "            FadeIn(label2[0], IN),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(cube2, 90 * DEGREES, OUT, run_time=2),\n",
        "            FadeIn(label2[1], IN),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class OneFinalPoint(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"One final point!\")\n",
        "        self.play_student_changes(\"happy\", \"tease\", \"thinking\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class MultiplicationFromTheRight(Scene):\n",
        "    def construct(self):\n",
        "        i, dot, j = product = OldTex(\"i\", \"\\\\cdot\", \"j\")\n",
        "        product.set_height(1.5)\n",
        "        product.to_edge(UP, buff=LARGE_BUFF)\n",
        "        i.set_color(GREEN)\n",
        "        j.set_color(RED)\n",
        "        i_rect = SurroundingRectangle(i)\n",
        "        j_rect = SurroundingRectangle(j)\n",
        "        i_rect.match_height(j_rect, about_edge=UP, stretch=True)\n",
        "        VGroup(i_rect, j_rect).set_color(WHITE)\n",
        "        action_words = OldTexText(\"Think of as \\\\\\\\ an action\")\n",
        "        point_words = OldTexText(\"Think of as \\\\\\\\ a point\")\n",
        "        action_words.next_to(i_rect, LEFT)\n",
        "        point_words.next_to(j_rect, RIGHT)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            i.get_top(),\n",
        "            j.get_top(),\n",
        "            path_arc=-PI,\n",
        "        )\n",
        "        arrow.set_stroke(width=2)\n",
        "\n",
        "        self.add(product)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(\n",
        "            FadeIn(i_rect),\n",
        "            Write(action_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(j_rect),\n",
        "            Write(point_words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(arrow.flip)\n",
        "        self.play(Swap(point_words, action_words))\n",
        "\n",
        "\n",
        "class MultiplicationByJFromRight(ShowJMultiplication):\n",
        "    def show_multiplication(self):\n",
        "        self.set_camera_orientation(theta=-80 * DEGREES)\n",
        "\n",
        "        q_tracker = self.q_tracker\n",
        "        m_tracker = self.multiplier_tracker\n",
        "\n",
        "        def normalize_tracker(t):\n",
        "            t.set_value(normalize(t.get_value()))\n",
        "\n",
        "        updates = [\n",
        "            UpdateFromFunc(tracker, normalize_tracker)\n",
        "            for tracker in (q_tracker, m_tracker)\n",
        "        ]\n",
        "\n",
        "        run_time = self.run_time_per_rotation\n",
        "\n",
        "        m_values = [[1, 0, 0, 0]]\n",
        "        q_values = [[0, 1, 0, 0]]\n",
        "        for values in m_values, q_values:\n",
        "            for x in range(4):\n",
        "                values.append(\n",
        "                    q_mult(values[-1], [0, 0, 1, 0])\n",
        "                )\n",
        "\n",
        "        for m_val, q_val in zip(m_values, q_values):\n",
        "            self.play(\n",
        "                m_tracker.set_value, m_val,\n",
        "                q_tracker.set_value, q_val,\n",
        "                *updates,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "    def get_projected_sphere(self, *args, **kwargs):\n",
        "        kwargs[\"multiply_from_right\"] = True\n",
        "        return ShowJMultiplication.get_projected_sphere(\n",
        "            self, *args, **kwargs\n",
        "        )\n",
        "\n",
        "    def get_projected_circle(self, *args, **kwargs):\n",
        "        kwargs[\"multiply_from_right\"] = True\n",
        "        return ShowJMultiplication.get_projected_circle(\n",
        "            self, *args, **kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "class HowQuaternionsRotate3dPoints(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"Coming up:\\\\\\\\\",\n",
        "            \"How quaternions act on 3d points\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        expression = OldTex(\n",
        "            \"q\", \"\\\\cdot\", \"p\", \"\\\\cdot\", \"q^{-1}\"\n",
        "        )\n",
        "        expression.scale(2)\n",
        "        expression.set_color_by_tex(\"q\", PINK)\n",
        "        expression.set_color_by_tex(\"p\", YELLOW)\n",
        "\n",
        "        right_arrow = Arrow(\n",
        "            expression[0].get_top(),\n",
        "            expression[2].get_top(),\n",
        "            path_arc=-PI,\n",
        "            color=WHITE,\n",
        "        )\n",
        "        right_arrow.set_stroke(width=4)\n",
        "        left_arrow = right_arrow.copy()\n",
        "        left_arrow.flip(about_point=expression[2].get_top())\n",
        "        left_arrow.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(Write(expression))\n",
        "        self.play(ShowCreation(right_arrow))\n",
        "        self.play(ShowCreation(left_arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HoldUpQuanta(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        logo = ImageMobject(\"Quanta logo\")\n",
        "        logo.set_width(6)\n",
        "        logo.next_to(self.teacher, UR)\n",
        "        logo.to_edge(RIGHT, buff=2)\n",
        "\n",
        "        words = OldTexText(\"Associated quaternion post\")\n",
        "        words.to_edge(UP, buff=LARGE_BUFF)\n",
        "        arrow = Arrow(logo.get_top(), words.get_bottom())\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(logo),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            GrowFromPoint(words, arrow.get_start())\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShareWithFriends(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        pi1, pi2 = self.pi_creatures\n",
        "\n",
        "        self.pi_creature_says(\n",
        "            pi1, \"Come learn about \\\\\\\\ quaternions!\",\n",
        "            bubble_config={\n",
        "                \"direction\": LEFT,\n",
        "                \"width\": 4,\n",
        "                \"height\": 3,\n",
        "            },\n",
        "            target_mode=\"hooray\",\n",
        "            look_at=pi2.eyes,\n",
        "            added_anims=[\n",
        "                ApplyMethod(\n",
        "                    pi2.change, \"confused\",\n",
        "                    run_time=1.5,\n",
        "                    rate_func=squish_rate_func(smooth, 0.3, 1)\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        bubble = ThoughtBubble(\n",
        "            direction=RIGHT,\n",
        "            width=4,\n",
        "            height=4,\n",
        "        )\n",
        "        bubble.pin_to(pi2)\n",
        "        bubble.write(\"What's that, some\\\\\\\\kind of particle?\")\n",
        "        bubble.resize_to_content()\n",
        "        VGroup(bubble, bubble.content).shift_onto_screen(buff=SMALL_BUFF)\n",
        "        self.play(\n",
        "            pi2.look_at, pi1.eyes,\n",
        "            pi1.look_at, pi2.eyes,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "        )\n",
        "        self.wait(1)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(pi1, target_mode=\"raise_right_hand\")\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        time_words = OldTexText(\"Oh man...\\\\\\\\30 minutes\")\n",
        "        time_words.move_to(bubble.content)\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint().next_to(pi1, UL, LARGE_BUFF)),\n",
        "            pi2.change, \"sad\",\n",
        "            FadeOut(bubble.content, DOWN),\n",
        "            FadeInFromDown(time_words, DOWN),\n",
        "        )\n",
        "        self.wait(7)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        pi1 = PiCreature(color=BLUE)\n",
        "        pi1.to_edge(DOWN)\n",
        "        pi1.flip()\n",
        "        pi1.shift(2.5 * RIGHT)\n",
        "        pi2 = PiCreature(color=RED)\n",
        "        pi2.to_edge(DOWN)\n",
        "        pi2.shift(2 * LEFT)\n",
        "        return [pi1, pi2]\n",
        "\n",
        "\n",
        "class QuaternionEndscreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Matt Russell\",\n",
        "            \"soekul\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Dinesh Dharme\",\n",
        "            \"Scott Walter\",\n",
        "            \"Brice Gower\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"brian tiger chow\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Roy Larson\",\n",
        "            \"Andrew Sachs\",\n",
        "            \"Ho\u00e0ng T\u00f9ng L\u00e2m\",\n",
        "            \"Devin Scott\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Arthur Zey\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yu Jun\",\n",
        "            \"dave nicponski\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Luk\u00e1\u0161 Nov\u00fd\",\n",
        "            \"Fela\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Federico Lebron\",\n",
        "            \"L0j1k\",\n",
        "            \"Ayan Doss\",\n",
        "            \"Dylan Houlihan\",\n",
        "            \"Steven Soloway\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Nate Heckmann\",\n",
        "            \"Michael Faust\",\n",
        "            \"Richard Comish\",\n",
        "            \"Nero Li\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Solara570\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Kai Siang   Ang\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Cooper Jones\",\n",
        "            \"James Hughes\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Song Gao\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"John Griffith\",\n",
        "            \"Chris Connett\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Bong Choung\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Cody Brocious\",\n",
        "            \"James H. Park\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"Dave B\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Awoo\",\n",
        "            \"Dr  David G. Stork\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class ThumbnailP1(RuleOfQuaternionMultiplication):\n",
        "    CONFIG = {\n",
        "        \"three_d_axes_config\": {\n",
        "            \"num_axis_pieces\": 20,\n",
        "        },\n",
        "        \"unit_labels_scale_factor\": 1.5,\n",
        "        \"quaternion\": [1, 0, 0, 0],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_all_trackers()\n",
        "        self.remove(self.pink_dot_label)\n",
        "        q_tracker = self.q_tracker\n",
        "        m_tracker = self.multiplier_tracker\n",
        "\n",
        "        # quat = normalize([-0.5, 0.5, -0.5, 0.5])\n",
        "        quat = normalize(self.quaternion)\n",
        "        m_tracker.set_value(quat)\n",
        "        q_tracker.set_value(quat)\n",
        "        proj_sphere = self.get_projected_sphere(0, solid=False)\n",
        "        # self.specially_color_sphere(proj_sphere)\n",
        "        proj_sphere.set_color_by_gradient(\n",
        "            BLUE, YELLOW\n",
        "        )\n",
        "        proj_sphere.set_stroke(WHITE)\n",
        "        proj_sphere.set_fill(opacity=0.4)\n",
        "        for i, face in enumerate(proj_sphere):\n",
        "            alpha = i / len(proj_sphere)\n",
        "            opacity = 0.7 * (1 - there_and_back(alpha))\n",
        "            face.set_fill(opacity=opacity)\n",
        "\n",
        "        # unit_sphere = self.get_projected_sphere(0, quaternion=[1, 0, 0, 0], solid=False)\n",
        "        # self.specially_color_sphere(unit_sphere)\n",
        "        # unit_sphere.set_stroke(width=0)\n",
        "        # proj_sphere.set_fill_by_checkerboard(BLUE_E, BLUE, opacity=0.8)\n",
        "        for face in proj_sphere:\n",
        "            face.set_points(face.get_points()[::-1])\n",
        "            max_r = np.max(np.apply_along_axis(get_norm, 1, face.get_points()))\n",
        "            if max_r > 30:\n",
        "                face.fade(1)\n",
        "\n",
        "        for label in self.unit_labels:\n",
        "            label.set_shade_in_3d(False)\n",
        "            label.set_background_stroke(color=BLACK, width=2)\n",
        "\n",
        "        self.add(proj_sphere)\n",
        "        # self.add(unit_sphere)\n",
        "\n",
        "        for mobject in self.mobjects:\n",
        "            try:\n",
        "                mobject.shift(IN)\n",
        "            except ValueError:\n",
        "                pass\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-110 * DEGREES,\n",
        "        )\n",
        "\n",
        "\n",
        "class ThumbnailP2(ThumbnailP1):\n",
        "    CONFIG = {\n",
        "        \"quaternion\": [0, 1, 0, 0],\n",
        "    }\n",
        "\n",
        "\n",
        "class ThumbnailOverlay(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Quaternions \\\\\\\\\", \"visualized\")\n",
        "        title.set_width(7)\n",
        "        # title[1].scale(0.7, about_edge=UP)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.set_height(FRAME_HEIGHT)\n",
        "\n",
        "        title.set_background_stroke(color=BLACK, width=1)\n",
        "\n",
        "        for part in (title[0][4:6], title[1][4:5]):\n",
        "            rect = BackgroundRectangle(part)\n",
        "            rect.set_fill(opacity=1)\n",
        "            rect.stretch(0.9, 0)\n",
        "            rect.stretch(1.1, 1)\n",
        "            title.add_to_back(rect)\n",
        "        # title.add_to_back(BackgroundRectangle(title[0]))\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        arrow.scale(1.5)\n",
        "        arrow.tip.scale(2)\n",
        "        arrow.set_stroke(width=10)\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        self.add(v_line)\n",
        "        self.add(arrow)\n",
        "        self.add(title)\n"
    ]
}