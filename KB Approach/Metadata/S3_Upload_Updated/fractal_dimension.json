{
    "topic": "The mathematical concept being demonstrated is the Sierpinski triangle, which is a fractal",
    "code": [
        "\n",
        "from manim_imports_ext import *\n",
        "from functools import reduce\n",
        "\n",
        "def break_up(mobject, factor = 1.3):\n",
        "    mobject.scale(factor)\n",
        "    for submob in mobject:\n",
        "        submob.scale(1./factor)\n",
        "    return mobject\n",
        "\n",
        "class Britain(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"Britain.svg\",\n",
        "        \"stroke_width\" : 0,\n",
        "        \"fill_color\" : BLUE_D,\n",
        "        \"fill_opacity\" : 1,\n",
        "        \"height\" : 5,\n",
        "        \"mark_paths_closed\" : True,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.set_points(self[0].get_points())\n",
        "        self.submobjects = []\n",
        "        self.set_height(self.height)\n",
        "        self.center()\n",
        "\n",
        "class Norway(Britain):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"Norway\",\n",
        "        \"mark_paths_closed\" : False\n",
        "    }\n",
        "\n",
        "class KochTest(Scene):\n",
        "    def construct(self):\n",
        "        koch = KochCurve(order = 5, stroke_width = 2)\n",
        "\n",
        "        self.play(ShowCreation(koch, run_time = 3))\n",
        "        self.play(\n",
        "            koch.scale, 3, koch.get_left(),\n",
        "            koch.set_stroke, None, 4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SierpinskiTest(Scene):\n",
        "    def construct(self):\n",
        "        sierp = Sierpinski(\n",
        "            order = 5,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            sierp,\n",
        "            run_time = 5,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        # self.play(sierp.scale, 2, sierp.get_top())\n",
        "        # self.wait(3)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "###################################\n",
        "\n",
        "\n",
        "class ZoomInOnFractal(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"fractal_order\" : 6,\n",
        "        \"num_zooms\" : 5,\n",
        "        \"fractal_class\" : DiamondFractal,\n",
        "        \"index_to_replace\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        fractal = self.fractal_class(order = self.fractal_order)\n",
        "        fractal.show()\n",
        "\n",
        "        fractal = self.introduce_fractal()\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.blink()\n",
        "        self.zoom_in(fractal)\n",
        "\n",
        "\n",
        "    def introduce_fractal(self):\n",
        "        fractal = self.fractal_class(order = 0)\n",
        "        self.play(FadeIn(fractal))\n",
        "        for order in range(1, self.fractal_order+1):\n",
        "            new_fractal = self.fractal_class(order = order)\n",
        "            self.play(\n",
        "                Transform(fractal, new_fractal, run_time = 2),\n",
        "                self.pi_creature.change_mode, \"hooray\"\n",
        "            )\n",
        "        return fractal\n",
        "\n",
        "    def zoom_in(self, fractal):\n",
        "        grower = fractal[self.index_to_replace]\n",
        "        grower_target = fractal.copy()\n",
        "\n",
        "        for x in range(self.num_zooms):\n",
        "            self.tweak_fractal_subpart(grower_target)\n",
        "            grower_family = grower.family_members_with_points()\n",
        "            everything = VGroup(*[\n",
        "                submob\n",
        "                for submob in fractal.family_members_with_points()\n",
        "                if not submob.is_off_screen()\n",
        "                if submob not in grower_family\n",
        "            ])\n",
        "            everything.generate_target()\n",
        "            everything.target.shift(\n",
        "                grower_target.get_center()-grower.get_center()\n",
        "            )\n",
        "            everything.target.scale(\n",
        "                grower_target.get_height()/grower.get_height()\n",
        "            )\n",
        "\n",
        "            self.play(\n",
        "                Transform(grower, grower_target),\n",
        "                MoveToTarget(everything),\n",
        "                self.pi_creature.change_mode, \"thinking\",\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "            grower_target = grower.copy()\n",
        "            grower = grower[self.index_to_replace]\n",
        "\n",
        "\n",
        "    def tweak_fractal_subpart(self, subpart):\n",
        "        subpart.rotate(np.pi/4)\n",
        "\n",
        "class WhatAreFractals(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"But what \\\\emph{is} a fractal?\",\n",
        "            index = 2,\n",
        "            width = 6\n",
        "        )\n",
        "        self.play_student_changes(\"thinking\", \"pondering\", None)\n",
        "        self.wait()\n",
        "\n",
        "        name = OldTexText(\"Benoit Mandelbrot\")\n",
        "        name.to_corner(UP+LEFT)\n",
        "        # picture = Rectangle(height = 4, width = 3)\n",
        "        picture = ImageMobject(\"Mandelbrot\")\n",
        "        picture.set_height(4)\n",
        "        picture.next_to(name, DOWN)\n",
        "        self.play(\n",
        "            Write(name, run_time = 2),\n",
        "            FadeIn(picture),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, name)\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        question = OldTexText(\"Aren't they\", \"self-similar\", \"shapes?\")\n",
        "        question.set_color_by_tex(\"self-similar\", YELLOW)\n",
        "        self.student_says(question)\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceVonKochCurve(Scene):\n",
        "    CONFIG = {\n",
        "        \"order\" : 5,\n",
        "        \"stroke_width\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        snowflake = self.get_snowflake()\n",
        "        name = OldTexText(\"Von Koch Snowflake\")\n",
        "        name.to_edge(UP)\n",
        "\n",
        "        self.play(ShowCreation(snowflake, run_time = 3))\n",
        "        self.play(Write(name, run_time = 2))\n",
        "        curve = self.isolate_one_curve(snowflake)\n",
        "        self.wait()\n",
        "\n",
        "        self.zoom_in_on(curve)\n",
        "        self.zoom_in_on(curve)\n",
        "        self.zoom_in_on(curve)\n",
        "\n",
        "    def get_snowflake(self):\n",
        "        triangle = RegularPolygon(n = 3, start_angle = np.pi/2)\n",
        "        triangle.set_height(4)\n",
        "        curves = VGroup(*[\n",
        "            KochCurve(\n",
        "                order = self.order,\n",
        "                stroke_width = self.stroke_width\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        for index, curve in enumerate(curves):\n",
        "            width = curve.get_width()\n",
        "            curve.move_to(\n",
        "                (np.sqrt(3)/6)*width*UP, DOWN\n",
        "            )\n",
        "            curve.rotate(-index*2*np.pi/3)\n",
        "        curves.set_color_by_gradient(BLUE, WHITE, BLUE)\n",
        "\n",
        "        return curves\n",
        "\n",
        "    def isolate_one_curve(self, snowflake):\n",
        "        self.play(*[\n",
        "            ApplyMethod(curve.shift, curve.get_center()/2)\n",
        "            for curve in snowflake\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            snowflake.scale, 2.1,\n",
        "            snowflake.next_to, UP, DOWN\n",
        "        )\n",
        "        self.remove(*snowflake[1:])\n",
        "        return snowflake[0]\n",
        "\n",
        "    def zoom_in_on(self, curve):\n",
        "        larger_curve = KochCurve(\n",
        "            order = self.order+1,\n",
        "            stroke_width = self.stroke_width\n",
        "        )\n",
        "        larger_curve.replace(curve)\n",
        "        larger_curve.scale(3, about_point = curve.get_corner(DOWN+LEFT))\n",
        "        larger_curve.set_color_by_gradient(\n",
        "            curve[0].get_color(),\n",
        "            curve[-1].get_color(),\n",
        "        )\n",
        "\n",
        "        self.play(Transform(curve, larger_curve, run_time = 2))\n",
        "        n_parts = len(curve.split())\n",
        "        sub_portion = VGroup(*curve[:n_parts/4])\n",
        "        self.play(\n",
        "            sub_portion.set_color, YELLOW,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceSierpinskiTriangle(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"order\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        sierp = Sierpinski(order = self.order)\n",
        "        sierp.save_state()\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            sierp,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            *[\n",
        "                ApplyMethod(submob.shift, submob.get_center())\n",
        "                for submob in sierp\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        for submob in sierp:\n",
        "            self.play(sierp.shift, -submob.get_center())\n",
        "            self.wait()\n",
        "        self.play(sierp.restore)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait()\n",
        "\n",
        "class SelfSimilarFractalsAsSubset(Scene):\n",
        "    CONFIG = {\n",
        "        \"fractal_width\" : 1.5\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_self_similar_fractals()\n",
        "        self.add_general_fractals()\n",
        "\n",
        "    def add_self_similar_fractals(self):\n",
        "        fractals = VGroup(\n",
        "            DiamondFractal(order = 5),\n",
        "            KochSnowFlake(order = 3),\n",
        "            Sierpinski(order = 5),\n",
        "        )\n",
        "        for submob in fractals:\n",
        "            submob.set_width(self.fractal_width)\n",
        "        fractals.arrange(RIGHT)\n",
        "        fractals[-1].next_to(VGroup(*fractals[:-1]), DOWN)\n",
        "\n",
        "        title = OldTexText(\"Self-similar fractals\")\n",
        "        title.next_to(fractals, UP)\n",
        "\n",
        "        small_rect = Rectangle()\n",
        "        small_rect.replace(VGroup(fractals, title), stretch = True)\n",
        "        small_rect.scale(1.2)\n",
        "        self.small_rect = small_rect\n",
        "\n",
        "        group = VGroup(fractals, title, small_rect)\n",
        "        group.to_corner(UP+LEFT, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            ShowCreation(fractals),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(ShowCreation(small_rect))\n",
        "        self.wait()\n",
        "\n",
        "    def add_general_fractals(self):\n",
        "        big_rectangle = Rectangle(\n",
        "            width = FRAME_WIDTH - MED_LARGE_BUFF,\n",
        "            height = FRAME_HEIGHT - MED_LARGE_BUFF,\n",
        "        )\n",
        "        title = OldTexText(\"Fractals\")\n",
        "        title.scale(1.5)\n",
        "        title.next_to(ORIGIN, RIGHT, buff = LARGE_BUFF)\n",
        "        title.to_edge(UP, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        britain = Britain(\n",
        "            fill_opacity = 0,\n",
        "            stroke_width = 2,\n",
        "            stroke_color = WHITE,\n",
        "        )\n",
        "        britain.next_to(self.small_rect, RIGHT)\n",
        "        britain.shift(2*DOWN)\n",
        "\n",
        "        randy = Randolph().flip().scale(1.4)\n",
        "        randy.next_to(britain, buff = SMALL_BUFF)\n",
        "        randy.generate_target()\n",
        "        randy.target.change_mode(\"pleading\")\n",
        "        fractalify(randy.target, order = 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(big_rectangle),\n",
        "            Write(title),\n",
        "        )\n",
        "        self.play(ShowCreation(britain), run_time = 5)\n",
        "        self.play(\n",
        "            britain.set_fill, BLUE, 1,\n",
        "            britain.set_stroke, None, 0,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(MoveToTarget(randy, run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "class ConstrastSmoothAndFractal(Scene):\n",
        "    CONFIG = {\n",
        "        \"britain_zoom_point_proportion\" : 0.45,\n",
        "        \"scale_factor\" : 50,\n",
        "        \"fractalification_order\" : 2,\n",
        "        \"fractal_dimension\" : 1.21,\n",
        "    }\n",
        "    def construct(self):\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        smooth = OldTexText(\"Smooth\")\n",
        "        smooth.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        fractal = OldTexText(\"Fractal\")\n",
        "        fractal.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        VGroup(smooth, fractal).to_edge(UP)\n",
        "        background_rectangle = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = FRAME_X_RADIUS,\n",
        "        )\n",
        "        background_rectangle.to_edge(RIGHT, buff = 0)\n",
        "        background_rectangle.set_fill(BLACK, 1)\n",
        "        background_rectangle.set_stroke(width = 0)\n",
        "        self.add(v_line, background_rectangle, smooth, fractal)\n",
        "\n",
        "        britain = Britain(\n",
        "            fill_opacity = 0,\n",
        "            stroke_width = 2,\n",
        "            stroke_color = WHITE,\n",
        "        )[0]\n",
        "        anchors = britain.get_anchors()\n",
        "        smooth_britain = VMobject()\n",
        "        smooth_britain.set_points_smoothly(anchors[::10])\n",
        "        smooth_britain.center().shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        index = np.argmax(smooth_britain.get_anchors()[:,0])\n",
        "        smooth_britain.zoom_point = smooth_britain.point_from_proportion(\n",
        "            self.britain_zoom_point_proportion\n",
        "        )\n",
        "\n",
        "        britain.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        britain.zoom_point = britain.point_from_proportion(\n",
        "            self.britain_zoom_point_proportion\n",
        "        )\n",
        "        fractalify(\n",
        "            britain,\n",
        "            order = self.fractalification_order,\n",
        "            dimension = self.fractal_dimension,\n",
        "        )\n",
        "\n",
        "        britains = VGroup(britain, smooth_britain)\n",
        "        self.play(*[\n",
        "            ShowCreation(mob, run_time = 3)\n",
        "            for mob in britains\n",
        "        ])\n",
        "        self.play(\n",
        "            britains.set_fill, BLUE, 1,\n",
        "            britains.set_stroke, None, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                smooth_britain.scale,\n",
        "                self.scale_factor,\n",
        "                smooth_britain.zoom_point\n",
        "            ),\n",
        "            Animation(v_line),\n",
        "            Animation(background_rectangle),\n",
        "            ApplyMethod(\n",
        "                britain.scale,\n",
        "                self.scale_factor,\n",
        "                britain.zoom_point\n",
        "            ),\n",
        "            Animation(smooth),\n",
        "            Animation(fractal),\n",
        "            run_time = 10,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class InfiniteKochZoom(Scene):\n",
        "    CONFIG = {\n",
        "        \"order\" : 6,\n",
        "        \"left_point\" : 3*LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        small_curve = self.get_curve(self.order)\n",
        "        larger_curve = self.get_curve(self.order + 1)\n",
        "        larger_curve.scale(3, about_point = small_curve.get_points()[0])\n",
        "        self.play(Transform(small_curve, larger_curve, run_time = 2))\n",
        "        self.repeat_frames(5)\n",
        "\n",
        "\n",
        "\n",
        "    def get_curve(self, order):\n",
        "        koch_curve = KochCurve(\n",
        "            monochromatic = True,\n",
        "            order = order,\n",
        "            color = BLUE,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "        koch_curve.set_width(18)\n",
        "        koch_curve.shift(\n",
        "            self.left_point - koch_curve.get_points()[0]\n",
        "        )\n",
        "        return koch_curve\n",
        "\n",
        "class ShowIdealizations(Scene):\n",
        "    def construct(self):\n",
        "        arrow = DoubleArrow(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "        arrow.shift(DOWN)\n",
        "        left_words = OldTexText(\"Idealization \\\\\\\\ as smooth\")\n",
        "        middle_words = OldTexText(\"Nature\")\n",
        "        right_words = OldTexText(\"\"\"\n",
        "            Idealization\n",
        "            as perfectly\n",
        "            self-similar\n",
        "        \"\"\")\n",
        "        for words in left_words, middle_words, right_words:\n",
        "            words.scale(0.8)\n",
        "            words.next_to(arrow, DOWN)\n",
        "        left_words.to_edge(LEFT)\n",
        "        right_words.to_edge(RIGHT)\n",
        "        self.add(arrow, left_words, middle_words, right_words)\n",
        "\n",
        "        britain = Britain()[0]\n",
        "        britain.set_height(4)\n",
        "        britain.next_to(arrow, UP)\n",
        "\n",
        "        anchors = britain.get_anchors()\n",
        "        smooth_britain = VMobject()\n",
        "        smooth_britain.set_points_smoothly(anchors[::10])\n",
        "        smooth_britain.set_stroke(width = 0)\n",
        "        smooth_britain.set_fill(BLUE_D, opacity = 1)\n",
        "        smooth_britain.next_to(arrow, UP)\n",
        "        smooth_britain.to_edge(LEFT)\n",
        "\n",
        "        koch_snowflake = KochSnowFlake(order = 5, monochromatic = True)\n",
        "        koch_snowflake.set_stroke(width = 0)\n",
        "        koch_snowflake.set_fill(BLUE_D, opacity = 1)\n",
        "        koch_snowflake.set_height(3)\n",
        "        koch_snowflake.rotate(2*np.pi/3)\n",
        "        koch_snowflake.next_to(arrow, UP)\n",
        "        koch_snowflake.to_edge(RIGHT)\n",
        "\n",
        "        VGroup(smooth_britain, britain, koch_snowflake).set_color_by_gradient(\n",
        "            BLUE_B, BLUE_D\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(britain))\n",
        "        self.wait()\n",
        "        self.play(Transform(britain.copy(), smooth_britain))\n",
        "        self.wait()\n",
        "        self.play(Transform(britain.copy(), koch_snowflake))\n",
        "        self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "class SayFractalDimension(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Fractal dimension\")\n",
        "        self.play_student_changes(\"confused\", \"hesitant\", \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class ExamplesOfDimension(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\"%s-dimensional\"%s)\n",
        "            for s in (\"1.585\", \"1.262\", \"1.21\")\n",
        "        ])\n",
        "        fractals = VGroup(*[\n",
        "            Sierpinski(order = 7),\n",
        "            KochSnowFlake(order = 5),\n",
        "            Britain(stroke_width = 2, fill_opacity = 0)\n",
        "        ])\n",
        "        for fractal, vect in zip(fractals, [LEFT, ORIGIN, RIGHT]):\n",
        "            fractal.to_edge(vect)\n",
        "        fractals[2].shift(0.5*UP)\n",
        "        fractals[1].shift(0.5*RIGHT)\n",
        "        for fractal, label, vect in zip(fractals, labels, [DOWN, UP, DOWN]):\n",
        "            label.next_to(fractal, vect)\n",
        "            label.shift_onto_screen()\n",
        "            self.play(\n",
        "                ShowCreation(fractal),\n",
        "                Write(label),\n",
        "                run_time = 3\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "class FractalDimensionIsNonsense(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer().shift(DOWN+3*RIGHT)\n",
        "        mathy = Mathematician().shift(DOWN+3*LEFT)\n",
        "        morty.make_eye_contact(mathy)\n",
        "\n",
        "        self.add(morty, mathy)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                mathy, \"It's 1.585-dimensional!\",\n",
        "                target_mode = \"hooray\"\n",
        "            ),\n",
        "            morty.change_mode, \"hesitant\"\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            PiCreatureSays(morty, \"Nonsense!\", target_mode = \"angry\"),\n",
        "            FadeOut(mathy.bubble),\n",
        "            FadeOut(mathy.bubble.content),\n",
        "            mathy.change_mode, \"guilty\"\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "class DimensionForNaturalNumbers(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\"%d-dimensional\"%d)\n",
        "            for d in (1, 2, 3)\n",
        "        ])\n",
        "        for label, vect in zip(labels, [LEFT, ORIGIN, RIGHT]):\n",
        "            label.to_edge(vect)\n",
        "        labels.shift(2*DOWN)\n",
        "\n",
        "        line = Line(DOWN+LEFT, 3*UP+RIGHT, color = BLUE)\n",
        "        line.next_to(labels[0], UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(labels[0]),\n",
        "            ShowCreation(line)\n",
        "        )\n",
        "        self.wait()\n",
        "        for label in labels[1:]:\n",
        "            self.play(Write(label))\n",
        "            self.wait()\n",
        "\n",
        "class Show2DPlanein3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class ShowCubeIn3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class OfCourseItsMadeUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Fractal dimension\n",
        "            \\\\emph{is} a made up concept...\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"hesitant\"]*3)\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"\"\"But it's useful!\"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class FourSelfSimilarShapes(Scene):\n",
        "    CONFIG = {\n",
        "        \"shape_width\" : 2,\n",
        "        \"sierpinski_order\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        titles = self.get_titles()\n",
        "        shapes = self.get_shapes(titles)\n",
        "\n",
        "        self.introduce_shapes(titles, shapes)\n",
        "        self.show_self_similarity(shapes)\n",
        "        self.mention_measurements()\n",
        "\n",
        "    def get_titles(self):\n",
        "        titles = VGroup(*list(map(TexText, [\n",
        "            \"Line\", \"Square\", \"Cube\", \"Sierpinski\"\n",
        "        ])))\n",
        "        for title, x in zip(titles, np.linspace(-0.75, 0.75, 4)):\n",
        "            title.shift(x*FRAME_X_RADIUS*RIGHT)\n",
        "        titles.to_edge(UP)\n",
        "        return titles\n",
        "\n",
        "    def get_shapes(self, titles):\n",
        "        line = VGroup(\n",
        "            Line(LEFT, ORIGIN),\n",
        "            Line(ORIGIN, RIGHT)\n",
        "        )\n",
        "        line.set_color(BLUE_C)\n",
        "\n",
        "        square = VGroup(*[\n",
        "            Square().next_to(ORIGIN, vect, buff = 0)\n",
        "            for vect in compass_directions(start_vect = DOWN+LEFT)\n",
        "        ])\n",
        "        square.set_stroke(width = 0)\n",
        "        square.set_fill(BLUE, 0.7)\n",
        "\n",
        "        cube = OldTexText(\"TODO\")\n",
        "        cube.set_fill(opacity = 0)\n",
        "\n",
        "        sierpinski = Sierpinski(order = self.sierpinski_order)\n",
        "\n",
        "        shapes = VGroup(line, square, cube, sierpinski)\n",
        "        for shape, title in zip(shapes, titles):\n",
        "            shape.set_width(self.shape_width)\n",
        "            shape.next_to(title, DOWN, buff = MED_SMALL_BUFF)\n",
        "        line.shift(DOWN)\n",
        "\n",
        "        return shapes\n",
        "\n",
        "    def introduce_shapes(self, titles, shapes):\n",
        "        line, square, cube, sierpinski = shapes\n",
        "\n",
        "        brace = Brace(VGroup(*shapes[:3]), DOWN)\n",
        "        brace_text = brace.get_text(\"Not fractals\")\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(GrowFromCenter(square))\n",
        "        self.play(FadeIn(cube))\n",
        "        self.play(ShowCreation(sierpinski))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, brace_text])))\n",
        "        self.wait()\n",
        "\n",
        "        for title in titles:\n",
        "            self.play(Write(title, run_time = 1))\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_self_similarity(self, shapes):\n",
        "        shapes_copy = shapes.copy()\n",
        "        self.shapes_copy = shapes_copy\n",
        "        line, square, cube, sierpinski = shapes_copy\n",
        "\n",
        "        self.play(line.shift, 3*DOWN)\n",
        "        self.play(ApplyFunction(break_up, line))\n",
        "        self.wait()\n",
        "        brace = Brace(line[0], DOWN)\n",
        "        brace_text = brace.get_text(\"1/2\")\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        brace.add(brace_text)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(square.next_to, square, DOWN, LARGE_BUFF)\n",
        "        self.play(ApplyFunction(break_up, square))\n",
        "        subsquare = square[0]\n",
        "        subsquare.save_state()\n",
        "        self.play(subsquare.replace, shapes[1])\n",
        "        self.wait()\n",
        "        self.play(subsquare.restore)\n",
        "        self.play(brace.next_to, subsquare, DOWN)\n",
        "        self.wait()\n",
        "\n",
        "        self.wait(5)#Handle cube\n",
        "\n",
        "        self.play(sierpinski.next_to, sierpinski, DOWN, LARGE_BUFF)\n",
        "        self.play(ApplyFunction(break_up, sierpinski))\n",
        "        self.wait()\n",
        "        self.play(brace.next_to, sierpinski[0], DOWN)\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(brace))\n",
        "\n",
        "    def mention_measurements(self):\n",
        "        line, square, cube, sierpinski = self.shapes_copy\n",
        "\n",
        "        labels = list(map(TexText, [\n",
        "            \"$1/2$ length\",\n",
        "            \"$1/4$ area\",\n",
        "            \"$1/8$ volume\",\n",
        "            \"You'll see...\",\n",
        "        ]))\n",
        "        for label, shape in zip(labels, self.shapes_copy):\n",
        "            label.next_to(shape, DOWN)\n",
        "            label.to_edge(DOWN, buff = MED_LARGE_BUFF)\n",
        "            if label is labels[-1]:\n",
        "                label.shift(0.1*UP) #Dumb\n",
        "\n",
        "            self.play(\n",
        "                Write(label, run_time = 1),\n",
        "                shape[0].set_color, YELLOW\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class BreakUpCubeIn3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class BrokenUpCubeIn3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class GeneralWordForMeasurement(Scene):\n",
        "    def construct(self):\n",
        "        measure = OldTexText(\"``Measure''\")\n",
        "        measure.to_edge(UP)\n",
        "        mass = OldTexText(\"Mass\")\n",
        "        mass.move_to(measure)\n",
        "\n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"Length\", \"Area\", \"Volume\"\n",
        "        ])))\n",
        "        words.arrange(RIGHT, buff = 2*LARGE_BUFF)\n",
        "        words.next_to(measure, DOWN, buff = 2*LARGE_BUFF)\n",
        "        colors = color_gradient([BLUE_B, BLUE_D], len(words))\n",
        "        for word, color in zip(words, colors):\n",
        "            word.set_color(color)\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                measure.get_bottom(), word.get_top(),\n",
        "                color = word.get_color(),\n",
        "                buff = MED_SMALL_BUFF\n",
        "            )\n",
        "            for word in words\n",
        "        ])\n",
        "\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word))\n",
        "        self.play(ShowCreation(lines, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(Write(measure))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(measure, mass))\n",
        "        self.wait(2)\n",
        "\n",
        "class ImagineShapesAsMetal(FourSelfSimilarShapes):\n",
        "    def construct(self):\n",
        "        titles = VGroup(*list(map(VGroup, self.get_titles())))\n",
        "        shapes = self.get_shapes(titles)\n",
        "        shapes.shift(DOWN)\n",
        "        descriptions = VGroup(*[\n",
        "            OldTexText(*words, arg_separator = \"\\\\\\\\\")\n",
        "            for shape, words in zip(shapes, [\n",
        "                [\"Thin\", \"wire\"],\n",
        "                [\"Flat\", \"sheet\"],\n",
        "                [\"Solid\", \"cube\"],\n",
        "                [\"Sierpinski\", \"mesh\"]\n",
        "            ])\n",
        "        ])\n",
        "        for title, description in zip(titles, descriptions):\n",
        "            description.move_to(title, UP)\n",
        "            title.target = description\n",
        "\n",
        "        self.add(titles, shapes)\n",
        "        for shape in shapes:\n",
        "            shape.generate_target()\n",
        "            shape.target.set_color(GREY_B)\n",
        "        shapes[-1].target.set_color_by_gradient(GREY, WHITE)\n",
        "        for shape, title in zip(shapes, titles):\n",
        "            self.play(\n",
        "                MoveToTarget(title),\n",
        "                MoveToTarget(shape)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        for shape in shapes:\n",
        "            self.play(\n",
        "                shape.scale, 0.5, shape.get_top(),\n",
        "                run_time = 3,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class ScaledLineMass(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Line\",\n",
        "        \"mass_scaling_factor\" : \"\\\\frac{1}{2}\",\n",
        "        \"shape_width\" : 2,\n",
        "        \"break_up_factor\" : 1.3,\n",
        "        \"vert_distance\" : 2,\n",
        "        \"brace_direction\" : DOWN,\n",
        "        \"shape_to_shape_buff\" : 2*LARGE_BUFF,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(self.title)\n",
        "        title.to_edge(UP)\n",
        "        scaling_factor_label = OldTexText(\n",
        "            \"Scaling factor:\", \"$\\\\frac{1}{2}$\"\n",
        "        )\n",
        "        scaling_factor_label[1].set_color(YELLOW)\n",
        "        scaling_factor_label.to_edge(LEFT).shift(UP)\n",
        "        mass_scaling_label = OldTexText(\n",
        "            \"Mass scaling factor:\", \"$%s$\"%self.mass_scaling_factor\n",
        "        )\n",
        "        mass_scaling_label[1].set_color(GREEN)\n",
        "        mass_scaling_label.next_to(\n",
        "            scaling_factor_label, DOWN,\n",
        "            aligned_edge = LEFT,\n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        shape = self.get_shape()\n",
        "        shape.set_width(self.shape_width)\n",
        "        shape.center()\n",
        "        shape.shift(FRAME_X_RADIUS*RIGHT/2 + self.vert_distance*UP)\n",
        "\n",
        "        big_brace = Brace(shape, self.brace_direction)\n",
        "        big_brace_text = big_brace.get_text(\"$1$\")\n",
        "\n",
        "        shape_copy = shape.copy()\n",
        "        shape_copy.next_to(shape, DOWN, buff = self.shape_to_shape_buff)\n",
        "        shape_copy.scale(self.break_up_factor)\n",
        "        for submob in shape_copy:\n",
        "            submob.scale(1./self.break_up_factor)\n",
        "\n",
        "        little_brace = Brace(shape_copy[0], self.brace_direction)\n",
        "        little_brace_text = little_brace.get_text(\"$\\\\frac{1}{2}$\")\n",
        "\n",
        "        self.add(title, scaling_factor_label, mass_scaling_label[0])\n",
        "        self.play(GrowFromCenter(shape))\n",
        "        self.play(\n",
        "            GrowFromCenter(big_brace),\n",
        "            Write(big_brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            shape.copy().replace, shape_copy[0]\n",
        "        )\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(shape_copy[0])\n",
        "        self.play(\n",
        "            GrowFromCenter(little_brace),\n",
        "            Write(little_brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(mass_scaling_label[1], run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(\n",
        "            VGroup(*shape_copy[1:]),\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            shape_copy.copy(), shape\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def get_shape(self):\n",
        "        return VGroup(\n",
        "            Line(LEFT, ORIGIN),\n",
        "            Line(ORIGIN, RIGHT)\n",
        "        ).set_color(BLUE)\n",
        "\n",
        "class ScaledSquareMass(ScaledLineMass):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Square\",\n",
        "        \"mass_scaling_factor\" : \"\\\\frac{1}{4} = \\\\left( \\\\frac{1}{2} \\\\right)^2\",\n",
        "        \"brace_direction\" : LEFT,\n",
        "    }\n",
        "    def get_shape(self):\n",
        "        return VGroup(*[\n",
        "            Square(\n",
        "                stroke_width = 0,\n",
        "                fill_color =  BLUE,\n",
        "                fill_opacity = 0.7\n",
        "            ).shift(vect)\n",
        "            for vect in compass_directions(start_vect = DOWN+LEFT)\n",
        "        ])\n",
        "\n",
        "class ScaledCubeMass(ScaledLineMass):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Cube\",\n",
        "        \"mass_scaling_factor\" : \"\\\\frac{1}{8} = \\\\left( \\\\frac{1}{2} \\\\right)^3\",\n",
        "    }\n",
        "    def get_shape(self):\n",
        "        return VectorizedPoint()\n",
        "\n",
        "class FormCubeFromSubcubesIn3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class ScaledSierpinskiMass(ScaledLineMass):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Sierpinski\",\n",
        "        \"mass_scaling_factor\" : \"\\\\frac{1}{3}\",\n",
        "        \"vert_distance\" : 2.5,\n",
        "        \"shape_to_shape_buff\" : 1.5*LARGE_BUFF,\n",
        "    }\n",
        "    def get_shape(self):\n",
        "        return Sierpinski(order = 6)\n",
        "\n",
        "class DefineTwoDimensional(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"dimension\" : \"2\",\n",
        "        \"length_color\" : GREEN,\n",
        "        \"dimension_color\" : YELLOW,\n",
        "        \"shape_width\" : 2,\n",
        "        \"scale_factor\" : 0.5,\n",
        "        \"bottom_shape_buff\" : MED_SMALL_BUFF,\n",
        "        \"scalar\" : \"s\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_h_line()\n",
        "        self.add_shape()\n",
        "        self.add_width_mass_labels()\n",
        "        self.show_top_length()\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.perform_scaling()\n",
        "        self.show_dimension()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            self.dimension, \"-dimensional\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        self.dimension_in_title = title[0]\n",
        "        self.dimension_in_title.set_color(self.dimension_color)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        self.title = title\n",
        "\n",
        "    def add_h_line(self):\n",
        "        self.h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        self.add(self.h_line)\n",
        "\n",
        "    def add_shape(self):\n",
        "        shape = self.get_shape()\n",
        "        shape.set_width(self.shape_width)\n",
        "        shape.next_to(self.title, DOWN, buff = MED_LARGE_BUFF)\n",
        "        # self.shape.shift(FRAME_Y_RADIUS*UP/2)\n",
        "        self.mass_color = shape.get_color()\n",
        "        self.add(shape)\n",
        "\n",
        "        self.shape = shape\n",
        "\n",
        "    def add_width_mass_labels(self):\n",
        "        top_length = OldTexText(\"Length:\", \"$L$\")\n",
        "        top_mass = OldTexText(\"Mass:\", \"$M$\")\n",
        "        bottom_length = OldTexText(\n",
        "            \"Length: \", \"$%s$\"%self.scalar, \"$L$\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        bottom_mass = OldTexText(\n",
        "            \"Mass: \",\n",
        "            \"$%s^%s$\"%(self.scalar, self.dimension),\n",
        "            \"$M$\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        self.dimension_in_exp = VGroup(\n",
        "            *bottom_mass[1][-len(self.dimension):]\n",
        "        )\n",
        "        self.dimension_in_exp.set_color(self.dimension_color)\n",
        "\n",
        "        top_group = VGroup(top_length, top_mass)\n",
        "        bottom_group = VGroup(bottom_length, bottom_mass)\n",
        "        for group in top_group, bottom_group:\n",
        "            group.arrange(\n",
        "                DOWN,\n",
        "                buff = MED_LARGE_BUFF,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "            group[0][-1].set_color(self.length_color)\n",
        "            group[1][-1].set_color(self.mass_color)\n",
        "\n",
        "        top_group.next_to(self.h_line, UP, buff = LARGE_BUFF)\n",
        "        bottom_group.next_to(self.h_line, DOWN, buff = LARGE_BUFF)\n",
        "        for group in top_group, bottom_group:\n",
        "            group.to_edge(LEFT)\n",
        "\n",
        "        self.add(top_group, bottom_group)\n",
        "\n",
        "        self.top_L = top_length[-1]\n",
        "        self.bottom_L = VGroup(*bottom_length[-2:])\n",
        "        self.bottom_mass = bottom_mass\n",
        "\n",
        "    def show_top_length(self):\n",
        "        brace = Brace(self.shape, LEFT)\n",
        "        top_L = self.top_L.copy()\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(top_L.next_to, brace, LEFT)\n",
        "        self.wait()\n",
        "\n",
        "        self.brace = brace\n",
        "\n",
        "    def perform_scaling(self):\n",
        "        group = VGroup(self.shape, self.brace).copy()\n",
        "        self.play(\n",
        "            group.shift,\n",
        "            (group.get_top()[1]+self.bottom_shape_buff)*DOWN\n",
        "        )\n",
        "\n",
        "        shape, brace = group\n",
        "        bottom_L = self.bottom_L.copy()\n",
        "        shape.generate_target()\n",
        "        shape.target.scale(\n",
        "            self.scale_factor,\n",
        "        )\n",
        "        brace.target = Brace(shape.target, LEFT)\n",
        "        self.play(*list(map(MoveToTarget, group)))\n",
        "        self.play(bottom_L.next_to, brace, LEFT)\n",
        "        self.wait()\n",
        "\n",
        "    def show_dimension(self):\n",
        "        top_dimension = self.dimension_in_title.copy()\n",
        "        self.play(self.pi_creature.look_at, top_dimension)\n",
        "        self.play(Transform(\n",
        "            top_dimension,\n",
        "            self.dimension_in_exp,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_shape(self):\n",
        "        return Square(\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.7,\n",
        "        )\n",
        "\n",
        "class DefineThreeDimensional(DefineTwoDimensional):\n",
        "    CONFIG = {\n",
        "        \"dimension\" : \"3\",\n",
        "    }\n",
        "    def get_shape(self):\n",
        "        return Square(\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = 0\n",
        "        )\n",
        "\n",
        "class DefineSierpinskiDimension(DefineTwoDimensional):\n",
        "    CONFIG = {\n",
        "        \"dimension\" : \"D\",\n",
        "        \"scalar\" : \"\\\\left( \\\\frac{1}{2} \\\\right)\",\n",
        "        \"sierpinski_order\" : 6,\n",
        "        \"equation_scale_factor\" : 1.3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        DefineTwoDimensional.construct(self)\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "        self.add_one_third()\n",
        "        self.isolate_equation()\n",
        "\n",
        "    def add_one_third(self):\n",
        "        equation = OldTexText(\n",
        "            \"$= \\\\left(\\\\frac{1}{3}\\\\right)$\", \"$M$\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        equation.set_color_by_tex(\"$M$\", self.mass_color)\n",
        "        equation.next_to(self.bottom_mass)\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = VGroup(self.bottom_mass, equation)\n",
        "        self.distilled_equation = VGroup(\n",
        "            self.bottom_mass[1],\n",
        "            equation[0]\n",
        "        ).copy()\n",
        "\n",
        "    def isolate_equation(self):\n",
        "        # everything = VGroup(*self.get_mobjects())\n",
        "        keepers = [self.pi_creature, self.equation]\n",
        "        for mob in keepers:\n",
        "            mob.save_state()\n",
        "        keepers_copies = [mob.copy() for mob in keepers]\n",
        "        self.play(\n",
        "            *[\n",
        "                ApplyMethod(mob.fade, 0.5)\n",
        "                for mob in self.get_mobjects()\n",
        "            ] + [\n",
        "                Animation(mob)\n",
        "                for mob in keepers_copies\n",
        "            ]\n",
        "        )\n",
        "        self.remove(*keepers_copies)\n",
        "        for mob in keepers:\n",
        "            ApplyMethod(mob.restore).update(1)\n",
        "        self.add(*keepers)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"confused\",\n",
        "            self.pi_creature.look_at, self.equation\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        equation = self.distilled_equation\n",
        "        self.play(\n",
        "            equation.arrange, RIGHT,\n",
        "            equation.scale, self.equation_scale_factor,\n",
        "            equation.to_corner, UP+RIGHT,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        simpler_equation = OldTex(\"2^D = 3\")\n",
        "        simpler_equation[1].set_color(self.dimension_color)\n",
        "        simpler_equation.scale(self.equation_scale_factor)\n",
        "        simpler_equation.next_to(equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        log_expression = OldTex(\"\\\\log_2(3) \\\\approx\", \"1.585\")\n",
        "        log_expression[-1].set_color(self.dimension_color)\n",
        "        log_expression.scale(self.equation_scale_factor)\n",
        "        log_expression.next_to(simpler_equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "        log_expression.shift_onto_screen()\n",
        "\n",
        "        self.play(Write(simpler_equation))\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait(2)\n",
        "        self.play(Write(log_expression))\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"hooray\",\n",
        "            self.pi_creature.look_at, log_expression\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_shape(self):\n",
        "        return Sierpinski(\n",
        "            order = self.sierpinski_order,\n",
        "            color = RED,\n",
        "        )\n",
        "\n",
        "class ShowSierpinskiCurve(Scene):\n",
        "    CONFIG = {\n",
        "        \"max_order\" : 8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        curve = self.get_curve(2)\n",
        "        self.play(ShowCreation(curve, run_time = 2))\n",
        "        for order in range(3, self.max_order + 1):\n",
        "            self.play(Transform(\n",
        "                curve, self.get_curve(order),\n",
        "                run_time = 2\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "    def get_curve(self, order):\n",
        "        curve = SierpinskiCurve(order = order, monochromatic = True)\n",
        "        curve.set_color(RED)\n",
        "        return curve\n",
        "\n",
        "class LengthAndAreaOfSierpinski(ShowSierpinskiCurve):\n",
        "    CONFIG = {\n",
        "        \"curve_start_order\" : 5,\n",
        "        \"sierpinski_start_order\" : 4,\n",
        "        \"n_iterations\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        length = OldTexText(\"Length = $\\\\infty$\")\n",
        "        length.shift(FRAME_X_RADIUS*LEFT/2).to_edge(UP)\n",
        "        area = OldTexText(\"Area = $0$\")\n",
        "        area.shift(FRAME_X_RADIUS*RIGHT/2).to_edge(UP)\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        self.add(length, area, v_line)\n",
        "\n",
        "        curve = self.get_curve(order = self.curve_start_order)\n",
        "        sierp = self.get_sierpinski(order = self.sierpinski_start_order)\n",
        "        self.add(curve, sierp)\n",
        "        self.wait()\n",
        "\n",
        "        for x in range(self.n_iterations):\n",
        "            new_curve = self.get_curve(order = self.curve_start_order+x+1)\n",
        "            alpha = (x+1.0)/self.n_iterations\n",
        "            stroke_width = interpolate(3, 1, alpha)\n",
        "            new_curve.set_stroke(width = stroke_width)\n",
        "\n",
        "            new_sierp = self.get_sierpinski(\n",
        "                order = self.sierpinski_start_order+x+1\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                Transform(sierp, new_sierp),\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.play(sierp.set_fill, None, 0)\n",
        "        self.wait()\n",
        "\n",
        "    def get_curve(self, order):\n",
        "        # curve = ShowSierpinskiCurve.get_curve(self, order)\n",
        "        curve = SierpinskiCurve(order = order)\n",
        "        curve.set_height(4).center()\n",
        "        curve.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        return curve\n",
        "\n",
        "    def get_sierpinski(self, order):\n",
        "        result = Sierpinski(order = order)\n",
        "        result.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        return result\n",
        "\n",
        "class FractionalAnalogOfLengthAndArea(Scene):\n",
        "    def construct(self):\n",
        "        last_sc = LengthAndAreaOfSierpinski(skip_animations = True)\n",
        "        self.add(*last_sc.get_mobjects())\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty,\n",
        "            \"\"\"\n",
        "            Better described with a\n",
        "            1.585-dimensional measure.\n",
        "            \"\"\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class DimensionOfKoch(Scene):\n",
        "    CONFIG = {\n",
        "        \"scaling_factor_color\" : YELLOW,\n",
        "        \"mass_scaling_color\" : BLUE,\n",
        "        \"dimension_color\" : GREEN_A,\n",
        "        \"curve_class\" : KochCurve,\n",
        "        \"scaling_factor\" : 3,\n",
        "        \"mass_scaling_factor\" : 4,\n",
        "        \"num_subparts\" : 4,\n",
        "        \"koch_curve_order\" : 5,\n",
        "        \"koch_curve_width\" : 5,\n",
        "        \"break_up_factor\" : 1.5,\n",
        "        \"down_shift\" : 3*DOWN,\n",
        "        \"dimension_rhs\" : \"\\\\approx 1.262\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_labels()\n",
        "        self.add_curve()\n",
        "        self.break_up_curve()\n",
        "        self.compare_sizes()\n",
        "        self.show_dimension()\n",
        "\n",
        "    def add_labels(self):\n",
        "        scaling_factor = OldTexText(\n",
        "            \"Scaling factor:\",\n",
        "            \"$\\\\frac{1}{%d}$\"%self.scaling_factor,\n",
        "        )\n",
        "        scaling_factor.next_to(ORIGIN, UP)\n",
        "        scaling_factor.to_edge(LEFT)\n",
        "        scaling_factor[1].set_color(self.scaling_factor_color)\n",
        "        self.add(scaling_factor[0])\n",
        "\n",
        "        mass_scaling = OldTexText(\n",
        "            \"Mass scaling factor:\",\n",
        "            \"$\\\\frac{1}{%d}$\"%self.mass_scaling_factor\n",
        "        )\n",
        "        mass_scaling.next_to(ORIGIN, DOWN)\n",
        "        mass_scaling.to_edge(LEFT)\n",
        "        mass_scaling[1].set_color(self.mass_scaling_color)\n",
        "        self.add(mass_scaling[0])\n",
        "\n",
        "        self.scaling_factor_mob = scaling_factor[1]\n",
        "        self.mass_scaling_factor_mob = mass_scaling[1]\n",
        "\n",
        "    def add_curve(self):\n",
        "        curve = self.curve_class(order = self.koch_curve_order)\n",
        "        curve.set_width(self.koch_curve_width)\n",
        "        curve.to_corner(UP+RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(curve, run_time = 2))\n",
        "        self.wait()\n",
        "        self.curve = curve\n",
        "\n",
        "    def break_up_curve(self):\n",
        "        curve_copy = self.curve.copy()\n",
        "        length = len(curve_copy)\n",
        "        n_parts = self.num_subparts\n",
        "        broken_curve = VGroup(*[\n",
        "            VGroup(*curve_copy[i*length/n_parts:(i+1)*length/n_parts])\n",
        "            for i in range(n_parts)\n",
        "        ])\n",
        "        self.play(broken_curve.shift, self.down_shift)\n",
        "\n",
        "        broken_curve.generate_target()\n",
        "        break_up(broken_curve.target, self.break_up_factor)\n",
        "        broken_curve.target.shift_onto_screen\n",
        "        self.play(MoveToTarget(broken_curve))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(broken_curve)\n",
        "        self.broken_curve = broken_curve\n",
        "\n",
        "    def compare_sizes(self):\n",
        "        big_brace = Brace(self.curve, DOWN)\n",
        "        one = big_brace.get_text(\"$1$\")\n",
        "        little_brace = Brace(self.broken_curve[0], DOWN)\n",
        "        one_third = little_brace.get_text(\"1/%d\"%self.scaling_factor)\n",
        "        one_third.set_color(self.scaling_factor_color)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(big_brace),\n",
        "            GrowFromCenter(little_brace),\n",
        "            Write(one),\n",
        "            Write(one_third),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(self.scaling_factor_mob))\n",
        "        self.wait()\n",
        "        self.play(Write(self.mass_scaling_factor_mob))\n",
        "        self.wait()\n",
        "\n",
        "    def show_dimension(self):\n",
        "        raw_formula = OldTex(\"\"\"\n",
        "            \\\\left( \\\\frac{1}{%s} \\\\right)^D\n",
        "            =\n",
        "            \\\\left( \\\\frac{1}{%s} \\\\right)\n",
        "        \"\"\"%(self.scaling_factor, self.mass_scaling_factor))\n",
        "        formula = VGroup(\n",
        "            VGroup(*raw_formula[:5]),\n",
        "            VGroup(raw_formula[5]),\n",
        "            VGroup(raw_formula[6]),\n",
        "            VGroup(*raw_formula[7:]),\n",
        "        )\n",
        "        formula.to_corner(UP+LEFT)\n",
        "\n",
        "        simpler_formula = OldTex(\n",
        "            str(self.scaling_factor),\n",
        "            \"^D\", \"=\",\n",
        "            str(self.mass_scaling_factor)\n",
        "        )\n",
        "        simpler_formula.move_to(formula, UP)\n",
        "\n",
        "        for mob in formula, simpler_formula:\n",
        "            mob[0].set_color(self.scaling_factor_color)\n",
        "            mob[1].set_color(self.dimension_color)\n",
        "            mob[3].set_color(self.mass_scaling_color)\n",
        "\n",
        "        log_expression = OldTex(\n",
        "            \"D = \\\\log_%d(%d) %s\"%(\n",
        "                self.scaling_factor,\n",
        "                self.mass_scaling_factor,\n",
        "                self.dimension_rhs\n",
        "            )\n",
        "        )\n",
        "        log_expression[0].set_color(self.dimension_color)\n",
        "        log_expression[5].set_color(self.scaling_factor_color)\n",
        "        log_expression[7].set_color(self.mass_scaling_color)\n",
        "        log_expression.next_to(\n",
        "            simpler_formula, DOWN,\n",
        "            aligned_edge = LEFT,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        third = self.scaling_factor_mob.copy()\n",
        "        fourth = self.mass_scaling_factor_mob.copy()\n",
        "        for mob in third, fourth:\n",
        "            mob.add(VectorizedPoint(mob.get_right()))\n",
        "            mob.add_to_back(VectorizedPoint(mob.get_left()))\n",
        "\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Transform(third, formula[0]),\n",
        "            Transform(fourth, formula[-1]),\n",
        "        )\n",
        "        self.play(*list(map(FadeIn, formula[1:-1])))\n",
        "        self.remove(third, fourth)\n",
        "        self.add(formula)\n",
        "        self.wait(2)\n",
        "        self.play(Transform(formula, simpler_formula))\n",
        "        self.wait(2)\n",
        "        self.play(Write(log_expression))\n",
        "        self.wait(2)\n",
        "\n",
        "class DimensionOfQuadraticKoch(DimensionOfKoch):\n",
        "    CONFIG = {\n",
        "        \"curve_class\" : QuadraticKoch,\n",
        "        \"scaling_factor\" : 4,\n",
        "        \"mass_scaling_factor\" : 8,\n",
        "        \"num_subparts\" : 8,\n",
        "        \"koch_curve_order\" : 4,\n",
        "        \"koch_curve_width\" : 4,\n",
        "        \"break_up_factor\" : 1.7,\n",
        "        \"down_shift\" : 4*DOWN,\n",
        "        \"dimension_rhs\" : \"= \\\\frac{3}{2} = 1.5\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_labels()\n",
        "        self.add_curve()\n",
        "        self.set_color_curve_subparts()\n",
        "        self.show_dimension()\n",
        "\n",
        "    def get_curve(self, order):\n",
        "        curve = self.curve_class(\n",
        "            order = order,\n",
        "            monochromatic = True\n",
        "        )\n",
        "        curve.set_width(self.koch_curve_width)\n",
        "        alpha = float(order) / self.koch_curve_order\n",
        "        stroke_width = interpolate(3, 1, alpha)\n",
        "        curve.set_stroke(width = stroke_width)\n",
        "        return curve\n",
        "\n",
        "    def add_curve(self):\n",
        "        seed_label = OldTexText(\"Seed\")\n",
        "        seed_label.shift(FRAME_X_RADIUS*RIGHT/2).to_edge(UP)\n",
        "        seed = self.get_curve(order = 1)\n",
        "        seed.next_to(seed_label, DOWN)\n",
        "\n",
        "        curve = seed.copy()\n",
        "\n",
        "        resulting_fractal = OldTexText(\"Resulting fractal\")\n",
        "        resulting_fractal.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "\n",
        "        self.add(seed_label, seed)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            curve.next_to, resulting_fractal, DOWN, MED_LARGE_BUFF,\n",
        "            Write(resulting_fractal, run_time = 1)\n",
        "        )\n",
        "        for order in range(2, self.koch_curve_order+1):\n",
        "            new_curve = self.get_curve(order)\n",
        "            new_curve.move_to(curve)\n",
        "            n_curve_parts = curve.get_num_curves()\n",
        "            curve.insert_n_curves(6 * n_curve_parts)\n",
        "            curve.make_jagged()\n",
        "            self.play(Transform(curve, new_curve, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.curve = curve\n",
        "\n",
        "    def set_color_curve_subparts(self):\n",
        "        n_parts = self.num_subparts\n",
        "        colored_curve = self.curve_class(\n",
        "            order = self.koch_curve_order,\n",
        "            stroke_width = 1\n",
        "        )\n",
        "        colored_curve.replace(self.curve)\n",
        "        length = len(colored_curve)\n",
        "        broken_curve = VGroup(*[\n",
        "            VGroup(*colored_curve[i*length/n_parts:(i+1)*length/n_parts])\n",
        "            for i in range(n_parts)\n",
        "        ])\n",
        "        colors = it.cycle([WHITE, RED])\n",
        "        for subpart, color in zip(broken_curve, colors):\n",
        "            subpart.set_color(color)\n",
        "        self.play(\n",
        "            FadeOut(self.curve),\n",
        "            FadeIn(colored_curve)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                lambda m : break_up(m, self.break_up_factor),\n",
        "                broken_curve,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(self.scaling_factor_mob))\n",
        "        self.play(Write(self.mass_scaling_factor_mob))\n",
        "        self.wait(2)\n",
        "\n",
        "class ThisIsSelfSimilarityDimension(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            This is called\n",
        "            ``self-similarity dimension''\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class ShowSeveralSelfSimilarityDimensions(Scene):\n",
        "    def construct(self):\n",
        "        vects = [\n",
        "            4*LEFT,\n",
        "            ORIGIN,\n",
        "            4*RIGHT,\n",
        "        ]\n",
        "        fractal_classes = [\n",
        "            PentagonalFractal,\n",
        "            QuadraticKoch,\n",
        "            DiamondFractal,\n",
        "        ]\n",
        "        max_orders = [\n",
        "            4,\n",
        "            4,\n",
        "            5,\n",
        "        ]\n",
        "        dimensions = [\n",
        "            1.668,\n",
        "            1.500,\n",
        "            1.843,\n",
        "        ]\n",
        "\n",
        "        title = OldTexText(\"``Self-similarity dimension''\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(YELLOW)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "        def get_curves(order):\n",
        "            curves = VGroup()\n",
        "            for Class, vect in zip(fractal_classes, vects):\n",
        "                curve = Class(order = order)\n",
        "                curve.set_width(2),\n",
        "                curve.shift(vect)\n",
        "                curves.add(curve)\n",
        "            return curves\n",
        "        curves = get_curves(1)\n",
        "        self.add(curves)\n",
        "\n",
        "        for curve, dimension, u in zip(curves, dimensions, [1, -1, 1]):\n",
        "            label = OldTexText(\"%.3f-dimensional\"%dimension)\n",
        "            label.scale(0.85)\n",
        "            label.next_to(curve, u*UP, buff = LARGE_BUFF)\n",
        "            self.add(label)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for order in  range(2, max(max_orders)+1):\n",
        "            anims = []\n",
        "            for curve, max_order in zip(curves, max_orders):\n",
        "                if order <= max_order:\n",
        "                    new_curve = curve.__class__(order = order)\n",
        "                    new_curve.replace(curve)\n",
        "                    anims.append(Transform(curve, new_curve))\n",
        "            self.play(*anims, run_time = 2)\n",
        "        self.wait()\n",
        "        self.curves = curves\n",
        "\n",
        "class SeparateFractals(Scene):\n",
        "    def construct(self):\n",
        "        last_sc = ShowSeveralSelfSimilarityDimensions(skip_animations = True)\n",
        "        self.add(*last_sc.get_mobjects())\n",
        "        quad_koch = last_sc.curves[1]\n",
        "        length = len(quad_koch)\n",
        "        new_quad_koch = VGroup(*[\n",
        "            VGroup(*quad_koch[i*length/8:(i+1)*length/8])\n",
        "            for i in range(8)\n",
        "        ])\n",
        "        curves = list(last_sc.curves)\n",
        "        curves[1] = new_quad_koch\n",
        "        curves = VGroup(*curves)\n",
        "        curves.save_state()\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda m : break_up(m, 2),\n",
        "                curve\n",
        "            )\n",
        "            for curve in curves\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.play(curves.restore)\n",
        "        self.wait()\n",
        "\n",
        "class ShowDiskScaling(Scene):\n",
        "    def construct(self):\n",
        "        self.show_non_self_similar_shapes()\n",
        "        self.isolate_disk()\n",
        "        self.scale_disk()\n",
        "        self.write_mass_scaling_factor()\n",
        "        self.try_fitting_small_disks()\n",
        "\n",
        "    def show_non_self_similar_shapes(self):\n",
        "        title = OldTexText(\n",
        "            \"Most shapes are not self-similar\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        hexagon = RegularPolygon(n = 6)\n",
        "        disk = Circle()\n",
        "        blob = VMobject().set_points_smoothly([\n",
        "            RIGHT, RIGHT+UP, ORIGIN, RIGHT+DOWN, LEFT, UP, RIGHT\n",
        "        ])\n",
        "        britain = Britain()\n",
        "        shapes = VGroup(hexagon, blob, disk, britain)\n",
        "        for shape in shapes:\n",
        "            shape.set_width(1.5)\n",
        "            shape.set_stroke(width = 0)\n",
        "            shape.set_fill(opacity = 1)\n",
        "        shapes.set_color_by_gradient(BLUE_B, BLUE_E)\n",
        "        shapes.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        shapes.next_to(title, DOWN)\n",
        "        for shape in shapes:\n",
        "            self.play(FadeIn(shape))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.disk = disk\n",
        "        self.to_fade = VGroup(\n",
        "            title, hexagon, blob, britain\n",
        "        )\n",
        "\n",
        "    def isolate_disk(self):\n",
        "        disk = self.disk\n",
        "        self.play(\n",
        "            FadeOut(self.to_fade),\n",
        "            disk.set_width, 2,\n",
        "            disk.next_to, ORIGIN, LEFT, 2,\n",
        "            disk.set_fill, BLUE_D, 0.7\n",
        "        )\n",
        "\n",
        "        radius = Line(\n",
        "            disk.get_center(), disk.get_right(),\n",
        "            color = YELLOW\n",
        "        )\n",
        "        one = OldTex(\"1\").next_to(radius, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(Write(one))\n",
        "        self.wait()\n",
        "\n",
        "        self.disk.add(radius, one)\n",
        "\n",
        "    def scale_disk(self):\n",
        "        scaled_disk = self.disk.copy()\n",
        "        scaled_disk.generate_target()\n",
        "        scaled_disk.target.scale(2)\n",
        "        scaled_disk.target.next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        one = scaled_disk.target[-1]\n",
        "        two = OldTex(\"2\")\n",
        "        two.move_to(one, UP)\n",
        "        scaled_disk.target.submobjects[-1] = two\n",
        "\n",
        "        self.play(MoveToTarget(scaled_disk))\n",
        "        self.wait()\n",
        "\n",
        "        self.scaled_disk = scaled_disk\n",
        "\n",
        "    def write_mass_scaling_factor(self):\n",
        "        mass_scaling = OldTexText(\n",
        "            \"Mass scaling factor: $2^2 = 4$\"\n",
        "        )\n",
        "        mass_scaling.next_to(self.scaled_disk, UP)\n",
        "        mass_scaling.to_edge(UP)\n",
        "        self.play(Write(mass_scaling))\n",
        "        self.wait()\n",
        "\n",
        "    def try_fitting_small_disks(self):\n",
        "        disk = self.disk.copy()\n",
        "        disk.submobjects = []\n",
        "        disk.set_fill(opacity = 0.5)\n",
        "        foursome = VGroup(*[\n",
        "            disk.copy().next_to(ORIGIN, vect, buff = 0)\n",
        "            for vect in compass_directions(start_vect = UP+RIGHT)\n",
        "        ])\n",
        "        foursome.move_to(self.scaled_disk)\n",
        "\n",
        "        self.play(Transform(disk, foursome))\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(foursome)\n",
        "        self.wait()\n",
        "        self.play(ApplyFunction(\n",
        "            lambda m : break_up(m, 0.2),\n",
        "            foursome,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 4,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(foursome))\n",
        "        self.wait()\n",
        "\n",
        "class WhatDoYouMeanByMass(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What do you mean \\\\\\\\ by mass?\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"sassy\", \"confused\")\n",
        "        self.wait()\n",
        "        self.play(self.get_teacher().change_mode, \"thinking\")\n",
        "        self.wait(2)\n",
        "        self.teacher_thinks(\"\")\n",
        "        self.zoom_in_on_thought_bubble()\n",
        "\n",
        "class BoxCountingScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.25,\n",
        "        \"box_color\" : YELLOW,\n",
        "        \"box_opacity\" : 0.5,\n",
        "        \"num_boundary_check_points\" : 200,\n",
        "        \"corner_rect_left_extension\" : 0,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.num_rows = 2*int(FRAME_Y_RADIUS/self.box_width)+1\n",
        "        self.num_cols = 2*int(FRAME_X_RADIUS/self.box_width)+1\n",
        "\n",
        "    def get_grid(self):\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        v_lines = VGroup(*[\n",
        "            v_line.copy().shift(u*x*self.box_width*RIGHT)\n",
        "            for x in range(self.num_cols/2+1)\n",
        "            for u in [-1, 1]\n",
        "        ])\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_lines = VGroup(*[\n",
        "            h_line.copy().shift(u*y*self.box_width*UP)\n",
        "            for y in range(self.num_rows/2+1)\n",
        "            for u in [-1, 1]\n",
        "        ])\n",
        "\n",
        "        grid = VGroup(v_lines, h_lines)\n",
        "        if self.box_width > 0.2:\n",
        "            grid.set_stroke(width = 1)\n",
        "        else:\n",
        "            grid.set_stroke(width = 0.5)\n",
        "        return grid\n",
        "\n",
        "    def get_highlighted_boxes(self, vmobject):\n",
        "        points = []\n",
        "        if vmobject.stroke_width > 0:\n",
        "            for submob in vmobject.family_members_with_points():\n",
        "                alphas = np.linspace(0, 1, self.num_boundary_check_points)\n",
        "                points += [\n",
        "                    submob.point_from_proportion(alpha)\n",
        "                    for alpha in alphas\n",
        "                ]\n",
        "        if vmobject.fill_opacity > 0:\n",
        "            camera = Camera(**LOW_QUALITY_CAMERA_CONFIG)\n",
        "            camera.capture_mobject(vmobject)\n",
        "            box_centers = self.get_box_centers()\n",
        "            pixel_coords = camera.points_to_pixel_coords(box_centers)\n",
        "            for index, (x, y) in enumerate(pixel_coords):\n",
        "                try:\n",
        "                    rgb = camera.pixel_array[y, x]\n",
        "                    if not np.all(rgb == np.zeros(3)):\n",
        "                        points.append(box_centers[index])\n",
        "                except:\n",
        "                    pass\n",
        "        return self.get_boxes(points)\n",
        "\n",
        "    def get_box_centers(self):\n",
        "        bottom_left = reduce(op.add, [\n",
        "            self.box_width*(self.num_cols/2)*LEFT,\n",
        "            self.box_width*(self.num_rows/2)*DOWN,\n",
        "            self.box_width*RIGHT/2,\n",
        "            self.box_width*UP/2,\n",
        "        ])\n",
        "        return np.array([\n",
        "            bottom_left + (x*RIGHT+y*UP)*self.box_width\n",
        "            for x in range(self.num_cols)\n",
        "            for y in range(self.num_rows)\n",
        "        ])\n",
        "\n",
        "    def get_boxes(self, points):\n",
        "        points = np.array(points)\n",
        "        rounded_points = np.floor(points/self.box_width)*self.box_width\n",
        "        unique_rounded_points = np.vstack({\n",
        "            tuple(row) for\n",
        "            row in rounded_points\n",
        "        })\n",
        "\n",
        "        return VGroup(*[\n",
        "            Square(\n",
        "                side_length = self.box_width,\n",
        "                stroke_width = 0,\n",
        "                fill_color = self.box_color,\n",
        "                fill_opacity = self.box_opacity,\n",
        "            ).move_to(point, DOWN+LEFT)\n",
        "            for point in unique_rounded_points\n",
        "        ])\n",
        "\n",
        "    def get_corner_rect(self):\n",
        "        rect = Rectangle(\n",
        "            height = FRAME_Y_RADIUS/2,\n",
        "            width = FRAME_X_RADIUS+self.corner_rect_left_extension,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8\n",
        "        )\n",
        "        rect.to_corner(UP+RIGHT, buff = 0)\n",
        "        return rect\n",
        "\n",
        "    def get_counting_label(self):\n",
        "        label = OldTexText(\"Boxes touched:\")\n",
        "        label.next_to(ORIGIN, RIGHT)\n",
        "        label.to_edge(UP)\n",
        "        label.shift(self.corner_rect_left_extension*LEFT)\n",
        "        self.counting_num_reference = label[-1]\n",
        "        rect = BackgroundRectangle(label)\n",
        "        rect.stretch(1.3, 0)\n",
        "        rect.move_to(label, LEFT)\n",
        "        label.add_to_back(rect)\n",
        "        return label\n",
        "\n",
        "    def count_boxes(self, boxes):\n",
        "        num = DecimalNumber(len(boxes), num_decimal_places = 0)\n",
        "        num.next_to(boxes, RIGHT)\n",
        "        num.add_to_back(BackgroundRectangle(num))\n",
        "\n",
        "        self.play(ShowCreation(boxes, run_time = 3))\n",
        "        self.play(Write(num))\n",
        "        self.play(\n",
        "            num.next_to, self.counting_num_reference, RIGHT, MED_SMALL_BUFF, DOWN,\n",
        "            num.set_color, YELLOW\n",
        "        )\n",
        "        return num\n",
        "\n",
        "class BoxCountingWithDisk(BoxCountingScene):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.25,\n",
        "        \"num_boundary_check_points\" : 200,\n",
        "        \"corner_rect_left_extension\" : 2,\n",
        "        \"disk_opacity\" : 0.5,\n",
        "        \"disk_stroke_width\" : 0.5,\n",
        "        \"decimal_string\" : \"= %.2f\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        disk = Circle(radius = 1)\n",
        "        disk.set_fill(BLUE, opacity = self.disk_opacity)\n",
        "        disk.set_stroke(BLUE, width = self.disk_stroke_width)\n",
        "        disk.shift(0.1*np.sqrt(2)*(UP+RIGHT))\n",
        "\n",
        "        radius = Line(disk.get_center(), disk.get_right())\n",
        "        disk.add(radius)\n",
        "        one = OldTex(\"1\").next_to(radius, DOWN, SMALL_BUFF)\n",
        "\n",
        "        boxes = self.get_highlighted_boxes(disk)\n",
        "        small_box_num = len(boxes)\n",
        "        grid = self.get_grid()\n",
        "        corner_rect = self.get_corner_rect()\n",
        "        counting_label = self.get_counting_label()\n",
        "\n",
        "        prop_words = OldTexText(\"Proportional to\", \"$\\\\pi r^2$\")\n",
        "        prop_words[1].set_color(BLUE)\n",
        "        prop_words.next_to(counting_label, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        self.add(disk, one)\n",
        "        self.play(\n",
        "            ShowCreation(grid),\n",
        "            Animation(disk),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(corner_rect),\n",
        "            FadeIn(counting_label)\n",
        "        )\n",
        "        counting_mob = self.count_boxes(boxes)\n",
        "        self.wait()\n",
        "        self.play(Write(prop_words, run_time = 2))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(prop_words))\n",
        "\n",
        "\n",
        "        disk.generate_target()\n",
        "        disk.target.scale(2, about_point = disk.get_top())\n",
        "        two = OldTex(\"2\").next_to(disk.target[1], DOWN, SMALL_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(disk),\n",
        "            Transform(one, two),\n",
        "            FadeOut(boxes),\n",
        "        )\n",
        "        self.play(counting_mob.next_to, counting_mob, DOWN)\n",
        "        boxes = self.get_highlighted_boxes(disk)\n",
        "        large_box_count = len(boxes)\n",
        "        new_counting_mob = self.count_boxes(boxes)\n",
        "        self.wait()\n",
        "\n",
        "        frac_line = OldTex(\"-\")\n",
        "        frac_line.set_color(YELLOW)\n",
        "        frac_line.stretch_to_fit_width(new_counting_mob.get_width())\n",
        "        frac_line.next_to(new_counting_mob, DOWN, buff = SMALL_BUFF)\n",
        "        decimal = OldTex(self.decimal_string%(float(large_box_count)/small_box_num))\n",
        "        decimal.next_to(frac_line, RIGHT)\n",
        "        approx = OldTex(\"\\\\approx 2^2\")\n",
        "        approx.next_to(decimal, RIGHT, aligned_edge = DOWN)\n",
        "        approx.shift_onto_screen()\n",
        "        self.play(*list(map(Write, [frac_line, decimal])))\n",
        "        self.play(Write(approx))\n",
        "        self.wait()\n",
        "\n",
        "        randy = Randolph().shift(3*RIGHT).to_edge(DOWN)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Is it?\",\n",
        "            target_mode = \"sassy\",\n",
        "            bubble_config = {\"direction\" : LEFT}\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class FinerBoxCountingWithDisk(BoxCountingWithDisk):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.03,\n",
        "        \"num_boundary_check_points\" : 1000,\n",
        "        \"disk_stroke_width\" : 0.5,\n",
        "        \"decimal_string\" : \"= %.2f\",\n",
        "    }\n",
        "\n",
        "class PlotDiskBoxCounting(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"Scaling factor\",\n",
        "        \"y_axis_label\" : \"Number of boxes \\\\\\\\ touched\",\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"x_min\" : 0,\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 30,\n",
        "        \"func\" : lambda x : 0.5*x**2,\n",
        "        \"func_label\" : \"f(x) = cx^2\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.plot_points()\n",
        "        self.describe_better_fit()\n",
        "\n",
        "    def plot_points(self):\n",
        "        self.setup_axes()\n",
        "        self.graph_function(self.func)\n",
        "        self.remove(self.graph)\n",
        "\n",
        "        data_points = [\n",
        "            self.input_to_graph_point(x) + ((random.random()-0.5)/x)*UP\n",
        "            for x in np.arange(2, 10, 0.5)\n",
        "        ]\n",
        "        data_dots = VGroup(*[\n",
        "            Dot(point, radius = 0.05, color = YELLOW)\n",
        "            for point in data_points\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(data_dots))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(self.graph))\n",
        "        self.label_graph(\n",
        "            self.graph,\n",
        "            self.func_label,\n",
        "            direction = RIGHT+DOWN,\n",
        "            buff = SMALL_BUFF,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def describe_better_fit(self):\n",
        "        words = OldTexText(\"Better fit at \\\\\\\\ higher inputs\")\n",
        "        arrow = Arrow(2*LEFT, 2*RIGHT)\n",
        "        arrow.next_to(self.x_axis_label_mob, UP)\n",
        "        arrow.shift(2*LEFT)\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class FineGridSameAsLargeScaling(BoxCountingScene):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.25/6,\n",
        "        \"scale_factor\" : 6\n",
        "    }\n",
        "    def construct(self):\n",
        "        disk = Circle(radius = 1)\n",
        "        disk.set_fill(BLUE, opacity = 0.5)\n",
        "        disk.set_stroke(BLUE, width = 1)\n",
        "\n",
        "        grid = self.get_grid()\n",
        "        grid.scale(self.scale_factor)\n",
        "\n",
        "        self.add(grid, disk)\n",
        "        self.wait()\n",
        "        self.play(disk.scale, self.scale_factor)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            grid.scale, 1./self.scale_factor,\n",
        "            disk.scale, 1./self.scale_factor,\n",
        "            disk.set_stroke, None, 0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        boxes = self.get_highlighted_boxes(disk)\n",
        "        self.play(ShowCreation(boxes, run_time = 3))\n",
        "        self.wait(2)\n",
        "\n",
        "class BoxCountingSierpinski(BoxCountingScene):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.1,\n",
        "        \"sierpinski_order\" : 7,\n",
        "        \"sierpinski_width\" : 3,\n",
        "        \"num_boundary_check_points\" : 6,\n",
        "        \"corner_rect_left_extension\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add(self.get_grid())\n",
        "        sierp = Sierpinski(order = self.sierpinski_order)\n",
        "        sierp.set_fill(opacity = 0)\n",
        "        sierp.move_to(3*DOWN, DOWN+RIGHT)\n",
        "        sierp.set_width(self.sierpinski_width)\n",
        "        boxes = self.get_highlighted_boxes(sierp)\n",
        "\n",
        "        corner_rect = self.get_corner_rect()\n",
        "        counting_label = self.get_counting_label()\n",
        "\n",
        "        self.play(ShowCreation(sierp))\n",
        "        self.play(*list(map(FadeIn, [corner_rect, counting_label])))\n",
        "        self.wait()\n",
        "        counting_mob = self.count_boxes(boxes)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(boxes),\n",
        "            sierp.scale, 2, sierp.get_corner(DOWN+RIGHT),\n",
        "        )\n",
        "        self.play(counting_mob.next_to, counting_mob, DOWN)\n",
        "        boxes = self.get_highlighted_boxes(sierp)\n",
        "        new_counting_mob = self.count_boxes(boxes)\n",
        "        self.wait()\n",
        "\n",
        "        frac_line = OldTex(\"-\")\n",
        "        frac_line.set_color(YELLOW)\n",
        "        frac_line.stretch_to_fit_width(new_counting_mob.get_width())\n",
        "        frac_line.next_to(new_counting_mob, DOWN, buff = SMALL_BUFF)\n",
        "        approx_three = OldTex(\"\\\\approx 3\")\n",
        "        approx_three.next_to(frac_line, RIGHT)\n",
        "        equals_exp = OldTex(\"= 2^{1.585...}\")\n",
        "        equals_exp.next_to(approx_three, RIGHT, aligned_edge = DOWN)\n",
        "        equals_exp.shift_onto_screen()\n",
        "\n",
        "        self.play(*list(map(Write, [frac_line, approx_three])))\n",
        "        self.wait()\n",
        "        self.play(Write(equals_exp))\n",
        "        self.wait()\n",
        "\n",
        "class PlotSierpinskiBoxCounting(PlotDiskBoxCounting):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda x : 0.5*x**1.585,\n",
        "        \"func_label\" : \"f(x) = cx^{1.585}\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.plot_points()\n",
        "\n",
        "class BoxCountingWithBritain(BoxCountingScene):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.1,\n",
        "        \"num_boundary_check_points\" : 5000,\n",
        "        \"corner_rect_left_extension\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_box_counting()\n",
        "        self.show_formula()\n",
        "\n",
        "    def show_box_counting(self):\n",
        "        self.add(self.get_grid())\n",
        "        britain = Britain(\n",
        "            stroke_width = 2,\n",
        "            fill_opacity = 0\n",
        "        )\n",
        "        britain = fractalify(britain, order = 1, dimension = 1.21)\n",
        "        britain.shift(DOWN+LEFT)\n",
        "        boxes = self.get_highlighted_boxes(britain)\n",
        "\n",
        "        self.play(ShowCreation(britain, run_time = 3))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(boxes, run_time = 3))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(boxes))\n",
        "        self.play(britain.scale, 2.5, britain.get_corner(DOWN+RIGHT))\n",
        "        boxes = self.get_highlighted_boxes(britain)\n",
        "        self.play(ShowCreation(boxes, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def show_formula(self):\n",
        "        corner_rect = self.get_corner_rect()\n",
        "        equation = OldTexText(\"\"\"\n",
        "            Number of boxes $\\\\approx$\n",
        "            \\\\quad $c(\\\\text{scaling factor})^{1.21}$\n",
        "        \"\"\")\n",
        "        equation.next_to(\n",
        "            corner_rect.get_corner(UP+LEFT), DOWN+RIGHT\n",
        "        )\n",
        "\n",
        "        N = equation[0].copy()\n",
        "        word_len = len(\"Numberofboxes\")\n",
        "        approx = equation[word_len].copy()\n",
        "        c = equation[word_len+1].copy()\n",
        "        s = equation[word_len+3].copy()\n",
        "        dim = VGroup(*equation[-len(\"1.21\"):]).copy()\n",
        "\n",
        "        N.set_color(YELLOW)\n",
        "        s.set_color(BLUE)\n",
        "        dim.set_color(GREEN)\n",
        "\n",
        "        simpler_eq = VGroup(N, approx, c, s, dim)\n",
        "        simpler_eq.generate_target()\n",
        "        simpler_eq.target.arrange(buff = SMALL_BUFF)\n",
        "        simpler_eq.target.move_to(N, LEFT)\n",
        "        simpler_eq.target[-1].next_to(\n",
        "            simpler_eq.target[-2].get_corner(UP+RIGHT),\n",
        "            RIGHT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(corner_rect),\n",
        "            Write(equation)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(simpler_eq))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(equation),\n",
        "            Animation(simpler_eq)\n",
        "        )\n",
        "        self.play(MoveToTarget(simpler_eq))\n",
        "        self.wait(2)\n",
        "\n",
        "        log_expression1 = OldTex(\n",
        "            \"\\\\log(\", \"N\", \")\", \"=\",\n",
        "            \"\\\\log(\", \"c\", \"s\", \"^{1.21}\", \")\"\n",
        "        )\n",
        "        log_expression2 = OldTex(\n",
        "            \"\\\\log(\", \"N\", \")\", \"=\",\n",
        "            \"\\\\log(\", \"c\", \")\", \"+\",\n",
        "            \"1.21\", \"\\\\log(\", \"s\", \")\"\n",
        "        )\n",
        "        for log_expression in log_expression1, log_expression2:\n",
        "            log_expression.next_to(simpler_eq, DOWN, aligned_edge = LEFT)\n",
        "            log_expression.set_color_by_tex(\"N\", N.get_color())\n",
        "            log_expression.set_color_by_tex(\"s\", s.get_color())\n",
        "            log_expression.set_color_by_tex(\"^{1.21}\", dim.get_color())\n",
        "            log_expression.set_color_by_tex(\"1.21\", dim.get_color())\n",
        "        rewired_log_expression1 = VGroup(*[\n",
        "            log_expression1[index].copy()\n",
        "            for index in [\n",
        "                0, 1, 2, 3, #match with log_expression2\n",
        "                4, 5, 8, 8,\n",
        "                7, 4, 6, 8\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        self.play(Write(log_expression1))\n",
        "        self.remove(log_expression1)\n",
        "        self.add(rewired_log_expression1)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            rewired_log_expression1,\n",
        "            log_expression2,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.final_expression = VGroup(\n",
        "            simpler_eq, rewired_log_expression1\n",
        "        )\n",
        "\n",
        "class GiveShapeAndPonder(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        randy = Randolph()\n",
        "        morty.next_to(ORIGIN, DOWN).shift(3*RIGHT)\n",
        "        randy.next_to(ORIGIN, DOWN).shift(3*LEFT)\n",
        "\n",
        "        norway = Norway(fill_opacity = 0, stroke_width = 1)\n",
        "        norway.set_width(2)\n",
        "        norway.next_to(morty, UP+LEFT, buff = -MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, norway,\n",
        "            randy.look_at, norway,\n",
        "            ShowCreation(norway)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class CheapBoxCountingWithBritain(BoxCountingWithBritain):\n",
        "    CONFIG = {\n",
        "        \"skip_animations\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_formula()\n",
        "\n",
        "class ConfusedAtParabolicData(PlotDiskBoxCounting):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda x : 0.5*x**1.6,\n",
        "        \"func_label\" : \"f(x) = cx^{1.21}\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.plot_points()\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.shift(RIGHT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change_mode, \"confused\")\n",
        "        self.play(randy.look_at, self.x_axis_label_mob)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceLogLogPlot(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"\\\\log(s)\",\n",
        "        \"y_axis_label\" : \"\\\\log(N)\",\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"graph_origin\" : 2.5*DOWN+6*LEFT,\n",
        "        \"dimension\" : 1.21,\n",
        "        \"y_intercept\" : 2,\n",
        "        \"x_max\" : 16,\n",
        "    }\n",
        "    def construct(self):\n",
        "        last_scene = CheapBoxCountingWithBritain()\n",
        "        expression = last_scene.final_expression\n",
        "        box = Rectangle(\n",
        "            stroke_color = WHITE,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.7,\n",
        "        )\n",
        "        box.replace(expression, stretch = True)\n",
        "        box.scale(1.2)\n",
        "        expression.add_to_back(box)\n",
        "        self.add(expression)\n",
        "\n",
        "        self.setup_axes(animate = False)\n",
        "        self.x_axis_label_mob[-2].set_color(BLUE)\n",
        "        self.y_axis_label_mob[-2].set_color(YELLOW)\n",
        "        graph = self.graph_function(\n",
        "            lambda x : self.y_intercept+self.dimension*x\n",
        "        )\n",
        "        self.remove(graph)\n",
        "        p1 = self.input_to_graph_point(2)\n",
        "        p2 = self.input_to_graph_point(3)\n",
        "        interim_point = p2[0]*RIGHT + p1[1]*UP\n",
        "        h_line = Line(p1, interim_point)\n",
        "        v_line = Line(interim_point, p2)\n",
        "        slope_lines = VGroup(h_line, v_line)\n",
        "        slope_lines.set_color(GREEN)\n",
        "\n",
        "        slope = OldTexText(\"Slope = \", \"$%.2f$\"%self.dimension)\n",
        "        slope[-1].set_color(GREEN)\n",
        "        slope.next_to(slope_lines, RIGHT)\n",
        "\n",
        "        self.wait()\n",
        "        data_points = [\n",
        "            self.input_to_graph_point(x) + ((random.random()-0.5)/x)*UP\n",
        "            for x in np.arange(1, 8, 0.7)\n",
        "        ]\n",
        "        data_dots = VGroup(*[\n",
        "            Dot(point, radius = 0.05, color = YELLOW)\n",
        "            for point in data_points\n",
        "        ])\n",
        "        self.play(ShowCreation(data_dots, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Animation(expression)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(slope_lines))\n",
        "        self.play(Write(slope))\n",
        "        self.wait()\n",
        "\n",
        "class ManyBritainCounts(BoxCountingWithBritain):\n",
        "    CONFIG = {\n",
        "        \"box_width\" : 0.1,\n",
        "        \"num_boundary_check_points\" : 10000,\n",
        "        \"corner_rect_left_extension\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        britain = Britain(\n",
        "            stroke_width = 2,\n",
        "            fill_opacity = 0\n",
        "        )\n",
        "        britain = fractalify(britain, order = 1, dimension = 1.21)\n",
        "        britain.next_to(ORIGIN, LEFT)\n",
        "        self.add(self.get_grid())\n",
        "        self.add(britain)\n",
        "\n",
        "        for x in range(5):\n",
        "            self.play(britain.scale, 2, britain.point_from_proportion(0.8))\n",
        "            boxes = self.get_highlighted_boxes(britain)\n",
        "            self.play(ShowCreation(boxes))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(boxes))\n",
        "\n",
        "class ReadyForRealDefinition(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Now for what\n",
        "            fractals really are.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class DefineFractal(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Fractals are shapes\n",
        "            with a non-integer dimension.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\"thinking\", \"happy\", \"erm\")\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"Kind of...\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look, DOWN)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "class RoughnessAndFractionalDimension(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"Non-integer dimension $\\\\Leftrightarrow$ Roughness\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        randy = Randolph().scale(2)\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "        self.add(randy)\n",
        "\n",
        "        target = randy.copy()\n",
        "        target.change_mode(\"hooray\")\n",
        "        ponder_target = randy.copy()\n",
        "        ponder_target.change_mode(\"pondering\")\n",
        "        for mob in target, ponder_target:\n",
        "            fractalify(mob, order = 2)\n",
        "\n",
        "        dimension_label = OldTexText(\"Boundary dimension = \", \"1\")\n",
        "        dimension_label.to_edge(LEFT)\n",
        "        one = dimension_label[1]\n",
        "        one.set_color(BLUE)\n",
        "        new_dim = OldTex(\"1.2\")\n",
        "        new_dim.move_to(one, DOWN+LEFT)\n",
        "        new_dim.set_color(one.get_color())\n",
        "        self.add(dimension_label)\n",
        "\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            Transform(randy, target, run_time = 2),\n",
        "            Transform(one, new_dim)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look, DOWN+RIGHT)\n",
        "        self.wait()\n",
        "        self.play(randy.look, DOWN+LEFT)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(Transform(randy, ponder_target))\n",
        "        self.wait()\n",
        "\n",
        "class DifferentSlopesAtDifferentScales(IntroduceLogLogPlot):\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.x_axis_label_mob[-2].set_color(BLUE)\n",
        "        self.y_axis_label_mob[-2].set_color(YELLOW)\n",
        "        self.graph_function(\n",
        "            lambda x : 0.01*(x-5)**3 + 0.3*x + 3\n",
        "        )\n",
        "        self.remove(self.graph)\n",
        "\n",
        "        words = OldTexText(\"\"\"\n",
        "            Different slopes\n",
        "            at different scales\n",
        "        \"\"\")\n",
        "        words.to_edge(RIGHT)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(words.get_left(), self.input_to_graph_point(x))\n",
        "            for x in (1, 7, 12)\n",
        "        ])\n",
        "\n",
        "\n",
        "        data_points = [\n",
        "            self.input_to_graph_point(x) + (0.3*(random.random()-0.5))*UP\n",
        "            for x in np.arange(1, self.x_max, 0.7)\n",
        "        ]\n",
        "        data_dots = VGroup(*[\n",
        "            Dot(point, radius = 0.05, color = YELLOW)\n",
        "            for point in data_points\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(data_dots, run_time = 2))\n",
        "        self.play(ShowCreation(self.graph))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class HoldUpCoilExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        point = UP+RIGHT\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "            self.get_teacher().look_at, point\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look_at, point)\n",
        "            for pi in self.get_students()\n",
        "        ])\n",
        "        self.wait(5)\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look_at, point)\n",
        "            for pi in self.get_students()\n",
        "        ])\n",
        "        self.wait(5)\n",
        "\n",
        "class SmoothHilbertZoom(Scene):\n",
        "    def construct(self):\n",
        "        hilbert = HilbertCurve(\n",
        "            order = 7,\n",
        "            color = MAROON_B,\n",
        "            monochromatic = True\n",
        "        )\n",
        "        hilbert.make_smooth()\n",
        "        self.add(hilbert)\n",
        "\n",
        "        two_d_title = OldTexText(\"2D at a distance...\")\n",
        "        one_d_title = OldTexText(\"1D up close\")\n",
        "        for title in two_d_title, one_d_title:\n",
        "            title.to_edge(UP)\n",
        "\n",
        "        self.add(two_d_title)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                hilbert.scale, 100,\n",
        "                hilbert.point_from_proportion(0.3),\n",
        "            ),\n",
        "            Transform(\n",
        "                two_d_title, one_d_title,\n",
        "                rate_func = squish_rate_func(smooth)\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ListDimensionTypes(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"use_morty\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        types = VGroup(*list(map(TexText, [\n",
        "            \"Box counting dimension\",\n",
        "            \"Information dimension\",\n",
        "            \"Hausdorff dimension\",\n",
        "            \"Packing dimension\"\n",
        "        ])))\n",
        "        types.arrange(DOWN, aligned_edge = LEFT)\n",
        "        for text in types:\n",
        "            self.play(\n",
        "                Write(text, run_time = 1),\n",
        "                self.pi_creature.change_mode, \"pondering\"\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "class ZoomInOnBritain(Scene):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\" : 1000\n",
        "    }\n",
        "    def construct(self):\n",
        "        britain = Britain()\n",
        "        fractalify(britain, order = 3, dimension = 1.21)\n",
        "        anchors = britain.get_anchors()\n",
        "\n",
        "        key_value = int(0.3*len(anchors))\n",
        "        point = anchors[key_value]\n",
        "        thinning_factor = 100\n",
        "        num_neighbors_kept = 1000\n",
        "\n",
        "        britain.set_points_as_corners(reduce(\n",
        "            lambda a1, a2 : np.append(a1, a2, axis = 0),\n",
        "            [\n",
        "            anchors[:key_value-num_neighbors_kept:thinning_factor,:],\n",
        "            anchors[key_value-num_neighbors_kept:key_value+num_neighbors_kept,:],\n",
        "            anchors[key_value+num_neighbors_kept::thinning_factor,:],\n",
        "            ]\n",
        "        ))\n",
        "\n",
        "        self.add(britain)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            britain.scale, self.zoom_factor, point,\n",
        "            run_time = 10\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class NoteTheConstantSlope(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Note the \\\\\\\\ constant slope\")\n",
        "        words.set_color(YELLOW)\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class FromHandwavyToQuantitative(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        morty = Mortimer()\n",
        "        for pi in randy, morty:\n",
        "            pi.next_to(ORIGIN, DOWN)\n",
        "        randy.shift(2*LEFT)\n",
        "        morty.shift(2*RIGHT)\n",
        "        randy.make_eye_contact(morty)\n",
        "\n",
        "        self.add(randy, morty)\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Fractals are rough\",\n",
        "            target_mode = \"shruggie\"\n",
        "        ))\n",
        "        self.play(morty.change_mode, \"sassy\")\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                morty, \"We can make \\\\\\\\ that quantitative!\",\n",
        "                target_mode = \"hooray\"\n",
        "            ),\n",
        "            FadeOut(randy.bubble),\n",
        "            FadeOut(randy.bubble.content),\n",
        "            randy.change_mode, \"happy\"\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class WhatSlopeDoesLogLogPlotApproach(IntroduceLogLogPlot):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"What slope does \\\\\\\\ this approach?\",\n",
        "        \"x_max\" : 20,\n",
        "        \"y_max\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.x_axis_label_mob[-2].set_color(BLUE)\n",
        "        self.y_axis_label_mob[-2].set_color(YELLOW)\n",
        "\n",
        "        spacing = 0.5\n",
        "        x_range = np.arange(1, self.x_max, spacing)\n",
        "        randomness = [\n",
        "            0.5*np.exp(-x/2)+spacing*(0.8 + random.random()/(x**(0.5)))\n",
        "            for x in x_range\n",
        "        ]\n",
        "        cum_sums = np.cumsum(randomness)\n",
        "        data_points = [\n",
        "            self.coords_to_point(x, cum_sum)\n",
        "            for x, cum_sum in zip(x_range, cum_sums)\n",
        "        ]\n",
        "        data_dots = VGroup(*[\n",
        "            Dot(point, radius = 0.025, color = YELLOW)\n",
        "            for point in data_points\n",
        "        ])\n",
        "\n",
        "        words = OldTexText(self.words)\n",
        "        p1, p2 = [\n",
        "            data_dots[int(alpha*len(data_dots))].get_center()\n",
        "            for alpha in (0.3, 0.5)\n",
        "        ]\n",
        "        words.rotate(Line(p1, p2).get_angle())\n",
        "        words.next_to(p1, RIGHT, aligned_edge = DOWN, buff = 1.5)\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        self.add(morty)\n",
        "\n",
        "        self.play(ShowCreation(data_dots, run_time = 7))\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            morty.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class BritainBoxCountHighZoom(BoxCountingWithBritain):\n",
        "    def construct(self):\n",
        "        britain = Britain(\n",
        "            stroke_width = 2,\n",
        "            fill_opacity = 0\n",
        "        )\n",
        "        britain = fractalify(britain, order = 2, dimension = 1.21)\n",
        "        self.add(self.get_grid())\n",
        "        self.add(britain)\n",
        "\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                britain.scale, 10, britain.point_from_proportion(0.3),\n",
        "                run_time = 2\n",
        "            )\n",
        "            if x == 0:\n",
        "                a, b = 0.2, 0.5\n",
        "            else:\n",
        "                a, b = 0.25, 0.35\n",
        "            britain.pointwise_become_partial(britain, a, b)\n",
        "            self.count_britain(britain)\n",
        "            self.wait()\n",
        "\n",
        "    def count_britain(self, britain):\n",
        "        boxes = self.get_highlighted_boxes(britain)\n",
        "        self.play(ShowCreation(boxes))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(boxes))\n",
        "\n",
        "class IfBritainWasEventuallySmooth(Scene):\n",
        "    def construct(self):\n",
        "        britain = Britain()\n",
        "        britain.make_smooth()\n",
        "        point = britain.point_from_proportion(0.3)\n",
        "\n",
        "        self.add(britain)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            britain.scale, 200, point,\n",
        "            run_time = 10\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SmoothBritainLogLogPlot(IntroduceLogLogPlot):\n",
        "    CONFIG = {\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.graph_function(\n",
        "            lambda x : (1 + np.exp(-x/5.0))*x\n",
        "        )\n",
        "        self.remove(self.graph)\n",
        "\n",
        "        p1, p2, p3, p4 = [\n",
        "            self.input_to_graph_point(x)\n",
        "            for x in (1, 2, 7, 8)\n",
        "        ]\n",
        "        interim_point1 = p2[0]*RIGHT + p1[1]*UP\n",
        "        interim_point2 = p4[0]*RIGHT + p3[1]*UP\n",
        "\n",
        "        print(self.func(2))\n",
        "\n",
        "        slope_lines1, slope_lines2 = VMobject(), VMobject()\n",
        "        slope_lines1.set_points_as_corners(\n",
        "            [p1, interim_point1, p2]\n",
        "        )\n",
        "        slope_lines2.set_points_as_corners(\n",
        "            [p3, interim_point2, p4]\n",
        "        )\n",
        "        slope_lines_group = VGroup(slope_lines1, slope_lines2)\n",
        "        slope_lines_group.set_color(GREEN)\n",
        "\n",
        "        slope_label1 = OldTexText(\"Slope $> 1$\")\n",
        "        slope_label2 = OldTexText(\"Slope $= 1$\")\n",
        "        slope_label1.next_to(slope_lines1)\n",
        "        slope_label2.next_to(slope_lines2)\n",
        "\n",
        "        data_points = [\n",
        "            self.input_to_graph_point(x) + ((random.random()-0.5)/x)*UP\n",
        "            for x in np.arange(1, 12, 0.7)\n",
        "        ]\n",
        "        data_dots = VGroup(*[\n",
        "            Dot(point, radius = 0.05, color = YELLOW)\n",
        "            for point in data_points\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(data_dots, run_time = 3))\n",
        "        self.play(ShowCreation(self.graph))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(slope_lines1),\n",
        "            Write(slope_label1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(slope_lines2),\n",
        "            Write(slope_label2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SlopeAlwaysAboveOne(WhatSlopeDoesLogLogPlotApproach):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"Slope always $> 1$\",\n",
        "        \"x_max\" : 20,\n",
        "    }\n",
        "\n",
        "class ChangeWorldview(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            This changes how\n",
        "            you see the world.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class CompareBritainAndNorway(Scene):\n",
        "    def construct(self):\n",
        "        norway = Norway(\n",
        "            fill_opacity = 0,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "        norway.to_corner(UP+RIGHT, buff = 0)\n",
        "        fractalify(norway, order = 1, dimension = 1.5)\n",
        "        anchors = list(norway.get_anchors())\n",
        "        anchors.append(FRAME_X_RADIUS*RIGHT+FRAME_Y_RADIUS*UP)\n",
        "        norway.set_points_as_corners(anchors)\n",
        "\n",
        "        britain = Britain(\n",
        "            fill_opacity = 0,\n",
        "            stroke_width = 2\n",
        "        )\n",
        "        britain.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        britain.to_edge(UP)\n",
        "        fractalify(britain, order = 1, dimension = 1.21)\n",
        "\n",
        "        britain_label = OldTexText(\"\"\"\n",
        "            Britain coast:\n",
        "            1.21-dimensional\n",
        "        \"\"\")\n",
        "        norway_label = OldTexText(\"\"\"\n",
        "            Norway coast:\n",
        "            1.52-dimensional\n",
        "        \"\"\")\n",
        "        britain_label.next_to(britain, DOWN)\n",
        "        norway_label.next_to(britain_label, RIGHT, aligned_edge = DOWN)\n",
        "        norway_label.to_edge(RIGHT)\n",
        "\n",
        "        self.add(britain_label, norway_label)\n",
        "        self.play(\n",
        "            *list(map(ShowCreation, [norway, britain])),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*it.chain(*[\n",
        "            [\n",
        "                mob.set_stroke, None, 0,\n",
        "                mob.set_fill, BLUE, 1\n",
        "            ]\n",
        "            for mob in (britain, norway)\n",
        "        ]))\n",
        "        self.wait(2)\n",
        "\n",
        "class CompareOceansLabels(Scene):\n",
        "    def construct(self):\n",
        "        label1 = OldTexText(\"Dimension $\\\\approx 2.05$\")\n",
        "        label2 = OldTexText(\"Dimension $\\\\approx 2.3$\")\n",
        "\n",
        "        label1.shift(FRAME_X_RADIUS*LEFT/2).to_edge(UP)\n",
        "        label2.shift(FRAME_X_RADIUS*RIGHT/2).to_edge(UP)\n",
        "\n",
        "        self.play(Write(label1))\n",
        "        self.wait()\n",
        "        self.play(Write(label2))\n",
        "        self.wait()\n",
        "\n",
        "class CompareOceans(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class FractalNonFractalFlowChart(Scene):\n",
        "    def construct(self):\n",
        "        is_fractal = OldTexText(\"Is it a \\\\\\\\ fractal?\")\n",
        "        nature = OldTexText(\"Probably from \\\\\\\\ nature\")\n",
        "        man_made = OldTexText(\"Probably \\\\\\\\ man-made\")\n",
        "\n",
        "        is_fractal.to_edge(UP)\n",
        "        nature.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        man_made.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "\n",
        "        yes_arrow = Arrow(\n",
        "            is_fractal.get_bottom(),\n",
        "            nature.get_top()\n",
        "        )\n",
        "        no_arrow = Arrow(\n",
        "            is_fractal.get_bottom(),\n",
        "            man_made.get_top()\n",
        "        )\n",
        "\n",
        "        yes = OldTexText(\"Yes\")\n",
        "        no = OldTexText(\"No\")\n",
        "        yes.set_color(GREEN)\n",
        "        no.set_color(RED)\n",
        "\n",
        "        for word, arrow in (yes, yes_arrow), (no, no_arrow):\n",
        "            word.next_to(ORIGIN, UP)\n",
        "            word.rotate(arrow.get_angle())\n",
        "            if word is yes:\n",
        "                word.rotate(np.pi)\n",
        "            word.shift(arrow.get_center())\n",
        "\n",
        "        britain = Britain()\n",
        "        britain.set_height(3)\n",
        "        britain.to_corner(UP+LEFT)\n",
        "        self.add(britain)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.set_height(3)\n",
        "        randy.to_corner(UP+RIGHT)\n",
        "        self.add(randy)\n",
        "\n",
        "        self.add(is_fractal)\n",
        "        self.wait()\n",
        "        for word, arrow, answer in (yes, yes_arrow, nature), (no, no_arrow, man_made):\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                Write(word, run_time = 1)\n",
        "            )\n",
        "            self.play(Write(answer, run_time = 1))\n",
        "            if word is yes:\n",
        "                self.wait()\n",
        "            else:\n",
        "                self.play(Blink(randy))\n",
        "\n",
        "class ShowPiCreatureFractalCreation(FractalCreation):\n",
        "    CONFIG = {\n",
        "        \"fractal_class\" : PentagonalPiCreatureFractal,\n",
        "        \"max_order\" : 4,\n",
        "    }\n",
        "\n",
        "class FractalPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Batiz-Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Vecht   \",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class AffirmLogo(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"fill_color\" : \"#0FA0EA\",\n",
        "        \"fill_opacity\" : 1,\n",
        "        \"stroke_color\" : \"#0FA0EA\",\n",
        "        \"stroke_width\" : 0,\n",
        "        \"file_name\" : \"affirm_logo\",\n",
        "        \"width\" : 3,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.set_width(self.width)\n",
        "\n",
        "class MortyLookingAtRectangle(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        url = OldTexText(\"affirmjobs.3b1b.co\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.shift_onto_screen()\n",
        "        url.save_state()\n",
        "        url.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "\n",
        "        affirm_logo = AffirmLogo()[0]\n",
        "        affirm_logo.to_corner(UP+RIGHT, buff = MED_LARGE_BUFF)\n",
        "        affirm_logo.shift(0.5*DOWN)\n",
        "\n",
        "        self.add(morty)\n",
        "        affirm_logo.save_state()\n",
        "        affirm_logo.shift(DOWN)\n",
        "        affirm_logo.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            ApplyMethod(affirm_logo.restore, run_time = 2),\n",
        "            morty.look_at, affirm_logo,\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, url,\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            url.restore,\n",
        "            morty.change_mode, \"happy\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        for mode in [\"wave_2\", \"hooray\", \"happy\", \"pondering\", \"happy\"]:\n",
        "            self.play(morty.change_mode, mode)\n",
        "            self.wait(2)\n",
        "            self.play(Blink(morty))\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"1.5-dimensional\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "\n",
        "        koch_curve = QuadraticKoch(order = 6, monochromatic = True)\n",
        "        koch_curve.set_stroke(width = 0)\n",
        "        koch_curve.set_fill(BLUE)\n",
        "        koch_curve.set_height(1.5*FRAME_Y_RADIUS)\n",
        "        koch_curve.to_edge(DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        self.add(koch_curve, title)\n"
    ]
}