{
    "topic": "demonstrates the concept of temperature distribution in a 3D space. The animation shows how",
    "code": [
        "from scipy import integrate\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part2.heat_equation import *\n",
        "\n",
        "\n",
        "class TemperatureGraphScene(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": TAU,\n",
        "            \"y_min\": 0,\n",
        "            \"y_max\": 10,\n",
        "            \"z_min\": -3,\n",
        "            \"z_max\": 3,\n",
        "            \"x_axis_config\": {\n",
        "                \"tick_frequency\": TAU / 8,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            \"num_axis_pieces\": 1,\n",
        "        },\n",
        "        \"default_graph_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"background_image_file\": \"VerticalTempGradient\",\n",
        "        },\n",
        "        \"default_surface_config\": {\n",
        "            \"fill_opacity\": 0.1,\n",
        "            \"checkerboard_colors\": [GREY_B],\n",
        "            \"stroke_width\": 0.5,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "        },\n",
        "        \"temp_text\": \"Temperature\",\n",
        "    }\n",
        "\n",
        "    def get_three_d_axes(self, include_labels=True, include_numbers=False, **kwargs):\n",
        "        config = dict(self.axes_config)\n",
        "        config.update(kwargs)\n",
        "        axes = ThreeDAxes(**config)\n",
        "        axes.set_stroke(width=2)\n",
        "\n",
        "        if include_numbers:\n",
        "            self.add_axes_numbers(axes)\n",
        "\n",
        "        if include_labels:\n",
        "            self.add_axes_labels(axes)\n",
        "\n",
        "        # Adjust axis orientation\n",
        "        axes.x_axis.rotate(\n",
        "            90 * DEGREES, RIGHT,\n",
        "            about_point=axes.c2p(0, 0, 0),\n",
        "        )\n",
        "        axes.y_axis.rotate(\n",
        "            90 * DEGREES, UP,\n",
        "            about_point=axes.c2p(0, 0, 0),\n",
        "        )\n",
        "\n",
        "        # Add xy-plane\n",
        "        input_plane = self.get_surface(\n",
        "            axes, lambda x, t: 0\n",
        "        )\n",
        "        input_plane.set_style(\n",
        "            fill_opacity=0.5,\n",
        "            fill_color=BLUE_B,\n",
        "            stroke_width=0.5,\n",
        "            stroke_color=WHITE,\n",
        "        )\n",
        "\n",
        "        axes.input_plane = input_plane\n",
        "\n",
        "        return axes\n",
        "\n",
        "    def add_axes_numbers(self, axes):\n",
        "        x_axis = axes.x_axis\n",
        "        y_axis = axes.y_axis\n",
        "        tex_vals = [\n",
        "            (\"\\\\pi \\\\over 2\", TAU / 4),\n",
        "            (\"\\\\pi\", TAU / 2),\n",
        "            (\"3\\\\pi \\\\over 2\", 3 * TAU / 4),\n",
        "            (\"2\\\\pi\", TAU)\n",
        "        ]\n",
        "        x_labels = VGroup()\n",
        "        for tex, val in tex_vals:\n",
        "            label = OldTex(tex)\n",
        "            label.scale(0.5)\n",
        "            label.next_to(x_axis.n2p(val), DOWN)\n",
        "            x_labels.add(label)\n",
        "        x_axis.add(x_labels)\n",
        "        x_axis.numbers = x_labels\n",
        "\n",
        "        y_axis.add_numbers()\n",
        "        for number in y_axis.numbers:\n",
        "            number.rotate(90 * DEGREES)\n",
        "        return axes\n",
        "\n",
        "    def add_axes_labels(self, axes):\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label.next_to(axes.x_axis.get_end(), RIGHT)\n",
        "        axes.x_axis.label = x_label\n",
        "\n",
        "        t_label = OldTexText(\"Time\")\n",
        "        t_label.rotate(90 * DEGREES, OUT)\n",
        "        t_label.next_to(axes.y_axis.get_end(), UP)\n",
        "        axes.y_axis.label = t_label\n",
        "\n",
        "        temp_label = OldTexText(self.temp_text)\n",
        "        temp_label.rotate(90 * DEGREES, RIGHT)\n",
        "        temp_label.next_to(axes.z_axis.get_zenith(), RIGHT)\n",
        "        axes.z_axis.label = temp_label\n",
        "        for axis in axes:\n",
        "            axis.add(axis.label)\n",
        "        return axes\n",
        "\n",
        "    def get_time_slice_graph(self, axes, func, t, **kwargs):\n",
        "        config = dict()\n",
        "        config.update(self.default_graph_style)\n",
        "        config.update({\n",
        "            \"t_min\": axes.x_min,\n",
        "            \"t_max\": axes.x_max,\n",
        "        })\n",
        "        config.update(kwargs)\n",
        "        return ParametricCurve(\n",
        "            lambda x: axes.c2p(\n",
        "                x, t, func(x, t)\n",
        "            ),\n",
        "            **config,\n",
        "        )\n",
        "\n",
        "    def get_initial_state_graph(self, axes, func, **kwargs):\n",
        "        return self.get_time_slice_graph(\n",
        "            axes,\n",
        "            lambda x, t: func(x),\n",
        "            t=0,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_surface(self, axes, func, **kwargs):\n",
        "        config = {\n",
        "            \"u_min\": axes.y_min,\n",
        "            \"u_max\": axes.y_max,\n",
        "            \"v_min\": axes.x_min,\n",
        "            \"v_max\": axes.x_max,\n",
        "            \"resolution\": (\n",
        "                (axes.y_max - axes.y_min) // axes.y_axis.tick_frequency,\n",
        "                (axes.x_max - axes.x_min) // axes.x_axis.tick_frequency,\n",
        "            ),\n",
        "        }\n",
        "        config.update(self.default_surface_config)\n",
        "        config.update(kwargs)\n",
        "        return ParametricSurface(\n",
        "            lambda t, x: axes.c2p(\n",
        "                x, t, func(x, t)\n",
        "            ),\n",
        "            **config\n",
        "        )\n",
        "\n",
        "    def orient_three_d_mobject(self, mobject,\n",
        "                               phi=85 * DEGREES,\n",
        "                               theta=-80 * DEGREES):\n",
        "        mobject.rotate(-90 * DEGREES - theta, OUT)\n",
        "        mobject.rotate(phi, LEFT)\n",
        "        return mobject\n",
        "\n",
        "    def get_rod_length(self):\n",
        "        return self.axes_config[\"x_max\"]\n",
        "\n",
        "    def get_const_time_plane(self, axes):\n",
        "        t_tracker = ValueTracker(0)\n",
        "        plane = Polygon(\n",
        "            *[\n",
        "                axes.c2p(x, 0, z)\n",
        "                for x, z in [\n",
        "                    (axes.x_min, axes.z_min),\n",
        "                    (axes.x_max, axes.z_min),\n",
        "                    (axes.x_max, axes.z_max),\n",
        "                    (axes.x_min, axes.z_max),\n",
        "                ]\n",
        "            ],\n",
        "            stroke_width=0,\n",
        "            fill_color=WHITE,\n",
        "            fill_opacity=0.2\n",
        "        )\n",
        "        plane.add_updater(lambda m: m.shift(\n",
        "            axes.c2p(\n",
        "                axes.x_min,\n",
        "                t_tracker.get_value(),\n",
        "                axes.z_min,\n",
        "            ) - plane.get_points()[0]\n",
        "        ))\n",
        "        plane.t_tracker = t_tracker\n",
        "        return plane\n",
        "\n",
        "\n",
        "class SimpleCosExpGraph(TemperatureGraphScene):\n",
        "    def construct(self):\n",
        "        axes = self.get_three_d_axes()\n",
        "        cos_graph = self.get_cos_graph(axes)\n",
        "        cos_exp_surface = self.get_cos_exp_surface(axes)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "        )\n",
        "        self.camera.frame_center.shift(3 * RIGHT)\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(cos_graph))\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            cos_exp_surface,\n",
        "            lambda m, a: m.become(\n",
        "                self.get_cos_exp_surface(axes, v_max=a * 10)\n",
        "            ),\n",
        "            run_time=3\n",
        "        ))\n",
        "\n",
        "        self.add(cos_graph.copy())\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        cos_graph.add_updater(\n",
        "            lambda m: m.become(self.get_time_slice_graph(\n",
        "                axes,\n",
        "                lambda x: self.cos_exp(x, get_t()),\n",
        "                t=get_t()\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        plane = Rectangle(\n",
        "            stroke_width=0,\n",
        "            fill_color=WHITE,\n",
        "            fill_opacity=0.1,\n",
        "        )\n",
        "        plane.rotate(90 * DEGREES, RIGHT)\n",
        "        plane.match_width(axes.x_axis)\n",
        "        plane.match_depth(axes.z_axis, stretch=True)\n",
        "        plane.move_to(axes.c2p(0, 0, 0), LEFT)\n",
        "\n",
        "        self.add(plane, cos_graph)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                t_tracker.set_value, 10,\n",
        "                run_time=10,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                plane.shift, 10 * UP,\n",
        "                run_time=10,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            VFadeIn(plane),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    #\n",
        "    def cos_exp(self, x, t, A=2, omega=1.5, k=0.1):\n",
        "        return A * np.cos(omega * x) * np.exp(-k * (omega**2) * t)\n",
        "\n",
        "    def get_cos_graph(self, axes, **config):\n",
        "        return self.get_initial_state_graph(\n",
        "            axes,\n",
        "            lambda x: self.cos_exp(x, 0),\n",
        "            **config\n",
        "        )\n",
        "\n",
        "    def get_cos_exp_surface(self, axes, **config):\n",
        "        return self.get_surface(\n",
        "            axes,\n",
        "            lambda x, t: self.cos_exp(x, t),\n",
        "            **config\n",
        "        )\n",
        "\n",
        "\n",
        "class AddMultipleSolutions(SimpleCosExpGraph):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 0.7,\n",
        "            },\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        axes1, axes2, axes3 = all_axes = VGroup(*[\n",
        "            self.get_three_d_axes(\n",
        "                include_labels=False,\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        all_axes.scale(0.5)\n",
        "        self.orient_three_d_mobject(all_axes)\n",
        "\n",
        "        As = [1.5, 1.5]\n",
        "        omegas = [1.5, 2.5]\n",
        "        ks = [0.1, 0.1]\n",
        "        quads = [\n",
        "            (axes1, [As[0]], [omegas[0]], [ks[0]]),\n",
        "            (axes2, [As[1]], [omegas[1]], [ks[1]]),\n",
        "            (axes3, As, omegas, ks),\n",
        "        ]\n",
        "\n",
        "        for axes, As, omegas, ks in quads:\n",
        "            graph = self.get_initial_state_graph(\n",
        "                axes,\n",
        "                lambda x: np.sum([\n",
        "                    self.cos_exp(x, 0, A, omega, k)\n",
        "                    for A, omega, k in zip(As, omegas, ks)\n",
        "                ])\n",
        "            )\n",
        "            surface = self.get_surface(\n",
        "                axes,\n",
        "                lambda x, t: np.sum([\n",
        "                    self.cos_exp(x, t, A, omega, k)\n",
        "                    for A, omega, k in zip(As, omegas, ks)\n",
        "                ])\n",
        "            )\n",
        "            surface.sort(lambda p: -p[2])\n",
        "\n",
        "            axes.add(surface, graph)\n",
        "            axes.graph = graph\n",
        "            axes.surface = surface\n",
        "\n",
        "        self.set_camera_orientation(distance=100)\n",
        "        plus = OldTex(\"+\").scale(2)\n",
        "        equals = OldTex(\"=\").scale(2)\n",
        "        group = VGroup(\n",
        "            axes1, plus, axes2, equals, axes3,\n",
        "        )\n",
        "        group.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        for axes in all_axes:\n",
        "            checkmark = OldTex(\"\\\\checkmark\")\n",
        "            checkmark.set_color(GREEN)\n",
        "            checkmark.scale(2)\n",
        "            checkmark.next_to(axes, UP)\n",
        "            checkmark.shift(0.7 * DOWN)\n",
        "            axes.checkmark = checkmark\n",
        "\n",
        "        self.add(axes1, axes2)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                Write(axes1.surface),\n",
        "                Write(axes2.surface),\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(axes1.checkmark, DOWN),\n",
        "                FadeIn(axes2.checkmark, DOWN),\n",
        "            ),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(plus))\n",
        "        self.play(\n",
        "            Transform(\n",
        "                axes1.copy().set_fill(opacity=0),\n",
        "                axes3\n",
        "            ),\n",
        "            Transform(\n",
        "                axes2.copy().set_fill(opacity=0),\n",
        "                axes3\n",
        "            ),\n",
        "            FadeIn(equals, LEFT)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(axes3.checkmark, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BreakDownAFunction(SimpleCosExpGraph):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"z_axis_config\": {\n",
        "                \"unit_size\": 0.75,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            \"z_min\": -2,\n",
        "            \"y_max\": 20,\n",
        "        },\n",
        "        \"low_axes_config\": {\n",
        "            \"z_min\": -3,\n",
        "            \"z_axis_config\": {\"unit_size\": 1}\n",
        "        },\n",
        "        \"n_low_axes\": 4,\n",
        "        \"k\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.set_camera_orientation(distance=100)\n",
        "        self.set_axes()\n",
        "        self.setup_graphs()\n",
        "        self.show_break_down()\n",
        "        self.show_solutions_for_waves()\n",
        "\n",
        "    def set_axes(self):\n",
        "        top_axes = self.get_three_d_axes()\n",
        "        top_axes.z_axis.label.next_to(\n",
        "            top_axes.z_axis.get_end(), OUT, SMALL_BUFF\n",
        "        )\n",
        "        top_axes.y_axis.set_opacity(0)\n",
        "        self.orient_three_d_mobject(top_axes)\n",
        "        top_axes.y_axis.label.rotate(-10 * DEGREES, UP)\n",
        "        top_axes.scale(0.75)\n",
        "        top_axes.center()\n",
        "        top_axes.to_edge(UP)\n",
        "\n",
        "        low_axes = self.get_three_d_axes(**self.low_axes_config)\n",
        "        low_axes.y_axis.set_opacity(0)\n",
        "        for axis in low_axes:\n",
        "            axis.label.fade(1)\n",
        "        # low_axes.add(low_axes.input_plane)\n",
        "        # low_axes.input_plane.set_opacity(0)\n",
        "\n",
        "        self.orient_three_d_mobject(low_axes)\n",
        "        low_axes_group = VGroup(*[\n",
        "            low_axes.deepcopy()\n",
        "            for x in range(self.n_low_axes)\n",
        "        ])\n",
        "        low_axes_group.arrange(\n",
        "            RIGHT, buff=low_axes.get_width() / 3\n",
        "        )\n",
        "        low_axes_group.set_width(FRAME_WIDTH - 2.5)\n",
        "        low_axes_group.next_to(top_axes, DOWN, LARGE_BUFF)\n",
        "        low_axes_group.to_edge(LEFT)\n",
        "\n",
        "        self.top_axes = top_axes\n",
        "        self.low_axes_group = low_axes_group\n",
        "\n",
        "    def setup_graphs(self):\n",
        "        top_axes = self.top_axes\n",
        "        low_axes_group = self.low_axes_group\n",
        "\n",
        "        top_graph = self.get_initial_state_graph(\n",
        "            top_axes,\n",
        "            self.initial_func,\n",
        "            discontinuities=self.get_initial_func_discontinuities(),\n",
        "            color=YELLOW,\n",
        "        )\n",
        "        top_graph.set_stroke(width=4)\n",
        "\n",
        "        fourier_terms = self.get_fourier_cosine_terms(\n",
        "            self.initial_func\n",
        "        )\n",
        "\n",
        "        low_graphs = VGroup(*[\n",
        "            self.get_initial_state_graph(\n",
        "                axes,\n",
        "                lambda x: A * np.cos(n * x / 2)\n",
        "            )\n",
        "            for n, axes, A in zip(\n",
        "                it.count(),\n",
        "                low_axes_group,\n",
        "                fourier_terms\n",
        "            )\n",
        "        ])\n",
        "        k = self.k\n",
        "        low_surfaces = VGroup(*[\n",
        "            self.get_surface(\n",
        "                axes,\n",
        "                lambda x, t: np.prod([\n",
        "                    A,\n",
        "                    np.cos(n * x / 2),\n",
        "                    np.exp(-k * (n / 2)**2 * t)\n",
        "                ])\n",
        "            )\n",
        "            for n, axes, A in zip(\n",
        "                it.count(),\n",
        "                low_axes_group,\n",
        "                fourier_terms\n",
        "            )\n",
        "        ])\n",
        "        top_surface = self.get_surface(\n",
        "            top_axes,\n",
        "            lambda x, t: np.sum([\n",
        "                np.prod([\n",
        "                    A,\n",
        "                    np.cos(n * x / 2),\n",
        "                    np.exp(-k * (n / 2)**2 * t)\n",
        "                ])\n",
        "                for n, A in zip(\n",
        "                    it.count(),\n",
        "                    fourier_terms\n",
        "                )\n",
        "            ])\n",
        "        )\n",
        "\n",
        "        self.top_graph = top_graph\n",
        "        self.low_graphs = low_graphs\n",
        "        self.low_surfaces = low_surfaces\n",
        "        self.top_surface = top_surface\n",
        "\n",
        "    def show_break_down(self):\n",
        "        top_axes = self.top_axes\n",
        "        low_axes_group = self.low_axes_group\n",
        "        top_graph = self.top_graph\n",
        "        low_graphs = self.low_graphs\n",
        "\n",
        "        plusses = VGroup(*[\n",
        "            OldTex(\"+\").next_to(\n",
        "                axes.x_axis.get_end(),\n",
        "                RIGHT, MED_SMALL_BUFF\n",
        "            )\n",
        "            for axes in low_axes_group\n",
        "        ])\n",
        "        dots = OldTex(\"\\\\cdots\")\n",
        "        dots.next_to(plusses, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            dots.get_right(),\n",
        "            top_graph.get_end() + 1.4 * DOWN + 1.7 * RIGHT,\n",
        "            path_arc=90 * DEGREES,\n",
        "        )\n",
        "\n",
        "        top_words = OldTexText(\"Arbitrary\\\\\\\\function\")\n",
        "        top_words.next_to(top_axes, LEFT, MED_LARGE_BUFF)\n",
        "        top_words.set_color(YELLOW)\n",
        "        top_arrow = Arrow(\n",
        "            top_words.get_right(),\n",
        "            top_graph.point_from_proportion(0.3)\n",
        "        )\n",
        "\n",
        "        low_words = OldTexText(\"Sine curves\")\n",
        "        low_words.set_color(BLUE)\n",
        "        low_words.next_to(low_axes_group, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(top_axes)\n",
        "        self.play(ShowCreation(top_graph))\n",
        "        self.play(\n",
        "            FadeIn(top_words, RIGHT),\n",
        "            ShowCreation(top_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, low_axes_group),\n",
        "            FadeIn(low_words, UP),\n",
        "            LaggedStartMap(FadeInFromDown, [*plusses, dots]),\n",
        "            *[\n",
        "                TransformFromCopy(top_graph, low_graph)\n",
        "                for low_graph in low_graphs\n",
        "            ],\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def show_solutions_for_waves(self):\n",
        "        low_axes_group = self.low_axes_group\n",
        "        top_axes = self.top_axes\n",
        "        low_graphs = self.low_graphs\n",
        "        low_surfaces = self.low_surfaces\n",
        "        top_surface = self.top_surface\n",
        "        top_graph = self.top_graph\n",
        "\n",
        "        for surface in [top_surface, *low_surfaces]:\n",
        "            surface.sort(lambda p: -p[2])\n",
        "\n",
        "        anims1 = []\n",
        "        anims2 = [\n",
        "            ApplyMethod(\n",
        "                top_axes.y_axis.set_opacity, 1,\n",
        "            ),\n",
        "        ]\n",
        "        for axes, surface, graph in zip(low_axes_group, low_surfaces, low_graphs):\n",
        "            axes.y_axis.set_opacity(1)\n",
        "            axes.y_axis.label.fade(1)\n",
        "            anims1 += [\n",
        "                ShowCreation(axes.y_axis),\n",
        "                Write(surface, run_time=2),\n",
        "            ]\n",
        "            anims2.append(AnimationGroup(\n",
        "                TransformFromCopy(graph, top_graph.copy()),\n",
        "                Transform(\n",
        "                    surface.copy().set_fill(opacity=0),\n",
        "                    top_surface,\n",
        "                )\n",
        "            ))\n",
        "\n",
        "        self.play(*anims1)\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*anims2, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        checkmark = OldTex(\"\\\\checkmark\")\n",
        "        checkmark.set_color(GREEN)\n",
        "        low_checkmarks = VGroup(*[\n",
        "            checkmark.copy().next_to(\n",
        "                surface.get_top(), UP, SMALL_BUFF\n",
        "            )\n",
        "            for surface in low_surfaces\n",
        "        ])\n",
        "        top_checkmark = checkmark.copy()\n",
        "        top_checkmark.scale(1.5)\n",
        "        top_checkmark.move_to(top_axes.get_corner(UR))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, low_checkmarks))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            TransformFromCopy(low_checkmark, top_checkmark.copy())\n",
        "            for low_checkmark in low_checkmarks\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def initial_func(self, x):\n",
        "        # return 3 * np.exp(-(x - PI)**2)\n",
        "\n",
        "        x1 = TAU / 4 - 1\n",
        "        x2 = TAU / 4 + 1\n",
        "        x3 = 3 * TAU / 4 - 1.6\n",
        "        x4 = 3 * TAU / 4 + 0.3\n",
        "\n",
        "        T0 = -2\n",
        "        T1 = 2\n",
        "        T2 = 1\n",
        "\n",
        "        if x < x1:\n",
        "            return T0\n",
        "        elif x < x2:\n",
        "            alpha = inverse_interpolate(x1, x2, x)\n",
        "            return bezier([T0, T0, T1, T1])(alpha)\n",
        "        elif x < x3:\n",
        "            return T1\n",
        "        elif x < x4:\n",
        "            alpha = inverse_interpolate(x3, x4, x)\n",
        "            return bezier([T1, T1, T2, T2])(alpha)\n",
        "        else:\n",
        "            return T2\n",
        "\n",
        "    def get_initial_func_discontinuities(self):\n",
        "        # return [TAU / 4, 3 * TAU / 4]\n",
        "        return []\n",
        "\n",
        "    def get_fourier_cosine_terms(self, func, n_terms=40):\n",
        "        result = [\n",
        "            integrate.quad(\n",
        "                lambda x: (1 / PI) * func(x) * np.cos(n * x / 2),\n",
        "                0, TAU\n",
        "            )[0]\n",
        "            for n in range(n_terms)\n",
        "        ]\n",
        "        result[0] = result[0] / 2\n",
        "        return result\n",
        "\n",
        "\n",
        "class OceanOfPossibilities(TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"z_min\": 0,\n",
        "            \"z_max\": 4,\n",
        "        },\n",
        "        \"k\": 0.2,\n",
        "        \"default_surface_config\": {\n",
        "            # \"resolution\": (32, 20),\n",
        "            # \"resolution\": (8, 5),\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_camera()\n",
        "        self.setup_axes()\n",
        "        self.setup_surface()\n",
        "        self.show_solution()\n",
        "        self.reference_boundary_conditions()\n",
        "        self.reference_initial_condition()\n",
        "        self.ambiently_change_solution()\n",
        "\n",
        "    def setup_camera(self):\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.get_three_d_axes(include_numbers=True)\n",
        "        axes.add(axes.input_plane)\n",
        "        axes.scale(0.8)\n",
        "        axes.center()\n",
        "        axes.shift(OUT + RIGHT)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.axes = axes\n",
        "\n",
        "    def setup_surface(self):\n",
        "        axes = self.axes\n",
        "        k = self.k\n",
        "\n",
        "        # Parameters for surface function\n",
        "        initial_As = [2] + [\n",
        "            0.8 * random.choice([-1, 1]) / n\n",
        "            for n in range(1, 20)\n",
        "        ]\n",
        "        A_trackers = Group(*[\n",
        "            ValueTracker(A)\n",
        "            for A in initial_As\n",
        "        ])\n",
        "\n",
        "        def get_As():\n",
        "            return [At.get_value() for At in A_trackers]\n",
        "\n",
        "        omegas = [n / 2 for n in range(0, 10)]\n",
        "\n",
        "        def func(x, t):\n",
        "            return np.sum([\n",
        "                np.prod([\n",
        "                    A * np.cos(omega * x),\n",
        "                    np.exp(-k * omega**2 * t)\n",
        "                ])\n",
        "                for A, omega in zip(get_As(), omegas)\n",
        "            ])\n",
        "\n",
        "        # Surface and graph\n",
        "        surface = always_redraw(\n",
        "            lambda: self.get_surface(axes, func)\n",
        "        )\n",
        "        t_tracker = ValueTracker(0)\n",
        "        graph = always_redraw(\n",
        "            lambda: self.get_time_slice_graph(\n",
        "                axes, func, t_tracker.get_value(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        surface.suspend_updating()\n",
        "        graph.suspend_updating()\n",
        "\n",
        "        self.surface_func = func\n",
        "        self.surface = surface\n",
        "        self.graph = graph\n",
        "        self.t_tracker = t_tracker\n",
        "        self.A_trackers = A_trackers\n",
        "        self.omegas = omegas\n",
        "\n",
        "    def show_solution(self):\n",
        "        axes = self.axes\n",
        "        surface = self.surface\n",
        "        graph = self.graph\n",
        "        t_tracker = self.t_tracker\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        opacity_tracker = ValueTracker(0)\n",
        "        plane = always_redraw(lambda: Polygon(\n",
        "            *[\n",
        "                axes.c2p(x, get_t(), T)\n",
        "                for x, T in [\n",
        "                    (0, 0), (TAU, 0), (TAU, 4), (0, 4)\n",
        "                ]\n",
        "            ],\n",
        "            stroke_width=0,\n",
        "            fill_color=WHITE,\n",
        "            fill_opacity=opacity_tracker.get_value(),\n",
        "        ))\n",
        "\n",
        "        self.add(surface, plane, graph)\n",
        "        graph.resume_updating()\n",
        "        self.play(\n",
        "            opacity_tracker.set_value, 0.2,\n",
        "            ApplyMethod(\n",
        "                t_tracker.set_value, 1,\n",
        "                rate_func=linear\n",
        "            ),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                t_tracker.set_value, 10,\n",
        "                rate_func=linear,\n",
        "                run_time=9\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.plane = plane\n",
        "\n",
        "    def reference_boundary_conditions(self):\n",
        "        axes = self.axes\n",
        "        t_numbers = axes.y_axis.numbers\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                axes.c2p(x, 0, 0),\n",
        "                axes.c2p(x, axes.y_max, 0),\n",
        "                stroke_width=3,\n",
        "                stroke_color=MAROON_B,\n",
        "            )\n",
        "            for x in [0, axes.x_max]\n",
        "        ])\n",
        "        surface_boundary_lines = always_redraw(lambda: VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t: axes.c2p(\n",
        "                    x, t,\n",
        "                    self.surface_func(x, t)\n",
        "                ),\n",
        "                t_max=axes.y_max\n",
        "            ).match_style(self.graph)\n",
        "            for x in [0, axes.x_max]\n",
        "        ]))\n",
        "        # surface_boundary_lines.suspend_updating()\n",
        "        words = VGroup()\n",
        "        for line in lines:\n",
        "            word = OldTexText(\"Boundary\")\n",
        "            word.set_stroke(BLACK, 3, background=True)\n",
        "            word.scale(1.5)\n",
        "            word.match_color(line)\n",
        "            word.rotate(90 * DEGREES, RIGHT)\n",
        "            word.rotate(90 * DEGREES, OUT)\n",
        "            word.next_to(line, OUT, SMALL_BUFF)\n",
        "            words.add(word)\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            theta=-45 * DEGREES,\n",
        "            added_anims=[\n",
        "                LaggedStartMap(ShowCreation, lines),\n",
        "                LaggedStartMap(\n",
        "                    FadeInFrom, words,\n",
        "                    lambda m: (m, IN)\n",
        "                ),\n",
        "                FadeOut(t_numbers),\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(l1, l2)\n",
        "                for l1, l2 in zip(lines, surface_boundary_lines)\n",
        "            ])\n",
        "        )\n",
        "        self.add(surface_boundary_lines)\n",
        "        self.wait()\n",
        "        self.move_camera(\n",
        "            theta=-70 * DEGREES,\n",
        "        )\n",
        "\n",
        "        self.surface_boundary_lines = surface_boundary_lines\n",
        "\n",
        "    def reference_initial_condition(self):\n",
        "        plane = self.plane\n",
        "        t_tracker = self.t_tracker\n",
        "\n",
        "        self.play(\n",
        "            t_tracker.set_value, 0,\n",
        "            run_time=2\n",
        "        )\n",
        "        plane.clear_updaters()\n",
        "        self.play(FadeOut(plane))\n",
        "\n",
        "    def ambiently_change_solution(self):\n",
        "        A_trackers = self.A_trackers\n",
        "\n",
        "        def generate_A_updater(A, rate):\n",
        "            def update(m, dt):\n",
        "                m.total_time += dt\n",
        "                m.set_value(\n",
        "                    2 * A * np.sin(rate * m.total_time + PI / 6)\n",
        "                )\n",
        "            return update\n",
        "\n",
        "        rates = [0, 0.2] + [\n",
        "            0.5 + 0.5 * np.random.random()\n",
        "            for x in range(len(A_trackers) - 2)\n",
        "        ]\n",
        "\n",
        "        for tracker, rate in zip(A_trackers, rates):\n",
        "            tracker.total_time = 0\n",
        "            tracker.add_updater(generate_A_updater(\n",
        "                tracker.get_value(),\n",
        "                rate\n",
        "            ))\n",
        "\n",
        "        self.add(*A_trackers)\n",
        "        self.surface_boundary_lines.resume_updating()\n",
        "        self.surface.resume_updating()\n",
        "        self.graph.resume_updating()\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class AnalyzeSineCurve(TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"origin_point\": 3 * LEFT,\n",
        "        \"axes_config\": {\n",
        "            \"z_min\": -1.5,\n",
        "            \"z_max\": 1.5,\n",
        "            \"z_axis_config\": {\n",
        "                \"unit_size\": 2,\n",
        "                \"tick_frequency\": 0.5,\n",
        "            }\n",
        "        },\n",
        "        \"tex_to_color_map\": {\n",
        "            \"{x}\": GREEN,\n",
        "            \"T\": YELLOW,\n",
        "            \"=\": WHITE,\n",
        "            \"0\": WHITE,\n",
        "            \"\\\\Delta t\": WHITE,\n",
        "            \"\\\\sin\": WHITE,\n",
        "            \"{t}\": PINK,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.ask_about_sine_curve()\n",
        "        self.show_sine_wave_on_axes()\n",
        "        self.reference_curvature()\n",
        "        self.show_derivatives()\n",
        "        self.show_curvature_matching_height()\n",
        "        self.show_time_step_scalings()\n",
        "        self.smooth_evolution()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.get_three_d_axes()\n",
        "        axes.rotate(90 * DEGREES, LEFT)\n",
        "        axes.shift(self.origin_point - axes.c2p(0, 0, 0))\n",
        "        y_axis = axes.y_axis\n",
        "        y_axis.fade(1)\n",
        "        z_axis = axes.z_axis\n",
        "        z_axis.label.next_to(z_axis.get_end(), UP, SMALL_BUFF)\n",
        "\n",
        "        self.add_axes_numbers(axes)\n",
        "        y_axis.remove(y_axis.numbers)\n",
        "        axes.z_axis.add_numbers(\n",
        "            *range(-1, 2),\n",
        "            direction=LEFT,\n",
        "        )\n",
        "\n",
        "        self.axes = axes\n",
        "\n",
        "    def ask_about_sine_curve(self):\n",
        "        curve = FunctionGraph(\n",
        "            lambda t: np.sin(t),\n",
        "            x_min=0,\n",
        "            x_max=TAU,\n",
        "        )\n",
        "        curve.move_to(DR)\n",
        "        curve.set_width(5)\n",
        "        curve.set_color(YELLOW)\n",
        "        question = OldTexText(\"What's so special?\")\n",
        "        question.scale(1.5)\n",
        "        question.to_edge(UP)\n",
        "        question.shift(2 * LEFT)\n",
        "        arrow = Arrow(\n",
        "            question.get_bottom(),\n",
        "            curve.point_from_proportion(0.25)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(curve),\n",
        "            Write(question, run_time=1),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.quick_sine_curve = curve\n",
        "        self.question_group = VGroup(question, arrow)\n",
        "\n",
        "    def show_sine_wave_on_axes(self):\n",
        "        axes = self.axes\n",
        "        graph = self.get_initial_state_graph(\n",
        "            axes, lambda x: np.sin(x)\n",
        "        )\n",
        "        graph.set_stroke(width=4)\n",
        "        graph_label = OldTex(\n",
        "            \"T({x}, 0) = \\\\sin\\\\left({x}\\\\right)\",\n",
        "            tex_to_color_map=self.tex_to_color_map,\n",
        "        )\n",
        "        graph_label.next_to(\n",
        "            graph.point_from_proportion(0.25), UR,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        v_line, x_tracker = self.get_v_line_with_x_tracker(graph)\n",
        "\n",
        "        xs = VGroup(\n",
        "            *graph_label.get_parts_by_tex(\"x\"),\n",
        "            axes.x_axis.label,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(axes),\n",
        "            self.quick_sine_curve.become, graph,\n",
        "            FadeOut(self.question_group, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(graph_label),\n",
        "            FadeIn(graph),\n",
        "        )\n",
        "        self.remove(self.quick_sine_curve)\n",
        "        self.add(v_line)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                x_tracker.set_value, TAU,\n",
        "                rate_func=lambda t: smooth(t, 3),\n",
        "                run_time=5,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeAround, xs,\n",
        "                run_time=3,\n",
        "                lag_ratio=0.2,\n",
        "            )\n",
        "        )\n",
        "        self.remove(v_line, x_tracker)\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "        self.v_line = v_line\n",
        "        self.x_tracker = x_tracker\n",
        "\n",
        "    def reference_curvature(self):\n",
        "        curve_segment, curve_x_tracker = \\\n",
        "            self.get_curve_segment_with_x_tracker(self.graph)\n",
        "\n",
        "        self.add(curve_segment)\n",
        "        self.play(\n",
        "            curve_x_tracker.set_value, TAU,\n",
        "            run_time=5,\n",
        "            rate_func=lambda t: smooth(t, 3),\n",
        "        )\n",
        "        self.play(FadeOut(curve_segment))\n",
        "\n",
        "        self.curve_segment = curve_segment\n",
        "        self.curve_x_tracker = curve_x_tracker\n",
        "\n",
        "    def show_derivatives(self):\n",
        "        deriv1 = OldTex(\n",
        "            \"{\\\\partial T \\\\over \\\\partial {x}}({x}, 0)\",\n",
        "            \"= \\\\cos\\\\left({x}\\\\right)\",\n",
        "            tex_to_color_map=self.tex_to_color_map,\n",
        "        )\n",
        "        deriv2 = OldTex(\n",
        "            \"{\\\\partial^2 T \\\\over \\\\partial {x}^2}({x}, 0)\",\n",
        "            \"= -\\\\sin\\\\left({x}\\\\right)\",\n",
        "            tex_to_color_map=self.tex_to_color_map,\n",
        "        )\n",
        "\n",
        "        deriv1.to_corner(UR)\n",
        "        deriv2.next_to(\n",
        "            deriv1, DOWN,\n",
        "            buff=0.75,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        VGroup(deriv1, deriv2).shift(1.4 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Animation(Group(*self.get_mobjects())),\n",
        "            FadeIn(deriv1, LEFT),\n",
        "            self.camera.frame_center.shift, 2 * RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(deriv2, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.deriv1 = deriv1\n",
        "        self.deriv2 = deriv2\n",
        "\n",
        "    def show_curvature_matching_height(self):\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        curve_segment = self.curve_segment\n",
        "        curve_x_tracker = self.curve_x_tracker\n",
        "\n",
        "        d2_graph = self.get_initial_state_graph(\n",
        "            axes, lambda x: -np.sin(x),\n",
        "        )\n",
        "        dashed_d2_graph = DashedVMobject(d2_graph, num_dashes=50)\n",
        "        dashed_d2_graph.color_using_background_image(None)\n",
        "        dashed_d2_graph.set_stroke(RED, 2)\n",
        "\n",
        "        vector, x_tracker = self.get_v_line_with_x_tracker(\n",
        "            d2_graph,\n",
        "            line_creator=lambda p1, p2: Arrow(\n",
        "                p1, p2, color=RED, buff=0\n",
        "            )\n",
        "        )\n",
        "\n",
        "        lil_vectors = self.get_many_lil_vectors(graph)\n",
        "        lil_vector = always_redraw(\n",
        "            lambda: self.get_lil_vector(\n",
        "                graph, x_tracker.get_value()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        d2_rect = SurroundingRectangle(\n",
        "            self.deriv2[-5:],\n",
        "            color=RED,\n",
        "        )\n",
        "        self.play(ShowCreation(d2_rect))\n",
        "        self.add(vector)\n",
        "        self.add(lil_vector)\n",
        "        self.add(curve_segment)\n",
        "        curve_x_tracker.set_value(0)\n",
        "        self.play(\n",
        "            ShowCreation(dashed_d2_graph),\n",
        "            x_tracker.set_value, TAU,\n",
        "            curve_x_tracker.set_value, TAU,\n",
        "            ShowIncreasingSubsets(lil_vectors[1:]),\n",
        "            run_time=8,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.remove(vector)\n",
        "        self.remove(lil_vector)\n",
        "        self.add(lil_vectors)\n",
        "        self.play(\n",
        "            FadeOut(curve_segment),\n",
        "            FadeOut(d2_rect),\n",
        "        )\n",
        "\n",
        "        self.lil_vectors = lil_vectors\n",
        "        self.dashed_d2_graph = dashed_d2_graph\n",
        "\n",
        "    def show_time_step_scalings(self):\n",
        "        axes = self.axes\n",
        "        graph_label = self.graph_label\n",
        "        dashed_d2_graph = self.dashed_d2_graph\n",
        "        lil_vectors = self.lil_vectors\n",
        "        graph = self.graph\n",
        "\n",
        "        factor = 0.9\n",
        "\n",
        "        new_label = OldTex(\n",
        "            \"T({x}, \\\\Delta t) = c \\\\cdot \\\\sin\\\\left({x}\\\\right)\",\n",
        "            tex_to_color_map=self.tex_to_color_map,\n",
        "        )\n",
        "        final_label = OldTex(\n",
        "            \"T({x}, {t}) = (\\\\text{something}) \\\\cdot \\\\sin\\\\left({x}\\\\right)\",\n",
        "            tex_to_color_map=self.tex_to_color_map,\n",
        "        )\n",
        "        for label in (new_label, final_label):\n",
        "            label.shift(\n",
        "                graph_label.get_part_by_tex(\"=\").get_center() -\n",
        "                label.get_part_by_tex(\"=\").get_center()\n",
        "            )\n",
        "        final_label.shift(1.5 * LEFT)\n",
        "\n",
        "        h_lines = VGroup(\n",
        "            DashedLine(axes.c2p(0, 0, 1), axes.c2p(TAU, 0, 1)),\n",
        "            DashedLine(axes.c2p(0, 0, -1), axes.c2p(TAU, 0, -1)),\n",
        "        )\n",
        "\n",
        "        lil_vectors.add_updater(lambda m: m.become(\n",
        "            self.get_many_lil_vectors(graph)\n",
        "        ))\n",
        "\n",
        "        i = 4\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                graph_label[:i], new_label[:i],\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                graph_label[i + 1:i + 3],\n",
        "                new_label[i + 1:i + 3],\n",
        "            ),\n",
        "            FadeOut(graph_label[i], UP),\n",
        "            FadeIn(new_label[i], DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                graph_label[i + 3:],\n",
        "                new_label[i + 4:]\n",
        "            ),\n",
        "            FadeInFromDown(new_label[i + 3])\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(dashed_d2_graph),\n",
        "            FadeIn(h_lines),\n",
        "        )\n",
        "        self.play(\n",
        "            graph.stretch, factor, 1,\n",
        "            h_lines.stretch, factor, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Repeat\n",
        "        last_coef = None\n",
        "        last_exp = None\n",
        "        delta_T = new_label.get_part_by_tex(\"\\\\Delta t\")\n",
        "        c = new_label.get_part_by_tex(\"c\")[0]\n",
        "        prefix = new_label[:4]\n",
        "        prefix.generate_target()\n",
        "        for x in range(5):\n",
        "            coef = Integer(x + 2)\n",
        "            exp = coef.copy().scale(0.7)\n",
        "            coef.next_to(\n",
        "                delta_T, LEFT, SMALL_BUFF,\n",
        "                aligned_edge=DOWN,\n",
        "            )\n",
        "            exp.move_to(c.get_corner(UR), DL)\n",
        "            anims1 = [FadeIn(coef, 0.25 * DOWN)]\n",
        "            anims2 = [FadeIn(exp, 0.25 * DOWN)]\n",
        "            if last_coef:\n",
        "                anims1.append(\n",
        "                    FadeOut(last_coef, 0.25 * UP)\n",
        "                )\n",
        "                anims2.append(\n",
        "                    FadeOut(last_exp, 0.25 * UP)\n",
        "                )\n",
        "            last_coef = coef\n",
        "            last_exp = exp\n",
        "            prefix.target.next_to(coef, LEFT, SMALL_BUFF)\n",
        "            prefix.target.match_y(prefix)\n",
        "            anims1.append(MoveToTarget(prefix))\n",
        "\n",
        "            self.play(*anims1)\n",
        "            self.play(\n",
        "                graph.stretch, factor, 1,\n",
        "                h_lines.stretch, factor, 1,\n",
        "                *anims2,\n",
        "            )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                new_label[:4],\n",
        "                final_label[:4],\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                VGroup(last_coef, delta_T),\n",
        "                final_label.get_part_by_tex(\"{t}\"),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                last_exp,\n",
        "                final_label.get_part_by_tex(\"something\"),\n",
        "            ),\n",
        "            FadeOut(new_label.get_part_by_tex(\"\\\\cdot\"), UP),\n",
        "            ReplacementTransform(\n",
        "                new_label[-4:],\n",
        "                final_label[-4:],\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                new_label.get_part_by_tex(\"=\"),\n",
        "                final_label.get_part_by_tex(\"=\"),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                new_label.get_part_by_tex(\")\"),\n",
        "                final_label.get_part_by_tex(\")\"),\n",
        "            ),\n",
        "        )\n",
        "        final_label.add_background_rectangle(opacity=1)\n",
        "        self.add(final_label)\n",
        "        self.wait()\n",
        "\n",
        "        group = VGroup(graph, h_lines)\n",
        "        group.add_updater(lambda m, dt: m.stretch(\n",
        "            (1 - 0.1 * dt), 1\n",
        "        ))\n",
        "        self.add(group)\n",
        "        self.wait(10)\n",
        "\n",
        "    def smooth_evolution(self):\n",
        "        pass\n",
        "\n",
        "    #\n",
        "    def get_rod(self, temp_func):\n",
        "        pass\n",
        "\n",
        "    def get_v_line_with_x_tracker(self, graph, line_creator=DashedLine):\n",
        "        axes = self.axes\n",
        "        x_min = axes.x_axis.p2n(graph.get_start())\n",
        "        x_max = axes.x_axis.p2n(graph.get_end())\n",
        "        x_tracker = ValueTracker(x_min)\n",
        "        get_x = x_tracker.get_value\n",
        "        v_line = always_redraw(lambda: line_creator(\n",
        "            axes.c2p(get_x(), 0, 0),\n",
        "            graph.point_from_proportion(\n",
        "                inverse_interpolate(\n",
        "                    x_min, x_max, get_x()\n",
        "                )\n",
        "            ),\n",
        "        ))\n",
        "        return v_line, x_tracker\n",
        "\n",
        "    def get_curve_segment_with_x_tracker(self, graph, delta_x=0.5):\n",
        "        axes = self.axes\n",
        "        x_min = axes.x_axis.p2n(graph.get_start())\n",
        "        x_max = axes.x_axis.p2n(graph.get_end())\n",
        "        x_tracker = ValueTracker(x_min)\n",
        "        get_x = x_tracker.get_value\n",
        "\n",
        "        def x2a(x):\n",
        "            return inverse_interpolate(x_min, x_max, x)\n",
        "\n",
        "        curve = VMobject(\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=5\n",
        "        )\n",
        "        curve.add_updater(lambda m: m.pointwise_become_partial(\n",
        "            graph,\n",
        "            max(x2a(get_x() - delta_x), 0),\n",
        "            min(x2a(get_x() + delta_x), 1),\n",
        "        ))\n",
        "        return curve, x_tracker\n",
        "\n",
        "    def get_lil_vector(self, graph, x):\n",
        "        x_axis = self.axes.x_axis\n",
        "        point = graph.point_from_proportion(x / TAU)\n",
        "        x_axis_point = x_axis.n2p(x_axis.p2n(point))\n",
        "        return Arrow(\n",
        "            point,\n",
        "            interpolate(\n",
        "                point, x_axis_point, 0.5,\n",
        "            ),\n",
        "            buff=0,\n",
        "            color=RED\n",
        "        )\n",
        "\n",
        "    def get_many_lil_vectors(self, graph, n=13):\n",
        "        return VGroup(*[\n",
        "            self.get_lil_vector(graph, x)\n",
        "            for x in np.linspace(0, TAU, n)\n",
        "        ])\n",
        "\n",
        "\n",
        "class SineWaveScaledByExp(TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"z_min\": -1.5,\n",
        "            \"z_max\": 1.5,\n",
        "            \"z_axis_config\": {\n",
        "                \"unit_size\": 2,\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"label_direction\": LEFT,\n",
        "            },\n",
        "            \"y_axis_config\": {\n",
        "                \"label_direction\": RIGHT,\n",
        "            },\n",
        "        },\n",
        "        \"k\": 0.3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_camera()\n",
        "        self.show_sine_wave()\n",
        "        self.show_decay_surface()\n",
        "        self.linger_at_end()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.get_three_d_axes()\n",
        "\n",
        "        # Add number labels\n",
        "        self.add_axes_numbers(axes)\n",
        "        for axis in [axes.x_axis, axes.y_axis]:\n",
        "            axis.numbers.rotate(\n",
        "                90 * DEGREES,\n",
        "                axis=axis.get_vector(),\n",
        "                about_point=axis.point_from_proportion(0.5)\n",
        "            )\n",
        "            axis.numbers.set_shade_in_3d(True)\n",
        "        axes.z_axis.add_numbers(*range(-1, 2))\n",
        "        for number in axes.z_axis.numbers:\n",
        "            number.rotate(90 * DEGREES, RIGHT)\n",
        "\n",
        "        axes.z_axis.label.next_to(\n",
        "            axes.z_axis.get_end(), OUT,\n",
        "        )\n",
        "\n",
        "        # Input plane\n",
        "        axes.input_plane.set_opacity(0.25)\n",
        "        self.add(axes.input_plane)\n",
        "\n",
        "        # Shift into place\n",
        "        # axes.shift(5 * LEFT)\n",
        "        self.axes = axes\n",
        "        self.add(axes)\n",
        "\n",
        "    def setup_camera(self):\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "            distance=50,\n",
        "        )\n",
        "        self.camera.frame.move_to(2 * RIGHT)\n",
        "\n",
        "    def show_sine_wave(self):\n",
        "        time_tracker = ValueTracker(0)\n",
        "        graph = always_redraw(\n",
        "            lambda: self.get_time_slice_graph(\n",
        "                self.axes,\n",
        "                self.sin_exp,\n",
        "                t=time_tracker.get_value(),\n",
        "            )\n",
        "        )\n",
        "        graph.suspend_updating()\n",
        "\n",
        "        graph_label = OldTex(\"\\\\sin(x)\")\n",
        "        graph_label.set_color(BLUE)\n",
        "        graph_label.rotate(90 * DEGREES, RIGHT)\n",
        "        graph_label.next_to(\n",
        "            graph.point_from_proportion(0.25),\n",
        "            OUT,\n",
        "            SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(graph_label, IN)\n",
        "        )\n",
        "        self.wait()\n",
        "        graph.resume_updating()\n",
        "\n",
        "        self.time_tracker = time_tracker\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_decay_surface(self):\n",
        "        time_tracker = self.time_tracker\n",
        "        axes = self.axes\n",
        "\n",
        "        plane = Rectangle()\n",
        "        plane.rotate(90 * DEGREES, RIGHT)\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.set_fill(WHITE, 0.2)\n",
        "        plane.match_depth(axes.z_axis)\n",
        "        plane.match_width(axes.x_axis, stretch=True)\n",
        "        plane.add_updater(\n",
        "            lambda p: p.move_to(axes.c2p(\n",
        "                0,\n",
        "                time_tracker.get_value(),\n",
        "                0,\n",
        "            ), LEFT)\n",
        "        )\n",
        "\n",
        "        time_slices = VGroup(*[\n",
        "            self.get_time_slice_graph(\n",
        "                self.axes,\n",
        "                self.sin_exp,\n",
        "                t=t,\n",
        "            )\n",
        "            for t in range(0, 10)\n",
        "        ])\n",
        "        surface_t_tracker = ValueTracker(0)\n",
        "        surface = always_redraw(\n",
        "            lambda: self.get_surface(\n",
        "                self.axes,\n",
        "                self.sin_exp,\n",
        "                v_max=surface_t_tracker.get_value(),\n",
        "            ).set_stroke(opacity=0)\n",
        "        )\n",
        "\n",
        "        exp_graph = ParametricCurve(\n",
        "            lambda t: axes.c2p(\n",
        "                PI / 2,\n",
        "                t,\n",
        "                self.sin_exp(PI / 2, t)\n",
        "            ),\n",
        "            t_min=axes.y_min,\n",
        "            t_max=axes.y_max,\n",
        "        )\n",
        "        exp_graph.set_stroke(RED, 3)\n",
        "        exp_graph.set_shade_in_3d(True)\n",
        "\n",
        "        exp_label = OldTex(\"e^{-\\\\alpha t}\")\n",
        "        exp_label.scale(1.5)\n",
        "        exp_label.set_color(RED)\n",
        "        exp_label.rotate(90 * DEGREES, RIGHT)\n",
        "        exp_label.rotate(90 * DEGREES, OUT)\n",
        "        exp_label.next_to(\n",
        "            exp_graph.point_from_proportion(0.3),\n",
        "            OUT + UP,\n",
        "        )\n",
        "\n",
        "        self.move_camera(\n",
        "            theta=-25 * DEGREES,\n",
        "        )\n",
        "        self.add(surface)\n",
        "        self.add(plane)\n",
        "        self.play(\n",
        "            surface_t_tracker.set_value, axes.y_max,\n",
        "            time_tracker.set_value, axes.y_max,\n",
        "            ShowIncreasingSubsets(\n",
        "                time_slices,\n",
        "                int_func=np.ceil,\n",
        "            ),\n",
        "            run_time=5,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        surface.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(exp_graph),\n",
        "            FadeOut(plane),\n",
        "            FadeIn(exp_label, IN),\n",
        "            time_slices.set_stroke, {\"width\": 1},\n",
        "        )\n",
        "\n",
        "    def linger_at_end(self):\n",
        "        self.wait()\n",
        "        self.begin_ambient_camera_rotation(rate=-0.02)\n",
        "        self.wait(20)\n",
        "\n",
        "    #\n",
        "    def sin_exp(self, x, t):\n",
        "        return np.sin(x) * np.exp(-self.k * t)\n",
        "\n",
        "\n",
        "class BoundaryConditionReference(ShowEvolvingTempGraphWithArrows):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_graph()\n",
        "\n",
        "        rod = self.get_rod(0, 10)\n",
        "        self.color_rod_by_graph(rod)\n",
        "\n",
        "        boundary_points = [\n",
        "            rod.get_right(),\n",
        "            rod.get_left(),\n",
        "        ]\n",
        "        boundary_dots = VGroup(*[\n",
        "            Dot(point, radius=0.2)\n",
        "            for point in boundary_points\n",
        "        ])\n",
        "        boundary_arrows = VGroup(*[\n",
        "            Vector(2 * DOWN).next_to(dot, UP)\n",
        "            for dot in boundary_dots\n",
        "        ])\n",
        "        boundary_arrows.set_stroke(YELLOW, 10)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Different rules\\\\\\\\\",\n",
        "            \"at the boundary\",\n",
        "        )\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        # self.add(self.axes)\n",
        "        # self.add(self.graph)\n",
        "        self.add(rod)\n",
        "        self.play(FadeInFromDown(words))\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, boundary_arrows),\n",
        "            LaggedStartMap(GrowFromCenter, boundary_dots),\n",
        "            lag_ratio=0.3,\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimulateRealSineCurve(ShowEvolvingTempGraphWithArrows):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": TAU,\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 1.5,\n",
        "                \"include_tip\": False,\n",
        "                \"tick_frequency\": PI / 4,\n",
        "            },\n",
        "            \"y_min\": -1.5,\n",
        "            \"y_max\": 1.5,\n",
        "            \"y_axis_config\": {\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"unit_size\": 2,\n",
        "            },\n",
        "        },\n",
        "        \"graph_x_min\": 0,\n",
        "        \"graph_x_max\": TAU,\n",
        "        \"arrow_xs\": np.linspace(0, TAU, 13),\n",
        "        \"rod_opacity\": 0.5,\n",
        "        \"wait_time\": 30,\n",
        "        \"alpha\": 0.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_clock()\n",
        "        self.add_rod()\n",
        "        self.add_arrows()\n",
        "        self.initialize_updaters()\n",
        "        self.let_play()\n",
        "\n",
        "    def add_labels_to_axes(self):\n",
        "        x_axis = self.axes.x_axis\n",
        "        x_axis.add(*[\n",
        "            OldTex(tex).scale(0.5).next_to(\n",
        "                x_axis.n2p(n),\n",
        "                DOWN,\n",
        "                buff=MED_SMALL_BUFF\n",
        "            )\n",
        "            for tex, n in [\n",
        "                (\"\\\\tau \\\\over 4\", TAU / 4),\n",
        "                (\"\\\\tau \\\\over 2\", TAU / 2),\n",
        "                (\"3 \\\\tau \\\\over 4\", 3 * TAU / 4),\n",
        "                (\"\\\\tau\", TAU),\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "    def add_axes(self):\n",
        "        super().add_axes()\n",
        "        self.add_labels_to_axes()\n",
        "\n",
        "    def add_rod(self):\n",
        "        super().add_rod()\n",
        "        self.rod.set_opacity(self.rod_opacity)\n",
        "        self.rod.set_stroke(width=0)\n",
        "\n",
        "    def initial_function(self, x):\n",
        "        return np.sin(x)\n",
        "\n",
        "    def y_to_color(self, y):\n",
        "        return temperature_to_color(0.8 * y)\n",
        "\n",
        "\n",
        "class StraightLine3DGraph(TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"z_min\": 0,\n",
        "            \"z_max\": 10,\n",
        "            \"z_axis_config\": {\n",
        "                'unit_size': 0.5,\n",
        "            }\n",
        "        },\n",
        "        \"c\": 1.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        axes = self.get_three_d_axes()\n",
        "        axes.add(axes.input_plane)\n",
        "        axes.move_to(2 * IN + UP, IN)\n",
        "        surface = self.get_surface(\n",
        "            axes, self.func,\n",
        "        )\n",
        "        initial_graph = self.get_initial_state_graph(\n",
        "            axes, lambda x: self.func(x, 0)\n",
        "        )\n",
        "\n",
        "        plane = self.get_const_time_plane(axes)\n",
        "        initial_graph.add_updater(\n",
        "            lambda m: m.move_to(plane, IN)\n",
        "        )\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-100 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(initial_graph)\n",
        "        self.play(\n",
        "            TransformFromCopy(initial_graph, surface)\n",
        "        )\n",
        "        self.add(surface, initial_graph)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(plane),\n",
        "            ApplyMethod(\n",
        "                plane.t_tracker.set_value, 10,\n",
        "                rate_func=linear,\n",
        "                run_time=10,\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeOut(plane))\n",
        "        self.wait(15)\n",
        "\n",
        "    def func(self, x, t):\n",
        "        return self.c * x\n",
        "\n",
        "\n",
        "class SimulateLinearGraph(SimulateRealSineCurve):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"y_min\": 0,\n",
        "            \"y_max\": 3,\n",
        "            \"y_axis_config\": {\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"unit_size\": 2,\n",
        "            },\n",
        "        },\n",
        "        \"arrow_scale_factor\": 2,\n",
        "        \"alpha\": 1,\n",
        "        \"wait_time\": 40,\n",
        "        \"step_size\": 0.02,\n",
        "    }\n",
        "\n",
        "    # def let_play(self):\n",
        "    #     pass\n",
        "\n",
        "    def add_labels_to_axes(self):\n",
        "        pass\n",
        "\n",
        "    def y_to_color(self, y):\n",
        "        return temperature_to_color(0.8 * (y - 1.5))\n",
        "\n",
        "    def initial_function(self, x):\n",
        "        axes = self.axes\n",
        "        y_max = axes.y_max\n",
        "        x_max = axes.x_max\n",
        "        slope = y_max / x_max\n",
        "        return slope * x\n",
        "\n",
        "\n",
        "class EmphasizeBoundaryPoints(SimulateLinearGraph):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def let_play(self):\n",
        "        rod = self.rod\n",
        "        self.graph.update(0.01)\n",
        "        self.arrows.update()\n",
        "\n",
        "        to_update = VGroup(\n",
        "            self.graph,\n",
        "            self.arrows,\n",
        "            self.time_label,\n",
        "        )\n",
        "        for mob in to_update:\n",
        "            mob.suspend_updating()\n",
        "\n",
        "        dots = VGroup(\n",
        "            Dot(rod.get_left()),\n",
        "            Dot(rod.get_right()),\n",
        "        )\n",
        "        for dot in dots:\n",
        "            dot.set_height(0.2)\n",
        "            dot.set_color(YELLOW)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Different rules\\\\\\\\\"\n",
        "            \"at the boundary\"\n",
        "        )\n",
        "        words.next_to(rod, UP)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                words.get_corner(corner),\n",
        "                dot.get_top(),\n",
        "                path_arc=u * 60 * DEGREES,\n",
        "            )\n",
        "            for corner, dot, u in zip(\n",
        "                [LEFT, RIGHT], dots, [1, -1]\n",
        "            )\n",
        "        ])\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, dots,\n",
        "                scale_factor=5,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, arrows,\n",
        "            ),\n",
        "            lag_ratio=0.4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for mob in to_update:\n",
        "            mob.resume_updating()\n",
        "\n",
        "        super().let_play()\n",
        "\n",
        "\n",
        "class FlatEdgesContinuousEvolution(ShowEvolvingTempGraphWithArrows):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 30,\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_clock()\n",
        "        self.add_rod()\n",
        "        self.initialize_updaters()\n",
        "        self.add_boundary_lines()\n",
        "        self.let_play()\n",
        "\n",
        "    def add_boundary_lines(self):\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        lines.set_width(1.5)\n",
        "        lines.set_stroke(WHITE, 5, opacity=0.5)\n",
        "        lines.add_updater(self.update_lines)\n",
        "\n",
        "        turn_animation_into_updater(\n",
        "            ShowCreation(lines, run_time=2)\n",
        "        )\n",
        "        self.add(lines)\n",
        "\n",
        "    def update_lines(self, lines):\n",
        "        graph = self.graph\n",
        "        lines[0].move_to(graph.get_start())\n",
        "        lines[1].move_to(graph.get_end())\n",
        "\n",
        "    def initial_function(self, x):\n",
        "        return ShowEvolvingTempGraphWithArrows.initial_function(self, x)\n",
        "\n",
        "\n",
        "class MoreAccurateTempFlowWithArrows(ShowEvolvingTempGraphWithArrows):\n",
        "    CONFIG = {\n",
        "        \"arrow_scale_factor\": 1,\n",
        "        \"max_magnitude\": 1,\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def setup_axes(self):\n",
        "        super().setup_axes()\n",
        "        y_axis = self.axes.y_axis\n",
        "        y_axis.remove(y_axis.label)\n",
        "\n",
        "\n",
        "class SlopeToHeatFlow(FlatEdgesContinuousEvolution):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 20,\n",
        "        \"xs\": [1.75, 5.25, 7.8],\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 10,\n",
        "            \"x_axis_config\": {\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        },\n",
        "        \"n_arrows\": 10,\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_rod()\n",
        "        #\n",
        "        self.show_slope_labels()\n",
        "        self.show_heat_flow()\n",
        "\n",
        "    def show_slope_labels(self):\n",
        "        axes = self.axes\n",
        "        # axes.x_axis.add_numbers()\n",
        "        graph = self.graph\n",
        "        xs = self.xs\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            TangentLine(\n",
        "                graph,\n",
        "                inverse_interpolate(\n",
        "                    axes.x_min,\n",
        "                    axes.x_max,\n",
        "                    x\n",
        "                ),\n",
        "                length=2,\n",
        "                stroke_opacity=0.75,\n",
        "            )\n",
        "            for x in xs\n",
        "        ])\n",
        "\n",
        "        slope_words = VGroup()\n",
        "        for line in lines:\n",
        "            slope = line.get_slope()\n",
        "            word = OldTexText(\n",
        "                \"Slope =\",\n",
        "                \"${:.2}$\".format(slope)\n",
        "            )\n",
        "            if slope > 0:\n",
        "                word[1].set_color(GREEN)\n",
        "            else:\n",
        "                word[1].set_color(RED)\n",
        "\n",
        "            word.set_width(line.get_length())\n",
        "            word.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "            word.rotate(\n",
        "                line.get_angle(),\n",
        "                about_point=ORIGIN,\n",
        "            )\n",
        "            word.shift(line.get_center())\n",
        "            slope_words.add(word)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(Write, slope_words),\n",
        "            lag_ratio=0.5,\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.lines = lines\n",
        "        self.slope_words = slope_words\n",
        "\n",
        "    def show_heat_flow(self):\n",
        "        axes = self.axes\n",
        "        xs = self.xs\n",
        "        slope_words = self.slope_words\n",
        "        tan_lines = self.lines\n",
        "\n",
        "        slopes = map(Line.get_slope, self.lines)\n",
        "        flow_rates = [-s for s in slopes]\n",
        "\n",
        "        points = list(map(axes.x_axis.n2p, xs))\n",
        "        v_lines = VGroup(*[\n",
        "            Line(\n",
        "                line.get_center(), point,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "            for point, line in zip(points, tan_lines)\n",
        "        ])\n",
        "\n",
        "        flow_words = VGroup(*[\n",
        "            OldTexText(\"Heat flow\").next_to(\n",
        "                point, DOWN\n",
        "            ).scale(0.8)\n",
        "            for point in points\n",
        "        ])\n",
        "        flow_mobjects = VGroup(*[\n",
        "            self.get_flow(x, flow_rate)\n",
        "            for x, flow_rate in zip(xs, flow_rates)\n",
        "        ])\n",
        "\n",
        "        self.add(flow_mobjects)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(\n",
        "                    sw[0], fw[0]\n",
        "                )\n",
        "                for sw, fw in zip(slope_words, flow_words)\n",
        "            ]),\n",
        "            LaggedStartMap(ShowCreation, v_lines),\n",
        "            lag_ratio=0.4,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(self.wait_time)\n",
        "\n",
        "    def get_flow(self, x, flow_rate):\n",
        "        return VGroup(*[\n",
        "            self.get_single_flow_arrow(\n",
        "                x, flow_rate,\n",
        "                t_offset=to\n",
        "            )\n",
        "            for to in np.linspace(0, 5, self.n_arrows)\n",
        "        ])\n",
        "\n",
        "    def get_single_flow_arrow(self, x, flow_rate, t_offset):\n",
        "        axes = self.axes\n",
        "        point = axes.x_axis.n2p(x)\n",
        "\n",
        "        h_shift = 0.5\n",
        "        v_shift = 0.4 * np.random.random() + 0.1\n",
        "\n",
        "        arrow = Vector(0.5 * RIGHT * np.sign(flow_rate))\n",
        "        arrow.move_to(point)\n",
        "        arrow.shift(v_shift * UP)\n",
        "        lp = arrow.get_center() + h_shift * LEFT\n",
        "        rp = arrow.get_center() + h_shift * RIGHT\n",
        "        lc = self.rod_point_to_color(lp)\n",
        "        rc = self.rod_point_to_color(rp)\n",
        "\n",
        "        run_time = 3 / flow_rate\n",
        "        animation = UpdateFromAlphaFunc(\n",
        "            arrow,\n",
        "            lambda m, a: m.move_to(\n",
        "                interpolate(lp, rp, a)\n",
        "            ).set_color(\n",
        "                interpolate_color(lc, rc, a)\n",
        "            ).set_opacity(there_and_back(a)),\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        result = cycle_animation(animation)\n",
        "        animation.total_time += t_offset\n",
        "        return result\n",
        "\n",
        "\n",
        "class CloserLookAtStraightLine(SimulateLinearGraph):\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_clock()\n",
        "        self.add_rod()\n",
        "        # self.initialize_updaters()\n",
        "        #\n",
        "        self.show_t_eq_0_state()\n",
        "        self.show_t_gt_0_state()\n",
        "\n",
        "    def show_t_eq_0_state(self):\n",
        "        t_eq = OldTex(\"t\", \"=\", \"0\")\n",
        "        t_eq.next_to(self.time_label, DOWN)\n",
        "\n",
        "        circles = VGroup(*[\n",
        "            Circle(\n",
        "                radius=0.25,\n",
        "                stroke_color=YELLOW,\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        circles.add_updater(self.attach_to_endpoints)\n",
        "\n",
        "        self.play(Write(t_eq))\n",
        "        self.play(ShowCreation(circles))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(circles))\n",
        "\n",
        "        self.circles = circles\n",
        "        self.t_eq = t_eq\n",
        "\n",
        "    def show_t_gt_0_state(self):\n",
        "        # circles = self.circles\n",
        "        t_eq = self.t_eq\n",
        "\n",
        "        t_ineq = OldTex(\"t\", \">\", \"0\")\n",
        "        t_ineq.move_to(t_eq)\n",
        "\n",
        "        slope_lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        slope_lines.set_opacity(0.5)\n",
        "        slope_lines.add_updater(self.attach_to_endpoints)\n",
        "\n",
        "        self.remove(t_eq)\n",
        "        self.add(t_ineq)\n",
        "\n",
        "        self.initialize_updaters()\n",
        "        self.run_clock(0.1)\n",
        "        for mob in self.mobjects:\n",
        "            mob.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "        self.add(slope_lines)\n",
        "        self.add(self.clock, self.time_label, t_ineq)\n",
        "        self.play(ShowCreation(slope_lines))\n",
        "        for mob in self.mobjects:\n",
        "            mob.resume_updating()\n",
        "\n",
        "        self.run_clock(self.wait_time)\n",
        "\n",
        "    #\n",
        "    def attach_to_endpoints(self, mobs):\n",
        "        points = [\n",
        "            self.graph.get_start(),\n",
        "            self.graph.get_end(),\n",
        "        ]\n",
        "        for mob, point in zip(mobs, points):\n",
        "            mob.move_to(point)\n",
        "        return mobs\n",
        "\n",
        "\n",
        "class ManipulateSinExpSurface(TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"z_max\": 1.25,\n",
        "            \"z_min\": -1.25,\n",
        "            \"z_axis_config\": {\n",
        "                \"unit_size\": 2.5,\n",
        "                \"tick_frequency\": 0.5,\n",
        "            },\n",
        "            \"x_axis_config\": {\n",
        "                # \"unit_size\": 1.5,\n",
        "                \"unit_size\": 1.0,\n",
        "                \"tick_frequency\": 1,\n",
        "            },\n",
        "            \"x_max\": 10,\n",
        "            \"y_max\": 15,\n",
        "        },\n",
        "        \"alpha\": 0.2,\n",
        "        \"tex_mobject_config\": {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{x}\": GREEN,\n",
        "                \"{t}\": YELLOW,\n",
        "                \"\\\\omega\": MAROON_B,\n",
        "                \"^2\": WHITE,\n",
        "            },\n",
        "        },\n",
        "        \"graph_config\": {},\n",
        "        \"initial_phi\": -90 * DEGREES,\n",
        "        \"initial_omega\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_sine_wave()\n",
        "        self.shift_sine_to_cosine()\n",
        "        self.show_derivatives_of_cos()\n",
        "        self.show_cos_exp_surface()\n",
        "        self.change_frequency()\n",
        "        self.talk_through_omega()\n",
        "        self.show_cos_omega_derivatives()\n",
        "        self.show_rebalanced_exp()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.get_three_d_axes(include_numbers=True)\n",
        "        axes.x_axis.remove(axes.x_axis.numbers)\n",
        "        L = OldTex(\"L\")\n",
        "        L.rotate(90 * DEGREES, RIGHT)\n",
        "        L.next_to(axes.x_axis.get_end(), IN)\n",
        "        axes.x_axis.label = L\n",
        "        axes.x_axis.add(L)\n",
        "\n",
        "        axes.shift(5 * LEFT + 0.5 * IN)\n",
        "        axes.z_axis.label[0].remove(\n",
        "            *axes.z_axis.label[0][1:]\n",
        "        )\n",
        "        axes.z_axis.label.next_to(\n",
        "            axes.z_axis.get_end(), OUT\n",
        "        )\n",
        "        axes.z_axis.add_numbers(\n",
        "            *np.arange(-1, 1.5, 0.5),\n",
        "            direction=LEFT,\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "        for number in axes.z_axis.numbers:\n",
        "            number.rotate(90 * DEGREES, RIGHT)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=90 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "            distance=100,\n",
        "        )\n",
        "\n",
        "        self.add(axes)\n",
        "        self.remove(axes.y_axis)\n",
        "        self.axes = axes\n",
        "\n",
        "    def add_sine_wave(self):\n",
        "        self.initialize_parameter_trackers()\n",
        "        graph = self.get_graph()\n",
        "        sin_label = OldTex(\n",
        "            \"\\\\sin\\\\left({x}\\\\right)\",\n",
        "            **self.tex_mobject_config,\n",
        "        )\n",
        "        sin_label.shift(2 * LEFT + 2.75 * UP)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(sin_label)\n",
        "        graph.suspend_updating()\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(sin_label),\n",
        "        )\n",
        "        graph.resume_updating()\n",
        "        self.wait()\n",
        "\n",
        "        self.sin_label = sin_label\n",
        "        self.graph = graph\n",
        "\n",
        "    def shift_sine_to_cosine(self):\n",
        "        graph = self.graph\n",
        "        sin_label = self.sin_label\n",
        "\n",
        "        sin_cross = Cross(sin_label)\n",
        "        sin_cross.add_updater(\n",
        "            lambda m: m.move_to(sin_label)\n",
        "        )\n",
        "        cos_label = OldTex(\n",
        "            \"\\\\cos\\\\left({x}\\\\right)\",\n",
        "            **self.tex_mobject_config,\n",
        "        )\n",
        "        cos_label.move_to(sin_label, LEFT)\n",
        "        cos_label.shift(LEFT)\n",
        "        # cos_label.shift(\n",
        "        #     axes.c2p(0, 0) - axes.c2p(PI / 2, 0),\n",
        "        # )\n",
        "\n",
        "        left_tangent = Line(ORIGIN, RIGHT)\n",
        "        left_tangent.set_stroke(WHITE, 5)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(cos_label)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.phi_tracker.set_value, 0,\n",
        "            ),\n",
        "            FadeOut(sin_label, LEFT),\n",
        "            FadeIn(cos_label, RIGHT),\n",
        "            run_time=2,\n",
        "        )\n",
        "        left_tangent.move_to(graph.get_start(), LEFT)\n",
        "        self.play(ShowCreation(left_tangent))\n",
        "        self.play(FadeOut(left_tangent))\n",
        "\n",
        "        self.cos_label = cos_label\n",
        "\n",
        "    def show_derivatives_of_cos(self):\n",
        "        cos_label = self.cos_label\n",
        "        cos_exp_label = OldTex(\n",
        "            \"\\\\cos\\\\left({x}\\\\right)\",\n",
        "            \"e^{-\\\\alpha {t}}\",\n",
        "            **self.tex_mobject_config\n",
        "        )\n",
        "        cos_exp_label.move_to(cos_label, LEFT)\n",
        "\n",
        "        ddx_group, ddx_exp_group = [\n",
        "            self.get_ddx_computation_group(\n",
        "                label,\n",
        "                *[\n",
        "                    OldTex(\n",
        "                        s + \"\\\\left({x}\\\\right)\" + exp,\n",
        "                        **self.tex_mobject_config,\n",
        "                    )\n",
        "                    for s in [\"-\\\\sin\", \"-\\\\cos\"]\n",
        "                ]\n",
        "            )\n",
        "            for label, exp in [\n",
        "                (cos_label, \"\"),\n",
        "                (cos_exp_label, \"e^{-\\\\alpha {t}}\"),\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(ddx_group)\n",
        "        self.play(FadeIn(ddx_group))\n",
        "        self.wait()\n",
        "\n",
        "        # Cos exp\n",
        "        transforms = [\n",
        "            ReplacementTransform(\n",
        "                cos_label, cos_exp_label,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                ddx_group, ddx_exp_group,\n",
        "            ),\n",
        "        ]\n",
        "        for trans in transforms:\n",
        "            trans.begin()\n",
        "            self.add_fixed_in_frame_mobjects(trans.mobject)\n",
        "        self.play(*transforms)\n",
        "        self.add_fixed_in_frame_mobjects(\n",
        "            cos_exp_label, ddx_exp_group\n",
        "        )\n",
        "        self.remove_fixed_in_frame_mobjects(\n",
        "            cos_label,\n",
        "            *[\n",
        "                trans.mobject\n",
        "                for trans in transforms\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.cos_exp_label = cos_exp_label\n",
        "        self.ddx_exp_group = ddx_exp_group\n",
        "\n",
        "    def show_cos_exp_surface(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        surface = self.get_cos_exp_surface()\n",
        "        self.add(surface)\n",
        "        surface.max_t_tracker.set_value(0)\n",
        "        self.move_camera(\n",
        "            phi=85 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "            added_anims=[\n",
        "                ApplyMethod(\n",
        "                    surface.max_t_tracker.set_value,\n",
        "                    axes.y_max,\n",
        "                    run_time=4,\n",
        "                ),\n",
        "                Write(axes.y_axis),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.surface = surface\n",
        "\n",
        "    def change_frequency(self):\n",
        "        cos_exp_label = self.cos_exp_label\n",
        "        ddx_exp_group = self.ddx_exp_group\n",
        "        omega_tracker = self.omega_tracker\n",
        "\n",
        "        cos_omega = OldTex(\n",
        "            \"\\\\cos\\\\left(\",\n",
        "            \"\\\\omega\", \"\\\\cdot\", \"{x}\",\n",
        "            \"\\\\right)\",\n",
        "            **self.tex_mobject_config\n",
        "        )\n",
        "        cos_omega.move_to(cos_exp_label, LEFT)\n",
        "\n",
        "        omega = cos_omega.get_part_by_tex(\"\\\\omega\")\n",
        "        brace = Brace(omega, UP, buff=SMALL_BUFF)\n",
        "        omega_decimal = always_redraw(\n",
        "            lambda: DecimalNumber(\n",
        "                omega_tracker.get_value(),\n",
        "                color=omega.get_color(),\n",
        "            ).next_to(brace, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(\n",
        "            cos_omega,\n",
        "            brace,\n",
        "            omega_decimal,\n",
        "        )\n",
        "        self.play(\n",
        "            self.camera.phi_tracker.set_value, 90 * DEGREES,\n",
        "            self.camera.theta_tracker.set_value, -90 * DEGREES,\n",
        "            FadeOut(self.surface),\n",
        "            FadeOut(self.axes.y_axis),\n",
        "            FadeOut(cos_exp_label),\n",
        "            FadeOut(ddx_exp_group),\n",
        "            FadeIn(cos_omega),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeInFromDown(omega_decimal)\n",
        "        )\n",
        "        for n in [2, 6, 1, 4]:\n",
        "            freq = n * PI / self.axes.x_max\n",
        "            self.play(\n",
        "                omega_tracker.set_value, freq,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.cos_omega = cos_omega\n",
        "        self.omega_brace = brace\n",
        "\n",
        "    def talk_through_omega(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        x_tracker = ValueTracker(0)\n",
        "        get_x = x_tracker.get_value\n",
        "        v_line = always_redraw(lambda: DashedLine(\n",
        "            axes.c2p(get_x(), 0, 0),\n",
        "            axes.c2p(get_x(), 0, self.func(get_x(), 0)),\n",
        "        ))\n",
        "\n",
        "        x = self.cos_omega.get_part_by_tex(\"{x}\")\n",
        "        brace = Brace(x, DOWN)\n",
        "        x_decimal = always_redraw(\n",
        "            lambda: DecimalNumber(\n",
        "                get_x(),\n",
        "                color=x.get_color()\n",
        "            ).next_to(brace, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.add(v_line)\n",
        "        self.add_fixed_in_frame_mobjects(brace, x_decimal)\n",
        "        self.play(\n",
        "            x_tracker.set_value, 5,\n",
        "            run_time=5,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(v_line),\n",
        "            FadeOut(brace),\n",
        "            FadeOut(x_decimal),\n",
        "        )\n",
        "        self.remove_fixed_in_frame_mobjects(\n",
        "            brace, x_decimal\n",
        "        )\n",
        "\n",
        "    def show_cos_omega_derivatives(self):\n",
        "        cos_omega = self.cos_omega\n",
        "        ddx_omega_group = self.get_ddx_computation_group(\n",
        "            cos_omega,\n",
        "            *[\n",
        "                OldTex(\n",
        "                    s + \"\\\\left(\\\\omega \\\\cdot {x}\\\\right)\",\n",
        "                    **self.tex_mobject_config,\n",
        "                )\n",
        "                for s in [\"-\\\\omega \\\\sin\", \"-\\\\omega^2 \\\\cos\"]\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        omega_squared = ddx_omega_group[-1][1:3]\n",
        "        rect = SurroundingRectangle(omega_squared)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(ddx_omega_group)\n",
        "        self.play(FadeIn(ddx_omega_group))\n",
        "        self.wait()\n",
        "        self.add_fixed_in_frame_mobjects(rect)\n",
        "        self.play(ShowCreationThenFadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.ddx_omega_group = ddx_omega_group\n",
        "\n",
        "    def show_rebalanced_exp(self):\n",
        "        cos_omega = self.cos_omega\n",
        "        ddx_omega_group = self.ddx_omega_group\n",
        "\n",
        "        cos_exp = OldTex(\n",
        "            \"\\\\cos\\\\left(\",\n",
        "            \"\\\\omega\", \"\\\\cdot\", \"{x}\",\n",
        "            \"\\\\right)\",\n",
        "            \"e^{-\\\\alpha \\\\omega^2 {t}}\",\n",
        "            **self.tex_mobject_config\n",
        "        )\n",
        "        cos_exp.move_to(cos_omega, DL)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(cos_exp)\n",
        "        self.play(\n",
        "            FadeOut(cos_omega),\n",
        "            FadeOut(ddx_omega_group),\n",
        "            FadeIn(cos_exp),\n",
        "        )\n",
        "        self.remove_fixed_in_frame_mobjects(\n",
        "            cos_omega,\n",
        "            ddx_omega_group,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(self.surface),\n",
        "            FadeIn(self.axes.y_axis),\n",
        "            VGroup(\n",
        "                cos_exp,\n",
        "                self.omega_brace,\n",
        "            ).shift, 4 * RIGHT,\n",
        "            self.camera.phi_tracker.set_value, 80 * DEGREES,\n",
        "            self.camera.theta_tracker.set_value, -80 * DEGREES,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.omega_tracker.set_value, TAU / 10,\n",
        "            run_time=6,\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def initialize_parameter_trackers(self):\n",
        "        self.phi_tracker = ValueTracker(\n",
        "            self.initial_phi\n",
        "        )\n",
        "        self.omega_tracker = ValueTracker(\n",
        "            self.initial_omega\n",
        "        )\n",
        "        self.t_tracker = ValueTracker(0)\n",
        "\n",
        "    def get_graph(self):\n",
        "        return always_redraw(\n",
        "            lambda: self.get_time_slice_graph(\n",
        "                self.axes, self.func,\n",
        "                t=self.t_tracker.get_value(),\n",
        "                **self.graph_config\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def get_cos_exp_surface(self):\n",
        "        max_t_tracker = ValueTracker(self.axes.y_max)\n",
        "        surface = always_redraw(\n",
        "            lambda: self.get_surface(\n",
        "                self.axes,\n",
        "                self.func,\n",
        "                v_max=max_t_tracker.get_value(),\n",
        "            )\n",
        "        )\n",
        "        surface.max_t_tracker = max_t_tracker\n",
        "        return surface\n",
        "\n",
        "    def func(self, x, t):\n",
        "        phi = self.phi_tracker.get_value()\n",
        "        omega = self.omega_tracker.get_value()\n",
        "        alpha = self.alpha\n",
        "        return op.mul(\n",
        "            np.cos(omega * (x + phi)),\n",
        "            np.exp(-alpha * (omega**2) * t)\n",
        "        )\n",
        "\n",
        "    def get_ddx_computation_group(self, f, df, ddf):\n",
        "        arrows = VGroup(*[\n",
        "            Vector(0.5 * RIGHT) for x in range(2)\n",
        "        ])\n",
        "        group = VGroup(\n",
        "            arrows[0], df, arrows[1], ddf\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "        group.next_to(f, RIGHT)\n",
        "\n",
        "        for arrow in arrows:\n",
        "            label = OldTex(\n",
        "                \"\\\\partial \\\\over \\\\partial {x}\",\n",
        "                **self.tex_mobject_config,\n",
        "            )\n",
        "            label.scale(0.5)\n",
        "            label.next_to(arrow, UP, SMALL_BUFF)\n",
        "            arrow.add(label)\n",
        "\n",
        "        group.arrows = arrows\n",
        "        group.funcs = VGroup(df, ddf)\n",
        "\n",
        "        return group\n",
        "\n",
        "\n",
        "class ShowFreq1CosExpDecay(ManipulateSinExpSurface):\n",
        "    CONFIG = {\n",
        "        \"freq\": 1,\n",
        "        \"alpha\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_back_y_axis()\n",
        "        self.initialize_parameter_trackers()\n",
        "        self.phi_tracker.set_value(0)\n",
        "        self.omega_tracker.set_value(\n",
        "            self.freq * TAU / 10,\n",
        "        )\n",
        "        #\n",
        "        self.show_decay()\n",
        "\n",
        "    def add_back_y_axis(self):\n",
        "        axes = self.axes\n",
        "        self.add(axes.y_axis)\n",
        "        self.remove(axes.y_axis.numbers)\n",
        "        self.remove(axes.y_axis.label)\n",
        "\n",
        "    def show_decay(self):\n",
        "        axes = self.axes\n",
        "        t_tracker = self.t_tracker\n",
        "        t_max = self.axes.y_max\n",
        "\n",
        "        graph = always_redraw(\n",
        "            lambda: self.get_time_slice_graph(\n",
        "                axes,\n",
        "                self.func,\n",
        "                t=t_tracker.get_value(),\n",
        "                stroke_width=5,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        surface = self.get_surface(\n",
        "            self.axes, self.func,\n",
        "        )\n",
        "        plane = self.get_const_time_plane(axes)\n",
        "\n",
        "        self.add(surface, plane, graph)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-85 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "        self.play(\n",
        "            t_tracker.set_value, t_max,\n",
        "            plane.t_tracker.set_value, t_max,\n",
        "            run_time=t_max,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowFreq2CosExpDecay(ShowFreq1CosExpDecay):\n",
        "    CONFIG = {\n",
        "        \"freq\": 2,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowFreq4CosExpDecay(ShowFreq1CosExpDecay):\n",
        "    CONFIG = {\n",
        "        \"freq\": 4,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowHarmonics(SimulateRealSineCurve):\n",
        "    CONFIG = {\n",
        "        \"rod_opacity\": 0.75,\n",
        "        \"initial_omega\": 1.27,\n",
        "        \"default_n_rod_pieces\": 32,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_rod()\n",
        "        self.rod.add_updater(self.color_rod_by_graph)\n",
        "        #\n",
        "        self.show_formula()\n",
        "\n",
        "    def add_graph(self):\n",
        "        omega_tracker = ValueTracker(self.initial_omega)\n",
        "        get_omega = omega_tracker.get_value\n",
        "        graph = always_redraw(\n",
        "            lambda: self.axes.get_graph(\n",
        "                lambda x: np.cos(get_omega() * x),\n",
        "                x_min=self.graph_x_min,\n",
        "                x_max=self.graph_x_max,\n",
        "                step_size=self.step_size,\n",
        "                discontinuities=[5],\n",
        "            ).color_using_background_image(\"VerticalTempGradient\")\n",
        "        )\n",
        "\n",
        "        self.add(graph)\n",
        "        self.graph = graph\n",
        "        self.omega_tracker = omega_tracker\n",
        "\n",
        "    def show_formula(self):\n",
        "        rod = self.rod\n",
        "        graph = self.graph\n",
        "        axes = self.axes\n",
        "        omega_tracker = self.omega_tracker\n",
        "        L = TAU\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"=\", \"\\\\cos\\\\left(\",\n",
        "            \"2(\\\\pi / L)\", \"\\\\cdot\", \"{x}\",\n",
        "            \"\\\\right)\",\n",
        "            tex_to_color_map={\n",
        "                \"{x}\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        formula.next_to(\n",
        "            self.axes.y_axis.label, RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        omega_part = formula.get_part_by_tex(\"\\\\pi\")\n",
        "        omega_brace = Brace(omega_part, DOWN)\n",
        "        omega = OldTex(\"\\\\omega\")\n",
        "        omega.set_color(MAROON_B)\n",
        "        omega.next_to(omega_brace, DOWN, SMALL_BUFF)\n",
        "        formula.remove(omega_part)\n",
        "\n",
        "        pi_over_L = OldTex(\"(\\\\pi / L)\")\n",
        "        pi_over_L.move_to(omega_part)\n",
        "        pi_over_L.match_color(omega)\n",
        "\n",
        "        self.add(formula)\n",
        "        self.add(omega_brace)\n",
        "        self.add(omega)\n",
        "\n",
        "        self.remove(graph)\n",
        "        self.play(GrowFromEdge(rod, LEFT))\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(axes.x_axis.label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(graph))\n",
        "        self.play(FadeInFromDown(pi_over_L))\n",
        "        self.play(\n",
        "            omega_tracker.set_value, PI / L,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show x\n",
        "        x_tracker = ValueTracker(0)\n",
        "        tip = ArrowTip(\n",
        "            start_angle=-90 * DEGREES,\n",
        "            color=WHITE,\n",
        "        )\n",
        "        tip.add_updater(lambda m: m.move_to(\n",
        "            axes.x_axis.n2p(x_tracker.get_value()),\n",
        "            DOWN,\n",
        "        ))\n",
        "        x_sym = OldTex(\"x\")\n",
        "        x_sym.set_color(GREEN)\n",
        "        x_sym.add_background_rectangle(buff=SMALL_BUFF)\n",
        "        x_sym.add_updater(lambda m: m.next_to(tip, UP, SMALL_BUFF))\n",
        "\n",
        "        self.play(\n",
        "            Write(tip),\n",
        "            Write(x_sym),\n",
        "        )\n",
        "        self.play(\n",
        "            x_tracker.set_value, L,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(\n",
        "            x_sym, formula.get_part_by_tex(\"{x}\")\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeOut(tip),\n",
        "            FadeOut(x_sym),\n",
        "        )\n",
        "\n",
        "        # Harmonics\n",
        "        pi_over_L.generate_target()\n",
        "        n_sym = Integer(2)\n",
        "        n_sym.match_color(pi_over_L)\n",
        "        group = VGroup(n_sym, pi_over_L.target)\n",
        "        group.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        group.move_to(pi_over_L)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(pi_over_L),\n",
        "            FadeInFromDown(n_sym),\n",
        "            ApplyMethod(\n",
        "                omega_tracker.set_value, 2 * PI / L,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in [*range(3, 9), 0]:\n",
        "            new_n_sym = Integer(n)\n",
        "            new_n_sym.move_to(n_sym, DR)\n",
        "            new_n_sym.match_style(n_sym)\n",
        "            self.play(\n",
        "                FadeOut(n_sym, UP),\n",
        "                FadeIn(new_n_sym, DOWN),\n",
        "                omega_tracker.set_value, n * PI / L,\n",
        "            )\n",
        "            self.wait()\n",
        "            n_sym = new_n_sym\n",
        "\n",
        "    #\n",
        "    def add_labels_to_axes(self):\n",
        "        x_axis = self.axes.x_axis\n",
        "        L = OldTex(\"L\")\n",
        "        L.next_to(x_axis.get_end(), DOWN)\n",
        "        x_axis.add(L)\n",
        "        x_axis.label = L\n",
        "\n",
        "\n",
        "class ShowHarmonicSurfaces(ManipulateSinExpSurface):\n",
        "    CONFIG = {\n",
        "        \"alpha\": 0.2,\n",
        "        \"initial_phi\": 0,\n",
        "        \"initial_omega\": PI / 10,\n",
        "        \"n_iterations\": 8,\n",
        "        \"default_surface_config\": {\n",
        "            \"resolution\": (40, 30),\n",
        "            \"surface_piece_config\": {\n",
        "                \"stroke_width\": 0.5,\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.initialize_parameter_trackers()\n",
        "        self.add_surface()\n",
        "        self.add_graph()\n",
        "        self.show_all_harmonic_surfaces()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        super().setup_axes()\n",
        "        self.add(self.axes.y_axis)\n",
        "        self.set_camera_orientation(\n",
        "            phi=82 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "        )\n",
        "\n",
        "    def add_surface(self):\n",
        "        self.surface = self.get_cos_exp_surface()\n",
        "        self.add(self.surface)\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.graph = self.get_graph()\n",
        "        self.add(self.graph)\n",
        "\n",
        "    def show_all_harmonic_surfaces(self):\n",
        "        omega_tracker = self.omega_tracker\n",
        "        formula = self.get_formula(str(1))\n",
        "        L = self.axes.x_max\n",
        "\n",
        "        self.begin_ambient_camera_rotation(rate=0.01)\n",
        "        self.add_fixed_in_frame_mobjects(formula)\n",
        "        self.wait(2)\n",
        "        for n in range(2, self.n_iterations):\n",
        "            if n > 5:\n",
        "                n_str = \"n\"\n",
        "            else:\n",
        "                n_str = str(n)\n",
        "            new_formula = self.get_formula(n_str)\n",
        "            self.play(\n",
        "                Transform(formula, new_formula),\n",
        "                ApplyMethod(\n",
        "                    omega_tracker.set_value,\n",
        "                    n * PI / L\n",
        "                ),\n",
        "            )\n",
        "            self.wait(3)\n",
        "\n",
        "    #\n",
        "    def get_formula(self, n_str):\n",
        "        n_str = \"{\" + n_str + \"}\"\n",
        "        result = OldTex(\n",
        "            \"\\\\cos\\\\left(\",\n",
        "            n_str, \"(\", \"\\\\pi / L\", \")\", \"{x}\"\n",
        "            \"\\\\right)\"\n",
        "            \"e^{-\\\\alpha (\", n_str, \"\\\\pi / L\", \")^2\",\n",
        "            \"{t}}\",\n",
        "            tex_to_color_map={\n",
        "                \"{x}\": GREEN,\n",
        "                \"{t}\": YELLOW,\n",
        "                \"\\\\pi / L\": MAROON_B,\n",
        "                n_str: MAROON_B,\n",
        "            }\n",
        "        )\n",
        "        result.to_edge(UP)\n",
        "        return result\n",
        "\n",
        "\n",
        "class Thumbnail(ShowHarmonicSurfaces):\n",
        "    CONFIG = {\n",
        "        \"default_surface_config\": {\n",
        "            \"resolution\": (40, 30),\n",
        "            # \"resolution\": (10, 10),\n",
        "        },\n",
        "        \"graph_config\": {\n",
        "            \"stroke_width\": 8,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.initialize_parameter_trackers()\n",
        "        self.add_surface()\n",
        "        self.add_graph()\n",
        "        #\n",
        "        self.omega_tracker.set_value(3 * PI / 10)\n",
        "        self.set_camera_orientation(\n",
        "            theta=-70 * DEGREES,\n",
        "        )\n",
        "\n",
        "        axes = self.axes\n",
        "        for axis in [axes.y_axis, axes.z_axis]:\n",
        "            axis.numbers.set_opacity(0)\n",
        "            axis.remove(*axis.numbers)\n",
        "        axes.x_axis.label.set_opacity(0)\n",
        "        axes.z_axis.label.set_opacity(0)\n",
        "\n",
        "        for n in range(2, 16, 2):\n",
        "            new_graph = self.get_time_slice_graph(\n",
        "                axes, self.func, t=n,\n",
        "                **self.graph_config\n",
        "            )\n",
        "            new_graph.set_shade_in_3d(True)\n",
        "            new_graph.set_stroke(\n",
        "                width=8 / np.sqrt(n),\n",
        "                # opacity=1 / n**(1 / 4),\n",
        "            )\n",
        "            self.add(new_graph)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Sine waves + Linearity + Fourier = Solution\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(DOWN)\n",
        "        words.shift(2 * DOWN)\n",
        "        self.add_fixed_in_frame_mobjects(words)\n",
        "\n",
        "        self.camera.frame_center.shift(DOWN)\n",
        "        self.update_mobjects(0)\n",
        "        self.surface.set_stroke(width=0.1)\n",
        "        self.surface.set_fill(opacity=0.2)\n"
    ]
}