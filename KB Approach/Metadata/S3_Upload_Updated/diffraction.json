{
    "topic": "The mathematical concept being demonstrated is the conversion of HSL (Hue, Saturation, Light",
    "code": [
        "from __future__ import annotations\n",
        "from manim_imports_ext import *\n",
        "\n",
        "def hsl_to_rgb(hsl):\n",
        "    \"\"\"\n",
        "    Convert an array of HSL values to RGB.\n",
        "\n",
        "    Args:\n",
        "    hsl (np.ndarray): A numpy array of shape (n, 3), where each row represents an HSL value\n",
        "                      (Hue [0, 1), Saturation [0, 1], Lightness [0, 1]).\n",
        "\n",
        "    Returns:\n",
        "    np.ndarray: An array of shape (n, 3), containing RGB values in the range [0, 1].\n",
        "    \"\"\"\n",
        "    h = hsl[:, 0]\n",
        "    s = hsl[:, 1]\n",
        "    l = hsl[:, 2]\n",
        "\n",
        "    def hue_to_rgb(p, q, t):\n",
        "        t = np.where(t < 0, t + 1, np.where(t > 1, t - 1, t))\n",
        "        return np.where(t < 1/6, p + (q - p) * 6 * t,\n",
        "               np.where(t < 1/2, q,\n",
        "               np.where(t < 2/3, p + (q - p) * (2/3 - t) * 6, p\n",
        "        )))\n",
        "\n",
        "    q = np.where(l < 0.5, l * (1 + s), l + s - l * s)\n",
        "    p = 2 * l - q\n",
        "\n",
        "    r = hue_to_rgb(p, q, h + 1 / 3)\n",
        "    g = hue_to_rgb(p, q, h)\n",
        "    b = hue_to_rgb(p, q, h - 1 / 3)\n",
        "\n",
        "    rgb = np.stack([r, g, b], axis=1)\n",
        "    return rgb\n",
        "\n",
        "\n",
        "class LightWaveSlice(Mobject):\n",
        "    shader_folder: str = str(Path(Path(__file__).parent, \"diffraction_shader\"))\n",
        "    data_dtype: Sequence[Tuple[str, type, Tuple[int]]] = [\n",
        "        ('point', np.float32, (3,)),\n",
        "    ]\n",
        "    render_primitive: int = moderngl.TRIANGLE_STRIP\n",
        "\n",
        "    def __init__(\n",
        "        self,\n",
        "        point_sources: DotCloud,\n",
        "        shape: tuple[float, float] = (8.0, 8.0),\n",
        "        color: ManimColor = BLUE_D,\n",
        "        opacity: float = 1.0,\n",
        "        frequency: float = 1.0,\n",
        "        wave_number: float = 1.0,\n",
        "        max_amp: Optional[float] = None,\n",
        "        decay_factor: float = 0.5,\n",
        "        show_intensity: bool = False,\n",
        "        **kwargs\n",
        "    ):\n",
        "        self.shape = shape\n",
        "        self.point_sources = point_sources\n",
        "        self._is_paused = False\n",
        "        super().__init__(**kwargs)\n",
        "\n",
        "        if max_amp is None:\n",
        "            max_amp = point_sources.get_num_points()\n",
        "        self.set_uniforms(dict(\n",
        "            frequency=frequency,\n",
        "            wave_number=wave_number,\n",
        "            max_amp=max_amp,\n",
        "            time=0,\n",
        "            decay_factor=decay_factor,\n",
        "            show_intensity=float(show_intensity),\n",
        "            time_rate=1.0,\n",
        "        ))\n",
        "        self.set_color(color, opacity)\n",
        "\n",
        "        self.add_updater(lambda m, dt: m.increment_time(dt))\n",
        "        self.always.sync_points()\n",
        "        self.apply_depth_test()\n",
        "\n",
        "    def init_data(self) -> None:\n",
        "        super().init_data(length=4)\n",
        "        self.data[\"point\"][:] = [UL, DL, UR, DR]\n",
        "\n",
        "    def init_points(self) -> None:\n",
        "        self.set_shape(*self.shape)\n",
        "\n",
        "    def set_color(\n",
        "        self,\n",
        "        color: ManimColor | Iterable[ManimColor] | None,\n",
        "        opacity: float | Iterable[float] | None = None,\n",
        "        recurse=False,\n",
        "    ) -> Self:\n",
        "        if color is not None:\n",
        "            self.set_uniform(color=color_to_rgb(color))\n",
        "        if opacity is not None:\n",
        "            self.set_uniform(opacity=opacity)\n",
        "        return self\n",
        "\n",
        "    def set_opacity(self, opacity: float, recurse=False):\n",
        "        self.set_uniform(opacity=opacity)\n",
        "        return self\n",
        "\n",
        "    def set_wave_number(self, wave_number: float):\n",
        "        self.set_uniform(wave_number=wave_number)\n",
        "        return self\n",
        "\n",
        "    def set_frequency(self, frequency: float):\n",
        "        self.set_uniform(frequency=frequency)\n",
        "        return self\n",
        "\n",
        "    def set_max_amp(self, max_amp: float):\n",
        "        self.set_uniform(max_amp=max_amp)\n",
        "        return self\n",
        "\n",
        "    def set_decay_factor(self, decay_factor: float):\n",
        "        self.set_uniform(decay_factor=decay_factor)\n",
        "        return self\n",
        "\n",
        "    def set_time_rate(self, time_rate: float):\n",
        "        self.set_uniform(time_rate=time_rate)\n",
        "        return self\n",
        "\n",
        "    def set_sources(self, point_sources: DotCloud):\n",
        "        self.point_sources = point_sources\n",
        "        return self\n",
        "\n",
        "    def sync_points(self):\n",
        "        sources: DotCloud = self.point_sources\n",
        "        for n, point in enumerate(sources.get_points()):\n",
        "            self.set_uniform(**{f\"point_source{n}\": point})\n",
        "        self.set_uniform(n_sources=sources.get_num_points())\n",
        "        return self\n",
        "\n",
        "    def increment_time(self, dt):\n",
        "        self.uniforms[\"time\"] += self.uniforms[\"time_rate\"] * dt\n",
        "        return self\n",
        "\n",
        "    def show_intensity(self, show: bool = True):\n",
        "        self.set_uniform(show_intensity=float(show))\n",
        "\n",
        "    def pause(self):\n",
        "        self.set_uniform(time_rate=0)\n",
        "        return self\n",
        "\n",
        "    def unpause(self):\n",
        "        self.set_uniform(time_rate=1)\n",
        "        return self\n",
        "\n",
        "    def interpolate(\n",
        "        self,\n",
        "        wave1: LightWaveSlice,\n",
        "        wave2: LightWaveSlice,\n",
        "        alpha: float,\n",
        "        path_func: Callable[[np.ndarray, np.ndarray, float], np.ndarray] = straight_path\n",
        "    ) -> Self:\n",
        "        self.locked_uniform_keys.add(\"time\")\n",
        "        super().interpolate(wave1, wave2, alpha, path_func)\n",
        "\n",
        "    def wave_func(self, points):\n",
        "        time = self.uniforms[\"time\"]\n",
        "        wave_number = self.uniforms[\"wave_number\"]\n",
        "        frequency = self.uniforms[\"frequency\"]\n",
        "        decay_factor = self.uniforms[\"decay_factor\"]\n",
        "\n",
        "        values = np.zeros(len(points))\n",
        "        for source_point in self.point_sources.get_points():\n",
        "            dists = np.linalg.norm(points - source_point, axis=1)\n",
        "            values += np.cos(TAU * (wave_number * dists - frequency * time)) * (dists + 1)**(-decay_factor)\n",
        "        return values\n",
        "\n",
        "\n",
        "class LightIntensity(LightWaveSlice):\n",
        "    def __init__(\n",
        "        self,\n",
        "        *args,\n",
        "        color: ManimColor = BLUE,\n",
        "        show_intensity: bool = True,\n",
        "        **kwargs\n",
        "    ):\n",
        "        super().__init__(*args, color=color, show_intensity=show_intensity, **kwargs)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class LightFieldAroundScene(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add scene\n",
        "        frame = self.frame\n",
        "        folder = \"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2024/holograms/Paul Animations/LightFieldDraft\"\n",
        "        scene, scene_top, lamp = group = Group(\n",
        "            ImageMobject(os.path.join(folder, \"LightFieldScene\")),\n",
        "            ImageMobject(os.path.join(folder, \"TopHalfCutoff\")),\n",
        "            ImageMobject(os.path.join(folder, \"Lamp\")),\n",
        "        )\n",
        "        group.set_height(7)\n",
        "        group.to_edge(RIGHT)\n",
        "\n",
        "        light_point = scene.get_corner(UL) + 1.6 * RIGHT + 0.8 * DOWN\n",
        "        scene_point = scene.get_center() + 0.8 * RIGHT + 0.4 * DOWN\n",
        "\n",
        "        frame.reorient(0, 0, 0, (3.44, -0.2, 0.0), 4.78)\n",
        "        self.add(scene)\n",
        "        self.play(FadeIn(scene, 0.25 * UP))\n",
        "        self.wait()\n",
        "\n",
        "        # Add light\n",
        "        line = Line(light_point, scene_point)\n",
        "        n_dots = 50\n",
        "        light = Group(\n",
        "            GlowDot(line.pfp(a), color=WHITE, radius=interpolate(0.5, 4, a), opacity=3 / n_dots)\n",
        "            for a in np.linspace(0, 1, n_dots)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(lamp, time_span=(1, 3)),\n",
        "            FadeIn(light, lag_ratio=0.2, time_span=(1, 3)),\n",
        "            frame.animate.reorient(0, 0, 0, (3.64, 0.68, 0.0), 5.30),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Set up wave\n",
        "        sources = DotCloud([\n",
        "            (2.42, -0.27, 0.0),\n",
        "            (1.96, -0.14, 0.0),\n",
        "            (2.11, 0.05, 0.0),\n",
        "            (2.51, 0.16, 0.0),\n",
        "            (2.75, 0.07, 0.0),\n",
        "            (3.19, 0.41, 0.0),\n",
        "            (3.48, 0.39, 0.0),\n",
        "            (4.81, 0.28, 0.0),\n",
        "            (5.1, 0.22, 0.0),\n",
        "            (5.53, -0.04, 0.0),\n",
        "            (5.8, -0.18, 0.0),\n",
        "            (4.87, -0.58, 0.0),\n",
        "            (4.71, -0.68, 0.0),\n",
        "            (4.28, -0.61, 0.0),\n",
        "            (3.92, -0.51, 0.0),\n",
        "            (4.18, -0.27, 0.0),\n",
        "            (3.8, 0.09, 0.0),\n",
        "            (3.55, 0.23, 0.0),\n",
        "            (2.43, 0.7, 0.0),\n",
        "            (2.43, 0.7, 0.0),\n",
        "            (3.71, 0.51, 0.0),\n",
        "            (3.94, -0.49, 0.0),\n",
        "            (1.9, -0.3, 0.0),\n",
        "            (2.61, 0.06, 0.0),\n",
        "            (2.92, 0.23, 0.0),\n",
        "            (3.25, 0.38, 0.0),\n",
        "        ])\n",
        "        wave = LightWaveSlice(sources)\n",
        "        wave.set_max_amp(math.sqrt(30))\n",
        "        wave.set_shape(50, 100)\n",
        "        wave.rotate(70 * DEGREES, LEFT)\n",
        "        wave.set_wave_number(4)\n",
        "        wave.set_frequency(1)\n",
        "\n",
        "        n_perp_waves = 10\n",
        "        perp_waves = Group(wave.copy().rotate(PI / 2, RIGHT).shift(z * OUT) for z in np.linspace(-1, 1, n_perp_waves))\n",
        "        perp_waves.set_opacity(0.1)\n",
        "\n",
        "        self.add(scene, wave, perp_waves, scene_top, lamp, light)\n",
        "        self.play(\n",
        "            FadeIn(wave),\n",
        "            FadeIn(perp_waves),\n",
        "            light.animate.set_opacity(2 / n_dots),\n",
        "            scene.animate.set_opacity(0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Slow zoom out\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Linger\n",
        "        self.wait(12)\n",
        "\n",
        "        # Reflection\n",
        "        if False:\n",
        "            self.remove(light)\n",
        "            self.remove(lamp)\n",
        "            self.frame.set_theta(-10 * DEGREES).set_y(0.5)\n",
        "            scene_top.set_opacity(0.5)\n",
        "            self.wait(12)\n",
        "\n",
        "        # Show an observer\n",
        "        eye_dot = GlowDot(1.0 * LEFT, radius=0.5, color=WHITE)\n",
        "\n",
        "        self.play(FadeIn(eye_dot))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            eye_dot.animate.move_to(1.5 * LEFT + 2 * DOWN).set_anim_args(path_arc=45 * DEGREES),\n",
        "            run_time=12,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.play(FadeOut(eye_dot))\n",
        "\n",
        "        # Show recreation\n",
        "        right_rect = FullScreenRectangle().set_fill(BLACK, 1)\n",
        "        right_rect.stretch(0.35, 0, about_edge=RIGHT)\n",
        "        film_rect = Rectangle()\n",
        "        film_rect.set_fill(interpolate_color(RED_E, BLACK, 0.8), 1).set_stroke(WHITE, 1)\n",
        "        film_rect.rotate(80 * DEGREES, UP)\n",
        "        film_rect.rotate(20 * DEGREES, RIGHT)\n",
        "        film_rect.move_to(right_rect.get_left())\n",
        "\n",
        "        laser_point = RIGHT_SIDE + RIGHT\n",
        "        laser_light = VGroup(\n",
        "            Line(laser_point, film_rect.pfp(a + random.random() / 250))\n",
        "            for a in np.linspace(0, 1, 250)\n",
        "        )\n",
        "        laser_light.set_stroke(GREEN_SCREEN, (0, 1), 0.2)\n",
        "        laser_light.shuffle()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(lamp),\n",
        "            FadeOut(light),\n",
        "            FadeOut(scene),\n",
        "            FadeOut(scene_top),\n",
        "            FadeIn(right_rect),\n",
        "            FadeIn(film_rect),\n",
        "        )\n",
        "        self.play(ShowCreation(laser_light, lag_ratio=0.001))\n",
        "        self.wait(12)\n",
        "        self.wait(2)  # Just in case\n",
        "\n",
        "\n",
        "class DiffractionGratingScene(InteractiveScene):\n",
        "    light_position = 10 * DOWN + 5 * OUT + 3 * LEFT\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.camera.light_source.move_to(self.light_position)\n",
        "\n",
        "    def get_wall_with_slits(self, n_slits, spacing=1.0, slit_width=0.1, height=0.25, depth=3.0, total_width=40, color=GREY_D, shading=(0.5, 0.5, 0.5)):\n",
        "        width = spacing - slit_width\n",
        "        cube = Cube().set_shape(width, height, depth)\n",
        "        parts = cube.replicate(n_slits + 1)\n",
        "        parts.arrange(RIGHT, buff=slit_width)\n",
        "        edge_piece_width = 0.5 * (total_width - parts.get_width()) + parts[0].get_width()\n",
        "        parts[0].set_width(edge_piece_width, stretch=True, about_edge=RIGHT)\n",
        "        parts[-1].set_width(edge_piece_width, stretch=True, about_edge=LEFT)\n",
        "\n",
        "        parts.set_color(color)\n",
        "        parts.set_shading(*shading)\n",
        "        return parts\n",
        "\n",
        "    def get_point_sources_from_wall(self, wall, z=0):\n",
        "        sources = GlowDots(np.array([\n",
        "            midpoint(p1.get_right(), p2.get_left())\n",
        "            for p1, p2 in zip(wall, wall[1:])\n",
        "        ]))\n",
        "        sources.set_color(WHITE)\n",
        "        sources.set_z(z)\n",
        "        return sources\n",
        "\n",
        "    def get_plane_wave(self, direction=UP):\n",
        "        return LightWaveSlice(DotCloud([-1000 * direction]), decay_factor=0)\n",
        "\n",
        "    def get_graph_over_wave(self, line, light_wave, color=WHITE, stroke_width=2, direction=OUT, scale_factor=0.5, n_curves=500):\n",
        "        line.insert_n_curves(n_curves - line.get_num_curves())\n",
        "        graph = line.copy()\n",
        "        graph.line = line\n",
        "\n",
        "        def update_graph(graph):\n",
        "            points = graph.line.get_anchors()\n",
        "            values = scale_factor * light_wave.wave_func(points)\n",
        "            graph.set_points_smoothly(points + values[:, np.newaxis] * direction)\n",
        "\n",
        "        graph.add_updater(update_graph)\n",
        "        graph.apply_depth_test()\n",
        "        graph.set_stroke(color, stroke_width)\n",
        "        return graph\n",
        "\n",
        "\n",
        "class LightExposingFilm(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Set up wave\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        source_dist = 16.5\n",
        "        source = GlowDot(source_dist * OUT).set_opacity(0)\n",
        "        wave = LightWaveSlice(source, decay_factor=0, wave_number=0.5)\n",
        "        wave.set_opacity(0)\n",
        "        wave_line = Line(source.get_center(), ORIGIN)\n",
        "        wave_line.set_stroke(width=0)\n",
        "        initial_wave_amp = 0.75\n",
        "        wave_amp_tracker = ValueTracker(initial_wave_amp)\n",
        "        graph = self.get_graph_over_wave(wave_line, wave, direction=UP, scale_factor=wave_amp_tracker.get_value(), n_curves=200)\n",
        "        graph.add_updater(lambda m: m.stretch(wave_amp_tracker.get_value() / initial_wave_amp, dim=1))\n",
        "\n",
        "        # Set up linear vector field\n",
        "        def field_func(points):\n",
        "            result = np.zeros_like(points)\n",
        "            result[:, 1] = wave_amp_tracker.get_value() * wave.wave_func(points)\n",
        "            return result\n",
        "\n",
        "        linear_field = VectorField(field_func, sample_points=wave_line.get_points()[::4], max_vect_len=2.0)\n",
        "        linear_field.always.update_vectors()\n",
        "        linear_field.set_stroke(WHITE, width=1.5, opacity=0.75)\n",
        "\n",
        "        # Add film\n",
        "        film = Rectangle(16, 9)\n",
        "        film.set_fill(GREY_E, 0.75)\n",
        "        film.set_height(8)\n",
        "        film.center()\n",
        "\n",
        "        exp_source = GlowDot(OUT).set_opacity(0)\n",
        "        exposure = LightIntensity(exp_source)\n",
        "        exposure.set_color(GREEN)\n",
        "        exposure.set_decay_factor(3)\n",
        "        exposure.set_max_amp(0.15)\n",
        "        exposure.set_opacity(0.7)\n",
        "        exposure.replace(film, stretch=True)\n",
        "\n",
        "        film_label = Text(\"Film\", font_size=96)\n",
        "        film_label.next_to(film, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        frame.reorient(-18, -7, 0, (0.46, -0.4, -2.46), 17.86)\n",
        "        self.add(film, exposure, film_label)\n",
        "        self.add(wave, linear_field, graph)\n",
        "\n",
        "        # Fade in\n",
        "        self.play(\n",
        "            frame.animate.reorient(-88, -4, 0, (3.56, -0.71, 4.59), 14.60),\n",
        "            FadeIn(exposure, time_span=(0, 3)),\n",
        "            run_time=7.5\n",
        "        )\n",
        "\n",
        "        # Label amplitude\n",
        "        low_line = DashedLine(8 * OUT, ORIGIN)\n",
        "        high_line = low_line.copy().shift(wave_amp_tracker.get_value() * UP)\n",
        "        amp_lines = VGroup(low_line, high_line)\n",
        "        amp_lines.set_stroke(YELLOW, 3)\n",
        "        brace = Brace(amp_lines, RIGHT)\n",
        "        brace.rotate(PI / 2, DOWN)\n",
        "        brace.next_to(amp_lines, OUT, SMALL_BUFF)\n",
        "        amp_label = Tex(R\"\\text{Amplitude}\", font_size=72)\n",
        "        amp_label.set_backstroke(BLACK, 5)\n",
        "        amp_label.rotate(PI / 2, DOWN)\n",
        "        amp_label.next_to(brace, OUT, SMALL_BUFF)\n",
        "        fade_rect = Rectangle(8, 3)\n",
        "        fade_rect.rotate(PI / 2, DOWN)\n",
        "        fade_rect.next_to(amp_lines, OUT, buff=0)\n",
        "        fade_rect.set_stroke(BLACK, 0)\n",
        "        fade_rect.set_fill(BLACK, 0.7)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(amp_lines[0]),\n",
        "            ReplacementTransform(amp_lines[0].copy().fade(1), amp_lines[1]),\n",
        "        )\n",
        "        self.play(Write(amp_label, stroke_color=WHITE, lag_ratio=0.1, run_time=2.0))\n",
        "        self.wait_until(lambda: 8 / 30 < wave.uniforms[\"time\"] % 1 < 9 / 30)\n",
        "\n",
        "        # Label phase\n",
        "        phase_text = Text(\"Phase\", font_size=72)\n",
        "        phase_circle = Circle(radius=0.75)\n",
        "        phase_circle.set_stroke(BLUE, 2)\n",
        "        phase_circle.next_to(phase_text, DOWN)\n",
        "        phase_vect = Arrow(phase_circle.get_center(), phase_circle.get_right(), buff=0, thickness=2)\n",
        "        phase_vect.set_fill(BLUE)\n",
        "\n",
        "        phase_label = VGroup(phase_text, phase_circle, phase_vect)\n",
        "        phase_label.rotate(PI / 2, DOWN)\n",
        "        phase_label.next_to(amp_lines, DOWN, buff=2)\n",
        "        phase_label.set_z(2)\n",
        "        og_phase_label = phase_label.copy()\n",
        "\n",
        "        wavelength = 1.0 / wave.uniforms[\"wave_number\"]\n",
        "        start_z = 0\n",
        "        phase_line = Line(start_z * OUT, (start_z + wavelength) * OUT)\n",
        "        phase_line.set_stroke(BLUE, 3)\n",
        "\n",
        "        phase_arrow = Arrow(phase_text.get_corner(IN + UP) + 0.2 * (OUT + UP), phase_line.get_start(), buff=0)\n",
        "        phase_arrow.always.set_perpendicular_to_camera(self.frame)\n",
        "\n",
        "        self.play(\n",
        "            wave.animate.pause(),\n",
        "            FadeIn(phase_label),\n",
        "            FadeIn(phase_arrow),\n",
        "            frame.animate.reorient(-99, -2, 0, (3.56, -0.71, 4.59), 14.60),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(phase_vect, -TAU, axis=LEFT, about_point=phase_vect.get_start()),\n",
        "            ShowCreation(phase_line),\n",
        "            phase_arrow.animate.put_start_and_end_on(phase_arrow.get_start(), phase_line.get_end()),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(phase_vect, TAU, axis=LEFT, about_point=phase_vect.get_start()),\n",
        "            phase_arrow.animate.put_start_and_end_on(phase_arrow.get_start(), phase_line.get_start()),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Decrease and increase amplitude\n",
        "        amp_group = VGroup(amp_lines, brace)\n",
        "        amp_group.f_always.set_height(wave_amp_tracker.get_value, stretch=lambda: True)\n",
        "        amp_group.always.move_to(ORIGIN, IN + DOWN)\n",
        "        amp_label.always.next_to(brace, OUT, SMALL_BUFF)\n",
        "        self.add(amp_group, amp_label)\n",
        "\n",
        "        phase_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            phase_circle.get_center(),\n",
        "            phase_circle.pfp((wave.uniforms[\"frequency\"] * wave.uniforms[\"time\"]) % 1),\n",
        "        ))\n",
        "        phase_vect.always.set_perpendicular_to_camera(self.frame)\n",
        "\n",
        "        self.play(\n",
        "            wave.animate.set_time_rate(0.5),\n",
        "            frame.animate.reorient(-55, -13, 0, (2.59, -0.61, 2.18), 17.00),\n",
        "            phase_arrow.animate.fade(0.8),\n",
        "            phase_label.animate.fade(0.8),\n",
        "            FadeOut(phase_line),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            wave_amp_tracker.animate.set_value(0.25),\n",
        "            exposure.animate.set_opacity(0.25),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            wave_amp_tracker.animate.set_value(1.0),\n",
        "            exposure.animate.set_opacity(1.0),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write exposure expression\n",
        "        exp_expr = Tex(R\"\\text{Exposure} = c \\cdot |\\text{Amplitude}|^2\", font_size=72)\n",
        "        exp_expr.move_to(2 * UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                Write(exp_expr[R\"\\text{Exposure} = c \\cdot |\"][0]),\n",
        "                TransformFromCopy(amp_label.copy().clear_updaters(), exp_expr[R\"\\text{Amplitude}\"][0]),\n",
        "                Write(exp_expr[R\"|^2\"][0]),\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "            frame.animate.reorient(-34, -15, 0, (1.48, -0.23, 1.29), 16.08),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Focus on phase again\n",
        "        to_fade = VGroup(fade_rect, amp_group, amp_label)\n",
        "        wave.pause()\n",
        "        self.play(\n",
        "            FadeOut(to_fade, lag_ratio=0.01, time_span=(0, 1.5)),\n",
        "            phase_label.animate.match_style(og_phase_label),\n",
        "            phase_arrow.animate.set_fill(opacity=1),\n",
        "            frame.animate.reorient(-86, -4, 0, (2.43, -0.97, 1.94), 12.91),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Shift back the phase\n",
        "        shift_label = TexText(R\"Shift back phase $\\rightarrow$\")\n",
        "        shift_label.rotate(PI / 2, DOWN)\n",
        "        shift_label.move_to(7 * OUT + 1.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            wave.animate.set_uniform(time_rate=-0.5).set_anim_args(rate_func=there_and_back),\n",
        "            FadeIn(shift_label, shift=OUT),\n",
        "            run_time=2.0\n",
        "        )\n",
        "        self.play(FadeOut(shift_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Play for a while\n",
        "        self.play(wave.animate.set_time_rate(0.5))\n",
        "        self.wait(16)\n",
        "\n",
        "        # Shine a second beam in\n",
        "        source2 = GlowDot(source_dist * (OUT + RIGHT))\n",
        "        wave2 = LightWaveSlice(source2)\n",
        "        wave2.set_uniforms(dict(wave.uniforms))\n",
        "        wave2.set_opacity(0)\n",
        "        line2 = Line(ORIGIN, source2.get_center())\n",
        "        ref_amp = 0.75\n",
        "        graph2 = self.get_graph_over_wave(line2, wave2, direction=UP, scale_factor=ref_amp, n_curves=int(200 * math.sqrt(2)))\n",
        "        graph2.set_color(YELLOW)\n",
        "        graph2.update()\n",
        "\n",
        "        def field_func2(points):\n",
        "            result = np.zeros_like(points)\n",
        "            result[:, 1] = ref_amp * wave2.wave_func(points)\n",
        "            return result\n",
        "\n",
        "        linear_field2 = VectorField(field_func2, sample_points=line2.get_points()[::4], max_vect_len=2.0)\n",
        "        linear_field2.always.update_vectors()\n",
        "        linear_field2.set_stroke(YELLOW, width=1.5, opacity=0.75)\n",
        "\n",
        "        ref_wave_label = Text(\"Reference Wave\", font_size=72)\n",
        "        ref_wave_label.set_color(YELLOW)\n",
        "        ref_wave_label.set_backstroke(BLACK, 3)\n",
        "        ref_wave_label.rotate(PI / 4, DOWN)\n",
        "        ref_wave_label.move_to([5, 1.25, 5])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(phase_label),\n",
        "            FadeOut(phase_arrow),\n",
        "            wave_amp_tracker.animate.set_value(0.75),\n",
        "            exposure.animate.set_opacity(0.75),\n",
        "            frame.animate.reorient(-32, -20, 0, (1.48, -0.73, 0.84), 14.72),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait_until(lambda: 8 / 30 < wave.uniforms[\"time\"] % 1 < 9 / 30)\n",
        "        self.add(wave2)\n",
        "        self.play(\n",
        "            FadeIn(graph2),\n",
        "            FadeIn(linear_field2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(ref_wave_label, shift=UP))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Zoom in\n",
        "        self.play(\n",
        "            frame.animate.reorient(-58, -18, 0, (3.29, 0.39, 0.55), 10.68),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            exposure.animate.set_opacity(1).set_max_amp(0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Shift back\n",
        "        shift_label = TexText(R\"Shift back phase $\\rightarrow$\")\n",
        "        shift_label.rotate(PI / 2, DOWN)\n",
        "        shift_label.set_backstroke(BLACK, 5)\n",
        "        shift_label.move_to(5 * OUT + 1.25 * UP)\n",
        "\n",
        "        self.play(\n",
        "            wave.animate.pause(),\n",
        "            wave2.animate.pause(),\n",
        "        )\n",
        "        self.play(\n",
        "            wave.animate.set_uniform(time_rate=-0.5).set_anim_args(rate_func=there_and_back),\n",
        "            exposure.animate.set_max_amp(0.2).set_opacity(0.15),\n",
        "            FadeIn(shift_label, OUT),\n",
        "            run_time=2.0\n",
        "        )\n",
        "        self.play(FadeOut(shift_label))\n",
        "        self.play(\n",
        "            wave.animate.set_time_rate(0.5),\n",
        "            wave2.animate.set_time_rate(0.5),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-54, -16, 0, (3.01, -0.09, 0.55), 14.47),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "        wave.pause()\n",
        "        wave2.pause()\n",
        "        self.play(\n",
        "            wave.animate.set_uniform(time_rate=-0.5).set_anim_args(rate_func=there_and_back),\n",
        "            exposure.animate.set_max_amp(0.1).set_opacity(1),\n",
        "            FadeIn(shift_label, OUT),\n",
        "            run_time=2.0\n",
        "        )\n",
        "        self.play(FadeOut(shift_label))\n",
        "        wave.set_time_rate(0.5)\n",
        "        wave2.set_time_rate(0.5)\n",
        "        self.play(\n",
        "            frame.animate.reorient(15, -22, 0, (2.14, -0.48, -0.07), 15.51),\n",
        "            run_time=12,\n",
        "        )\n",
        "\n",
        "        wave.pause()\n",
        "        wave2.pause()\n",
        "        self.play(\n",
        "            wave.animate.set_uniform(time_rate=-0.5).set_anim_args(rate_func=there_and_back),\n",
        "            exposure.animate.set_max_amp(0.2).set_opacity(0.15),\n",
        "            run_time=2.0\n",
        "        )\n",
        "        wave.set_time_rate(0.5)\n",
        "        wave2.set_time_rate(0.5)\n",
        "        self.play(\n",
        "            frame.animate.reorient(15, -14, 0, (1.47, 0.09, -0.04), 13.26),\n",
        "            run_time=12,\n",
        "        )\n",
        "\n",
        "\n",
        "class TwoInterferingWaves(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Setup reference and object waves\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        film_border = ScreenRectangle()\n",
        "        film_border.set_height(6)\n",
        "        film_border.set_fill(BLACK, 0)\n",
        "        film_border.set_stroke(WHITE, 1)\n",
        "        film_image = ImageMobject(\"HologramFilm.jpg\")\n",
        "        film_image.replace(film_border)\n",
        "\n",
        "        frame.set_height(6)\n",
        "        self.add(film_image, film_border)\n",
        "\n",
        "        # Add waves\n",
        "        obj_vect = 5 * OUT + 2 * LEFT\n",
        "        ref_vect = 5 * OUT + 2 * RIGHT\n",
        "        lp = film_border.get_left() + 3 * DOWN\n",
        "        rp = film_border.get_right() + 3 * DOWN\n",
        "\n",
        "        obj_points = DotCloud(np.random.random((31, 3)))\n",
        "        obj_points.set_height(10)\n",
        "        obj_points.move_to(obj_vect)\n",
        "        obj_wave = LightWaveSlice(obj_points)\n",
        "        obj_wave.set_wave_number(8)\n",
        "        obj_wave.set_frequency(1)\n",
        "        obj_wave.set_max_amp(3)\n",
        "\n",
        "        ref_wave = LightWaveSlice(TrueDot(10 * ref_vect))\n",
        "        ref_wave.match_points(obj_wave)\n",
        "        ref_wave.set_uniforms(dict(obj_wave.uniforms))\n",
        "        ref_wave.set_max_amp(1.25)\n",
        "        ref_wave.set_decay_factor(0)\n",
        "        ref_wave.set_opacity(0.85)\n",
        "\n",
        "        rect = film_border\n",
        "        obj_wave.set_points([\n",
        "            2 * obj_vect, rect.get_corner(UL), rect.get_corner(DL),\n",
        "            2 * obj_vect, rect.get_corner(UL), rect.get_corner(UR),\n",
        "            2 * obj_vect, rect.get_corner(UR), rect.get_corner(DR),\n",
        "            2 * obj_vect, rect.get_corner(DR), rect.get_corner(DL),\n",
        "        ])\n",
        "        ref_wave.set_points([\n",
        "            2 * ref_vect, rect.get_corner(UL), rect.get_corner(DL),\n",
        "            2 * ref_vect, rect.get_corner(UL), rect.get_corner(UR),\n",
        "            2 * ref_vect, rect.get_corner(UR), rect.get_corner(DR),\n",
        "            2 * ref_vect, rect.get_corner(DR), rect.get_corner(DL),\n",
        "        ])\n",
        "        obj_wave.deactivate_depth_test()\n",
        "        ref_wave.deactivate_depth_test()\n",
        "\n",
        "        waves = Group(ref_wave, obj_wave)\n",
        "        waves.set_opacity(0.25)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(waves),\n",
        "            frame.animate.reorient(0, -21, 0, (-0.09, -0.86, 0.04), 9.40),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Diversion into backdrop for complex wave scene\n",
        "        if False:\n",
        "            # Isolate object wave\n",
        "            new_obj_wave = LightWaveSlice(obj_points)\n",
        "            new_obj_wave.set_points([2 * obj_vect, rect.get_left(), rect.get_right()])\n",
        "            new_obj_wave.set_uniforms(dict(obj_wave.uniforms))\n",
        "            new_obj_wave.set_opacity(1)\n",
        "            new_obj_wave.set_frequency(0.25)\n",
        "\n",
        "            frame.reorient(0, -19, 0, (0.01, -0.03, -0.28), 12.53)\n",
        "            waves.set_opacity(0.4)\n",
        "            for wave in waves:\n",
        "                wave.set_frequency(0.25)\n",
        "            self.wait(4)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(ref_wave),\n",
        "                FadeOut(film_border),\n",
        "                FadeOut(film_image),\n",
        "                FadeOut(obj_wave),\n",
        "                FadeIn(new_obj_wave)\n",
        "            )\n",
        "\n",
        "            # Go to 2d slice\n",
        "            self.play(\n",
        "                new_obj_wave.animate.scale(10),\n",
        "                frame.animate.reorient(-3, -5, 0, (-0.96, 0.03, -0.15), 5.32),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait(4)\n",
        "\n",
        "            # Circle a point\n",
        "            circle = Circle(radius=0.1).set_stroke(WHITE, 2)\n",
        "            circle.move_to(LEFT + 2 * DOWN)\n",
        "            circle.reverse_points()\n",
        "            full_rect = FullScreenRectangle()\n",
        "            full_rect.set_fill(BLACK, 0.75)\n",
        "            full_rect.append_points([full_rect.get_end(), *circle.get_points()])\n",
        "\n",
        "            circle.fix_in_frame()\n",
        "            full_rect.fix_in_frame()\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(full_rect),\n",
        "                ShowCreation(circle),\n",
        "            )\n",
        "            self.wait(8)\n",
        "\n",
        "        # Add exposure\n",
        "        exposure = LightIntensity(obj_points)\n",
        "        exposure.set_color(WHITE)\n",
        "        exposure.replace(film_border, stretch=True)\n",
        "        exposure.set_wave_number(256)\n",
        "        exposure.set_max_amp(4)\n",
        "\n",
        "        # One more insertion\n",
        "        exposure.set_opacity(0.5)\n",
        "        self.add(exposure, waves)\n",
        "        frame.reorient(-18, -30, 0, (-5.85, -0.18, -0.89), 15.16)\n",
        "        self.play(\n",
        "            frame.animate.reorient(17, -24, 0, (-5.5, -0.82, -0.67), 15.86),\n",
        "            run_time=30\n",
        "        )\n",
        "\n",
        "        self.add(exposure, waves)\n",
        "        self.play(\n",
        "            FadeIn(exposure, run_time=5),\n",
        "            FadeOut(waves, time_span=(3, 5)),\n",
        "        )\n",
        "\n",
        "        # Zoom in on the film\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0.5, 0.07, 0.0), 0.15),\n",
        "            film_image.animate.set_opacity(0.1).set_anim_args(time_span=(0, 5)),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(frame.animate.reorient(0, 0, 0, (0.41, 0.03, 0.0), 0.05), run_time=8)\n",
        "\n",
        "\n",
        "class SinglePointOnFilm(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Reference image\n",
        "        img = ImageMobject(\"SinglePointHologram\")\n",
        "        img.set_height(FRAME_HEIGHT)\n",
        "        img.fix_in_frame()\n",
        "        img.set_opacity(0.75)\n",
        "        # self.add(img)\n",
        "\n",
        "        # Create object and reference wave\n",
        "        # Much of this copied from CreateZonePlate below\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(42 * DEGREES)\n",
        "        axes = ThreeDAxes()\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        wave_width = 100\n",
        "        wave_number = 2\n",
        "        frequency = 1\n",
        "\n",
        "        source_point = GlowDot(color=WHITE, radius=0.5)\n",
        "        source_point.move_to([0., -0.75, 4.62])\n",
        "        obj_wave = LightWaveSlice(source_point)\n",
        "        obj_wave.set_decay_factor(0.7)\n",
        "\n",
        "        obj_wave.set_width(wave_width)\n",
        "        obj_wave.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "        obj_wave.move_to(source_point)\n",
        "        obj_wave.set_wave_number(wave_number)\n",
        "        obj_wave.set_frequency(frequency)\n",
        "\n",
        "        # Add film\n",
        "        plate_border = Rectangle(4, 4)\n",
        "        plate_border.set_fill(BLACK, 0)\n",
        "        plate_border.set_stroke(WHITE, 2)\n",
        "        plate_body = Square3D()\n",
        "        plate_body.set_color(BLACK, 0.9)\n",
        "        plate_body.replace(plate_border, stretch=True)\n",
        "        plate_body.set_shading(0.1, 0.1, 0)\n",
        "\n",
        "        plate = Group(plate_body, plate_border)\n",
        "        plate.center()\n",
        "\n",
        "        film_label = Text(\"Film\")\n",
        "        film_label.next_to(plate, UP)\n",
        "        film_label.set_backstroke(BLACK, 3)\n",
        "        film_label.set_z_index(1)\n",
        "\n",
        "        # Spherical waves\n",
        "        wave_stack = Group(\n",
        "            obj_wave.copy().rotate(PI / 2, OUT).set_opacity(0.1)\n",
        "            for x in range(30)\n",
        "        )\n",
        "        wave_stack.set_opacity(0.07)\n",
        "        wave_stack.arrange_to_fit_width(4)\n",
        "        wave_stack.sort(lambda p: -p[0])\n",
        "        wave_stack.move_to(obj_wave)\n",
        "\n",
        "        # Label object wave\n",
        "        source_label = Text(\"Object (idealized point)\", font_size=36)\n",
        "        source_label.next_to(source_point, UR, buff=MED_LARGE_BUFF)\n",
        "        source_label.shift(0.25 * UL)\n",
        "        source_label.set_backstroke(BLACK, 2)\n",
        "        source_arrow = Arrow(source_label[\"Object\"].get_bottom(), source_point.get_center(), buff=0.1)\n",
        "        source_arrow.set_perpendicular_to_camera(self.frame)\n",
        "        source_label.add(source_arrow)\n",
        "        source_label.rotate(PI / 2, DOWN, about_point=source_point.get_center())\n",
        "        obj_point = TrueDot()\n",
        "        obj_point.move_to(source_point)\n",
        "\n",
        "        obj_wave_label = Text(\"Object wave\")\n",
        "        obj_wave_label.rotate(PI / 2, LEFT)\n",
        "        obj_wave_label.next_to(source_point, IN, buff=0.1)\n",
        "        obj_wave_label.set_backstroke(BLACK, 2)\n",
        "\n",
        "        frame.reorient(-88, -12, 0, (0.22, -0.81, 4.62), 13.76)\n",
        "        self.add(plate, film_label)\n",
        "        self.add(obj_wave, wave_stack, obj_point, source_point)\n",
        "        self.add(source_label)\n",
        "        self.wait()\n",
        "\n",
        "        # Slowly reorient\n",
        "        self.play(\n",
        "            frame.animate.reorient(-14, -11, 0, (0.27, 0.14, 3.59), 6.17),\n",
        "            Rotate(source_label, PI / 2, UP, about_point=source_point.get_center()),\n",
        "            Rotate(wave_stack, PI / 2, UP, about_point=source_point.get_center()),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "        # Look from above\n",
        "        self.play(\n",
        "            FadeOut(wave_stack),\n",
        "            FadeOut(source_label),\n",
        "            FadeOut(plate),\n",
        "            FadeOut(film_label),\n",
        "            obj_wave.animate.set_decay_factor(0.5),\n",
        "            frame.animate.reorient(0, -90, 0, source_point.get_center(), 4).set_anim_args(run_time=4)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ExplainWaveVisualization(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Set up the wave\n",
        "        full_width = 20\n",
        "        frame = self.frame\n",
        "\n",
        "        source = GlowDot(ORIGIN, color=WHITE)\n",
        "        source.set_radius(0.5)\n",
        "        wave = LightWaveSlice(source)\n",
        "        wave.set_width(full_width)\n",
        "        wave.move_to(ORIGIN)\n",
        "\n",
        "        frame.reorient\n",
        "        self.add(wave, source)\n",
        "\n",
        "        # Talk through what's displayed\n",
        "        def field_func(points):\n",
        "            result = np.zeros_like(points)\n",
        "            result[:, 2] = 0.5 * wave.wave_func(points)\n",
        "            return result\n",
        "\n",
        "        linear_field = VectorField(\n",
        "            field_func,\n",
        "            sample_points=np.linspace(ORIGIN, 10 * UP, 100),\n",
        "            max_vect_len=1.0,\n",
        "        )\n",
        "        linear_field.always.update_vectors()\n",
        "        linear_field.set_stroke(WHITE, width=1.5, opacity=0.75)\n",
        "        full_field = VectorField(\n",
        "            field_func,\n",
        "            width=full_width,\n",
        "            height=full_width,\n",
        "            x_density=5,\n",
        "            y_density=5,\n",
        "            max_vect_len=0.5,\n",
        "        )\n",
        "        full_field.sample_points\n",
        "        full_field.set_stroke(WHITE, width=1.5, opacity=0.25)\n",
        "        full_field.always.update_vectors()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(71, 77, 0, (-0.62, 0.7, 0.19), 3.11),\n",
        "            wave.animate.set_uniform(time_rate=0.5).set_anim_args(suspend_mobject_updating=False),\n",
        "            VFadeIn(full_field, time_span=(0, 2)),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            VFadeIn(linear_field),\n",
        "            VFadeOut(full_field),\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.wait_until(lambda: 15 / 30 < wave.uniforms[\"time\"] % 1 < 16 / 30)\n",
        "        self.play(\n",
        "            wave.animate.pause().set_anim_args(suspend_mobject_updating=False),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show example vectors\n",
        "        sample_vect = Vector(OUT, thickness=1.0)\n",
        "        sample_vect.set_fill(WHITE, 1, border_width=0.5)\n",
        "        sample_vect.base_point = Dot(0.705 * UP, fill_color=BLUE, radius=0.02)\n",
        "\n",
        "        def update_sample_vect(vect):\n",
        "            point = vect.base_point.get_center()\n",
        "            vect.put_start_and_end_on(point, point + 0.95 * field_func([point])[0])\n",
        "            vect.set_perpendicular_to_camera(self.frame)\n",
        "\n",
        "        update_sample_vect(sample_vect)\n",
        "\n",
        "        self.play(\n",
        "            linear_field.animate.set_stroke(opacity=0.2),\n",
        "            GrowArrow(sample_vect, run_time=2),\n",
        "            frame.animate.reorient(81, 84, 0, (-0.5, 0.69, 0.23), 1.65).set_anim_args(run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sample_vect.base_point, 0.1 * IN))\n",
        "        self.wait()\n",
        "        sample_vect.add_updater(update_sample_vect)\n",
        "        self.play(sample_vect.base_point.animate.move_to(1.315 * UP).set_color(RED), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(sample_vect.base_point.animate.move_to(1.01 * UP).set_color(GREY_E), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VFadeOut(sample_vect, time_span=(0, 2)),\n",
        "            FadeOut(sample_vect.base_point, time_span=(0, 2)),\n",
        "            linear_field.animate.set_stroke(opacity=0.75).set_anim_args(time_span=(0, 2)),\n",
        "            wave.animate.set_uniform(time_rate=0.5).set_anim_args(suspend_mobject_updating=False),\n",
        "            frame.animate.reorient(49, 79, 0, (-0.14, 1.34, 0.23), 2.78),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show full 3d field\n",
        "        full_field = VectorField(\n",
        "            lambda p: 0.5 * field_func(p),\n",
        "            x_density=4,\n",
        "            y_density=4,\n",
        "            z_density=2,\n",
        "            depth=4,\n",
        "            max_vect_len=0.5,\n",
        "        )\n",
        "        full_field.set_stroke(WHITE, width=1, opacity=0.25)\n",
        "        full_field.always.update_vectors()\n",
        "\n",
        "        added_waves = Group(\n",
        "            wave.copy().rotate(PI / 2, UP).shift(z * RIGHT).set_opacity(0.1)\n",
        "            for z in np.arange(-2, 2, 0.1)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            # VFadeIn(full_field),\n",
        "            VFadeOut(linear_field),\n",
        "            FadeIn(added_waves, suspend_mobject_updating=False),\n",
        "            frame.animate.reorient(48, 79, 0, (-0.42, 1.07, 0.35), 4.18).set_anim_args(run_time=8)\n",
        "        )\n",
        "        wave.save_state()\n",
        "        wave.scale(0)\n",
        "        self.play(\n",
        "            Restore(wave, suspend_mobject_updating=False),\n",
        "            FadeOut(added_waves, time_span=(0, 1), suspend_mobject_updating=False),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show a sine wave\n",
        "        line = Line(ORIGIN, 10 * UR)\n",
        "        line.shift(source.get_center())\n",
        "        line.set_stroke(TEAL, 2)\n",
        "        graph = self.get_graph_over_wave(line, wave)\n",
        "        graph.set_stroke(WHITE, 2)\n",
        "        wave.set_z_index(1)\n",
        "        source.set_z_index(1)\n",
        "\n",
        "        linear_field = VectorField(\n",
        "            field_func,\n",
        "            sample_points=line.get_anchors()[::2],\n",
        "            max_vect_len=1.0,\n",
        "        )\n",
        "        linear_field.set_stroke(WHITE, 0.75)\n",
        "        linear_field.always.update_vectors()\n",
        "\n",
        "        self.add(line, graph)\n",
        "        self.play(\n",
        "            ShowCreation(line, time_span=(0, 3)),\n",
        "            ShowCreation(graph, time_span=(0, 3)),\n",
        "            VFadeIn(linear_field, time_span=(0, 3), suspend_mobject_updating=False),\n",
        "            frame.animate.reorient(0, 73, 0, (-0.03, 1.7, 0.2), 4.65),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class CreateZonePlate(DiffractionGratingScene):\n",
        "    samples = 4\n",
        "\n",
        "    def construct(self):\n",
        "        # Create object and reference wave\n",
        "        frame = self.frame\n",
        "        axes = ThreeDAxes()\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        wave_width = 100\n",
        "        wave_number = 4\n",
        "        frequency = 1\n",
        "\n",
        "        ref_wave = self.get_plane_wave(direction=IN)\n",
        "        ref_wave.set_opacity(0.75)\n",
        "        ref_source = ref_wave.point_sources\n",
        "        source_point = GlowDot(OUT, color=WHITE, radius=0.5)\n",
        "        obj_wave = LightWaveSlice(source_point)\n",
        "        obj_wave.set_decay_factor(0.7)\n",
        "\n",
        "        for wave in [obj_wave, ref_wave]:\n",
        "            wave.set_width(wave_width)\n",
        "            wave.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "            wave.center()\n",
        "            wave.set_wave_number(wave_number)\n",
        "            wave.set_frequency(frequency)\n",
        "\n",
        "        frame.reorient(-32, -21, 0, (-0.74, 0.32, -0.49), 7.08)\n",
        "\n",
        "        def get_all_sources():\n",
        "            return np.vstack([\n",
        "                obj_wave.point_sources.get_points(),\n",
        "                ref_wave.point_sources.get_points()\n",
        "            ])\n",
        "\n",
        "        # Add film\n",
        "        plate = Rectangle(16, 9)\n",
        "        plate.set_height(4)\n",
        "        plate.set_stroke(WHITE, 1, 0.5).set_fill(BLACK, 0.0)\n",
        "        plate.set_shading(0.1, 0.1, 0)\n",
        "        plate.apply_depth_test()\n",
        "        plate_body = Square3D()\n",
        "        plate_group = Group(plate_body, plate)\n",
        "\n",
        "        plate_body.set_color(BLACK, 0.9)\n",
        "        plate_body.set_shape(plate.get_width(), plate.get_height())\n",
        "        plate_body.move_to(plate.get_center() + 1e-2 * IN)\n",
        "\n",
        "        exposure = LightIntensity(DotCloud(get_all_sources()))\n",
        "        exposure.set_decay_factor(0)\n",
        "        exposure.set_wave_number(wave_number)\n",
        "        exposure.replace(plate, stretch=True).shift(1e-2 * OUT)\n",
        "        exposure.set_color(WHITE, 0.85)\n",
        "\n",
        "        film = Group(plate, exposure)\n",
        "        film.set_height(4)\n",
        "        film.set_z(-2)\n",
        "\n",
        "        film_label = Text(\"Film\")\n",
        "        film_label.next_to(plate, UP)\n",
        "        film_label.set_backstroke(BLACK, 3)\n",
        "        film_label.set_z_index(1)\n",
        "\n",
        "        # Label object wave\n",
        "        source_label = Text(\"Object (idealized point)\", font_size=24)\n",
        "        source_label.next_to(source_point, UR, buff=0)\n",
        "        source_label.shift(0.25 * UL)\n",
        "        source_label.set_backstroke(BLACK, 2)\n",
        "        source_arrow = Arrow(source_label[\"Object\"].get_bottom(), source_point.get_center(), buff=0.1)\n",
        "        source_arrow.always.set_perpendicular_to_camera(self.frame)\n",
        "        obj_point = TrueDot()\n",
        "        obj_point.move_to(source_point)\n",
        "\n",
        "        obj_wave_label = Text(\"Object wave\")\n",
        "        obj_wave_label.rotate(PI / 2, LEFT)\n",
        "        obj_wave_label.next_to(source_point, IN, buff=0.1)\n",
        "        obj_wave_label.set_backstroke(BLACK, 2)\n",
        "\n",
        "        frame.reorient(41, -9, 0, (-0.72, 0.27, -0.49), 6.75)\n",
        "        self.add(plate_group, obj_wave, film_label)\n",
        "        plate_body.move_to(plate.get_center() + 1e-2 * IN)\n",
        "        self.play(\n",
        "            FadeIn(source_point),\n",
        "            FadeIn(source_label),\n",
        "            GrowArrow(source_arrow),\n",
        "            frame.animate.reorient(-4, -10, 0, (-0.74, 0.32, -0.49), 7.08).set_anim_args(run_time=5)\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingStrings(source_label, obj_wave_label),\n",
        "            FadeOut(source_arrow),\n",
        "            frame.animate.reorient(0, -47, 0, (-0.74, 0.32, -0.49), 7.08).set_anim_args(run_time=3),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Label reference wave\n",
        "        ref_wave.match_width(film, stretch=True)\n",
        "        ref_wave.move_to(film, IN)\n",
        "        ref_wave_label = Text(\"Reference wave\")\n",
        "        ref_wave_label.rotate(PI / 2, LEFT)\n",
        "        ref_wave_label.next_to(obj_wave_label, OUT, buff=1.5)\n",
        "        ref_wave_label.set_backstroke(BLACK, 2)\n",
        "\n",
        "        wave_fronts = Group(\n",
        "            plate.copy().set_color([BLUE, RED][z % 2], 0.15).shift(0.5 * z * OUT)\n",
        "            for z in range(4, 16)\n",
        "        )\n",
        "        for front in wave_fronts:\n",
        "            front.add_updater(lambda m, dt: m.shift(dt * (frequency / wave_number) * IN))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(obj_wave, 0.1 * DOWN),\n",
        "            FadeOut(obj_wave_label),\n",
        "            FadeOut(source_point),\n",
        "            FadeIn(ref_wave, 0.1 * DOWN),\n",
        "            FadeIn(ref_wave_label),\n",
        "            frame.animate.reorient(0, -40, 0, (-0.16, 0.01, -0.24), 7.08).set_anim_args(run_time=4),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(wave_fronts, time_span=(0, 2), lag_ratio=0.05),\n",
        "            frame.animate.reorient(0, -37, 0, (-0.16, 0.01, -0.24), 7.08),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(FadeOut(wave_fronts, run_time=2, lag_ratio=0.1))\n",
        "        self.add(ref_source)\n",
        "\n",
        "        # Put reference at an angle\n",
        "        angle = 60 * DEGREES\n",
        "        direction = rotate_vector(OUT, angle, axis=UP)\n",
        "        dist = ref_wave.get_depth()\n",
        "        ref_wave.save_state()\n",
        "        ref_wave.point_sources.save_state()\n",
        "        ref_wave.target = ref_wave.generate_target()\n",
        "        p0 = film.get_left()\n",
        "        p1 = film.get_right()\n",
        "        p2 = p0 + dist * direction\n",
        "        p3 = p1 + dist * direction\n",
        "        ref_wave.target.set_points([p2, p0, p3, p1])\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(ref_wave, run_time=2),\n",
        "            Rotate(ref_wave.point_sources, angle, axis=UP, about_point=ORIGIN),\n",
        "            Rotate(ref_wave_label, angle, axis=UP, about_point=film.get_center()),\n",
        "            run_time=10,\n",
        "            rate_func=lambda t: there_and_back_with_pause(t, 0.5)\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Also show the object wave from this perspective\n",
        "        self.remove(ref_wave, ref_wave_label)\n",
        "        self.add(obj_wave, obj_wave_label, source_point)\n",
        "        obj_wave_label.shift(0.25 * OUT)\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show combined wave\n",
        "        comb_label = Text(\"Combined wave\")\n",
        "        comb_label.rotate(PI / 2, LEFT)\n",
        "        comb_label.next_to(ref_wave_label, UP)\n",
        "        comb_label.set_backstroke(BLACK, 3)\n",
        "        comb_wave = obj_wave.copy()\n",
        "        comb_wave.point_sources = DotCloud([\n",
        "            *(source_point.get_center() for x in range(2)),\n",
        "            *np.linspace(20 * OUT + 4 * LEFT, 20 * OUT + 4 * RIGHT, 25)\n",
        "        ])\n",
        "        comb_wave.set_decay_factor(0.8)\n",
        "        comb_wave.set_max_amp(1.5)\n",
        "\n",
        "        self.remove(obj_wave, obj_wave_label)\n",
        "        self.add(comb_wave, comb_label, source_point)\n",
        "        self.wait(8)\n",
        "\n",
        "        # Preview exposure\n",
        "        self.add(exposure, comb_wave, comb_label)\n",
        "        self.play(FadeIn(exposure, run_time=3))\n",
        "        self.wait(8)\n",
        "\n",
        "        # Change to side view\n",
        "        self.play(\n",
        "            FadeOut(comb_label),\n",
        "            comb_wave.animate.set_opacity(0.1),\n",
        "            FadeOut(film_label),\n",
        "            FadeOut(exposure),\n",
        "            frame.animate.reorient(80, -2, 0, (-0.64, 0.23, -0.93), 4.34),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Add graphs to middle\n",
        "        ref_source.get_center()\n",
        "        ref_source.move_to(source_point.get_center() + ((1000 // wave_number) * wave_number) * OUT)\n",
        "        ref_wave.set_uniform(time=obj_wave.uniforms[\"time\"])\n",
        "\n",
        "        obj_color, ref_color = colors = [TEAL, YELLOW]\n",
        "        obj_line, ref_line = lines = VGroup(\n",
        "            Line(source_point.get_center(), film.get_center()).set_stroke(color, 1, 0.5)\n",
        "            for color in colors\n",
        "        )\n",
        "        ref_line.scale(2, about_point=ref_line.get_end())\n",
        "        ref_line.shift(0.02 * RIGHT)\n",
        "\n",
        "        obj_graph, ref_graph = graphs = VGroup(\n",
        "            self.get_graph_over_wave(line, wave, scale_factor=sf, direction=UP, color=color)\n",
        "            for line, color, wave, sf in zip(lines, colors, [obj_wave, ref_wave], [0.15, 0.1])\n",
        "        )\n",
        "        graphs.set_stroke(width=2, opacity=1)\n",
        "\n",
        "        obj_label = Text(\"Object wave\", font_size=24).rotate(PI / 2, UP)\n",
        "        ref_label = Text(\"Reference wave\", font_size=24).rotate(PI / 2, UP)\n",
        "        obj_label.set_color(obj_color).next_to(obj_graph, UP, aligned_edge=OUT)\n",
        "        obj_label.shift(0.1 * IN)\n",
        "        ref_label.set_color(ref_color).next_to(ref_graph, DOWN)\n",
        "        ref_label.match_z(obj_label).shift(OUT)\n",
        "\n",
        "        obj_wave.set_opacity(0)\n",
        "        obj_wave.set_decay_factor(0.5)\n",
        "        ref_wave.set_opacity(0)\n",
        "\n",
        "        comb_wave.set_z_index(1)\n",
        "\n",
        "        self.add(obj_wave, ref_wave)\n",
        "        self.play(\n",
        "            ShowCreation(obj_line),\n",
        "            ShowCreation(obj_graph),\n",
        "            FadeIn(obj_label, lag_ratio=0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            ShowCreation(ref_line),\n",
        "            ShowCreation(ref_graph),\n",
        "            FadeIn(ref_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show middle exposure\n",
        "        round_exposure = self.get_round_exposure(exposure, radius=0.25)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(round_exposure),\n",
        "            frame.animate.reorient(53, -15, 0, (-0.83, 0.12, -0.62), 5.25).set_anim_args(run_time=3),\n",
        "        )\n",
        "\n",
        "        # Look off center\n",
        "        exposure.replace(plate, stretch=True)\n",
        "        exposure.set_shape(0.5 * plate.get_width(), 0.25)\n",
        "        exposure.move_to(plate.get_center(), LEFT).shift(1e-2 * OUT)\n",
        "        full_exposure = exposure.copy()\n",
        "        full_exposure.replace(plate, stretch=True)\n",
        "        full_exposure.shift(2e-2 * OUT)\n",
        "        exposure.save_state()\n",
        "        exposure.stretch(0, 0, about_edge=LEFT)\n",
        "\n",
        "        O_point = obj_label[0].get_center()\n",
        "        obj_label.add_updater(\n",
        "            lambda m: m.rotate(\n",
        "                angle_of_vector((m[-1].get_center() - m[0].get_center())[0::2]) - angle_of_vector(obj_line.get_vector()[0::2]),\n",
        "                axis=UP,\n",
        "            ).shift(O_point - m[0].get_center())\n",
        "        )\n",
        "\n",
        "        trg_point = VectorizedPoint(plate.get_center())\n",
        "        obj_line.add_updater(lambda m: m.put_start_and_end_on(source_point.get_center(), trg_point.get_center()))\n",
        "        ref_line.add_updater(lambda m: m.move_to(trg_point.get_center() + 0.02 * RIGHT, IN))\n",
        "\n",
        "        self.play(\n",
        "            obj_wave.animate.pause(),\n",
        "            ref_wave.animate.pause(),\n",
        "            comb_wave.animate.pause(),\n",
        "        )\n",
        "        self.play(\n",
        "            trg_point.animate.move_to(film.get_right()),\n",
        "            round_exposure.animate.shift(0.01 * OUT),\n",
        "            MaintainPositionRelativeTo(ref_label, ref_line),\n",
        "            Restore(exposure),\n",
        "            frame.animate.reorient(35, -14, 0, (1.01, 0.23, -2.8), 8.40),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Look to halfwavelength point\n",
        "        trg_x = 0.9\n",
        "        mid_line = Line(source_point.get_center(), plate.get_center())\n",
        "        mid_line.set_stroke(TEAL, 2)\n",
        "        mid_line_label = Tex(\"D\", font_size=30).rotate(PI / 2, LEFT)\n",
        "        mid_line_label.next_to(mid_line, LEFT)\n",
        "        d_line_label = Tex(R\"D + \\frac{\\lambda}{2}\", font_size=30).rotate(PI / 2, LEFT)\n",
        "        VGroup(mid_line_label, d_line_label).set_fill(TEAL, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(obj_label),\n",
        "            FadeOut(ref_label),\n",
        "            FadeOut(ref_line),\n",
        "            FadeOut(ref_graph),\n",
        "            frame.animate.reorient(0, -62, 0, (-0.27, -1.26, -1.17), 7.38),\n",
        "            trg_point.animate.move_to(plate.get_center() + trg_x * RIGHT),\n",
        "            run_time=3\n",
        "        )\n",
        "        d_line_label.next_to(obj_line.get_center(), RIGHT, buff=SMALL_BUFF)\n",
        "        self.play(\n",
        "            FadeIn(mid_line),\n",
        "            FadeIn(mid_line_label),\n",
        "            FadeIn(d_line_label),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(84, -9, 0, (-0.26, -0.27, -1.86), 3.23),\n",
        "            FadeOut(VGroup(mid_line, mid_line_label, d_line_label)),\n",
        "            FadeIn(ref_line),\n",
        "            FadeIn(ref_graph),\n",
        "            obj_wave.animate.unpause(),\n",
        "            ref_wave.animate.unpause(),\n",
        "            comb_wave.animate.unpause(),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show the circle\n",
        "        circle = Circle(radius=trg_x)\n",
        "        circle.move_to(film)\n",
        "        circle.set_stroke(GREY_D, 1)\n",
        "\n",
        "        tail = TracingTail(circle.get_end, stroke_color=BLUE_D, stroke_width=(0, 3))\n",
        "\n",
        "        self.add(tail)\n",
        "        self.wait()\n",
        "        self.add(circle, tail)\n",
        "        round_exposure.set_width(0.25)\n",
        "        self.play(\n",
        "            frame.animate.reorient(41, -15, 0, (-0.54, -0.17, -1.78), 4.65),\n",
        "            ShowCreation(circle),\n",
        "            UpdateFromFunc(trg_point, lambda m, c=circle: m.move_to(c.get_end())),\n",
        "            round_exposure.animate.set_width(3),\n",
        "            FadeOut(exposure, time_span=(0, 1)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(FadeOut(circle, run_time=2))\n",
        "        self.remove(tail)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Grow rings fully\n",
        "        exposure.replace(plate, stretch=True).shift(0.01 * OUT)\n",
        "\n",
        "        self.add(exposure, round_exposure)\n",
        "        self.play(\n",
        "            FadeOut(round_exposure, run_time=2),\n",
        "            FadeIn(exposure, run_time=2),\n",
        "            comb_wave.animate.set_opacity(0.5).set_anim_args(time_span=(6, 8)),\n",
        "            frame.animate.reorient(0, -23, 0, (-0.14, 0.01, -2.23), 6.52).set_anim_args(run_time=8)\n",
        "        )\n",
        "\n",
        "        # Just kinda hang for a bit\n",
        "        time0 = self.time\n",
        "        frame.add_updater(lambda m, t0=time0, sc=self: m.set_theta(math.sin(0.1 * (sc.time - t0)) * 30 * DEGREES))\n",
        "        self.play(trg_point.animate.move_to(film.get_left()), run_time=10)\n",
        "        self.play(trg_point.animate.move_to(film.get_right()), run_time=20)\n",
        "        self.wait(5)\n",
        "        frame.clear_updaters()\n",
        "\n",
        "        # Change wavelength\n",
        "        trg_wave_number = 16\n",
        "\n",
        "        for wave in [obj_wave, ref_wave, comb_wave, exposure]:\n",
        "            wave.set_wave_number(trg_wave_number)\n",
        "            wave.set_frequency(0.25 * trg_wave_number)\n",
        "\n",
        "        ref_line.insert_n_curves(1000)\n",
        "        obj_line.insert_n_curves(1000)\n",
        "        ref_graph.set_stroke(width=1)\n",
        "        obj_graph.set_stroke(width=1)\n",
        "\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            FadeOut(VGroup(ref_line, ref_graph, obj_line, obj_graph)),\n",
        "            FadeOut(comb_wave)\n",
        "        )\n",
        "\n",
        "        # Bring objet closer in\n",
        "        self.play(\n",
        "            frame.animate.reorient(-85, -9, 0, (0.65, -0.24, -0.14), 6.52),\n",
        "            run_time=4\n",
        "        )\n",
        "        exposure.point_sources.set_points([OUT, 1001 * OUT])\n",
        "        exposure.point_sources.set_radius(0)\n",
        "\n",
        "        mid_line = Line()\n",
        "        mid_line.set_stroke(TEAL, 2)\n",
        "\n",
        "        def get_film_point():\n",
        "            x, y, _ = source_point.get_center()\n",
        "            z = film.get_z()\n",
        "            return np.array([x, y, z])\n",
        "\n",
        "        mid_line.add_updater(lambda m: m.set_points_as_corners([source_point.get_center(), get_film_point()]))\n",
        "\n",
        "        def get_dist_label():\n",
        "            label = DecimalNumber(mid_line.get_length(), font_size=24)\n",
        "            label.set_backstroke(BLACK, 3)\n",
        "            label.rotate(PI / 2, DOWN)\n",
        "            label.next_to(mid_line, UP, SMALL_BUFF)\n",
        "            return label\n",
        "\n",
        "        dist_label = always_redraw(get_dist_label)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(mid_line, suspend_mobject_updating=True),\n",
        "            VFadeIn(dist_label),\n",
        "        )\n",
        "\n",
        "        for vect in [2 * IN, 4 * OUT, 2 * IN]:\n",
        "            self.play(\n",
        "                source_point.animate.shift(vect),\n",
        "                exposure.point_sources.animate.shift(vect),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Move in 3d\n",
        "        axes = ThreeDAxes()\n",
        "        axes.match_width(film)\n",
        "        axes.move_to(film)\n",
        "        mid_line.set_z_index(1)\n",
        "        dist_label.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            Write(axes, lag_ratio=0.01),\n",
        "            frame.animate.reorient(-44, -21, 0, (0.09, -0.06, -1.4), 7.22),\n",
        "            exposure.animate.set_opacity(0.5),\n",
        "            FadeOut(dist_label),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        frame.add_ambient_rotation(2 * DEGREES)\n",
        "        exposure.point_sources.add_updater(lambda m: m.move_to(source_point, IN))\n",
        "        points = [RIGHT, RIGHT + IN, 3 * LEFT + IN, 3 * LEFT + 2 * OUT, 2 * OUT + 3 * RIGHT + 2 * UP, UR, OUT]\n",
        "        for point in points:\n",
        "            self.play(source_point.animate.move_to(point), run_time=2)\n",
        "            self.wait()\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(axes),\n",
        "            FadeOut(mid_line),\n",
        "            FadeOut(source_point),\n",
        "        )\n",
        "\n",
        "        # Shine the reference through it\n",
        "        ref_wave.set_opacity(0.75)\n",
        "        ref_wave.set_wave_number(4.0)\n",
        "        ref_wave.set_frequency(1.0)\n",
        "        ref_wave.unpause()\n",
        "\n",
        "        self.add(exposure, ref_wave)\n",
        "        self.play(\n",
        "            FadeIn(ref_wave, time_span=(0, 2)),\n",
        "            frame.animate.reorient(0, -24, 0, (0.08, -0.07, -1.39), 7.22),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Go to other side\n",
        "        frame.reorient(-171, -18, 0, (0.12, -0.21, -1.33), 9.31)\n",
        "        self.remove(film)\n",
        "        self.add(exposure, plate)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, -16, 0, (-3.06, -0.18, -3.19), 1.49),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def get_round_exposure(self, exposure, radius=1.0, n_pieces=128):\n",
        "        d_theta = TAU / n_pieces\n",
        "        vects = [rotate_vector(RIGHT, theta) for theta in np.linspace(0, TAU, n_pieces + 1)]\n",
        "        result = Group(\n",
        "            exposure.copy().set_points([ORIGIN, v1, v2])\n",
        "            for v1, v2 in zip(vects, vects[1:])\n",
        "        )\n",
        "        result.set_width(radius)\n",
        "        result.move_to(exposure)\n",
        "        return result\n",
        "\n",
        "        self.add(round_exposure)\n",
        "\n",
        "    def get_3d_waves(self, wave, x_range=(-4, 4, 0.5), opacity=0.25):\n",
        "        waves = Group(\n",
        "            wave.copy().rotate(PI / 2, OUT).move_to(x * RIGHT)\n",
        "            for x in np.arange(*x_range)\n",
        "        )\n",
        "        waves.set_opacity(opacity)\n",
        "        cam_point = self.frame.get_implied_camera_location()\n",
        "        waves.sort(lambda p: -get_norm(p - cam_point))\n",
        "        return waves\n",
        "\n",
        "\n",
        "class ShowEffectOfChangedReferenceAngle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Create object and reference wave\n",
        "        frame = self.frame\n",
        "        axes = ThreeDAxes()\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        wave_width = 100\n",
        "        wave_number = 10\n",
        "        frequency = 1\n",
        "\n",
        "        source_points = GlowDots([OUT, 10 * OUT], color=WHITE, radius=0.0)\n",
        "        wave = LightWaveSlice(source_points)\n",
        "\n",
        "        wave.set_width(wave_width)\n",
        "        wave.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "        wave.center()\n",
        "        wave.set_wave_number(wave_number)\n",
        "        wave.set_frequency(frequency)\n",
        "        wave.set_max_amp(1.5)\n",
        "        wave.set_decay_factor(0.5)\n",
        "\n",
        "        # Add film\n",
        "        plate_border = Rectangle(16, 9)\n",
        "        plate_border.set_fill(BLACK, 0)\n",
        "        plate_border.set_stroke(WHITE, 2)\n",
        "        plate = Square3D()\n",
        "        plate.set_color(BLACK, 0.9)\n",
        "        plate.replace(plate_border, stretch=True)\n",
        "        plate.set_shading(0.1, 0.1, 0)\n",
        "        exposure = LightIntensity(source_points)\n",
        "        exposure.set_decay_factor(0)\n",
        "        exposure.set_wave_number(wave_number)\n",
        "        exposure.replace(plate_border, stretch=True).shift(1e-2 * OUT)\n",
        "        exposure.set_color(WHITE, 0.85)\n",
        "\n",
        "        plate_group = Group(plate_border, plate)\n",
        "        film = Group(plate_group, exposure)\n",
        "        film.set_height(4)\n",
        "        film.set_z(-2)\n",
        "\n",
        "        film_label = Text(\"Film\")\n",
        "        film_label.next_to(plate_group, UP)\n",
        "        film_label.set_backstroke(BLACK, 3)\n",
        "        film_label.set_z_index(1)\n",
        "\n",
        "        source_dot = GlowDot(source_points.get_points()[0], color=WHITE, radius=0.5)\n",
        "\n",
        "        self.add(film, exposure, wave, source_points, source_dot)\n",
        "\n",
        "        # Add reference wave lines\n",
        "        plate_border.insert_n_curves(max(25 - plate_border.get_num_curves(), 0))\n",
        "        film_points = np.array([plate_border.pfp(a) for a in np.linspace(0, 1, 500)])\n",
        "        ref_lines = Line().replicate(len(film_points))\n",
        "        ref_lines.set_stroke(GREEN_SCREEN, width=1, opacity=0.25)\n",
        "\n",
        "        def update_ref_lines(lines):\n",
        "            for line, point in zip(lines, film_points):\n",
        "                line.set_points_as_corners([source_points.get_points()[1], point])\n",
        "            return lines\n",
        "\n",
        "        ref_lines.add_updater(update_ref_lines)\n",
        "\n",
        "        self.add(ref_lines)\n",
        "\n",
        "        # Move reference wave\n",
        "        frame.reorient(-52, -29, 0, (1.21, -0.31, 1.52), 9.28)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(source_points, 60 * DEGREES, axis=UP, about_point=source_points.get_points()[0], run_time=5),\n",
        "            frame.animate.reorient(-48, -46, 0, (1.17, -0.41, 1.55), 9.28),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class DoubleSlit(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Show a diffraction grating\n",
        "        frame = self.frame\n",
        "        full_width = 40\n",
        "\n",
        "        n_slit_wall = self.get_wall_with_slits(16, spacing=1.0, total_width=full_width)\n",
        "        n_slit_wall.move_to(0.5 * IN, IN)\n",
        "        n_slit_wall.save_state()\n",
        "        n_slit_wall.arrange(RIGHT, buff=0)\n",
        "        n_slit_wall.move_to(n_slit_wall.saved_state)\n",
        "\n",
        "        in_wave = self.get_plane_wave()\n",
        "        in_wave.set_opacity(0.85)\n",
        "        in_wave.set_width(full_width)\n",
        "        in_wave.move_to(ORIGIN, UP)\n",
        "\n",
        "        line = Line(0.5 * IN + 16 * DOWN + 0.5 * OUT, 0.5 * IN + 0.5 * OUT)\n",
        "        graph = self.get_graph_over_wave(line, in_wave)\n",
        "\n",
        "        self.add(graph)\n",
        "        self.add(n_slit_wall)\n",
        "        self.add(in_wave)\n",
        "\n",
        "        frame.reorient(-31, 67, 0, (-3.1, 1.32, -1.12), 15.89)\n",
        "        self.play(\n",
        "            frame.animate.reorient(33, 65, 0, (1.24, 1.09, -0.39), 10.01),\n",
        "            UpdateFromAlphaFunc(\n",
        "                graph,\n",
        "                lambda m, a: m.set_stroke(width=3 * clip(there_and_back_with_pause(2 * a, 0.7), 0, 1)),\n",
        "            ),\n",
        "            Restore(n_slit_wall, time_span=(9, 12)),\n",
        "            run_time=15\n",
        "        )\n",
        "\n",
        "        # Preview the other side\n",
        "        sources = self.get_point_sources_from_wall(n_slit_wall)\n",
        "        sources.set_opacity(0)\n",
        "        out_wave = LightWaveSlice(sources)\n",
        "        out_wave.set_max_amp(1)\n",
        "        out_wave.set_opacity(0.85)\n",
        "        out_wave.set_decay_factor(0.5)\n",
        "        out_wave.set_width(full_width * 2.5)\n",
        "        out_wave.move_to(ORIGIN, DOWN)\n",
        "\n",
        "        self.add(sources)\n",
        "        self.play(\n",
        "            frame.animate.reorient(1, 49, 0, (-0.02, 3.62, 0.61), 11.96),\n",
        "            FadeIn(out_wave, time_span=(0, 2), suspend_mobject_updating=False),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Change spacing\n",
        "        wall = n_slit_wall\n",
        "        wall.target = self.get_wall_with_slits(16, spacing=2 + 0.2 * PI, total_width=2 * full_width)\n",
        "        wall.target.move_to(wall)\n",
        "        in_wave.match_width(out_wave)\n",
        "        in_wave.move_to(ORIGIN, UP)\n",
        "\n",
        "        start_arrows, end_arrows = [\n",
        "            VGroup(\n",
        "                Tex(R\"\\leftrightarrow\").set_width(0.7 * block.get_width(), stretch=True).next_to(block, OUT)\n",
        "                for block in group[1:-1]\n",
        "            ).rotate(30 * DEGREES, RIGHT).set_backstroke(BLACK, 5)\n",
        "            for group in [wall, wall.target]\n",
        "        ]\n",
        "\n",
        "        self.play(FadeIn(start_arrows))\n",
        "        self.play(\n",
        "            Transform(start_arrows, end_arrows),\n",
        "            MoveToTarget(wall),\n",
        "            sources.animate.match_points(self.get_point_sources_from_wall(wall.target)),\n",
        "            # frame.animate.reorient(0, 40, 0, (-0.61, 5.11, 1.62), 24.87),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(FadeOut(start_arrows))\n",
        "\n",
        "        out_wave.set_width(500, about_edge=DOWN)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 52, 0, (0.91, 35.42, 33.91), 102.49),\n",
        "            run_time=16\n",
        "        )\n",
        "\n",
        "        # Reduce to one slit\n",
        "        single_slit_wall = self.get_wall_with_slits(1)\n",
        "        single_slit_wall.move_to(wall)\n",
        "        source = self.get_point_sources_from_wall(single_slit_wall)\n",
        "        source.set_radius(0.5)\n",
        "        radial_wave = LightWaveSlice(source)\n",
        "        radial_wave.set_width(full_width)\n",
        "        radial_wave.move_to(ORIGIN, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(11, 65, 0, (-0.03, 0.06, 0.14), 8.66),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(single_slit_wall, in_wave)\n",
        "        self.play(\n",
        "            FadeOut(wall, scale=0.9),\n",
        "            FadeOut(out_wave, suspend_mobject_updating=False),\n",
        "            FadeIn(single_slit_wall),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 9, 0, (-0.04, 1.61, 0.15), 8.66),\n",
        "            FadeIn(radial_wave, suspend_mobject_updating=False),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        single_slit_wall.set_z_index(1)\n",
        "        self.play(\n",
        "            FadeIn(source),\n",
        "            single_slit_wall.animate.set_opacity(0.1),\n",
        "            in_wave.animate.set_opacity(0.1),\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Setup for sine waves\n",
        "        def field_func(points):\n",
        "            result = np.zeros_like(points)\n",
        "            result[:, 2] = 0.5 * radial_wave.wave_func(points)\n",
        "            return result\n",
        "\n",
        "        # Expose some film\n",
        "        film_shape = (12, 6)\n",
        "        film = Rectangle(*film_shape)\n",
        "        film.set_fill(GREY_E, 1)\n",
        "        film.set_stroke(WHITE, 1)\n",
        "        film.rotate(PI / 2, RIGHT)\n",
        "        film.move_to(source).set_y(5)\n",
        "\n",
        "        exposure = LightIntensity(source, shape=film_shape)\n",
        "        exposure.rotate(PI / 2, RIGHT)\n",
        "        exposure.move_to(film)\n",
        "        exposure.set_color(GREEN_SCREEN)\n",
        "        exposure.set_decay_factor(3.5)\n",
        "        exposure.set_max_amp(0.005)\n",
        "        exposure.set_opacity(1e-3)\n",
        "\n",
        "        radial_wave.set_z_index(1)\n",
        "\n",
        "        single_slit_wall.set_opacity(1)\n",
        "        single_slit_wall.set_depth(1.5, about_edge=IN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(source),\n",
        "            FadeIn(film, shift=5 * IN),\n",
        "            FadeIn(exposure, shift=5 * IN),\n",
        "            FadeIn(single_slit_wall),\n",
        "            in_wave.animate.set_opacity(0.85).set_time_rate(1.0).set_anim_args(suspend_mobject_updating=False),\n",
        "            radial_wave.animate.set_time_rate(1.0).set_anim_args(suspend_mobject_updating=False),\n",
        "            frame.animate.reorient(-19, 68, 0, (-2.38, 4.22, 0.53), 10.86),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(exposure.animate.set_opacity(1))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Wave to various spots\n",
        "        exposure_glow = GlowDot(color=GREEN_SCREEN)\n",
        "        exposure_glow.move_to(film.get_center())\n",
        "        line = Line(stroke_color=TEAL)\n",
        "        line.f_always.put_start_and_end_on(\n",
        "            source.get_center, exposure_glow.get_center\n",
        "        )\n",
        "        graph = self.get_graph_over_wave(line, radial_wave, scale_factor=0.2)\n",
        "        graph.set_stroke(WHITE, 2, 1)\n",
        "        line.set_stroke(opacity=0)\n",
        "\n",
        "        graph.set_z_index(0)\n",
        "        line.set_stroke(TEAL, 2, 1)\n",
        "        self.add(line, graph, radial_wave)\n",
        "        self.play(\n",
        "            VFadeIn(graph),\n",
        "            VFadeIn(line),\n",
        "            FadeIn(exposure_glow),\n",
        "            frame.animate.reorient(-46, 65, 0, (-1.12, 3.76, 0.49), 6.83),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(exposure_glow.animate.shift(5 * RIGHT).set_opacity(0.5), run_time=3)\n",
        "        self.play(\n",
        "            radial_wave.animate.set_decay_factor(1.0).set_max_amp(0.75).set_anim_args(suspend_mobject_updating=False),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(9, 59, 0, (0.54, 4.02, 0.04), 8.32),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        source.match_points(self.get_point_sources_from_wall(single_slit_wall))\n",
        "\n",
        "        # Change to double slit\n",
        "        two_slit_wall = self.get_wall_with_slits(2, spacing=3.0, depth=single_slit_wall.get_depth())\n",
        "        two_slit_wall.move_to(single_slit_wall)\n",
        "\n",
        "        source.match_points(self.get_point_sources_from_wall(two_slit_wall))\n",
        "\n",
        "        self.remove(single_slit_wall, graph, line, exposure_glow)\n",
        "        self.add(two_slit_wall)\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-25, 48, 0, (0.23, 4.15, -0.03), 9.80),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(28, 50, 0, (0.23, 4.15, -0.03), 9.80),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        out_wave = radial_wave  # Just rename\n",
        "\n",
        "        # Down to two point sources\n",
        "        source_pair = source\n",
        "        source1 = source.copy().set_points(source.get_points()[0:1])\n",
        "        source2 = source.copy().set_points(source.get_points()[1:2])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(two_slit_wall, shift=2 * IN),\n",
        "            FadeOut(in_wave, suspend_mobject_updating=False),\n",
        "            FadeIn(source1),\n",
        "            FadeIn(source2),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 68, 0, (0.23, 4.15, -0.03), 9.80),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Show each individual wave\n",
        "        wave1 = out_wave.copy().set_sources(source1).shift(1e-3 * OUT)\n",
        "        wave2 = out_wave.copy().set_sources(source2).shift(1e-3 * IN)\n",
        "        exp1 = exposure.copy().set_sources(source1).shift(1e-3 * DOWN)\n",
        "        exp2 = exposure.copy().set_sources(source2).shift(2e-3 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(source2),\n",
        "            FadeOut(out_wave, suspend_mobject_updating=False),\n",
        "            FadeIn(wave1, suspend_mobject_updating=False),\n",
        "            exposure.animate.set_opacity(0),\n",
        "            FadeIn(exp1),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.add(wave2, wave1)\n",
        "        self.play(\n",
        "            FadeOut(source1),\n",
        "            FadeIn(source2),\n",
        "            FadeOut(wave1, suspend_mobject_updating=False),\n",
        "            FadeIn(wave2, suspend_mobject_updating=False),\n",
        "            FadeOut(exp1),\n",
        "            FadeIn(exp2),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeIn(source1),\n",
        "            FadeOut(wave2, suspend_mobject_updating=False),\n",
        "            FadeIn(out_wave, suspend_mobject_updating=False),\n",
        "            FadeOut(exp2),\n",
        "            exposure.animate.set_opacity(1),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Focus on center point\n",
        "        exposure_point = GlowDot(color=GREEN_SCREEN)\n",
        "        exposure_point.move_to(film.get_center())\n",
        "\n",
        "        lines = Line().replicate(2)\n",
        "        lines.set_stroke(TEAL, 2)\n",
        "        lines[0].f_always.put_start_and_end_on(source1.get_center, exposure_point.get_center)\n",
        "        lines[1].f_always.put_start_and_end_on(source2.get_center, exposure_point.get_center)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            self.get_graph_over_wave(lines[0], wave1),\n",
        "            self.get_graph_over_wave(lines[1], wave2),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            out_wave.animate.pause().set_opacity(0.5),\n",
        "            exposure.animate.set_opacity(0),\n",
        "            frame.animate.reorient(0, 69, 0, (-0.09, 4.1, -0.16), 7.52),\n",
        "            FadeIn(exposure_point),\n",
        "            run_time=3,\n",
        "        )\n",
        "        wave1.set_uniform(time=out_wave.uniforms[\"time\"])\n",
        "        wave2.set_uniform(time=out_wave.uniforms[\"time\"])\n",
        "        self.play(ShowCreation(lines, lag_ratio=0, suspend_mobject_updating=True))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(graphs, lag_ratio=0, run_time=3, suspend_mobject_updating=True))\n",
        "\n",
        "        # Show combination from a side angle\n",
        "        self.play(frame.animate.reorient(-80, 83, 0, (-0.09, 4.1, -0.16), 7.52), run_time=3)\n",
        "        wave1.pause().set_opacity(0)\n",
        "        wave2.pause().set_opacity(0)\n",
        "        self.add(wave1, wave2)\n",
        "        self.play(*(\n",
        "            wave.animate.unpause().set_anim_args(suspend_mobject_updating=False)\n",
        "            for wave in [out_wave, wave1, wave2]\n",
        "        ))\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 66, 0, (0.12, 4.03, -0.38), 7.52),\n",
        "            *(\n",
        "                wave.animate.pause().set_anim_args(suspend_mobject_updating=False)\n",
        "                for wave in [out_wave, wave1, wave2]\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shift to a destructive point\n",
        "        self.play(\n",
        "            exposure_point.animate.shift(0.9 * RIGHT).set_opacity(0.25),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-98, 82, 0, (0.27, 4.19, -0.01), 2.93),\n",
        "            *(\n",
        "                wave.animate.unpause().set_anim_args(suspend_mobject_updating=False)\n",
        "                for wave in [out_wave, wave1, wave2]\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(8)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-2, 69, 0, (-0.23, 2.91, 0.1), 6.38),\n",
        "            exposure.animate.set_opacity(1),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # And now over to another constructive point\n",
        "        self.play(\n",
        "            exposure_point.animate.shift(0.9 * RIGHT).set_opacity(1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(81, 88, 0, (-0.23, 2.91, 0.1), 6.38),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 67, 0, (-0.07, 1.75, 0.9), 6.42),\n",
        "            *(\n",
        "                wave.animate.pause().set_anim_args(suspend_mobject_updating=False)\n",
        "                for wave in [out_wave, wave1, wave2]\n",
        "            ),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(\n",
        "            exposure_point.animate.shift(5 * LEFT),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.play(\n",
        "            exposure_point.animate.move_to(film.get_center()),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Shorten wave length\n",
        "        trg_color = Color(hsl=(0.7, 0.7, 0.5))\n",
        "        self.play(\n",
        "            *(\n",
        "                wave.animate.set_wave_number(2).set_anim_args(suspend_mobject_updating=False)\n",
        "                for wave in [out_wave, wave1, wave2, exposure]\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                Point(),\n",
        "                lambda m, a: exposure.set_color(interpolate_color_by_hsl(GREEN_SCREEN, trg_color, a)),\n",
        "                remover=True\n",
        "            ),\n",
        "            exposure_point.animate.set_color(trg_color),\n",
        "            run_time=6\n",
        "        )\n",
        "\n",
        "        new_out_wave = LightWaveSlice(source_pair)\n",
        "        new_out_wave.replace(out_wave, stretch=True)\n",
        "        new_out_wave.set_uniforms(dict(out_wave.uniforms))\n",
        "        new_out_wave.pause()\n",
        "        self.remove(out_wave)\n",
        "        self.add(new_out_wave)\n",
        "        out_wave = new_out_wave\n",
        "\n",
        "        # Pan over various spots\n",
        "        for wave in [out_wave, wave1, wave2]:\n",
        "            wave.set_frequency(2)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-80, 68, 0, (-0.22, 2.44, 0.8), 6.42),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            exposure_point.animate.shift(3 * LEFT),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=16,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(graphs),\n",
        "        )\n",
        "        self.remove(wave1, wave2)\n",
        "\n",
        "        # Bring back slits, look over it all\n",
        "        self.play(out_wave.animate.unpause().set_opacity(1).set_anim_args(suspend_mobject_updating=False))\n",
        "        new_in_wave = self.get_plane_wave()\n",
        "        new_in_wave.replace(in_wave)\n",
        "        new_in_wave.set_wave_number(2)\n",
        "        new_in_wave.set_frequency(2)\n",
        "        new_in_wave.set_opacity(0.75)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(new_in_wave, time_span=(0, 2), suspend_mobject_updating=False),\n",
        "            FadeIn(two_slit_wall, time_span=(0, 1)),\n",
        "            FadeOut(source1, time_span=(0, 2)),\n",
        "            FadeOut(source2, time_span=(0, 2)),\n",
        "            frame.animate.reorient(-25, 62, 0, (-0.82, 2.58, 0.5), 9.13),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(30, 60, 0, (-0.48, 2.77, 0.52), 9.13),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=24\n",
        "        )\n",
        "\n",
        "\n",
        "class FullDiffractionGrating(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Set up the grating\n",
        "        full_width = 100\n",
        "        wave_number = 2 + 0.1 * PI  # Make it irrational\n",
        "        frequency = 1\n",
        "        slit_dist = 1.0\n",
        "\n",
        "        frame = self.frame\n",
        "        frame.reorient(-28, 76, 0, (0, 3.29, -0.61), 8.17)\n",
        "\n",
        "        wall = self.get_wall_with_slits(32, spacing=slit_dist, depth=2.0, total_width=full_width)\n",
        "        wall.move_to(0.5 * IN, IN)\n",
        "\n",
        "        in_wave = self.get_plane_wave()\n",
        "        in_wave.set_wave_number(wave_number)\n",
        "        in_wave.set_frequency(frequency)\n",
        "        in_wave.set_shape(full_width, full_width)\n",
        "        in_wave.set_opacity(0.85)\n",
        "        in_wave.move_to(ORIGIN, UP)\n",
        "\n",
        "        sources = self.get_point_sources_from_wall(wall)\n",
        "        out_wave = LightWaveSlice(sources, wave_number=wave_number, frequency=frequency)\n",
        "        out_wave.set_shape(full_width, full_width)\n",
        "        out_wave.set_opacity(0.25)\n",
        "        out_wave.set_max_amp(2)\n",
        "        out_wave.move_to(ORIGIN, DOWN)\n",
        "\n",
        "        self.add(wall)\n",
        "        self.add(in_wave)\n",
        "        self.add(out_wave)\n",
        "\n",
        "        # Label the distance apart\n",
        "        piece = wall[16]\n",
        "        brace = Brace(piece, UP)\n",
        "        brace.rotate(PI / 2, RIGHT)\n",
        "        brace.next_to(piece, OUT, SMALL_BUFF)\n",
        "        dist_label = Tex(R\"d\", font_size=60)\n",
        "        dist_label.rotate(PI / 2, RIGHT)\n",
        "        dist_label.next_to(brace, OUT, SMALL_BUFF)\n",
        "        VGroup(brace, dist_label).set_backstroke(BLACK, 5)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(dist_label, 0.25 * OUT),\n",
        "            frame.animate.reorient(11, 72, 0, (-1.12, 5.34, -0.64), 11.13).set_anim_args(run_time=8),\n",
        "        )\n",
        "        dist_label.add(brace)\n",
        "\n",
        "        # Show model as an array of point sources\n",
        "        sources.set_radius(0.5)\n",
        "        wall.save_state()\n",
        "        wall.target = wall.generate_target()\n",
        "        wall.target.stretch(0.05, dim=2, about_point=ORIGIN)\n",
        "        wall.target.stretch(0.5, dim=1, about_point=ORIGIN)\n",
        "\n",
        "        dist_label.set_z_index(1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 12, 0, (0, 4.45, -0.62), 11.20),\n",
        "            dist_label.animate.rotate(PI / 2, LEFT).next_to(piece, UP, SMALL_BUFF),\n",
        "            MoveToTarget(wall, time_span=(3, 5)),\n",
        "            FadeIn(sources, time_span=(1, 3)),\n",
        "            out_wave.animate.set_opacity(1).set_anim_args(suspend_mobject_updating=False),\n",
        "            in_wave.animate.set_opacity(0.25).set_anim_args(suspend_mobject_updating=False),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show the N graphs\n",
        "        point_tracker = GlowDot(color=YELLOW, radius=1)\n",
        "        point_tracker.move_to(8 * UP)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for line, source_point in zip(lines, sources.get_points()):\n",
        "                line.put_start_and_end_on(source_point, point_tracker.get_center())\n",
        "\n",
        "        lines = Line().replicate(sources.get_num_points())\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "        lines.add_updater(update_lines)\n",
        "\n",
        "        individual_sources = Group(\n",
        "            sources.copy().set_points(sources.get_points()[i:i + 1])\n",
        "            for i in range(sources.get_num_points())\n",
        "        )\n",
        "\n",
        "        waves = Group(\n",
        "            out_wave.copy().set_sources(src).set_opacity(0)\n",
        "            for src in individual_sources\n",
        "        )\n",
        "        waves.scale(0)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            self.get_graph_over_wave(line, wave, scale_factor=0.25)\n",
        "            for line, wave in zip(lines, waves)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            out_wave.animate.set_opacity(0.2).set_anim_args(suspend_mobject_updating=False),\n",
        "            FadeOut(dist_label),\n",
        "            FadeIn(point_tracker),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(lines, graphs, out_wave)\n",
        "        self.add(waves)\n",
        "        self.play(\n",
        "            ShowCreation(lines, lag_ratio=0.01, time_span=(0, 2)),\n",
        "            ShowCreation(graphs, lag_ratio=0.01, suspend_mobject_updating=False, time_span=(0, 2)),\n",
        "            frame.animate.reorient(1, 57, 0, (-0.17, 5.75, 0.32), 14.54),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(graphs),\n",
        "            FadeOut(point_tracker),\n",
        "            out_wave.animate.set_opacity(0.85).set_anim_args(suspend_mobject_updating=False),\n",
        "            frame.animate.reorient(0, 42, 0, (0, 5.4, 0.45), 13.00),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(waves)\n",
        "\n",
        "        # Zoom out to large\n",
        "        out_wave.set_width(500, about_edge=DOWN)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0, 95, 0), 200),\n",
        "            out_wave.animate.set_max_amp(1).set_anim_args(suspend_mobject_updating=False),\n",
        "            run_time=20\n",
        "        )\n",
        "\n",
        "        # Let it run for a few cycles, we'll use this as an underlay for parts that follow\n",
        "        self.wait(4)\n",
        "\n",
        "        # Highlight the higher order beams\n",
        "        in_wave.scale(0)\n",
        "        out_wave.scale(0)\n",
        "\n",
        "        beam_point = GlowDot(color=WHITE, radius=3)\n",
        "        beam_point.move_to(1000 * UP)\n",
        "        beam_outlines = Line().replicate(2)\n",
        "        center_beam_line = Line()\n",
        "        VGroup(beam_outlines, center_beam_line).set_stroke(WHITE, 50)\n",
        "        beam_outlines[0].f_always.put_start_and_end_on(sources.get_left, beam_point.get_center)\n",
        "        beam_outlines[1].f_always.put_start_and_end_on(sources.get_right, beam_point.get_center)\n",
        "        center_beam_line.f_always.put_start_and_end_on(sources.get_center, beam_point.get_center)\n",
        "\n",
        "        theta = math.asin(1.0 / wave_number / slit_dist)  # Diffraction equation!\n",
        "\n",
        "        self.play(ShowCreation(beam_outlines, lag_ratio=0))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Rotate(beam_point, -theta, about_point=ORIGIN),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(beam_point, 2 * theta, about_point=ORIGIN),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Ask about the angle\n",
        "        v_line = Line(ORIGIN, get_norm(beam_point.get_center()) * UP)\n",
        "        d_line = Line(ORIGIN, beam_point.get_center())\n",
        "        VGroup(v_line, d_line).set_stroke(WHITE, 50)\n",
        "\n",
        "        arc = og_big_arc = Arc(PI / 2 + theta, -theta, radius=30)\n",
        "        arc.set_stroke(WHITE, 50)\n",
        "        theta_sym = Tex(R\"\\theta\")\n",
        "        theta_sym.set_width(arc.get_width() / 2)\n",
        "        theta_sym.next_to(arc, UP, buff=2).shift(LEFT)\n",
        "\n",
        "        self.remove(beam_outlines)\n",
        "        self.play(\n",
        "            TransformFromCopy(beam_outlines[0], d_line),\n",
        "            TransformFromCopy(beam_outlines[1], d_line),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(d_line, v_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_sym),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Analyze central beam\n",
        "        beam_point.rotate(-theta, about_point=ORIGIN)\n",
        "        point_tracker.move_to(180 * UP)\n",
        "        point_tracker.set_radius(8)\n",
        "\n",
        "        L_line = Line(ORIGIN, point_tracker.get_center())\n",
        "        x_line = Line(sources.get_center(), sources.get_left())\n",
        "        hyp = Line(sources.get_left(), point_tracker.get_center())\n",
        "        VGroup(L_line, hyp).set_stroke(YELLOW, width=50)\n",
        "        x_line.set_stroke(WHITE, 50)\n",
        "\n",
        "        L_label = Tex(\"L\", font_size=800)\n",
        "        x_label = Tex(\"x\", font_size=800)\n",
        "        hyp_label = Tex(R\"\\sqrt{L^2 + x^2}\", font_size=800)\n",
        "\n",
        "        L_label.next_to(L_line.pfp(0.4), RIGHT, buff=2)\n",
        "        L_label.match_color(L_line)\n",
        "        x_label.next_to(x_line, UP, buff=3)\n",
        "        hyp_label.next_to(hyp.pfp(0.4), LEFT, buff=2)\n",
        "        hyp_label.match_color(hyp)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(beam_outlines),\n",
        "            FadeOut(d_line),\n",
        "            FadeOut(v_line),\n",
        "            FadeOut(arc),\n",
        "            FadeOut(theta_sym),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(point_tracker),\n",
        "            out_wave.animate.set_opacity(0.5).set_anim_args(suspend_mobject_updating=False)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(L_line),\n",
        "            VFadeIn(L_label),\n",
        "            FadeOut(beam_outlines),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(L_line, hyp),\n",
        "            ShowCreation(x_line),\n",
        "            TransformMatchingStrings(L_label.copy(), hyp_label),\n",
        "            FadeIn(x_label, shift=3 * LEFT),\n",
        "        )\n",
        "\n",
        "        # Show the approximation (In another scene)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show all the different lines\n",
        "        self.play(FadeOut(VGroup(L_label, x_label, hyp_label, x_line, L_line, hyp)))\n",
        "        lines.set_stroke(YELLOW, 30)\n",
        "        lines.update()\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreationThenFadeOut, lines, lag_ratio=0.25, run_time=8))\n",
        "\n",
        "        # Analyze a point off the center\n",
        "        new_angle = theta\n",
        "        lines.set_stroke(width=10)\n",
        "        arc = Arc(PI / 2 - new_angle, new_angle, radius=30)\n",
        "        arc.set_stroke(WHITE, 50)\n",
        "        theta_sym = Tex(R\"\\theta\")\n",
        "        theta_sym.set_width(0.45 * arc.get_width())\n",
        "        theta_sym.next_to(arc.get_center(), UP, buff=2).shift(RIGHT)\n",
        "        d_line = v_line.copy().rotate(-new_angle, about_edge=DOWN)\n",
        "        question = Text(\"What about\\nover here?\")\n",
        "        question.set_height(15)\n",
        "        question.rotate(frame.get_phi(), RIGHT)\n",
        "        question.always.next_to(point_tracker, DR, buff=-2)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(point_tracker, -new_angle, about_point=ORIGIN),\n",
        "            VFadeIn(question),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(ShowCreation(d_line))\n",
        "        self.play(\n",
        "            TransformFromCopy(d_line, v_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_sym)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(lines, lag_ratio=0.01, run_time=2, suspend_mobject_updating=True),\n",
        "            FadeOut(VGroup(v_line, d_line, arc, theta_sym))\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            point_tracker.animate.move_to(1.15 * point_tracker.get_center()),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Zoom in near the slits again\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0.0, 2.75, 0.0), 8),\n",
        "            lines.animate.set_stroke(width=5),\n",
        "            out_wave.animate.set_opacity(0.1).set_anim_args(suspend_mobject_updating=False),\n",
        "            in_wave.animate.set_opacity(0.1).set_anim_args(suspend_mobject_updating=False),\n",
        "            sources.animate.set_radius(0.35),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show individual lines\n",
        "        lines.suspend_updating()\n",
        "        line1 = lines[15].copy()\n",
        "        line2 = lines[16].copy()\n",
        "        line2.set_stroke(WHITE)\n",
        "        for line in [line1, line2]:\n",
        "            line.set_length(8, about_point=line.get_start())\n",
        "            line.set_stroke(opacity=1)\n",
        "            line.save_state()\n",
        "\n",
        "        lines.target = lines.generate_target()\n",
        "        lines.target.set_stroke(width=1, opacity=0.5)\n",
        "\n",
        "        long_label = Text(\"Is this longer...\")\n",
        "        short_label = Text(\"...than this?\")\n",
        "        long_label.match_color(line1)\n",
        "        long_label.next_to(line1.get_center(), LEFT)\n",
        "        short_label.next_to(line2.get_center(), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(lines),\n",
        "            ShowCreation(line1, time_span=(0.5, 1.5)),\n",
        "            FadeIn(long_label, time_span=(0.5, 1.5))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(line2),\n",
        "            TransformMatchingStrings(long_label.copy(), short_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom out and pivot\n",
        "        for line in [line1, line2]:\n",
        "            line.put_start_and_end_on(line.get_start(), point_tracker.get_center())\n",
        "\n",
        "        tail = TracingTail(line.get_start, time_traced=3.0, stroke_width=(0, 10))\n",
        "        point_label = TexText(R\"Point we're\\\\analyzing\")\n",
        "        point_label.set_height(1.5 * question.get_height())\n",
        "        point_label.move_to(question, UL)\n",
        "        self.remove(question)\n",
        "        self.add(point_label)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (14.74, 92.42, 0.0), 209.77),\n",
        "            line2.animate.set_stroke(width=50),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(tail)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                line2, -30 * DEGREES,\n",
        "                about_point=point_tracker.get_center(),\n",
        "                rate_func=lambda t: wiggle(t, 2),\n",
        "                run_time=8,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0, 1.5, 0.0), 6.0),\n",
        "            line2.animate.set_stroke(width=5),\n",
        "            VFadeOut(tail),\n",
        "            FadeOut(point_label),\n",
        "            FadeOut(in_wave, suspend_mobject_updating=False),\n",
        "            FadeOut(out_wave, suspend_mobject_updating=False),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Rotate again, as a perp\n",
        "        tail.add_updater(lambda m: m.set_stroke(width=(0, 5)))\n",
        "        self.add(tail)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                line2, -1 * DEGREES,\n",
        "                about_point=point_tracker.get_center(),\n",
        "                # rate_func=lambda t: wiggle(t, 2),\n",
        "                rate_func=there_and_back,\n",
        "                run_time=5,\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.remove(tail)\n",
        "\n",
        "        # Drop perpendicular\n",
        "        p1 = line1.get_start()\n",
        "        p2 = line2.get_start()\n",
        "        to_point = rotate_vector(UP, -theta)\n",
        "        foot = p1 + math.sin(theta) * to_point\n",
        "\n",
        "        diff_label_group = always_redraw(lambda: self.get_diff_label_group(\n",
        "            p1=sources.get_points()[15],\n",
        "            p2=sources.get_points()[16],\n",
        "            theta=PI / 2 - line1.get_angle()\n",
        "        ))\n",
        "        diff_label_group.suspend_updating()\n",
        "        triangle, elbow, altitude, arc, small_theta_sym, diff_segment, brace, d_label = diff_label_group\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(altitude),\n",
        "            FadeOut(VGroup(long_label, short_label)),\n",
        "            frame.animate.reorient(0, 0, 0, (0.5, 0.88, 0.0), 3.8),\n",
        "            sources.animate.set_radius(0.2),\n",
        "        )\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.wait()\n",
        "\n",
        "        # Compare lengths\n",
        "        for line in line1, line2:\n",
        "            line.set_length(5, about_point=line.get_start())\n",
        "        matched_segment = line2.copy().shift(altitude.get_vector())\n",
        "        matched_segment.set_color(TEAL)\n",
        "        label1 = TexText(R\"Length of shorter line $\\rightarrow$\", font_size=24)\n",
        "        label1.next_to(p2, UR, buff=SMALL_BUFF)\n",
        "        label1.rotate(PI / 2 - theta, about_point=p2)\n",
        "        label1.shift(0.1 * to_point)\n",
        "        label2 = label1.copy()\n",
        "        label2.match_color(matched_segment)\n",
        "        label2.shift(matched_segment.get_start() - line2.get_start())\n",
        "\n",
        "        diff_label = Text(\"Difference\", font_size=24)\n",
        "        diff_label.next_to(brace.get_center(), LEFT, buff=0.2).shift(0.15 * UP)\n",
        "        diff_label.set_color(RED)\n",
        "        diff_segment.set_stroke(RED, 5)\n",
        "\n",
        "        self.play(\n",
        "            Write(label1, stroke_width=1),\n",
        "            ShowCreation(line2),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(line2, matched_segment),\n",
        "            line1.animate.set_stroke(width=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromCenter(brace),\n",
        "            GrowFromCenter(diff_segment),\n",
        "            Write(diff_label, stroke_width=1),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Draw the appropriate right triangle\n",
        "        d_sine_theta = Tex(R\"d \\cdot \\sin(\\theta)\", font_size=24)\n",
        "        d_sine_theta.move_to(diff_label, RIGHT)\n",
        "\n",
        "        self.add(triangle, elbow, altitude, diff_segment)\n",
        "        self.play(\n",
        "            wall.animate.set_height(0.01, stretch=True),\n",
        "            FadeIn(triangle),\n",
        "            FadeOut(label1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(d_label, 0.25 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(d_label.copy(), d_sine_theta, run_time=1),\n",
        "            FadeOut(diff_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(d_sine_theta[R\"\\theta\"][0], small_theta_sym),\n",
        "            ShowCreation(arc),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Lock the leg to match wavelength\n",
        "        self.remove(in_wave, out_wave)\n",
        "        self.checkpoint(\"d*sin(theta)\")\n",
        "\n",
        "        lambda_label = Tex(R\"= \\lambda\")\n",
        "        lambda_label[1].set_color(TEAL)\n",
        "        lambda_label.set_height(0.75 * d_sine_theta.get_height())\n",
        "        lambda_label.add_updater(lambda m: m.next_to(brace.pfp(0.5), UL, buff=0.025))\n",
        "\n",
        "        n_cycles = 8\n",
        "        sine = FunctionGraph(lambda x: -math.sin(x), x_range=(0, n_cycles * TAU, 0.1))\n",
        "        sine.set_stroke(TEAL, 1)\n",
        "        sine.set_width(n_cycles * diff_segment.get_length())\n",
        "        sine.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            diff_segment.get_start(), diff_segment.get_end()\n",
        "        ).scale(n_cycles, about_point=diff_segment.get_start()))\n",
        "\n",
        "        lock_arrow = Vector(0.5 * DOWN, thickness=2).next_to(brace, UP, buff=0.05)\n",
        "        lock_label = Text(\"Consider this\\nlocked\", font_size=16)\n",
        "        lock_label.next_to(lock_arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            d_sine_theta.animate.scale(0.75).next_to(lambda_label, LEFT, buff=0.05).shift(0.025 * DOWN),\n",
        "            FadeIn(lambda_label, 0.25 * RIGHT),\n",
        "            FadeOut(line2),\n",
        "            FadeOut(matched_segment),\n",
        "            diff_segment.animate.set_stroke(width=2),\n",
        "            frame.animate.reorient(0, 0, 0, (0.14, 0.48, 0.0), 3.17).set_anim_args(run_time=2),\n",
        "        )\n",
        "        self.play(ShowCreation(sine, rate_func=linear))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(lock_label),\n",
        "            GrowArrow(lock_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(lock_arrow, lock_label)))\n",
        "\n",
        "        # Show the other sine waves\n",
        "        shift_value = p2 - p1\n",
        "        other_sines = VGroup(sine.copy().shift(x * shift_value) for x in range(-2, 4) if x != 0)\n",
        "        other_sines.clear_updaters()\n",
        "\n",
        "        self.play(ShowCreation(other_sines, lag_ratio=0.25, run_time=4))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(other_sines, lag_ratio=0.25, run_time=2))\n",
        "\n",
        "        # Change the distance between points\n",
        "        self.add(diff_label_group)\n",
        "        diff_label_group.resume_updating()\n",
        "\n",
        "        lines.resume_updating()\n",
        "        line1.clear_updaters()\n",
        "        line1.add_updater(lambda m: m.match_points(lines[15]))\n",
        "        line1.resume_updating()\n",
        "\n",
        "        def get_dist_point(wavelength):\n",
        "            dist_to_point = get_norm(point_tracker.get_center())\n",
        "            d = get_norm(sources.get_points()[1] - sources.get_points()[0])\n",
        "            angle = math.asin(wavelength / d)\n",
        "            return rotate_vector(UP, -angle) * dist_to_point\n",
        "\n",
        "        self.add(lines, line1, diff_label_group, sine)\n",
        "        wall_center = sources.get_points()[15]\n",
        "        scale_factors = [0.5, 2.0, 1.5, 1.0 / 1.5][:-1]\n",
        "        for scale_factor in scale_factors:\n",
        "            arrows = VGroup(Vector(0.3 * RIGHT, thickness=1), Vector(0.3 * LEFT, thickness=1))\n",
        "            arrows.arrange(RIGHT if scale_factor < 1 else LEFT, buff=0.25)\n",
        "            arrows.always.move_to(d_label)\n",
        "            self.play(\n",
        "                UpdateFromFunc(point_tracker, lambda m: m.move_to(get_dist_point(1.0 / wave_number))),\n",
        "                MaintainPositionRelativeTo(d_sine_theta, lambda_label),\n",
        "                sources.animate.scale(scale_factor, about_point=wall_center),\n",
        "                wall.animate.scale(scale_factor, about_point=wall_center),\n",
        "                FadeIn(arrows, scale=scale_factor, suspend_mobject_updating=False, time_span=(0, 2)),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.play(FadeOut(arrows))\n",
        "\n",
        "        # Show double\n",
        "        if False:  # This was just a temporary insert, not to be run in general\n",
        "            d_angle2, d_angle3 = [\n",
        "                angle_of_vector(get_dist_point(n / wave_number)) - angle_of_vector(get_dist_point((n + 1) / wave_number))\n",
        "                for n in (1, 2)\n",
        "            ]\n",
        "            sine.clear_updaters()\n",
        "            new_rhs = Tex(Rf\"= 1.00 \\lambda\", t2c={R\"\\lambda\": TEAL})\n",
        "            new_rhs.set_height(0.8 * lambda_label.get_height())\n",
        "            factor = new_rhs.make_number_changeable(\"1.00\")\n",
        "            factor_tracker = ValueTracker(1.0)\n",
        "            new_rhs.f_always.set_value(factor_tracker.get_value)\n",
        "            new_rhs.always.move_to(lambda_label, RIGHT)\n",
        "\n",
        "            self.play(\n",
        "                d_sine_theta.animate.next_to(new_rhs, LEFT, buff=0.05).shift(0.02 * DOWN),\n",
        "                lambda_label.animate.set_opacity(0),\n",
        "                FadeIn(new_rhs)\n",
        "            )\n",
        "            self.play(\n",
        "                Rotate(point_tracker, -d_angle2, about_point=ORIGIN),\n",
        "                Rotate(sine, -d_angle2, about_point=sine.get_start()),\n",
        "                factor_tracker.animate.set_value(2.0),\n",
        "                MaintainPositionRelativeTo(d_sine_theta, lambda_label),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                Rotate(point_tracker, -d_angle2, about_point=ORIGIN),\n",
        "                Rotate(sine, -d_angle2, about_point=sine.get_start()),\n",
        "                factor_tracker.animate.set_value(3.0),\n",
        "                MaintainPositionRelativeTo(d_sine_theta, lambda_label),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show the angle match\n",
        "        self.revert_to_checkpoint(\"d*sin(theta)\")\n",
        "\n",
        "        p4 = p2 + 2 * (p2 - p1)\n",
        "        h_line = Line(p2, p1).scale(3, about_edge=RIGHT)\n",
        "        h_line.set_stroke(WHITE, 0)\n",
        "        angle_group = VGroup(triangle, arc, small_theta_sym, h_line).copy()\n",
        "        angle_group[0].set_opacity(0)\n",
        "        angle_group.target = angle_group.generate_target()\n",
        "        angle_group.target.rotate(-PI / 2)\n",
        "        angle_group.target.move_to(p4, DL)\n",
        "        angle_group.target[2].rotate(PI / 2).shift(0.01 * UR)\n",
        "        angle_group.target[3].set_stroke(WHITE, 3)\n",
        "        angle_group.target.scale(2, about_edge=DL)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(angle_group),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write conclusion\n",
        "        conclusion = VGroup(\n",
        "            Text(\"Difference in distance:\", font_size=36),\n",
        "            Tex(R\"d \\cdot \\sin(\\theta)\")\n",
        "        )\n",
        "        conclusion.arrange(DOWN)\n",
        "        conclusion_box = SurroundingRectangle(conclusion, buff=MED_SMALL_BUFF)\n",
        "        conclusion_box.set_stroke(WHITE, 1)\n",
        "        conclusion_box.set_fill(BLACK, 1)\n",
        "        conclusion_group = VGroup(conclusion_box, conclusion)\n",
        "        conclusion_group.to_corner(UL, buff=SMALL_BUFF)\n",
        "        conclusion_group.fix_in_frame()\n",
        "        conclusion_group.set_fill(border_width=0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(conclusion_box),\n",
        "            FadeIn(conclusion[0]),\n",
        "            TransformFromCopy(d_sine_theta, conclusion[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(conclusion_group))\n",
        "\n",
        "        # Zoom out\n",
        "        out_wave.set_sources(sources.copy().set_points(sources.get_points()[10:-10]))\n",
        "        out_wave.set_sources(sources)\n",
        "        out_wave.set_width(800).move_to(ORIGIN, DOWN)\n",
        "        out_wave.set_opacity(0)\n",
        "        lines.resume_updating()\n",
        "\n",
        "        self.add(out_wave)\n",
        "        self.play(\n",
        "            FadeOut(diff_label_group, lag_ratio=0.1, time_span=(0, 1.5)),\n",
        "            FadeOut(VGroup(d_sine_theta, matched_segment, line1, line2, angle_group), lag_ratio=0.1, time_span=(0, 1.5)),\n",
        "            out_wave.animate.set_opacity(0.85).set_anim_args(suspend_mobject_updating=False, time_span=(0, 2)),\n",
        "            frame.animate.reorient(0, 0, 0, (0, 200, 0.0), 400),\n",
        "            sources.animate.set_radius(0.75),\n",
        "            lines.animate.set_stroke(width=20).set_anim_args(suspend_mobject_updating=False),\n",
        "            point_tracker.animate.scale(2.0, about_point=ORIGIN).set_anim_args(time_span=(0, 8)),\n",
        "            run_time=20,\n",
        "            rate_func=lambda t: t**6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add back arc label\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            PI / 2, angle_of_vector(point_tracker.get_center()) - PI / 2,\n",
        "            radius=50,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=100\n",
        "        ))\n",
        "        theta_sym.set_height(16)\n",
        "        theta_sym.add_updater(lambda m, arc=arc: m.next_to(arc.pfp(0.7), UP, buff=6))\n",
        "        theta_sym.suspend_updating()\n",
        "        VGroup(v_line, d_line).set_stroke(WHITE, 150)\n",
        "        d_line.add_updater(lambda m, pt=point_tracker: m.put_start_and_end_on(ORIGIN, 5 * pt.get_center()))\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            ShowCreation(d_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_sym, stroke_width=20),\n",
        "            run_time=1\n",
        "        )\n",
        "        theta_sym.resume_updating()\n",
        "        self.wait(4)\n",
        "\n",
        "        # Change the slit distance zoomed out\n",
        "        for scale_factor in scale_factors:\n",
        "            self.play(\n",
        "                UpdateFromFunc(point_tracker, lambda m: m.move_to(get_dist_point(1.0 / wave_number))),\n",
        "                sources.animate.scale(scale_factor, about_point=wall_center),\n",
        "                wall.animate.scale(scale_factor, about_point=wall_center),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Double and triple the angle\n",
        "        for n in [1, 2]:\n",
        "            d_angle = angle_of_vector(get_dist_point(n / wave_number)) - angle_of_vector(get_dist_point((n + 1) / wave_number))\n",
        "            self.play(\n",
        "                Rotate(point_tracker, -d_angle, about_point=ORIGIN),\n",
        "                frame.animate.set_height(450),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def get_diff_label_group(self, p1, p2, theta):\n",
        "        # Altitude\n",
        "        to_point = rotate_vector(UP, -theta)\n",
        "        dist = get_norm(p2 - p1)\n",
        "        foot = p1 + dist * math.sin(theta) * to_point\n",
        "\n",
        "        altitude = DashedLine(p2, foot, dash_length=get_norm(foot - p2) / 39.5)\n",
        "        elbow = Elbow(width=0.1 * dist, angle=-theta - PI / 2).shift(foot)\n",
        "\n",
        "        altitude.set_stroke(WHITE, 2)\n",
        "        elbow.set_stroke(WHITE, 2)\n",
        "\n",
        "        # Triangle\n",
        "        triangle = Polygon(p1, foot, p2)\n",
        "        triangle.set_stroke(width=0)\n",
        "        triangle.set_fill(YELLOW, 0.5)\n",
        "        d_label = Tex(R\"d\", font_size=24)\n",
        "        d_label.next_to(triangle, DOWN, SMALL_BUFF)\n",
        "\n",
        "        # Leg\n",
        "        diff_segment = Line(p1, foot)\n",
        "        diff_segment.set_stroke(RED, 2)\n",
        "        brace = VMobject().set_points_as_corners([LEFT, UL, UR, RIGHT])\n",
        "        brace.set_shape(diff_segment.get_length(), 0.1)\n",
        "        brace.set_stroke(WHITE, 1)\n",
        "        # brace = Brace(Line(ORIGIN, 0.75 * RIGHT), UP)\n",
        "        # brace.set_shape(diff_segment.get_length(), 0.15)\n",
        "        brace.rotate(PI / 2 - theta)\n",
        "        brace.move_to(diff_segment).shift(0.1 * rotate_vector(to_point, PI / 2))\n",
        "\n",
        "        # Angle label\n",
        "        arc_rad = min(0.35 * dist, 0.35 * get_norm(foot - p2))\n",
        "        arc = Arc(PI, -theta, radius=arc_rad).shift(p2)\n",
        "        arc.set_stroke(WHITE, 2)\n",
        "        small_theta_sym = Tex(R\"\\theta\")\n",
        "        small_theta_sym.set_height(0.8 * arc.get_height())\n",
        "        small_theta_sym.next_to(arc.pfp(0.5), LEFT, buff=0.05)\n",
        "\n",
        "        return VGroup(triangle, elbow, altitude, arc, small_theta_sym, diff_segment, brace, d_label)\n",
        "\n",
        "    def old(self):\n",
        "        # Old\n",
        "        dist_label = DecimalNumber(num_decimal_places=1)\n",
        "        dist_label.set_height(4)\n",
        "        dist_label.add_updater(lambda m: m.next_to(L_line.get_center(), RIGHT, buff=2))\n",
        "        dist_label.add_updater(lambda m: m.set_value(L_line.get_length()))\n",
        "\n",
        "\n",
        "class PlaneWaveThroughZonePlate(DiffractionGratingScene):\n",
        "    def construct(self):\n",
        "        # Set up the zone plate and object\n",
        "        frame = self.frame\n",
        "        wave_number = 4\n",
        "        frequency = 2.0\n",
        "\n",
        "        obj_dot = Group(GlowDot(), TrueDot())\n",
        "        obj_dot.move_to(4 * RIGHT)\n",
        "        obj_dot.set_color(WHITE)\n",
        "\n",
        "        zone_sources = DotCloud([obj_dot.get_center(), 1002 * RIGHT])\n",
        "        plate = LightIntensity(zone_sources)\n",
        "        plate.set_shape(9, 16)\n",
        "        plate.rotate(PI / 2, UP)\n",
        "        plate.set_height(8)\n",
        "        plate.set_color(WHITE, 0.7)\n",
        "        plate.set_wave_number(24)\n",
        "        plate.set_decay_factor(0)\n",
        "        plate_top = plate.copy()\n",
        "        plate_top.rotate(PI / 2, DOWN)\n",
        "        plate_top.set_width(0.075, stretch=True)\n",
        "        plate_top.move_to(plate)\n",
        "\n",
        "        ref_wave = self.get_plane_wave(LEFT)\n",
        "        ref_wave.set_shape(10, plate.get_height())\n",
        "        ref_wave.set_frequency(frequency)\n",
        "        ref_wave.set_color(BLUE_C, 0.5)\n",
        "        ref_wave.set_wave_number(wave_number)\n",
        "        ref_wave.move_to(plate, LEFT)\n",
        "\n",
        "        frame.reorient(19, 77, 0, ORIGIN, 8.00)\n",
        "        self.add(plate)\n",
        "        self.add(obj_dot)\n",
        "\n",
        "        # Add Number plane\n",
        "        plane = NumberPlane(x_range=(-10, 10, 1), y_range=(-8, 8, 1.0))\n",
        "        plane.become(NumberPlane(x_range=(-10, 10, 1), y_range=(-8, 8, 1.0)))\n",
        "        plane.fade(0.5)\n",
        "        plane.apply_depth_test()\n",
        "        self.add(plate, plane)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(58, 73, 0, ORIGIN, 8.00),\n",
        "            Write(plane, stroke_width=3, lag_ratio=0.01, time_span=(2, 6)),\n",
        "            run_time=6\n",
        "        )\n",
        "\n",
        "        # Draw a line\n",
        "        film_point = 2 * UP\n",
        "        line = Line(film_point, obj_dot.get_center())\n",
        "        line.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            frame.animate.reorient(0, 0, 0),\n",
        "            FadeIn(plate_top),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Where the object had been\n",
        "        dash_circle = DashedVMobject(Arc(angle=(23 / 24) * TAU), num_dashes=12)\n",
        "        dash_circle.set_stroke(YELLOW, 3)\n",
        "        dash_circle.replace(obj_dot).set_width(0.2)\n",
        "        for part in dash_circle:\n",
        "            dash_circle.set_joint_type(\"no_joint\")\n",
        "        had_been_words = Text(\"Where the object\\nhad been\", font_size=36)\n",
        "        had_been_words.next_to(dash_circle, UP, buff=0, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(obj_dot),\n",
        "            Write(dash_circle, stroke_width=3, run_time=1),\n",
        "            Write(had_been_words, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(had_been_words))\n",
        "\n",
        "        # Show angle\n",
        "        theta = -line.get_angle()\n",
        "        arc = Arc(PI - theta, theta, radius=1)\n",
        "        arc.shift(obj_dot.get_center())\n",
        "        h_line = Line(ORIGIN, obj_dot.get_center())\n",
        "        h_line.set_stroke(WHITE, 2)\n",
        "        theta_prime_sym = Tex(R\"\\theta'\")\n",
        "        theta_prime_sym.set_max_height(0.8 * arc.get_height())\n",
        "        theta_prime_sym.next_to(arc.pfp(0.4), LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(line, h_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_prime_sym),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Set up terms for the calculations for the spacing\n",
        "        # TODO, consider adding many little lines for all the fringes\n",
        "        self.remove(plate)\n",
        "        v_line = Line(ORIGIN, film_point)\n",
        "\n",
        "        d_lines = Line(LEFT, RIGHT).replicate(2).set_width(0.3)\n",
        "        d_lines.set_stroke(WHITE, 2)\n",
        "        d_lines.arrange(DOWN, buff=0.1)\n",
        "        d_lines.move_to(film_point, DOWN)\n",
        "        lil_brace = Brace(Line(ORIGIN, 0.25 * UP), LEFT)\n",
        "        lil_brace.match_height(d_lines)\n",
        "        lil_brace.next_to(d_lines, LEFT, buff=0.05)\n",
        "        big_brace = Brace(Group(d_lines[1], Point(ORIGIN)), LEFT, buff=0)\n",
        "        big_brace.match_width(lil_brace, about_edge=RIGHT, stretch=True)\n",
        "\n",
        "        kw = dict(font_size=42)\n",
        "        L_label = Tex(\"L\", **kw).next_to(h_line, DOWN, 2 * SMALL_BUFF)\n",
        "        x_label = Tex(\"x\", **kw).next_to(big_brace, LEFT, SMALL_BUFF)\n",
        "        d_label = Tex(\"d\", **kw).next_to(lil_brace, LEFT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "        L_label.set_color(BLUE)\n",
        "        x_label.set_color(RED)\n",
        "        VGroup(L_label, x_label, d_label).set_backstroke(BLACK, 5)\n",
        "\n",
        "        terms = VGroup(\n",
        "            d_lines, lil_brace, big_brace,\n",
        "            L_label, x_label, d_label\n",
        "        )\n",
        "\n",
        "        # Limit to reference beam at just one point\n",
        "        equations_tex = [\n",
        "            R\"\\lambda = \\sqrt{L^2 + (x + d)^2} - \\sqrt{L^2 + x^2}\",\n",
        "            R\"= \\sqrt{L^2 + x^2 + 2xd + d^2} - \\sqrt{L^2 + x^2}\",\n",
        "            R\"\\approx \\sqrt{L^2 + x^2 + 2xd} - \\sqrt{L^2 + x^2}\",\n",
        "            R\"\\approx \\frac{1}{2\\sqrt{L^2 + x^2}} 2xd\",\n",
        "            R\"= d \\cdot \\frac{x}{\\sqrt{L^2 + x^2}}\",\n",
        "            R\"= d \\cdot \\sin(\\theta')\",\n",
        "        ]\n",
        "        equations = VGroup(\n",
        "            Tex(eq, t2c={R\"\\lambda\": YELLOW, \"L\": BLUE, \"x\": RED}, font_size=36)\n",
        "            for eq in equations_tex\n",
        "        )\n",
        "        equations.arrange(DOWN, buff=0.65, aligned_edge=LEFT)\n",
        "        equations.move_to(9.5 * LEFT + 5.65 * UP, UL)\n",
        "        equations.set_backstroke(BLACK, 10)\n",
        "\n",
        "        annotations = VGroup(\n",
        "            Text(\"The distances between adjacent fringes and\\nthe object should differ by one wavelength\"),\n",
        "            TexText(R\"$d^2$ is small compared to $xd$\"),\n",
        "            TexText(R\"Linear approximation:\\\\ \\quad \\\\$\\sqrt{X + \\epsilon} \\approx \\sqrt{X} + \\frac{1}{2\\sqrt{X}} \\epsilon$\"),\n",
        "        )\n",
        "        annotations.scale(0.75)\n",
        "        for annotation, i in zip(annotations, [0, 1, 3]):\n",
        "            eq = equations[i]\n",
        "            annotation.next_to(eq, RIGHT, buff=1.5)\n",
        "            if i == 2:\n",
        "                annotation.next_to(eq, DR)\n",
        "            arrow = Arrow(annotation.get_left(), eq.get_right())\n",
        "            annotation.add(arrow)\n",
        "            annotation.set_color(GREY_A)\n",
        "        annotations[2][:-1].align_to(annotations[2][-1], UP)\n",
        "\n",
        "        braces = VGroup(\n",
        "            Brace(equations[0][R\"\\sqrt{L^2 + (x + d)^2}\"], UP, SMALL_BUFF),\n",
        "            Brace(equations[0][R\"\\sqrt{L^2 + x^2}\"], UP, SMALL_BUFF),\n",
        "        )\n",
        "        brace_texts = VGroup(\n",
        "            TexText(R\"Dist. to fringe\\\\at height $(x + d)$\", font_size=24).next_to(braces[0], UP, SMALL_BUFF),\n",
        "            TexText(R\"Dist. to fringe\\\\at height $x$\", font_size=24).next_to(braces[1], UP, SMALL_BUFF),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(terms, lag_ratio=0.1, time_span=(0, 2)),\n",
        "            Write(equations, time_span=(2, 5)),\n",
        "            frame.animate.reorient(0, 0, 0, (-2, 2.5, 0.0), 9).set_anim_args(run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(annotations[0]),\n",
        "            FadeIn(braces),\n",
        "            FadeIn(brace_texts),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(annotations[1]))\n",
        "        self.play(FadeIn(annotations[2]))\n",
        "        self.wait()\n",
        "\n",
        "        # Reduce down to the key conclusion\n",
        "        key_equation = Tex(R\"d \\cdot \\sin(\\theta') = \\lambda\", **kw)\n",
        "        key_equation.next_to(line, UP, MED_LARGE_BUFF)\n",
        "        key_equation.scale(1.25)\n",
        "        key_equation.shift(RIGHT + 0.5 * UP)\n",
        "\n",
        "        box = SurroundingRectangle(key_equation, buff=MED_SMALL_BUFF)\n",
        "        box.set_fill(BLACK, 1)\n",
        "        box.set_stroke(YELLOW, 1)\n",
        "\n",
        "        terms.remove(d_label, lil_brace, d_lines)\n",
        "\n",
        "        self.add(d_label, lil_brace, d_lines)\n",
        "        self.play(\n",
        "            ReplacementTransform(equations[-1][0], key_equation[9], time_span=(0, 2)),\n",
        "            ReplacementTransform(equations[-1][1:], key_equation[:9], time_span=(0, 2)),\n",
        "            ReplacementTransform(equations[0][0], key_equation[10], time_span=(0, 2)),\n",
        "            FadeOut(equations[0][1:], time_span=(1.0, 1.5)),\n",
        "            FadeOut(equations[1:-1], lag_ratio=0.01, time_span=(1.0, 2.5)),\n",
        "            FadeOut(annotations, lag_ratio=0.01),\n",
        "            FadeOut(terms, lag_ratio=0.1, time_span=(1.0, 3.0)),\n",
        "            FadeOut(h_line),\n",
        "            FadeOut(braces),\n",
        "            FadeOut(brace_texts),\n",
        "            frame.animate.reorient(0, 0, 0, (0, 1, 0), 6).set_anim_args(time_span=(1, 3.5)),\n",
        "        )\n",
        "        self.add(box, key_equation)\n",
        "        self.play(\n",
        "            Write(box),\n",
        "            FlashAround(key_equation, buff=MED_SMALL_BUFF, time_width=1.5, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Smaller slit width\n",
        "        lil_brace.generate_target()\n",
        "        lil_brace.target.flip().next_to(d_lines, RIGHT, buff=0.025)\n",
        "\n",
        "        arrow = Vector(0.3 * DL, thickness=2)\n",
        "        arrow.next_to(lil_brace.target, UR, buff=0)\n",
        "\n",
        "        new_plate_top = plate_top.copy()\n",
        "        new_plate_top.set_wave_number(50)\n",
        "        new_plate_top.save_state()\n",
        "        new_plate_top.stretch(0, 0)\n",
        "\n",
        "        self.play(\n",
        "            d_label.animate.next_to(arrow.get_start(), UR, 0.5 * SMALL_BUFF),\n",
        "            GrowArrow(arrow),\n",
        "            MoveToTarget(lil_brace)\n",
        "        )\n",
        "        self.play(\n",
        "            d_lines.animate.stretch(0.25, 1, about_edge=DOWN),\n",
        "            lil_brace.animate.scale(0.25, about_edge=DL).set_stroke(WHITE, 1),\n",
        "            arrow.animate.put_start_and_end_on(arrow.get_start(), arrow.get_end() + 0.05 * LEFT + 0.05 * DOWN),\n",
        "            plate_top.animate.stretch(0, 0),\n",
        "            Restore(new_plate_top),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(new_plate_top)\n",
        "        plate_top.become(new_plate_top)\n",
        "\n",
        "        # Shine reference beam in\n",
        "        ref_wave = self.get_beam()\n",
        "        ref_wave.move_to(film_point, LEFT)\n",
        "\n",
        "        out_beams = self.get_triple_beam(film_point, obj_dot.get_center())\n",
        "\n",
        "        self.play(GrowFromPoint(ref_wave, film_point + 8 * RIGHT, run_time=2, rate_func=linear))\n",
        "        self.play(*(\n",
        "            GrowFromPoint(beam[1], film_point, run_time=2, rate_func=linear)\n",
        "            for beam in out_beams\n",
        "        ))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Note the matching angle\n",
        "        upper_arc = arc.copy()\n",
        "        upper_arc.shift(film_point - obj_dot.get_center())\n",
        "        theta_sym = Tex(R\"\\theta\", font_size=42)\n",
        "        theta_sym.next_to(upper_arc.pfp(0.4), LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(upper_arc),\n",
        "            Write(theta_sym),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Write the diffraction equation\n",
        "        key_equation.set_backstroke(BLACK, 8)\n",
        "        key_equation.generate_target()\n",
        "        box.generate_target()\n",
        "        diff_eq = Tex(R\"d \\cdot \\sin(\\theta) = \\lambda\")\n",
        "        key_equation.target.match_height(diff_eq)\n",
        "        key_equation.target.next_to([6.5, 5.5, 0], DL, SMALL_BUFF)\n",
        "        diff_eq.next_to(key_equation.target, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        box.target.surround(VGroup(key_equation.target, diff_eq))\n",
        "        box.target.set_opacity(0)\n",
        "\n",
        "        diff_eq_label = VGroup(\n",
        "            Text(\"Diffraction\\nequation\", font_size=36),\n",
        "            Vector(RIGHT),\n",
        "        )\n",
        "        diff_eq_label.arrange(RIGHT)\n",
        "        diff_eq_label.next_to(diff_eq, LEFT)\n",
        "\n",
        "        VGroup(diff_eq, diff_eq_label).set_backstroke(BLACK, 8)\n",
        "\n",
        "        theta_sym_copy = theta_sym.copy()\n",
        "        theta_sym_copy.set_backstroke()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0.0, 2, 0.0), 8.00),\n",
        "            MoveToTarget(box),\n",
        "            MoveToTarget(key_equation),\n",
        "            Transform(theta_sym_copy, diff_eq[R\"\\theta\"][0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Write(diff_eq),\n",
        "            FadeIn(diff_eq_label[0], lag_ratio=0.1),\n",
        "            GrowArrow(diff_eq_label[1]),\n",
        "        )\n",
        "        self.remove(theta_sym_copy)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Write implication\n",
        "        implication = VGroup(Tex(R\"\\Downarrow\"), Tex(R\"\\theta = \\theta'\"))\n",
        "        implication.arrange(DOWN)\n",
        "        implication.next_to(diff_eq, DOWN)\n",
        "        implication.set_backstroke(width=5)\n",
        "\n",
        "        self.play(Write(implication))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(theta_sym.copy(), theta_prime_sym, remover=True),\n",
        "            Transform(upper_arc.copy(), arc, remover=True),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Move film point around\n",
        "        film_dot = Point(film_point)\n",
        "\n",
        "        line.f_always.put_start_and_end_on(film_dot.get_center, obj_dot.get_center)\n",
        "\n",
        "        ref_wave.always.match_y(film_dot)\n",
        "\n",
        "        def update_out_beams(beams):\n",
        "            beams.become(self.get_triple_beam(\n",
        "                film_dot.get_center(),\n",
        "                obj_dot.get_center(),\n",
        "            ))\n",
        "            for beam in beams:\n",
        "                beam[1].set_uniform(time=self.time)\n",
        "\n",
        "        out_beams.clear_updaters()\n",
        "        out_beams.add_updater(update_out_beams)\n",
        "\n",
        "        self.add(out_beams)\n",
        "        self.play(film_dot.animate.move_to(film_point))\n",
        "\n",
        "        arc.add_updater(lambda m: m.become(\n",
        "            Arc(PI, line.get_angle()).shift(obj_dot.get_center())\n",
        "        ))\n",
        "        upper_arc.add_updater(lambda m: m.match_points(arc).shift(\n",
        "            film_dot.get_center() - obj_dot.get_center()\n",
        "        ))\n",
        "        theta_prime_sym.add_updater(\n",
        "            lambda m: m.set_height(min(0.8 * arc.get_height(), 0.35)).next_to(arc.pfp(0.6), LEFT, SMALL_BUFF)\n",
        "        )\n",
        "        theta_sym.add_updater(lambda m: m.replace(theta_prime_sym[0]).shift(\n",
        "            film_dot.get_center() - obj_dot.get_center()\n",
        "        ))\n",
        "\n",
        "        d_group = VGroup(d_label, arrow, d_lines, lil_brace)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(d_group, time_span=(0, 1)),\n",
        "            film_dot.animate.set_y(1),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(film_dot.animate.set_y(3.5), run_time=5)\n",
        "        self.play(film_dot.animate.set_y(0.5), run_time=6)\n",
        "        self.play(film_dot.animate.set_y(3.5), run_time=6)\n",
        "\n",
        "        # Show zone plate and observer\n",
        "        equaiton_group = VGroup(box, key_equation, diff_eq, diff_eq_label, implication)\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.move_to(4 * LEFT, DOWN)\n",
        "\n",
        "        plate.set_opacity(0.5)\n",
        "        plate.set_wave_number(plate_top.uniforms[\"wave_number\"])\n",
        "\n",
        "        self.add(plate, plane)\n",
        "        self.play(\n",
        "            FadeOut(equaiton_group, lag_ratio=0.1, time_span=(0, 2)),\n",
        "            film_dot.animate.set_y(1.0),\n",
        "            FadeOut(plate_top, time_span=(0, 1)),\n",
        "            FadeIn(randy, time_span=(1, 3)),\n",
        "            frame.animate.reorient(-33, 43, 0, (-2.43, 0.5, -0.12), 9.60),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(randy.change(\"pondering\", obj_dot))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show full reference wave\n",
        "        big_ref_wave = self.get_3d_ref_wave(plate)\n",
        "\n",
        "        self.add(big_ref_wave, plate)\n",
        "        self.play(\n",
        "            FadeIn(big_ref_wave),\n",
        "            FadeOut(ref_wave),\n",
        "            frame.animate.reorient(-40, 67, 0, (-2.43, 0.5, -0.12), 9.60).set_anim_args(run_time=3)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show many beams off the plate\n",
        "        mid_line_points = DotCloud().to_grid(25, 1)\n",
        "        mid_line_points.replace(plate, dim_to_match=1)\n",
        "        mid_line_points.rotate(PI)\n",
        "        plate_points = DotCloud().to_grid(15, 11)\n",
        "        dense_plate_points = DotCloud().to_grid(60, 40)\n",
        "        for dot_cloud in [plate_points, dense_plate_points]:\n",
        "            dot_cloud.rotate(PI / 2, UP)\n",
        "            dot_cloud.replace(plate, stretch=True)\n",
        "\n",
        "        mid_lines_out = self.get_radiating_lines(mid_line_points, obj_dot)\n",
        "        lines_out = self.get_radiating_lines(plate_points, obj_dot)\n",
        "        dense_lines_out = self.get_radiating_lines(dense_plate_points, obj_dot)\n",
        "        ghost_lines = self.get_ghost_lines(mid_line_points, obj_dot)\n",
        "        dense_ghost_lines = self.get_ghost_lines(dense_plate_points, obj_dot)\n",
        "\n",
        "        out_beams.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(out_beams),\n",
        "            FadeOut(VGroup(theta_sym, theta_prime_sym, upper_arc, arc, line)),\n",
        "            ShowCreation(lines_out, lag_ratio=0.01, run_time=4),\n",
        "            frame.animate.reorient(-93, 62, 0, (-2.43, 0.5, -0.12), 9.60).set_anim_args(run_time=5)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines_out, time_span=(1, 2)),\n",
        "            FadeOut(big_ref_wave),\n",
        "            FadeIn(mid_lines_out, time_span=(1, 2)),\n",
        "            frame.animate.to_default_state(),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, ghost_lines, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Move character around\n",
        "        def get_view_point():\n",
        "            eye_point = randy.eyes[1].get_center()\n",
        "            obj_point = obj_dot.get_center()\n",
        "            vect = obj_point - eye_point\n",
        "            alpha = 1.0 - (obj_point[0] / vect[0])\n",
        "            return eye_point + alpha * vect\n",
        "\n",
        "        def update_lines(lines):\n",
        "            view_point = get_view_point()\n",
        "            min_dist = 2.5 * get_norm(lines[0].get_start() - lines[1].get_start())\n",
        "            for line in lines:\n",
        "                dist = get_norm(line.get_start() - view_point)\n",
        "                alpha = clip(inverse_interpolate(min_dist, 0, dist), 0, 1)\n",
        "                line.set_stroke(opacity=interpolate(0, 1, alpha))\n",
        "\n",
        "        screen_dot = GlowDot(radius=0.5)\n",
        "        screen_dot.f_always.move_to(get_view_point)\n",
        "\n",
        "        mid_lines_out.add_updater(update_lines)\n",
        "        ghost_lines.add_updater(update_lines)\n",
        "\n",
        "        randy.always.look_at(obj_dot)\n",
        "\n",
        "        self.play(FadeIn(screen_dot))\n",
        "        self.add(mid_lines_out, ghost_lines)\n",
        "        for y in [-2.8, 2.2]:\n",
        "            self.play(randy.animate.set_y(y), run_time=4)\n",
        "\n",
        "        # Movement in 3d\n",
        "        dense_lines_out.clear_updaters()\n",
        "        dense_ghost_lines.clear_updaters()\n",
        "        dense_lines_out.add_updater(update_lines)\n",
        "        dense_ghost_lines.add_updater(update_lines)\n",
        "\n",
        "        glass = Rectangle()\n",
        "        glass.rotate(PI / 2, UP)\n",
        "        glass.replace(plate, stretch=True)\n",
        "        glass.set_stroke(WHITE, 1)\n",
        "        glass.set_fill(BLACK, 0.25)\n",
        "\n",
        "        self.remove(plate)\n",
        "        self.add(glass, randy)\n",
        "        self.play(\n",
        "            FadeIn(glass, time_span=(0, 1)),\n",
        "            FadeOut(mid_lines_out, time_span=(1, 2)),\n",
        "            FadeOut(ghost_lines, time_span=(1, 2)),\n",
        "            FadeIn(dense_lines_out, time_span=(1, 2)),\n",
        "            FadeIn(dense_ghost_lines, time_span=(1, 2)),\n",
        "            randy.animate.rotate(PI / 2, RIGHT).shift(0.2 * (IN + DOWN)),\n",
        "            frame.animate.reorient(-48, 71, 0, (0.53, -0.56, 0.06), 10.86),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        frame.add_ambient_rotation(1 * DEGREES)\n",
        "        for (y, z) in [(-3, 2), (-2, -1.5), (-1, 1), (2, 2), (1.1, 1.1)]:\n",
        "            self.play(randy.animate.set_y(y).set_z(z), run_time=3)\n",
        "\n",
        "        # Reintroduce the beams\n",
        "        frame.clear_updaters()\n",
        "        dense_lines_out.clear_updaters()\n",
        "        dense_ghost_lines.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(dense_lines_out, time_span=(0, 1)),\n",
        "            FadeOut(dense_ghost_lines, time_span=(0, 1)),\n",
        "            FadeOut(screen_dot, time_span=(0, 1)),\n",
        "            FadeOut(glass, time_span=(2, 3)),\n",
        "            FadeIn(plate_top, time_span=(2.0, 3)),\n",
        "            randy.animate.rotate(PI / 2, LEFT).move_to(4 * LEFT, DOWN),\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, FRAME_HEIGHT),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(GrowFromPoint(ref_wave, ref_wave.get_right(), rate_func=linear))\n",
        "        out_beams.clear_updaters()\n",
        "        self.play(GrowFromPoint(out_beams, film_dot.get_center(), rate_func=linear))\n",
        "        out_beams.add_updater(update_out_beams)\n",
        "        self.wait(3)\n",
        "\n",
        "        # Move film point\n",
        "        self.play(\n",
        "            film_dot.animate.match_y(randy.eyes),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            randy.animate.move_to(2.4 * LEFT),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Highlight other first order beam\n",
        "        self.remove(out_beams)\n",
        "        out_beams = self.get_triple_beam(film_dot.get_center(), obj_dot.get_center())\n",
        "        self.add(out_beams)\n",
        "        self.play(\n",
        "            out_beams[0][1].animate.set_opacity(0.25),\n",
        "            out_beams[1][1].animate.set_opacity(0.25),\n",
        "        )\n",
        "        randy.clear_updaters()\n",
        "        self.play(randy.change(\"confused\", film_point))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(4)\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        # Add all other first order beams\n",
        "        out_beams.add_updater(update_out_beams)\n",
        "        out_beams.add_updater(lambda m: m[0][1].set_opacity(0.25))\n",
        "        out_beams.add_updater(lambda m: m[1][1].set_opacity(0.25))\n",
        "\n",
        "        conj_lines = VGroup(\n",
        "            Line(point, obj_dot.get_center())\n",
        "            for point in mid_line_points.get_points()\n",
        "        )\n",
        "        conj_lines.flip(UP, about_point=ORIGIN)\n",
        "        conj_lines.set_stroke(YELLOW, 1)\n",
        "        conj_lines.sort(lambda p: -p[1])\n",
        "\n",
        "        self.add(out_beams)\n",
        "        self.play(film_dot.animate.set_y(4), run_time=4)\n",
        "        self.play(\n",
        "            film_dot.animate.set_y(-4),\n",
        "            FadeIn(conj_lines, lag_ratio=0.25, run_time=4),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(film_dot.animate.set_y(3.5), run_time=8)\n",
        "        self.play(film_dot.animate.set_y(2), run_time=8)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(conj_lines))\n",
        "\n",
        "        # Show higher order beams\n",
        "        theta = -angle_of_vector(obj_dot.get_center() - film_dot.get_center())\n",
        "        wave_number = 250\n",
        "        wavelength = 1.0 / wave_number\n",
        "        spacing = wavelength / math.sin(theta)\n",
        "        n_sources = 32\n",
        "        sources = DotCloud().to_grid(n_sources, 1)\n",
        "        sources.set_height(spacing * (n_sources - 1))\n",
        "        sources.move_to(film_dot)\n",
        "        out_wave = LightWaveSlice(sources)\n",
        "        out_wave.set_color(BLUE_A)\n",
        "        out_wave.set_shape(20, 20)\n",
        "        out_wave.move_to(ORIGIN, RIGHT)\n",
        "        out_wave.set_wave_number(wave_number)\n",
        "        out_wave.set_frequency(1.0)\n",
        "        out_wave.set_decay_factor(0)\n",
        "        out_wave.set_max_amp(10)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(out_beams),\n",
        "            GrowFromPoint(out_wave, film_dot.get_center()),\n",
        "            frame.animate.reorient(0, 0, 0, (-0.1, 1.85, 0.0), 11.08).set_anim_args(run_time=4),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def get_radiating_lines(self, point_cloud, obj_dot, length=20, stroke_color=YELLOW, stroke_width=1):\n",
        "        lines = VGroup()\n",
        "        for point in point_cloud.get_points():\n",
        "            line = Line(obj_dot.get_center(), point)\n",
        "            line.set_length(length)\n",
        "            line.shift(point - line.get_start())\n",
        "            line.set_stroke(stroke_color, stroke_width)\n",
        "            lines.add(line)\n",
        "        return lines\n",
        "\n",
        "    def get_ghost_lines(self, point_cloud, obj_dot, dash_length=0.15, stroke_color=WHITE, stroke_width=1):\n",
        "        lines = VGroup(\n",
        "            DashedLine(point, obj_dot.get_center(), dash_length=dash_length)\n",
        "            for point in point_cloud.get_points()\n",
        "        )\n",
        "        lines.set_stroke(stroke_color, stroke_width)\n",
        "        return lines\n",
        "\n",
        "    def get_3d_ref_wave(self, plate, n_planes=50, spacing=1.0, speed=1.0, opacity=0.25):\n",
        "        planes = Square3D().replicate(n_planes)\n",
        "        planes.rotate(PI / 2, UP)\n",
        "        planes.replace(plate, stretch=True)\n",
        "        planes.arrange(RIGHT, buff=spacing)\n",
        "        planes.move_to(RIGHT, LEFT)\n",
        "        for n, plane in enumerate(planes):\n",
        "            plane.set_color([BLUE, RED][n % 2])\n",
        "            plane.set_opacity(opacity)\n",
        "\n",
        "        def update_planes(planes, dt):\n",
        "            for plane in planes:\n",
        "                plane.shift(dt * LEFT * speed)\n",
        "                x = plane.get_x()\n",
        "                if x < 1:\n",
        "                    plane.set_opacity(opacity * x)\n",
        "                if x < 0.1:\n",
        "                    plane.next_to(planes, RIGHT, buff=spacing)\n",
        "                    plane.set_opacity(opacity)\n",
        "            planes.sort(lambda p: -p[0])\n",
        "            return planes\n",
        "\n",
        "        planes.add_updater(update_planes)\n",
        "\n",
        "        return planes\n",
        "\n",
        "    def get_triple_beam(self, film_point, obj_point, **kwargs):\n",
        "        theta = PI - angle_of_vector(film_point - obj_point)\n",
        "        beams = Group(\n",
        "            self.get_beam(angle=angle, **kwargs)\n",
        "            for angle in [-theta, 0, theta]\n",
        "        )\n",
        "        beams.shift(film_point)\n",
        "        beams.deactivate_depth_test()\n",
        "        return beams\n",
        "\n",
        "    def get_beam(self, height=0.1, width=15, n_sources=8, source_height=0.15, wave_number=20, frequency=2.3, color=BLUE_A, opacity=0.75, angle=0):\n",
        "        mini_sources = DotCloud().to_grid(n_sources, 1)\n",
        "        mini_sources.set_height(source_height)\n",
        "        mini_sources.set_radius(0).set_opacity(0)\n",
        "        mini_sources.move_to(0.75 * RIGHT)\n",
        "        wave = LightWaveSlice(\n",
        "            mini_sources,\n",
        "            wave_number=wave_number,\n",
        "            frequency=frequency,\n",
        "            color=color,\n",
        "            opacity=opacity,\n",
        "            decay_factor=0.25,\n",
        "            max_amp=0.4 * n_sources,\n",
        "        )\n",
        "        wave.set_shape(width, height)\n",
        "        wave.move_to(ORIGIN, RIGHT)\n",
        "        beam = Group(mini_sources, wave)\n",
        "        beam.rotate(angle, about_point=ORIGIN)\n",
        "        return beam\n",
        "\n",
        "\n",
        "class SuperpositionOfPoints(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up pi creature dot cloud\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        output_dir = Path(self.file_writer.output_directory)\n",
        "        data_file = output_dir.parent.joinpath(\"data\", \"PiCreaturePointCloud.csv\")\n",
        "        all_points = np.loadtxt(data_file, delimiter=',', skiprows=1)\n",
        "        all_points = all_points[:int(0.8 * len(all_points))]  # Limit to first 400k\n",
        "        dot_cloud = DotCloud(all_points)\n",
        "        dot_cloud.set_height(4).center()\n",
        "        dot_cloud.rotate(50 * DEGREES, DOWN)\n",
        "        points = dot_cloud.get_points().copy()\n",
        "        max_z_index = np.argmax(points[:, 2])\n",
        "        min_z_index = np.argmin(points[:, 2])\n",
        "        all_points = np.array([points[max_z_index], points[min_z_index], *points])\n",
        "\n",
        "        dot_cloud.set_points(all_points[:100_000])\n",
        "        dot_cloud.set_radius(0.02)\n",
        "\n",
        "        # Add axes, points and plate\n",
        "        plate_center = 5 * IN\n",
        "        axes = ThreeDAxes(x_range=(-6, 6), y_range=(-4, 4), z_range=(-4, 8))\n",
        "        axes.shift(plate_center - axes.get_origin())\n",
        "\n",
        "        dist_point = 1000 * OUT\n",
        "        dot_cloud.set_points(np.array([2 * LEFT, 2 * LEFT, dist_point]))\n",
        "        dot_cloud.set_color(BLUE_B)\n",
        "        dot_cloud.set_radius(0.5)\n",
        "        dot_cloud.set_glow_factor(2)\n",
        "\n",
        "        plate = LightIntensity(dot_cloud)\n",
        "        plate.set_color(WHITE)\n",
        "        plate.set_shape(16, 9)\n",
        "        plate.set_height(6)\n",
        "        plate.move_to(plate_center)\n",
        "        plate.set_wave_number(16)\n",
        "        plate.set_max_amp(4)\n",
        "        plate.set_decay_factor(0)\n",
        "\n",
        "        frame.reorient(-66, -21, 0, (-0.95, 0.41, -1.11), 11.73)\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(1 * DEGREES)\n",
        "        self.add(axes)\n",
        "        self.add(plate)\n",
        "        self.add(dot_cloud)\n",
        "\n",
        "        # Separate out pair of points\n",
        "        point_sets = [\n",
        "            (2 * LEFT, RIGHT + OUT),\n",
        "            (2 * LEFT + IN, RIGHT + OUT),\n",
        "            (2 * LEFT + IN, 3 * RIGHT + 2 * IN),\n",
        "            (LEFT + 2 * OUT, RIGHT + OUT),\n",
        "        ]\n",
        "\n",
        "        for point_set in point_sets:\n",
        "            self.play(\n",
        "                dot_cloud.animate.set_points([*point_set, dist_point]),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        # Zoom in on the plate\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-18, -11, 0, (-1.52, 1.18, -0.67), 0.92),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dot_cloud.set_points([point_sets[-1][0], dist_point])\n",
        "        plate.set_max_amp(3)\n",
        "        self.wait(2)\n",
        "        dot_cloud.set_points([point_sets[-1][1], dist_point])\n",
        "        self.wait(2)\n",
        "        dot_cloud.set_points([*point_sets[-1], dist_point])\n",
        "        plate.set_max_amp(4)\n",
        "        self.play(\n",
        "            frame.animate.reorient(61, -7, 0, (0.61, -0.11, -2.44), 8.66),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Add on up to 32 points\n",
        "        self.play(\n",
        "            dot_cloud.animate.set_points([*all_points[:2], dist_point]).set_radius(0.2),\n",
        "            run_time=8\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(0.5 * DEGREES)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                dot_cloud,\n",
        "                lambda m, a: m.set_points(\n",
        "                    [*all_points[:int(2 + a * 29)], dist_point]\n",
        "                )\n",
        "            ),\n",
        "            UpdateFromFunc(plate, lambda m: m.set_max_amp(2 * np.sqrt(dot_cloud.get_num_points()))),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Describe as a combination of zone plates\n",
        "        zone_plates = Group()\n",
        "        for point in all_points[:30]:\n",
        "            zone_plate = LightIntensity(DotCloud([point, dist_point]))\n",
        "            zone_plate.set_uniforms(dict(plate.uniforms))\n",
        "            zone_plate.match_points(plate)\n",
        "            zone_plate.set_max_amp(10)\n",
        "            zone_plate.set_opacity(0.25)\n",
        "            zone_plates.add(zone_plate)\n",
        "\n",
        "        zone_plates.deactivate_depth_test()\n",
        "        self.remove(plate)\n",
        "        self.add(zone_plates)\n",
        "\n",
        "        for n, zone_plate, point in zip(it.count(1), zone_plates, all_points[:30]):\n",
        "            zone_plate.shift(1e-2 * IN)\n",
        "            zone_plate.save_state()\n",
        "            zone_plate.scale(0).move_to(point).set_max_amp(2).set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(plate, lambda m, a: m.set_opacity(1 - there_and_back_with_pause(a, 0.6))),\n",
        "            LaggedStartMap(Restore, zone_plates, lag_ratio=0.05),\n",
        "            frame.animate.reorient(66, -18, 0, (1.44, 0.59, -6.18), 16.05),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(FadeOut(zone_plates))\n",
        "\n",
        "        # Move around points\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(-2 * DEGREES)\n",
        "\n",
        "        dot_cloud.save_state()\n",
        "        self.play(dot_cloud.animate.shift(2 * IN), run_time=3)\n",
        "        self.play(Rotate(dot_cloud, PI / 2 , axis=UP, about_point=ORIGIN), run_time=3)\n",
        "        self.play(Restore(dot_cloud), run_time=3)\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show reference wave through it\n",
        "        rect = Rectangle().replace(plate, stretch=True)\n",
        "        rect.insert_n_curves(20)\n",
        "        beam = VGroup(\n",
        "            Line(25 * OUT, rect.pfp(a))\n",
        "            for a in np.linspace(0, 1, 500)\n",
        "        )\n",
        "        beam.set_stroke(GREEN_SCREEN, (1, 0), 0.5)\n",
        "        beam.shuffle()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(beam, lag_ratio=1 / len(beam)),\n",
        "            FadeOut(dot_cloud),\n",
        "            frame.animate.reorient(83, -27, 0, (-0.63, -0.01, -0.79), 14.36),\n",
        "            run_time=2\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        dot_cloud.set_color(GREEN_SCREEN)\n",
        "\n",
        "        # Test\n",
        "        frame.reorient(-26, -9, 0, (0.15, -0.46, -0.42), 15.13)\n",
        "        self.play(frame.animate.reorient(0, 0, 0, (0.53, 0.16, -0.0), 0.22), run_time=8)\n",
        "        self.play(frame.animate.reorient(3, 0, 0, (0.14, -0.02, 0.03), 0.22), run_time=8)\n",
        "\n",
        "        # Build it up again from the other side\n",
        "        self.play(\n",
        "            plate.animate.set_opacity(0.2).set_anim_args(time_span=(1.6, 1.7)),\n",
        "            frame.animate.reorient(162, -3, 0, (-0.89, 0.06, 0.03), 12.77),\n",
        "            run_time=4,\n",
        "        )\n",
        "        dot_cloud.set_points([all_points[0], dist_point])\n",
        "        plate.set_max_amp(2 * np.sqrt(dot_cloud.get_num_points()))\n",
        "        self.add(dot_cloud)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                dot_cloud,\n",
        "                lambda m, a: m.set_points(\n",
        "                    [*all_points[:int(1 + a * 29)], dist_point]\n",
        "                )\n",
        "            ),\n",
        "            UpdateFromFunc(plate, lambda m: m.set_max_amp(2 * np.sqrt(dot_cloud.get_num_points()))),\n",
        "            frame.animate.reorient(207, -8, 0, (-0.89, 0.06, 0.03), 12.77),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Close up on cloud\n",
        "        self.play(\n",
        "            FadeOut(beam),\n",
        "            FadeOut(dot_cloud),\n",
        "            frame.animate.reorient(185, -39, 0, (-0.89, 0.06, 0.03), 12.77).set_anim_args(run_time=3),\n",
        "        )\n",
        "        dot_cloud.set_color(BLUE).set_glow_factor(1).set_radius(0.1)\n",
        "        self.play(\n",
        "            FadeOut(plate),\n",
        "            FadeIn(dot_cloud),\n",
        "            frame.animate.reorient(115, -16, 0, (0.33, 0.28, -0.52), 4.38),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Denser cloud\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                dot_cloud,\n",
        "                lambda m, a: m.set_points(\n",
        "                    [*all_points[:int(interpolate(31, 500, a))], dist_point]\n",
        "                ).set_glow_factor(interpolate(1, 0, a**0.25)).set_radius(interpolate(0.1, 0.02, a**0.25)).set_opacity(interpolate(1, 0.5, a**0.25)),\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                dot_cloud,\n",
        "                lambda m, a: m.set_points(\n",
        "                    [*all_points[:int(interpolate(500, len(all_points), a**3))]]\n",
        "                ).set_radius(interpolate(0.02, 0.01, a)).set_opacity(interpolate(0.5, 0.2, a)),\n",
        "            ),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Add better updating film\n",
        "        sheet_dots = self.create_dot_sheet(plate.get_width(), plate.get_height(), radius=0.025, z=plate.get_z())\n",
        "        self.color_sheet_by_exposure(sheet_dots, dot_cloud.get_points()[:1000], wave_number=32)\n",
        "        self.add(sheet_dots)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-16, -45, 0, (-0.97, 1.52, -1.18), 8.67),\n",
        "            run_time=2,\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(3 * DEGREES)\n",
        "\n",
        "        # Move dot cloud around\n",
        "        self.play(\n",
        "            dot_cloud.animate.shift(2 * IN),\n",
        "            UpdateFromFunc(sheet_dots, lambda m: self.color_sheet_by_exposure(m, dot_cloud.get_points()[:1000], wave_number=32)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Rotate(dot_cloud, 120 * DEGREES, axis=UP),\n",
        "            UpdateFromFunc(sheet_dots, lambda m: self.color_sheet_by_exposure(m, dot_cloud.get_points()[:1000], wave_number=32)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            dot_cloud.animate.shift(3 * OUT),\n",
        "            UpdateFromFunc(sheet_dots, lambda m: self.color_sheet_by_exposure(m, dot_cloud.get_points()[:1000], wave_number=32)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Transform point into film\n",
        "        frame.clear_updaters()\n",
        "        frame.reorient(111, -13, 0, (-0.54, 0.04, -1.71), 5.72)\n",
        "        pre_dots = dot_cloud.copy()\n",
        "        pre_dots.set_points(dot_cloud.get_points()[:len(sheet_dots.get_points())])\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(pre_dots, sheet_dots, time_span=(2, 8)),\n",
        "            frame.animate.reorient(17, -19, 0, (0.82, 0.57, -3.07), 7.99),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.play(\n",
        "            dot_cloud.animate.shift(2 * IN),\n",
        "            UpdateFromFunc(sheet_dots, lambda m: self.color_sheet_by_exposure(m, dot_cloud.get_points()[:1000], wave_number=32)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def color_sheet_by_exposure(self, sheet_dots, point_sources, wave_number=16, opacity=0.5):\n",
        "        centers = sheet_dots.get_points()\n",
        "        diffs = centers[:, np.newaxis, :] - point_sources[np.newaxis, :, :]\n",
        "        distances = np.linalg.norm(diffs, axis=2)\n",
        "        amplitudes = np.exp(distances * TAU * 1j * wave_number).sum(1)\n",
        "        mags = abs(amplitudes)\n",
        "        max_amp = 2 * np.sqrt(len(point_sources))\n",
        "        opacities = opacity * np.clip(mags / max_amp, 0, 1)\n",
        "        sheet_dots.set_opacity(opacities)\n",
        "        return sheet_dots\n",
        "\n",
        "    def create_dot_sheet(self, width=4, height=4, radius=0.05, z=0, make_3d=False):\n",
        "        # Add dots\n",
        "        dots = DotCloud()\n",
        "        dots.set_color(WHITE)\n",
        "        dots.to_grid(int(height / radius), int(width / radius))\n",
        "        dots.set_shape(width, height)\n",
        "        dots.set_radius(radius)\n",
        "        dots.set_z(z)\n",
        "\n",
        "        if make_3d:\n",
        "            dots.make_3d()\n",
        "\n",
        "        return dots\n",
        "\n",
        "\n",
        "class ComplexWavesBase(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Transition from TwoInterferingWaves to just show the object wave\n",
        "        # Maybe it makes more sense to do that from TwoInterferingWaves itself?\n",
        "        pass\n",
        "\n",
        "\n",
        "class ComplexWaves(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add Amplitude(R + O)^2\n",
        "        amp_expr = Tex(R\"\\text{Amplitude}(R + O)^2\", font_size=60)\n",
        "        amp_expr.to_edge(UP)\n",
        "        RO = amp_expr[R\"R + O\"][0]\n",
        "        RO.save_state()\n",
        "        RO.set_x(0)\n",
        "\n",
        "        self.play(FadeIn(RO, UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(amp_expr[R\"\\text{Amplitude}(\"][0]),\n",
        "            Write(amp_expr[R\")\"][0], time_span=(1.5, 2)),\n",
        "            Restore(RO, time_span=(0.5, 1.5)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(amp_expr[R\"^2\"], 0.25 * UP, scale=0.8))\n",
        "        self.wait()\n",
        "\n",
        "        # Expand as functions of (x, y, z, t)\n",
        "        amp_expr.save_state()\n",
        "\n",
        "        O_func = Tex(\"O(x, y, z, t)\", font_size=60)\n",
        "        O_func.move_to(UP + LEFT)\n",
        "\n",
        "        xyz_rect = SurroundingRectangle(O_func[\"x, y, z\"], buff=0.05)\n",
        "        xyz_rect.set_stroke(YELLOW)\n",
        "        xyz_rect.stretch(1.3, 1, about_edge=DOWN)\n",
        "        xyz_rect.round_corners()\n",
        "        xyz_arrow = Vector(2.2 * UP, thickness=5).next_to(xyz_rect, DOWN)\n",
        "        xyz_arrow.set_backstroke(BLACK, 4)\n",
        "        space_words = Text(\"Point\\nin space\", font_size=36)\n",
        "        space_words.next_to(xyz_rect, UP)\n",
        "\n",
        "        time_rect = SurroundingRectangle(O_func[\"t\"], buff=0.05)\n",
        "        time_rect.match_height(xyz_rect, stretch=True, about_edge=DOWN)\n",
        "        time_rect.align_to(xyz_rect, DOWN)\n",
        "        time_rect.round_corners()\n",
        "        time_rect.set_stroke(TEAL)\n",
        "        time_word = Text(\"Time\", font_size=36)  # Make a clock instead?\n",
        "        time_word.next_to(time_rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            amp_expr.animate.scale(0.5).to_corner(UL).set_opacity(0.5),\n",
        "            TransformFromCopy(amp_expr[\"O\"][0], O_func[\"O\"][0]),\n",
        "        )\n",
        "        self.play(Write(O_func[1:], run_time=1, stroke_color=WHITE))\n",
        "        O_func.set_backstroke(BLACK, 5)\n",
        "        self.play(\n",
        "            ShowCreation(xyz_rect),\n",
        "            GrowArrow(xyz_arrow),\n",
        "            FadeIn(space_words, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransformPieces(space_words, time_word),\n",
        "            ShowCreation(time_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show O(x, y, z, t) outputting to a real line\n",
        "        frequency = 0.25\n",
        "        amplitude = 1.5\n",
        "        out_arrow = Vector(RIGHT, thickness=4)\n",
        "        out_arrow.next_to(O_func, RIGHT)\n",
        "\n",
        "        real_line = NumberLine((-2, 2, 0.25), width=4, tick_size=0.025, big_tick_spacing=1.0, longer_tick_multiple=3)\n",
        "        real_line.next_to(out_arrow, RIGHT)\n",
        "        plane = ComplexPlane(\n",
        "            (-2, 2), (-2, 2),\n",
        "            width=4,\n",
        "            background_line_style=dict(\n",
        "                stroke_color=GREY_C,\n",
        "                stroke_width=1,\n",
        "            ),\n",
        "            faded_line_style=dict(\n",
        "                stroke_color=GREY_D,\n",
        "                stroke_width=0.5,\n",
        "                stroke_opacity=1,\n",
        "            )\n",
        "        )\n",
        "        plane.move_to(real_line)\n",
        "\n",
        "        real_line.add_numbers(list(range(-2, 3)), font_size=16)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "        plane.set_stroke(behind=True)\n",
        "\n",
        "        time_tracker = ValueTracker()\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        def get_z():\n",
        "            return amplitude * np.exp(complex(0, TAU * frequency * time_tracker.get_value()))\n",
        "\n",
        "        def get_z_point():\n",
        "            return plane.n2p(get_z())\n",
        "\n",
        "        real_indicator = Group(GlowDot(radius=0.3), TrueDot().make_3d())\n",
        "\n",
        "        def update_real_indicator(indicator):\n",
        "            x = get_z().real\n",
        "            indicator.move_to(plane.n2p(x))\n",
        "            if x > 0:\n",
        "                indicator.set_color(interpolate_color(GREY_D, BLUE, x / amplitude))\n",
        "            else:\n",
        "                indicator.set_color(interpolate_color(GREY_D, RED, -x / amplitude))\n",
        "\n",
        "        real_indicator.add_updater(update_real_indicator)\n",
        "\n",
        "        self.add(time_tracker)\n",
        "        self.play(\n",
        "            GrowArrow(out_arrow),\n",
        "            FadeIn(real_line),\n",
        "            xyz_rect.animate.set_stroke(width=1),\n",
        "            time_rect.animate.set_stroke(width=1),\n",
        "            FadeOut(time_word),\n",
        "            FadeIn(real_indicator)\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "        # Extend to complex plane\n",
        "        complex_label = Text(\"Complex Plane\")\n",
        "        complex_label.next_to(plane, UP)\n",
        "        complex_dot = real_indicator.copy()\n",
        "        complex_dot.clear_updaters()\n",
        "        complex_dot.set_color(YELLOW)\n",
        "        complex_dot.f_always.move_to(get_z_point)\n",
        "\n",
        "        complex_arrow = Vector(RIGHT)\n",
        "        complex_arrow.set_color(YELLOW)\n",
        "        complex_arrow.f_always.put_start_and_end_on(plane.get_origin, get_z_point)\n",
        "\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_stroke(GREY, 1)\n",
        "        v_line.f_always.put_start_and_end_on(get_z_point, real_indicator.get_center)\n",
        "\n",
        "        self.add(plane, real_indicator)\n",
        "        self.play(\n",
        "            FadeIn(plane),\n",
        "            FadeOut(real_line),\n",
        "            FadeIn(complex_arrow),\n",
        "            FadeIn(v_line),\n",
        "        )\n",
        "        self.play(Write(complex_label))\n",
        "        self.wait(12)\n",
        "\n",
        "        # Get into a good position\n",
        "        time_tracker.resume_updating()\n",
        "        self.wait_until(lambda: 0.4 < time_tracker.get_value() % 4 < 0.5)\n",
        "        time_tracker.suspend_updating()\n",
        "\n",
        "        # Mention amplitude and phase\n",
        "        angle = complex_arrow.get_angle()\n",
        "        rot_arrow = complex_arrow.copy()\n",
        "        rot_arrow.clear_updaters()\n",
        "        rot_arrow.rotate(-angle, about_point=rot_arrow.get_start())\n",
        "        rot_arrow.set_opacity(0)\n",
        "        brace = Brace(rot_arrow, UP, buff=0)\n",
        "        amp_label = brace.get_text(\"Amplitude\", font_size=30)\n",
        "        amp_label.set_backstroke(BLACK, 5)\n",
        "        VGroup(brace, amp_label).rotate(angle, about_point=complex_arrow.get_start())\n",
        "\n",
        "        arc = Arc(0, angle, radius=0.5, arc_center=plane.get_origin())\n",
        "        phase_label = Text(\"Phase\", font_size=30)\n",
        "        phase_label.next_to(arc, RIGHT, SMALL_BUFF)\n",
        "        phase_label.shift(SMALL_BUFF * UR)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(amp_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            TransformFromCopy(rot_arrow, complex_arrow, path_arc=angle),\n",
        "            Write(phase_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Re-emphasize the real component\n",
        "        self.play(FadeOut(VGroup(brace, amp_label, arc, phase_label)))\n",
        "        time_tracker.resume_updating()\n",
        "\n",
        "        plane.save_state()\n",
        "        self.play(\n",
        "            plane.animate.fade(0.75),\n",
        "            FadeIn(real_line),\n",
        "            complex_arrow.animate.set_fill(opacity=0.25)\n",
        "        )\n",
        "        self.wait(8)\n",
        "        self.play(\n",
        "            Restore(plane),\n",
        "            FadeOut(real_line),\n",
        "            complex_arrow.animate.set_fill(opacity=1.0)\n",
        "        )\n",
        "        self.wait(8)\n",
        "        self.play(\n",
        "            FadeOut(xyz_rect),\n",
        "            FadeOut(time_rect),\n",
        "            FadeOut(xyz_arrow),\n",
        "            FadeOut(out_arrow),\n",
        "            FadeOut(real_indicator),\n",
        "            FadeOut(v_line),\n",
        "        )\n",
        "\n",
        "        # Package back into R + O expression\n",
        "        time_tracker.suspend_updating()\n",
        "\n",
        "        self.remove(complex_label)\n",
        "        plane.add(complex_label)\n",
        "        self.add(plane, complex_arrow)\n",
        "        self.play(\n",
        "            Transform(O_func, amp_expr.saved_state[-3], remover=True),\n",
        "            Restore(amp_expr),\n",
        "            plane.animate.move_to(DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Add R arrow\n",
        "        O_arrow = complex_arrow\n",
        "        O_arrow.clear_updaters()\n",
        "        R_arrow = Vector().set_color(TEAL)\n",
        "        comb_arrow = Vector().set_color(GREY_B)\n",
        "\n",
        "        R_phase_tracker = ValueTracker(30 * DEGREES)\n",
        "        O_phase_tracker = ValueTracker(complex_arrow.get_angle())\n",
        "        R_amp = math.sqrt(2)\n",
        "        O_amp = 1.5\n",
        "\n",
        "        def get_R():\n",
        "            return R_amp * np.exp(complex(0, R_phase_tracker.get_value()))\n",
        "\n",
        "        def get_O():\n",
        "            return O_amp * np.exp(complex(0, O_phase_tracker.get_value()))\n",
        "\n",
        "        R_arrow.put_start_and_end_on(plane.get_origin(), plane.n2p(get_R()))\n",
        "        comb_arrow.put_start_and_end_on(plane.get_origin(), plane.n2p(get_R() + get_O()))\n",
        "\n",
        "        R_label = self.get_arrow_label(R_arrow, \"R\")\n",
        "        O_label = self.get_arrow_label(O_arrow, \"O\")\n",
        "        comb_label = self.get_arrow_label(comb_arrow, \"R + O\", buff=-0.5)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(R_arrow),\n",
        "            O_arrow.animate.shift(R_arrow.get_vector()),\n",
        "            FadeIn(R_label),\n",
        "            FadeIn(O_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(comb_arrow),\n",
        "            FadeIn(comb_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        R_arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(), plane.n2p(get_R())\n",
        "        ))\n",
        "        O_arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.n2p(get_R()), plane.n2p(get_R() + get_O()),\n",
        "        ))\n",
        "        comb_arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(), plane.n2p(get_R() + get_O()),\n",
        "        ))\n",
        "\n",
        "        # Write |R + O|^2\n",
        "        lhs = Text(\"Film opacity = \")\n",
        "        lhs.move_to(amp_expr, LEFT)\n",
        "        lhs.set_color(GREY_B)\n",
        "        new_amp_expr = Tex(R\"c|R + O|^2\")\n",
        "        new_amp_expr.next_to(lhs, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(amp_expr[\"(R + O)^2\"][0], new_amp_expr),\n",
        "            FadeOut(amp_expr[\"Amplitude\"][0]),\n",
        "        )\n",
        "        self.play(FadeIn(lhs, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Change R and O values\n",
        "        self.play(\n",
        "            R_phase_tracker.animate.set_value(-45 * DEGREES),\n",
        "            O_phase_tracker.animate.set_value(-45 * DEGREES), run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            O_phase_tracker.animate.set_value(-125 * DEGREES),\n",
        "            R_phase_tracker.animate.set_value(45 * DEGREES),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_arrow_label(self, arrow, symbol, font_size=24, buff=0.25):\n",
        "        result = Tex(symbol, font_size=font_size)\n",
        "        result.match_color(arrow)\n",
        "        result.add_updater(lambda m: m.move_to(arrow.get_center() + buff * normalize(rotate_vector(arrow.get_vector(), PI / 2))))\n",
        "        return result\n",
        "\n",
        "\n",
        "class StateOnA2DScreen(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add screen\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        screen = ScreenRectangle()\n",
        "        screen.set_height(6)\n",
        "        screen.set_stroke(WHITE, 1)\n",
        "\n",
        "        source_points = DotCloud(np.random.random((10, 3)))\n",
        "        source_points.set_width(8)\n",
        "        source_points.move_to(screen, OUT)\n",
        "        wave2d = LightWaveSlice(source_points)\n",
        "        wave2d.replace(screen, stretch=True)\n",
        "        wave2d.set_wave_number(4)\n",
        "        wave2d.set_frequency(1)\n",
        "        wave2d.set_max_amp(4)\n",
        "        wave2d.set_decay_factor(0)\n",
        "\n",
        "        axes = ThreeDAxes((-5, 5), (-5, 5), (-5, 5))\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(screen)\n",
        "        self.add(wave2d)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Zoom out to 3d waves\n",
        "        wave3d = Group(\n",
        "            # wave2d.copy().rotate(PI / 2, RIGHT).stretch(10, 2).move_to(ORIGIN, IN)\n",
        "        )\n",
        "        n_slices = 3\n",
        "        for x in np.linspace(-5, 5, n_slices):\n",
        "            wave_slice = wave2d.copy()\n",
        "            wave_slice.scale(20)\n",
        "            wave_slice.rotate(PI / 2, UP)\n",
        "            wave_slice.move_to(ORIGIN, IN)\n",
        "            wave_slice.set_x(x)\n",
        "            wave_slice.set_opacity(1.0 / n_slices)\n",
        "            wave3d.add(wave_slice)\n",
        "\n",
        "        for wave in wave3d:\n",
        "            wave.set_opacity(1)\n",
        "            wave.set_max_amp(10)\n",
        "\n",
        "        # wave3d[n_slices // 2].set_opacity(0.75)\n",
        "        # wave3d.set_opacity(0.1)\n",
        "        # wave3d.save_state()\n",
        "        # wave3d.stretch(0, dim=2, about_point=ORIGIN)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(101, -1, 0, (-0.53, 0.13, 7.82), 13.40),\n",
        "            FadeIn(wave3d, time_span=(3, 8)),\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "        # Linger and collapse\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                wave.animate.match_points(wave2d).set_opacity(1).shift(1e-2 * IN)\n",
        "                for wave in wave3d\n",
        "            ), lag_ratio=0),\n",
        "            frame.animate.reorient(25, -6, 0, (0.18, 0.29, 0.15), 9.15).set_anim_args(time_span=(1, 4)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "## Old ##\n",
        "\n",
        "class PointSourceDiffractionPattern(InteractiveScene):\n",
        "    # default_frame_orientation = (-35, -10)\n",
        "    include_axes = True\n",
        "    axes_config = dict(\n",
        "        x_range=(-6, 6),\n",
        "        y_range=(-6, 6),\n",
        "        z_range=(-6, 6),\n",
        "    )\n",
        "    light_frequency = 2.0\n",
        "    wave_length = 1.0\n",
        "    use_hue = False\n",
        "    max_mag = 3.0\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        self.frame.reorient(-35, -10)\n",
        "\n",
        "        if self.include_axes:\n",
        "            axes = self.axes = ThreeDAxes(**self.axes_config)\n",
        "            axes.set_stroke(opacity=0.5)\n",
        "            self.add(axes)\n",
        "\n",
        "        # Set up light sources\n",
        "        points = self.point_sources = DotCloud(self.get_point_source_locations())\n",
        "        points.set_glow_factor(2)\n",
        "        points.set_radius(0.2)\n",
        "        points.set_color(WHITE)\n",
        "        self.add(points)\n",
        "\n",
        "        # Add frequency trackerg\n",
        "        self.frequency_tracker = ValueTracker(self.light_frequency)\n",
        "        self.wave_length_tracker = ValueTracker(self.wave_length)\n",
        "        self.light_time_tracker = ValueTracker(0)\n",
        "        self.max_mag_tracker = ValueTracker(self.max_mag)\n",
        "\n",
        "    def get_point_source_locations(self):\n",
        "        radius = 2.0\n",
        "        n_sources = 5\n",
        "        ring = Circle(radius=radius)\n",
        "        ring.set_stroke(WHITE, 3)\n",
        "        return np.array([ring.pfp(a) for a in np.arange(0, 1, 1 / n_sources)])\n",
        "\n",
        "    def get_light_time(self):\n",
        "        return self.light_time_tracker.get_value()\n",
        "\n",
        "    def get_frequency(self):\n",
        "        return self.frequency_tracker.get_value()\n",
        "\n",
        "    def color_dot_cloud_by_diffraction(self, dot_cloud):\n",
        "        frequency = self.get_frequency()\n",
        "        point_sources = self.point_sources.get_points()\n",
        "        max_mag = self.max_mag_tracker.get_value()\n",
        "\n",
        "        centers = dot_cloud.get_points()\n",
        "        diffs = centers[:, np.newaxis, :] - point_sources[np.newaxis, :, :]\n",
        "        distances = np.linalg.norm(diffs, axis=2)\n",
        "        amplitudes = np.exp(distances * TAU * 1j * frequency).sum(1)\n",
        "        mags = abs(amplitudes)\n",
        "        opacities = 0.5 * np.clip(mags / max_mag, 0, 1)\n",
        "\n",
        "        n = len(centers)\n",
        "        rgbas = dot_cloud.data[\"rgba\"]\n",
        "        rgbas[:, 3] = opacities\n",
        "\n",
        "        if self.use_hue:\n",
        "            hues = (np.log(amplitudes).imag / TAU) % 1\n",
        "            hsl = 0.5 * np.ones((n, 3))\n",
        "            hsl[:, 0] = hues\n",
        "            rgbas[:, :3] = hsl_to_rgb(hsl)\n",
        "\n",
        "        dot_cloud.set_rgba_array(rgbas)\n",
        "        return dot_cloud\n",
        "\n",
        "    def create_dot_sheet(self, width=4, height=4, radius=0.05, z=0, make_3d=False):\n",
        "        # Add dots\n",
        "        dots = DotCloud()\n",
        "        dots.set_color(WHITE)\n",
        "        dots.to_grid(int(height / radius / 2), int(width / radius / 2))\n",
        "        dots.set_shape(width, height)\n",
        "        dots.set_radius(radius)\n",
        "        dots.add_updater(self.color_dot_cloud_by_diffraction)\n",
        "        dots.suspend_updating = lambda: None  # Never suspend!\n",
        "        dots.set_z(z)\n",
        "\n",
        "        if make_3d:\n",
        "            dots.make_3d()\n",
        "\n",
        "        return dots\n",
        "\n",
        "    # TODO, have a picture-in-picture graph showing the sine waves for a given source\n",
        "    # TODO, have a picture in picture phasor\n"
    ]
}