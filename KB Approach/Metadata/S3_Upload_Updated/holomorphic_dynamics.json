{
    "topic": "The mathematical concept being demonstrated is the Mandelbrot fractal.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.newton_fractal import *\n",
        "\n",
        "\n",
        "MANDELBROT_COLORS = [\n",
        "    \"#00065c\",\n",
        "    \"#061e7e\",\n",
        "    \"#0c37a0\",\n",
        "    \"#205abc\",\n",
        "    \"#4287d3\",\n",
        "    \"#D9EDE4\",\n",
        "    \"#F0F9E4\",\n",
        "    \"#BA9F6A\",\n",
        "    \"#573706\",\n",
        "]\n",
        "\n",
        "\n",
        "def get_c_dot_label(dot, get_c, font_size=24, direction=UP):\n",
        "    c_label = VGroup(\n",
        "        OldTex(\"c = \", font_size=font_size),\n",
        "        DecimalNumber(get_c(), font_size=font_size, include_sign=True)\n",
        "    ).arrange(RIGHT, buff=0.075)\n",
        "    c_label[0].shift(0.02 * DOWN)\n",
        "    c_label.set_color(YELLOW)\n",
        "    c_label.set_stroke(BLACK, 5, background=True)\n",
        "    c_label.add_updater(lambda m: m.next_to(dot, direction, SMALL_BUFF))\n",
        "    c_label.add_updater(lambda m: m[1].set_value(get_c()))\n",
        "    return c_label\n",
        "\n",
        "\n",
        "def get_iteration_label(font_size=36):\n",
        "    kw = {\n",
        "        \"tex_to_color_map\": {\n",
        "            \"z_0\": BLUE_C,\n",
        "            \"z_1\": BLUE_D,\n",
        "            \"z_2\": GREEN_D,\n",
        "            \"z_3\": GREEN_E,\n",
        "            \"z_{n + 1}\": GREEN_D,\n",
        "            \"z_n\": BLUE,\n",
        "            \"\\\\longrightarrow\": WHITE,\n",
        "        },\n",
        "        \"font_size\": font_size,\n",
        "    }\n",
        "    iterations = OldTex(\n",
        "        \"\"\"\n",
        "        z_0 \\\\longrightarrow\n",
        "        z_1 \\\\longrightarrow\n",
        "        z_2 \\\\longrightarrow\n",
        "        z_3 \\\\longrightarrow\n",
        "        \\\\cdots\n",
        "        \"\"\",\n",
        "        **kw\n",
        "    )\n",
        "    for part in iterations.get_parts_by_tex(\"\\\\longrightarrow\"):\n",
        "        f = OldTex(\"f\", **kw)\n",
        "        f.scale(0.5)\n",
        "        f.next_to(part, UP, buff=0)\n",
        "        part.add(f)\n",
        "\n",
        "    rule = OldTex(\"z_{n + 1} &= f(z_n)\", **kw)\n",
        "    result = VGroup(rule, iterations)\n",
        "    result.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "    return result\n",
        "\n",
        "\n",
        "class MandelbrotFractal(NewtonFractal):\n",
        "    CONFIG = {\n",
        "        \"shader_folder\": \"mandelbrot_fractal\",\n",
        "        \"data_dtype\": [\n",
        "            ('point', np.float32, (3,)),\n",
        "        ],\n",
        "        \"scale_factor\": 1.0,\n",
        "        \"offset\": ORIGIN,\n",
        "        \"colors\": MANDELBROT_COLORS,\n",
        "        \"n_colors\": 9,\n",
        "        \"parameter\": complex(0, 0),\n",
        "        \"n_steps\": 300,\n",
        "        \"mandelbrot\": True,\n",
        "    }\n",
        "\n",
        "    def init_uniforms(self):\n",
        "        Mobject.init_uniforms(self)\n",
        "        self.uniforms[\"mandelbrot\"] = float(self.mandelbrot)\n",
        "        self.set_parameter(self.parameter)\n",
        "        self.set_opacity(self.opacity)\n",
        "        self.set_scale(self.scale_factor)\n",
        "        self.set_colors(self.colors)\n",
        "        self.set_offset(self.offset)\n",
        "        self.set_n_steps(self.n_steps)\n",
        "\n",
        "    def set_parameter(self, c):\n",
        "        self.uniforms[\"parameter\"] = np.array([c.real, c.imag])\n",
        "        return self\n",
        "\n",
        "    def set_opacity(self, opacity):\n",
        "        self.uniforms[\"opacity\"] = opacity\n",
        "        return self\n",
        "\n",
        "    def set_colors(self, colors):\n",
        "        for n in range(len(colors)):\n",
        "            self.uniforms[f\"color{n}\"] = color_to_rgb(colors[n])\n",
        "        return self\n",
        "\n",
        "\n",
        "class JuliaFractal(MandelbrotFractal):\n",
        "    CONFIG = {\n",
        "        \"n_steps\": 100,\n",
        "        \"mandelbrot\": False,\n",
        "    }\n",
        "\n",
        "    def set_c(self, c):\n",
        "        self.set_parameter(c)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class MandelbrotSetPreview(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(\n",
        "            (-2, 1), (-2, 2),\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_B,\n",
        "                \"stroke_opacity\": 0.5,\n",
        "            }\n",
        "        )\n",
        "        plane.set_width(0.7 * FRAME_WIDTH)\n",
        "        plane.axes.set_stroke(opacity=0.5)\n",
        "        plane.add_coordinate_labels(font_size=18)\n",
        "\n",
        "        mandelbrot = MandelbrotFractal(plane)\n",
        "        mandelbrot.set_n_steps(0)\n",
        "\n",
        "        self.add(mandelbrot, plane)\n",
        "        self.play(\n",
        "            mandelbrot.animate.set_n_steps(300),\n",
        "            rate_func=lambda a: a**3,\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HolomorphicDynamics(Scene):\n",
        "    def construct(self):\n",
        "        self.show_goals()\n",
        "        self.complex_functions()\n",
        "        self.repeated_functions()\n",
        "        self.example_fractals()\n",
        "\n",
        "    def show_goals(self):\n",
        "        background = FullScreenRectangle()\n",
        "        self.add(background)\n",
        "\n",
        "        title = self.title = Text(\"Holomorphic Dynamics\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "        title.set_stroke(BLACK, 3, background=True)\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "        underline.scale(1.2)\n",
        "        underline.insert_n_curves(20)\n",
        "        underline.set_stroke(YELLOW, [1, *5 * [3], 1])\n",
        "        self.add(title)\n",
        "        self.add(underline, title)\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.wait()\n",
        "\n",
        "        frames = Square().replicate(2)\n",
        "        frames.set_height(5)\n",
        "        frames.set_width(6, stretch=True)\n",
        "        frames.set_stroke(WHITE, 2)\n",
        "        frames.set_fill(BLACK, 1)\n",
        "        frames.arrange(RIGHT, buff=1)\n",
        "        frames.to_edge(DOWN)\n",
        "\n",
        "        goals = VGroup(\n",
        "            # OldTexText(\"Newton's fractal $\\\\leftrightarrow$ Mandelbrot\"),\n",
        "            # OldTexText(\"Tie up loose ends\"),\n",
        "            OldTexText(\"Goal 1: Other Mandelbrot occurrences\"),\n",
        "            OldTexText(\"Goal 2: Tie up loose ends\"),\n",
        "        )\n",
        "        goals.set_width(frames[0].get_width())\n",
        "        goals.set_fill(GREY_A)\n",
        "        for goal, frame in zip(goals, frames):\n",
        "            goal.next_to(frame, UP)\n",
        "            goal.align_to(goals[0], UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(frames[0]),\n",
        "            FadeIn(goals[0], 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(frames[1]),\n",
        "            FadeIn(goals[1], 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition\n",
        "        rect = SurroundingRectangle(title.get_part_by_text(\"Holomorphic\"))\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        self.play(\n",
        "            ReplacementTransform(underline, rect),\n",
        "            FadeOut(background),\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                *goals, *frames,\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        self.title_rect = rect\n",
        "\n",
        "    def complex_functions(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"\\\\mathds{C}\": BLUE,\n",
        "                \"z\": YELLOW,\n",
        "            }\n",
        "        }\n",
        "        f_def = VGroup(\n",
        "            OldTex(\"f : \\\\mathds{C} \\\\rightarrow \\\\mathds{C}\", **kw),\n",
        "            OldTex(\"f'(z) \\\\text{ exists}\", **kw)\n",
        "        )\n",
        "        f_def.arrange(RIGHT, aligned_edge=DOWN, buff=LARGE_BUFF)\n",
        "        f_def.next_to(self.title, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        for part in f_def:\n",
        "            self.play(Write(part, stroke_width=1))\n",
        "            self.wait()\n",
        "\n",
        "        # Examples\n",
        "        examples = VGroup(\n",
        "            OldTex(\"f(z) = z^2 + 1\", **kw),\n",
        "            OldTex(\"f(z) = e^z\", **kw),\n",
        "            OldTex(\"f(z) = \\\\sin\\\\left(z\\\\right)\", **kw),\n",
        "            OldTex(\"\\\\vdots\")\n",
        "        )\n",
        "        examples.arrange(DOWN, buff=0.35, aligned_edge=LEFT)\n",
        "        examples[-1].shift(0.25 * RIGHT)\n",
        "        examples.set_width(2.5)\n",
        "        examples.to_corner(UL)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, examples,\n",
        "            shift=0.25 * DOWN,\n",
        "            run_time=3,\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "        # Transition\n",
        "        rect = self.title_rect\n",
        "        new_rect = SurroundingRectangle(self.title.get_part_by_text(\"Dynamics\"))\n",
        "        new_rect.match_style(rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(examples, lag_ratio=0.1),\n",
        "            FadeOut(f_def, lag_ratio=0.1),\n",
        "            Transform(rect, new_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def repeated_functions(self):\n",
        "        words = OldTexText(\"For some function $f(z)$,\")\n",
        "        rule, iterations = get_iteration_label()\n",
        "        group = VGroup(words, iterations, rule)\n",
        "        group.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        group.next_to(self.title, DOWN, LARGE_BUFF)\n",
        "        group.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words),\n",
        "            FadeIn(iterations, lag_ratio=0.2, run_time=2)\n",
        "        )\n",
        "        self.play(FadeIn(rule, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            words, iterations, rule, self.title_rect\n",
        "        )))\n",
        "\n",
        "    def example_fractals(self):\n",
        "        newton = OldTex(\"z - {P(z) \\\\over P'(z)}\")\n",
        "        mandelbrot = OldTex(\"z^2 + c\")\n",
        "        exponential = OldTex(\"a^z\")\n",
        "\n",
        "        rhss = VGroup(newton, mandelbrot, exponential)\n",
        "        f_eqs = VGroup()\n",
        "        lhss = VGroup()\n",
        "        for rhs in rhss:\n",
        "            rhs.generate_target()\n",
        "            lhs = OldTex(\"f(z) = \")\n",
        "            lhs.next_to(rhs, LEFT)\n",
        "            f_eqs.add(VGroup(lhs, rhs))\n",
        "            lhss.add(lhs)\n",
        "        VGroup(exponential, mandelbrot).shift(0.05 * UP)\n",
        "        f_eqs.arrange(RIGHT, buff=1.5)\n",
        "        f_eqs.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        rects = Square().replicate(3)\n",
        "        rects.arrange(RIGHT, buff=0.2 * rects.get_width())\n",
        "        rects.set_width(FRAME_WIDTH - 1)\n",
        "        rects.center().to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        arrows = VGroup()\n",
        "        for rect, f_eq in zip(rects, f_eqs):\n",
        "            arrow = Vector(0.5 * DOWN)\n",
        "            arrow.next_to(rect, UP)\n",
        "            arrows.add(arrow)\n",
        "            f_eq.next_to(arrow, UP)\n",
        "        f_eqs[0].match_y(f_eqs[1])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.title, UP),\n",
        "            LaggedStartMap(Write, rhss),\n",
        "            LaggedStartMap(FadeIn, lhss),\n",
        "            LaggedStartMap(FadeIn, rects),\n",
        "            LaggedStartMap(ShowCreation, arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HolomorphicPreview(Scene):\n",
        "    def construct(self):\n",
        "        in_plane = ComplexPlane(\n",
        "            (-2, 2),\n",
        "            (-2, 2),\n",
        "            height=5,\n",
        "            width=5,\n",
        "        )\n",
        "        in_plane.add_coordinate_labels(font_size=18)\n",
        "        in_plane.to_corner(DL)\n",
        "        out_plane = in_plane.deepcopy()\n",
        "        out_plane.to_corner(DR)\n",
        "\n",
        "        input_word = Text(\"Input\")\n",
        "        output_word = Text(\"Output\")\n",
        "\n",
        "        input_word.next_to(in_plane, UP)\n",
        "        output_word.next_to(out_plane, UP)\n",
        "\n",
        "        self.add(in_plane, out_plane, input_word, output_word)\n",
        "\n",
        "        # Show tiny neighborhood\n",
        "        tiny_plane = ComplexPlane(\n",
        "            (-2, 2),\n",
        "            (-2, 2),\n",
        "            height=0.5,\n",
        "            width=0.5,\n",
        "            axis_config={\n",
        "                \"stroke_width\": 1.0,\n",
        "            },\n",
        "            background_line_style={\n",
        "                \"stroke_width\": 1.0,\n",
        "            },\n",
        "            faded_line_ratio=1,\n",
        "        )\n",
        "        tiny_plane.move_to(in_plane.c2p(1, 1))\n",
        "\n",
        "        for plane in in_plane, out_plane:\n",
        "            plane.generate_target()\n",
        "            for mob in plane.target.family_members_with_points():\n",
        "                mob.set_opacity(mob.get_opacity() * 0.25)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(tiny_plane),\n",
        "            MoveToTarget(in_plane),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        def f(z):\n",
        "            w = z - complex(1, 1)\n",
        "            return complex(-1, 0.5) + complex(-1, 1) * w + 0.2 * w**2\n",
        "\n",
        "        tiny_plane.prepare_for_nonlinear_transform()\n",
        "        tiny_plane_image = tiny_plane.copy()\n",
        "        tiny_plane_image.apply_function(\n",
        "            lambda p: out_plane.n2p(f(in_plane.p2n(p)))\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(\n",
        "            tiny_plane, tiny_plane_image,\n",
        "            path_arc=-PI / 4,\n",
        "            stroke_width=5,\n",
        "        )\n",
        "        f_label = OldTex(\"f(z)\")\n",
        "        f_label.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        words = Text(\"Looks roughly like\\nscaling + rotating\")\n",
        "        words.set_width(2.5)\n",
        "        words.move_to(VGroup(in_plane, out_plane))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(f_label, 0.1 * UP),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(tiny_plane, tiny_plane_image),\n",
        "            MoveToTarget(out_plane),\n",
        "            FadeIn(words),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class AmbientRepetition(Scene):\n",
        "    n_steps = 30\n",
        "    # c = -0.6436875 + -0.441j\n",
        "    c = -0.5436875 + -0.641j\n",
        "    show_labels = True\n",
        "\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.set_height(6)\n",
        "        plane.add_coordinate_labels(font_size=18)\n",
        "        plane.to_corner(DR, buff=SMALL_BUFF)\n",
        "        self.add(plane)\n",
        "\n",
        "        font_size = 30\n",
        "\n",
        "        z0 = complex(0, 0)\n",
        "        dot = Dot(color=BLUE)\n",
        "        dot.move_to(plane.n2p(z0))\n",
        "        z_label = OldTex(\"z\", font_size=font_size)\n",
        "        z_label.set_stroke(BLACK, 5, background=True)\n",
        "        z_label.next_to(dot, UP, SMALL_BUFF)\n",
        "        if not self.show_labels:\n",
        "            z_label.set_opacity(0)\n",
        "        self.add(dot, z_label)\n",
        "\n",
        "        self.add(TracedPath(dot.get_center, stroke_width=1))\n",
        "\n",
        "        func = self.func\n",
        "\n",
        "        def get_new_point():\n",
        "            z = plane.p2n(dot.get_center())\n",
        "            return plane.n2p(func(z))\n",
        "\n",
        "        for n in range(self.n_steps):\n",
        "            new_point = get_new_point()\n",
        "            arrow = Arrow(dot.get_center(), new_point, buff=dot.get_height() / 2)\n",
        "\n",
        "            dot_copy = dot.copy()\n",
        "            dot_copy.move_to(new_point)\n",
        "            dot_copy.set_color(YELLOW)\n",
        "            fz_label = OldTex(\"f(z)\", font_size=font_size)\n",
        "            fz_label.set_stroke(BLACK, 8, background=True)\n",
        "            fz_label.next_to(dot_copy, normalize(new_point - dot.get_center()), buff=0)\n",
        "            if not self.show_labels:\n",
        "                fz_label.set_opacity(0)\n",
        "\n",
        "            self.add(dot, dot_copy, arrow, z_label)\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                TransformFromCopy(dot, dot_copy),\n",
        "                FadeInFromPoint(fz_label, z_label.get_center()),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            to_fade = VGroup(\n",
        "                dot.copy(), z_label.copy(),\n",
        "                dot_copy, arrow, fz_label,\n",
        "            )\n",
        "            dot.move_to(dot_copy)\n",
        "            z_label.next_to(dot, UP, SMALL_BUFF)\n",
        "            self.remove(z_label)\n",
        "            self.play(\n",
        "                *map(FadeOut, to_fade),\n",
        "                FadeIn(z_label),\n",
        "            )\n",
        "\n",
        "    def func(self, z):\n",
        "        return 2 * ((z / 2)**2 + self.c)\n",
        "\n",
        "\n",
        "class AmbientRepetitionLimitPoint(AmbientRepetition):\n",
        "    n_steps = 30\n",
        "    c = complex()\n",
        "    c = 0.234 + 0.222j\n",
        "    show_labels = False\n",
        "\n",
        "\n",
        "class AmbientRepetitionInfty(AmbientRepetition):\n",
        "    c = -0.7995 + 0.3503j\n",
        "    n_steps = 12\n",
        "\n",
        "\n",
        "class AmbientRepetitionChaos(AmbientRepetition):\n",
        "    def func(self, c):\n",
        "        return complex(\n",
        "            random.random() * 4 - 2,\n",
        "            random.random() * 4 - 2,\n",
        "        )\n",
        "\n",
        "\n",
        "class Recap(VideoWrapper):\n",
        "    title = \"Newton's fractal quick recap\"\n",
        "    animate_boundary = False\n",
        "    screen_height = 6.3\n",
        "\n",
        "\n",
        "class RepeatedNewtonPlain(RepeatedNewton):\n",
        "    n_steps = 20\n",
        "    colors = ROOT_COLORS_DEEP\n",
        "\n",
        "\n",
        "class RationalFunctions(Scene):\n",
        "    def construct(self):\n",
        "        # Show function\n",
        "        equation = OldTex(\n",
        "            \"f(z)\",\n",
        "            \"=\", \"z - {P(z) \\\\over P'(z)}\",\n",
        "            \"=\", \"z - {z^3 - 1 \\\\over 3z^2}\",\n",
        "            \"=\", \"{2z^3 + 1 \\\\over 3z^2}\"\n",
        "        )\n",
        "        iter_brace = Brace(equation[2], UP)\n",
        "        iter_text = iter_brace.get_text(\"What's being iterated\")\n",
        "        VGroup(iter_brace, iter_text).set_color(BLUE_D)\n",
        "        example_brace = Brace(equation[4], DOWN)\n",
        "        example_text = example_brace.get_text(\"For example\")\n",
        "        VGroup(example_brace, example_text).set_color(TEAL_D)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(equation[:3]),\n",
        "            GrowFromCenter(iter_brace),\n",
        "            FadeIn(iter_text, 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(equation[3:5]),\n",
        "            GrowFromCenter(example_brace),\n",
        "            FadeIn(example_text, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equation[5]),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(equation[4][i].copy(), equation[6][j])\n",
        "                for i, j in zip(\n",
        "                    [1, 0, *range(2, 10)],\n",
        "                    [0, 0, *range(1, 9)],\n",
        "                )\n",
        "            ), lag_ratio=0.02)\n",
        "        )\n",
        "        self.add(equation[6])\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(equation[4][i].copy().set_opacity(0), equation[6][j].copy().set_opacity(0))\n",
        "                for i, j in zip(\n",
        "                    [0, 0, 0, 0],\n",
        "                    [0, 0, 0, 0],\n",
        "                )\n",
        "            ), lag_ratio=0.02)\n",
        "        )\n",
        "        self.add(equation)\n",
        "        self.wait()\n",
        "\n",
        "        # Name rational function\n",
        "        box = SurroundingRectangle(equation[6], buff=SMALL_BUFF)\n",
        "        box.set_stroke(YELLOW, 2)\n",
        "        rational_name = OldTexText(\"``Rational function''\")\n",
        "        rational_name.next_to(box, UP, buff=1.5)\n",
        "        arrow = Arrow(rational_name, box)\n",
        "\n",
        "        self.play(\n",
        "            Write(rational_name),\n",
        "            ShowCreation(arrow),\n",
        "            ShowCreation(box),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Forget about the Newton's method origins\n",
        "        self.play(\n",
        "            equation[:2].animate.next_to(ORIGIN, LEFT, SMALL_BUFF),\n",
        "            equation[2:6].animate.set_opacity(0.5).scale(0.5).to_corner(DR),\n",
        "            VGroup(equation[6], box).animate.next_to(ORIGIN, RIGHT, SMALL_BUFF),\n",
        "            MaintainPositionRelativeTo(\n",
        "                VGroup(rational_name, arrow),\n",
        "                box,\n",
        "            ),\n",
        "            FadeOut(\n",
        "                VGroup(example_brace, example_text, iter_brace, iter_text),\n",
        "                shift=2 * RIGHT + DOWN\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Other rational functions\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        rhs = equation[6]\n",
        "        functions = VGroup(\n",
        "            OldTex(\"3z^4 + z^3 + 4 \\\\over z^5 + 5z + 9\"),\n",
        "            OldTex(\"2z^6 + 7z^4 + 1z \\\\over 8z^3 + 2z^2 + 8\"),\n",
        "            OldTex(\"(z^2 + 1)^2 \\\\over 4z(z^2 - 1)\"),\n",
        "            OldTex(\"az + b \\\\over cz + d\"),\n",
        "            OldTex(\"z^2 + az + b \\\\over z^2 + cz + d\"),\n",
        "            OldTex(\n",
        "                \"a_n z^n + \\\\cdots + a_0 \\\\over \"\n",
        "                \"b_m z^m + \\\\cdots + b_0\"\n",
        "            ),\n",
        "            OldTex(\"z^2 + c \\\\over 1\"),\n",
        "        )\n",
        "\n",
        "        for function in functions:\n",
        "            function.replace(rhs, dim_to_match=1)\n",
        "            function.move_to(rhs, LEFT)\n",
        "            function.set_max_width(rhs.get_width() + 2)\n",
        "\n",
        "        for n, function in enumerate(functions):\n",
        "            self.play(\n",
        "                FadeOut(rhs, lag_ratio=0.1),\n",
        "                FadeIn(function, lag_ratio=0.1),\n",
        "                box.animate.set_opacity(0),\n",
        "            )\n",
        "            self.remove(box)\n",
        "            self.wait()\n",
        "            if n == 0:\n",
        "                self.play(\n",
        "                    rational_name.animate.next_to(box, UP),\n",
        "                    arrow.animate.scale(0, about_edge=DOWN),\n",
        "                    ApplyMethod(frame.shift, 2 * DOWN, run_time=2),\n",
        "                    FadeOut(equation[2:6]),\n",
        "                )\n",
        "            else:\n",
        "                self.wait()\n",
        "            rhs = function[0]\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(box),\n",
        "            FadeOut(rational_name),\n",
        "            FadeOut(rhs[4:]),\n",
        "            rhs[:4].animate.next_to(ORIGIN, RIGHT, SMALL_BUFF).shift(0.07 * UP),\n",
        "            frame.animate.shift(DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowFatouAndJulia(Scene):\n",
        "    def construct(self):\n",
        "        time_range = (1900, 2020)\n",
        "        timeline = NumberLine(\n",
        "            (*time_range, 1),\n",
        "            tick_size=0.025,\n",
        "            longer_tick_multiple=4,\n",
        "            big_tick_numbers=range(*time_range, 10),\n",
        "        )\n",
        "        timeline.stretch(0.25, 0)\n",
        "        timeline.add_numbers(\n",
        "            range(*time_range, 10),\n",
        "            group_with_commas=False,\n",
        "        )\n",
        "        timeline.set_y(-3)\n",
        "        timeline.to_edge(LEFT, buff=0)\n",
        "\n",
        "        line = Line(timeline.n2p(1917), timeline.n2p(1920))\n",
        "        line.scale(2)\n",
        "        brace = Brace(line, UP)\n",
        "        brace.stretch(1 / 2, 0)\n",
        "        line.stretch(0.6, 0)\n",
        "        line.insert_n_curves(20)\n",
        "        line.set_stroke(BLUE, [1, *3 * [5], 1])\n",
        "\n",
        "        kw = {\"label_direction\": UP, \"height\": 3}\n",
        "        figures = Group(\n",
        "            get_figure(\"Pierre_Fatou\", \"Pierre Fatou\", \"1878-1929\", **kw),\n",
        "            get_figure(\"Gaston_Julia\", \"Gaston Julia\", \"1893-1978\", **kw),\n",
        "        )\n",
        "        figures.set_height(3)\n",
        "        figures.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        figures.next_to(brace, UP)\n",
        "\n",
        "        self.add(timeline)\n",
        "        self.add(figures)\n",
        "        for figure in figures:\n",
        "            self.remove(*figure[2:])\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.align_to(timeline, RIGHT)\n",
        "        self.play(Restore(frame, run_time=3))\n",
        "        self.play(LaggedStart(*(\n",
        "            Write(VGroup(*figure[2:]))\n",
        "            for figure in figures\n",
        "        ), lag_ratio=0.7))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Names\n",
        "        names = VGroup(*(figure[2][-5:] for figure in figures))\n",
        "        rects = VGroup(*(SurroundingRectangle(name, buff=0.05) for name in names))\n",
        "        rects.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, rects))\n",
        "\n",
        "\n",
        "class IveSeenThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\"f(z) = z^2 + c\")\n",
        "        equation.to_edge(UP)\n",
        "        self.add(equation)\n",
        "\n",
        "        mandelbrot_outline = ImageMobject(\"Mandelbrot_boundary\")\n",
        "        mandelbrot_outline.set_height(3)\n",
        "        mandelbrot_outline.move_to(self.students[2].get_corner(UR))\n",
        "        mandelbrot_outline.shift(1.2 * UP)\n",
        "\n",
        "        self.student_says(\n",
        "            \"I've seen this one\",\n",
        "            target_mode=\"surprised\",\n",
        "            look_at=equation,\n",
        "            added_anims=[\n",
        "                self.students[0].change(\"tease\", equation),\n",
        "                self.students[1].change(\"happy\", equation),\n",
        "                self.teacher.change(\"happy\", equation),\n",
        "            ]\n",
        "        )\n",
        "        self.play(self.teacher.change(\"tease\"))\n",
        "        self.wait(2)\n",
        "        self.add(mandelbrot_outline, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeOut(self.background),\n",
        "            RemovePiCreatureBubble(\n",
        "                self.students[2],\n",
        "                target_mode=\"raise_right_hand\",\n",
        "                look_at=mandelbrot_outline,\n",
        "            ),\n",
        "            FadeIn(mandelbrot_outline, 0.5 * UP, scale=2),\n",
        "            self.students[0].change(\"pondering\", mandelbrot_outline),\n",
        "            self.students[1].change(\"thinking\", mandelbrot_outline),\n",
        "            self.teacher.change(\"happy\", self.students[2].eyes),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class MandelbrotIntro(Scene):\n",
        "    n_iterations = 30\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_process_description()\n",
        "        self.add_plane()\n",
        "        self.show_iterations()\n",
        "        self.add_mandelbrot_image()\n",
        "\n",
        "    def add_process_description(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{c}\": YELLOW,\n",
        "            }\n",
        "        }\n",
        "        terms = self.terms = VGroup(\n",
        "            OldTex(\"z_{n + 1} = z_n^2 + {c}\", **kw),\n",
        "            OldTex(\"{c} \\\\text{ can be changed}\", **kw),\n",
        "            OldTex(\"z_0 = 0\", **kw),\n",
        "        )\n",
        "        terms.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        terms.to_corner(UL)\n",
        "\n",
        "        equation = OldTex(\"f(z) = z^2 + c\")\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.process_terms = terms\n",
        "        self.add(equation)\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(equation, terms[0]))\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane((-2, 1), (-2, 2))\n",
        "        plane.set_height(4)\n",
        "        plane.set_height(1.5 * FRAME_HEIGHT)\n",
        "        plane.next_to(2 * LEFT, RIGHT, buff=0)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        self.add(plane)\n",
        "\n",
        "    def show_iterations(self):\n",
        "        plane = self.plane\n",
        "\n",
        "        # c0 = complex(-0.2, 0.95)\n",
        "        c0 = complex(-0.6, 0.4)\n",
        "\n",
        "        c_dot = self.c_dot = Dot()\n",
        "        c_dot.set_fill(YELLOW)\n",
        "        c_dot.set_stroke(BLACK, 5, background=True)\n",
        "        c_dot.move_to(plane.n2p(c0))\n",
        "        c_dot.add_updater(lambda m: m)  # Null\n",
        "\n",
        "        n_iter_tracker = ValueTracker(1)\n",
        "\n",
        "        def get_n_iters():\n",
        "            return int(n_iter_tracker.get_value())\n",
        "\n",
        "        def get_c():\n",
        "            return plane.p2n(c_dot.get_center())\n",
        "\n",
        "        def update_lines(lines):\n",
        "            z1 = 0\n",
        "            c = get_c()\n",
        "            new_lines = []\n",
        "\n",
        "            for n in range(get_n_iters()):\n",
        "                try:\n",
        "                    z2 = z1**2 + c\n",
        "                    new_lines.append(Line(\n",
        "                        plane.n2p(z1),\n",
        "                        plane.n2p(z2),\n",
        "                        stroke_color=GREY,\n",
        "                        stroke_width=2,\n",
        "                    ))\n",
        "                    new_lines.append(Dot(\n",
        "                        plane.n2p(z2),\n",
        "                        fill_color=YELLOW,\n",
        "                        fill_opacity=0.5,\n",
        "                        radius=0.05,\n",
        "                    ))\n",
        "                    z1 = z2\n",
        "                except Exception:\n",
        "                    pass\n",
        "\n",
        "            lines.set_submobjects(new_lines)\n",
        "\n",
        "        c_label = get_c_dot_label(c_dot, get_c)\n",
        "\n",
        "        lines = VGroup()\n",
        "        lines.set_stroke(background=True)\n",
        "        lines.add_updater(update_lines)\n",
        "        self.add(lines, c_dot, c_label)\n",
        "\n",
        "        def increase_step(run_time=1.0):\n",
        "            n_iter_tracker.increment_value(1)\n",
        "            lines.update()\n",
        "            lines.suspend_updating()\n",
        "            self.add(*lines, c_dot, c_label)\n",
        "            self.play(\n",
        "                ShowCreation(lines[-2]),\n",
        "                TransformFromCopy(lines[-3], lines[-1]),\n",
        "                run_time=run_time\n",
        "            )\n",
        "            self.add(lines, c_dot, c_label)\n",
        "            lines.resume_updating()\n",
        "\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"c\": YELLOW,\n",
        "            }\n",
        "        }\n",
        "        new_lines = VGroup(\n",
        "            OldTex(\"z_1 = 0^2 + c = c\", **kw),\n",
        "            OldTex(\"z_2 = c^2 + c\", **kw),\n",
        "            OldTex(\"z_3 = (c^2 + c)^2 + c\", **kw),\n",
        "            OldTex(\"z_4 = ((c^2 + c)^2 + c)^2 + c\", **kw),\n",
        "            OldTex(\"\\\\vdots\", **kw),\n",
        "        )\n",
        "        new_lines.arrange(DOWN, aligned_edge=LEFT)\n",
        "        new_lines[-2].scale(0.8, about_edge=LEFT)\n",
        "        new_lines.next_to(self.process_terms[2], DOWN, aligned_edge=LEFT)\n",
        "        new_lines[-1].match_x(new_lines[-2][0][2])\n",
        "\n",
        "        # Show c\n",
        "        self.wait()\n",
        "        self.play(Write(self.process_terms[1]))\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show first step\n",
        "        dot = Dot(plane.n2p(0))\n",
        "        self.play(FadeIn(self.process_terms[2], 0.5 * DOWN))\n",
        "        self.play(FadeIn(dot, scale=0.2, run_time=2))\n",
        "        self.play(FadeOut(dot))\n",
        "\n",
        "        self.play(FadeIn(new_lines[0], 0.5 * DOWN))\n",
        "        self.play(ShowCreationThenFadeOut(\n",
        "            lines[0].copy().set_stroke(BLUE, 5)\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show second step\n",
        "        self.play(FadeIn(new_lines[1], 0.5 * DOWN))\n",
        "        increase_step()\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show 3rd to nth steps\n",
        "        self.play(FadeIn(new_lines[2], 0.5 * DOWN))\n",
        "        increase_step()\n",
        "        self.play(FadeIn(new_lines[3], 0.5 * DOWN))\n",
        "        increase_step()\n",
        "        self.wait(5)\n",
        "        self.play(FadeIn(new_lines[4]))\n",
        "        for n in range(self.n_iterations):\n",
        "            increase_step(run_time=0.25)\n",
        "\n",
        "        # Play around\n",
        "        self.wait(15)\n",
        "\n",
        "    def add_mandelbrot_image(self):\n",
        "        mandelbrot_set = MandelbrotFractal(self.plane)\n",
        "\n",
        "        self.add(mandelbrot_set, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeIn(mandelbrot_set, run_time=2),\n",
        "            # self.plane.animate.set_opacity(0.5)\n",
        "            self.plane.animate.set_stroke(WHITE, opacity=0.25)\n",
        "        )\n",
        "\n",
        "    # Listeners\n",
        "    def on_mouse_motion(self, point, d_point):\n",
        "        super().on_mouse_motion(point, d_point)\n",
        "        if self.window.is_key_pressed(ord(\" \")):\n",
        "            self.c_dot.move_to(point)\n",
        "\n",
        "\n",
        "class BenSparksVideoWrapper(VideoWrapper):\n",
        "    title = \"Heavily inspired from Ben Sparks\"\n",
        "\n",
        "\n",
        "class AckoNet(VideoWrapper):\n",
        "    title = \"Acko.net, How to Fold a Julia Fractal\"\n",
        "\n",
        "\n",
        "class ParameterSpaceVsSeedSpace(Scene):\n",
        "    def construct(self):\n",
        "        boxes = Square().get_grid(2, 2, buff=0)\n",
        "        boxes.set_stroke(WHITE, 2)\n",
        "        boxes.set_height(6)\n",
        "        boxes.set_width(10, stretch=True)\n",
        "        boxes.to_corner(DR)\n",
        "        self.add(boxes)\n",
        "\n",
        "        f_labels = VGroup(\n",
        "            OldTex(\"f(z) = z^2 + c\"),\n",
        "            OldTex(\"f(z) = z - {P(z) \\\\over P'(z)}\"),\n",
        "        )\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"function\": YELLOW,\n",
        "                \"seed\": BLUE_D,\n",
        "            }\n",
        "        }\n",
        "        top_labels = VGroup(\n",
        "            OldTexText(\"One seed\\\\\\\\Pixel $\\\\leftrightarrow$ function\", **kw),\n",
        "            OldTexText(\"One function\\\\\\\\Pixel $\\\\leftrightarrow$ seed\", **kw),\n",
        "        )\n",
        "        for f_label, box in zip(f_labels, boxes[::2]):\n",
        "            f_label.set_max_width(3.25)\n",
        "            f_label.next_to(box, LEFT)\n",
        "        for top_label, box in zip(top_labels, boxes):\n",
        "            top_label.next_to(box, UP, buff=0.2)\n",
        "\n",
        "        for f_label in f_labels:\n",
        "            self.play(FadeIn(f_label, 0.25 * LEFT))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(top_labels[0]))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(\n",
        "            top_labels[0].copy(), top_labels[1]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MandelbrotStill(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane((-3, 2), (-1.3, 1.3))\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        fractal = MandelbrotFractal(plane)\n",
        "        self.add(fractal)\n",
        "\n",
        "\n",
        "class JuliaStill(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane((-4, 4), (-1.5, 1.5))\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        fractal = JuliaFractal(plane)\n",
        "        fractal.set_c(-0.03 + 0.74j)\n",
        "        fractal.set_n_steps(100)\n",
        "        self.add(fractal)\n",
        "\n",
        "\n",
        "class ClassicJuliaSetDemo(MandelbrotIntro):\n",
        "    def construct(self):\n",
        "        # Init planes\n",
        "        kw = {\n",
        "            \"background_line_style\": {\n",
        "                \"stroke_width\": 0.5,\n",
        "            }\n",
        "        }\n",
        "        planes = VGroup(\n",
        "            ComplexPlane((-2, 1), (-1.6, 1.6), **kw),\n",
        "            ComplexPlane((-2, 2), (-2, 2), **kw),\n",
        "        )\n",
        "        for plane, corner in zip(planes, [DL, DR]):\n",
        "            plane.set_stroke(WHITE, opacity=0.5)\n",
        "            plane.set_height(6)\n",
        "            plane.to_corner(corner, buff=MED_SMALL_BUFF)\n",
        "            plane.to_edge(DOWN, SMALL_BUFF)\n",
        "\n",
        "        planes[1].add_coordinate_labels(font_size=18)\n",
        "        planes[0].add_coordinate_labels(\n",
        "            (-1, 0, 1, 1j, -1j),\n",
        "            font_size=18\n",
        "        )\n",
        "\n",
        "        # Init fractals\n",
        "        mandelbrot = MandelbrotFractal(planes[0])\n",
        "        julia = JuliaFractal(planes[1])\n",
        "        fractals = Group(mandelbrot, julia)\n",
        "\n",
        "        self.add(*fractals, *planes)\n",
        "\n",
        "        # Add c_dot\n",
        "        c_dot = self.c_dot = Dot(radius=0.05)\n",
        "        c_dot.set_fill(YELLOW, 1)\n",
        "        c_dot.move_to(planes[0].c2p(-0.5, 0.5))\n",
        "        c_dot.add_updater(lambda m: m)\n",
        "\n",
        "        def get_c():\n",
        "            return planes[0].p2n(c_dot.get_center())\n",
        "\n",
        "        c_label = get_c_dot_label(c_dot, get_c, direction=UR)\n",
        "        julia.add_updater(lambda m: m.set_c(get_c()))\n",
        "\n",
        "        self.add(c_dot, c_label)\n",
        "\n",
        "        # Add labels\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{z_0}\": GREY_A,\n",
        "                \"{c}\": YELLOW,\n",
        "                \"\\\\text{Pixel}\": BLUE_D,\n",
        "            },\n",
        "        }\n",
        "\n",
        "        title = OldTexText(\"Iterate\\\\\\\\$z^2 + c$\")\n",
        "        title.move_to(Line(*planes))\n",
        "        title[0][-1].set_color(YELLOW)\n",
        "        self.add(title)\n",
        "\n",
        "        labels = VGroup(\n",
        "            VGroup(\n",
        "                OldTex(\"{c} \\\\leftrightarrow \\\\text{Pixel}\", **kw),\n",
        "                OldTex(\"z_0 = 0\", **kw),\n",
        "            ),\n",
        "            VGroup(\n",
        "                OldTex(\"{c} = \\\\text{const.}\", **kw),\n",
        "                OldTex(\"z_0 \\\\leftrightarrow \\\\text{Pixel}\", **kw),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        for label, plane in zip(labels, planes):\n",
        "            label.arrange(DOWN, aligned_edge=LEFT)\n",
        "            label.next_to(plane, UP)\n",
        "\n",
        "        space_labels = VGroup(\n",
        "            OldTex(\"{c}\\\\text{-space}\", **kw),\n",
        "            OldTex(\"{z_0}\\\\text{-space}\", **kw),\n",
        "        )\n",
        "        for label, plane in zip(space_labels, planes):\n",
        "            label.scale(0.5)\n",
        "            label.move_to(plane, UL).shift(SMALL_BUFF * DR)\n",
        "        self.add(space_labels)\n",
        "\n",
        "        # Animations\n",
        "        self.add(labels[0])\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                labels[0][0][0],\n",
        "                labels[1][0][0],\n",
        "            ),\n",
        "            FadeIn(labels[1][0][1]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                labels[0][1].get_part_by_tex(\"z_0\"),\n",
        "                labels[1][1].get_part_by_tex(\"z_0\"),\n",
        "            ),\n",
        "            FadeTransform(\n",
        "                labels[0][0][1:].copy(),\n",
        "                labels[1][1][1:],\n",
        "            ),\n",
        "        )\n",
        "\n",
        "\n",
        "class AskAboutGeneralTheory(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Think about constructing\\\\\\\\a general theory\"),\n",
        "            added_anims=[self.change_students(\n",
        "                \"pondering\", \"thinking\", \"pondering\",\n",
        "                look_at=UP,\n",
        "            )]\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"What questions would\\\\\\\\you ask?\"),\n",
        "            target_mode=\"tease\",\n",
        "        )\n",
        "        self.play_student_changes(\"thinking\", \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class NewtonRuleLabel(Scene):\n",
        "    def construct(self):\n",
        "        rule = get_newton_rule()\n",
        "        rule.scale(1.5)\n",
        "        rule.set_stroke(BLACK, 5, background=True)\n",
        "        rule.to_corner(UL)\n",
        "\n",
        "        box = SurroundingRectangle(rule, buff=0.2)\n",
        "        box.set_fill(BLACK, 0.9)\n",
        "        box.set_stroke(WHITE, 1)\n",
        "        VGroup(box, rule).to_corner(UL, buff=0)\n",
        "\n",
        "        self.add(box, rule)\n",
        "\n",
        "\n",
        "class FixedPoints(Scene):\n",
        "    def construct(self):\n",
        "        # Set the stage\n",
        "        iter_label = self.add_labels()\n",
        "        rule, iterations = iter_label\n",
        "        plane = self.add_plane()\n",
        "        z_dot, z_label = self.add_z_dot()\n",
        "\n",
        "        # Ask question\n",
        "        question = OldTexText(\"When does $z$ stay fixed in place?\")\n",
        "        question.next_to(plane, RIGHT, MED_LARGE_BUFF, aligned_edge=UP)\n",
        "\n",
        "        arrow = self.get_arrow_loop(z_dot)\n",
        "\n",
        "        # f(z) = z\n",
        "        t2c = {\"z\": BLUE}\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": t2c,\n",
        "            \"isolate\": [\"=\", \"\\\\Rightarrow\", \"A(\", \"B(\", \")\"],\n",
        "        }\n",
        "        equation = OldTex(\"f(z) = z\", **kw)\n",
        "        equation.next_to(question, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        newton_example = OldTex(\n",
        "            \"z - {P(z) \\\\over P'(z)} = z\",\n",
        "            \"\\\\quad \\\\Leftrightarrow \\\\quad \",\n",
        "            \"P(z) = 0\",\n",
        "            **kw,\n",
        "        )\n",
        "        newton_example.next_to(equation, DOWN, buff=LARGE_BUFF)\n",
        "        mandelbrot_example = OldTex(\n",
        "            \"\\\\text{Exercise 1a: Find the fixed points}\\\\\\\\\",\n",
        "            \"\\\\text{of }\", \"f(z) = z^2 + c\",\n",
        "            alignment=\"\\\\centering\",\n",
        "            **kw\n",
        "        )\n",
        "        mandelbrot_example[1:].match_x(mandelbrot_example[0])\n",
        "        mandelbrot_example.move_to(newton_example)\n",
        "\n",
        "        fixed_point = Text(\"Fixed point\")\n",
        "        fixed_point.next_to(equation, DOWN, LARGE_BUFF)\n",
        "        fixed_point.to_edge(RIGHT)\n",
        "        fp_arrow = Arrow(\n",
        "            fixed_point.get_left(),\n",
        "            equation[1].get_bottom(),\n",
        "            path_arc=-PI / 4,\n",
        "        )\n",
        "        fp_group = VGroup(fixed_point, fp_arrow)\n",
        "        fp_group.set_color(YELLOW)\n",
        "\n",
        "        self.play(FadeIn(equation, DOWN))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(fixed_point),\n",
        "            ShowCreation(fp_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(newton_example, shift=0.5 * DOWN),\n",
        "            FadeOut(fp_group),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(newton_example, 0.5 * DOWN),\n",
        "            FadeIn(mandelbrot_example, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Rational function\n",
        "        question_group = VGroup(question, equation)\n",
        "        question_group.generate_target()\n",
        "        iterations.generate_target()\n",
        "        VGroup(question_group.target, iterations.target).to_edge(UP)\n",
        "\n",
        "        rational_parts = VGroup(\n",
        "            OldTex(\"{A(z) \\\\over B(z)} = z\", **kw),\n",
        "            OldTex(\"A(z) = z \\\\cdot B(z)\", **kw),\n",
        "            OldTex(\"A(z) - z \\\\cdot B(z) = 0\", **kw),\n",
        "        )\n",
        "        rational_parts.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        for part, tex in zip(rational_parts[1:], (\"=\", \"-\")):\n",
        "            curr_x = part.get_part_by_tex(tex).get_x()\n",
        "            target_x = rational_parts[0].get_part_by_tex(\"=\").get_x()\n",
        "            part.shift((target_x - curr_x) * RIGHT)\n",
        "        rational_parts.next_to(question_group.target, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(rule, UP),\n",
        "            MoveToTarget(question_group),\n",
        "            MoveToTarget(iterations),\n",
        "            FadeOut(mandelbrot_example),\n",
        "            FadeIn(rational_parts[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        for p1, p2 in zip(rational_parts, rational_parts[1:]):\n",
        "            self.play(\n",
        "                TransformMatchingTex(\n",
        "                    p1.copy(), p2,\n",
        "                    path_arc=PI / 2,\n",
        "                    run_time=2,\n",
        "                    fade_transform_mismatches=True,\n",
        "                )\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        rect = SurroundingRectangle(rational_parts[-1])\n",
        "        solution_words = Text(\"Must have\\nsolutions!\", font_size=36)\n",
        "        solution_words.set_color(YELLOW)\n",
        "        solution_words.next_to(rect, RIGHT)\n",
        "        solution_words.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(solution_words, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        example_roots = [\n",
        "            -1.5 + 0.5j, -1.5 - 0.5j,\n",
        "            -1.0 + 1.2j, -1.0 - 1.2j,\n",
        "            1.0 + 1.0j, 1.0 - 1.0j,\n",
        "            0.5, 1.7,\n",
        "        ]\n",
        "        glow_dots = VGroup(*(\n",
        "            glow_dot(plane.n2p(root))\n",
        "            for root in example_roots\n",
        "        ))\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, glow_dots,\n",
        "            scale=0.5,\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about stability\n",
        "        def get_arrows(point, inward=False):\n",
        "            arrows = VGroup(*(\n",
        "                Arrow(ORIGIN, vect, buff=0.3)\n",
        "                for vect in compass_directions(8)\n",
        "            ))\n",
        "            arrows.set_height(1)\n",
        "            arrows.move_to(point)\n",
        "            if inward:\n",
        "                for arrow in arrows:\n",
        "                    arrow.rotate(PI)\n",
        "            return arrows\n",
        "\n",
        "        outward_arrows = get_arrows(glow_dots[2])\n",
        "        inward_arrows = get_arrows(glow_dots[4], inward=True)\n",
        "        arrow_groups = VGroup(inward_arrows, outward_arrows)\n",
        "\n",
        "        stability_words = VGroup(\n",
        "            Text(\"Attracting\"),\n",
        "            Text(\"Repelling\"),\n",
        "        )\n",
        "        for words, arrows in zip(stability_words, arrow_groups):\n",
        "            words.scale(0.7)\n",
        "            words.next_to(arrows, UP, SMALL_BUFF)\n",
        "            words.set_color(GREY_A)\n",
        "            words.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        stability_question = Text(\n",
        "            \"When are fixed points stable?\"\n",
        "        )\n",
        "        stability_question.move_to(question)\n",
        "        stable_underline = Underline(\n",
        "            stability_question.get_part_by_text(\"stable\")\n",
        "        )\n",
        "        stable_underline.insert_n_curves(20)\n",
        "        stable_underline.scale(1.2)\n",
        "        stable_underline.set_stroke(MAROON_B, [1, *4 * [4], 1])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question, RIGHT),\n",
        "            FadeIn(stability_question, RIGHT),\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(z_dot),\n",
        "            FadeOut(z_label),\n",
        "        )\n",
        "        self.play(ShowCreation(stable_underline))\n",
        "        self.wait()\n",
        "\n",
        "        for words, arrows in zip(stability_words, arrow_groups):\n",
        "            self.play(\n",
        "                FadeIn(words),\n",
        "                ShowCreation(arrows, lag_ratio=0.2, run_time=3)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show derivative condition\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.to_corner(DR)\n",
        "\n",
        "        deriv_ineq = OldTex(\"|f'(z)| < 1\", **kw)\n",
        "        deriv_ineq.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        equation.generate_target()\n",
        "        group = VGroup(equation.target, deriv_ineq)\n",
        "        group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        group.move_to(equation)\n",
        "\n",
        "        attracting_condition = deriv_ineq.copy()\n",
        "        repelling_condition = OldTex(\"|f'(z)| > 1\", **kw)\n",
        "        conditions = VGroup(attracting_condition, repelling_condition)\n",
        "        for condition, words in zip(conditions, stability_words):\n",
        "            condition.scale(0.7)\n",
        "            condition.set_stroke(BLACK, 5, background=True)\n",
        "            condition.move_to(words, DOWN)\n",
        "            if conditions is conditions[0]:\n",
        "                condition.shift(SMALL_BUFF * UP)\n",
        "            words.generate_target()\n",
        "            words.target.next_to(condition, UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                *rational_parts, rect, solution_words,\n",
        "            )),\n",
        "            VFadeIn(morty),\n",
        "            morty.change(\"tease\"),\n",
        "        )\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Use derivatives!\",\n",
        "            target_mode=\"hooray\",\n",
        "            bubble_config={\n",
        "                \"height\": 2,\n",
        "                \"width\": 4,\n",
        "            }\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(morty, target_mode=\"happy\"))\n",
        "        for condition, words in zip(conditions, stability_words):\n",
        "            self.play(\n",
        "                Write(condition),\n",
        "                MoveToTarget(words),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeInFromPoint(deriv_ineq, morty.get_corner(UL)),\n",
        "            MoveToTarget(equation),\n",
        "            morty.change(\"raise_right_hand\")\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        # Newton derivative examples\n",
        "        newton_case = VGroup(\n",
        "            OldTex(\"f(z) = z - {P(z) \\\\over P'(z)}\", **kw),\n",
        "            OldTex(\"f'(z) = {P(z)P''(z) \\\\over P'(z)^2}\", **kw),\n",
        "            OldTex(\"P(z) = 0 \\\\quad \\\\Rightarrow \\\\quad f'(z) = 0\", **kw),\n",
        "        )\n",
        "        newton_case.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "        newton_case.scale(0.8)\n",
        "        newton_case.next_to(equation, DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        alt_line1 = OldTex(\"f'(z) = 1 - {P'(z)P'(z) - P(z)P''(z) \\\\over P'(z)^2}\", **kw)\n",
        "        alt_line1.match_height(newton_case[1])\n",
        "        alt_line1.move_to(newton_case[1], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(equation.copy()[:3], newton_case[0]),\n",
        "            morty.change(\"pondering\", newton_case[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                deriv_ineq[:-1].copy(),\n",
        "                alt_line1[:4],\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(alt_line1[4:], lag_ratio=0.1, run_time=1.5),\n",
        "            morty.animate.scale(0.8, about_edge=DR).change(\"sassy\", alt_line1),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(alt_line1[4:], newton_case[1][4:]),\n",
        "            morty.change(\"tease\", alt_line1),\n",
        "        )\n",
        "        self.remove(alt_line1)\n",
        "        self.add(newton_case[1])\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"pondering\", newton_case[2]),\n",
        "            FadeIn(newton_case[2])\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        # Show super-attraction\n",
        "        super_arrows = VGroup(*(\n",
        "            get_arrows(dot, inward=True)\n",
        "            for dot in glow_dots\n",
        "        ))\n",
        "        attraction_anims = []\n",
        "        for cluster in super_arrows:\n",
        "            for arrow in cluster:\n",
        "                new_arrow = arrow.copy()\n",
        "                new_arrow.scale(1.5)\n",
        "                new_arrow.set_stroke(YELLOW, 8)\n",
        "                attraction_anims.append(\n",
        "                    ShowCreationThenFadeOut(new_arrow)\n",
        "                )\n",
        "\n",
        "        rect = SurroundingRectangle(newton_case[2][6:])\n",
        "        super_words = OldTexText(\"``Superattracting''\", font_size=36)\n",
        "        super_words.set_color(YELLOW)\n",
        "        super_words.next_to(rect, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"thinking\"),\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(super_words)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                *conditions, *stability_words,\n",
        "                outward_arrows, inward_arrows,\n",
        "            )),\n",
        "            LaggedStartMap(FadeIn, super_arrows, scale=0.5)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*attraction_anims, lag_ratio=0.02),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                *super_arrows, *newton_case,\n",
        "                rect, super_words, morty,\n",
        "                glow_dots,\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        # Mandelbrot exercise\n",
        "        part1 = mandelbrot_example\n",
        "        part1.set_height(0.9)\n",
        "        part2 = OldTexText(\n",
        "            \"Exercise 1b: Determine when at least\\\\\\\\\"\n",
        "            \"one fixed point is attracting.\",\n",
        "        )\n",
        "        part3 = OldTexText(\n",
        "            \"Exercise 1c$^{**}$: Show that the set of values\\\\\\\\\",\n",
        "            \"$c$ satisfying this form a cardioid.\",\n",
        "            tex_to_color_map={\"$c$\": YELLOW}\n",
        "        )\n",
        "        parts = VGroup(part1, part2, part3)\n",
        "        for part in part2, part3:\n",
        "            part.scale(part1[0][0].get_height() / part[0][0].get_height())\n",
        "        parts.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        parts.next_to(\n",
        "            VGroup(equation, deriv_ineq),\n",
        "            DOWN, buff=LARGE_BUFF,\n",
        "        )\n",
        "\n",
        "        mandelbrot = MandelbrotFractal(plane)\n",
        "\n",
        "        R = 0.25\n",
        "        cardioid = ParametricCurve(\n",
        "            lambda t: plane.c2p(\n",
        "                2 * R * math.cos(t) - R * math.cos(2 * t),\n",
        "                2 * R * math.sin(t) - R * math.sin(2 * t),\n",
        "            ),\n",
        "            t_range=(0, TAU)\n",
        "        )\n",
        "        cardioid.set_stroke(YELLOW, 4)\n",
        "\n",
        "        self.add(mandelbrot, plane)\n",
        "        plane.generate_target(use_deepcopy=True)\n",
        "        plane.target.set_stroke(WHITE, opacity=0.5)\n",
        "        self.play(\n",
        "            MoveToTarget(plane),\n",
        "            FadeIn(mandelbrot),\n",
        "            FadeIn(part1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(part2))\n",
        "        self.wait()\n",
        "        print(self.num_plays)\n",
        "        self.play(Write(part3))\n",
        "        self.play(ShowCreation(cardioid, run_time=4, rate_func=linear))\n",
        "        self.play(\n",
        "            cardioid.animate.set_fill(YELLOW, 0.25),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_labels(self):\n",
        "        iter_label = get_iteration_label(48)\n",
        "        iter_label.to_edge(UP)\n",
        "        self.add(iter_label)\n",
        "        return iter_label\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane(\n",
        "            (-2, 2), (-2, 2),\n",
        "            background_line_style={\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        )\n",
        "        plane.set_height(5)\n",
        "        plane.to_corner(DL)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "        self.add(plane)\n",
        "        return plane\n",
        "\n",
        "    def add_z_dot(self, z=1 + 1j, z_tex=\"z\"):\n",
        "        z_dot = Dot(radius=0.05, color=BLUE)\n",
        "        z_dot.move_to(self.plane.n2p(z))\n",
        "        z_label = OldTex(z_tex, font_size=30)\n",
        "        z_label.next_to(z_dot, UL, buff=0)\n",
        "        self.add(z_dot, z_label)\n",
        "        return z_dot, z_label\n",
        "\n",
        "    def get_arrow_loop(self, dot):\n",
        "        arrow = Line(\n",
        "            dot.get_bottom(),\n",
        "            dot.get_right(),\n",
        "            path_arc=330 * DEGREES,\n",
        "            buff=0.05,\n",
        "        )\n",
        "        arrow.add_tip(width=0.15, length=0.15)\n",
        "        arrow.set_color(GREY_A)\n",
        "        return arrow\n",
        "\n",
        "\n",
        "class UseNewton(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\n",
        "                \"You could solve\\\\\\\\ $A(z) - z\\\\cdot B(z) = 0$ \\\\\\\\\",\n",
        "                \"using Newton's method\"\n",
        "            ),\n",
        "            bubble_config={\n",
        "                \"width\": 4,\n",
        "                \"height\": 3,\n",
        "            },\n",
        "            target_mode=\"hooray\",\n",
        "            added_anims=[\n",
        "                self.change_students(\"confused\", \"erm\", \"maybe\")\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.student_says(\n",
        "            Text(\"Too meta...\"),\n",
        "            target_mode=\"sassy\",\n",
        "            index=2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class DescribeDerivative(Scene):\n",
        "    zoom_in_frame = False\n",
        "    z = 1\n",
        "    z_str = \"{1}\"\n",
        "    fz_str = \"1\"\n",
        "    fpz_str = \"2\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Add plane\n",
        "        plane = ComplexPlane((-4, 4), (-2, 2))\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        plane.add_coordinate_labels(font_size=18)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Add function labels\n",
        "        z_str = self.z_str\n",
        "        fz_str = self.fz_str\n",
        "        fpz_str = self.fpz_str\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"z\": GREY_A,\n",
        "                z_str: YELLOW,\n",
        "            },\n",
        "            \"isolate\": [\"f\", \"(\", \")\", \"=\", z_str, fz_str, fpz_str],\n",
        "        }\n",
        "        f_label = OldTex(\"f(z) = z^2\", **kw)\n",
        "        df_label = OldTex(\"f'(z) = 2z\", **kw)\n",
        "        labels = VGroup(f_label, df_label)\n",
        "        labels.arrange(DOWN)\n",
        "        labels.to_corner(UL)\n",
        "        labels.set_stroke(BLACK, 5, background=True)\n",
        "        corner_rect = SurroundingRectangle(labels, buff=0.25)\n",
        "        corner_rect.set_stroke(WHITE, 2)\n",
        "        corner_rect.set_fill(BLACK, 0.9)\n",
        "        corner_group = VGroup(corner_rect, *labels)\n",
        "        corner_group.to_corner(UL, buff=0)\n",
        "\n",
        "        df_question = Text(\"Derivative?\")\n",
        "        df_question.set_stroke(BLACK, 5, background=True)\n",
        "        df_arrow = Vector(LEFT)\n",
        "        df_arrow.next_to(f_label, RIGHT, SMALL_BUFF)\n",
        "        df_question.next_to(df_arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(corner_rect, f_label)\n",
        "        self.play(\n",
        "            FadeIn(df_question, 0.2 * RIGHT),\n",
        "            ShowCreation(df_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(df_label, shift=0.5 * DOWN),\n",
        "            FadeOut(df_question),\n",
        "            Uncreate(df_arrow),\n",
        "        )\n",
        "\n",
        "        # Add dots\n",
        "        density = 10\n",
        "        dot_radius = 0.025\n",
        "        dots = DotCloud([\n",
        "            plane.c2p(x, y)\n",
        "            for x in np.arange(-3.7, 3.7, 1.0 / density)\n",
        "            for y in np.arange(-2.0, 2.1, 1.0 / density)\n",
        "        ])\n",
        "        dots.set_radius(dot_radius)\n",
        "        dots.set_color(GREY_B)\n",
        "        dots.set_gloss(0.2)\n",
        "        dots.set_opacity(0.5)\n",
        "        dots.add_updater(lambda m: m)\n",
        "\n",
        "        epsilon = 5e-3\n",
        "        tiny_dots = DotCloud([\n",
        "            plane.n2p(self.z + epsilon * complex(x, y))\n",
        "            for x in np.arange(-20, 20)\n",
        "            for y in np.arange(-10, 10)\n",
        "        ])\n",
        "        tiny_dots.set_radius(dot_radius * 15 * epsilon)\n",
        "        tiny_dots.set_opacity(0.75)\n",
        "        tiny_dots.set_color_by_gradient(YELLOW, BLUE)\n",
        "        tiny_dots.set_gloss(0.2)\n",
        "\n",
        "        self.add(dots, corner_group)\n",
        "        self.play(ShowCreation(dots), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Show function evaluation\n",
        "        ex_labels = VGroup(\n",
        "            OldTex(f\"f({z_str}) = {fz_str}\", **kw),\n",
        "            OldTex(f\"f'({z_str}) = {fpz_str}\", **kw),\n",
        "        )\n",
        "        for ex_label, gen_label in zip(ex_labels, labels):\n",
        "            ex_label.next_to(gen_label, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        ex_labels[0].align_to(ex_labels[1], LEFT)\n",
        "\n",
        "        corner_rect.generate_target()\n",
        "        corner_rect.target.set_width(\n",
        "            VGroup(ex_labels, labels).get_width() + 0.5,\n",
        "            about_edge=LEFT,\n",
        "            stretch=True,\n",
        "        )\n",
        "\n",
        "        self.add(*corner_group)\n",
        "        self.play(\n",
        "            MoveToTarget(corner_rect),\n",
        "            FadeIn(ex_labels),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Apply function\n",
        "        fade_anims = []\n",
        "        if self.zoom_in_frame:\n",
        "            rect = self.camera.frame\n",
        "            plane.generate_target()\n",
        "            fade_anims = [\n",
        "                ApplyMethod(dots.set_opacity, 0, rate_func=squish_rate_func(smooth, 0.5, 1.0)),\n",
        "                plane.animate.set_stroke(width=0.25),\n",
        "            ]\n",
        "        else:\n",
        "            rect = ScreenRectangle()\n",
        "            rect.set_height(FRAME_HEIGHT)\n",
        "            rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(\n",
        "            rect.animate.replace(tiny_dots, 1).move_to(plane.n2p(self.z)),\n",
        "            *fade_anims,\n",
        "            FadeIn(tiny_dots),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # def func(p):\n",
        "        #     z = plane.p2n(p)\n",
        "        #     return plane.n2p(z**2)\n",
        "\n",
        "        def homotopy(x, y, z, t):\n",
        "            z = plane.p2n([x, y, z])\n",
        "            return plane.n2p(z**(1 + t))\n",
        "\n",
        "        rc = rect.get_center()\n",
        "        path = ParametricCurve(lambda t: homotopy(*rc, t))\n",
        "\n",
        "        self.play(\n",
        "            Homotopy(homotopy, dots),\n",
        "            Homotopy(homotopy, tiny_dots),\n",
        "            MoveAlongPath(rect, path),\n",
        "            # dots.animate.apply_function(func),\n",
        "            # tiny_dots.animate.apply_function(func),\n",
        "            # rect.animate.move_to(func(rect.get_center())),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DescribeDerivativeInnerFrame(DescribeDerivative):\n",
        "    zoom_in_frame = True\n",
        "\n",
        "\n",
        "class DescribeDerivativeIExample(DescribeDerivative):\n",
        "    z = 1j\n",
        "    z_str = \"{i}\"\n",
        "    fz_str = \"-1\"\n",
        "    fpz_str = \"2i\"\n",
        "\n",
        "\n",
        "class DescribeDerivativeIExampleInnerFrame(DescribeDerivativeIExample):\n",
        "    zoom_in_frame = True\n",
        "\n",
        "\n",
        "class LooksLikeTwoMult(Scene):\n",
        "    const = \"2\"\n",
        "\n",
        "    def construct(self):\n",
        "        tex = OldTexText(f\"Looks like $z \\\\rightarrow {self.const}\\\\cdot z$\")\n",
        "        tex.set_stroke(BLACK, 5, background=True)\n",
        "        self.play(FadeIn(tex, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LooksLikeTwoiMult(LooksLikeTwoMult):\n",
        "    const = \"2i\"\n",
        "\n",
        "\n",
        "class Cycles(FixedPoints):\n",
        "    def construct(self):\n",
        "        # Set the stage\n",
        "        iter_label = self.add_labels()\n",
        "        rule, iterations = iter_label\n",
        "        self.remove(rule)\n",
        "        iterations.to_edge(UP)\n",
        "\n",
        "        plane = self.add_plane()\n",
        "        z0_dot, z0_label = self.add_z_dot(complex(-1.1, 0.6), \"z_0\")\n",
        "        z1_dot, z1_label = self.add_z_dot(complex(0.2, -0.5), \"z_1\")\n",
        "        z1_label.next_to(z1_dot, UR, SMALL_BUFF)\n",
        "        z_dots = VGroup(z0_dot, z1_dot)\n",
        "        z_labels = VGroup(z0_label, z1_label)\n",
        "\n",
        "        # Ask question\n",
        "        question = OldTexText(\"When does $z$ cycle?\")\n",
        "        question.next_to(plane, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        kw = {\"path_arc\": PI / 3, \"buff\": 0.1}\n",
        "        arrows = VGroup(\n",
        "            Arrow(z0_dot, z1_dot, **kw),\n",
        "            Arrow(z1_dot, z0_dot, **kw),\n",
        "        )\n",
        "        arrows.set_stroke(opacity=0.75)\n",
        "        z_dot = z0_dot.copy()\n",
        "        z_dot.set_color(YELLOW)\n",
        "\n",
        "        self.add(question)\n",
        "        self.play(\n",
        "            ShowCreation(arrows[0]),\n",
        "            TransformFromCopy(z0_dot, z1_dot, path_arc=-PI / 3),\n",
        "            TransformFromCopy(z0_label, z1_label, path_arc=-PI / 3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(z1_dot, z_dot, path_arc=-PI / 3),\n",
        "            ShowCreation(arrows[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(1, 5):\n",
        "            self.play(z_dot.move_to, z_dots[n % 2], path_arc=PI / 3)\n",
        "            self.wait()\n",
        "\n",
        "        # Show formula\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\"z\": BLUE},\n",
        "            \"isolate\": [\"f\"],\n",
        "        }\n",
        "\n",
        "        f2_equation = OldTex(\"f(f(z)) = z\", **kw)\n",
        "        f2_equation.next_to(plane, RIGHT, MED_LARGE_BUFF, aligned_edge=UP)\n",
        "\n",
        "        julia_fractal = JuliaFractal(plane)\n",
        "        julia_fractal.set_c(-0.18 + 0.77j)\n",
        "\n",
        "        z2c = OldTex(\"f(z) = z^2 + c\", **kw)\n",
        "        z2c.next_to(f2_equation, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(f2_equation, 0.25 * DOWN))\n",
        "        self.wait()\n",
        "        self.add(julia_fractal, plane, z_dots, z_dot, z_labels, arrows, z_dot)\n",
        "        julia_fractal.set_opacity(0)\n",
        "        self.play(\n",
        "            julia_fractal.animate.set_opacity(0.75),\n",
        "            Write(z2c),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Example with z^2 + c\n",
        "        julia_f2_eqs = VGroup(\n",
        "            OldTex(\"(z^2 + c)^2 + c = z\", **kw),\n",
        "            OldTex(\"z^4 + 2cz^2 -z + c^2 + c = 0\", **kw),\n",
        "        )\n",
        "        julia_f2_eqs.arrange(DOWN, buff=0.7, aligned_edge=LEFT)\n",
        "        julia_f2_eqs.next_to(f2_equation, DOWN, buff=1.0, aligned_edge=LEFT)\n",
        "\n",
        "        eq_arrows = VGroup(\n",
        "            Arrow(f2_equation.get_bottom(), julia_f2_eqs.get_top()),\n",
        "            Arrow(z2c.get_bottom(), julia_f2_eqs.get_top()),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            *map(ShowCreation, eq_arrows),\n",
        "            FadeIn(julia_f2_eqs[0], 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                julia_f2_eqs[0].copy(),\n",
        "                julia_f2_eqs[1]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add fixed_points\n",
        "        fixed_dots = VGroup(\n",
        "            Dot(plane.c2p(0.8, -0.5), color=GREY_A),\n",
        "            Dot(plane.c2p(-0.9, -0.6), color=GREY_A),\n",
        "        )\n",
        "        arrow_loops = VGroup(*(\n",
        "            self.get_arrow_loop(dot)\n",
        "            for dot in fixed_dots\n",
        "        ))\n",
        "\n",
        "        for dot, loop in zip(fixed_dots, arrow_loops):\n",
        "            loop.set_color(GREY_B)\n",
        "            self.play(\n",
        "                FadeIn(dot, scale=0.3),\n",
        "                ShowCreation(loop),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                eq_arrows, *julia_f2_eqs,\n",
        "                *fixed_dots, *arrow_loops,\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        # N cycles\n",
        "        fn_eq = OldTex(\n",
        "            \"f(f(\\\\cdots f(z) \\\\cdots)) = z\",\n",
        "            **kw\n",
        "        )\n",
        "        fn_eq.move_to(f2_equation, LEFT)\n",
        "        fn_eq.shift(SMALL_BUFF * DOWN)\n",
        "        brace = Brace(\n",
        "            fn_eq[:fn_eq.index_of_part_by_tex(\"z\")],\n",
        "            DOWN\n",
        "        )\n",
        "        brace_tex = brace.get_tex(\"n \\\\text{ times}\", buff=SMALL_BUFF)\n",
        "        brace_tex.scale(0.7, about_edge=UP)\n",
        "\n",
        "        for z in [-0.2 + 0.6j, 1.1 - 0.6j, 0.4 + 0.2j]:\n",
        "            dot = z0_dot.copy()\n",
        "            dot.set_fill(BLUE_D)\n",
        "            dot.move_to(plane.n2p(z))\n",
        "            z_dots.add(dot)\n",
        "\n",
        "        n_arrows = VGroup()\n",
        "        for d1, d2 in adjacent_pairs(z_dots):\n",
        "            arrow = Arrow(d1, d2, buff=0.1, path_arc=PI / 8)\n",
        "            arrow.set_stroke(WHITE, opacity=0.7)\n",
        "            n_arrows.add(arrow)\n",
        "\n",
        "        dot_anims = []\n",
        "        n = len(z_dots)\n",
        "        for k in range(1, n + 1):\n",
        "            dot_anims.append(\n",
        "                ApplyMethod(z_dot.move_to, z_dots[k % n], path_arc=PI / 8)\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(f2_equation, fn_eq),\n",
        "            FadeOut(z2c),\n",
        "            ReplacementTransform(arrows, n_arrows),\n",
        "            *map(GrowFromCenter, z_dots[2:])\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_tex, SMALL_BUFF * DOWN),\n",
        "            Succession(*dot_anims, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about how many solutions\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.to_corner(DR)\n",
        "        z2c.next_to(fn_eq, UP, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                morty, \"How many solutions?\",\n",
        "                bubble_config={\"height\": 2, \"width\": 4}\n",
        "            ),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(z2c),\n",
        "            RemovePiCreatureBubble(\n",
        "                morty,\n",
        "                target_mode=\"pondering\",\n",
        "                look_at=z2c,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 1,000,000-cycles\n",
        "        million = Integer(1e6, font_size=36)\n",
        "        million.next_to(brace, DOWN)\n",
        "        million.set_value(0)\n",
        "        mega_poly = OldTex(\n",
        "            \"z^{2^{1{,}000{,}000}} +\",\n",
        "            \"\\\\cdots \\\\text{(nightmare)} \\\\cdots\",\n",
        "            \"= 0\",\n",
        "            **kw\n",
        "        )\n",
        "        mega_poly.next_to(million, DOWN, buff=0.75)\n",
        "        mega_poly.align_to(fn_eq, LEFT)\n",
        "\n",
        "        expr = self.show_composition(million, morty, **kw)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(million, 1e6, run_time=2),\n",
        "            VFadeIn(million),\n",
        "            FadeOut(brace_tex),\n",
        "            morty.change(\"raise_right_hand\", fn_eq)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeOut(expr),\n",
        "            Write(mega_poly),\n",
        "            morty.animate.set_height(1.8, about_edge=DR).change(\"horrified\", mega_poly),\n",
        "        )\n",
        "        self.play(morty.animate.look_at(mega_poly.get_right()))\n",
        "        self.wait()\n",
        "\n",
        "        # Show \"million\" dots\n",
        "        N = 5000\n",
        "        points = np.random.random((N, 3))\n",
        "        points[:, 2] = 0\n",
        "        dots = DotCloud(points, radius=0)\n",
        "        dots.replace(plane)\n",
        "        dots.set_radius(0.01)\n",
        "        dots.set_color(GREY_B)\n",
        "        dots.set_opacity(1)\n",
        "        dots.add_updater(lambda m: m)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(z_labels),\n",
        "            FadeOut(z_dots),\n",
        "            FadeOut(n_arrows),\n",
        "            morty.change(\"erm\", dots),\n",
        "            ShowCreation(dots, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dots),\n",
        "            FadeOut(mega_poly),\n",
        "            FadeOut(morty),\n",
        "            FadeOut(z2c),\n",
        "        )\n",
        "\n",
        "        # Rational map\n",
        "        rational = OldTex(\"f(z) = {A(z) \\\\over B(z)}\", **kw)\n",
        "        rational.next_to(million, DOWN, LARGE_BUFF)\n",
        "        rational.align_to(fn_eq, LEFT)\n",
        "\n",
        "        self.play(FadeIn(rational))\n",
        "        for arrow, dot in zip(n_arrows, [*z_dots[1:], z_dots[0]]):\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                z_dot.animate.move_to(dot),\n",
        "                path_arc=PI / 6,\n",
        "            )\n",
        "            self.add(dot, z_dot)\n",
        "\n",
        "        # Ask about attracting cycle\n",
        "        new_question = Text(\"When is a cycle attracting?\")\n",
        "        new_question.get_part_by_text(\"attracting\").set_color(YELLOW)\n",
        "        new_question.next_to(question, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(new_question, run_time=1),\n",
        "            fn_eq.animate.shift(0.5 * DOWN),\n",
        "            FadeOut(brace),\n",
        "            FadeOut(million),\n",
        "        )\n",
        "\n",
        "        circle = Circle(radius=0.5)\n",
        "        circle.set_stroke(YELLOW, 1, 1)\n",
        "        circle.set_fill(YELLOW, 0.25)\n",
        "        h_tracker = ValueTracker(1.0)\n",
        "        circle.add_updater(lambda m: m.set_height(h_tracker.get_value()))\n",
        "        circle.add_updater(lambda m: m.move_to(z_dot))\n",
        "\n",
        "        multipliers = [0.9, 0.9, 1.2, 0.5, 1.1]\n",
        "\n",
        "        self.add(circle, z_dot)\n",
        "        self.play(GrowFromCenter(circle))\n",
        "\n",
        "        for n in range(3):\n",
        "            for mult, dot in zip(multipliers, [*z_dots[1:], z_dots[0]]):\n",
        "                self.play(\n",
        "                    ApplyMethod(z_dot.move_to, dot, path_arc=PI / 6),\n",
        "                    h_tracker.animate.set_value(h_tracker.get_value() * mult),\n",
        "                )\n",
        "\n",
        "        # Possibly add on a bit for Fatou's theorem?\n",
        "        theorem = OldTexText(\n",
        "            \"Theorem (Fatou 1919): If $f(z)$ has an\\\\\\\\\",\n",
        "            \"attracting cycle, then at least one solution\\\\\\\\\",\n",
        "            \"to $f'(z) = 0$ will fall into it.\",\n",
        "            font_size=36,\n",
        "        )\n",
        "        theorem.arrange(DOWN, buff=0.15, aligned_edge=LEFT)\n",
        "        theorem.next_to(fn_eq, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            rational.animate.set_height(0.8).next_to(fn_eq, RIGHT, LARGE_BUFF),\n",
        "            FadeIn(theorem),\n",
        "        )\n",
        "\n",
        "    def show_composition(self, ref_mob, morty, **kwargs):\n",
        "        tex = \"z^2 + c\"\n",
        "        polys = VGroup(OldTex(tex, **kwargs))\n",
        "        for n in range(20):\n",
        "            new_tex_parts = [\"\\\\left(\", tex, \"\\\\right)^2 + c\"]\n",
        "            polys.add(OldTex(*new_tex_parts))\n",
        "            if n < 3:\n",
        "                tex = \"\".join(new_tex_parts)\n",
        "\n",
        "        for poly in polys:\n",
        "            poly.set_max_width(5)\n",
        "            poly.next_to(ref_mob, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        degree = VGroup(Text(\"Degree: \"), Integer(2))\n",
        "        degree.arrange(RIGHT)\n",
        "        degree.next_to(polys, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        curr_poly = polys[0]\n",
        "        self.play(\n",
        "            FadeIn(curr_poly),\n",
        "            FadeIn(degree),\n",
        "            morty.change(\"tease\", curr_poly),\n",
        "        )\n",
        "        for n, poly in enumerate(polys[1:]):\n",
        "            anims = []\n",
        "            if n == 4:\n",
        "                anims.append(morty.change(\"erm\"))\n",
        "            self.play(\n",
        "                curr_poly.animate.replace(poly[1]),\n",
        "                FadeIn(poly[::2]),\n",
        "                UpdateFromAlphaFunc(\n",
        "                    degree, lambda m, a: m[1].set_value(\n",
        "                        (2**(n + 1) if a < 0.5 else 2**(n + 2))\n",
        "                    )\n",
        "                ),\n",
        "                *anims,\n",
        "                run_time=(1 if n < 5 else 0.25)\n",
        "            )\n",
        "            poly.replace_submobject(1, curr_poly)\n",
        "            self.add(poly)\n",
        "            curr_poly = poly\n",
        "        self.wait()\n",
        "        self.play(FadeOut(degree))\n",
        "        return poly\n",
        "\n",
        "\n",
        "class TwoToMillionPoints(Scene):\n",
        "    c = -0.18 + 0.77j\n",
        "    plane_height = 7\n",
        "\n",
        "    def construct(self):\n",
        "        plane, julia_fractal = self.get_plane_and_fractal()\n",
        "\n",
        "        words = OldTexText(\"$\\\\approx 2^{1{,}000{,}000}$ solutions!\")\n",
        "        words.set_stroke(BLACK, 8, background=True)\n",
        "        words.move_to(plane, UL)\n",
        "        words.shift(MED_SMALL_BUFF * DR)\n",
        "\n",
        "        points = self.get_julia_set_points(plane, 100000, 1000)\n",
        "        dots = DotCloud(points)\n",
        "        dots.set_color(YELLOW)\n",
        "        dots.set_opacity(1)\n",
        "        dots.set_radius(0.025)\n",
        "        dots.add_updater(lambda m: m)\n",
        "        dots.make_3d()\n",
        "\n",
        "        self.add(julia_fractal, plane, words)\n",
        "        self.play(ShowCreation(dots, run_time=10))\n",
        "\n",
        "    def get_plane_and_fractal(self):\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.set_height(self.plane_height)\n",
        "        fractal = JuliaFractal(plane)\n",
        "        fractal.set_c(self.c)\n",
        "        return plane, fractal\n",
        "\n",
        "    def get_julia_set_points(self, plane, n_points, n_steps):\n",
        "        values = np.array([\n",
        "            complex(math.cos(x), math.sin(x))\n",
        "            for x in np.linspace(0, TAU, n_points)\n",
        "        ])\n",
        "\n",
        "        c = self.c\n",
        "        for n in range(n_steps):\n",
        "            units = -1 + 2 * np.random.randint(0, 2, len(values))\n",
        "            values[:] = (units * np.sqrt(values[:])) - c\n",
        "        values += c\n",
        "\n",
        "        return np.array(list(map(plane.n2p, values)))\n",
        "\n",
        "\n",
        "class CyclesHaveSolutions(Scene):\n",
        "    def construct(self):\n",
        "        text = VGroup(\n",
        "            OldTex(\n",
        "                \"f^n(z) = z \\\\text{ has solutions}\",\n",
        "                tex_to_color_map={\"z\": BLUE},\n",
        "            ),\n",
        "            OldTex(\"\\\\sim D^n \\\\text{ of them...}\"),\n",
        "        )\n",
        "        text.arrange(DOWN)\n",
        "\n",
        "        for part in text:\n",
        "            self.play(FadeIn(part))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MandelbrotFunctions(Scene):\n",
        "    def construct(self):\n",
        "        kw = {\"tex_to_color_map\": {\"c\": YELLOW}}\n",
        "        group = VGroup(\n",
        "            OldTex(\"f(z) = z^2 + c\", **kw),\n",
        "            OldTex(\"f'(z) = 2z\"),\n",
        "        )\n",
        "        group.arrange(DOWN, aligned_edge=LEFT)\n",
        "        self.add(group)\n",
        "\n",
        "\n",
        "class AmbientNewtonRepetition(RepeatedNewton):\n",
        "    coefs = [-4, 0, -3, 0, 1]\n",
        "    show_fractal_background = True\n",
        "    show_coloring = False\n",
        "    n_steps = 20\n",
        "    dot_density = 10.0\n",
        "    points_scalar = 2.0\n",
        "    dots_config = {\n",
        "        \"radius\": 0.025,\n",
        "        \"color\": GREY_A,\n",
        "        \"gloss\": 0.4,\n",
        "        \"shadow\": 0.1,\n",
        "        \"opacity\": 0.5,\n",
        "    }\n",
        "\n",
        "\n",
        "class AmbientNewtonBoundary(AmbientNewtonRepetition):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        fractal = self.get_fractal()\n",
        "        self.remove(self.plane)\n",
        "\n",
        "        fractal.set_julia_highlight(1e-4)\n",
        "        fractal.set_colors(5 * [WHITE])\n",
        "        self.play(GrowFromPoint(\n",
        "            fractal,\n",
        "            fractal.get_corner(UL),\n",
        "            run_time=5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CyclicAttractor(RepeatedNewton):\n",
        "    coefs = [2, -2, 0, 1]\n",
        "    n_steps = 20\n",
        "    show_coloring = False\n",
        "    cluster_radius = 0.5\n",
        "\n",
        "    def add_plane(self):\n",
        "        super().add_plane()\n",
        "        self.plane.axes.set_stroke(GREY_B, 1)\n",
        "        self.plane.scale(1.7)\n",
        "\n",
        "    def add_labels(self):\n",
        "        super().add_labels()\n",
        "        eq = self.corner_group[1]\n",
        "        self.play(FlashAround(eq, run_time=3))\n",
        "\n",
        "    def get_original_points(self):\n",
        "        return [\n",
        "            (r * np.cos(theta), r * np.sin(theta), 0)\n",
        "            for r in np.linspace(0, self.cluster_radius, 10)\n",
        "            for theta in np.linspace(0, TAU, int(50 * r)) + TAU * np.random.random()\n",
        "        ]\n",
        "\n",
        "\n",
        "class CyclicAttractorSmallRadius(CyclicAttractor):\n",
        "    cluster_radius = 0.25\n",
        "    colors = ROOT_COLORS_DEEP[0::2]\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "\n",
        "        fractal = NewtonFractal(\n",
        "            self.plane,\n",
        "            coefs=self.coefs,\n",
        "            colors=self.colors,\n",
        "            black_for_cycles=True,\n",
        "        )\n",
        "        dots = VGroup(*(\n",
        "            Dot(rd.get_center()) for rd in self.root_dots\n",
        "        ))\n",
        "        dots.set_stroke(BLACK, 3)\n",
        "        dots.set_fill(opacity=0)\n",
        "\n",
        "        self.add(fractal, *self.mobjects, dots)\n",
        "        self.play(\n",
        "            FadeIn(fractal),\n",
        "            self.plane.animate.fade(0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CyclicExercise(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Exercise 2: If $f(z) = z - {z^3 - 2z + 2 \\\\over 3z^2 - 2}$,\\\\\\\\\",\n",
        "            \"and $g(z) = f(f(z))$, confirm that $|g'(0)| < 1$.\"\n",
        "        )\n",
        "        words[1].shift(SMALL_BUFF * DOWN)\n",
        "        box = SurroundingRectangle(words, buff=0.45)\n",
        "        box.set_stroke(WHITE, 2)\n",
        "        box.set_fill(BLACK, 1)\n",
        "        group = VGroup(box, words)\n",
        "        group.to_edge(UP, buff=0)\n",
        "\n",
        "        hint = OldTexText(\n",
        "            \"Hint: Don't expand out $g(z)$. Use\\\\\\\\\",\n",
        "            \"the chain rule: $g'(0) = f'(f(0))f'(0)$\"\n",
        "        )\n",
        "        hint.scale(0.8)\n",
        "        hint.set_color(GREY_A)\n",
        "        hint_box = SurroundingRectangle(hint, buff=0.25)\n",
        "        hint_box.match_style(box)\n",
        "        hint_group = VGroup(hint_box, hint)\n",
        "        hint_group.next_to(group, DOWN, buff=0)\n",
        "\n",
        "        self.add(group)\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(hint_group))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskHowOftenThisHappensAlt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"How often does\\\\\\\\this happen?\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            },\n",
        "            index=0,\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\", 3 * UR),\n",
        "            self.change_students(\n",
        "                \"raise_left_hand\", \"pondering\", \"pondering\",\n",
        "                look_at=3 * UR,\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"raise_left_hand\", \"erm\", \"erm\",\n",
        "            look_at=3 * UR,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.teacher.change(\"tease\", 3 * UR))\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"pondering\", \"thinking\",\n",
        "            look_at=3 * UR,\n",
        "        )\n",
        "        self.wait(8)\n",
        "        return\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                self.teacher, \"You'll like this\",\n",
        "                target_mode=\"tease\",\n",
        "                run_time=1,\n",
        "            ),\n",
        "            self.students[1].change(\"thinking\", self.teacher.eyes),\n",
        "            self.students[2].change(\"thinking\", self.teacher.eyes),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WhatDoesBlackMean(Scene):\n",
        "    def construct(self):\n",
        "        lhs = OldTexText(\"$z_n$ never gets\\\\\\\\near a root\")\n",
        "        rhs = OldTexText(\"$\\\\Rightarrow$ \", \"Black \", )\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "        words = VGroup(lhs, rhs)\n",
        "        words.next_to(ORIGIN, UR, MED_LARGE_BUFF)\n",
        "        words.to_edge(RIGHT)\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        # lhs[0].set_color(BLACK)\n",
        "        # lhs[0].set_stroke(width=0)\n",
        "\n",
        "        arrow = Arrow(ORIGIN, words.get_left(), buff=0.1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(lhs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rhs))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PlayWithRootsSeekingCycles(ThreeRootFractal):\n",
        "    coefs = [2, -2, 0, 1]\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        self.fractal.uniforms[\"black_for_cycles\"] = 1.0\n",
        "\n",
        "\n",
        "class ShowCenterOfMassPoint(PlayWithRootsSeekingCycles):\n",
        "    display_root_values = True\n",
        "    only_center = False\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "\n",
        "        mean_dot = glow_dot(ORIGIN)\n",
        "        mean_dot.add_updater(lambda m: m.move_to(\n",
        "            sum([rd.get_center() for rd in self.root_dots]) / 3\n",
        "        ))\n",
        "        self.add(mean_dot)\n",
        "\n",
        "        if self.only_center:\n",
        "            mean_dot.set_opacity(0)\n",
        "            self.fractal.replace(mean_dot, stretch=True)\n",
        "            self.fractal.add_updater(lambda m: m.move_to(mean_dot))\n",
        "            window = Square()\n",
        "            window.set_stroke(WHITE, 1)\n",
        "            window.set_fill(BLACK, 0)\n",
        "            window.replace(self.fractal, stretch=True)\n",
        "            window.add_updater(lambda m: m.move_to(mean_dot))\n",
        "            self.add(window)\n",
        "\n",
        "        mean_label = OldTex(\"(r_1 + r_2 + r_3) / 3\", font_size=24)\n",
        "        mean_label.set_stroke(BLACK, 2, background=True)\n",
        "        mean_label.add_updater(lambda m: m.next_to(mean_dot, UP, buff=0.1))\n",
        "        self.add(mean_label)\n",
        "\n",
        "        circle = Circle(radius=2)\n",
        "        circle.rotate(PI)\n",
        "        circle.stretch(0.9)\n",
        "        circle.move_to(self.root_dots, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveAlongPath(\n",
        "                self.root_dots[2], circle,\n",
        "                rate_func=linear,\n",
        "                run_time=20\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            self.root_dots[2].animate.move_to(self.plane.n2p(-3)),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowCenterOfMassPointFocusIn(ShowCenterOfMassPoint):\n",
        "    only_center = True\n",
        "\n",
        "\n",
        "class CenterOfMassStatement(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"If there's an attracting cycle, the seed\\\\\\\\\",\n",
        "            \"$z_0 = (r_1 + r_2 + r_3) / 3$ will fall into it.\"\n",
        "        )\n",
        "        words.set_stroke(BLACK, 8, background=True)\n",
        "        words.to_corner(UL)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GenerateCubicParameterPlot(Scene):\n",
        "    colors = ROOT_COLORS_DEEP[0::2]\n",
        "\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        colors = self.colors\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"\\\\lambda\": colors[2],\n",
        "            }\n",
        "        }\n",
        "        title = OldTex(\n",
        "            \"z_{n+1} = z_n - {P(z_n) \\\\over P'(z_n)} \\\\qquad\\\\qquad \",\n",
        "            \"P(z) = (z - 1)(z + 1)(z - \\\\lambda)\",\n",
        "            font_size=30,\n",
        "            **kw\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        # Planes\n",
        "        planes = VGroup(*(\n",
        "            ComplexPlane(\n",
        "                (-2, 2), (-2, 2),\n",
        "                background_line_style={\n",
        "                    \"stroke_color\": GREY_B,\n",
        "                    \"stroke_opacity\": 0.5,\n",
        "                },\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ))\n",
        "        for plane, vect in zip(planes, [DL, DR]):\n",
        "            plane.add_coordinate_labels(font_size=18)\n",
        "            plane.set_height(5)\n",
        "            plane.to_corner(vect, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        root_dots = VGroup(*(\n",
        "            Dot(planes[0].n2p(z), color=color)\n",
        "            for color, z in zip(colors, [-1, 1, 1j])\n",
        "        ))\n",
        "        root_dots.set_stroke(BLACK, 2)\n",
        "\n",
        "        lambda_label = OldTex(\"\\\\lambda\", font_size=36)\n",
        "        lambda_label.set_color(interpolate_color(colors[2], WHITE, 0.75))\n",
        "        lambda_label.set_stroke(BLACK, 3, background=True)\n",
        "        lambda_label.add_updater(lambda m: m.next_to(\n",
        "            root_dots[2], UR, buff=SMALL_BUFF,\n",
        "        ))\n",
        "\n",
        "        # Fractals\n",
        "        left_fractal = NewtonFractal(\n",
        "            planes[0], coefs=[-1, 0, 0, 1],\n",
        "            colors=colors,\n",
        "            black_for_cycles=True,\n",
        "        )\n",
        "        left_fractal.add_updater(lambda m: m.set_roots([\n",
        "            planes[0].p2n(rd.get_center())\n",
        "            for rd in root_dots\n",
        "        ]))\n",
        "\n",
        "        right_fractal = MetaNewtonFractal(\n",
        "            planes[1],\n",
        "            colors=colors,\n",
        "            fixed_roots=[-1, 1],\n",
        "        )\n",
        "        row_meta_fractal = right_fractal.deepcopy()\n",
        "        col_meta_fractal = right_fractal.deepcopy()\n",
        "\n",
        "        self.add(left_fractal, planes[0], planes, root_dots, lambda_label)\n",
        "\n",
        "        # Plane titles\n",
        "        plane_titles = VGroup(\n",
        "            OldTexText(\"Pixel $\\\\leftrightarrow z_0$\"),\n",
        "            OldTexText(\"Pixel $\\\\leftrightarrow$ \", \"$\\\\lambda$\"),\n",
        "        )\n",
        "        plane_titles[1][-1].set_color(colors[2])\n",
        "        for plane_title, plane in zip(plane_titles, planes):\n",
        "            plane_title.next_to(plane, UP, MED_SMALL_BUFF)\n",
        "        plane_titles[0].align_to(plane_titles[1], UP)\n",
        "\n",
        "        self.add(plane_titles[0])\n",
        "\n",
        "        # Show left plane\n",
        "        pins = VGroup()\n",
        "        for rd in root_dots[:2]:\n",
        "            pin = SVGMobject(\"push_pin\")\n",
        "            pin.set_fill(GREY_C)\n",
        "            pin.set_stroke(width=0)\n",
        "            pin.set_gloss(0.5)\n",
        "            pin.set_height(0.3)\n",
        "            pin.rotate(10 * DEGREES)\n",
        "            pin.move_to(rd.get_center(), DR)\n",
        "            pins.add(pin)\n",
        "            self.play(\n",
        "                FadeIn(pin, 0.25 * DR),\n",
        "                FlashAround(rd),\n",
        "            )\n",
        "\n",
        "        self.wait()\n",
        "        circle = Circle()\n",
        "        circle.scale(0.5)\n",
        "        circle.rotate(PI / 2)\n",
        "        circle.move_to(root_dots[2].get_center(), UP)\n",
        "\n",
        "        self.play(MoveAlongPath(root_dots[2], circle, run_time=5))\n",
        "        self.play(\n",
        "            root_dots[2].animate.move_to(planes[0].get_corner(UL)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Center of mass dot\n",
        "        com_dot = Dot()\n",
        "        com_dot.set_fill(opacity=0)\n",
        "        com_dot.set_stroke(YELLOW, 3)\n",
        "        com_dot.add_updater(lambda m: m.move_to(\n",
        "            np.array([rd.get_center() for rd in root_dots]).mean(0)\n",
        "        ))\n",
        "        self.play(FadeIn(com_dot, scale=0.5), FadeOut(pins))\n",
        "        self.wait()\n",
        "\n",
        "        # Right plane\n",
        "        self.play(Write(plane_titles[1]))\n",
        "        self.wait()\n",
        "\n",
        "        # Show filling process\n",
        "        step = 0.1\n",
        "        square = Square()\n",
        "        square.set_stroke(WHITE, 2)\n",
        "        arrow = Arrow(LEFT, RIGHT, stroke_width=3)\n",
        "        self.add(row_meta_fractal, col_meta_fractal, planes[1])\n",
        "        self.add(square, arrow)\n",
        "\n",
        "        x_range = np.arange(-2, 2 + step, step)\n",
        "        y_range = np.arange(2, -2, -step)\n",
        "\n",
        "        thin_height = plane.get_y_unit_size() * step\n",
        "        col_meta_fractal.set_height(thin_height)\n",
        "        square.set_height(thin_height)\n",
        "\n",
        "        epsilon = 1e-6\n",
        "        for y, back in zip(y_range, it.cycle([False, True])):\n",
        "            height = max(epsilon, plane.get_y_unit_size() * abs(2 - y))\n",
        "            row_meta_fractal.set_height(height, stretch=True)\n",
        "            row_meta_fractal.move_to(planes[1], UP)\n",
        "            x0 = (2 if back else -2)\n",
        "            for x in (x_range[::-1] if back else x_range):\n",
        "                width = max(epsilon, planes[1].get_x_unit_size() * abs(x - x0))\n",
        "                col_meta_fractal.set_width(width, stretch=True)\n",
        "                col_meta_fractal.next_to(row_meta_fractal, DOWN, buff=0)\n",
        "                col_meta_fractal.align_to(row_meta_fractal, RIGHT if back else LEFT)\n",
        "\n",
        "                root_dots[2].move_to(planes[0].c2p(x, y))\n",
        "                square.move_to(\n",
        "                    col_meta_fractal, DOWN + (LEFT if back else RIGHT)\n",
        "                )\n",
        "                self.update_mobjects(0)\n",
        "                arrow.put_start_and_end_on(\n",
        "                    com_dot.get_center(),\n",
        "                    square.get_center(),\n",
        "                )\n",
        "                self.wait(1 / 15)\n",
        "\n",
        "        self.play(FadeOut(arrow), FadeOut(square))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in to meta fractal\n",
        "        frame = self.camera.frame\n",
        "        self.play(\n",
        "            frame.animate.replace(planes[1], 1),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Z0RuleLabel(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTex(\"z_0 = (r_1 + r_2 + r_3) / 3\")\n",
        "        self.add(label)\n",
        "\n",
        "\n",
        "class WhyFractals(Scene):\n",
        "    def construct(self):\n",
        "        words = Text(\"Why fractals?\")\n",
        "        words.set_stroke(BLACK, 5, background=True)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SmallCircleProperty(Scene):\n",
        "    def construct(self):\n",
        "        # Titles\n",
        "        rule = OldTexText(\n",
        "            \"For any rational map, color points\\\\\\\\based on their limiting behavior...\\\\\\\\\",\n",
        "            \"(which limit point, which limit cycle, etc.)\",\n",
        "            font_size=36,\n",
        "        )\n",
        "        rule.to_corner(UL)\n",
        "        rule[-1].shift(SMALL_BUFF * DOWN)\n",
        "        rule[-1].set_color(GREY_B)\n",
        "\n",
        "        r_map = OldTex(\"z_{n + 1} = A(z_n) / B(z_n)\")\n",
        "        r_map.to_corner(UR)\n",
        "\n",
        "        # Fractal\n",
        "        colors = [\n",
        "            MANDELBROT_COLORS[0], BLUE_C, BLUE_E, ROOT_COLORS_DEEP[1],\n",
        "        ]\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.set_height(5)\n",
        "        plane.to_corner(DR)\n",
        "        fractal = NewtonFractal(plane, coefs=[5, 4j, 3, 2, 1], colors=colors)\n",
        "\n",
        "        # Circles\n",
        "        circles = Circle(radius=0.6).get_grid(3, 1, buff=0.5)\n",
        "        circles.replace(plane, 1)\n",
        "        circles.set_x(-1)\n",
        "        circles.set_stroke(WHITE, 2)\n",
        "\n",
        "        circles[0].set_fill(colors[2], 1)\n",
        "        semis = circles[1].copy().pointwise_become_partial(circles[1], 0, 0.5).replicate(2)\n",
        "        semis[1].rotate(PI, about_point=circles[1].get_center())\n",
        "        semis[0].set_fill(colors[0], 1)\n",
        "        semis[1].set_fill(colors[1], 1)\n",
        "        circles[1].add(semis)\n",
        "\n",
        "        multi_color_image = ImageMobject(\"MulticoloredNewtonsMapCircle\")\n",
        "        multi_color_image.add_updater(lambda m: m.replace(circles[2]))\n",
        "\n",
        "        # Circle label\n",
        "        circle_labels = VGroup(\n",
        "            Text(\"One color\"),\n",
        "            Text(\"Some colors\"),\n",
        "            Text(\"All colors\"),\n",
        "        )\n",
        "        marks = VGroup(Checkmark(), Exmark(), Checkmark())\n",
        "        for label, mark, circle in zip(circle_labels, marks, circles):\n",
        "            mark.set_height(0.5 * circle.get_height())\n",
        "            mark.next_to(circle, LEFT, MED_LARGE_BUFF)\n",
        "            label.next_to(mark, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        # Little circles\n",
        "        lil_circles = circles[0].replicate(2)\n",
        "        lil_circles.set_height(0.2)\n",
        "        lil_circles[0].move_to(plane.get_corner(UL) + MED_SMALL_BUFF * DR)\n",
        "        lil_circles[1].move_to(plane).shift([0.22, -0.12, 0])\n",
        "        lil_circles[1].set_fill(opacity=0)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for big, lil in zip(circles[::2], lil_circles):\n",
        "            vect = normalize(lil.get_center() - big.get_center())\n",
        "            v1 = rotate_vector(vect, 75 * DEGREES)\n",
        "            v2 = rotate_vector(vect, -75 * DEGREES)\n",
        "            big.insert_n_curves(20)\n",
        "            lines.add(VGroup(\n",
        "                Line(lil.get_top(), big.get_boundary_point(v1)),\n",
        "                Line(lil.get_bottom(), big.get_boundary_point(v2)),\n",
        "            ))\n",
        "        lines.set_stroke(WHITE, 1)\n",
        "\n",
        "        # Intro anims\n",
        "        self.add(rule[0])\n",
        "        self.play(FadeIn(r_map))\n",
        "        self.wait()\n",
        "        fractal.set_opacity(0)\n",
        "        self.add(fractal)\n",
        "        for i in range(1, 5):\n",
        "            opacities = np.zeros(4)\n",
        "            opacities[:i] = 1\n",
        "            self.play(fractal.animate.set_opacities(*opacities))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rule[-1], lag_ratio=0.1, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show circles\n",
        "        self.add(lil_circles[0])\n",
        "        self.play(\n",
        "            TransformFromCopy(lil_circles[0], circles[0]),\n",
        "            *map(ShowCreation, lines[0]),\n",
        "            FadeIn(circle_labels[0]),\n",
        "        )\n",
        "        self.play(Write(marks[0]))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(multi_color_image)\n",
        "        self.add(lil_circles[1])\n",
        "        self.play(\n",
        "            TransformFromCopy(lil_circles[1], circles[2]),\n",
        "            *map(ShowCreation, lines[1]),\n",
        "            FadeIn(circle_labels[2]),\n",
        "        )\n",
        "        self.play(Write(marks[2]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(circle_labels[1]),\n",
        "            FadeIn(circles[1]),\n",
        "        )\n",
        "        self.play(Write(marks[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MentionFatouSetsAndJuliaSets(Scene):\n",
        "    colors = [RED_E, BLUE_E, TEAL_E, MAROON_E]\n",
        "\n",
        "    def construct(self):\n",
        "        # Introduce terms\n",
        "        f_group, j_group = self.get_fractals()\n",
        "        f_name, j_name = VGroup(\n",
        "            Text(\"Fatou set\"),\n",
        "            Text(\"Julia set\"),\n",
        "        )\n",
        "        f_name.next_to(f_group, UP, MED_LARGE_BUFF)\n",
        "        j_name.next_to(j_group, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(j_name),\n",
        "            GrowFromCenter(j_group)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(f_name),\n",
        "            *map(GrowFromCenter, f_group)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Define Fatou set\n",
        "        fatou_condition = self.get_fatou_condition()\n",
        "        fatou_condition.set_width(FRAME_WIDTH - 1)\n",
        "        fatou_condition.center().to_edge(UP, buff=1.0)\n",
        "        lhs, arrow, rhs = fatou_condition\n",
        "        f_line = Line(LEFT, RIGHT)\n",
        "        f_line.match_width(fatou_condition)\n",
        "        f_line.next_to(fatou_condition, DOWN)\n",
        "        f_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(j_name, RIGHT),\n",
        "            FadeOut(j_group, RIGHT),\n",
        "            Write(lhs)\n",
        "        )\n",
        "        self.wait()\n",
        "        for words in lhs[-1]:\n",
        "            self.play(FlashUnder(\n",
        "                words,\n",
        "                buff=0,\n",
        "                time_width=1.5\n",
        "            ))\n",
        "        self.play(Write(arrow))\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(f_name.copy(), rhs[1][:8]),\n",
        "            FadeIn(rhs),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show Julia set\n",
        "        otherwise = Text(\"Otherwise...\")\n",
        "        otherwise.next_to(rhs, DOWN, LARGE_BUFF)\n",
        "        j_condition = OldTexText(\"$z_0 \\\\in$\", \" Julia set\", \" of $f$\")\n",
        "        j_condition.match_height(rhs)\n",
        "        j_condition.next_to(otherwise, DOWN, LARGE_BUFF)\n",
        "\n",
        "        j_group.set_height(4.0)\n",
        "        j_group.to_edge(DOWN)\n",
        "        j_group.set_x(-1.0)\n",
        "        j_name = j_condition.get_part_by_tex(\"Julia set\")\n",
        "        j_underline = Underline(j_name, buff=0.05)\n",
        "        j_underline.set_color(YELLOW)\n",
        "        arrow = Arrow(\n",
        "            j_name.get_bottom(),\n",
        "            j_group.get_right(),\n",
        "            path_arc=-45 * DEGREES,\n",
        "        )\n",
        "        arrow.set_stroke(YELLOW, 5)\n",
        "\n",
        "        julia_set = j_group[0]\n",
        "        julia_set.update()\n",
        "        julia_set.suspend_updating()\n",
        "        julia_copy = julia_set.copy()\n",
        "        julia_copy.clear_updaters()\n",
        "        julia_copy.set_colors(self.colors)\n",
        "        julia_copy.set_julia_highlight(0)\n",
        "\n",
        "        mover = f_group[:-4]\n",
        "        mover.generate_target()\n",
        "        mover.target.match_width(rhs)\n",
        "        mover.target.next_to(rhs, UP, MED_LARGE_BUFF)\n",
        "        mover.target.shift_onto_screen(buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(f_line),\n",
        "            FadeOut(f_name),\n",
        "            MoveToTarget(mover),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(otherwise),\n",
        "            FadeIn(j_condition, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(j_underline),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(j_group[1]),\n",
        "            FadeIn(julia_copy)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromPoint(julia_set, julia_set.get_corner(UL), run_time=2),\n",
        "            julia_copy.animate.set_opacity(0.2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_fractals(self, jy=1.5, fy=-2.5):\n",
        "        coefs = roots_to_coefficients([-1.5, 1.5, 1j, -1j])\n",
        "        n = len(coefs) - 1\n",
        "        colors = self.colors\n",
        "        f_planes = VGroup(*(self.get_plane() for x in range(n)))\n",
        "        f_planes.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        plusses = OldTex(\"+\").replicate(n - 1)\n",
        "        f_group = Group(*it.chain(*zip(f_planes, plusses)))\n",
        "        f_group.add(f_planes[-1])\n",
        "        f_group.arrange(RIGHT)\n",
        "        fatou = Group(*(\n",
        "            NewtonFractal(f_plane, coefs=coefs, colors=colors)\n",
        "            for f_plane in f_planes\n",
        "        ))\n",
        "        for i, fractal in enumerate(fatou):\n",
        "            opacities = n * [0.2]\n",
        "            opacities[i] = 1\n",
        "            fractal.set_opacities(*opacities)\n",
        "        f_group.add(*fatou)\n",
        "        f_group.set_y(fy)\n",
        "\n",
        "        j_plane = self.get_plane()\n",
        "        j_plane.set_y(jy)\n",
        "        julia = NewtonFractal(j_plane, coefs=coefs, colors=5 * [GREY_A])\n",
        "        julia.set_julia_highlight(1e-3)\n",
        "        j_group = Group(julia, j_plane)\n",
        "\n",
        "        for fractal, plane in zip((*fatou, julia), (*f_planes, j_plane)):\n",
        "            fractal.plane = plane\n",
        "            fractal.add_updater(\n",
        "                lambda m: m.set_offset(\n",
        "                    m.plane.get_center()\n",
        "                ).set_scale(\n",
        "                    m.plane.get_x_unit_size()\n",
        "                ).replace(m.plane)\n",
        "            )\n",
        "\n",
        "        fractals = Group(f_group, j_group)\n",
        "        return fractals\n",
        "\n",
        "    def get_plane(self):\n",
        "        plane = ComplexPlane(\n",
        "            (-2, 2), (-2, 2),\n",
        "            background_line_style={\"stroke_width\": 1, \"stroke_color\": GREY}\n",
        "        )\n",
        "        plane.set_height(2)\n",
        "        plane.set_opacity(0)\n",
        "        box = SurroundingRectangle(plane, buff=0)\n",
        "        box.set_stroke(WHITE, 1)\n",
        "        plane.add(box)\n",
        "        return plane\n",
        "\n",
        "    def get_fatou_condition(self):\n",
        "        zn = OldTex(\n",
        "            \"z_0\", \"\\\\overset{f}{\\\\longrightarrow}\",\n",
        "            \"z_1\", \"\\\\overset{f}{\\\\longrightarrow}\",\n",
        "            \"z_2\", \"\\\\overset{f}{\\\\longrightarrow}\",\n",
        "            \"\\\\dots\",\n",
        "            \"\\\\longrightarrow\"\n",
        "        )\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Stable fixed point\"),\n",
        "            OldTexText(\"Stable cycle\"),\n",
        "            OldTexText(\"$\\\\infty$\"),\n",
        "        )\n",
        "        words.arrange(DOWN, aligned_edge=LEFT)\n",
        "        brace = Brace(words, LEFT)\n",
        "        zn.next_to(brace, LEFT)\n",
        "        lhs = VGroup(zn, brace, words)\n",
        "\n",
        "        arrow = OldTex(\"\\\\Rightarrow\")\n",
        "        arrow.scale(2)\n",
        "        arrow.next_to(lhs, RIGHT, MED_LARGE_BUFF)\n",
        "        rhs = OldTex(\"z_0 \\\\in\", \" \\\\text{Fatou set of $f$}\")\n",
        "        rhs.next_to(arrow, RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        result = VGroup(lhs, arrow, rhs)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShowJuliaSetPoint(TwoToMillionPoints):\n",
        "    plane_height = 14\n",
        "    show_disk = False\n",
        "    n_steps = 60\n",
        "    disk_radius = 0.02\n",
        "\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        plane, fractal = self.get_plane_and_fractal()\n",
        "\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        for mob in plane.family_members_with_points():\n",
        "            if isinstance(mob, Line):\n",
        "                mob.set_stroke(opacity=0.5 * mob.get_stroke_opacity())\n",
        "        self.add(fractal, plane)\n",
        "\n",
        "        # Points\n",
        "        points = list(self.get_julia_set_points(plane, n_points=1, n_steps=1000))\n",
        "\n",
        "        def func(p):\n",
        "            z = plane.p2n(p)\n",
        "            return plane.n2p(z**2 + self.c)\n",
        "\n",
        "        for n in range(100):\n",
        "            points.append(func(points[-1]))\n",
        "\n",
        "        dot = Dot(points[0])\n",
        "        dot.set_color(YELLOW)\n",
        "\n",
        "        self.add(dot)\n",
        "\n",
        "        if self.show_disk:\n",
        "            dot.scale(0.5)\n",
        "            disk = dot.copy()\n",
        "            disk.insert_n_curves(10000)\n",
        "            disk.set_height(plane.get_x_unit_size() * self.disk_radius)\n",
        "            disk.set_fill(YELLOW, 0.25)\n",
        "            disk.set_stroke(YELLOW, 2, 1)\n",
        "            self.add(disk, dot)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        path_arc = 30 * DEGREES\n",
        "        point = dot.get_center().copy()\n",
        "        for n in range(self.n_steps):\n",
        "            new_point = func(point)\n",
        "            arrow = Arrow(point, new_point, path_arc=path_arc, buff=0)\n",
        "            arrow.set_stroke(WHITE, opacity=0.9)\n",
        "            self.add(dot.copy().set_opacity(0.5))\n",
        "            anims = []\n",
        "            if self.show_disk:\n",
        "                disk.generate_target()\n",
        "                disk.target.apply_function(func)\n",
        "                disk.target.make_smooth(approx=True)\n",
        "                anims.append(MoveToTarget(disk, path_arc=path_arc))\n",
        "                if disk.target.get_height() > frame.get_height():\n",
        "                    anims.extend([\n",
        "                        mob.animate.scale(2.0)\n",
        "                        for mob in [frame, fractal]\n",
        "                    ])\n",
        "            self.play(\n",
        "                ApplyMethod(dot.move_to, new_point, path_arc=path_arc),\n",
        "                ShowCreation(arrow),\n",
        "                *anims,\n",
        "            )\n",
        "            self.play(FadeOut(arrow))\n",
        "            point = new_point\n",
        "\n",
        "\n",
        "class ShowJuliaSetPointWithDisk(ShowJuliaSetPoint):\n",
        "    show_disk = True\n",
        "    n_steps = 11\n",
        "\n",
        "\n",
        "class AboutFatouDisks(Scene):\n",
        "    disk_style = {\n",
        "        \"fill_color\": YELLOW,\n",
        "        \"fill_opacity\": 0.5,\n",
        "        \"stroke_color\": YELLOW,\n",
        "        \"stroke_width\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        words = Text(\"(Small enough) disks around points in the Fatou set...\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        disks, arrows = self.get_disks_and_arrow()\n",
        "        arrows[-1].add(OldTex(\"\\\\dots\").next_to(arrows[-1], RIGHT))\n",
        "        group = VGroup(disks, arrows)\n",
        "        group.next_to(words, DOWN)\n",
        "\n",
        "        shrink_words = Text(\"...eventually shrink to 0\")\n",
        "        shrink_words.next_to(group, DOWN, aligned_edge=RIGHT)\n",
        "\n",
        "        self.add(words)\n",
        "        self.play_disk_progression(disks, arrows)\n",
        "        self.play(\n",
        "            FadeIn(arrows[-1]),\n",
        "            Write(shrink_words, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def play_disk_progression(self, disks, arrows):\n",
        "        self.add(disks[0])\n",
        "        for d1, d2, arrow in zip(disks, disks[1:], arrows):\n",
        "            self.play(\n",
        "                TransformFromCopy(d1.copy().fade(1), d2),\n",
        "                FadeIn(arrow),\n",
        "            )\n",
        "\n",
        "    def get_disks(self):\n",
        "        radii = [\n",
        "            *np.linspace(0.5, 1, 3),\n",
        "            *np.linspace(1, 0, 7)**2 + 0.05,\n",
        "        ]\n",
        "        disks = VGroup(*(Circle(radius=r, **self.disk_style) for r in radii))\n",
        "\n",
        "        for disk in disks:\n",
        "            disk.add(Dot(disk.get_center(), radius=0.01))\n",
        "\n",
        "        return disks\n",
        "\n",
        "    def get_disks_and_arrow(self):\n",
        "        disks = self.get_disks()\n",
        "        arrows = OldTex(\"\\\\rightarrow\").replicate(len(disks))\n",
        "        group = VGroup(*it.chain(*zip(disks, arrows)))\n",
        "        group.arrange(RIGHT)\n",
        "        group.set_width(FRAME_WIDTH - 2)\n",
        "        return disks, arrows\n",
        "\n",
        "\n",
        "class AboutFatouDisksJustWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"(Small enough) disks around points in the Fatou set...\\\\\\\\\",\n",
        "            \"...eventually shrink to 0\"\n",
        "        )\n",
        "        words.arrange(DOWN, aligned_edge=LEFT)\n",
        "        words.to_corner(UL)\n",
        "        words.set_stroke(BLACK, 6, background=True)\n",
        "\n",
        "        self.play(FadeIn(words[0], lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(words[1], lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowFatouDiskExample(Scene):\n",
        "    disk_radius = 0.1\n",
        "    n_steps = 14\n",
        "\n",
        "    def construct(self):\n",
        "        c = -1.06 + 0.11j\n",
        "        plane = ComplexPlane((-3, 3), (-2, 2))\n",
        "        for line in plane.family_members_with_points():\n",
        "            line.set_stroke(opacity=0.5 * line.get_stroke_opacity())\n",
        "        plane.set_height(1.8 * FRAME_HEIGHT)\n",
        "        plane.add_coordinate_labels(font_size=18)\n",
        "        fractal = JuliaFractal(plane, parameter=c)\n",
        "\n",
        "        # z0 = -1.1 + 0.1j\n",
        "        z0 = -0.3 + 0.2j\n",
        "\n",
        "        dot = Dot(plane.n2p(z0), radius=0.025)\n",
        "        dot.set_fill(YELLOW)\n",
        "\n",
        "        disk = dot.copy()\n",
        "        disk.set_height(2 * self.disk_radius * plane.get_x_unit_size())\n",
        "        disk.set_fill(YELLOW, 0.5)\n",
        "        disk.set_stroke(YELLOW, 1.0)\n",
        "        disk.insert_n_curves(1000)\n",
        "\n",
        "        def func(point):\n",
        "            return plane.n2p(plane.p2n(point)**2 + c)\n",
        "\n",
        "        self.add(fractal, plane)\n",
        "        self.add(disk, dot)\n",
        "        self.play(DrawBorderThenFill(disk))\n",
        "\n",
        "        path_arc = 10 * DEGREES\n",
        "        for n in range(self.n_steps):\n",
        "            point = dot.get_center()\n",
        "            new_point = func(point)\n",
        "            arrow = Arrow(point, new_point, path_arc=path_arc, buff=0.1)\n",
        "            self.play(\n",
        "                dot.animate.move_to(new_point),\n",
        "                disk.animate.apply_function(func),\n",
        "                ShowCreation(arrow),\n",
        "                path_arc=path_arc,\n",
        "            )\n",
        "            self.play(FadeOut(arrow))\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class AboutJuliaDisks(AboutFatouDisks):\n",
        "    def construct(self):\n",
        "        words1 = Text(\"Any tiny disk around a Julia set point...\")\n",
        "        words1.to_edge(UP)\n",
        "        disks, arrows = self.get_disks_and_arrow()\n",
        "        group = VGroup(disks, arrows)\n",
        "        group.next_to(words1, DOWN)\n",
        "        arrows[-1].add(disks[-1].copy().scale(5).next_to(arrows[-1], RIGHT))\n",
        "\n",
        "        words2 = Text(\"...eventually hits every point in the plane,\")\n",
        "        words2.next_to(disks, DOWN, aligned_edge=RIGHT)\n",
        "        words2.get_part_by_text(\"every point in the plane\").set_color(BLUE)\n",
        "\n",
        "        words3 = Text(\"with at most two exceptions.\")\n",
        "        words3.next_to(words2, DOWN, MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "\n",
        "        words4 = OldTexText(\n",
        "            \"``Stuff goes everywhere'' principle of Julia sets\",\n",
        "            font_size=60\n",
        "        )\n",
        "        words4.to_edge(DOWN, LARGE_BUFF)\n",
        "\n",
        "        VGroup(words1, words2, words3, words4).set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        plane = ComplexPlane((-100, 100), (-50, 50))\n",
        "        plane.scale(2)\n",
        "        plane.add_coordinate_labels()\n",
        "        plane.add(BackgroundRectangle(plane, opacity=0.25))\n",
        "        plane.set_stroke(background=True)\n",
        "        plane.add_updater(lambda m, dt: m.scale(1 - 0.15 * dt))\n",
        "\n",
        "        self.add(words1)\n",
        "        self.play_disk_progression(disks, arrows)\n",
        "        self.add(plane, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeIn(arrows[-1]),\n",
        "            FadeIn(words2, run_time=2, lag_ratio=0.1),\n",
        "            VFadeIn(plane, suspend_updating=False),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(words3, run_time=2, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(words4))\n",
        "        self.wait(6)\n",
        "        self.play(VFadeOut(plane, suspend_updating=False))\n",
        "\n",
        "    def get_disks(self):\n",
        "        c = -0.18 + 0.77j\n",
        "        z = -0.491 - 0.106j\n",
        "        plane = ComplexPlane()\n",
        "        disk = Circle(radius=0.1, **self.disk_style)\n",
        "        disk.move_to(plane.n2p(z))\n",
        "        disk.insert_n_curves(200)\n",
        "\n",
        "        disks = VGroup(disk)\n",
        "        for n in range(5):\n",
        "            new_disk = disks[-1].copy()\n",
        "            new_disk.apply_complex_function(lambda z: z**2 + c)\n",
        "            new_disk.make_smooth(approx=True)\n",
        "            disks.add(new_disk)\n",
        "\n",
        "        for disk in disks:\n",
        "            disk.center()\n",
        "\n",
        "        disks.set_height(1)\n",
        "\n",
        "        return disks\n",
        "\n",
        "\n",
        "class MontelCorrolaryScreenGrab(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class DescribeChaos(Scene):\n",
        "    def construct(self):\n",
        "        j_point = 3 * LEFT\n",
        "        j_value = -0.36554 - 0.29968j\n",
        "\n",
        "        plane = ComplexPlane((-3, 3), (-2, 2))\n",
        "        plane.scale(50)\n",
        "        plane.shift(j_point - plane.n2p(j_value))\n",
        "        fractal = JuliaFractal(plane)\n",
        "        fractal.set_c(-0.5 + 0.5j)\n",
        "        self.add(fractal, plane)\n",
        "\n",
        "        j_dot = Dot(color=YELLOW, radius=0.05)\n",
        "        j_dot.move_to(j_point)\n",
        "\n",
        "        j_label = Text(\"Julia set point\", color=YELLOW)\n",
        "        j_label.next_to(j_dot, UP, buff=1.0).shift(LEFT)\n",
        "        j_arrow = Line(j_label.get_bottom(), j_dot.get_center(), buff=0.1)\n",
        "        j_arrow.set_stroke(width=3)\n",
        "        j_arrow.set_color(YELLOW)\n",
        "\n",
        "        surrounding_dots = VGroup(*(\n",
        "            Dot(radius=0.05).move_to(j_dot.get_center() + buff * vect)\n",
        "            for n, buff in [(6, 0.2), (12, 0.4)]\n",
        "            for vect in compass_directions(n)\n",
        "        ))\n",
        "        surrounding_dots.set_color(GREY_B)\n",
        "        # for dot in surrounding_dots:\n",
        "        #     dot.shift(0.1 * (random.random() - 0.5))\n",
        "        dots_label = Text(\"Immediate neighbors\")\n",
        "        dots_label.next_to(surrounding_dots, DOWN)\n",
        "        dots_label.set_color(GREY_A)\n",
        "        sublabel = Text(\"drift far away\")\n",
        "        sublabel.set_color(GREY_A)\n",
        "        sublabel.next_to(dots_label, DOWN)\n",
        "        fa = sublabel.get_part_by_text(\"far away\")\n",
        "        strike = Line(LEFT, RIGHT)\n",
        "        strike.set_stroke(RED, 10)\n",
        "        strike.replace(fa, 0)\n",
        "        new_words = Text(\"everywhere!\")\n",
        "        new_words.next_to(fa, DOWN)\n",
        "        new_words.set_color(RED)\n",
        "\n",
        "        all_words = VGroup(j_label, dots_label, sublabel, new_words)\n",
        "        all_words.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for dot in surrounding_dots[-12:]:\n",
        "            point = dot.get_center()\n",
        "            vect = 0.6 * normalize(point - j_dot.get_center())\n",
        "            arrows.add(Arrow(point, point + vect, buff=0.1))\n",
        "        arrows.set_stroke(RED)\n",
        "\n",
        "        self.add(j_dot)\n",
        "        self.add(surrounding_dots)\n",
        "        self.add(j_label, j_arrow)\n",
        "        self.add(dots_label)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.replace(plane)\n",
        "        self.play(Restore(frame, run_time=5))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sublabel, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(strike),\n",
        "            FadeIn(new_words, shift=0.25 * DOWN)\n",
        "        )\n",
        "\n",
        "        self.add(arrows, all_words, strike)\n",
        "        self.play(LaggedStartMap(ShowCreation, arrows))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimulationOfTinyDisk(RepeatedNewton):\n",
        "    coefs = [1, 1, 0, 1]\n",
        "    plane_config = {\n",
        "        \"x_range\": (-4, 4),\n",
        "        \"y_range\": (-2, 2),\n",
        "        \"height\": 12,\n",
        "        \"width\": 24,\n",
        "    }\n",
        "    colors = ROOT_COLORS_DEEP[::2]\n",
        "    n_steps = 20\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "\n",
        "        def get_height_ratio():\n",
        "            return frame.get_height() / FRAME_HEIGHT\n",
        "\n",
        "        self.add_plane()\n",
        "        self.add_true_roots()\n",
        "        self.add_labels()\n",
        "        self.add_fractal_background()\n",
        "\n",
        "        fractal = self.fractal\n",
        "        julia_set = self.fractal_boundary\n",
        "        fractal.set_n_steps(40)\n",
        "        julia_set.set_n_steps(40)\n",
        "        fractal.set_opacity(0.3)\n",
        "        julia_set.set_opacity(1)\n",
        "        julia_set.add_updater(lambda m: m.set_julia_highlight(\n",
        "            get_height_ratio() * 1e-3\n",
        "        ))\n",
        "        julia_set.set_opacity(0.5)\n",
        "\n",
        "        # Generate dots\n",
        "        point = [1.10049904, 1.38962415, 0.]\n",
        "        target_height = 0.0006\n",
        "        cluster_radius = target_height / 50\n",
        "\n",
        "        dots = self.dots = DotCloud()\n",
        "        n_radii = 200\n",
        "        dots.set_points([\n",
        "            [cluster_radius * r * math.cos(theta), cluster_radius * r * math.sin(theta), 0]\n",
        "            for r in np.linspace(1, 0, n_radii)\n",
        "            for theta in np.linspace(0, TAU, int(r * 20)) + random.random() * TAU\n",
        "        ])\n",
        "        dots.set_height(0.3)\n",
        "        dots.set_gloss(0.5)\n",
        "        dots.set_shadow(0.5)\n",
        "        dots.set_color(GREY_A)\n",
        "        dots.move_to(point)\n",
        "        dots.add_updater(lambda m: m.set_radius(0.05 * get_height_ratio()))\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(target_height).move_to(point),\n",
        "            run_time=6,\n",
        "            rate_func=lambda a: smooth(a**0.5),\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(dots))\n",
        "        self.wait()\n",
        "        self.play(Restore(frame, run_time=6, rate_func=lambda a: smooth(a**3)))\n",
        "        fractal.set_n_steps(12)\n",
        "        julia_set.set_n_steps(12)\n",
        "\n",
        "        self.run_iterations()\n",
        "\n",
        "\n",
        "class SimulationAnnotations(Scene):\n",
        "    def construct(self):\n",
        "        dots = self.dots = DotCloud()\n",
        "        n_radii = 200\n",
        "        cluster_radius = 0.5\n",
        "        dots.set_points([\n",
        "            [cluster_radius * r * math.cos(theta), cluster_radius * r * math.sin(theta), 0]\n",
        "            for r in np.linspace(1, 0, n_radii)\n",
        "            for theta in np.linspace(0, TAU, int(r * 20)) + random.random() * TAU\n",
        "        ])\n",
        "\n",
        "        n_points_label = OldTexText(\"$\\\\sim 2{,}000$ points\")\n",
        "        n_points_label.next_to(dots, UP)\n",
        "\n",
        "        brace = Brace(\n",
        "            # Line(dots.get_bottom(), dots.get_corner(DR)),\n",
        "            Line(dots.get_center(), dots.get_right()),\n",
        "            DOWN, buff=0\n",
        "        )\n",
        "        brace_tex = OldTex(\"\\\\text{Radius } \\\\approx 1 / 1{,}000{,}000\")\n",
        "        brace_tex.next_to(dots, DOWN)\n",
        "\n",
        "        group = VGroup(n_points_label, brace, brace_tex)\n",
        "        group.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(Write(n_points_label))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_tex, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(group))\n",
        "\n",
        "\n",
        "class LattesExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        example = VGroup(\n",
        "            OldTexText(\"Latt\u00e8's example: \"),\n",
        "            OldTex(r\"L(z)=\\frac{\\left(z^{2}+1\\right)^{2}}{4 z\\left(z^{2}-1\\right)}\"),\n",
        "        )\n",
        "        example.arrange(RIGHT)\n",
        "        example[0].shift(SMALL_BUFF * DOWN)\n",
        "        example.move_to(self.hold_up_spot, DOWN)\n",
        "        example.set_x(0)\n",
        "\n",
        "        j_fact = OldTexText(\"Julia set of $L(z)$ is all of $\\\\mathds{C}$\")\n",
        "        j_fact.move_to(example)\n",
        "        subwords = OldTexText(\"(and the point at $\\\\infty$)\", font_size=36)\n",
        "        subwords.set_fill(GREY_A)\n",
        "        subwords.next_to(j_fact, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\", 3 * UR),\n",
        "            self.change_students(\n",
        "                \"pondering\", \"happy\", \"tease\",\n",
        "                look_at=3 * UR\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            self.teacher.change(\"sassy\", example),\n",
        "            Write(example)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"pondering\", \"pondering\",\n",
        "            look_at=example,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            example.animate.to_edge(UP),\n",
        "            FadeIn(j_fact),\n",
        "            self.change_students(\n",
        "                \"erm\", \"erm\", \"erm\",\n",
        "                look_at=j_fact,\n",
        "            ),\n",
        "            self.teacher.change(\"raise_right_hand\", j_fact)\n",
        "        )\n",
        "        self.play(FadeIn(subwords))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class JFunctionMention(Scene):\n",
        "    def construct(self):\n",
        "        image = ImageMobject(\"j_invariant\")\n",
        "        image.set_height(5)\n",
        "        name = OldTexText(\"Klein's $j$ function\")\n",
        "        name.next_to(image, UP)\n",
        "        words = Text(\"A whole story...\")\n",
        "        words.next_to(image, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(image),\n",
        "            Write(name)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LinksBelow(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.pi_creatures.flip().flip()\n",
        "        self.teacher_says(\"Links below\")\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"pondering\",\n",
        "            look_at=FRAME_HEIGHT * DOWN,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(self.teacher.change(\"happy\"))\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class MoreAmbientChaos(TwoToMillionPoints):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.set_height(7)\n",
        "        self.add(plane)\n",
        "\n",
        "        point = self.get_julia_set_points(plane, n_points=1, n_steps=1000)[0]\n",
        "        epsilon = 1e-6\n",
        "        dots = DotCloud([\n",
        "            point + epsilon * rotate_vector(RIGHT, random.random() * TAU)\n",
        "            for x in range(10)\n",
        "        ])\n",
        "        dots.set_gloss(0.5)\n",
        "        dots.set_shadow(0.5)\n",
        "        dots.set_radius(0.075)\n",
        "        dots.set_color(YELLOW)\n",
        "\n",
        "        def func(p):\n",
        "            z = plane.p2n(p)\n",
        "            return plane.n2p(z**2 + self.c)\n",
        "\n",
        "        n_steps = 100\n",
        "\n",
        "        for n in range(n_steps):\n",
        "            points = dots.get_points()\n",
        "\n",
        "            values = list(map(plane.p2n, points))\n",
        "            new_values = np.array(list(map(lambda z: z**2 + self.c, values)))\n",
        "\n",
        "            new_points = list(map(plane.n2p, new_values))\n",
        "\n",
        "            nn_points = []\n",
        "            for p in new_points:\n",
        "                if p[0] < plane.get_left()[0]:\n",
        "                    p[0] += 2 * (plane.get_left()[0] - p[0])\n",
        "                if p[0] > plane.get_right()[0]:\n",
        "                    p[0] -= 2 * (p[0] - plane.get_right()[0])\n",
        "                if p[1] < plane.get_bottom()[1]:\n",
        "                    p[1] += 2 * (plane.get_bottom()[1] - p[1])\n",
        "                if p[1] > plane.get_top()[1]:\n",
        "                    p[1] -= 2 * (p[1] - plane.get_top()[1])\n",
        "                nn_points.append(p)\n",
        "            new_points = nn_points\n",
        "\n",
        "            lines = VGroup(*(\n",
        "                Line(p1, p2)\n",
        "                for p1, p2 in zip(points, new_points)\n",
        "            ))\n",
        "            lines.set_stroke(WHITE, 1)\n",
        "\n",
        "            self.play(\n",
        "                dots.animate.set_points(new_points),\n",
        "                ShowCreation(lines, lag_ratio=0),\n",
        "            )\n",
        "            self.add(lines[0].copy().set_opacity(0.25))\n",
        "            for line in lines:\n",
        "                line.rotate(PI)\n",
        "            self.play(FadeOut(lines))\n",
        "\n",
        "\n",
        "class HighlightedJulia(IntroNewtonFractal):\n",
        "    coefs = [-1.0, 0.0, 0.0, 1.0, 0.0, 1.0]\n",
        "\n",
        "    def construct(self):\n",
        "        # self.init_fractal(root_colors=ROOT_COLORS_DEEP[0::2])\n",
        "        self.init_fractal(root_colors=ROOT_COLORS_DEEP)\n",
        "        fractal = self.fractal\n",
        "\n",
        "        def get_height_ratio():\n",
        "            return self.camera.frame.get_height() / FRAME_HEIGHT\n",
        "\n",
        "        fractal.set_colors(5 * [WHITE])\n",
        "        fractal.add_updater(lambda m: m.set_julia_highlight(get_height_ratio() * 1e-3))\n",
        "        fractal.set_n_steps(50)\n",
        "        # self.play(\n",
        "        #     fractal.animate.set_julia_highlight(1e-3),\n",
        "        #     run_time=5\n",
        "        # )\n",
        "\n",
        "        # self.embed()\n",
        "\n",
        "\n",
        "class MetaFractal(IntroNewtonFractal):\n",
        "    fixed_roots = [-1, 1]\n",
        "    z0 = complex(0.5, 0)\n",
        "    n_steps = 200\n",
        "\n",
        "    def construct(self):\n",
        "        colors = ROOT_COLORS_DEEP[0::2]\n",
        "        self.plane_config[\"faded_line_ratio\"] = 3\n",
        "        plane = self.get_plane()\n",
        "        root_dots = self.root_dots = VGroup(*(\n",
        "            Dot(plane.n2p(root), color=color)\n",
        "            for root, color in zip(self.fixed_roots, colors)\n",
        "        ))\n",
        "        root_dots.set_stroke(BLACK, 3)\n",
        "        fractal = MetaNewtonFractal(\n",
        "            plane,\n",
        "            fixed_roots=self.fixed_roots,\n",
        "            colors=colors,\n",
        "            n_steps=self.n_steps,\n",
        "            # z0=self.z0,\n",
        "        )\n",
        "        fractal.add_updater(lambda f: f.set_fixed_roots([\n",
        "            plane.p2n(dot.get_center())\n",
        "            for dot in root_dots\n",
        "        ]))\n",
        "\n",
        "        self.add(fractal, plane)\n",
        "        self.add(root_dots)\n",
        "\n",
        "        point1 = np.array([1.62070862, 1.68700851, 0.])\n",
        "        point2 = np.array([0.81263967, 2.84042313, 0.])\n",
        "        height1 = 0.083\n",
        "        height2 = 0.035\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.generate_target()\n",
        "        frame.target.move_to(point1)\n",
        "        frame.target.set_height(height1)\n",
        "\n",
        "        fractal.set_saturation_factor(2)\n",
        "        plane.remove(plane.coordinate_labels)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            run_time=8,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.play(\n",
        "            fractal.animate.set_saturation_factor(4),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                frame,\n",
        "                lambda m, a: m.set_height(\n",
        "                    interpolate(\n",
        "                        interpolate(height1, 2, a),\n",
        "                        interpolate(2, height2, a),\n",
        "                        a,\n",
        "                    ),\n",
        "                ).move_to(\n",
        "                    interpolate(point1, point2, a)\n",
        "                )\n",
        "            ),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Restore(frame),\n",
        "            fractal.animate.set_saturation_factor(0),\n",
        "            run_time=7\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Part1EndScroll(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        # \"title_text\": \"\",\n",
        "        \"scroll_time\": 30,\n",
        "        # \"show_pis\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class AmbientJulia(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(\n",
        "            (-4, 4), (-2, 2),\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_A,\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        )\n",
        "        plane.axes.set_stroke(width=1, opacity=0.5)\n",
        "        plane.set_height(14)\n",
        "        fractal = JuliaFractal(plane)\n",
        "        fractal.set_n_steps(100)\n",
        "\n",
        "        R = 0.25\n",
        "        cardioid = ParametricCurve(\n",
        "            lambda t: plane.c2p(\n",
        "                2 * R * math.cos(t) - R * math.cos(2 * t),\n",
        "                2 * R * math.sin(t) - R * math.sin(2 * t),\n",
        "            ),\n",
        "            t_range=(0, TAU)\n",
        "        )\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        fractal.add_updater(lambda m: m.set_c(\n",
        "            plane.p2n(cardioid.pfp(get_t()))\n",
        "        ))\n",
        "\n",
        "        self.add(fractal, plane)\n",
        "        self.play(\n",
        "            t_tracker.animate.set_value(1),\n",
        "            rate_func=linear,\n",
        "            run_time=300\n",
        "        )\n"
    ]
}