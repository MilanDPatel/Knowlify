{
    "topic": "demonstrates the concept of a sliced wave, which is a visualization of",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.optics_puzzles.objects import *\n",
        "\n",
        "\n",
        "class SlicedWave(Group):\n",
        "    default_wave_config = dict(\n",
        "        z_amplitude=0,\n",
        "        y_amplitude=1,\n",
        "        wave_len=2.0,\n",
        "        color=BLUE,\n",
        "    )\n",
        "    default_layer_style = dict(\n",
        "        stroke_width=2.0,\n",
        "        stroke_color=WHITE,\n",
        "    )\n",
        "    default_vect_wave_style = dict(\n",
        "        stroke_opacity=0.5\n",
        "    )\n",
        "\n",
        "    def __init__(\n",
        "        self,\n",
        "        axes,\n",
        "        layer_xs,\n",
        "        phase_kick_back=0,\n",
        "        layer_height=4.0,\n",
        "        damping_per_layer=1.0,\n",
        "        wave_config = dict(),\n",
        "        vect_wave_style=dict(),\n",
        "        layer_style=dict(),\n",
        "    ):\n",
        "        self.layer_xs = layer_xs\n",
        "        self.axes = axes\n",
        "        wave_kw = merge_dicts_recursively(self.default_wave_config, wave_config)\n",
        "        vwave_kw = merge_dicts_recursively(self.default_vect_wave_style, vect_wave_style)\n",
        "        line_kw = merge_dicts_recursively(self.default_layer_style, layer_style)\n",
        "\n",
        "        self.wave = OscillatingWave(axes, **wave_kw)\n",
        "        self.vect_wave = OscillatingFieldWave(axes, self.wave, **vwave_kw)\n",
        "        self.phase_kick_trackers = [\n",
        "            ValueTracker(phase_kick_back)\n",
        "            for x in layer_xs\n",
        "        ]\n",
        "        self.absorbtion_trackers = [\n",
        "            ValueTracker(damping_per_layer)\n",
        "            for x in layer_xs\n",
        "        ]\n",
        "        self.layers = VGroup()\n",
        "        for x in layer_xs:\n",
        "            line = Line(DOWN, UP, **line_kw)\n",
        "            line.set_height(layer_height)\n",
        "            line.move_to(axes.c2p(x, 0))\n",
        "            self.layers.add(line)\n",
        "\n",
        "        self.wave.xt_to_yz = self.xt_to_yz\n",
        "\n",
        "        super().__init__(\n",
        "            self.wave,\n",
        "            self.vect_wave,\n",
        "            self.layers,\n",
        "            *self.phase_kick_trackers\n",
        "        )\n",
        "\n",
        "    def set_layer_xs(self, xs):\n",
        "        self.layer_xs = xs\n",
        "\n",
        "    def xt_to_yz(self, x, t):\n",
        "        phase = np.ones_like(x)\n",
        "        phase *= TAU * t * self.wave.speed / self.wave.wave_len\n",
        "        amplitudes = self.wave.y_amplitude * np.ones_like(x)\n",
        "        for layer_x, pkt, at in zip(self.layer_xs, self.phase_kick_trackers, self.absorbtion_trackers):\n",
        "            phase[x > layer_x] += pkt.get_value()\n",
        "            amplitudes[x > layer_x] *= at.get_value()\n",
        "\n",
        "        y = amplitudes * np.sin(TAU * x / self.wave.wave_len - phase)\n",
        "        return y, np.zeros_like(x)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class SpeedInMediumFastPart(InteractiveScene):\n",
        "    z_amplitude = 0\n",
        "    y_amplitude = 1.0\n",
        "    color = YELLOW\n",
        "    wave_len = 3.0\n",
        "    speed = 1.5\n",
        "    medium_color = BLUE\n",
        "    medium_opacity = 0.35\n",
        "    add_label = True\n",
        "    run_time = 30\n",
        "    material_label = \"Glass\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Basic wave\n",
        "        axes = ThreeDAxes((-12, 12), (-4, 4))\n",
        "        axes.z_axis.set_stroke(opacity=0)\n",
        "        axes.y_axis.set_stroke(opacity=0)\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            z_amplitude=self.z_amplitude,\n",
        "            y_amplitude=self.y_amplitude,\n",
        "            color=self.color,\n",
        "            wave_len=self.wave_len,\n",
        "            speed=self.speed,\n",
        "        )\n",
        "        vect_wave = OscillatingFieldWave(axes, wave)\n",
        "        vect_wave.set_stroke(opacity=0.5)\n",
        "\n",
        "        self.add(axes, wave, vect_wave)\n",
        "\n",
        "        # Water label\n",
        "        rect = FullScreenRectangle()\n",
        "        rect.stretch(0.5, 0, about_edge=RIGHT)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(self.medium_color, self.medium_opacity)\n",
        "        self.add(rect)\n",
        "\n",
        "        if self.add_label:\n",
        "            label = Text(self.material_label, font_size=60)\n",
        "            label.next_to(rect.get_top(), DOWN)\n",
        "            self.add(label)\n",
        "\n",
        "        # Propagate\n",
        "        self.wait(self.run_time)\n",
        "\n",
        "\n",
        "class SpeedInMediumSlower(SpeedInMediumFastPart):\n",
        "    wave_len = 2.0\n",
        "    speed = 1.0\n",
        "\n",
        "\n",
        "class VectorOverMedia(InteractiveScene):\n",
        "    def construct(self):\n",
        "        vect = Vector(DOWN)\n",
        "        vect.next_to(UP, UP)\n",
        "        vect.to_edge(LEFT, buff=0)\n",
        "\n",
        "        def update_vect(v, dt):\n",
        "            # speed = 1.5 if v.get_x() < 0 else 1.0\n",
        "            speed = 1.33 if v.get_x() < 0 else 1.33 / 1.5\n",
        "            v.shift(dt * RIGHT * speed)\n",
        "\n",
        "        vect.add_updater(update_vect)\n",
        "        word = Text(\"Phase velocity\")\n",
        "        word.add_updater(lambda m: m.next_to(vect, UP))\n",
        "        self.add(vect)\n",
        "        self.add(word)\n",
        "        self.wait(13)\n",
        "\n",
        "\n",
        "class VioletWaveFast(SpeedInMediumFastPart):\n",
        "    color = get_spectral_color(0.95)\n",
        "    wave_len = 1.2\n",
        "    y_amplitude = 0.5\n",
        "    speed = 1.5\n",
        "    medium_opacity = 0.25\n",
        "    add_label = False\n",
        "    run_time = 15\n",
        "\n",
        "\n",
        "class VioletWaveSlow(VioletWaveFast):\n",
        "    wave_len = 1.2 * 0.5\n",
        "    speed = 1.5 * 0.5\n",
        "\n",
        "\n",
        "class GreenWaveFast(VioletWaveFast):\n",
        "    color = get_spectral_color(0.65)\n",
        "    wave_len = 1.5\n",
        "\n",
        "\n",
        "class GreenWaveSlow(GreenWaveFast):\n",
        "    wave_len = 1.5 * 0.6\n",
        "    speed = 1.5 * 0.6\n",
        "\n",
        "\n",
        "class OrangeWaveFast(VioletWaveFast):\n",
        "    color = get_spectral_color(0.3)\n",
        "    wave_len = 2.0\n",
        "\n",
        "\n",
        "class OrangeWaveSlow(OrangeWaveFast):\n",
        "    wave_len = 2.0 * 0.7\n",
        "    speed = 1.5 * 0.7\n",
        "\n",
        "\n",
        "class RedWaveFast(VioletWaveFast):\n",
        "    color = get_spectral_color(0.05)\n",
        "    wave_len = 2.5\n",
        "\n",
        "\n",
        "class RedWaveSlow(RedWaveFast):\n",
        "    wave_len = 2.5 * 0.8\n",
        "    speed = 1.5 * 0.8\n",
        "\n",
        "\n",
        "class PhaseKickBacks(SpeedInMediumFastPart):\n",
        "    layer_xs = np.arange(0, 8, 1)\n",
        "    kick_back_value = 0\n",
        "    axes_config = dict(\n",
        "        x_range=(-8, 8),\n",
        "        y_range=(-4, 4),\n",
        "    )\n",
        "    line_style = dict()\n",
        "    wave_config = dict()\n",
        "    vect_wave_style = dict()\n",
        "    layer_add_on_run_time = 5\n",
        "    damping_per_layer = 1.0\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = ThreeDAxes(**self.axes_config)\n",
        "        axes.z_axis.set_stroke(opacity=0)\n",
        "        return axes\n",
        "\n",
        "    def get_layer_xs(self):\n",
        "        return self.layer_xs\n",
        "\n",
        "    def get_sliced_wave(self):\n",
        "        return SlicedWave(\n",
        "            self.get_axes(),\n",
        "            self.get_layer_xs(),\n",
        "            wave_config=self.wave_config,\n",
        "            vect_wave_style=self.vect_wave_style,\n",
        "            layer_style=self.line_style,\n",
        "            phase_kick_back=self.kick_back_value,\n",
        "            damping_per_layer=self.damping_per_layer,\n",
        "        )\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.sliced_wave = self.get_sliced_wave()\n",
        "        self.add(self.sliced_wave)\n",
        "\n",
        "\n",
        "class RevertToOneLayerAtATime(PhaseKickBacks):\n",
        "    layer_xs = np.arange(0, FRAME_WIDTH / 2, FRAME_WIDTH / 2**(11))\n",
        "    kick_back_value = -0.025\n",
        "    n_layers_skipped = 64\n",
        "\n",
        "    exagerated_phase_kick = -0.8\n",
        "\n",
        "    line_style = dict(\n",
        "        stroke_width=1,\n",
        "        stroke_opacity=0.25,\n",
        "        stroke_color=BLUE_B\n",
        "    )\n",
        "    axes_config = dict(\n",
        "        x_range=(-12, 12),\n",
        "        y_range=(-4, 4),\n",
        "    )\n",
        "    wave_config = dict(\n",
        "        color=YELLOW,\n",
        "        sample_resolution=0.001\n",
        "    )\n",
        "    vect_wave_style = dict(tip_width_ratio=3, stroke_opacity=0.5)\n",
        "\n",
        "    def construct(self):\n",
        "        # Objects\n",
        "        sliced_wave = self.sliced_wave\n",
        "        wave = sliced_wave.wave\n",
        "        layers = sliced_wave.layers\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "\n",
        "        # Add label\n",
        "        block_label = Text(\"Material (e.g. glass)\")\n",
        "        block_label.next_to(layers, UP, aligned_edge=LEFT)\n",
        "\n",
        "        for pkt in pkts:\n",
        "            pkt.set_value(-0.015)\n",
        "\n",
        "        self.wait(5)\n",
        "        self.play(Write(block_label[\"Material\"], run_time=1))\n",
        "        self.play(FadeIn(block_label[\"(e.g. glass)\"], 0.25 * UP))\n",
        "        self.add(block_label)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show layers\n",
        "        layers.save_state()\n",
        "\n",
        "        rect = BackgroundRectangle(sliced_wave)\n",
        "        rect.set_fill(BLACK, 0.9)\n",
        "        self.add(sliced_wave, rect, layers)\n",
        "        self.play(\n",
        "            layers.animate.arrange(RIGHT, buff=0.3).move_to(ORIGIN, LEFT).set_stroke(width=2, opacity=1),\n",
        "            FadeIn(rect),\n",
        "            *(pkt.animate.set_value(0) for pkt in pkts),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Revert to one single layer\n",
        "        left_layers = VGroup()\n",
        "        for layer in layers:\n",
        "            if layer.get_x() < FRAME_WIDTH / 2:\n",
        "                left_layers.add(layer)\n",
        "        self.remove(layers)\n",
        "        self.add(left_layers)\n",
        "\n",
        "        layer_label = Text(\"Thin layer of material\")\n",
        "        layer_label.next_to(layers[0], UP, buff=0.75)\n",
        "\n",
        "        kw = dict(run_time=5, lag_ratio=0.1)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                layer.animate().set_stroke(opacity=0).shift(DOWN)\n",
        "                for layer in left_layers[:0:-1]\n",
        "            ), **kw),\n",
        "            layers[0].animate.set_stroke(width=2, opacity=1).set_height(5).set_anim_args(time_span=(4, 5)),\n",
        "            FadeTransform(\n",
        "                block_label, layer_label,\n",
        "                time_span=(4, 5)\n",
        "            ),\n",
        "            FadeOut(rect, time_span=(3, 5)),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Pause, shift the phase a bit\n",
        "        arrow = Vector(1.0 * LEFT, stroke_width=6)\n",
        "        arrow.next_to(wave, UP, buff=0.75)\n",
        "        arrow.set_x(0, LEFT).shift(0.1 * RIGHT)\n",
        "        phase_kick = self.exagerated_phase_kick\n",
        "        kick_words = Text(\"Kick back\\nthe phase\", font_size=36)\n",
        "        kick_words.next_to(arrow, RIGHT)\n",
        "        kick_label = VGroup(arrow, kick_words)\n",
        "        kick_label.set_color(RED)\n",
        "\n",
        "        self.wait(1 - (wave.time % 1))\n",
        "        wave.stop_clock()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            pkts[0].animate.set_value(phase_kick),\n",
        "            FadeIn(kick_label, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the phase kick\n",
        "        form1 = Tex(R\"A\\sin(kx)\")\n",
        "        form2 = Tex(R\"A\\sin(kx + 1.00)\")\n",
        "        pk_decimal: DecimalNumber = form2.make_number_changeable(\"1.00\")\n",
        "        pk_decimal.set_value(-phase_kick)\n",
        "        pk_decimal.set_color(RED)\n",
        "\n",
        "        VGroup(form1, form2).next_to(wave, DOWN)\n",
        "        form1.set_x(-FRAME_WIDTH / 4)\n",
        "        form2.set_x(+FRAME_WIDTH / 4)\n",
        "\n",
        "\n",
        "        self.play(FadeIn(form1, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingStrings(form1.copy(), form2, path_arc=20 * DEGREES))\n",
        "        self.wait()\n",
        "        for value in [-0.01, phase_kick]:\n",
        "            self.play(\n",
        "                pkts[0].animate.set_value(value),\n",
        "                ChangeDecimalToValue(pk_decimal, -value),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Add phase kick label\n",
        "        pk_label = Text(\"Phase kick = \", font_size=36, fill_color=GREY_B)\n",
        "        pk_label.next_to(wave, UP, LARGE_BUFF)\n",
        "        pk_label.to_edge(LEFT)\n",
        "\n",
        "        form2.remove(pk_decimal)\n",
        "        form2.add(pk_decimal.copy())\n",
        "        self.add(form2)\n",
        "        self.play(\n",
        "            pk_decimal.animate.match_height(pk_label).next_to(pk_label, RIGHT, 0.2, DOWN),\n",
        "            ReplacementTransform(kick_words[\"Kick\"].copy(), pk_label[\"kick\"]),\n",
        "            ReplacementTransform(kick_words[\"phase\"].copy(), pk_label[\"Phase\"]),\n",
        "            FadeIn(pk_label[\"=\"]),\n",
        "            run_time=2\n",
        "        )\n",
        "        pk_label.add(pk_decimal)\n",
        "        self.add(pk_label)\n",
        "        self.play(\n",
        "            FadeOut(form1),\n",
        "            FadeOut(form2),\n",
        "        )\n",
        "\n",
        "        # Show following layers\n",
        "        for layer in layers[1:]:\n",
        "            layer.match_height(layers[0])\n",
        "            layer.match_style(layers[0])\n",
        "            layer.set_stroke(opacity=0)\n",
        "\n",
        "        nls = self.n_layers_skipped\n",
        "        shown_layers = VGroup(layers[0])\n",
        "        layer_arrows = VGroup(VectorizedPoint(layer_label.get_center()))\n",
        "        for layer, pkt in zip(layers[nls::nls], pkts[nls::nls]):\n",
        "            layer.set_stroke(opacity=1)\n",
        "            shown_layers.add(layer)\n",
        "\n",
        "            layer_label.target = layer_label.generate_target()\n",
        "            layer_label.target.set_height(0.35)\n",
        "            layer_label.target.match_x(shown_layers)\n",
        "            layer_label.target.to_edge(UP, buff=0.25)\n",
        "\n",
        "            layer_arrows.target = VGroup(*(\n",
        "                Arrow(\n",
        "                    layer_label.target.get_bottom(),\n",
        "                    sl.get_top(),\n",
        "                    buff=0.1,\n",
        "                    stroke_width=2,\n",
        "                    stroke_opacity=0.5,\n",
        "                )\n",
        "                for sl in shown_layers\n",
        "            ))\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(kick_label),\n",
        "                GrowFromCenter(layer),\n",
        "                MoveToTarget(layer_label),\n",
        "                MoveToTarget(layer_arrows),\n",
        "            )\n",
        "            kick_label.align_to(layer, LEFT).shift(0.1 * RIGHT)\n",
        "            self.play(\n",
        "                FadeIn(kick_label, 0.5 * LEFT),\n",
        "                pkt.animate.set_value(phase_kick)\n",
        "            )\n",
        "        self.play(FadeOut(kick_label))\n",
        "\n",
        "        # Restart clock\n",
        "        wave.start_clock()\n",
        "        self.play(FadeOut(layer_label), FadeOut(layer_arrows))\n",
        "        self.wait(6)\n",
        "\n",
        "        # Change phase kick\n",
        "        self.play(FlashAround(pk_label))\n",
        "        for value in [-0.01, self.exagerated_phase_kick]:\n",
        "            phase_kick = value\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(pk_decimal, -phase_kick),\n",
        "                *(\n",
        "                    pkt.animate.set_value(phase_kick)\n",
        "                    for pkt in pkts[::nls]\n",
        "                ),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Number of layers label\n",
        "        n_shown_layers = len(layers[::nls])\n",
        "        n_layers_label = TexText(f\"Num. layers = {n_shown_layers}\", font_size=36)\n",
        "        n_layers_label.set_color(GREY_B)\n",
        "        n_layers_label.next_to(pk_label, UP, MED_LARGE_BUFF, LEFT)\n",
        "        nl_decimal = n_layers_label.make_number_changeable(n_shown_layers)\n",
        "        nl_decimal.set_color(BLUE)\n",
        "\n",
        "        self.play(FadeIn(n_layers_label, UP))\n",
        "        self.wait(8)\n",
        "\n",
        "        # Fill in\n",
        "        opacity = 1.0\n",
        "        stroke_width = 2.0\n",
        "        kw = dict(lag_ratio=0.1, run_time=3)\n",
        "        while nls > 1:\n",
        "            # Update parameters\n",
        "            nls //= 2\n",
        "            opacity = 0.25 + 0.5 * (opacity - 0.25)\n",
        "            stroke_width = 1.0 + 0.5 * (stroke_width - 1.0)\n",
        "            phase_kick /= 2\n",
        "\n",
        "            new_layers = layers[nls::2 * nls]\n",
        "            old_layers = layers[0::2 * nls]\n",
        "\n",
        "            new_nl_decimal = Integer(len(layers[::nls]))\n",
        "            new_nl_decimal.match_height(nl_decimal)\n",
        "            new_nl_decimal.match_style(nl_decimal)\n",
        "            new_nl_decimal.move_to(nl_decimal, LEFT)\n",
        "\n",
        "            new_pk_decimal = DecimalNumber(\n",
        "                -phase_kick,\n",
        "                num_decimal_places=(2 if -phase_kick > 0.05 else 3)\n",
        "            )\n",
        "            new_pk_decimal.match_height(pk_decimal)\n",
        "            new_pk_decimal.match_style(pk_decimal)\n",
        "            new_pk_decimal.move_to(pk_decimal, LEFT)\n",
        "\n",
        "            new_layers.set_stroke(width=stroke_width, opacity=opacity)\n",
        "\n",
        "            self.play(\n",
        "                LaggedStart(*(\n",
        "                    GrowFromCenter(layer)\n",
        "                    for layer in new_layers\n",
        "                ), **kw),\n",
        "                old_layers.animate.set_stroke(width=stroke_width, opacity=opacity),\n",
        "                LaggedStart(*(\n",
        "                    pkt.animate.set_value(phase_kick)\n",
        "                    for pkt in pkts[::nls]\n",
        "                ), **kw),\n",
        "                LaggedStart(\n",
        "                    FadeOut(nl_decimal, 0.2 * UP),\n",
        "                    FadeIn(new_nl_decimal, 0.2 * UP),\n",
        "                    FadeOut(pk_decimal, 0.2 * UP),\n",
        "                    FadeIn(new_pk_decimal, 0.2 * UP),\n",
        "                    lag_ratio=0.1,\n",
        "                    run_time=1\n",
        "                )\n",
        "            )\n",
        "\n",
        "            nl_decimal = new_nl_decimal\n",
        "            pk_decimal = new_pk_decimal\n",
        "\n",
        "            self.play(*(\n",
        "                pkt.animate.set_value(phase_kick)\n",
        "                for pkt in pkts[::nls]\n",
        "            ))\n",
        "            self.wait(3 if nls >= 32 else 1)\n",
        "\n",
        "        # Wait\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SimplerRevertToOneLayerAtATime(RevertToOneLayerAtATime):\n",
        "    layer_xs = np.arange(-0, 7.5, 0.11)\n",
        "    kick_back_value = -0.25\n",
        "    n_layers_skipped = 8\n",
        "\n",
        "\n",
        "class SlowedAndAbsorbed(RevertToOneLayerAtATime):\n",
        "    layer_xs = np.arange(-FRAME_WIDTH / 3, FRAME_WIDTH / 3, FRAME_WIDTH / 2**(8))\n",
        "    kick_back_value = -0.2\n",
        "    damping_per_layer = 1 - 2e-2\n",
        "    wave_config = dict(\n",
        "        color=YELLOW,\n",
        "        sample_resolution=0.001,\n",
        "    )\n",
        "    line_style = dict(\n",
        "        stroke_color=BLUE_B,\n",
        "        stroke_width=1.5,\n",
        "        stroke_opacity=0.5,\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Objects\n",
        "        sliced_wave = self.sliced_wave\n",
        "        wave = sliced_wave.wave\n",
        "        layers = sliced_wave.layers\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "        ats = sliced_wave.absorbtion_trackers\n",
        "\n",
        "        # Show labels\n",
        "        label = Text(\"Wave gets slowed and absorbed\")\n",
        "        label.next_to(layers, UP)\n",
        "        abs_words = label[\"and absorbed\"]\n",
        "\n",
        "        mu_label = Tex(R\"\\mu\").set_color(PINK)\n",
        "        mu_line = NumberLine((0, 1, 0.2), width=1.0, tick_size=0.05)\n",
        "        mu_line.rotate(PI / 2)\n",
        "        mu_line.to_corner(UR)\n",
        "        mu_indicator = Triangle(start_angle=0)\n",
        "        mu_indicator.set_width(0.15)\n",
        "        mu_indicator.set_fill(PINK, 1)\n",
        "        mu_indicator.set_stroke(width=0)\n",
        "        mu_tracker = ValueTracker(1)\n",
        "        mu_indicator.add_updater(lambda m: m.move_to(mu_line.n2p(mu_tracker.get_value()), RIGHT))\n",
        "        mu_label.add_updater(lambda m: m.next_to(mu_indicator, LEFT, buff=0.1))\n",
        "\n",
        "        for pkt in pkts:\n",
        "            pkt.set_value(0)\n",
        "        for at in ats:\n",
        "            at.set_value(1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(label, time_span=(0, 2)),\n",
        "            FlashAround(abs_words, color=PINK, time_span=(2, 4)),\n",
        "            abs_words.animate.set_color(PINK).set_anim_args(time_span=(2, 4)),\n",
        "            FadeIn(mu_line),\n",
        "            FadeIn(mu_indicator),\n",
        "            FadeIn(mu_label),\n",
        "            LaggedStart(*(\n",
        "                pkt.animate.set_value(self.kick_back_value)\n",
        "                for pkt in pkts\n",
        "            )),\n",
        "            LaggedStart(*(\n",
        "                at.animate.set_value(self.damping_per_layer)\n",
        "                for at in ats\n",
        "            )),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(layer, scale=0.8)\n",
        "                for layer in layers\n",
        "            )),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Play with mu\n",
        "        for mu in [0.1, 1.0]:\n",
        "            self.play(\n",
        "                mu_tracker.animate.set_value(mu),\n",
        "                *(at.animate.set_value(1 - mu * 2e-2) for at in ats),\n",
        "                run_time=3,\n",
        "            )\n",
        "\n",
        "        self.wait(17)\n",
        "\n",
        "\n",
        "class PlayWithIndex(RevertToOneLayerAtATime):\n",
        "    layer_xs = np.arange(-FRAME_WIDTH / 4, FRAME_WIDTH / 4, FRAME_WIDTH / 2**(10))\n",
        "\n",
        "    def construct(self):\n",
        "        # Objects\n",
        "        sliced_wave = self.sliced_wave\n",
        "        wave = sliced_wave.wave\n",
        "        layers = sliced_wave.layers\n",
        "        layers.set_stroke(BLUE, 1, 0.5)\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "\n",
        "        global_pk = ValueTracker(self.kick_back_value)\n",
        "        for pkt in pkts:\n",
        "            pkt.add_updater(lambda m: m.set_value(global_pk.get_value()))\n",
        "\n",
        "        def get_index():\n",
        "            return 1 - 20 * global_pk.get_value()\n",
        "\n",
        "        # equation label\n",
        "        equation = Tex(\n",
        "            R\"\"\"\n",
        "                \\text{Index of refraction } = \n",
        "                {\\small \\text{Speed in a vacuum} \\over \\text{Speed in medium}}\n",
        "                = 1.00\n",
        "            \"\"\",\n",
        "            t2c={\n",
        "                 R\"\\text{Speed in a vacuum}\": YELLOW,\n",
        "                 R\"\\text{Speed in medium}\": BLUE,\n",
        "            }\n",
        "        )\n",
        "        equation.next_to(layers, UP)\n",
        "        rhs = equation.make_number_changeable(\"1.00\")\n",
        "\n",
        "        rhs.add_updater(lambda m: m.set_value(get_index()))\n",
        "\n",
        "        arrow = Arrow(rhs.get_bottom(), layers.get_corner(UR) + 1.0 * DL)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.add(arrow)\n",
        "\n",
        "        # Speed label\n",
        "        speed_label = Tex(R\"\\text{Speed} = c / 1.00\")\n",
        "        speed_factor = speed_label.make_number_changeable(\"1.00\")\n",
        "        speed_factor.add_updater(lambda m: m.set_value(get_index()))\n",
        "        speed_label.next_to(layers.get_bottom(), UP)\n",
        "\n",
        "        self.add(speed_label)\n",
        "\n",
        "        # Change value\n",
        "        self.wait(3)\n",
        "        for value in [0, 0.02]:\n",
        "            self.play(global_pk.animate.set_value(value), run_time=2)\n",
        "            self.wait(3)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class RedLight(RevertToOneLayerAtATime):\n",
        "    wave_config = dict(\n",
        "        color=RED,\n",
        "        stroke_width=6,\n",
        "        sample_resolution=0.001,\n",
        "        wave_len=4.0,\n",
        "    )\n",
        "    kick_back_value = -0.005\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        sliced_wave = self.sliced_wave\n",
        "        wave = sliced_wave.wave\n",
        "        layers = sliced_wave.layers\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "        sliced_wave.update()\n",
        "        sliced_wave.clear_updaters()\n",
        "        sliced_wave.vect_wave.set_stroke(opacity=1)\n",
        "        sliced_wave.wave.make_jagged()\n",
        "\n",
        "        new_wave = VMobject()\n",
        "        new_wave.set_points_smoothly(sliced_wave.wave.get_anchors()[0::5])\n",
        "        new_wave.match_style(sliced_wave.wave)\n",
        "\n",
        "        self.add(self.sliced_wave)\n",
        "        self.add(new_wave)\n",
        "        self.remove(sliced_wave.layers)\n",
        "\n",
        "\n",
        "class XRay(RedLight):\n",
        "    wave_config = dict(\n",
        "        color=YELLOW,\n",
        "        stroke_width=6,\n",
        "        sample_resolution=0.001,\n",
        "        wave_len=1.0,\n",
        "    )\n",
        "    kick_back_value = 0.02\n",
        "\n",
        "\n",
        "class DissolveLayers(PhaseKickBacks):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        sliced_wave = self.sliced_wave\n",
        "        layers = sliced_wave.layers\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "\n",
        "        # Zoom in on layers\n",
        "        frame = self.frame\n",
        "        layers_copy = layers.copy()\n",
        "        layers_copy.set_stroke(width=1)\n",
        "        fade_rect = FullScreenRectangle().set_fill(BLACK, 1)\n",
        "\n",
        "        self.wait(4)\n",
        "        self.add(fade_rect, layers_copy)\n",
        "        self.play(\n",
        "            frame.animate.scale(0.2).move_to(layers).set_anim_args(run_time=4),\n",
        "            FadeIn(fade_rect, time_span=(1, 3)),\n",
        "            FadeIn(layers_copy, time_span=(1, 3)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.to_default_state().set_anim_args(run_time=2),\n",
        "            FadeOut(fade_rect),\n",
        "            FadeOut(layers_copy),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Dissolve\n",
        "        kw = dict(run_time=8, lag_ratio=0.1)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                layer.animate().set_stroke(WHITE, 2, 0).set_height(5)\n",
        "                for layer in layers[:0:-1]\n",
        "            ), **kw),\n",
        "            LaggedStart(*(\n",
        "                pkt.animate.set_value(0)\n",
        "                for pkt in pkts[:0:-1]\n",
        "            ), **kw),\n",
        "            layers[0].animate.set_stroke(WHITE, 2).set_height(5).set_anim_args(time_span=(7, 8))\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class IntroducePhaseKickBack(PhaseKickBacks):\n",
        "    layer_xs = np.arange(0, 8, PI / 4)\n",
        "    vect_wave_style = dict(stroke_width=0)\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up sine wave\n",
        "        sliced_wave = self.sliced_wave\n",
        "        axes = sliced_wave.axes\n",
        "        layers = sliced_wave.layers\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "        wave = sliced_wave.wave\n",
        "\n",
        "        self.remove(sliced_wave)\n",
        "        wave.stop_clock()\n",
        "        self.add(wave)\n",
        "        self.add(*pkts)\n",
        "\n",
        "        # # Pair of braces\n",
        "        # brace1 = Brace(Line(LEFT_SIDE, ORIGIN, buff=0.25), UP)\n",
        "        # brace2 = brace1.copy().set_x(FRAME_WIDTH / 4)\n",
        "        # braces = VGroup(brace1, brace2)\n",
        "        # braces.set_y(2)\n",
        "        # self.add(braces)\n",
        "\n",
        "        # b1_tex = brace1.get_tex(R\"\\sin(\\omega t - kx)\")\n",
        "        # b2_tex = brace2.get_tex(R\"\\sin(\\omega t - kx - \\Delta \\phi)\")\n",
        "\n",
        "        # self.add(b1_tex)\n",
        "        # self.add(b2_tex)\n",
        "\n",
        "        # Add one layer of material\n",
        "        self.play(GrowFromCenter(layers[0])) # TODO: Some kind of labels here?\n",
        "\n",
        "        # Show small kick back\n",
        "        arrow = Vector(2 * LEFT, stroke_width=8)\n",
        "        arrow.next_to(wave, UP, buff=0.75)\n",
        "        arrow.set_x(0, LEFT).shift(0.5 * RIGHT)\n",
        "        phase_kick = -0.5\n",
        "\n",
        "        self.play(\n",
        "            pkts[0].animate.set_value(phase_kick),\n",
        "            FadeIn(arrow, LEFT),\n",
        "        )\n",
        "        self.play(FadeOut(arrow))\n",
        "\n",
        "        # Add more layers of material\n",
        "        for layer, pkt in zip(layers[1:], pkts[1:]):\n",
        "            arrow.align_to(layer, LEFT).shift(0.25 * RIGHT)\n",
        "            self.play(\n",
        "                GrowFromCenter(layer),\n",
        "                FadeIn(arrow, LEFT),\n",
        "                pkt.animate.set_value(phase_kick),\n",
        "            )\n",
        "            self.play(FadeOut(arrow), run_time=0.5)\n",
        "\n",
        "        # Make it all more dense\n",
        "        pass\n",
        "\n",
        "\n",
        "class PhaseKickBackAddInLayers(PhaseKickBacks):\n",
        "    n_layers = 10\n",
        "    kick_back_value = 0\n",
        "    target_kick_back = -0.5\n",
        "\n",
        "    def get_layer_xs(self):\n",
        "        return np.linspace(0, 8, self.n_layers)\n",
        "\n",
        "    def construct(self):\n",
        "        sliced_wave = self.sliced_wave\n",
        "        lag_kw = dict(run_time=self.layer_add_on_run_time, lag_ratio=0.5)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeIn(line, 0.5 * DOWN)\n",
        "                for line in sliced_wave.layers\n",
        "            ), **lag_kw),\n",
        "            LaggedStart(*(\n",
        "                pkt.animate.set_value(self.target_kick_back)\n",
        "                for pkt in sliced_wave.phase_kick_trackers\n",
        "            ), **lag_kw),\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class DensePhaseKickBacks25(PhaseKickBackAddInLayers):\n",
        "    n_layers = 25\n",
        "    target_kick_back = -0.4\n",
        "    line_style = dict(\n",
        "        stroke_width=1.0,\n",
        "        stroke_color=BLUE_B,\n",
        "    )\n",
        "\n",
        "\n",
        "class DensePhaseKickBacks50(PhaseKickBackAddInLayers):\n",
        "    n_layers = 50\n",
        "    target_kick_back = -0.2\n",
        "    line_style = dict(\n",
        "        stroke_width=1.0,\n",
        "        stroke_color=BLUE_B,\n",
        "    )\n",
        "\n",
        "\n",
        "class DensePhaseKickBacks100(PhaseKickBackAddInLayers):\n",
        "    n_layers = 100\n",
        "    target_kick_back = -0.15\n",
        "    line_style = dict(\n",
        "        stroke_width=1.5,\n",
        "        stroke_color=BLUE_C,\n",
        "        stroke_opacity=0.7,\n",
        "    )\n",
        "    layer_add_on_run_time = 10\n",
        "\n",
        "\n",
        "class FastWave(PhaseKickBacks):\n",
        "    layer_xs = np.arange(-3, 3, 0.01)\n",
        "    kick_back_value = 0.01\n",
        "    line_style = dict(\n",
        "        stroke_width=1,\n",
        "        stroke_opacity=0.35,\n",
        "        stroke_color=BLUE_D\n",
        "    )\n",
        "    wave_config = dict(\n",
        "        color=YELLOW,\n",
        "        sample_resolution=0.001\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class KickForward(PhaseKickBacks):\n",
        "    layer_xs = np.arange(0, 8, 0.25)\n",
        "    kick_back_value = 0.25\n",
        "    line_style = dict(\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=2,\n",
        "        stroke_opacity=0.75,\n",
        "    )\n",
        "    wave_config = dict(\n",
        "        color=YELLOW,\n",
        "        sample_resolution=0.001\n",
        "    )\n",
        "    time_per_layer = 0.25\n",
        "\n",
        "    def construct(self):\n",
        "        # Objects\n",
        "        sliced_wave = self.sliced_wave\n",
        "        wave = sliced_wave.wave\n",
        "        layers = sliced_wave.layers\n",
        "        layers.stretch(1.2, 1)\n",
        "        pkts = sliced_wave.phase_kick_trackers\n",
        "\n",
        "        # Just show one layer\n",
        "        layer_label = Text(\"Thin layer of material\")\n",
        "        layer_label.next_to(layers[0], UP, buff=0.75)\n",
        "\n",
        "        for pkt in pkts:\n",
        "            pkt.set_value(0)\n",
        "\n",
        "        self.wait(1 - (wave.time % 1))\n",
        "        wave.stop_clock()\n",
        "        self.remove(layers)\n",
        "        self.play(\n",
        "            ShowCreation(layers[0]),\n",
        "            FadeIn(layer_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Kick back then forth\n",
        "        kick_back = VGroup(\n",
        "            Vector(LEFT, stroke_width=6),\n",
        "            Text(\"Kick back\\nthe phase\", font_size=36),\n",
        "        )\n",
        "        kick_back.set_color(RED)\n",
        "        kick_forward = VGroup(\n",
        "            Vector(RIGHT, stroke_width=6),\n",
        "            Text(\n",
        "                \"Kick forward\\nthe phase\", font_size=36,\n",
        "                t2s={\"forward\": ITALIC}\n",
        "            ),\n",
        "        )\n",
        "        kick_forward.set_color(GREEN)\n",
        "\n",
        "        for label in [kick_back, kick_forward]:\n",
        "            label.arrange(RIGHT)\n",
        "            label.next_to(wave, UP)\n",
        "            label.align_to(layers[0], LEFT).shift(MED_SMALL_BUFF * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            pkts[0].animate.set_value(-0.75),\n",
        "            FadeIn(kick_back, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(kick_back))\n",
        "        self.play(\n",
        "            pkts[0].animate.set_value(self.kick_back_value),\n",
        "            FadeIn(kick_forward, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(layer_label))\n",
        "\n",
        "        # Add other layers\n",
        "        wave.start_clock()\n",
        "        remaining_layers = layers[1:]\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(remaining_layers, rate_func=linear),\n",
        "            UpdateFromFunc(\n",
        "                kick_forward,\n",
        "                lambda m: m.align_to(remaining_layers.get_right(), LEFT).shift(MED_SMALL_BUFF * RIGHT),\n",
        "            ),\n",
        "            LaggedStart(*(\n",
        "                pkt.animate.set_value(self.kick_back_value)\n",
        "                for pkt in pkts[1:]\n",
        "            ), lag_ratio=1),\n",
        "            run_time = len(remaining_layers) * self.time_per_layer\n",
        "        )\n",
        "\n",
        "        # Wait\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class DenserKickForward(KickForward):  # Run at 9\n",
        "    layer_xs = np.arange(0, 8, 0.1)\n",
        "    kick_back_value = 0.1\n",
        "    line_style = dict(\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=1.5,\n",
        "        stroke_opacity=0.75,\n",
        "    )\n",
        "    time_per_layer = 0.1\n",
        "\n",
        "\n",
        "class DensestKickForward(DenserKickForward):\n",
        "    layer_xs = np.arange(0, 8, 0.025)\n",
        "    kick_back_value = 0.025\n",
        "    time_per_layer = 0.025\n",
        "    line_style = dict(\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=1.0,\n",
        "        stroke_opacity=0.65,\n",
        "    )\n"
    ]
}