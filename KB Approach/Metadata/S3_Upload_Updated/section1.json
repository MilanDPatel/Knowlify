{
    "topic": "The mathematical concept being demonstrated is the infinite sum of the reciprocals of squares of natural numbers",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "import displayer as disp\n",
        "\n",
        "from hilbert.curves import \\\n",
        "    TransformOverIncreasingOrders, FlowSnake, HilbertCurve, \\\n",
        "    SnakeCurve\n",
        "\n",
        "\n",
        "from constants import *\n",
        "\n",
        "\n",
        "\n",
        "def get_grid():\n",
        "    return Grid(64, 64)\n",
        "\n",
        "def get_freq_line():\n",
        "    return UnitInterval().shift(2*DOWN) ##Change?\n",
        "\n",
        "def get_mathy_and_bubble():\n",
        "    mathy = Mathematician()\n",
        "    mathy.to_edge(DOWN).shift(4*LEFT)\n",
        "    bubble = SpeechBubble(initial_width = 8)\n",
        "    bubble.pin_to(mathy)\n",
        "    return mathy, bubble\n",
        "\n",
        "class AboutSpaceFillingCurves(TransformOverIncreasingOrders):\n",
        "    @staticmethod\n",
        "    def args_to_string():\n",
        "        return \"\"\n",
        "\n",
        "    @staticmethod\n",
        "    def string_to_args(arg_str):\n",
        "        return ()\n",
        "\n",
        "    def construct(self):\n",
        "        self.bubble = ThoughtBubble().ingest_submobjects()\n",
        "        self.bubble.scale(1.5)\n",
        "\n",
        "        TransformOverIncreasingOrders.construct(self, FlowSnake, 7)\n",
        "        self.play(Transform(self.curve, self.bubble))\n",
        "        self.show_infinite_objects()\n",
        "        self.pose_question()\n",
        "        self.wait()\n",
        "\n",
        "    def show_infinite_objects(self):\n",
        "        sigma, summand, equals, result = OldTex([\n",
        "            \"\\\\sum_{n = 1}^{\\\\infty}\",\n",
        "            \"\\\\dfrac{1}{n^2}\",\n",
        "            \"=\",\n",
        "            \"\\\\dfrac{\\pi^2}{6}\"\n",
        "        ]).split()\n",
        "        alt_summand = OldTex(\"n\").replace(summand)\n",
        "        alt_result = OldTex(\"-\\\\dfrac{1}{12}\").replace(result)\n",
        "\n",
        "        rationals, other_equals, naturals = OldTex([\n",
        "            \"|\\\\mathds{Q}|\",\n",
        "            \"=\",\n",
        "            \"|\\\\mathds{N}|\"\n",
        "        ]).scale(2).split()\n",
        "        infinity = OldTex(\"\\\\infty\").scale(2)\n",
        "        local_mobjects = list(filter(\n",
        "            lambda m : isinstance(m, Mobject),\n",
        "            list(locals().values()),\n",
        "        ))\n",
        "        for mob in local_mobjects:    \n",
        "            mob.sort_points(get_norm)\n",
        "\n",
        "        self.play(ShimmerIn(infinity))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(summand),\n",
        "            ShimmerIn(equals),\n",
        "            ShimmerIn(result),\n",
        "            DelayByOrder(Transform(infinity, sigma))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(summand, alt_summand),\n",
        "            Transform(result, alt_result),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(infinity)\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(\n",
        "                Mobject(summand, equals, result, sigma),\n",
        "                Mobject(rationals, other_equals, naturals)\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(self.bubble)\n",
        "\n",
        "    def pose_question(self):\n",
        "        infinity, rightarrow, N = OldTex([\n",
        "            \"\\\\infty\", \"\\\\rightarrow\", \"N\"\n",
        "        ]).scale(2).split()\n",
        "        question_mark = OldTexText(\"?\").scale(2)\n",
        "\n",
        "        self.add(question_mark)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ShimmerIn(mob)\n",
        "            for mob in (infinity, rightarrow, N)\n",
        "        ] + [\n",
        "            ApplyMethod(question_mark.next_to, rightarrow, UP),\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class PostponePhilosophizing(Scene):\n",
        "    def construct(self):\n",
        "        abstract, arrow, concrete = OldTexText([\n",
        "            \"Abstract\", \" $\\\\rightarrow$ \", \"Concrete\"\n",
        "        ]).scale(2).split()\n",
        "\n",
        "        self.add(abstract, arrow, concrete)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                word1.replace, word2,\n",
        "                path_func = path_along_arc(np.pi/2)\n",
        "            )\n",
        "            for word1, word2 in it.permutations([abstract, concrete])\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GrowHilbertWithName(Scene):\n",
        "    def construct(self):\n",
        "        curve = HilbertCurve(order = 1)\n",
        "        words = OldTexText(\"``Hilbert Curve''\")\n",
        "        words.to_edge(UP, buff = 0.2)\n",
        "        self.play(\n",
        "            ShimmerIn(words),\n",
        "            Transform(curve, HilbertCurve(order = 2)),\n",
        "            run_time = 2\n",
        "        )\n",
        "        for n in range(3, 8):\n",
        "            self.play(\n",
        "                Transform(curve, HilbertCurve(order = n)),\n",
        "                run_time = 5. /n\n",
        "            )\n",
        "\n",
        "\n",
        "class SectionOne(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Section 1: Seeing with your ears\"))\n",
        "        self.wait()\n",
        "\n",
        "class WriteSomeSoftware(Scene):\n",
        "    pass #Done viea screen capture, written here for organization\n",
        "\n",
        "\n",
        "\n",
        "class ImageToSound(Scene):\n",
        "    def construct(self):\n",
        "        string = Vibrate(color = BLUE_D, run_time = 5)\n",
        "        picture = ImageMobject(\"lion\", invert = False)\n",
        "        picture.scale(0.8)\n",
        "        picture_copy = picture.copy()\n",
        "        picture.sort_points(get_norm)\n",
        "        string.mobject.sort_points(lambda p : -get_norm(p))\n",
        "\n",
        "        self.add(picture)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            picture, string.mobject,\n",
        "            run_time = 3,\n",
        "            rate_func = rush_into\n",
        "        ))\n",
        "        self.remove(picture)\n",
        "        self.play(string)\n",
        "\n",
        "        for mob in picture_copy, string.mobject:\n",
        "            mob.sort_points(lambda p : get_norm(p)%1)\n",
        "\n",
        "        self.play(Transform(\n",
        "            string.mobject, picture_copy,\n",
        "            run_time = 5,\n",
        "            rate_func = rush_from\n",
        "        ))\n",
        "\n",
        "class LinksInDescription(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"\"\"\n",
        "            See links in the description for more on\n",
        "            sight via sound.\n",
        "        \"\"\")\n",
        "        self.play(ShimmerIn(text))\n",
        "        self.play(ShowCreation(Arrow(text, 3*DOWN)))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ImageDataIsTwoDimensional(Scene):\n",
        "    def construct(self):\n",
        "        image = ImageMobject(\"lion\", invert = False)\n",
        "        image.scale(0.5)\n",
        "        image.shift(2*LEFT)\n",
        "\n",
        "        self.add(image)\n",
        "        for vect, num in zip([DOWN, RIGHT], [1, 2]):\n",
        "            brace = Brace(image, vect)\n",
        "            words_mob = OldTexText(\"Dimension %d\"%num)\n",
        "            words_mob.next_to(image, vect, buff = 1)\n",
        "            self.play(\n",
        "                Transform(Point(brace.get_center()), brace),\n",
        "                ShimmerIn(words_mob), \n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SoundDataIsOneDimensional(Scene):\n",
        "    def construct(self):\n",
        "        overtones = 5\n",
        "        floor = 2*DOWN\n",
        "        main_string = Vibrate(color = BLUE_D)\n",
        "        component_strings = [\n",
        "            Vibrate(\n",
        "                num_periods = k+1,\n",
        "                overtones = 1,\n",
        "                color = color,\n",
        "                center = 2*DOWN + UP*k\n",
        "            )\n",
        "            for k, color in zip(\n",
        "                list(range(overtones)),\n",
        "                Color(BLUE_E).range_to(WHITE, overtones)\n",
        "            )\n",
        "        ]\n",
        "        dots = [\n",
        "            Dot(\n",
        "                string.mobject.get_center(),\n",
        "                color = string.mobject.get_color()\n",
        "            )\n",
        "            for string in component_strings\n",
        "        ]\n",
        "\n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.shift(floor)\n",
        "        freq_line.sort_points(get_norm)\n",
        "        brace = Brace(freq_line, UP)\n",
        "        words = OldTexText(\"Range of frequency values\")\n",
        "        words.next_to(brace, UP)\n",
        "\n",
        "\n",
        "        self.play(*[\n",
        "            TransformAnimations(\n",
        "                main_string.copy(),\n",
        "                string,\n",
        "                run_time = 5\n",
        "            )\n",
        "            for string in component_strings\n",
        "        ])\n",
        "        self.clear()\n",
        "        self.play(*[\n",
        "            TransformAnimations(\n",
        "                string,\n",
        "                Animation(dot)\n",
        "            )\n",
        "            for string, dot in zip(component_strings, dots)\n",
        "        ])\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            ShowCreation(freq_line),\n",
        "            GrowFromCenter(brace),\n",
        "            ShimmerIn(words),\n",
        "            *[\n",
        "                Transform(\n",
        "                    dot,\n",
        "                    dot.copy().scale(2).rotate(-np.pi/2).shift(floor),\n",
        "                    path_func = path_along_arc(np.pi/3)\n",
        "                )\n",
        "                for dot in dots\n",
        "            ]\n",
        "        )\n",
        "        self.wait(0.5)\n",
        "\n",
        "class GridOfPixels(Scene):\n",
        "    def construct(self):\n",
        "        low_res = ImageMobject(\"low_resolution_lion\", invert = False)\n",
        "        high_res = ImageMobject(\"Lion\", invert = False)\n",
        "        grid = get_grid().scale(0.8)\n",
        "        for mob in low_res, high_res:\n",
        "            mob.replace(grid, stretch = True)\n",
        "        side_brace = Brace(low_res, LEFT)\n",
        "        top_brace = Brace(low_res, UP)\n",
        "        top_words = OldTexText(\"256 Px\", size = \"\\\\normal\")\n",
        "        side_words = top_words.copy().rotate(np.pi/2)\n",
        "        top_words.next_to(top_brace, UP)\n",
        "        side_words.next_to(side_brace, LEFT)\n",
        "\n",
        "        self.add(high_res)\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(Transform(high_res, low_res)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(top_brace),\n",
        "            GrowFromCenter(side_brace),\n",
        "            ShimmerIn(top_words),\n",
        "            ShimmerIn(side_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        for mob in grid, high_res:\n",
        "            mob.sort_points(get_norm)\n",
        "        self.play(DelayByOrder(Transform(high_res, grid)))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowFrequencySpace(Scene):\n",
        "    def construct(self):\n",
        "        freq_line = get_freq_line()\n",
        "\n",
        "        self.add(freq_line)\n",
        "        self.wait()\n",
        "        for tex, vect in zip([\"20 Hz\", \"20{,}000 Hz\"], [LEFT, RIGHT]):\n",
        "            tex_mob = OldTexText(tex)\n",
        "            tex_mob.to_edge(vect)\n",
        "            tex_mob.shift(UP)\n",
        "            arrow = Arrow(tex_mob, freq_line.get_edge_center(vect))\n",
        "            self.play(\n",
        "                ShimmerIn(tex_mob),\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class AssociatePixelWithFrequency(Scene):\n",
        "    def construct(self):\n",
        "        big_grid_dim = 20.\n",
        "        small_grid_dim = 6.\n",
        "        big_grid = Grid(64, 64, height = big_grid_dim, width = big_grid_dim)\n",
        "        big_grid.to_corner(UP+RIGHT, buff = 2)\n",
        "        small_grid = big_grid.copy()\n",
        "        small_grid.scale(small_grid_dim/big_grid_dim)\n",
        "        small_grid.center()\n",
        "        pixel = MobjectFromRegion(\n",
        "            region_from_polygon_vertices(*0.2*np.array([\n",
        "                RIGHT+DOWN,\n",
        "                RIGHT+UP,\n",
        "                LEFT+UP,\n",
        "                LEFT+DOWN\n",
        "            ]))\n",
        "        )\n",
        "        pixel.set_color(WHITE)\n",
        "        pixel_width = big_grid.width/big_grid.columns\n",
        "        pixel.set_width(pixel_width)\n",
        "        pixel.to_corner(UP+RIGHT, buff = 2)\n",
        "        pixel.shift(5*pixel_width*(2*LEFT+DOWN))\n",
        "\n",
        "        freq_line = get_freq_line()\n",
        "        dot = Dot()\n",
        "        dot.shift(freq_line.get_center() + 2*RIGHT)\n",
        "        string = Line(LEFT, RIGHT, color = GREEN)\n",
        "        arrow = Arrow(dot, string.get_center())\n",
        "        vibration_config = {\n",
        "            \"overtones\"      : 1,\n",
        "            \"spatial_period\" : 2,\n",
        "        }\n",
        "        vibration, loud_vibration, quiet_vibration = [\n",
        "            Vibrate(string.copy(), amplitude = a, **vibration_config)\n",
        "            for a in [0.5, 1., 0.25]\n",
        "        ]\n",
        "\n",
        "        self.add(small_grid)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(small_grid, big_grid)\n",
        "        )\n",
        "        self.play(FadeIn(pixel))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(small_grid),            \n",
        "            ShowCreation(freq_line)\n",
        "        )\n",
        "        self.remove(small_grid)\n",
        "        self.play(\n",
        "            Transform(pixel, dot),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(loud_vibration)\n",
        "        self.play(\n",
        "            TransformAnimations(loud_vibration, quiet_vibration),            \n",
        "            ApplyMethod(dot.fade, 0.9)\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(freq_line, dot, arrow)\n",
        "        self.play(quiet_vibration)\n",
        "\n",
        "\n",
        "class ListenToAllPixels(Scene):\n",
        "    def construct(self):\n",
        "        grid = get_grid()\n",
        "        grid.sort_points(get_norm)        \n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.sort_points(lambda p : p[0])\n",
        "        red, blue = Color(RED), Color(BLUE)\n",
        "        freq_line.set_color_by_gradient(red, blue)\n",
        "\n",
        "        colors = [\n",
        "            Color(rgb = interpolate(\n",
        "                np.array(red.rgb),\n",
        "                np.array(blue.rgb),\n",
        "                alpha\n",
        "            ))\n",
        "            for alpha in np.arange(4)/3.\n",
        "        ]\n",
        "        string = Line(3*LEFT, 3*RIGHT, color = colors[1])\n",
        "        vibration = Vibrate(string)\n",
        "        vibration_copy = vibration.copy()\n",
        "        vibration_copy.mobject.stroke_width = 1\n",
        "        sub_vibrations = [\n",
        "            Vibrate(\n",
        "                string.copy().shift((n-1)*UP).set_color(colors[n]),\n",
        "                overtones = 1,\n",
        "                spatial_period = 6./(n+1),\n",
        "                temporal_period = 1./(n+1),\n",
        "                amplitude = 0.5/(n+1)\n",
        "            )\n",
        "            for n in range(4)\n",
        "        ]\n",
        "        words = OldTex(\"&\\\\vdots \\\\\\\\ \\\\text{thousands }& \\\\text{of frequencies} \\\\\\\\ &\\\\vdots\")\n",
        "        words.to_edge(UP, buff = 0.1)\n",
        "\n",
        "        self.add(grid)\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(ApplyMethod(\n",
        "            grid.set_color_by_gradient, red, blue\n",
        "        )))\n",
        "        self.play(Transform(grid, freq_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(\n",
        "                words,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.2)\n",
        "            ),\n",
        "            *sub_vibrations,\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.play(\n",
        "            *[\n",
        "                TransformAnimations(\n",
        "                    sub_vib, vibration\n",
        "                )\n",
        "                for sub_vib in sub_vibrations\n",
        "            ]+[FadeOut(words)]\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(freq_line)\n",
        "        self.play(vibration)\n",
        "\n",
        "\n",
        "class LayAsideSpeculation(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Would this actually work?\")\n",
        "        grid = get_grid()\n",
        "        grid.set_width(6)\n",
        "        grid.to_edge(LEFT)\n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.set_width(6)\n",
        "        freq_line.center().to_edge(RIGHT)\n",
        "        mapping = Mobject(\n",
        "            grid, freq_line, Arrow(grid, freq_line)\n",
        "        )\n",
        "        mapping.ingest_submobjects()\n",
        "        lower_left = Point().to_corner(DOWN+LEFT, buff = 0)\n",
        "        lower_right = Point().to_corner(DOWN+RIGHT, buff = 0)\n",
        "\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(words, lower_right),\n",
        "            Transform(lower_left, mapping)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RandomMapping(Scene):\n",
        "    def construct(self):\n",
        "        grid = get_grid()\n",
        "        grid.set_width(6)\n",
        "        grid.to_edge(LEFT)\n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.set_width(6)\n",
        "        freq_line.center().to_edge(RIGHT)\n",
        "        # for mob in grid, freq_line:\n",
        "        #     indices = np.arange(mob.get_num_points())\n",
        "        #     random.shuffle(indices)\n",
        "        #     mob.points = mob.get_points()[indices]\n",
        "        stars = Stars(stroke_width = grid.stroke_width)\n",
        "\n",
        "        self.add(grid)\n",
        "        targets = [stars, freq_line]\n",
        "        alphas = [not_quite_there(rush_into), rush_from]\n",
        "        for target, rate_func in zip(targets, alphas):\n",
        "            self.play(Transform(\n",
        "                grid, target,\n",
        "                run_time = 3,\n",
        "                rate_func = rate_func,\n",
        "                path_func = path_along_arc(-np.pi/2)\n",
        "            ))\n",
        "        self.wait()\n",
        "        \n",
        "\n",
        "\n",
        "class DataScrambledAnyway(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Data is scrambled anyway, right?\"))\n",
        "        self.wait()\n",
        "        \n",
        "\n",
        "class LeverageExistingIntuitions(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Leverage existing intuitions\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ThinkInTermsOfReverseMapping(Scene):\n",
        "    def construct(self):\n",
        "        grid = get_grid()\n",
        "        grid.set_width(6)\n",
        "        grid.to_edge(LEFT)\n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.set_width(6)\n",
        "        freq_line.center().to_edge(RIGHT)\n",
        "        arrow =  Arrow(grid, freq_line)\n",
        "\n",
        "        color1, color2 = YELLOW_C, RED\n",
        "        square_length = 0.01\n",
        "        dot1 = Dot(color = color1)\n",
        "        dot1.shift(3*RIGHT)\n",
        "        dot2 = Dot(color = color2)\n",
        "        dot2.shift(3.1*RIGHT)\n",
        "        arrow1 = Arrow(2*RIGHT+UP, dot1, color = color1, buff = 0.1)\n",
        "        arrow2 = Arrow(4*RIGHT+UP, dot2, color = color2, buff = 0.1)\n",
        "        dot3, arrow3 = [\n",
        "            mob.copy().shift(5*LEFT+UP)\n",
        "            for mob in (dot1, arrow1)\n",
        "        ]\n",
        "        dot4, arrow4 = [\n",
        "            mob.copy().shift(5*LEFT+0.9*UP)\n",
        "            for mob in (dot2, arrow2)\n",
        "        ]\n",
        "\n",
        "        self.add(grid, freq_line, arrow)\n",
        "        self.wait()\n",
        "        self.play(ApplyMethod(\n",
        "            arrow.rotate, np.pi, \n",
        "            path_func = clockwise_path()\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow1))\n",
        "        self.add(dot1)\n",
        "        self.play(ShowCreation(arrow2))\n",
        "        self.add(dot2)\n",
        "        self.wait()\n",
        "        self.remove(arrow1, arrow2)\n",
        "        self.play(\n",
        "            Transform(dot1, dot3),\n",
        "            Transform(dot2, dot4)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(grid.fade, 0.8),\n",
        "            Animation(Mobject(dot3, dot4))\n",
        "        )\n",
        "        self.play(ShowCreation(arrow3))\n",
        "        self.play(ShowCreation(arrow4))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WeaveLineThroughPixels(Scene):\n",
        "    @staticmethod\n",
        "    def args_to_string(order):\n",
        "        return str(order)\n",
        "        \n",
        "    @staticmethod\n",
        "    def string_to_args(order_str):\n",
        "        return int(order_str)\n",
        "\n",
        "    def construct(self, order):\n",
        "        start_color, end_color = RED, GREEN\n",
        "        curve = HilbertCurve(order = order)\n",
        "        line = Line(5*LEFT, 5*RIGHT)\n",
        "        for mob in curve, line:\n",
        "            mob.set_color_by_gradient(start_color, end_color)\n",
        "        freq_line = get_freq_line()\n",
        "        freq_line.replace(line, stretch = True)\n",
        "\n",
        "        unit = 6./(2**order) #sidelength of pixel\n",
        "        up = unit*UP\n",
        "        right = unit*RIGHT\n",
        "        lower_left = 3*(LEFT+DOWN)\n",
        "        squares = Mobject(*[\n",
        "            Square(\n",
        "                side_length = unit, \n",
        "                color = WHITE\n",
        "            ).shift(x*right+y*up)\n",
        "            for x, y in it.product(list(range(2**order)), list(range(2**order)))\n",
        "        ])\n",
        "        squares.center()\n",
        "        targets = Mobject()\n",
        "        for square in squares.submobjects:\n",
        "            center = square.get_center()\n",
        "            distances = np.apply_along_axis(\n",
        "                lambda p : get_norm(p-center),\n",
        "                1,\n",
        "                curve.points\n",
        "            )\n",
        "            index_along_curve = np.argmin(distances)\n",
        "            fraction_along_curve = index_along_curve/float(curve.get_num_points())\n",
        "            target = square.copy().center().scale(0.8/(2**order))\n",
        "            line_index = int(fraction_along_curve*line.get_num_points())\n",
        "            target.shift(line.get_points()[line_index])\n",
        "            targets.add(target)\n",
        "\n",
        "\n",
        "        self.add(squares)\n",
        "        self.play(ShowCreation(\n",
        "            curve,\n",
        "            run_time = 5, \n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(curve, line),\n",
        "            Transform(squares, targets),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(freq_line))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WellPlayedGameOfSnake(Scene):\n",
        "    def construct(self):\n",
        "        grid = Grid(16, 16).fade()\n",
        "        snake_curve = SnakeCurve(order = 4)\n",
        "        words = OldTexText(\"``Snake Curve''\")\n",
        "        words.next_to(grid, UP)\n",
        "\n",
        "        self.add(grid)\n",
        "        self.play(ShowCreation(\n",
        "            snake_curve,\n",
        "            run_time = 7, \n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TellMathematicianFriend(Scene):\n",
        "    def construct(self):\n",
        "        mathy, bubble = get_mathy_and_bubble()\n",
        "        squiggle_mouth = mathy.mouth.copy()\n",
        "        squiggle_mouth.apply_function(\n",
        "            lambda x_y_z : (x_y_z[0], x_y_z[1]+0.02*np.sin(50*x_y_z[0]), x_y_z[2])\n",
        "        )\n",
        "        bubble.ingest_submobjects()        \n",
        "        bubble.write(\"Why not use a Hilbert curve \\\\textinterrobang \")\n",
        "        words1 = bubble.content\n",
        "        bubble.write(\"So, it's not one curve but an infinite family of curves \\\\dots\")\n",
        "        words2 = bubble.content\n",
        "        bubble.write(\"Well, no, it \\\\emph{is} just one thing, but I need \\\\\\\\ \\\n",
        "                      to tell you about a certain infinite family first.\")\n",
        "        words3 =  bubble.content\n",
        "        description = OldTexText(\"Mathematician friend\", size = \"\\\\small\")\n",
        "        description.next_to(mathy, buff = 2)\n",
        "        arrow = Arrow(description, mathy)\n",
        "\n",
        "        self.add(mathy)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            ShimmerIn(description)\n",
        "        )\n",
        "        self.wait()\n",
        "        point = Point(bubble.get_tip())\n",
        "        self.play(\n",
        "            Transform(point, bubble),\n",
        "        )\n",
        "        self.remove(point)\n",
        "        self.add(bubble)\n",
        "        self.play(ShimmerIn(words1))\n",
        "        self.wait()\n",
        "        self.remove(description, arrow)\n",
        "        self.play(\n",
        "            Transform(mathy.mouth, squiggle_mouth),\n",
        "            ApplyMethod(mathy.arm.wag, 0.2*RIGHT, LEFT),\n",
        "        )\n",
        "        self.remove(words1)\n",
        "        self.add(words2)\n",
        "        self.wait(2)\n",
        "        self.remove(words2)\n",
        "        self.add(words3)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ApplyPointwiseFunction(\n",
        "                lambda p : 15*p/get_norm(p),\n",
        "                bubble\n",
        "            ),\n",
        "            ApplyMethod(mathy.shift, 5*(DOWN+LEFT)),\n",
        "            FadeOut(words3),\n",
        "            run_time = 3\n",
        "        )\n",
        "\n",
        "\n",
        "class Order1PseudoHilbertCurve(Scene):\n",
        "    def construct(self):\n",
        "        words, s = OldTexText([\"Pseudo-Hilbert Curve\", \"s\"]).split()\n",
        "        pre_words = OldTexText(\"Order 1\")\n",
        "        pre_words.next_to(words, LEFT, buff = 0.5)\n",
        "        s.next_to(words, RIGHT, buff = 0.05, aligned_edge = DOWN)\n",
        "        cluster = Mobject(pre_words, words, s)\n",
        "        cluster.center()\n",
        "        cluster.scale(0.7)\n",
        "        cluster.to_edge(UP, buff = 0.3)\n",
        "        cluster.set_color(GREEN)\n",
        "        grid1 = Grid(1, 1)\n",
        "        grid2 = Grid(2, 2)\n",
        "        curve = HilbertCurve(order = 1)\n",
        "\n",
        "        self.add(words, s)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            s, pre_words, \n",
        "            path_func = path_along_arc(-np.pi/3)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(grid1))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(grid2))\n",
        "        self.wait()\n",
        "        kwargs = {\n",
        "            \"run_time\" : 5,\n",
        "            \"rate_func\" : None\n",
        "        }\n",
        "        self.play(ShowCreation(curve, **kwargs))\n",
        "        self.wait()\n",
        "\n",
        "class Order2PseudoHilbertCurve(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Order 2 Pseudo-Hilbert Curve\")\n",
        "        words.to_edge(UP, buff = 0.3)\n",
        "        words.set_color(GREEN)\n",
        "        grid2 = Grid(2, 2)\n",
        "        grid4 = Grid(4, 4, stroke_width = 2)\n",
        "        # order_1_curve = HilbertCurve(order = 1)\n",
        "        # squaggle_curve = order_1_curve.copy().apply_function(\n",
        "        #     lambda (x, y, z) : (x + np.cos(3*y), y + np.sin(3*x), z)\n",
        "        # )\n",
        "        # squaggle_curve.show()\n",
        "        mini_curves = [\n",
        "            HilbertCurve(order = 1).scale(0.5).shift(1.5*vect)\n",
        "            for vect in [\n",
        "                LEFT+DOWN,\n",
        "                LEFT+UP,\n",
        "                RIGHT+UP,\n",
        "                RIGHT+DOWN\n",
        "            ]\n",
        "        ]\n",
        "        last_curve = mini_curves[0]\n",
        "        naive_curve = Mobject(last_curve)\n",
        "        for mini_curve in mini_curves[1:]:\n",
        "            line = Line(last_curve.get_points()[-1], mini_curve.get_points()[0])\n",
        "            naive_curve.add(line, mini_curve)\n",
        "            last_curve = mini_curve\n",
        "        naive_curve.ingest_submobjects()\n",
        "        naive_curve.set_color_by_gradient(RED, GREEN)\n",
        "        order_2_curve = HilbertCurve(order = 2)\n",
        "\n",
        "        self.add(words, grid2)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(grid4))\n",
        "        self.play(*[\n",
        "            ShowCreation(mini_curve)\n",
        "            for mini_curve in mini_curves\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(naive_curve, run_time = 5))\n",
        "        self.remove(*mini_curves)\n",
        "        self.wait()\n",
        "        self.play(Transform(naive_curve, order_2_curve))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Order3PseudoHilbertCurve(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Order 3 Pseudo-Hilbert Curve\")\n",
        "        words.set_color(GREEN)\n",
        "        words.to_edge(UP)\n",
        "        grid4 = Mobject(\n",
        "            Grid(2, 2),\n",
        "            Grid(4, 4, stroke_width = 2)\n",
        "        )\n",
        "        grid8 = Grid(8, 8, stroke_width = 1)\n",
        "        order_3_curve = HilbertCurve(order = 3)\n",
        "        mini_curves = [\n",
        "            HilbertCurve(order = 2).scale(0.5).shift(1.5*vect)\n",
        "            for vect in [\n",
        "                LEFT+DOWN,\n",
        "                LEFT+UP,\n",
        "                RIGHT+UP,\n",
        "                RIGHT+DOWN\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        self.add(words, grid4)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(grid8))\n",
        "        self.wait()\n",
        "        self.play(*list(map(GrowFromCenter, mini_curves)))\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(words, grid8, *mini_curves)\n",
        "        self.play(*[\n",
        "            ApplyMethod(curve.rotate, np.pi, axis)\n",
        "            for curve, axis in [\n",
        "                (mini_curves[0], UP+RIGHT),\n",
        "                (mini_curves[3], UP+LEFT)\n",
        "            ]\n",
        "        ])\n",
        "        self.play(ShowCreation(order_3_curve, run_time = 5))\n",
        "        self.wait()\n",
        "\n",
        "class GrowToOrder8PseudoHilbertCurve(Scene):\n",
        "    def construct(self):\n",
        "        self.curve = HilbertCurve(order = 1)\n",
        "        self.add(self.curve)\n",
        "        self.wait()\n",
        "        while self.curve.order < 8:\n",
        "            self.increase_order()\n",
        "\n",
        "\n",
        "    def increase_order(self):\n",
        "        mini_curves = [\n",
        "            self.curve.copy().scale(0.5).shift(1.5*vect)\n",
        "            for vect in [\n",
        "                LEFT+DOWN,\n",
        "                LEFT+UP,\n",
        "                RIGHT+UP,\n",
        "                RIGHT+DOWN\n",
        "            ]\n",
        "        ]\n",
        "        self.remove(self.curve)\n",
        "        self.play(\n",
        "            Transform(self.curve.copy(), mini_curves[0])\n",
        "        )\n",
        "        self.play(*[\n",
        "            GrowFromCenter(mini_curve)\n",
        "            for mini_curve in mini_curves[1:]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(*mini_curves)\n",
        "        self.play(*[\n",
        "            ApplyMethod(curve.rotate, np.pi, axis)\n",
        "            for curve, axis in [\n",
        "                (mini_curves[0], UP+RIGHT),\n",
        "                (mini_curves[3], UP+LEFT)\n",
        "            ]\n",
        "        ])\n",
        "        self.curve = HilbertCurve(order = self.curve.order+1)\n",
        "        self.play(ShowCreation(self.curve, run_time = 2))\n",
        "        self.remove(*mini_curves)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UseOrder8(Scene):\n",
        "    def construct(self):\n",
        "        mathy, bubble = get_mathy_and_bubble()\n",
        "        bubble.write(\"For a 256x256 pixel array...\")\n",
        "        words = OldTexText(\"Order 8 Pseudo-Hilbert Curve\")\n",
        "        words.set_color(GREEN)\n",
        "        words.to_edge(UP, buff = 0.3)\n",
        "        curve = HilbertCurve(order = 8)\n",
        "\n",
        "        self.add(mathy, bubble)\n",
        "        self.play(ShimmerIn(bubble.content))\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(words)\n",
        "        self.play(ShowCreation(\n",
        "            curve, run_time = 7, rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class HilbertBetterThanSnakeQ(Scene):\n",
        "    def construct(self):\n",
        "        hilbert_curves, snake_curves = [\n",
        "            [\n",
        "                CurveClass(order = n)\n",
        "                for n in range(2, 7)\n",
        "            ]\n",
        "            for CurveClass in (HilbertCurve, SnakeCurve)\n",
        "        ]\n",
        "        for curve in hilbert_curves+snake_curves:\n",
        "            curve.scale(0.8)\n",
        "        for curve in hilbert_curves:\n",
        "            curve.to_edge(LEFT)\n",
        "        for curve in snake_curves:\n",
        "            curve.to_edge(RIGHT)\n",
        "        greater_than = OldTex(\">\")\n",
        "        question_mark = OldTexText(\"?\")\n",
        "        question_mark.next_to(greater_than, UP)\n",
        "\n",
        "        self.add(greater_than, question_mark)\n",
        "        hilbert_curve = hilbert_curves[0]\n",
        "        snake_curve = snake_curves[0]\n",
        "        for new_hc, new_sc in zip(hilbert_curves[1:], snake_curves[1:]):\n",
        "            self.play(*[\n",
        "                Transform(hilbert_curve, new_hc),\n",
        "                Transform(snake_curve, new_sc)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ImagineItWorks(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Imagine your project succeeds...\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RandyWithHeadphones(Scene):\n",
        "    def construct(self):\n",
        "        headphones = ImageMobject(\"Headphones.png\")\n",
        "        headphones.scale(0.1)\n",
        "        headphones.stretch(2, 0)\n",
        "        headphones.shift(1.2*UP+0.05*LEFT)\n",
        "        headphones.set_color(GREY)\n",
        "        randy = Randolph()\n",
        "\n",
        "        self.add(randy, headphones)\n",
        "        self.wait(2)\n",
        "        self.play(ApplyMethod(randy.blink))\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class IncreaseResolution(Scene):\n",
        "    def construct(self):\n",
        "        grids = [\n",
        "            Grid(\n",
        "                2**order, 2**order,\n",
        "                stroke_width = 1\n",
        "            ).shift(0.3*DOWN)\n",
        "            for order in (6, 7)\n",
        "        ]\n",
        "        grid = grids[0]\n",
        "        side_brace = Brace(grid, LEFT)\n",
        "        top_brace = Brace(grid, UP)\n",
        "        top_words = OldTexText(\"256\")\n",
        "        new_top_words = OldTexText(\"512\")\n",
        "        side_words = top_words.copy()\n",
        "        new_side_words = new_top_words.copy()\n",
        "        for words in top_words, new_top_words:\n",
        "            words.next_to(top_brace, UP, buff = 0.1)\n",
        "        for words in side_words, new_side_words:\n",
        "            words.next_to(side_brace, LEFT)\n",
        "\n",
        "        self.add(grid)\n",
        "        self.play(\n",
        "            GrowFromCenter(side_brace),\n",
        "            GrowFromCenter(top_brace),\n",
        "            ShimmerIn(top_words),\n",
        "            ShimmerIn(side_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            DelayByOrder(Transform(*grids)),\n",
        "            Transform(top_words, new_top_words),\n",
        "            Transform(side_words, new_side_words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IncreasingResolutionWithSnakeCurve(Scene):\n",
        "    def construct(self):\n",
        "        start_curve = SnakeCurve(order = 6)\n",
        "        end_curve = SnakeCurve(order = 7)\n",
        "        start_dots, end_dots = [\n",
        "            Mobject(*[\n",
        "                Dot(\n",
        "                    curve.get_points()[int(x*curve.get_num_points())],\n",
        "                    color = color\n",
        "                )\n",
        "                for x, color in [\n",
        "                    (0.202, GREEN),\n",
        "                    (0.48, BLUE),\n",
        "                    (0.7, RED)\n",
        "                ]\n",
        "            ])\n",
        "            for curve in (start_curve, end_curve)\n",
        "        ]\n",
        "        self.add(start_curve)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(start_dots, run_time = 2),\n",
        "            ApplyMethod(start_curve.fade)\n",
        "        )\n",
        "        end_curve.fade()\n",
        "        self.play(\n",
        "            Transform(start_curve, end_curve),\n",
        "            Transform(start_dots, end_dots)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TrackSpecificCurvePoint(Scene):\n",
        "    CURVE_CLASS = None #Fillin\n",
        "    def construct(self):\n",
        "        line = get_freq_line().center()\n",
        "        line.sort_points(lambda p : p[0])\n",
        "        curves = [\n",
        "            self.CURVE_CLASS(order = order)\n",
        "            for order in range(3, 10)\n",
        "        ]\n",
        "        alpha = 0.48\n",
        "        dot = Dot(UP)\n",
        "        start_dot = Dot(0.1*LEFT)\n",
        "        dots = [\n",
        "            Dot(curve.get_points()[alpha*curve.get_num_points()])\n",
        "            for curve in curves\n",
        "        ]\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(Transform(dot, start_dot))\n",
        "        self.wait()\n",
        "        for new_dot, curve in zip(dots, curves):\n",
        "            self.play(\n",
        "                Transform(line, curve),\n",
        "                Transform(dot, new_dot)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class TrackSpecificSnakeCurvePoint(TrackSpecificCurvePoint):\n",
        "    CURVE_CLASS = SnakeCurve\n",
        "\n",
        "\n",
        "class NeedToRelearn(Scene):\n",
        "    def construct(self):\n",
        "        top_words = OldTexText(\"Different pixel-frequency association\")\n",
        "        bottom_words = OldTexText(\"Need to relearn sight-via-sound\")\n",
        "        top_words.shift(UP)\n",
        "        bottom_words.shift(DOWN)\n",
        "        arrow = Arrow(top_words, bottom_words)\n",
        "\n",
        "        self.play(ShimmerIn(top_words))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(ShimmerIn(bottom_words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TrackSpecificHilbertCurvePoint(TrackSpecificCurvePoint):\n",
        "    CURVE_CLASS = HilbertCurve\n",
        "\n",
        "\n",
        "\n"
    ]
}