{
    "topic": "The mathematical concept being demonstrated is the probability of rolling a particular number on a fair six-s",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.clt.main import *\n",
        "from _2022.convolutions.discrete import *\n",
        "\n",
        "import scipy.stats\n",
        "\n",
        "\n",
        "def wedge_func(x):\n",
        "    return np.clip(-np.abs(x) + 1, 0, 1)\n",
        "\n",
        "\n",
        "def double_lump(x):\n",
        "    return 0.45 * np.exp(-6 * (x - 0.5)**2) + np.exp(-6 * (x + 0.5)**2)\n",
        "\n",
        "\n",
        "def uniform(x):\n",
        "    return 1.0 * (-0.5 < x) * (x < 0.5)\n",
        "\n",
        "\n",
        "def get_conv_graph(axes, f, g, dx=0.1):\n",
        "    dx = 0.1\n",
        "    x_min, x_max = axes.x_range[:2]\n",
        "    x_samples = np.arange(x_min, x_max + dx, dx)\n",
        "    f_samples = np.array([f(x) for x in x_samples])\n",
        "    g_samples = np.array([g(x) for x in x_samples])\n",
        "    full_conv = np.convolve(f_samples, g_samples)\n",
        "    x0 = len(x_samples) // 2 - 1  # TODO, be smarter about this\n",
        "    conv_samples = full_conv[x0:x0 + len(x_samples)]\n",
        "    conv_graph = VMobject()\n",
        "    conv_graph.set_stroke(TEAL, 2)\n",
        "    conv_graph.set_points_smoothly(axes.c2p(x_samples, conv_samples * dx))\n",
        "    return conv_graph\n",
        "\n",
        "\n",
        "class TransitionToContinuousProbability(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup axes and initial graph\n",
        "        axes = Axes((0, 12), (0, 1, 0.2), width=14, height=5)\n",
        "        axes.to_edge(LEFT, LARGE_BUFF)\n",
        "        axes.to_edge(DOWN, buff=1.25)\n",
        "\n",
        "        def pd(x):\n",
        "            return (x**4) * np.exp(-x) / 8.0\n",
        "\n",
        "        graph = axes.get_graph(pd)\n",
        "        graph.set_stroke(WHITE, 2)\n",
        "        bars = axes.get_riemann_rectangles(graph, dx=1, x_range=(0, 6), input_sample_type=\"right\")\n",
        "        bars.set_stroke(WHITE, 3)\n",
        "\n",
        "        y_label = Text(\"Probability\", font_size=48)\n",
        "        y_label.next_to(axes.y_axis, UP, SMALL_BUFF)\n",
        "        y_label.shift_onto_screen()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(y_label)\n",
        "        self.add(*bars)\n",
        "\n",
        "        self.frame.move_to(0.5 * DOWN)\n",
        "\n",
        "        # Label as die probabilities\n",
        "        dice = get_die_faces(fill_color=BLUE_E, dot_color=WHITE, stroke_width=1)\n",
        "        dice.set_height(0.5)\n",
        "        for bar, die in zip(bars, dice):\n",
        "            die.next_to(bar, DOWN)\n",
        "\n",
        "        self.play(FadeIn(dice, 0.1 * UP, lag_ratio=0.05, rate_func=overshoot))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(dice, RIGHT, rate_func=running_start, run_time=1, path_arc=-PI / 5, lag_ratio=0.01))\n",
        "\n",
        "        # Make continuous\n",
        "        all_rects = VGroup(*(\n",
        "            axes.get_riemann_rectangles(\n",
        "                graph,\n",
        "                x_range=(0, min(6 + n, 12)),\n",
        "                dx=(1 / n),\n",
        "                input_sample_type=\"right\",\n",
        "            ).set_stroke(WHITE, width=(2.0 / n), opacity=(2.0 / n), behind=False)\n",
        "            for n in (*range(1, 10), *range(10, 20, 2), *range(20, 100, 5))\n",
        "        ))\n",
        "        area = all_rects[-1]\n",
        "        area.set_stroke(width=0)\n",
        "\n",
        "        self.remove(bars)\n",
        "        self.play(\n",
        "            ShowSubmobjectsOneByOne(all_rects, rate_func=bezier([0, 0, 0, 0, 1, 1])),\n",
        "            FadeOut(y_label),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.remove(all_rects)\n",
        "        self.add(area, graph)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.wait()\n",
        "\n",
        "        # Show continuous value\n",
        "        x_tracker = ValueTracker(0)\n",
        "        get_x = x_tracker.get_value\n",
        "        tip = ArrowTip(angle=PI / 2)\n",
        "        tip.set_height(0.25)\n",
        "        tip.add_updater(lambda m: m.move_to(axes.c2p(get_x(), 0), UP))\n",
        "        x_label = DecimalNumber(font_size=36)\n",
        "        x_label.add_updater(lambda m: m.set_value(get_x()))\n",
        "        x_label.add_updater(lambda m: m.next_to(tip, DOWN, buff=0.2))\n",
        "\n",
        "        self.play(FadeIn(tip), FadeIn(x_label))\n",
        "        self.play(x_tracker.animate.set_value(12), run_time=6)\n",
        "\n",
        "        # Labels\n",
        "        x_labels = VGroup(*(\n",
        "            Text(text)\n",
        "            for text in [\n",
        "                \"Temperature tomorrow at noon\",\n",
        "                \"Value of XYZ next year\",\n",
        "                \"Time before the next bus comes\",\n",
        "            ]\n",
        "        ))\n",
        "        for x_label in x_labels:\n",
        "            x_label.next_to(axes.c2p(4, 0), DOWN, buff=0.2)\n",
        "\n",
        "        self.play(Write(x_labels[0], run_time=1))\n",
        "        for xl1, xl2 in zip(x_labels, x_labels[1:]):\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(xl1, 0.5 * UP),\n",
        "                FadeIn(xl2, 0.5 * UP),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(x_labels[-1]),\n",
        "            x_tracker.animate.set_value(0).set_anim_args(run_time=3),\n",
        "        )\n",
        "        self.play(\n",
        "            x_tracker.animate.set_value(12), run_time=5\n",
        "        )\n",
        "        self.remove(tip, x_label)\n",
        "\n",
        "        # Label density\n",
        "        density = Text(\"Probability density\")\n",
        "        density.match_height(y_label)\n",
        "        density.move_to(y_label, LEFT)\n",
        "        cross = Cross(y_label)\n",
        "        cross.set_stroke(RED, width=(0, 8, 8, 8, 0))\n",
        "\n",
        "        self.play(FadeIn(y_label))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(y_label, cross).animate.shift(0.75 * UP),\n",
        "            FadeIn(density),\n",
        "            self.frame.animate.set_y(0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Interpretation\n",
        "        range_tracker = ValueTracker([0, 12])\n",
        "        sub_area_opacity_tracker = ValueTracker(0)\n",
        "\n",
        "        def get_subarea():\n",
        "            result = axes.get_area_under_graph(\n",
        "                graph, range_tracker.get_value()\n",
        "            )\n",
        "            result.set_stroke(width=0)\n",
        "            result.set_fill(TEAL, sub_area_opacity_tracker.get_value())\n",
        "            return result\n",
        "\n",
        "        sub_area = always_redraw(get_subarea)\n",
        "\n",
        "        v_lines = Line(DOWN, UP).replicate(2)\n",
        "        v_lines.set_stroke(GREY_A, 1)\n",
        "        v_lines.set_height(FRAME_HEIGHT)\n",
        "\n",
        "        def update_v_lines(v_lines):\n",
        "            values = range_tracker.get_value()\n",
        "            for value, line in zip(values, v_lines):\n",
        "                line.move_to(axes.c2p(value, 0), DOWN)\n",
        "\n",
        "        v_lines.add_updater(update_v_lines)\n",
        "\n",
        "        bound_labels = Tex(\"ab\")\n",
        "        bound_labels[0].add_updater(lambda m: m.move_to(v_lines[0], DOWN).shift(0.5 * DOWN))\n",
        "        bound_labels[1].add_updater(lambda m: m.move_to(v_lines[1], DOWN).shift(0.5 * DOWN))\n",
        "        bound_labels.add_updater(lambda m: m.set_opacity(sub_area_opacity_tracker.get_value()))\n",
        "\n",
        "        prob_label = Tex(R\"P(a < x < b) = \\text{This area}\")\n",
        "        prob_label.move_to(2 * UR)\n",
        "        rhs = prob_label[R\"\\text{This area}\"]\n",
        "        prob_arrow = Arrow(LEFT, RIGHT)\n",
        "        prob_arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            rhs.get_bottom() + 0.1 * DOWN,\n",
        "            sub_area.get_center(),\n",
        "        ))\n",
        "\n",
        "        self.add(area, sub_area, graph, bound_labels)\n",
        "        self.play(\n",
        "            area.animate.set_opacity(0.1),\n",
        "            range_tracker.animate.set_value([3, 4.5]),\n",
        "            sub_area_opacity_tracker.animate.set_value(1),\n",
        "            VFadeIn(v_lines),\n",
        "            FadeIn(prob_label),\n",
        "            VFadeIn(prob_arrow),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        for pair in [(5, 6), (1, 3), (2.5, 3), (4, 7)]:\n",
        "            self.play(range_tracker.animate.set_value(pair), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        # Name the pdf\n",
        "        long_name = Text(\"probability\\ndensity\\nfunction\", alignment=\"LEFT\")\n",
        "        short_name = Text(\"pdf\")\n",
        "        long_name.move_to(axes.c2p(1, 0.75), UL)\n",
        "        short_name.move_to(axes.c2p(2, 0.5))\n",
        "\n",
        "        self.play(FadeIn(long_name, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingStrings(long_name, short_name, lag_ratio=0.01, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show integral\n",
        "        int_rhs = Tex(R\"\\int_a^b p_X(x) \\, dx\")\n",
        "        int_rhs.move_to(rhs, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            rhs.animate.set_opacity(0).shift(0.5 * DOWN + 1.0 * LEFT),\n",
        "            FadeIn(int_rhs, DL)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ambient range changing\n",
        "        for pair in [(2.5, 7), (8, 10), (3.5, 9), (3, 4.5)]:\n",
        "            self.play(range_tracker.animate.set_value(pair), run_time=3)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class CompareFormulas(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup division\n",
        "        v_line = Line(DOWN, UP).set_height(FRAME_HEIGHT)\n",
        "        kw = dict(font_size=60)\n",
        "        disc_title, cont_title = titles = VGroup(\n",
        "            Text(\"Discrete case\", **kw),\n",
        "            Text(\"Continuous case\", **kw),\n",
        "        )\n",
        "        for vect, title in zip([LEFT, RIGHT], titles):\n",
        "            title.move_to(vect * FRAME_WIDTH * 0.25)\n",
        "            title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "            underline = Underline(title, stretch_factor=1.5)\n",
        "            underline.set_stroke(GREY_B)\n",
        "            title.add(underline)\n",
        "\n",
        "        self.add(v_line, titles)\n",
        "\n",
        "        # Discrete diagram (pre-made image)\n",
        "        discrete_diagram = ImageMobject(\"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2023/convolutions2/dice/DiscreteDistributionSum.png\")\n",
        "        discrete_diagram.set_height(5)\n",
        "        discrete_diagram.match_x(disc_title)\n",
        "        discrete_diagram.to_edge(DOWN, buff=0.5)\n",
        "        self.add(discrete_diagram)\n",
        "\n",
        "        # Continuous diagrams\n",
        "        kw = dict(y_range=(0, 1, 0.5), width=5, height=1.5)\n",
        "        all_axes = VGroup(\n",
        "            Axes((-2, 2), **kw),\n",
        "            Axes((-2, 2), **kw),\n",
        "            Axes((-3, 3), **kw),\n",
        "        )\n",
        "        all_axes[:2].arrange(RIGHT, buff=1.5)\n",
        "        all_axes[2].set_width(10)\n",
        "        all_axes[2].next_to(all_axes[:2], UP, buff=1.5)\n",
        "        all_axes.set_width(FRAME_WIDTH * 0.5 - 0.5)\n",
        "        all_axes.match_x(cont_title)\n",
        "        all_axes.to_edge(DOWN, buff=0.75)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            all_axes[0].get_graph(\n",
        "                wedge_func,\n",
        "                use_smoothing=False\n",
        "            ).set_stroke(BLUE),\n",
        "            all_axes[1].get_graph(double_lump).set_stroke(RED),\n",
        "            get_conv_graph(all_axes[2], wedge_func, double_lump).set_stroke(TEAL)\n",
        "        )\n",
        "        graphs.set_stroke(width=2)\n",
        "\n",
        "        tex_kw = dict()\n",
        "        labels = VGroup(\n",
        "            Tex(\"f(x)\", font_size=24),\n",
        "            Tex(\"g(y)\", font_size=24),\n",
        "            Tex(\"[f * g](s)\", font_size=36),\n",
        "        )\n",
        "        for label, axes in zip(labels, all_axes):\n",
        "            label.move_to(midpoint(axes.get_corner(UR), axes.get_top()), UP)\n",
        "\n",
        "        plots = VGroup(*(\n",
        "            VGroup(*tup)\n",
        "            for tup in zip(all_axes, graphs, labels)\n",
        "        ))\n",
        "\n",
        "        self.add(plots)\n",
        "\n",
        "        # Formulae\n",
        "        disc_formula = Tex(\n",
        "            R\"\\big[P_X * P_Y\\big](s) = \\sum_{x = 1}^N P_X(x) \\cdot P_Y(s - x)\",\n",
        "            font_size=36,\n",
        "            t2c={\"X\": BLUE, \"Y\": RED},\n",
        "        )\n",
        "        disc_formula.next_to(disc_title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        cont_formula = Tex(\n",
        "            R\"\\big[f * g \\big](s) = \\int_{-\\infty}^\\infty f(x) g(s - x) \\, dx\",\n",
        "            font_size=36,\n",
        "        )\n",
        "        cont_formula.match_x(cont_title)\n",
        "        cont_formula.match_y(disc_formula)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(disc_formula, run_time=2, lag_ratio=0.1),\n",
        "            FlashAround(disc_formula, time_width=1.5, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(disc_formula)\n",
        "        rect.set_stroke(YELLOW, 2, opacity=0)\n",
        "        target_rects = VGroup(*(\n",
        "            SurroundingRectangle(disc_formula[s][0])\n",
        "            for s in [\"P_X\", \"P_Y\", \"P_X * P_Y\", re.compile(R\"\\\\sum.*\")]\n",
        "        ))\n",
        "        target_rects.set_stroke(YELLOW, 2)\n",
        "        for target_rect in target_rects:\n",
        "            self.play(rect.animate.become(target_rect), run_time=0.5)\n",
        "            self.wait()\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                disc_formula.copy(), cont_formula,\n",
        "                lag_ratio=-0.001,\n",
        "                path_arc=-0.1 * PI\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Out of context\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        randy = Randolph()\n",
        "        randy.next_to(cont_formula, DL, LARGE_BUFF)\n",
        "\n",
        "        self.add(fade_rect, cont_formula)\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            VFadeIn(randy),\n",
        "            randy.change(\"horrified\", cont_formula),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change(\"pondering\", cont_formula))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "# Random samples from continuous distributions\n",
        "\n",
        "\n",
        "class RepeatedSamplesFromContinuousDistributions(InteractiveScene):\n",
        "    sigma1 = 1.0\n",
        "    sigma2 = 1.0\n",
        "\n",
        "    graph_colors = [BLUE, RED, TEAL]\n",
        "    graph_stroke_width = 2\n",
        "\n",
        "    dot_fade_factor = 0.25\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.random_variables = self.get_random_variables()\n",
        "        self.all_dots = Group()\n",
        "        self.add(self.all_dots)\n",
        "\n",
        "    def get_plots(self):\n",
        "        # Axes and graphs\n",
        "        all_axes = self.get_axes()\n",
        "        left_axes = all_axes[:2]\n",
        "        left_axes.arrange(DOWN, buff=1.5)\n",
        "        left_axes.to_edge(LEFT)\n",
        "        all_axes[2].center().to_edge(RIGHT)\n",
        "\n",
        "        for axes in all_axes:\n",
        "            axes.x_axis.add_numbers(font_size=16)\n",
        "            axes.y_axis.set_stroke(opacity=0.5)\n",
        "\n",
        "        pdfs = self.get_pdfs()\n",
        "        graphs = VGroup(*(\n",
        "            axes.get_graph(func).set_stroke(color)\n",
        "            for axes, func, color in zip(\n",
        "                all_axes,\n",
        "                self.get_pdfs(),\n",
        "                self.graph_colors\n",
        "            )\n",
        "        ))\n",
        "        graphs.add(self.get_sum_graph(all_axes[2]))\n",
        "        graphs.set_stroke(width=self.graph_stroke_width)\n",
        "\n",
        "        # Labels\n",
        "        labels = self.get_axes_labels(all_axes)\n",
        "\n",
        "        plots = VGroup(*(\n",
        "            VGroup(*tup)\n",
        "            for tup in zip(all_axes, graphs, labels)\n",
        "        ))\n",
        "        return plots\n",
        "\n",
        "    def get_axes(self):\n",
        "        return VGroup(*(\n",
        "            Axes(\n",
        "                (-5, 5), (0, 0.5, 0.25),\n",
        "                width=5.5,\n",
        "                height=2,\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ))\n",
        "\n",
        "    def get_axes_labels(self, all_axes):\n",
        "        a1, a2, a3 = all_axes\n",
        "        return VGroup(\n",
        "            Tex(\"X\").move_to(midpoint(a1.get_corner(UR), a1.get_top())),\n",
        "            Tex(\"Y\").move_to(midpoint(a2.get_corner(UR), a2.get_top())),\n",
        "            Tex(\"X + Y\").next_to(a3, UP, buff=1.0)\n",
        "        )\n",
        "\n",
        "    def repeated_samples(self, plots, n_repetitions, **kwargs):\n",
        "        for n in range(n_repetitions):\n",
        "            self.animate_samples(plots, **kwargs)\n",
        "\n",
        "    def animate_samples(\n",
        "        self,\n",
        "        plots,\n",
        "        time_between_samples=0.25,\n",
        "        time_before_fade=1.0,\n",
        "        animate=True,\n",
        "    ):\n",
        "        # Setup\n",
        "        xy_samples = np.round(self.get_samples(), 2)\n",
        "        sample_sum = sum(xy_samples)\n",
        "        samples = [*xy_samples[:2], sample_sum]\n",
        "        dots = Group()\n",
        "        labels = VGroup()\n",
        "        lines = VGroup()\n",
        "        for sample, plot in zip(samples, plots):\n",
        "            axes, graph, sym_label = plot\n",
        "            dot = GlowDot(axes.c2p(sample, 0))\n",
        "            label = DecimalNumber(sample)\n",
        "            label.next_to(sym_label, DOWN)\n",
        "            label.scale(0.75, about_edge=DOWN)\n",
        "            label.set_fill(GREY_A)\n",
        "\n",
        "            line = axes.get_v_line_to_graph(sample, graph, line_func=Line)\n",
        "            line.set_stroke(YELLOW, 2)\n",
        "\n",
        "            dots.add(dot)\n",
        "            labels.add(label)\n",
        "            lines.add(line)\n",
        "\n",
        "        if len(plots) > 2:\n",
        "            sum_label = VGroup(\n",
        "                DecimalNumber(samples[0]),\n",
        "                Tex(\"+\") if samples[1] > 0 else Tex(\"-\"),\n",
        "                DecimalNumber(abs(samples[1])),\n",
        "                Tex(\"=\"),\n",
        "                DecimalNumber(samples[2]),\n",
        "            )\n",
        "            sum_label.arrange(RIGHT, buff=0.15)\n",
        "            sum_label[-1].align_to(sum_label[0], DOWN)\n",
        "            sum_label.match_height(labels[2])\n",
        "            sum_label.match_style(labels[2])\n",
        "            sum_label.move_to(labels[2], DL)\n",
        "            labels.remove(labels[2])\n",
        "            labels.add(sum_label)\n",
        "            sum_label.shift((plots[2][2][\"+\"].get_x() - sum_label[1].get_x()) * RIGHT)\n",
        "\n",
        "        # Animate\n",
        "        for i in range(min(2, len(plots))):\n",
        "            self.add(dots[i], labels[i], lines[i])\n",
        "            if len(plots) > 2:\n",
        "                self.add(sum_label[:2 * i + 1])\n",
        "            self.wait(time_between_samples)\n",
        "        if len(plots) > 2:\n",
        "            self.play(LaggedStart(\n",
        "                Transform(dots[0].copy(), dots[2].copy().set_opacity(0.5), remover=True),\n",
        "                Transform(dots[1].copy(), dots[2].copy().set_opacity(0.5), remover=True),\n",
        "                FadeTransform(sum_label[:3].copy(), sum_label[3:]),\n",
        "                run_time=1.0 if animate else 0,\n",
        "            ))\n",
        "            self.add(sum_label)\n",
        "            self.add(dots[2])\n",
        "        self.wait(time_before_fade)\n",
        "        kw = dict(run_time=0.25 if animate else 0)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                dot.animate.set_radius(0.1).set_opacity(self.dot_fade_factor)\n",
        "                for dot in dots\n",
        "            ), **kw),\n",
        "            LaggedStartMap(FadeOut, labels, **kw),\n",
        "            LaggedStartMap(FadeOut, lines[:2], **kw),\n",
        "        )\n",
        "        self.all_dots.add(*dots)\n",
        "        self.add(self.all_dots)\n",
        "\n",
        "    def get_random_variables(self):\n",
        "        return [\n",
        "            scipy.stats.norm(0, self.sigma1),\n",
        "            scipy.stats.norm(0, self.sigma2),\n",
        "        ]\n",
        "\n",
        "    def get_samples(self):\n",
        "        return [\n",
        "            np.round(var.rvs(), 2)\n",
        "            for var in self.random_variables\n",
        "        ]\n",
        "\n",
        "    def get_pdfs(self):\n",
        "        return [var.pdf for var in self.random_variables]\n",
        "\n",
        "    def get_sum_graph(self, axes):\n",
        "        graph = get_conv_graph(axes, *self.get_pdfs())\n",
        "        graph.set_stroke(self.graph_colors[2])\n",
        "        return graph\n",
        "\n",
        "\n",
        "class SampleTwoNormals(RepeatedSamplesFromContinuousDistributions):\n",
        "    random_seed = 1\n",
        "    sigma1 = 1\n",
        "    sigma2 = 1.5\n",
        "\n",
        "    annotations = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup plots\n",
        "        plots = self.get_plots()\n",
        "        plots.to_edge(UP, buff=1.0)\n",
        "        sum_axes, sum_graph, sum_label = plots[2]\n",
        "        sum_axes.y_axis.set_opacity(0)\n",
        "        sum_graph.set_opacity(0)\n",
        "        sum_label.shift(DOWN)\n",
        "\n",
        "        normal_parameters = VGroup(*(\n",
        "            self.get_normal_parameter_labels(plot, 0, sigma)\n",
        "            for plot, sigma in zip(plots, [self.sigma1, self.sigma2])\n",
        "        ))\n",
        "        normal_words = VGroup(*(\n",
        "            Text(\"Normal\\ndistribution\", font_size=30, alignment=\"LEFT\").next_to(\n",
        "                parameters, UP, MED_LARGE_BUFF, LEFT\n",
        "            )\n",
        "            for parameters in normal_parameters\n",
        "        ))\n",
        "\n",
        "        if self.annotations:\n",
        "            plots.set_opacity(0)\n",
        "\n",
        "        # Repeated samples of X\n",
        "        frame = self.frame\n",
        "        frame.move_to(plots[0])\n",
        "        frame.set_height(plots[0].get_height() + 2)\n",
        "\n",
        "        self.add(plots[0])\n",
        "\n",
        "        if self.annotations:\n",
        "            # Describe X\n",
        "            axes, graph, label = plots[0]\n",
        "            label_rect = SurroundingRectangle(label, buff=0.05)\n",
        "            label_rect.set_stroke(YELLOW, 2)\n",
        "            sample_point = label.get_center() + label.get_height() * DOWN\n",
        "\n",
        "            rv_words = Text(\"Random variable\", font_size=24)\n",
        "            rv_words.next_to(label, UR, buff=0.5)\n",
        "            rv_arrow = Arrow(rv_words, label, buff=0.2, stroke_color=YELLOW)\n",
        "\n",
        "            sample_words = Text(\"Samples\", font_size=24)\n",
        "            sample_words.next_to(sample_point, DOWN, LARGE_BUFF)\n",
        "            sample_words.match_x(rv_words)\n",
        "            sample_arrow = Arrow(sample_words, sample_point + 0.25 * DR, buff=0.2)\n",
        "            sample_arrow.set_stroke(BLUE)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(rv_words, lag_ratio=0.1),\n",
        "                ShowCreation(label_rect),\n",
        "                GrowArrow(rv_arrow),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeTransform(rv_words.copy(), sample_words),\n",
        "                TransformFromCopy(rv_arrow, sample_arrow),\n",
        "                FadeOut(label_rect),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            # Describe normal distribution\n",
        "            curve_copy = graph.copy()\n",
        "            curve_copy.set_stroke(TEAL, 7, 1)\n",
        "\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeOut, VGroup(\n",
        "                    sample_words, sample_arrow, rv_arrow, rv_words,\n",
        "                )),\n",
        "                Write(normal_words[0], run_time=2),\n",
        "                FadeIn(normal_parameters[0]),\n",
        "                VShowPassingFlash(curve_copy, time_width=0.7, time_span=(0.5, 5)),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            # Show area\n",
        "            bound_tracker = ValueTracker([-1, -1])\n",
        "            area = always_redraw(lambda: axes.get_area_under_graph(\n",
        "                graph, bound_tracker.get_value()\n",
        "            ))\n",
        "\n",
        "            self.add(area)\n",
        "            self.play(\n",
        "                bound_tracker.animate.set_value([-1, 2]),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(FadeOut(area))\n",
        "\n",
        "        else:\n",
        "            self.repeated_samples(plots[:1], 30, time_before_fade=0.5)\n",
        "\n",
        "        # Show Y\n",
        "        frame.generate_target()\n",
        "        frame.target.set_height(plots[:2].get_height() + 2)\n",
        "        frame.target.move_to(plots[:2])\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            FadeIn(plots[1]),\n",
        "            FadeOut(self.all_dots),\n",
        "        )\n",
        "        self.all_dots.clear()\n",
        "\n",
        "        if self.annotations:\n",
        "            self.play(TransformFromCopy(*normal_words))\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeIn, normal_parameters[1], lag_ratio=0.25),\n",
        "                LaggedStartMap(\n",
        "                    FlashAround, normal_parameters[1],\n",
        "                    stroke_width=1,\n",
        "                    time_width=1.0,\n",
        "                    lag_ratio=0.25,\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "        else:\n",
        "            self.repeated_samples(plots[:2], 10, time_before_fade=0.5)\n",
        "\n",
        "        # Show sum\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            FadeIn(plots[2]),\n",
        "            FadeOut(self.all_dots),\n",
        "        )\n",
        "        self.all_dots.clear()\n",
        "\n",
        "        if self.annotations:\n",
        "            # Show multiple graphs\n",
        "            axes, graph, label = plots[2]\n",
        "            graphs = VGroup(\n",
        "                graph.copy(),\n",
        "                axes.get_graph(lambda x: 0.3 * np.exp(-0.1 * x**4)),\n",
        "                axes.get_graph(lambda x: 0.3 * (1 / (1 + x**2))),\n",
        "            )\n",
        "            graphs.set_stroke(TEAL, 2, 1)\n",
        "\n",
        "            kw = dict(font_size=24)\n",
        "            words = [\n",
        "                Text(\"Another\\nnormal?\", **kw),\n",
        "                Text(\"Something\\nnew?\", **kw),\n",
        "                Text(\"Maybe this?\", **kw),\n",
        "            ]\n",
        "            for word in words:\n",
        "                word.move_to(axes)\n",
        "                word.align_to(axes.x_axis.get_start(), LEFT)\n",
        "\n",
        "            curr_graph = graphs[0].copy()\n",
        "            self.play(\n",
        "                ShowCreation(curr_graph),\n",
        "                FadeIn(words[0], 0.5 * UP),\n",
        "            )\n",
        "            self.wait()\n",
        "            for i in range(2):\n",
        "                self.play(\n",
        "                    FadeOut(words[i], 0.5 * UP),\n",
        "                    FadeIn(words[i + 1], 0.5 * UP),\n",
        "                    Transform(curr_graph, graphs[i + 1])\n",
        "                )\n",
        "                self.wait()\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(words[-1]),\n",
        "                Transform(curr_graph, graphs[0])\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(FadeOut(curr_graph, run_time=3))\n",
        "        else:\n",
        "            self.repeated_samples(\n",
        "                plots, 10,\n",
        "                time_between_samples=0.25,\n",
        "                time_before_fade=1.0,\n",
        "            )\n",
        "            # More! Faster!\n",
        "            self.repeated_samples(\n",
        "                plots[:3], 100,\n",
        "                time_between_samples=1 / 30,\n",
        "                time_before_fade=0.2,\n",
        "                animate=False\n",
        "            )\n",
        "\n",
        "    def get_normal_parameter_labels(self, plot, mean, sigma, font_size=18, color=GREY_A):\n",
        "        kw = dict(font_size=font_size)\n",
        "        labels = VGroup(\n",
        "            Tex(R\"\\text{Mean} = 0.0\", **kw),\n",
        "            Tex(R\"\\text{Std. Dev.} = 0.0\", **kw),\n",
        "        )\n",
        "        for label, value in zip(labels, [mean, sigma]):\n",
        "            number = label.make_number_changeable(\"0.0\")\n",
        "            number.set_value(value)\n",
        "\n",
        "        labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        labels.move_to(plot, LEFT)\n",
        "        labels.shift(0.1 * plot.get_height() * DOWN)\n",
        "        labels.align_to(plot[0].x_axis.get_start(), LEFT)\n",
        "        labels.set_color(color)\n",
        "\n",
        "        return labels\n",
        "\n",
        "    def get_sum_graph(self, axes):\n",
        "        # Todo, it would be better to directly convolve the first\n",
        "        # two graphs\n",
        "        var = scipy.stats.norm(0, np.sqrt(self.sigma1**2 + self.sigma2**2))\n",
        "        return axes.get_graph(var.pdf, color=self.graph_colors[2])\n",
        "\n",
        "\n",
        "class IntroAnnotations(SampleTwoNormals):\n",
        "    annotations = True\n",
        "\n",
        "\n",
        "class AddTwoGammaDistributions(RepeatedSamplesFromContinuousDistributions):\n",
        "    dot_fade_factor = 0.75\n",
        "\n",
        "    def construct(self):\n",
        "        # Plots\n",
        "        plots = self.get_plots()\n",
        "        self.add(plots)\n",
        "\n",
        "        # Add graph labels\n",
        "        kw = dict(font_size=30)\n",
        "        graph_labels = VGroup(\n",
        "            Tex(\"e^{-x}\", **kw),\n",
        "            Tex(R\"\\frac{1}{2} x^2 \\cdot e^{-x}\", **kw),\n",
        "            Tex(R\"\\frac{1}{6} x^3 \\cdot e^{-x}\", **kw),\n",
        "        )\n",
        "        for plot, label, x in zip(plots, graph_labels, [1, 2, 3]):\n",
        "            axes, graph, var_label = plot\n",
        "            label.next_to(axes.i2gp(x, graph), UP, SMALL_BUFF)\n",
        "            label.match_color(graph)\n",
        "        graph_labels[0].shift(0.3 * UR)\n",
        "\n",
        "        self.add(graph_labels)\n",
        "\n",
        "        # Initial samples\n",
        "        self.repeated_samples(\n",
        "            plots, 40,\n",
        "            animate=False,\n",
        "            time_between_samples=0.1,\n",
        "            time_before_fade=0.5\n",
        "        )\n",
        "\n",
        "        # Graph equation\n",
        "        frame = self.frame\n",
        "        fs_rect = FullScreenRectangle()\n",
        "        fs_rect.set_stroke(GREY_B, 1)\n",
        "        fs_rect.set_fill(BLACK, 1)\n",
        "        fuller_rect = FullScreenRectangle()\n",
        "        fuller_rect.set_fill(GREY_E, 1)\n",
        "        fuller_rect.scale(3)\n",
        "        self.add(fuller_rect, fs_rect, *self.mobjects)\n",
        "\n",
        "        graph_groups = VGroup(*(\n",
        "            VGroup(plot[1], label).copy()\n",
        "            for plot, label in zip(plots, graph_labels)\n",
        "        ))\n",
        "        graph_groups.generate_target()\n",
        "        for graph_group in graph_groups.target:\n",
        "            graph_group[0].stretch(0.5, 0, about_edge=LEFT)\n",
        "            graph_group[0].set_stroke(width=4)\n",
        "            graph_group[1].shift(SMALL_BUFF * UP)\n",
        "\n",
        "        kw = dict(font_size=96)\n",
        "        lp, rp = parens = Tex(\"()\", **kw)\n",
        "        parens.stretch(1.5, 1)\n",
        "        parens.match_height(graph_groups.target[0])\n",
        "        equation = VGroup(\n",
        "            lp.copy(), graph_groups.target[0], rp.copy(),\n",
        "            Tex(\"*\", **kw),\n",
        "            lp.copy(), graph_groups.target[1], rp.copy(),\n",
        "            Tex(\"=\", **kw),\n",
        "            graph_groups.target[2],\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=0.5)\n",
        "        equation[:3].space_out_submobjects(0.9)\n",
        "        equation[4:7].space_out_submobjects(0.9)\n",
        "        equation.next_to(plots, UP, buff=1.5)\n",
        "        symbols = VGroup(*(\n",
        "            mob for mob in equation\n",
        "            if mob not in graph_groups.target\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(13, about_point = 3 * DOWN),\n",
        "            FadeIn(fuller_rect),\n",
        "            FadeIn(fs_rect),\n",
        "            MoveToTarget(graph_groups, run_time=2),\n",
        "            Write(symbols, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label convolution\n",
        "        conv_label = Text(\"Convolution\", font_size=72)\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(equation[3], UP)\n",
        "        conv_label.next_to(arrow, UP)\n",
        "        VGroup(conv_label, arrow).set_color(YELLOW)\n",
        "        self.play(Write(conv_label), GrowArrow(arrow))\n",
        "\n",
        "        # More repeated samples\n",
        "        self.repeated_samples(\n",
        "            plots, 50,\n",
        "            animate=False,\n",
        "            time_between_samples=0.1,\n",
        "            time_before_fade=0.5\n",
        "        )\n",
        "\n",
        "    def get_axes(self):\n",
        "        kw = dict(width=5.5, height=2,)\n",
        "        return VGroup(\n",
        "            Axes((0, 10), (0, 1.0, 0.25), **kw),\n",
        "            Axes((0, 10), (0, 0.5, 0.25), **kw),\n",
        "            Axes((0, 10), (0, 0.5, 0.25), **kw),\n",
        "        )\n",
        "\n",
        "    def get_random_variables(self):\n",
        "        return [\n",
        "            scipy.stats.gamma(1),\n",
        "            scipy.stats.gamma(3),\n",
        "        ]\n",
        "\n",
        "    def get_sum_graph(self, axes):\n",
        "        var = scipy.stats.gamma(4)\n",
        "        return axes.get_graph(\n",
        "            var.pdf,\n",
        "            color=self.graph_colors[2]\n",
        "        )\n",
        "\n",
        "\n",
        "class SampleWedgePlusDoubleLump(RepeatedSamplesFromContinuousDistributions):\n",
        "    def construct(self):\n",
        "        # Plots\n",
        "        plots = self.get_plots()\n",
        "        plots[0][1].make_jagged()\n",
        "        self.add(plots)\n",
        "\n",
        "        # Initial samples\n",
        "        self.repeated_samples(\n",
        "            plots, 50,\n",
        "            animate=False,\n",
        "            time_between_samples=0.1,\n",
        "            time_before_fade=0.5\n",
        "        )\n",
        "\n",
        "    def get_axes(self):\n",
        "        return VGroup(*(\n",
        "            Axes(\n",
        "                (-2, 2), (0, 1, 0.25),\n",
        "                width=5.5,\n",
        "                height=2.5,\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ))\n",
        "\n",
        "    def get_samples(self):\n",
        "        x1 = sum(np.random.uniform(-0.5, 0.5, 2))\n",
        "        # Hack\n",
        "        x2 = np.random.normal(0, 0.5)\n",
        "        x2 += (0.5 if random.random() < 0.3 else -0.5)\n",
        "\n",
        "        return [x1, x2]\n",
        "\n",
        "    def get_pdfs(self):\n",
        "        return [wedge_func, double_lump]\n",
        "\n",
        "\n",
        "class ContinuousSampleAnnotations(SampleWedgePlusDoubleLump):\n",
        "    def construct(self):\n",
        "        plots = self.get_plots()\n",
        "        plots[0][1].make_jagged()\n",
        "        # self.add(plots)\n",
        "\n",
        "        thick_graphs = VGroup(*(\n",
        "            plot[1].copy().set_stroke(width=10)\n",
        "            for plot in plots\n",
        "        ))\n",
        "\n",
        "        # Labels\n",
        "        func_labels = VGroup(Tex(\"f(x)\"), Tex(\"g(y)\"))\n",
        "        func_labels.scale(0.75)\n",
        "        for graph, label in zip(thick_graphs, func_labels):\n",
        "            label.next_to(graph.pfp(0.4), LEFT)\n",
        "            self.play(\n",
        "                Write(label, time_span=(1, 2)),\n",
        "                VShowPassingFlash(graph, time_width=1.5, run_time=3),\n",
        "            )\n",
        "\n",
        "        # Question\n",
        "        question = Text(\"What is this?\")\n",
        "        question.move_to(plots[2][0].get_corner(UL)).shift(0.5 * RIGHT)\n",
        "        question.set_color(TEAL_A)\n",
        "        arrow = Arrow(question.get_bottom(), plots[2][1].pfp(0.25), buff=0.2)\n",
        "        arrow.set_color(TEAL_A)\n",
        "\n",
        "        self.play(FadeIn(question), GrowArrow(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UniformSamples(RepeatedSamplesFromContinuousDistributions):\n",
        "    def construct(self):\n",
        "        # Plots\n",
        "        plots = self.get_plots()\n",
        "        funcs = [uniform, uniform, wedge_func]\n",
        "\n",
        "        for plot, func in zip(plots, funcs):\n",
        "            axes, graph, label = plot\n",
        "            axes.y_axis.add_numbers(\n",
        "                np.arange(0.5, 2.5, 0.5),\n",
        "                font_size=12,\n",
        "                buff=0.15,\n",
        "                num_decimal_places=1,\n",
        "            )\n",
        "            new_graph = axes.get_graph(\n",
        "                func,\n",
        "                x_range=(-2, 2, 0.01),\n",
        "                use_smoothing=False\n",
        "            )\n",
        "            new_graph.match_style(graph)\n",
        "            graph.match_points(new_graph)\n",
        "\n",
        "        plots[2][1].set_opacity(0)\n",
        "        plots[2][0].y_axis.set_opacity(0)\n",
        "\n",
        "        self.add(plots)\n",
        "\n",
        "        # Samples\n",
        "        self.repeated_samples(\n",
        "            plots, 50,\n",
        "            animate=False,\n",
        "            time_between_samples=0.1,\n",
        "            time_before_fade=0.5\n",
        "        )\n",
        "\n",
        "    def get_axes(self):\n",
        "        return VGroup(*(\n",
        "            Axes(\n",
        "                (-2, 2), (0, 2, 0.5),\n",
        "                width=5.5,\n",
        "                height=2,\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ))\n",
        "\n",
        "    def get_samples(self):\n",
        "        return np.random.uniform(-0.5, 0.5, 2)\n",
        "\n",
        "    def get_pdfs(self):\n",
        "        return [uniform, uniform]\n",
        "\n",
        "\n",
        "class WedgeAndExpSamples(SampleWedgePlusDoubleLump):\n",
        "    def get_axes(self):\n",
        "        return VGroup(\n",
        "            Axes(\n",
        "                (-2, 2), (0, 1, 0.25),\n",
        "                width=5.5,\n",
        "                height=2,\n",
        "            ),\n",
        "            Axes(\n",
        "                (-2, 5), (0, 1.0, 0.25),\n",
        "                width=5.5,\n",
        "                height=2,\n",
        "            ),\n",
        "            Axes(\n",
        "                (-3, 6), (0, 1.0, 0.25),\n",
        "                width=5.5,\n",
        "                height=2,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def get_random_variables(self):\n",
        "        return [\n",
        "            scipy.stats.gamma(1),\n",
        "            scipy.stats.gamma(3),\n",
        "        ]\n",
        "\n",
        "    def get_samples(self):\n",
        "        wedge_sum = np.random.uniform(-0.5, 0.5, 2).sum()\n",
        "        exp_value = np.clip(self.random_variables[0].rvs() - 2, -2, 5)\n",
        "        return [wedge_sum, exp_value]\n",
        "\n",
        "    def get_pdfs(self):\n",
        "        return [wedge_func, lambda x: self.random_variables[0].pdf(x + 2)]\n",
        "\n",
        "\n",
        "# Sliding window view of convolutions\n",
        "\n",
        "\n",
        "class Convolutions(InteractiveScene):\n",
        "    axes_config = dict(\n",
        "        x_range=(-3, 3, 1),\n",
        "        y_range=(-1, 1, 1.0),\n",
        "        width=6,\n",
        "        height=2,\n",
        "    )\n",
        "    f_graph_style = dict(stroke_color=BLUE, stroke_width=2)\n",
        "    g_graph_style = dict(stroke_color=YELLOW, stroke_width=2)\n",
        "    fg_graph_style = dict(stroke_color=GREEN, stroke_width=4)\n",
        "    conv_graph_style = dict(stroke_color=TEAL, stroke_width=2)\n",
        "    f_graph_x_step = 0.1\n",
        "    g_graph_x_step = 0.1\n",
        "    f_label_tex = \"f(x)\"\n",
        "    g_label_tex = \"g(s - x)\"\n",
        "    fg_label_tex = R\"f(x) \\cdot g(s - x)\"\n",
        "    conv_label_tex = R\"[f * g](s) = \\int_{-\\infty}^\\infty f(x) \\cdot g(s - x) dx\"\n",
        "    label_config = dict(font_size=36)\n",
        "    t_color = TEAL\n",
        "    area_line_dx = 0.05\n",
        "    jagged_product = True\n",
        "    jagged_convolution = True\n",
        "    g_is_rect = False\n",
        "    conv_y_stretch_factor = 2.0\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        if self.g_is_rect:\n",
        "            k1_tracker = self.k1_tracker = ValueTracker(1)\n",
        "            k2_tracker = self.k2_tracker = ValueTracker(1)\n",
        "\n",
        "        # Add axes\n",
        "        all_axes = self.all_axes = self.get_all_axes()\n",
        "        f_axes, g_axes, fg_axes, conv_axes = all_axes\n",
        "        x_min, x_max = self.axes_config[\"x_range\"][:2]\n",
        "\n",
        "        self.disable_interaction(*all_axes)\n",
        "        self.add(*all_axes)\n",
        "\n",
        "        # Add f(x)\n",
        "        f_graph = self.f_graph = f_axes.get_graph(self.f, x_range=(x_min, x_max, self.f_graph_x_step))\n",
        "        f_graph.set_style(**self.f_graph_style)\n",
        "        f_label = self.f_label = self.get_label(self.f_label_tex, f_axes)\n",
        "        if self.jagged_product:\n",
        "            f_graph.make_jagged()\n",
        "\n",
        "        self.add(f_graph)\n",
        "        self.add(f_label)\n",
        "\n",
        "        # Add g(s - x)\n",
        "        self.toggle_selection_mode()  # So triangle is highlighted\n",
        "        s_indicator = self.s_indicator = ArrowTip().rotate(90 * DEGREES)\n",
        "        s_indicator.set_height(0.15)\n",
        "        s_indicator.set_fill(self.t_color, 0.8)\n",
        "        s_indicator.move_to(g_axes.get_origin(), UP)\n",
        "        s_indicator.add_updater(lambda m: m.align_to(g_axes.get_origin(), UP))\n",
        "\n",
        "        def get_s():\n",
        "            return g_axes.x_axis.p2n(s_indicator.get_center())\n",
        "\n",
        "        self.get_s = get_s\n",
        "        g_graph = self.g_graph = g_axes.get_graph(lambda x: 0, x_range=(x_min, x_max, self.g_graph_x_step))\n",
        "        g_graph.set_style(**self.g_graph_style)\n",
        "        if self.g_is_rect:\n",
        "            x_min = g_axes.x_axis.x_min\n",
        "            x_max = g_axes.x_axis.x_max\n",
        "            g_graph.add_updater(lambda m: m.set_points_as_corners([\n",
        "                g_axes.c2p(x, y)\n",
        "                for s in [get_s()]\n",
        "                for k1 in [k1_tracker.get_value()]\n",
        "                for k2 in [k2_tracker.get_value()]\n",
        "                for x, y in [\n",
        "                    (x_min, 0), (-0.5 / k1 + s, 0), (-0.5 / k1 + s, k2), (0.5 / k1 + s, k2), (0.5 / k1 + s, 0), (x_max, 0)\n",
        "                ]\n",
        "            ]))\n",
        "        else:\n",
        "            g_axes.bind_graph_to_func(g_graph, lambda x: self.g(get_s() - x), jagged=self.jagged_product)\n",
        "\n",
        "        g_label = self.g_label = self.get_label(self.g_label_tex, g_axes)\n",
        "\n",
        "        s_label = self.s_label = VGroup(*Tex(\"s = \"), DecimalNumber())\n",
        "        s_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        s_label.scale(0.5)\n",
        "        s_label.set_backstroke(width=8)\n",
        "        s_label.add_updater(lambda m: m.next_to(s_indicator, DOWN, buff=0.15))\n",
        "        s_label.add_updater(lambda m: m[-1].set_value(get_s()))\n",
        "\n",
        "        self.add(g_graph)\n",
        "        self.add(g_label)\n",
        "        self.add(s_indicator)\n",
        "        self.add(s_label)\n",
        "\n",
        "        # Show integral of f(x) * g(s - x)\n",
        "        def prod_func(x):\n",
        "            k1 = self.k1_tracker.get_value() if self.g_is_rect else 1\n",
        "            k2 = self.k2_tracker.get_value() if self.g_is_rect else 1\n",
        "            return self.f(x) * self.g((get_s() - x) * k1) * k2\n",
        "\n",
        "        fg_graph = fg_axes.get_graph(lambda x: 0, x_range=(x_min, x_max, self.g_graph_x_step))\n",
        "        pos_graph = fg_graph.copy()\n",
        "        neg_graph = fg_graph.copy()\n",
        "        for graph in f_graph, g_graph, fg_graph, pos_graph, neg_graph:\n",
        "            self.disable_interaction(graph)\n",
        "        fg_graph.set_style(**self.fg_graph_style)\n",
        "        VGroup(pos_graph, neg_graph).set_stroke(width=0)\n",
        "        pos_graph.set_fill(BLUE, 0.5)\n",
        "        neg_graph.set_fill(RED, 0.5)\n",
        "\n",
        "        get_discontinuities = None\n",
        "        if self.g_is_rect:\n",
        "            def get_discontinuities():\n",
        "                k1 = self.k1_tracker.get_value()\n",
        "                return [get_s() - 0.5 / k1, get_s() + 0.5 / k1]\n",
        "\n",
        "        kw = dict(\n",
        "            jagged=self.jagged_product,\n",
        "            get_discontinuities=get_discontinuities,\n",
        "        )\n",
        "        fg_axes.bind_graph_to_func(fg_graph, prod_func, **kw)\n",
        "        fg_axes.bind_graph_to_func(pos_graph, lambda x: np.clip(prod_func(x), 0, np.inf), **kw)\n",
        "        fg_axes.bind_graph_to_func(neg_graph, lambda x: np.clip(prod_func(x), -np.inf, 0), **kw)\n",
        "\n",
        "        self.prod_graphs = VGroup(fg_graph, pos_graph, neg_graph)\n",
        "\n",
        "        fg_label = self.fg_label = self.get_label(self.fg_label_tex, fg_axes)\n",
        "\n",
        "        self.add(pos_graph, neg_graph, fg_axes, fg_graph)\n",
        "        self.add(fg_label)\n",
        "\n",
        "        # Show convolution\n",
        "        conv_graph = self.conv_graph = self.get_conv_graph(conv_axes)\n",
        "        if self.jagged_convolution:\n",
        "            conv_graph.make_jagged()\n",
        "        conv_graph.set_style(**self.conv_graph_style)\n",
        "\n",
        "        graph_dot = self.graph_dot = GlowDot(color=WHITE)\n",
        "        graph_dot.add_updater(lambda d: d.move_to(conv_graph.quick_point_from_proportion(\n",
        "            inverse_interpolate(x_min, x_max, get_s())\n",
        "        )))\n",
        "        graph_line = self.graph_line = Line(stroke_color=WHITE, stroke_width=1)\n",
        "        graph_line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            graph_dot.get_center(),\n",
        "            [graph_dot.get_x(), conv_axes.get_y(), 0],\n",
        "        ))\n",
        "        self.conv_graph_dot = graph_dot\n",
        "        self.conv_graph_line = graph_line\n",
        "\n",
        "        conv_label = self.conv_label = Tex(self.conv_label_tex, **self.label_config)\n",
        "        conv_label.match_x(conv_axes)\n",
        "        conv_label.set_y(np.mean([conv_axes.get_y(UP), FRAME_HEIGHT / 2]))\n",
        "\n",
        "        self.add(conv_graph)\n",
        "        self.add(graph_dot)\n",
        "        self.add(graph_line)\n",
        "        self.add(conv_label)\n",
        "\n",
        "    def get_all_axes(self):\n",
        "        all_axes = VGroup(*(Axes(**self.axes_config) for x in range(4)))\n",
        "        all_axes[:3].arrange(DOWN, buff=0.75)\n",
        "        all_axes[3].next_to(all_axes[:3], RIGHT, buff=1.5)\n",
        "        all_axes[3].y_axis.stretch(\n",
        "            self.conv_y_stretch_factor, 1\n",
        "        )\n",
        "        all_axes.to_edge(LEFT)\n",
        "        all_axes.to_edge(DOWN, buff=0.1)\n",
        "\n",
        "        for i, axes in enumerate(all_axes):\n",
        "            x_label = Tex(\"x\" if i < 3 else \"s\", font_size=24)\n",
        "            x_label.next_to(axes.x_axis.get_right(), UP, MED_SMALL_BUFF)\n",
        "            axes.x_label = x_label\n",
        "            axes.x_axis.add(x_label)\n",
        "            axes.y_axis.ticks.set_opacity(0)\n",
        "            axes.x_axis.ticks.stretch(0.5, 1)\n",
        "\n",
        "        return all_axes\n",
        "\n",
        "    def get_label(self, tex, axes):\n",
        "        label = Tex(tex, **self.label_config)\n",
        "        label.move_to(midpoint(axes.get_origin(), axes.get_right()))\n",
        "        label.match_y(axes.get_top())\n",
        "        return label\n",
        "\n",
        "    def get_conv_graph(self, conv_axes):\n",
        "        return get_conv_graph(conv_axes, self.f, self.g)\n",
        "\n",
        "    def get_conv_s_indicator(self):\n",
        "        g_s_indicator = VGroup(self.s_indicator, self.s_label)\n",
        "        f_axes, g_axes, fg_axes, conv_axes = self.all_axes\n",
        "\n",
        "        def get_s():\n",
        "            return g_axes.x_axis.p2n(self.s_indicator.get_x())\n",
        "\n",
        "        conv_s_indicator = g_s_indicator.copy()\n",
        "        conv_s_indicator.add_updater(lambda m: m.become(g_s_indicator))\n",
        "        conv_s_indicator.add_updater(lambda m: m.shift(\n",
        "            conv_axes.c2p(get_s(), 0) - g_axes.c2p(get_s(), 0)\n",
        "        ))\n",
        "        return conv_s_indicator\n",
        "\n",
        "    def f(self, x):\n",
        "        return 0.5 * np.exp(-0.8 * x**2) * (0.5 * x**3 - 3 * x + 1)\n",
        "\n",
        "    def g(self, x):\n",
        "        return np.exp(-x**2) * np.sin(2 * x)\n",
        "\n",
        "\n",
        "class ProbConvolutions(Convolutions):\n",
        "    jagged_product = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Hit most of previous setup\n",
        "        f_axes, g_axes, fg_axes, conv_axes = self.all_axes\n",
        "        f_graph, g_graph, prod_graphs, conv_graph = self.f_graph, self.g_graph, self.prod_graphs, self.conv_graph\n",
        "        f_label, g_label, fg_label, conv_label = self.f_label, self.g_label, self.fg_label, self.conv_label\n",
        "        s_indicator = self.s_indicator\n",
        "        s_label = self.s_label\n",
        "        self.remove(s_indicator, s_label)\n",
        "\n",
        "        f_axes.x_axis.add_numbers(font_size=16, buff=0.1, excluding=[0])\n",
        "        self.remove(f_axes, f_graph, f_label)\n",
        "\n",
        "        y_label = Tex(\"y\").replace(g_axes.x_label)\n",
        "        g_label.shift(0.2 * UP)\n",
        "        gy_label = Tex(\"g(y)\", **self.label_config).replace(g_label, dim_to_match=1)\n",
        "        gmx_label = Tex(\"g(-x)\", **self.label_config).replace(g_label, dim_to_match=1)\n",
        "        g_axes.x_label.set_opacity(0)\n",
        "        self.remove(g_axes, g_graph, g_label)\n",
        "\n",
        "        alt_fg_label = Tex(R\"p_X(x) \\cdot g(-x)\", **self.label_config)\n",
        "        alt_fg_label.move_to(fg_label)\n",
        "\n",
        "        conv_label.shift_onto_screen()\n",
        "        sum_label = Tex(\"[f * g](s)\", **self.label_config)\n",
        "        sum_label.move_to(conv_label)\n",
        "        self.remove(fg_axes, prod_graphs, fg_label)\n",
        "        conv_cover = SurroundingRectangle(conv_axes, buff=0.25)\n",
        "        conv_cover.set_stroke(width=0)\n",
        "        conv_cover.set_fill(BLACK, 0.5)\n",
        "        self.add(conv_cover)\n",
        "\n",
        "        # Show f\n",
        "        f_term = conv_label[\"f(x)\"][0]\n",
        "        f_rect = SurroundingRectangle(f_term)\n",
        "        f_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(f_rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(f_term, f_label),\n",
        "            FadeIn(f_axes),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(f_graph),\n",
        "            VShowPassingFlash(f_graph.copy().set_stroke(width=5)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show g\n",
        "        true_g_graph = g_axes.get_graph(self.g)\n",
        "        true_g_graph.match_style(g_graph)\n",
        "\n",
        "        g_term = conv_label[\"g\"][1]\n",
        "        g_rect = SurroundingRectangle(g_term, buff=0.05)\n",
        "        g_rect.match_style(f_rect)\n",
        "\n",
        "        self.play(ReplacementTransform(f_rect, g_rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(g_term, gy_label),\n",
        "            FadeIn(g_axes),\n",
        "            FadeIn(y_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(true_g_graph),\n",
        "            VShowPassingFlash(true_g_graph.copy().set_stroke(width=5)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Range over pairs of values\n",
        "        int_rect = SurroundingRectangle(conv_label[re.compile(R\"\\\\int.*\")])\n",
        "        x_rects = VGroup(*(\n",
        "            SurroundingRectangle(x, buff=0.05)\n",
        "            for x in conv_label[\"x\"]\n",
        "        ))\n",
        "        VGroup(int_rect, *x_rects).match_style(g_rect)\n",
        "\n",
        "        const_sum = 0.3\n",
        "        x_tracker = ValueTracker(-1.0)\n",
        "        y_tracker = ValueTracker()\n",
        "        x_term = DecimalNumber(include_sign=True, edge_to_fix=RIGHT)\n",
        "        y_term = DecimalNumber(include_sign=True)\n",
        "        s_term = DecimalNumber(const_sum)\n",
        "        equation = VGroup(x_term, y_term, Tex(\"=\"), s_term)\n",
        "        VGroup(x_term, s_term).shift(0.05 * RIGHT)\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.match_x(conv_label)\n",
        "\n",
        "        x_brace, y_brace, s_brace = braces = VGroup(*(\n",
        "            Brace(term, UP, SMALL_BUFF)\n",
        "            for term in [x_term, y_term, s_term]\n",
        "        ))\n",
        "        x_brace.add(x_brace.get_tex(\"x\").set_color(BLUE))\n",
        "        y_brace.add(y_brace.get_tex(\"y\").set_color(YELLOW))\n",
        "        s_brace.add(s_brace.get_tex(\"s\").set_color(GREY_B))\n",
        "        y_brace[-1].align_to(x_brace[-1], UP)\n",
        "        alt_y_label = Tex(\"s - x\")\n",
        "        alt_y_label.space_out_submobjects(0.8)\n",
        "        alt_y_label.move_to(y_brace[-1], UP)\n",
        "        alt_y_label.set_color_by_tex_to_color_map({\"s\": GREY_B, \"x\": BLUE})\n",
        "\n",
        "        def get_x():\n",
        "            return x_tracker.get_value()\n",
        "\n",
        "        def get_y():\n",
        "            return const_sum - get_x()\n",
        "\n",
        "        f_always(y_tracker.set_value, get_y)\n",
        "        f_always(x_term.set_value, get_x)\n",
        "        f_always(y_term.set_value, get_y)\n",
        "\n",
        "        Axes.get_v_line_to_graph\n",
        "        x_line = always_redraw(lambda: f_axes.get_v_line_to_graph(\n",
        "            get_x(), f_graph, line_func=Line, color=WHITE\n",
        "        ))\n",
        "        y_line = always_redraw(lambda: g_axes.get_v_line_to_graph(\n",
        "            get_y(), true_g_graph, line_func=Line, color=WHITE\n",
        "        ))\n",
        "        x_dot = GlowDot(color=BLUE)\n",
        "        y_dot = GlowDot(color=YELLOW)\n",
        "        f_always(x_dot.move_to, x_line.get_end)\n",
        "        f_always(y_dot.move_to, y_line.get_end)\n",
        "\n",
        "        self.play(ReplacementTransform(g_rect, int_rect))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            conv_cover.animate.set_opacity(1),\n",
        "            FadeIn(equation),\n",
        "            FadeIn(braces),\n",
        "            VFadeIn(x_line),\n",
        "            VFadeIn(y_line),\n",
        "            FadeIn(x_dot),\n",
        "            FadeIn(y_dot),\n",
        "        ))\n",
        "        for x in [1.0, -1.0]:\n",
        "            self.play(x_tracker.animate.set_value(x), run_time=8)\n",
        "\n",
        "        self.wait()\n",
        "        self.remove(int_rect)\n",
        "        self.play(*(\n",
        "            ReplacementTransform(int_rect.copy(), x_rect)\n",
        "            for x_rect in x_rects\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(x_rects, lag_ratio=0.5))\n",
        "        self.play(\n",
        "            FadeTransform(conv_label[\"s - x\"].copy(), alt_y_label),\n",
        "            y_brace[-1].animate.set_opacity(0)\n",
        "        )\n",
        "        self.remove(alt_y_label)\n",
        "        y_brace[-1].become(alt_y_label)\n",
        "\n",
        "        for x in [1.0, -1.0]:\n",
        "            self.play(x_tracker.animate.set_value(x), run_time=8)\n",
        "\n",
        "        self.play(LaggedStart(*map(FadeOut, [\n",
        "            x_line, x_dot, y_line, y_dot,\n",
        "            *equation, *braces\n",
        "        ])), lag_ratio=0.2)\n",
        "\n",
        "        # Flip g\n",
        "        gsmx_rect = SurroundingRectangle(conv_label[\"g(s - x)\"], buff=0.05)\n",
        "        gsmx_rect.match_style(g_rect)\n",
        "\n",
        "        g_axes_copy = g_axes.copy()\n",
        "        g_axes_copy.add(y_label)\n",
        "        true_group = VGroup(g_axes_copy, gy_label, true_g_graph)\n",
        "\n",
        "        self.play(ShowCreation(gsmx_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            true_group.animate.to_edge(DOWN, buff=MED_SMALL_BUFF),\n",
        "        )\n",
        "        self.add(*true_group)\n",
        "        g_axes.generate_target()\n",
        "        g_axes.target.x_label.set_opacity(1),\n",
        "        self.play(\n",
        "            TransformMatchingShapes(gy_label.copy(), gmx_label),\n",
        "            true_g_graph.copy().animate.flip().move_to(g_graph).set_anim_args(remover=True),\n",
        "            MoveToTarget(g_axes),\n",
        "        )\n",
        "        self.add(g_graph)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(true_group))\n",
        "\n",
        "        # Show the parameter s\n",
        "        self.play(\n",
        "            s_indicator.animate.match_x(g_axes.c2p(2, 0)).set_anim_args(run_time=3),\n",
        "            VFadeIn(s_indicator),\n",
        "            VFadeIn(s_label),\n",
        "            TransformMatchingTex(gmx_label, g_label, run_time=1),\n",
        "        )\n",
        "        self.wait()  # Play with the slider\n",
        "        self.play(\n",
        "            s_indicator.animate.match_x(g_axes.c2p(0.3, 0))\n",
        "        )\n",
        "\n",
        "        # Show product\n",
        "        fg_rect = SurroundingRectangle(conv_label[R\"f(x) \\cdot g(s - x)\"])\n",
        "        fg_rect.match_style(g_rect)\n",
        "\n",
        "        self.play(ReplacementTransform(gsmx_rect, fg_rect))\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(f_axes.copy(), fg_axes),\n",
        "            FadeTransform(g_axes.copy(), fg_axes),\n",
        "            Transform(f_graph.copy(), prod_graphs[0].copy(), remover=True),\n",
        "            Transform(g_graph.copy(), prod_graphs[0].copy(), remover=True),\n",
        "            TransformFromCopy(\n",
        "                VGroup(*f_label, *g_label),\n",
        "                fg_label\n",
        "            ),\n",
        "            FadeOut(fg_rect),\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.add(*prod_graphs)\n",
        "        self.play(FadeIn(prod_graphs[1]))\n",
        "        self.add(prod_graphs)\n",
        "        # Play with the slider\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_indicator.animate.match_x(g_axes.c2p(-0.8, 0))\n",
        "        )\n",
        "\n",
        "        # Show convolution\n",
        "        def get_s():\n",
        "            return g_axes.x_axis.p2n(s_indicator.get_x())\n",
        "\n",
        "        conv_s_indicator = self.get_conv_s_indicator()\n",
        "\n",
        "        self.play(FadeOut(conv_cover))\n",
        "        self.play(Transform(\n",
        "            VGroup(indicator, s_label).copy().clear_updaters(),\n",
        "            conv_s_indicator.copy().clear_updaters(),\n",
        "            remover=True\n",
        "        ))\n",
        "        self.add(conv_s_indicator)\n",
        "        # Play with the slider\n",
        "        self.wait()\n",
        "        self.play(s_indicator.animate.match_x(g_axes.c2p(-0.4, 0)))\n",
        "\n",
        "    def highlight_several_regions(self, highlighted_xs=None, s=0, reference=None):\n",
        "        # Highlight a few regions\n",
        "        if highlighted_xs is None:\n",
        "            highlighted_xs = np.arange(-1, 1.1, 0.1)\n",
        "\n",
        "        g_axes = self.all_axes[1]\n",
        "        highlight_rect = Rectangle(width=0.1, height=FRAME_HEIGHT / 2)\n",
        "        highlight_rect.set_stroke(width=0)\n",
        "        highlight_rect.set_fill(TEAL, 0.5)\n",
        "        highlight_rect.move_to(g_axes.get_origin(), DOWN)\n",
        "        highlight_rect.set_opacity(0.5)\n",
        "        self.add(highlight_rect)\n",
        "\n",
        "        last_label = VMobject()\n",
        "        for x in highlighted_xs:\n",
        "            x_tex = f\"{{{np.round(x, 1)}}}\"\n",
        "            diff_tex = f\"{{{np.round(s - x, 1)}}}\"\n",
        "            label = Tex(\n",
        "                fR\"p_X({x_tex}) \\cdot p_Y({diff_tex})\",\n",
        "                tex_to_color_map={diff_tex: YELLOW, x_tex: BLUE},\n",
        "                font_size=36\n",
        "            )\n",
        "            if reference:\n",
        "                label.next_to(reference, UP, MED_LARGE_BUFF)\n",
        "            else:\n",
        "                label.next_to(ORIGIN, DOWN, LARGE_BUFF)\n",
        "\n",
        "            highlight_rect.set_x(g_axes.c2p(x, 0)[0]),\n",
        "            self.add(label)\n",
        "            self.remove(last_label)\n",
        "            self.wait(0.25)\n",
        "            last_label = label\n",
        "        self.play(FadeOut(last_label), FadeOut(highlight_rect))\n",
        "\n",
        "    def f(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return double_lump(x)\n",
        "\n",
        "\n",
        "class ConvolveTwoUniforms(Convolutions):\n",
        "    jagged_product = True\n",
        "    jagged_convolution = True\n",
        "    axes_config = dict(\n",
        "        x_range=(-2, 2, 0.5),\n",
        "        y_range=(-1, 1, 1.0),\n",
        "        width=6,\n",
        "        height=2,\n",
        "    )\n",
        "    f_graph_x_step = 0.025\n",
        "    g_graph_x_step = 0.025\n",
        "    conv_y_stretch_factor = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        self.all_axes[0].x_axis.add_numbers(\n",
        "            font_size=16, num_decimal_places=1,\n",
        "            excluding=[0], buff=0.1,\n",
        "        )\n",
        "        self.g_label.shift(MED_LARGE_BUFF * UP)\n",
        "        self.fg_label.shift(MED_LARGE_BUFF * UP)\n",
        "        self.add(self.get_conv_s_indicator())\n",
        "\n",
        "        # Show it all\n",
        "        self.wait(60)\n",
        "\n",
        "    def f(self, x):\n",
        "        return uniform(x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return uniform(x)\n",
        "\n",
        "\n",
        "class ConvolveUniformWithWedge(Convolutions):\n",
        "    f_graph_x_step = 0.025\n",
        "    g_graph_x_step = 0.025\n",
        "\n",
        "    def construct(self):\n",
        "        self.conv_graph.shift(0.025 * LEFT)\n",
        "\n",
        "        # Play around with it\n",
        "        self.wait(20)\n",
        "\n",
        "    def f(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return uniform(x)\n",
        "\n",
        "\n",
        "class ConvolveTwoNormals(Convolutions):\n",
        "    def construct(self):\n",
        "        # Play around with it\n",
        "        self.wait(20)\n",
        "\n",
        "    def f(self, x):\n",
        "        return gauss_func(x, 0, 0.5)\n",
        "\n",
        "    def g(self, x):\n",
        "        return gauss_func(x, 0, 0.5)\n",
        "\n",
        "\n",
        "class ProbConvolutionControlled(ProbConvolutions):\n",
        "    t_time_pairs = [(-2.5, 4), (2.5, 10), (-1, 6)]\n",
        "    initial_t = 0\n",
        "\n",
        "    def construct(self):\n",
        "        s_indicator = self.s_indicator\n",
        "        g_axes = self.all_axes[1]\n",
        "\n",
        "        def set_t(t):\n",
        "            return s_indicator.animate.set_x(g_axes.c2p(t, 0)[0])\n",
        "\n",
        "        s_indicator.set_x(g_axes.c2p(self.initial_t, 0)[0])\n",
        "        for t, time in self.t_time_pairs:\n",
        "            self.play(set_t(t), run_time=time)\n",
        "\n",
        "\n",
        "class ProbConvolutionControlledToMatchSlices(ProbConvolutionControlled):\n",
        "    t_time_pairs = [(-1.5, 20), (1.5, 20), (-0.5, 20)]\n",
        "    initial_t = 2\n",
        "\n",
        "\n",
        "class AltSyncedConvolution(ProbConvolutionControlledToMatchSlices):\n",
        "    t_time_pairs = [(1.0, 15), (-1.5, 10), (-3.0, 10), (1.0, 20)]\n",
        "    initial_t = -3.0\n",
        "\n",
        "    def f(self, x):\n",
        "        return (x > -2) * np.exp(-2 - x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "\n",
        "class ThumbnailGraphs(AltSyncedConvolution):\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        s_indicator = self.s_indicator\n",
        "        f_axes, g_axes = self.all_axes[:2]\n",
        "\n",
        "        for axes in [f_axes, g_axes]:\n",
        "            axes.set_stroke(width=4)\n",
        "            axes.x_axis[1].set_stroke(width=0)\n",
        "        for graph in [self.f_graph, self.g_graph, self.prod_graphs]:\n",
        "            graph.set_stroke(width=8)\n",
        "\n",
        "        s = -1.68\n",
        "        s_indicator.set_x(g_axes.c2p(s, 0)[0])\n",
        "\n",
        "\n",
        "class AltConvolutions(Convolutions):\n",
        "    jagged_product = True\n",
        "\n",
        "    def construct(self):\n",
        "        s_indicator = self.s_indicator\n",
        "        g_axes = self.all_axes[1]\n",
        "\n",
        "        # Sample values\n",
        "        for t in [3, -3, -1.0]:\n",
        "            self.play(s_indicator.animate.set_x(g_axes.c2p(t, 0)[0]), run_time=3)\n",
        "            self.wait()\n",
        "\n",
        "    def f(self, x):\n",
        "        if x < -2:\n",
        "            return -0.5\n",
        "        elif x < -1:\n",
        "            return x + 1.5\n",
        "        elif x < 1:\n",
        "            return -0.5 * x\n",
        "        else:\n",
        "            return 0.5 * x - 1\n",
        "\n",
        "    def g(self, x):\n",
        "        return np.exp(-3 * x**2)\n",
        "\n",
        "\n",
        "class MovingAverageAsConvolution(Convolutions):\n",
        "    g_graph_x_step = 0.1\n",
        "    jagged_product = True\n",
        "    g_is_rect = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        super().construct()\n",
        "        s_indicator = self.s_indicator\n",
        "        f_axes, g_axes, fg_axes, conv_axes = self.all_axes\n",
        "        self.g_label.shift(0.25 * UP)\n",
        "        self.fg_label.shift(0.25 * UP)\n",
        "\n",
        "        y_axes = VGroup(*(axes.y_axis for axes in self.all_axes[1:3]))\n",
        "        fake_ys = y_axes.copy()\n",
        "        for fake_y in fake_ys:\n",
        "            fake_y.stretch(1.2, 1)\n",
        "        self.add(*fake_ys, *self.mobjects)\n",
        "\n",
        "        conv_axes.y_axis.match_height(f_axes.y_axis)\n",
        "        VGroup(conv_axes).match_y(f_axes)\n",
        "        self.conv_graph.match_points(get_conv_graph(conv_axes, self.f, self.g))\n",
        "        self.conv_label.next_to(conv_axes, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        # Sample values\n",
        "        def set_t(t):\n",
        "            return s_indicator.animate.set_x(g_axes.c2p(t, 0)[0])\n",
        "\n",
        "        self.play(set_t(-2.5), run_time=2)\n",
        "        self.play(set_t(2.5), run_time=8)\n",
        "        self.wait()\n",
        "        self.play(set_t(-1), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate to slice\n",
        "        top_line, side_line = Line().replicate(2)\n",
        "        top_line.add_updater(lambda l: l.put_start_and_end_on(*self.g_graph.get_anchors()[4:6]))\n",
        "        side_line.add_updater(lambda l: l.put_start_and_end_on(*self.g_graph.get_anchors()[2:4]))\n",
        "\n",
        "        top_line.set_stroke(width=0)\n",
        "        self.add(top_line)\n",
        "\n",
        "        left_rect, right_rect = fade_rects = FullScreenFadeRectangle().replicate(2)\n",
        "        left_rect.add_updater(lambda m: m.set_x(top_line.get_left()[0], RIGHT))\n",
        "        right_rect.add_updater(lambda m: m.set_x(top_line.get_right()[0], LEFT))\n",
        "\n",
        "        self.play(FadeIn(fade_rects))\n",
        "        self.play(set_t(-2), run_time=3)\n",
        "        self.play(set_t(-0.5), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(fade_rects))\n",
        "\n",
        "        # Show rect dimensions\n",
        "        get_k1 = self.k1_tracker.get_value\n",
        "        get_k2 = self.k2_tracker.get_value\n",
        "        top_label = DecimalNumber(1, font_size=24)\n",
        "        top_label.add_updater(lambda m: m.set_value(1.0 / get_k1()))\n",
        "        top_label.add_updater(lambda m: m.next_to(top_line, UP, SMALL_BUFF))\n",
        "        side_label = DecimalNumber(1, font_size=24)\n",
        "        side_label.add_updater(lambda m: m.set_value(get_k2()))\n",
        "        side_label.add_updater(lambda m: m.next_to(side_line, LEFT, SMALL_BUFF))\n",
        "\n",
        "        def change_ks(k1, k2, run_time=3):\n",
        "            new_conv_graph = get_conv_graph(\n",
        "                self.all_axes[3], self.f, lambda x: self.g(k1 * x) * k2,\n",
        "            )\n",
        "            new_conv_graph.match_style(self.conv_graph)\n",
        "            self.play(\n",
        "                self.k1_tracker.animate.set_value(k1),\n",
        "                self.k2_tracker.animate.set_value(k2),\n",
        "                Transform(self.conv_graph, new_conv_graph),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "        top_line.set_stroke(WHITE, 3)\n",
        "        side_line.set_stroke(RED, 3)\n",
        "        self.play(\n",
        "            ShowCreation(side_line),\n",
        "            VFadeIn(side_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(top_line),\n",
        "            VFadeIn(top_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change dimensions\n",
        "        change_ks(0.5, 1)\n",
        "        self.wait()\n",
        "        change_ks(0.5, 0.5)\n",
        "        self.play(set_t(-1.5), run_time=2)\n",
        "        self.play(set_t(-0.25), run_time=2)\n",
        "        self.wait()\n",
        "        change_ks(2, 0.5)\n",
        "        self.wait()\n",
        "        change_ks(2, 2)\n",
        "        self.wait()\n",
        "        change_ks(4, 4)\n",
        "        change_ks(1, 1)\n",
        "        self.play(*map(FadeOut, [top_label, top_line, side_label, side_line]))\n",
        "\n",
        "        # Show area\n",
        "        rect = Rectangle()\n",
        "        rect.set_fill(YELLOW, 0.5)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_gloss(1)\n",
        "        rect.add_updater(lambda m: m.set_width(g_axes.x_axis.unit_size / get_k1(), stretch=True))\n",
        "        rect.add_updater(lambda m: m.set_height(g_axes.y_axis.unit_size * get_k2(), stretch=True))\n",
        "        rect.add_updater(lambda m: m.set_x(s_indicator.get_x()))\n",
        "        rect.add_updater(lambda m: m.set_y(g_axes.get_origin()[1], DOWN))\n",
        "\n",
        "        area_label = Tex(R\"\\text{Area } = 1\", font_size=36)\n",
        "        area_label.next_to(rect, UP, MED_LARGE_BUFF)\n",
        "        area_label.to_edge(LEFT)\n",
        "        arrow = Arrow(area_label.get_bottom(), rect.get_center())\n",
        "\n",
        "        avg_label = TexText(R\"Average value of\\\\$f(x)$ in the window\", font_size=24)\n",
        "        avg_label.move_to(area_label, DL)\n",
        "        shift_value = self.all_axes[2].get_origin() - g_axes.get_origin() + 0.5 * DOWN\n",
        "        avg_label.shift(shift_value)\n",
        "        arrow2 = arrow.copy().shift(shift_value)\n",
        "\n",
        "        self.play(\n",
        "            Write(area_label, stroke_color=WHITE),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(avg_label, lag_ratio=0.1),\n",
        "            ShowCreation(arrow2)\n",
        "        )\n",
        "        self.wait()\n",
        "        for k in [1.4, 0.8, 1.0, 4.0, 10.0, 1.0]:\n",
        "            change_ks(k, k)\n",
        "        self.play(*map(FadeOut, [area_label, arrow, avg_label, arrow2]))\n",
        "\n",
        "        # More ambient variation\n",
        "        self.play(set_t(-2.5), run_time=3)\n",
        "        self.play(set_t(2.5), run_time=8)\n",
        "        self.play(set_t(0), run_time=4)\n",
        "        change_ks(20, 20)\n",
        "        self.wait()\n",
        "        change_ks(10, 10)\n",
        "        self.wait()\n",
        "        change_ks(0.2, 0.2, run_time=12)\n",
        "        self.wait()\n",
        "\n",
        "    def f(self, x):\n",
        "        return kinked_function(x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return rect_func(x)\n",
        "\n",
        "\n",
        "class GaussianConvolution(ProbConvolutionControlled):\n",
        "    jagged_product = True\n",
        "    t_time_pairs = [(-3.0, 4), (3.0, 10), (-1, 10), (1, 5)]\n",
        "    conv_y_stretch_factor = 1.0\n",
        "\n",
        "    def f(self, x):\n",
        "        return 1.5 * np.exp(-x**2) / np.sqrt(PI)\n",
        "\n",
        "    def g(self, x):\n",
        "        return 1.5 * np.exp(-x**2) / np.sqrt(PI)\n",
        "\n",
        "\n",
        "class GaussConvolutions(Convolutions):\n",
        "    conv_y_stretch_factor = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "\n",
        "    def f(self, x):\n",
        "        return np.exp(-x**2)\n",
        "\n",
        "    def g(self, x):\n",
        "        return np.exp(-x**2)\n",
        "\n",
        "\n",
        "class RepeatedConvolution(MovingAverageAsConvolution):\n",
        "    resolution = 0.01\n",
        "    n_iterations = 12\n",
        "    when_to_renormalize = 5\n",
        "    f_label_tex = \"f_1(x)\"\n",
        "    g_label_tex = \"f_1(s - x)\"\n",
        "    fg_label_tex = R\"f_1(x) \\cdot f_1(s - x)\"\n",
        "    conv_label_tex = R\"f_2(s) = [f_1 * f_1](s)\"\n",
        "    conv_y_stretch_factor = 1.0\n",
        "    convolution_creation_time = 5\n",
        "    pre_rescale_factor = 1.5\n",
        "    lower_graph_target_area = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Clean the board\n",
        "        dx = self.resolution\n",
        "        axes1, axes2, axes3, conv_axes = self.all_axes\n",
        "        g_graph = self.g_graph\n",
        "\n",
        "        x_min, x_max = axes1.x_range[:2]\n",
        "        x_samples = np.arange(x_min, x_max + dx, dx)\n",
        "        f_samples = np.array([self.f(x) for x in x_samples])\n",
        "        g_samples = np.array([self.g(x) for x in x_samples])\n",
        "\n",
        "        self.remove(\n",
        "            self.f_graph,\n",
        "            self.prod_graphs,\n",
        "            self.conv_graph,\n",
        "            self.conv_graph_dot,\n",
        "            self.conv_graph_line,\n",
        "        )\n",
        "        for axes in self.all_axes[:3]:\n",
        "            axes.x_label.set_opacity(0)\n",
        "\n",
        "        # New f graph\n",
        "        f_graph = g_graph.copy()\n",
        "        f_graph.clear_updaters()\n",
        "        f_graph.set_stroke(BLUE, 3)\n",
        "        f_graph.shift(axes1.get_origin() - axes2.get_origin())\n",
        "\n",
        "        self.add(f_graph)\n",
        "\n",
        "        # New prod graph\n",
        "        def update_prod_graph(prod_graph):\n",
        "            s = self.get_s()\n",
        "            prod_samples = np.array([\n",
        "                f_sample * self.g(s - x)\n",
        "                for f_sample, x in zip(f_samples, x_samples)\n",
        "            ])\n",
        "            prod_graph.set_points_as_corners(\n",
        "                axes3.c2p(x_samples, prod_samples)\n",
        "            )\n",
        "\n",
        "        prod_graph = VMobject()\n",
        "        prod_graph.set_stroke(GREEN, 2)\n",
        "        prod_graph.set_fill(BLUE_E, 1)\n",
        "        prod_graph.add_updater(update_prod_graph)\n",
        "\n",
        "        self.fg_label.shift(0.35 * UP)\n",
        "        self.g_label.shift(0.35 * UP)\n",
        "\n",
        "        self.add(prod_graph)\n",
        "        self.add(self.fg_label)\n",
        "\n",
        "        # Move convolution axes\n",
        "        conv_axes.match_y(axes1)\n",
        "        self.remove(self.conv_label)\n",
        "        conv_label = self.get_conv_label(2)\n",
        "        self.conv_label = conv_label\n",
        "        self.add(conv_label)\n",
        "\n",
        "        # Show repeated convolutions\n",
        "        for n in range(1, self.n_iterations + 1):\n",
        "            conv_samples, conv_graph = self.create_convolution(\n",
        "                x_samples, f_samples, g_samples, conv_axes,\n",
        "            )\n",
        "            if n == self.when_to_renormalize:\n",
        "                self.add_rescale_arrow()\n",
        "            if n >= self.when_to_renormalize:\n",
        "                self.rescale_conv(conv_axes, conv_graph, n)\n",
        "            self.swap_graphs(f_graph, conv_graph, axes1, conv_axes, n)\n",
        "            self.swap_labels(n, conv_graph)\n",
        "            f_samples[:] = conv_samples\n",
        "\n",
        "    def create_convolution(self, x_samples, f_samples, g_samples, conv_axes):\n",
        "        # Prepare\n",
        "        self.set_s(x_samples[0], animate=False)\n",
        "\n",
        "        conv_samples, conv_graph = self.get_conv(\n",
        "            x_samples, f_samples, g_samples, conv_axes\n",
        "        )\n",
        "        endpoint_dot = GlowDot(color=WHITE)\n",
        "        endpoint_dot.add_updater(lambda m: m.move_to(conv_graph.get_points()[-1]))\n",
        "\n",
        "        # Sweep\n",
        "        self.play(\n",
        "            self.set_s(x_samples[-1]),\n",
        "            ShowCreation(conv_graph),\n",
        "            UpdateFromAlphaFunc(\n",
        "                endpoint_dot, lambda m, a: m.move_to(conv_graph.get_end()).set_opacity(min(6 * a, 1)),\n",
        "            ),\n",
        "            run_time=self.convolution_creation_time,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.play(FadeOut(endpoint_dot, run_time=0.5))\n",
        "\n",
        "        return conv_samples, conv_graph\n",
        "\n",
        "    def swap_graphs(self, f_graph, conv_graph, f_axes, conv_axes, n):\n",
        "        shift_value = f_axes.get_origin() - conv_axes.get_origin()\n",
        "        conv_axes_copy = conv_axes.deepcopy()\n",
        "\n",
        "        f_label = self.f_label\n",
        "        new_f_label = Tex(f\"f_{{{n + 1}}}(x)\", **self.label_config)\n",
        "        new_f_label.replace(self.conv_label[:len(new_f_label)])\n",
        "        new_f_label[-2].set_opacity(0)\n",
        "\n",
        "        f_group = VGroup(f_axes, f_graph, f_label)\n",
        "        new_f_graph = conv_graph.copy()\n",
        "        self.add(conv_axes_copy, new_f_graph)\n",
        "        anims = [\n",
        "            Transform(conv_axes_copy, f_axes, remover=True),\n",
        "            new_f_graph.animate.shift(shift_value).match_style(f_graph),\n",
        "            FadeOut(f_group, shift_value),\n",
        "            new_f_label.animate.replace(f_label, dim_to_match=1).set_opacity(1),\n",
        "        ]\n",
        "        self.play(LaggedStart(*anims))\n",
        "        self.remove(new_f_label, new_f_graph)\n",
        "        f_graph.become(new_f_graph)\n",
        "        f_label.become(new_f_label)\n",
        "        self.add(f_axes, f_graph, f_label)\n",
        "\n",
        "    def swap_labels(self, n, conv_graph):\n",
        "        # Test\n",
        "        new_conv_label = self.get_conv_label(n + 2)\n",
        "        new_conv_label.replace(self.conv_label)\n",
        "        prod_rhs = self.fg_label[6:]\n",
        "        new_prod_rhs = Tex(f\"f_{{{n + 1}}}(s - x)\")\n",
        "        new_prod_rhs.replace(prod_rhs, dim_to_match=1)\n",
        "\n",
        "        to_remove = VGroup(\n",
        "            self.conv_label[f\"f_{{{n + 1}}}\"],\n",
        "            self.conv_label[f\"f_{{{n}}}\"],\n",
        "            prod_rhs,\n",
        "        )\n",
        "        to_add = VGroup(\n",
        "            new_conv_label[f\"f_{{{n + 2}}}\"],\n",
        "            new_conv_label[f\"f_{{{n + 1}}}\"],\n",
        "            new_prod_rhs,\n",
        "        )\n",
        "        anims = [\n",
        "            LaggedStartMap(FadeOut, to_remove, shift=0.5 * UP),\n",
        "            LaggedStartMap(FadeIn, to_add, shift=0.5 * UP),\n",
        "            FadeOut(conv_graph),\n",
        "        ]\n",
        "        if hasattr(self, \"rescaled_graphs\"):\n",
        "            anims.append(self.rescaled_graphs.animate.set_stroke(width=0.5, opacity=0.5))\n",
        "        self.play(*anims, run_time=1)\n",
        "\n",
        "        self.remove(self.conv_label)\n",
        "        self.remove(new_prod_rhs)\n",
        "        self.conv_label = new_conv_label\n",
        "        prod_rhs.become(new_prod_rhs)\n",
        "        self.add(self.conv_label)\n",
        "        self.add(prod_rhs)\n",
        "\n",
        "    def add_rescale_arrow(self):\n",
        "        arrow = Vector(1.5 * DOWN)\n",
        "        label = TexText(R\"Rescale so that\\\\std. dev. = 1\", font_size=30)\n",
        "        label.next_to(arrow)\n",
        "        self.rescale_label = VGroup(label, arrow)\n",
        "        self.rescale_label.next_to(self.conv_label, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(label)\n",
        "        )\n",
        "        self.add(self.rescale_label)\n",
        "\n",
        "    def rescale_conv(self, conv_axes, conv_graph, n):\n",
        "        anims = []\n",
        "        if not hasattr(self, \"rescaled_axes\"):\n",
        "            self.rescaled_axes = conv_axes.copy()\n",
        "            self.rescaled_axes.next_to(self.rescale_label, DOWN)\n",
        "            self.rescaled_graphs = VGroup()\n",
        "            anims.append(TransformFromCopy(conv_axes, self.rescaled_axes))\n",
        "\n",
        "        factor = self.pre_rescale_factor / math.sqrt(n + 1)\n",
        "        stretched_graph = conv_graph.copy()\n",
        "        stretched_graph.stretch(factor, 0)\n",
        "        stretched_graph.stretch(1 / factor, 1, about_edge=DOWN)\n",
        "\n",
        "        new_graph = VMobject()\n",
        "        new_graph.start_new_path(conv_axes.x_axis.get_start())\n",
        "        new_graph.add_line_to(stretched_graph.get_start())\n",
        "        new_graph.append_vectorized_mobject(stretched_graph)\n",
        "        new_graph.add_line_to(conv_axes.x_axis.get_end())\n",
        "        new_graph.match_style(stretched_graph)\n",
        "        new_graph.shift(self.rescaled_axes.x_axis.pfp(0.5) - conv_axes.c2p(0, 0))\n",
        "        area = get_norm(new_graph.get_area_vector())\n",
        "        new_graph.stretch(self.lower_graph_target_area / area, 1, about_edge=DOWN)\n",
        "\n",
        "        anims.append(TransformFromCopy(conv_graph, new_graph))\n",
        "        self.play(*anims)\n",
        "\n",
        "        self.rescaled_graphs.add(new_graph)\n",
        "        self.add(self.rescaled_graphs)\n",
        "\n",
        "    def get_conv(self, x_samples, f_samples, g_samples, axes):\n",
        "        \"\"\"\n",
        "        Returns array of samples and graph\n",
        "        \"\"\"\n",
        "        conv_samples = self.resolution * scipy.signal.fftconvolve(\n",
        "            f_samples, g_samples, mode='same'\n",
        "        )\n",
        "        conv_graph = VMobject()\n",
        "        conv_graph.set_points_as_corners(axes.c2p(x_samples, conv_samples))\n",
        "        conv_graph.set_stroke(TEAL, 3)\n",
        "        return conv_samples, conv_graph\n",
        "\n",
        "    def get_s(self):\n",
        "        return self.all_axes[1].x_axis.p2n(self.s_indicator.get_center())\n",
        "\n",
        "    def set_s(self, s, animate=True):\n",
        "        if animate:\n",
        "            mob = self.s_indicator.animate\n",
        "        else:\n",
        "            mob = self.s_indicator\n",
        "        return mob.set_x(self.all_axes[1].c2p(s)[0])\n",
        "\n",
        "    def get_conv_label(self, n):\n",
        "        lhs = f\"f_{{{n}}}(s)\"\n",
        "        last = f\"f_{{{n - 1}}}\"\n",
        "        result = Tex(lhs, \"=\", R\"\\big[\", last, \"*\", \"f_1\", R\"\\big]\", \"(s)\")\n",
        "        result.set_height(0.5)\n",
        "        result.next_to(self.all_axes[3], DOWN, MED_LARGE_BUFF)\n",
        "        return result\n",
        "\n",
        "    def f(self, x):\n",
        "        return uniform(x)\n",
        "\n",
        "\n",
        "class RepeatedConvolutionDoubleLump(RepeatedConvolution):\n",
        "    n_iterations = 12\n",
        "    when_to_renormalize = 1\n",
        "    g_is_rect = False\n",
        "    axes_config = dict(\n",
        "        x_range=(-5, 5, 1),\n",
        "        y_range=(-1, 1, 1.0),\n",
        "        width=6,\n",
        "        height=2,\n",
        "    )\n",
        "    pre_rescale_factor = 0.75\n",
        "    lower_graph_target_area = 0.5\n",
        "\n",
        "    def f(self, x):\n",
        "        x *= 1.5\n",
        "        return 1.5 * 0.69 * (np.exp(-6 * (x - 0.8)**2) + np.exp(-6 * (x + 0.8)**2))\n",
        "\n",
        "    def g(self, x):\n",
        "        return self.f(x)\n",
        "\n",
        "\n",
        "class RepeatedConvolutionExp(RepeatedConvolutionDoubleLump):\n",
        "    pre_rescale_factor = 1.0\n",
        "    axes_config = dict(\n",
        "        x_range=(-10, 10, 1),\n",
        "        y_range=(-1, 1, 1.0),\n",
        "        width=6,\n",
        "        height=2,\n",
        "    )\n",
        "\n",
        "    def f(self, x):\n",
        "        return np.exp(-(x + 1)) * (x > -1)\n",
        "\n",
        "\n",
        "class RepeatedConvolutionGaussian(RepeatedConvolution):\n",
        "    g_is_rect = False\n",
        "    when_to_renormalize = 1\n",
        "    axes_config = dict(\n",
        "        x_range=(-7, 7, 1),\n",
        "        y_range=(-0.5, 0.5, 0.5),\n",
        "        width=6,\n",
        "        height=2,\n",
        "    )\n",
        "    convolution_creation_time = 2\n",
        "    pre_rescale_factor = 0.95\n",
        "\n",
        "    def f(self, x):\n",
        "        return gauss_func(x, 0,1)\n",
        "\n",
        "    def g(self, x):\n",
        "        return gauss_func(x, 0, 1)\n",
        "\n",
        "\n",
        "# Old rect material\n",
        "\n",
        "class MovingAverageOfRectFuncs(Convolutions):\n",
        "    f_graph_x_step = 0.01\n",
        "    g_graph_x_step = 0.01\n",
        "    jagged_product = True\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        s_indicator = self.s_indicator\n",
        "        g_axes = self.all_axes[1]\n",
        "        self.all_axes[3].y_axis.match_height(g_axes.y_axis)\n",
        "        self.conv_graph.set_height(0.5 * g_axes.y_axis.get_height(), about_edge=DOWN, stretch=True)\n",
        "\n",
        "        for t in [3, -3, 0]:\n",
        "            self.play(s_indicator.animate.set_x(g_axes.c2p(t, 0)[0]), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "    def f(self, x):\n",
        "        return rect_func(x / 2)\n",
        "\n",
        "    def g(self, x):\n",
        "        return 1.5 * rect_func(1.5 * x)\n",
        "\n",
        "\n",
        "class RectConvolutionsNewNotation(MovingAverageOfRectFuncs):\n",
        "    def construct(self):\n",
        "        # Setup axes\n",
        "        x_min, x_max = -1.0, 1.0\n",
        "        all_axes = axes1, axes2, axes3 = VGroup(*(\n",
        "            Axes(\n",
        "                (x_min, x_max, 0.5), (0, 5),\n",
        "                width=3.75, height=4\n",
        "            )\n",
        "            for x in range(3)\n",
        "        ))\n",
        "        all_axes.arrange(RIGHT, buff=LARGE_BUFF, aligned_edge=DOWN)\n",
        "        for axes in all_axes:\n",
        "            axes.x_axis.add_numbers(font_size=12, num_decimal_places=1)\n",
        "        axes2.y_axis.add_numbers(font_size=12, num_decimal_places=0, direction=DL, buff=0.05)\n",
        "        all_axes.move_to(DOWN)\n",
        "\n",
        "        self.add(all_axes)\n",
        "\n",
        "        # Prepare convolution graphs\n",
        "        dx = 0.01\n",
        "        xs = np.arange(x_min, x_max + dx, dx)\n",
        "        k_range = list(range(3, 9, 2))\n",
        "        conv_graphs = self.get_all_convolution_graphs(xs, rect_func(xs), axes3, k_range)\n",
        "        VGroup(*conv_graphs).set_stroke(TEAL, 3)\n",
        "\n",
        "        rect_defs = VGroup(\n",
        "            self.get_rect_func_def(),\n",
        "            *(self.get_rect_k_def(k) for k in k_range)\n",
        "        )\n",
        "        rect_defs.scale(0.75)\n",
        "        rect_defs.next_to(axes2, UP)\n",
        "        rect_defs[0][9:].scale(0.7, about_edge=LEFT)\n",
        "        rect_defs[0].next_to(axes1, UP).shift_onto_screen()\n",
        "\n",
        "        conv_labels = VGroup(\n",
        "            Tex(R\"\\big[\\text{rect} * \\text{rect}_3\\big](x)\"),\n",
        "            Tex(R\"\\big[\\text{rect} * \\text{rect}_3 * \\text{rect}_5\\big](x)\"),\n",
        "            Tex(R\"\\big[\\text{rect} * \\text{rect}_3 * \\text{rect}_5 * \\text{rect}_7 \\big](x)\"),\n",
        "        )\n",
        "        conv_labels.scale(0.75)\n",
        "        conv_labels.match_x(axes3).match_y(rect_defs)\n",
        "\n",
        "        # Show rect_1 * rect_3\n",
        "        rect_graphs = VGroup(*(\n",
        "            self.get_rect_k_graph(axes2, k)\n",
        "            for k in [1, *k_range]\n",
        "        ))\n",
        "        rect_graphs[0].set_color(BLUE)\n",
        "        rect_graphs[0].match_x(axes1)\n",
        "\n",
        "        rect = Rectangle(axes2.x_axis.unit_size / 3, axes2.y_axis.unit_size * 3)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(YELLOW, 0.5)\n",
        "        rect.move_to(axes2.get_origin(), DOWN)\n",
        "\n",
        "        self.add(*rect_graphs[:2])\n",
        "        self.add(*rect_defs[:2])\n",
        "        self.add(conv_graphs[0])\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Transform(rect_defs[0][:4].copy(), conv_labels[0][0][1:5], remover=True, path_arc=-PI / 3),\n",
        "            Transform(rect_defs[1][:5].copy(), conv_labels[0][0][6:11], remover=True, path_arc=-PI / 3),\n",
        "            FadeIn(conv_labels[0][0], lag_ratio=0.1, time_span=(1.5, 2.5)),\n",
        "            FadeOut(rect),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the rest\n",
        "        for n in range(2):\n",
        "            left_graph = rect_graphs[n] if n == 0 else conv_graphs[n - 1]\n",
        "            lefs_label = rect_defs[n] if n == 0 else conv_labels[n - 1]\n",
        "            k = 2 * n + 5\n",
        "            new_rect = Rectangle(axes2.x_axis.unit_size / k, axes2.y_axis.unit_size * k)\n",
        "            new_rect.set_stroke(width=0)\n",
        "            new_rect.set_fill(YELLOW, 0.5)\n",
        "            new_rect.move_to(axes2.get_origin(), DOWN)\n",
        "            self.play(\n",
        "                FadeOut(left_graph, 1.5 * LEFT),\n",
        "                FadeOut(lefs_label, 1.5 * LEFT),\n",
        "                FadeOut(rect_defs[n + 1]),\n",
        "                FadeOut(rect_graphs[n + 1]),\n",
        "                conv_labels[n].animate.match_x(axes1),\n",
        "                conv_graphs[n].animate.match_x(axes1),\n",
        "            )\n",
        "            self.play(\n",
        "                Write(rect_defs[n + 2], stroke_color=WHITE),\n",
        "                ShowCreation(rect_graphs[n + 2]),\n",
        "                FadeIn(new_rect),\n",
        "                run_time=1,\n",
        "            )\n",
        "            self.wait()\n",
        "            left_conv = conv_labels[n][0][1:-4]\n",
        "            r = len(left_conv) + 1\n",
        "            self.play(\n",
        "                Transform(left_conv.copy(), conv_labels[n + 1][0][1:r], remover=True, path_arc=-PI / 3),\n",
        "                Transform(rect_defs[2][:5].copy(), conv_labels[n + 1][0][r + 1:r + 6], remover=True, path_arc=-PI / 3),\n",
        "                FadeIn(conv_labels[n + 1][0], lag_ratio=0.1, time_span=(0.5, 1.5)),\n",
        "                ShowCreation(conv_graphs[n + 1]),\n",
        "            )\n",
        "            self.play(FadeOut(new_rect))\n",
        "            self.wait()\n",
        "\n",
        "    def get_rect_k_graph(self, axes, k):\n",
        "        x_range = axes.x_axis.x_range\n",
        "        x_range[2] = 1 / k\n",
        "        return axes.get_graph(\n",
        "            lambda x: k * rect_func(k * x),\n",
        "            discontinuities=(-1 / (2 * k), 1 / (2 * k)),\n",
        "            stroke_color=YELLOW,\n",
        "            stroke_width=3,\n",
        "        )\n",
        "\n",
        "    def get_rect_k_def(self, k):\n",
        "        return Tex(Rf\"\\text{{rect}}_{{{k}}}(x) := {k} \\cdot \\text{{rect}}({k}x)\")[0]\n",
        "\n",
        "\n",
        "class RectConvolutionFacts(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Equations\n",
        "        equations = VGroup(\n",
        "            Tex(R\"\\text{rect}\", \"(0)\", \"=\", \"1.0\"),\n",
        "            Tex(\n",
        "                R\"\\big[\",\n",
        "                R\"\\text{rect}\", \"*\",\n",
        "                R\"\\text{rect}_3\",\n",
        "                R\"\\big]\", \"(0)\", \"=\", \"1.0\"\n",
        "            ),\n",
        "            Tex(\n",
        "                R\"\\big[\",\n",
        "                R\"\\text{rect}\", \"*\",\n",
        "                R\"\\text{rect}_3\", \"*\",\n",
        "                R\"\\text{rect}_5\",\n",
        "                R\"\\big]\", \"(0)\", \"=\", \"1.0\"\n",
        "            ),\n",
        "            Tex(R\"\\vdots\"),\n",
        "            Tex(\n",
        "                R\"\\big[\",\n",
        "                R\"\\text{rect}\", \"*\",\n",
        "                R\"\\text{rect}_3\", \"*\", R\"\\cdots\", \"*\",\n",
        "                R\"\\text{rect}_{13}\",\n",
        "                R\"\\big]\", \"(0)\", \"=\", \"1.0\"\n",
        "            ),\n",
        "            Tex(\n",
        "                R\"\\big[\",\n",
        "                R\"\\text{rect}\", \"*\",\n",
        "                R\"\\text{rect}_3\", \"*\", R\"\\cdots\", \"*\",\n",
        "                R\"\\text{rect}_{13}\", \"*\",\n",
        "                R\"\\text{rect}_{15}\",\n",
        "                R\"\\big]\", \"(0)\", \"=\", SUB_ONE_FACTOR + R\"\\dots\"\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        for eq in equations:\n",
        "            eq.set_color_by_tex(R\"\\text{rect}\", BLUE)\n",
        "            eq.set_color_by_tex(\"_3\", TEAL)\n",
        "            eq.set_color_by_tex(\"_5\", GREEN)\n",
        "            eq.set_color_by_tex(\"_{13}\", YELLOW)\n",
        "            eq.set_color_by_tex(\"_{15}\", RED_B)\n",
        "\n",
        "        equations.arrange(DOWN, buff=0.75, aligned_edge=RIGHT)\n",
        "        equations[3].match_x(equations[2][-1])\n",
        "        equations[-1][:-1].align_to(equations[-2][-2], RIGHT)\n",
        "        equations[-1][-1].next_to(equations[-1][:-1], RIGHT)\n",
        "        equations.set_width(FRAME_WIDTH - 4)\n",
        "        equations.center()\n",
        "\n",
        "        # Show all (largely copy pasted...)\n",
        "        self.add(equations[0])\n",
        "        for i in range(4):\n",
        "            if i < 3:\n",
        "                src = equations[i].copy()\n",
        "            else:\n",
        "                src = equations[i + 1].copy()\n",
        "\n",
        "            if i < 2:\n",
        "                target = equations[i + 1]\n",
        "            elif i == 2:\n",
        "                target = VGroup(*equations[i + 1], *equations[i + 2])\n",
        "            else:\n",
        "                target = equations[i + 2]\n",
        "            self.play(TransformMatchingTex(src, target))\n",
        "            self.wait(0.5)\n",
        "\n",
        "        self.wait()\n"
    ]
}