{
    "topic": "demonstrates the concept of a \"Main Topic\" and a \"Meta Topic",
    "code": [
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from _2018.uncertainty import Flash\n",
        "from _2018.WindingNumber import *\n",
        "\n",
        "\n",
        "# Warning, this file uses ContinualChangingDecimal,\n",
        "# which has since been been deprecated.  Use a mobject\n",
        "# updater instead\n",
        "\n",
        "\n",
        "class AltTeacherStudentsScene(TeacherStudentsScene):\n",
        "    def setup(self):\n",
        "        TeacherStudentsScene.setup(self)\n",
        "        self.teacher.set_color(YELLOW_E)\n",
        "\n",
        "###############\n",
        "\n",
        "\n",
        "class IntroSceneWrapper(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\" : {\n",
        "            \"color\" : YELLOW_E,\n",
        "            \"flip_at_start\" : False,\n",
        "            \"height\" : 2,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\" : DOWN+LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_two_words()\n",
        "        self.describe_main_topic()\n",
        "        self.describe_meta_topic()\n",
        "\n",
        "    def introduce_two_words(self):\n",
        "        morty = self.pi_creature\n",
        "        rect = ScreenRectangle(height = 5)\n",
        "        rect.to_corner(UP+RIGHT)\n",
        "        self.add(rect)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT).scale(2)\n",
        "        h_line.to_corner(UP+LEFT)\n",
        "        h_line.shift(0.5*DOWN)\n",
        "\n",
        "        main_topic, meta_topic = topics = VGroup(\n",
        "            OldTexText(\"Main topic\"),\n",
        "            OldTexText(\"Meta topic\"),\n",
        "        )\n",
        "        topics.next_to(morty, UP)\n",
        "        topics.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            morty.change, \"raise_left_hand\",\n",
        "            FadeInFromDown(main_topic)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            main_topic.next_to, meta_topic.get_top(), UP, MED_SMALL_BUFF,\n",
        "            FadeInFromDown(meta_topic)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change, \"happy\",\n",
        "            main_topic.next_to, h_line, UP,\n",
        "            meta_topic.set_fill, {\"opacity\" : 0.2},\n",
        "        )\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(h_line, main_topic, meta_topic)\n",
        "\n",
        "    def describe_main_topic(self):\n",
        "        h_line = self.h_line\n",
        "        morty = self.pi_creature\n",
        "        main_topic = self.main_topic\n",
        "        meta_topic = self.meta_topic\n",
        "\n",
        "        solver = OldTexText(\"2d equation solver\")\n",
        "        solver.match_width(h_line)\n",
        "        solver.next_to(h_line, DOWN)\n",
        "        rainbow_solver1 = solver.copy()\n",
        "        rainbow_solver2 = solver.copy()\n",
        "        colors = [\"RED\", \"ORANGE\", \"YELLOW\", \"GREEN\", BLUE, \"PURPLE\", PINK]\n",
        "        rainbow_solver1.set_color_by_gradient(*colors)\n",
        "        rainbow_solver2.set_color_by_gradient(*reversed(colors))\n",
        "\n",
        "\n",
        "        xy_equation = OldTex(\"\"\"\n",
        "            \\\\left[\\\\begin{array}{c}\n",
        "                ye^x \\\\\\\\\n",
        "                \\\\sin(|xy|)\n",
        "            \\\\end{array}\\\\right] = \n",
        "            \\\\left[\\\\begin{array}{c}\n",
        "                y^2 \\\\\\\\\n",
        "                3y\n",
        "            \\\\end{array}\\\\right]\n",
        "        \"\"\")\n",
        "        # xy_equation.set_color_by_tex_to_color_map({\n",
        "        #     \"x\" : BLUE,\n",
        "        #     \"y\" : YELLOW\n",
        "        # })\n",
        "        xy_equation.scale(0.8)\n",
        "        xy_equation.next_to(solver, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        z_equation = OldTex(\"z\", \"^5\", \"+\", \"z\", \"+\", \"1\", \"=\", \"0\")\n",
        "        z_equation.set_color_by_tex(\"z\", GREEN)\n",
        "        z_equation.move_to(xy_equation, UP)\n",
        "\n",
        "        zeta = OldTex(\"\\\\zeta(s) = 0\")\n",
        "        zeta[2].set_color(GREEN)\n",
        "        zeta.next_to(z_equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(solver))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, xy_equation, run_time = 1),\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(xy_equation),\n",
        "            FadeIn(z_equation)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(zeta))\n",
        "        self.wait()\n",
        "        solver.save_state()\n",
        "        for rainbow_solver in rainbow_solver1, rainbow_solver2:\n",
        "            self.play(Transform(\n",
        "                solver, rainbow_solver,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.play(solver.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, VGroup(solver, z_equation, zeta)\n",
        "        ))\n",
        "        self.play(\n",
        "            main_topic.move_to, meta_topic,\n",
        "            main_topic.set_fill, {\"opacity\" : 0.2},\n",
        "            meta_topic.move_to, main_topic,\n",
        "            meta_topic.set_fill, {\"opacity\" : 1},\n",
        "            morty.change, \"hesitant\",\n",
        "            path_arc = TAU/8,\n",
        "        )\n",
        "\n",
        "    def describe_meta_topic(self):\n",
        "        h_line = self.h_line\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        words = OldTexText(\"Seek constructs which \\\\\\\\ compose nicely\")\n",
        "        words.scale(0.7)\n",
        "        words.next_to(h_line, DOWN)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.play(morty.change, \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "class Introduce1DFunctionCase(Scene):\n",
        "    CONFIG = {\n",
        "        \"search_range_rect_height\" : 0.15,\n",
        "        \"arrow_opacity\" : 1,\n",
        "        \"show_dotted_line_to_f\" : True,\n",
        "        \"arrow_config\": {\n",
        "            \"max_tip_length_to_length_ratio\" : 0.5,\n",
        "        },\n",
        "        \"show_midpoint_value\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_axes_one_at_a_time()\n",
        "        self.show_two_graphs()\n",
        "        self.transition_to_sqrt_2_case()\n",
        "        self.show_example_binary_search()\n",
        "\n",
        "    def show_axes_one_at_a_time(self):\n",
        "        axes = Axes(\n",
        "            x_min = -1, x_max = 3.2,\n",
        "            x_axis_config = {\n",
        "                \"unit_size\" : 3,\n",
        "                \"tick_frequency\" : 0.25,\n",
        "                \"big_tick_numbers\" : list(range(-1, 4))\n",
        "            },\n",
        "            y_min = -2, y_max = 4.5,\n",
        "        )\n",
        "        axes.to_corner(DOWN+LEFT)\n",
        "        axes.x_axis.add_numbers(*list(range(-1, 4)))\n",
        "        axes.y_axis.label_direction = LEFT\n",
        "        axes.y_axis.add_numbers(-1, *list(range(1, 5)))\n",
        "\n",
        "        inputs = OldTexText(\"Inputs\")\n",
        "        inputs.next_to(axes.x_axis, UP, aligned_edge = RIGHT)\n",
        "\n",
        "        outputs = OldTexText(\"Outputs\")\n",
        "        outputs.next_to(axes.y_axis, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(axes.x_axis),\n",
        "            Write(inputs)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(axes.y_axis),\n",
        "            FadeOut(axes.x_axis.numbers[1], rate_func = squish_rate_func(smooth, 0, 0.2)),\n",
        "            Write(outputs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.axes = axes\n",
        "        self.inputs_label = inputs\n",
        "        self.outputs_label = outputs\n",
        "\n",
        "    def show_two_graphs(self):\n",
        "        axes = self.axes\n",
        "        f_graph = axes.get_graph(\n",
        "            lambda x : 2*x*(x - 0.75)*(x - 1.5) + 1,\n",
        "            color = BLUE\n",
        "        )\n",
        "        g_graph = axes.get_graph(\n",
        "            lambda x : 1.8*np.cos(TAU*x/2),\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        label_x_corod = 2\n",
        "        f_label = OldTex(\"f(x)\")\n",
        "        f_label.match_color(f_graph)\n",
        "        f_label.next_to(axes.input_to_graph_point(label_x_corod, f_graph), LEFT)\n",
        "\n",
        "        g_label = OldTex(\"g(x)\")\n",
        "        g_label.match_color(g_graph)\n",
        "        g_label.next_to(\n",
        "            axes.input_to_graph_point(label_x_corod, g_graph), UP, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        solution = 0.24\n",
        "        cross_point = axes.input_to_graph_point(solution, f_graph)\n",
        "        l_v_line, r_v_line, v_line = [\n",
        "            DashedLine(\n",
        "                axes.coords_to_point(x, 0),\n",
        "                axes.coords_to_point(x, f_graph.underlying_function(solution)),\n",
        "            )\n",
        "            for x in (axes.x_min, axes.x_max, solution)\n",
        "        ]\n",
        "\n",
        "        equation = OldTex(\"f(x)\", \"=\", \"g(x)\")\n",
        "        equation[0].match_color(f_label)\n",
        "        equation[2].match_color(g_label)\n",
        "        equation.next_to(cross_point, UP, buff = 1.5, aligned_edge = LEFT)\n",
        "        equation_arrow = Arrow(\n",
        "            equation.get_bottom(), cross_point,\n",
        "            buff = SMALL_BUFF,\n",
        "            color = WHITE\n",
        "        )\n",
        "        equation.target = OldTex(\"x^2\", \"=\", \"2\")\n",
        "        equation.target.match_style(equation)\n",
        "        equation.target.to_edge(UP)\n",
        "\n",
        "        for graph, label in (f_graph, f_label), (g_graph, g_label):\n",
        "            self.play(\n",
        "                ShowCreation(graph),\n",
        "                Write(label, rate_func = squish_rate_func(smooth, 0.5, 1)),\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(r_v_line.copy().fade(1), v_line),\n",
        "            ReplacementTransform(l_v_line.copy().fade(1), v_line),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(f_label.copy(), equation[0]),\n",
        "            ReplacementTransform(g_label.copy(), equation[2]),\n",
        "            Write(equation[1]),\n",
        "            GrowArrow(equation_arrow),\n",
        "        )\n",
        "        for x in range(4):\n",
        "            self.play(\n",
        "                FadeOut(v_line.copy()),\n",
        "                ShowCreation(v_line, rate_func = squish_rate_func(smooth, 0.5, 1)),\n",
        "                run_time = 1.5\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(equation, replace_mobject_with_target_in_scene = True),\n",
        "            *list(map(FadeOut, [equation_arrow, v_line]))\n",
        "        )\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            f_graph, f_label, g_graph, g_label,\n",
        "            equation = equation.target\n",
        "        )\n",
        "\n",
        "    def transition_to_sqrt_2_case(self):\n",
        "        f_graph = self.f_graph\n",
        "        f_label = VGroup(self.f_label)\n",
        "        g_graph = self.g_graph\n",
        "        g_label = VGroup(self.g_label)\n",
        "        axes = self.axes\n",
        "        for label in f_label, g_label:\n",
        "            for x in range(2):\n",
        "                label.add(VectorizedPoint(label.get_center()))\n",
        "        for number in axes.y_axis.numbers:\n",
        "            number.add_background_rectangle()\n",
        "\n",
        "        squared_graph = axes.get_graph(lambda x : x**2)\n",
        "        squared_graph.match_style(f_graph)\n",
        "        two_graph = axes.get_graph(lambda x : 2)\n",
        "        two_graph.match_style(g_graph)\n",
        "\n",
        "        squared_label = OldTex(\"f(x)\", \"=\", \"x^2\")\n",
        "        squared_label.next_to(\n",
        "            axes.input_to_graph_point(2, squared_graph), RIGHT\n",
        "        )\n",
        "        squared_label.match_color(squared_graph)\n",
        "        two_label = OldTex(\"g(x)\", \"=\", \"2\")\n",
        "        two_label.next_to(\n",
        "            axes.input_to_graph_point(3, two_graph), UP,\n",
        "        )\n",
        "        two_label.match_color(two_graph)\n",
        "\n",
        "        find_sqrt_2 = self.find_sqrt_2 = OldTexText(\"(Find $\\\\sqrt{2}$)\")\n",
        "        find_sqrt_2.next_to(self.equation, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(f_graph, squared_graph),\n",
        "            ReplacementTransform(f_label, squared_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(g_graph, two_graph),\n",
        "            ReplacementTransform(g_label, two_label),\n",
        "            Animation(axes.y_axis.numbers)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(find_sqrt_2))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            squared_graph, two_graph,\n",
        "            squared_label, two_label,\n",
        "        )\n",
        "\n",
        "    def show_example_binary_search(self):\n",
        "        self.binary_search(\n",
        "            self.squared_graph, self.two_graph,\n",
        "            x0 = 1, x1 = 2,\n",
        "            n_iterations = 8\n",
        "        )\n",
        "\n",
        "    ##\n",
        "\n",
        "    def binary_search(\n",
        "        self, \n",
        "        f_graph, g_graph, \n",
        "        x0, x1, \n",
        "        n_iterations,\n",
        "        n_iterations_with_sign_mention = 0,\n",
        "        zoom = False,\n",
        "        ):\n",
        "\n",
        "        axes = self.axes\n",
        "        rect = self.rect = Rectangle()\n",
        "        rect.set_stroke(width = 0)\n",
        "        rect.set_fill(YELLOW, 0.5)\n",
        "        rect.replace(Line(\n",
        "            axes.coords_to_point(x0, 0),\n",
        "            axes.coords_to_point(x1, 0),\n",
        "        ), dim_to_match = 0)\n",
        "        rect.stretch_to_fit_height(self.search_range_rect_height)\n",
        "\n",
        "        #Show first left and right\n",
        "        mention_signs = n_iterations_with_sign_mention > 0\n",
        "        kwargs = {\"mention_signs\" : mention_signs}\n",
        "        leftovers0 = self.compare_graphs_at_x(f_graph, g_graph, x0, **kwargs)\n",
        "        self.wait()\n",
        "        leftovers1 = self.compare_graphs_at_x(f_graph, g_graph, x1, **kwargs)\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(rect))\n",
        "        self.wait()\n",
        "\n",
        "        all_leftovers = VGroup(leftovers0, leftovers1)\n",
        "        end_points = [x0, x1]\n",
        "        if mention_signs:\n",
        "            sign_word0 = leftovers0.sign_word\n",
        "            sign_word1 = leftovers1.sign_word\n",
        "\n",
        "        midpoint_line = Line(MED_SMALL_BUFF*UP, ORIGIN, color = YELLOW)\n",
        "        midpoint_line_update = UpdateFromFunc(\n",
        "            midpoint_line, lambda l : l.move_to(rect)\n",
        "        )\n",
        "        decimal = DecimalNumber(\n",
        "            0,\n",
        "            num_decimal_places = 3,\n",
        "            show_ellipsis = True,\n",
        "        )\n",
        "        decimal.scale(0.7)\n",
        "        decimal_update = ChangingDecimal(\n",
        "            decimal, lambda a : axes.x_axis.point_to_number(rect.get_center()),\n",
        "            position_update_func = lambda m : m.next_to(\n",
        "                midpoint_line, DOWN, SMALL_BUFF,\n",
        "                submobject_to_align = decimal[:-1],\n",
        "            ),\n",
        "        )\n",
        "        if not self.show_midpoint_value:\n",
        "            decimal.set_fill(opacity = 0)\n",
        "            midpoint_line.set_stroke(width = 0)\n",
        "\n",
        "        #Restrict to by a half each time\n",
        "        kwargs = {\n",
        "            \"mention_signs\" : False,\n",
        "            \"show_decimal\" : zoom,\n",
        "        } \n",
        "        for x in range(n_iterations - 1):\n",
        "            x_mid = np.mean(end_points)\n",
        "            leftovers_mid = self.compare_graphs_at_x(f_graph, g_graph, x_mid, **kwargs)\n",
        "            if leftovers_mid.too_high == all_leftovers[0].too_high:\n",
        "                index_to_fade = 0\n",
        "            else:\n",
        "                index_to_fade = 1\n",
        "            edge = [RIGHT, LEFT][index_to_fade]\n",
        "            to_fade = all_leftovers[index_to_fade]\n",
        "            all_leftovers.submobjects[index_to_fade] = leftovers_mid\n",
        "            end_points[index_to_fade] = x_mid\n",
        "\n",
        "            added_anims = []\n",
        "            if mention_signs:\n",
        "                word = [leftovers0, leftovers1][index_to_fade].sign_word\n",
        "                if x < n_iterations_with_sign_mention:\n",
        "                    added_anims = [word.next_to, leftovers_mid[0].get_end(), -edge]\n",
        "                elif word in self.camera.extract_mobject_family_members(self.mobjects):\n",
        "                    added_anims = [FadeOut(word)]\n",
        "\n",
        "            rect.generate_target()\n",
        "            rect.target.stretch(0.5, 0, about_edge = edge)\n",
        "            rect.target.stretch_to_fit_height(self.search_range_rect_height)\n",
        "            self.play(\n",
        "                MoveToTarget(rect),\n",
        "                midpoint_line_update,\n",
        "                decimal_update,\n",
        "                Animation(all_leftovers),\n",
        "                FadeOut(to_fade),\n",
        "                *added_anims\n",
        "            )\n",
        "            if zoom:\n",
        "                factor = 2.0/rect.get_width()\n",
        "                everything = VGroup(*self.mobjects)\n",
        "                decimal_index = everything.submobjects.index(decimal)\n",
        "                midpoint_line_index = everything.submobjects.index(midpoint_line)\n",
        "                everything.generate_target()\n",
        "                everything.target.scale(factor, about_point = rect.get_center())\n",
        "                everything.target[decimal_index].scale(1./factor, about_edge = UP)\n",
        "                everything.target[midpoint_line_index].scale(1./factor)\n",
        "                if factor > 1:\n",
        "                    self.play(\n",
        "                        everything.scale, factor, \n",
        "                        {\"about_point\" : rect.get_center()}\n",
        "                    )\n",
        "            else:\n",
        "                self.wait()\n",
        "\n",
        "    def compare_graphs_at_x(\n",
        "        self, f_graph, g_graph, x, \n",
        "        mention_signs = False,\n",
        "        show_decimal = False,\n",
        "        ):\n",
        "        axes = self.axes\n",
        "        f_point = axes.input_to_graph_point(x, f_graph)\n",
        "        g_point = axes.input_to_graph_point(x, g_graph)\n",
        "        arrow = Arrow(\n",
        "            g_point, f_point, buff = 0,\n",
        "            **self.arrow_config\n",
        "        )\n",
        "        too_high = f_point[1] > g_point[1]\n",
        "        if too_high:\n",
        "            arrow.set_fill(GREEN, opacity = self.arrow_opacity)\n",
        "        else:\n",
        "            arrow.set_fill(RED, opacity = self.arrow_opacity)\n",
        "\n",
        "        leftovers = VGroup(arrow)\n",
        "        leftovers.too_high = too_high\n",
        "\n",
        "        if self.show_dotted_line_to_f:\n",
        "            v_line = DashedLine(axes.coords_to_point(x, 0), f_point)\n",
        "            self.play(ShowCreation(v_line))\n",
        "            leftovers.add(v_line)\n",
        "\n",
        "        added_anims = []\n",
        "        if show_decimal:\n",
        "            decimal = DecimalNumber(\n",
        "                axes.x_axis.point_to_number(arrow.get_start()),\n",
        "                num_decimal_places = 3,\n",
        "                # show_ellipsis = True,\n",
        "            )\n",
        "            height = self.rect.get_height()\n",
        "            decimal.set_height(height)\n",
        "            next_to_kwargs = {\n",
        "                \"buff\" : height,\n",
        "            }\n",
        "            if too_high:\n",
        "                decimal.next_to(arrow, DOWN, **next_to_kwargs)\n",
        "                if hasattr(self, \"last_up_arrow_decimal\"):\n",
        "                    added_anims += [FadeOut(self.last_up_arrow_decimal)]\n",
        "                self.last_up_arrow_decimal = decimal\n",
        "            else:\n",
        "                decimal.next_to(arrow, UP, **next_to_kwargs)\n",
        "                if hasattr(self, \"last_down_arrow_decimal\"):\n",
        "                    added_anims += [FadeOut(self.last_down_arrow_decimal)]\n",
        "                self.last_down_arrow_decimal = decimal\n",
        "            line = Line(decimal, arrow, buff = 0)\n",
        "            # line.match_color(arrow)\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            decimal.add(line)\n",
        "            added_anims += [FadeIn(decimal)]\n",
        "\n",
        "        if mention_signs:\n",
        "            if too_high:\n",
        "                sign_word = OldTexText(\"Positive\")\n",
        "                sign_word.set_color(GREEN)\n",
        "                sign_word.scale(0.7)\n",
        "                sign_word.next_to(arrow.get_end(), RIGHT)\n",
        "            else:\n",
        "                sign_word = OldTexText(\"Negative\")\n",
        "                sign_word.set_color(RED)\n",
        "                sign_word.scale(0.7)\n",
        "                sign_word.next_to(arrow.get_end(), LEFT)\n",
        "            sign_word.add_background_rectangle()\n",
        "            added_anims += [FadeIn(sign_word)]\n",
        "            leftovers.sign_word = sign_word\n",
        "\n",
        "        self.play(GrowArrow(arrow), *added_anims)\n",
        "\n",
        "        return leftovers\n",
        "\n",
        "class PiCreaturesAreIntrigued(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"You can extend \\\\\\\\ this to 2d\",\n",
        "            bubble_config = {\"width\" : 4, \"height\" : 3}\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "class TransitionFromEquationSolverToZeroFinder(Introduce1DFunctionCase):\n",
        "    CONFIG = {\n",
        "        \"show_dotted_line_to_f\" : False,\n",
        "        \"arrow_config\" : {},\n",
        "        \"show_midpoint_value\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        #Just run through these without animating.\n",
        "        self.force_skipping()\n",
        "        self.show_axes_one_at_a_time()\n",
        "        self.show_two_graphs()\n",
        "        self.transition_to_sqrt_2_case()\n",
        "        self.revert_to_original_skipping_status()\n",
        "        ##\n",
        "\n",
        "        self.transition_to_difference_graph()\n",
        "        self.show_binary_search_with_signs()\n",
        "\n",
        "    def transition_to_difference_graph(self):\n",
        "        axes = self.axes\n",
        "        equation = x_squared, equals, two = self.equation\n",
        "        for s in \"-\", \"0\":\n",
        "            tex_mob = OldTex(s)\n",
        "            tex_mob.scale(0.01)\n",
        "            tex_mob.fade(1)\n",
        "            tex_mob.move_to(equation.get_right())\n",
        "            equation.add(tex_mob)\n",
        "        find_sqrt_2 = self.find_sqrt_2\n",
        "        rect = SurroundingRectangle(VGroup(equation, find_sqrt_2))\n",
        "        rect.set_color(WHITE)\n",
        "\n",
        "        f_graph = self.squared_graph\n",
        "        g_graph = self.two_graph\n",
        "        new_graph = axes.get_graph(\n",
        "            lambda x : f_graph.underlying_function(x) - g_graph.underlying_function(x),\n",
        "            color = GREEN\n",
        "        )\n",
        "        zero_graph = axes.get_graph(lambda x : 0)\n",
        "        zero_graph.set_stroke(BLACK, 0)\n",
        "\n",
        "        f_label = self.squared_label\n",
        "        g_label = self.two_label\n",
        "        new_label = OldTex(\"f(x)\", \"-\", \"g(x)\")\n",
        "        new_label[0].match_color(f_label)\n",
        "        new_label[2].match_color(g_label)\n",
        "        new_label.next_to(\n",
        "            axes.input_to_graph_point(2, new_graph),\n",
        "            LEFT\n",
        "        )\n",
        "\n",
        "        fg_labels = VGroup(f_label, g_label)\n",
        "        fg_labels.generate_target()\n",
        "        fg_labels.target.arrange(DOWN, aligned_edge = LEFT)\n",
        "        fg_labels.target.to_corner(UP+RIGHT)\n",
        "\n",
        "        new_equation = OldTex(\"x^2\", \"-\", \"2\", \"=\", \"0\")\n",
        "        new_equation[0].match_style(equation[0])\n",
        "        new_equation[2].match_style(equation[2])\n",
        "        new_equation.move_to(equation, RIGHT)\n",
        "        for tex in equation, new_equation:\n",
        "            tex.sort_alphabetically()\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(\n",
        "            ReplacementTransform(equation, new_equation, path_arc = TAU/4),\n",
        "            find_sqrt_2.next_to, new_equation, DOWN,\n",
        "        )\n",
        "        self.play(MoveToTarget(fg_labels))\n",
        "        self.play(\n",
        "            ReplacementTransform(f_graph, new_graph),\n",
        "            ReplacementTransform(g_graph, zero_graph),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(f_label[0].copy(), new_label[0]),\n",
        "            ReplacementTransform(g_label[0].copy(), new_label[2]),\n",
        "            Write(new_label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(new_graph, zero_graph)\n",
        "\n",
        "    def show_binary_search_with_signs(self):\n",
        "        self.play(FadeOut(self.axes.x_axis.numbers[2]))\n",
        "        self.binary_search(\n",
        "            self.new_graph, self.zero_graph,\n",
        "            1, 2,\n",
        "            n_iterations = 9,\n",
        "            n_iterations_with_sign_mention = 2,\n",
        "            zoom = True,\n",
        "        )\n",
        "\n",
        "class RewriteEquationWithTeacher(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        root_two_equations = VGroup(\n",
        "            OldTex(\"x^2\", \"\", \"=\", \"2\", \"\"),\n",
        "            OldTex(\"x^2\", \"-\", \"2\", \"=\", \"0\"),\n",
        "        )\n",
        "        for equation in root_two_equations:\n",
        "            equation.sort_alphabetically()\n",
        "            for part in equation.get_parts_by_tex(\"text\"):\n",
        "                part[2:-1].set_color(YELLOW)\n",
        "                part[2:-1].scale(0.9)\n",
        "            equation.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        brace = Brace(root_two_equations[1], UP)\n",
        "        f_equals_0 = brace.get_tex(\"f(x) = 0\")\n",
        "\n",
        "        self.teacher_holds_up(root_two_equations[0])\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            *root_two_equations, \n",
        "            run_time = 1.5,\n",
        "            path_arc = TAU/2\n",
        "        ))\n",
        "        self.play(self.change_students(*[\"pondering\"]*3))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            self.teacher.change, \"happy\"\n",
        "        )\n",
        "        self.play(Write(f_equals_0))\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "        #\n",
        "        to_remove = VGroup(root_two_equations[0], brace, f_equals_0)\n",
        "        two_d_equation = OldTex(\"\"\"\n",
        "            \\\\left[\\\\begin{array}{c}\n",
        "                ye^x \\\\\\\\\n",
        "                \\\\sin(xy)\n",
        "            \\\\end{array}\\\\right] = \n",
        "            \\\\left[\\\\begin{array}{c}\n",
        "                y^2 + x^3 \\\\\\\\\n",
        "                3y - x\n",
        "            \\\\end{array}\\\\right]\n",
        "        \"\"\")\n",
        "        complex_equation = OldTex(\"z\", \"^5 + \", \"z\", \" + 1 = 0\")\n",
        "        z_def = OldTexText(\n",
        "            \"(\", \"$z$\", \" is complex, \", \"$a + bi$\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        complex_group = VGroup(complex_equation, z_def)\n",
        "        complex_group.arrange(DOWN)\n",
        "        for tex in complex_group:\n",
        "            tex.set_color_by_tex(\"z\", GREEN)\n",
        "        complex_group.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                to_remove.next_to, FRAME_X_RADIUS*RIGHT, RIGHT,\n",
        "                remover = True,\n",
        "                rate_func = running_start,\n",
        "                path_arc = -TAU/4,\n",
        "            ),\n",
        "            self.teacher.change, \"hesitant\",\n",
        "            self.change_students(*[\"erm\"]*3)\n",
        "        )\n",
        "        self.teacher_holds_up(two_d_equation)\n",
        "        self.play_all_student_changes(\"horrified\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(two_d_equation),\n",
        "            FadeInFromDown(complex_group),\n",
        "        )\n",
        "        self.play_all_student_changes(\"confused\")\n",
        "        self.wait(3)\n",
        "\n",
        "class InputOutputScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"plane_width\" : 6,\n",
        "        \"plane_height\" : 6,\n",
        "        \"x_shift\" : FRAME_X_RADIUS/2,\n",
        "        \"y_shift\" : MED_LARGE_BUFF,\n",
        "        \"output_scalar\" : 10,\n",
        "        \"non_renormalized_func\" : plane_func_by_wind_spec(\n",
        "            (-2, -1, 2), \n",
        "            (1, 1, 1), \n",
        "            (2, -2, -1),\n",
        "        ),\n",
        "    }\n",
        "\n",
        "    ###\n",
        "\n",
        "    def func(self, coord_pair):\n",
        "        out_coords = np.array(self.non_renormalized_func(coord_pair))\n",
        "        out_norm = get_norm(out_coords)\n",
        "        if out_norm > 1:\n",
        "            angle = angle_of_vector(out_coords)\n",
        "            factor = 0.5-0.1*np.cos(4*angle)\n",
        "            target_norm = factor*np.log(out_norm)\n",
        "            out_coords *= target_norm / out_norm\n",
        "        else:\n",
        "            out_coords = (0, 0)\n",
        "        return tuple(out_coords)\n",
        "\n",
        "    def point_function(self, point):\n",
        "        in_coords = self.input_plane.point_to_coords(point)\n",
        "        out_coords = self.func(in_coords)\n",
        "        return self.output_plane.coords_to_point(*out_coords)\n",
        "\n",
        "    def get_colorings(self):\n",
        "        in_cmos = ColorMappedObjectsScene(\n",
        "            func = lambda p : self.non_renormalized_func(\n",
        "                (p[0]+self.x_shift, p[1]+self.y_shift)\n",
        "            )\n",
        "        )\n",
        "        scalar = self.output_scalar\n",
        "        out_cmos = ColorMappedObjectsScene(\n",
        "            func = lambda p : (\n",
        "                scalar*(p[0]-self.x_shift), scalar*(p[1]+self.y_shift)\n",
        "            )\n",
        "        )\n",
        "\n",
        "        input_coloring = Rectangle(\n",
        "            height = self.plane_height,\n",
        "            width = self.plane_width,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        output_coloring = input_coloring.copy()\n",
        "        colorings = VGroup(input_coloring, output_coloring)\n",
        "        vects = [LEFT, RIGHT]\n",
        "        cmos_pair = [in_cmos, out_cmos]\n",
        "        for coloring, vect, cmos in zip(colorings, vects, cmos_pair):\n",
        "            coloring.move_to(self.x_shift*vect + self.y_shift*DOWN)\n",
        "            coloring.color_using_background_image(cmos.background_image_file)\n",
        "        return colorings\n",
        "\n",
        "    def get_planes(self):\n",
        "        input_plane = self.input_plane = NumberPlane(\n",
        "            x_radius = self.plane_width / 2.0,\n",
        "            y_radius = self.plane_height / 2.0,\n",
        "        )\n",
        "        output_plane = self.output_plane = input_plane.deepcopy()\n",
        "        planes = VGroup(input_plane, output_plane)\n",
        "        vects = [LEFT, RIGHT]\n",
        "        label_texts = [\"Input\", \"Output\"]\n",
        "        label_colors = [GREEN, RED]\n",
        "        for plane, vect, text, color in zip(planes, vects, label_texts, label_colors):\n",
        "            plane.stretch_to_fit_width(self.plane_width)\n",
        "            plane.add_coordinates(x_vals = list(range(-2, 3)), y_vals = list(range(-2, 3)))\n",
        "            plane.white_parts = VGroup(plane.axes, plane.coordinate_labels)\n",
        "            plane.coordinate_labels.set_background_stroke(width=0)\n",
        "            plane.lines_to_fade = VGroup(planes, plane.secondary_lines)\n",
        "            plane.move_to(vect*FRAME_X_RADIUS/2 + self.y_shift*DOWN)\n",
        "            label = OldTexText(text)\n",
        "            label.scale(1.5)\n",
        "            label.add_background_rectangle()\n",
        "            label.move_to(plane)\n",
        "            label.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "            plane.add(label)\n",
        "            plane.label = label\n",
        "            for submob in plane.get_family():\n",
        "                if isinstance(submob, Tex) and hasattr(submob, \"background_rectangle\"):\n",
        "                    submob.remove(submob.background_rectangle)\n",
        "\n",
        "        return planes\n",
        "\n",
        "    def get_v_line(self):\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        v_line.set_stroke(WHITE, 5)\n",
        "        return v_line\n",
        "\n",
        "    def get_dots(self, input_plane, output_plane):\n",
        "        step = self.dot_density\n",
        "        x_min = -3.0\n",
        "        x_max = 3.0\n",
        "        y_min = -3.0\n",
        "        y_max = 3.0\n",
        "        dots = VGroup()\n",
        "        for x in np.arange(x_min, x_max + step, step):\n",
        "            for y in np.arange(y_max, y_min - step, -step):\n",
        "                out_coords = self.func((x, y))\n",
        "                dot = Dot(radius = self.dot_radius)\n",
        "                dot.set_stroke(BLACK, 1)\n",
        "                dot.move_to(input_plane.coords_to_point(x, y))\n",
        "                dot.original_position = dot.get_center()\n",
        "                dot.generate_target()\n",
        "                dot.target.move_to(output_plane.coords_to_point(*out_coords))\n",
        "                dot.target_color = rgba_to_color(point_to_rgba(\n",
        "                    tuple(self.output_scalar*np.array(out_coords))\n",
        "                ))\n",
        "                dots.add(dot)\n",
        "        return dots\n",
        "\n",
        "class IntroduceInputOutputScene(InputOutputScene):\n",
        "    CONFIG = {\n",
        "        \"dot_radius\" : 0.05,\n",
        "        \"dot_density\" : 0.25,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_planes()\n",
        "        self.map_single_point_to_point()\n",
        "\n",
        "    def setup_planes(self):\n",
        "        self.input_plane, self.output_plane = self.get_planes()\n",
        "        self.v_line = self.get_v_line()\n",
        "        self.add(self.input_plane, self.output_plane, self.v_line)\n",
        "\n",
        "    def map_single_point_to_point(self):\n",
        "        input_plane = self.input_plane\n",
        "        output_plane = self.output_plane\n",
        "\n",
        "        #Dots\n",
        "        dots = self.get_dots()\n",
        "\n",
        "        in_dot = dots[int(0.55*len(dots))].copy()\n",
        "        out_dot = in_dot.target\n",
        "        for mob in in_dot, out_dot:\n",
        "            mob.scale(1.5)\n",
        "        in_dot.set_color(YELLOW)\n",
        "        out_dot.set_color(PINK)\n",
        "\n",
        "        input_label_arrow = Vector(DOWN+RIGHT)\n",
        "        input_label_arrow.next_to(in_dot, UP+LEFT, SMALL_BUFF)\n",
        "        input_label = OldTexText(\"Input point\")\n",
        "        input_label.next_to(input_label_arrow.get_start(), UP, SMALL_BUFF)\n",
        "        for mob in input_label, input_label_arrow:\n",
        "            mob.match_color(in_dot)\n",
        "        input_label.add_background_rectangle()\n",
        "        \n",
        "        output_label_arrow = Vector(DOWN+LEFT)\n",
        "        output_label_arrow.next_to(out_dot, UP+RIGHT, SMALL_BUFF)\n",
        "        output_label = OldTexText(\"Output point\")\n",
        "        output_label.next_to(output_label_arrow.get_start(), UP, SMALL_BUFF)\n",
        "        for mob in output_label, output_label_arrow:\n",
        "            mob.match_color(out_dot)\n",
        "        output_label.add_background_rectangle()\n",
        "\n",
        "        path_arc = -TAU/4\n",
        "        curved_arrow = Arrow(\n",
        "            in_dot, out_dot,\n",
        "            buff = SMALL_BUFF,\n",
        "            path_arc = path_arc,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        curved_arrow.pointwise_become_partial(curved_arrow, 0, 0.95)\n",
        "        function_label = OldTex(\"f(\", \"\\\\text{2d input}\", \")\")\n",
        "        function_label.next_to(curved_arrow, UP)\n",
        "        function_label.add_background_rectangle()\n",
        "\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, dots))\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, dots,\n",
        "            path_arc = path_arc\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(dots))\n",
        "        self.play(\n",
        "            GrowFromCenter(in_dot),\n",
        "            GrowArrow(input_label_arrow),\n",
        "            FadeIn(input_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(curved_arrow),\n",
        "            ReplacementTransform(\n",
        "                in_dot.copy(), out_dot,\n",
        "                path_arc = path_arc\n",
        "            ),\n",
        "            FadeIn(function_label),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(output_label_arrow),\n",
        "            FadeIn(output_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            input_label_arrow, input_label,\n",
        "            output_label_arrow, output_label,\n",
        "            curved_arrow, function_label,\n",
        "        ])))\n",
        "\n",
        "        #General movements and wiggles\n",
        "        out_dot_continual_update = self.get_output_dot_continual_update(in_dot, out_dot)\n",
        "        self.add(out_dot_continual_update)\n",
        "\n",
        "        for vect in UP, RIGHT:\n",
        "            self.play(\n",
        "                in_dot.shift, 0.25*vect,\n",
        "                rate_func = lambda t : wiggle(t, 8),\n",
        "                run_time = 2\n",
        "            )\n",
        "        for vect in compass_directions(4, UP+RIGHT):\n",
        "            self.play(Rotating(\n",
        "                in_dot, about_point = in_dot.get_corner(vect),\n",
        "                radians = TAU,\n",
        "                run_time = 1\n",
        "            ))\n",
        "        self.wait()\n",
        "        for coords in (-2, 2), (-2, -2), (2, -2), (1.5, 1.5):\n",
        "            self.play(\n",
        "                in_dot.move_to, input_plane.coords_to_point(*coords),\n",
        "                path_arc = -TAU/4,\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_dots(self):\n",
        "        input_plane = self.input_plane\n",
        "        dots = VGroup()\n",
        "        step = self.dot_density\n",
        "        x_max = input_plane.x_radius\n",
        "        x_min = -x_max\n",
        "        y_max = input_plane.y_radius\n",
        "        y_min = -y_max\n",
        "\n",
        "        reverse = False\n",
        "        for x in np.arange(x_min+step, x_max, step):\n",
        "            y_range = list(np.arange(x_min+step, x_max, step))\n",
        "            if reverse:\n",
        "                y_range.reverse()\n",
        "            reverse = not reverse\n",
        "            for y in y_range:\n",
        "                dot = Dot(radius = self.dot_radius)\n",
        "                dot.move_to(input_plane.coords_to_point(x, y))\n",
        "                dot.generate_target()\n",
        "                dot.target.move_to(self.point_function(dot.get_center()))\n",
        "                dots.add(dot)\n",
        "        return dots\n",
        "\n",
        "    def get_output_dot_continual_update(self, input_dot, output_dot):\n",
        "        return Mobject.add_updater(\n",
        "            output_dot, \n",
        "            lambda od : od.move_to(self.point_function(input_dot.get_center()))\n",
        "        )\n",
        "\n",
        "class IntroduceVectorField(IntroduceInputOutputScene):\n",
        "    CONFIG = {\n",
        "        \"dot_density\" : 0.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_planes()\n",
        "        input_plane, output_plane = self.input_plane, self.output_plane\n",
        "        dots = self.get_dots()\n",
        "\n",
        "        in_dot = dots[0].copy()\n",
        "        in_dot.move_to(input_plane.coords_to_point(1.5, 1.5))\n",
        "        out_dot = in_dot.copy()\n",
        "        out_dot_continual_update = self.get_output_dot_continual_update(in_dot, out_dot)\n",
        "        for mob in in_dot, out_dot:\n",
        "            mob.scale(1.5)\n",
        "        in_dot.set_color(YELLOW)\n",
        "        out_dot.set_color(PINK)\n",
        "\n",
        "        out_vector = Arrow(\n",
        "            LEFT, RIGHT, \n",
        "            color = out_dot.get_color(),\n",
        "        )\n",
        "        out_vector.set_stroke(BLACK, 1)\n",
        "        continual_out_vector_update = Mobject.add_updater(\n",
        "            out_vector, lambda ov : ov.put_start_and_end_on(\n",
        "                output_plane.coords_to_point(0, 0),\n",
        "                out_dot.get_center(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        in_vector = out_vector.copy()\n",
        "        def update_in_vector(in_vector):\n",
        "            Transform(in_vector, out_vector).update(1)\n",
        "            in_vector.scale(0.5)\n",
        "            in_vector.shift(in_dot.get_center() - in_vector.get_start())\n",
        "        continual_in_vector_update = Mobject.add_updater(\n",
        "            in_vector, update_in_vector\n",
        "        )\n",
        "        continual_updates = [\n",
        "            out_dot_continual_update,\n",
        "            continual_out_vector_update, \n",
        "            continual_in_vector_update\n",
        "        ]\n",
        "\n",
        "        self.add(in_dot, out_dot)\n",
        "        self.play(GrowArrow(out_vector, run_time = 2))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(in_dot)\n",
        "        self.play(ReplacementTransform(out_vector.copy(), in_vector))\n",
        "        self.wait()\n",
        "        self.add(*continual_updates)\n",
        "        path = Square().rotate(-90*DEGREES)\n",
        "        path.replace(Line(\n",
        "            input_plane.coords_to_point(-1.5, -1.5),\n",
        "            input_plane.coords_to_point(1.5, 1.5),\n",
        "        ), stretch = True)\n",
        "        in_vectors = VGroup()\n",
        "        self.add(in_vectors)\n",
        "        for a in np.linspace(0, 1, 25):\n",
        "            self.play(\n",
        "                in_dot.move_to, path.point_from_proportion(a),\n",
        "                run_time = 0.2,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            in_vectors.add(in_vector.copy())\n",
        "\n",
        "        # Full vector field\n",
        "        newer_in_vectors = VGroup()\n",
        "        self.add(newer_in_vectors)\n",
        "        for dot in dots:\n",
        "            self.play(in_dot.move_to, dot, run_time = 1./15)\n",
        "            newer_in_vectors.add(in_vector.copy())\n",
        "        self.remove(*continual_updates)\n",
        "        self.remove()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            out_dot, out_vector, in_vectors, in_dot, in_vector\n",
        "        ])))\n",
        "        self.wait()\n",
        "        target_length = 0.4\n",
        "        for vector in newer_in_vectors:\n",
        "            vector.generate_target()\n",
        "            if vector.get_length() == 0:\n",
        "                continue\n",
        "            factor = target_length / vector.get_length()\n",
        "            vector.target.scale(factor, about_point = vector.get_start())\n",
        "\n",
        "        self.play(LaggedStartMap(MoveToTarget, newer_in_vectors))\n",
        "        self.wait()\n",
        "\n",
        "class TwoDScreenInOurThreeDWorld(AltTeacherStudentsScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.ask_about_2d_functions()\n",
        "        self.show_3d()\n",
        "\n",
        "    def ask_about_2d_functions(self):\n",
        "        in_plane = NumberPlane(x_radius = 2.5, y_radius = 2.5)\n",
        "        in_plane.add_coordinates()\n",
        "        in_plane.set_height(3)\n",
        "        out_plane = in_plane.copy()\n",
        "\n",
        "        in_text = OldTexText(\"Input space\")\n",
        "        out_text = OldTexText(\"Output space\")\n",
        "        VGroup(in_text, out_text).scale(0.75)\n",
        "        in_text.next_to(in_plane, UP, SMALL_BUFF)\n",
        "        out_text.next_to(out_plane, UP, SMALL_BUFF)\n",
        "        in_plane.add(in_text)\n",
        "        out_plane.add(out_text)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            LEFT, RIGHT, \n",
        "            path_arc = -TAU/4,\n",
        "            color = WHITE\n",
        "        )\n",
        "        arrow.pointwise_become_partial(arrow, 0.0, 0.97)\n",
        "        group = VGroup(in_plane, arrow, out_plane)\n",
        "        group.arrange(RIGHT)\n",
        "        arrow.shift(UP)\n",
        "        group.move_to(self.students)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        dots = VGroup()\n",
        "        dots_target = VGroup()\n",
        "        for x in np.arange(-2.5, 3.0, 0.5):\n",
        "            for y in np.arange(-2.5, 3.0, 0.5):\n",
        "                dot = Dot(radius = 0.05)\n",
        "                dot.move_to(in_plane.coords_to_point(x, y))\n",
        "                dot.generate_target()\n",
        "                dot.target.move_to(out_plane.coords_to_point(\n",
        "                    x + 0.25*np.cos(5*y), y + 0.25*np.sin(3*x)\n",
        "                ))\n",
        "                dots.add(dot)\n",
        "                dots_target.add(dot.target)\n",
        "        dots.set_color_by_gradient(YELLOW, RED)\n",
        "        dots_target.set_color_by_gradient(YELLOW, RED)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            Write(in_plane, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            ReplacementTransform(\n",
        "                in_plane.copy(), out_plane,\n",
        "                path_arc = -TAU/4,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, dots, run_time = 1),\n",
        "            self.change_students(*3*[\"erm\"]),\n",
        "        )\n",
        "        self.play(LaggedStartMap(MoveToTarget, dots, path_arc = -TAU/4))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    def show_3d(self):\n",
        "        laptop = Laptop().scale(2)\n",
        "        laptop.rotate(-TAU/12, DOWN)\n",
        "        laptop.rotate(-5*TAU/24, LEFT)\n",
        "        laptop.rotate(TAU/8, LEFT)\n",
        "        laptop.scale(2.3*FRAME_X_RADIUS/laptop.screen_plate.get_width())\n",
        "        laptop.shift(-laptop.screen_plate.get_center() + 0.1*IN)\n",
        "        should_shade_in_3d(laptop)\n",
        "\n",
        "        everything = VGroup(laptop, *self.mobjects)\n",
        "        everything.generate_target()\n",
        "        # for mob in everything.target.get_family():\n",
        "        #     if isinstance(mob, PiCreature):\n",
        "        #         mob.change_mode(\"confused\")\n",
        "        everything.target.rotate(TAU/12, LEFT)\n",
        "        everything.target.rotate(TAU/16, UP)\n",
        "        everything.target.shift(4*UP)\n",
        "\n",
        "        self.move_camera(\n",
        "            distance = 12,\n",
        "            run_time = 4,\n",
        "            added_anims = [MoveToTarget(everything, run_time = 4)],\n",
        "        )\n",
        "        always_rotate(everything, axis=UP, rate=3 * DEGREES)\n",
        "        self.wait(10)\n",
        "\n",
        "class EveryOutputPointHasAColor(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda p : p,\n",
        "        \"dot_spacing\" : 0.1,\n",
        "        \"dot_radius\" : 0.01,\n",
        "    }\n",
        "    def construct(self):\n",
        "        full_rect = FullScreenRectangle()\n",
        "        full_rect.set_fill(WHITE, 1)\n",
        "        full_rect.set_stroke(WHITE, 0)\n",
        "        full_rect.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        title = OldTexText(\"Output Space\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        title.set_stroke(BLACK, 1)\n",
        "        # self.add_foreground_mobjects(title)\n",
        "\n",
        "        plane = NumberPlane()\n",
        "        plane.fade(0.5)\n",
        "        plane.axes.set_stroke(WHITE, 3)\n",
        "        # plane.add(BackgroundRectangle(title))\n",
        "        self.add(plane)\n",
        "\n",
        "\n",
        "        dots = VGroup()\n",
        "        step = self.dot_spacing\n",
        "        for x in np.arange(-FRAME_X_RADIUS, FRAME_X_RADIUS+step, step):\n",
        "            for y in np.arange(-FRAME_Y_RADIUS, FRAME_Y_RADIUS+step, step):\n",
        "                dot = Dot(color = WHITE)\n",
        "                dot.color_using_background_image(self.background_image_file)\n",
        "                dot.move_to(x*RIGHT + y*UP)\n",
        "                dots.add(dot)\n",
        "        random.shuffle(dots.submobjects)\n",
        "\n",
        "        m = 3 #exponential factor        \n",
        "        n = 1\n",
        "        dot_groups = VGroup()\n",
        "        while n <= len(dots):\n",
        "            dot_groups.add(dots[n-1:m*n-1])\n",
        "            n *= m\n",
        "        self.play(LaggedStartMap(\n",
        "            LaggedStartMap, dot_groups,\n",
        "            lambda dg : (GrowFromCenter,  dg),\n",
        "            run_time = 8,\n",
        "            lag_ratio = 0.2,\n",
        "        ))\n",
        "\n",
        "class DotsHoppingToColor(InputOutputScene):\n",
        "    CONFIG = {\n",
        "        \"dot_radius\" : 0.05,\n",
        "        \"dot_density\" : 0.25,\n",
        "    }\n",
        "    def construct(self):\n",
        "        input_coloring, output_coloring = self.get_colorings()\n",
        "        input_plane, output_plane = self.get_planes()\n",
        "        v_line = self.get_v_line()\n",
        "\n",
        "        dots = self.get_dots(input_plane, output_plane)\n",
        "\n",
        "        right_half_block = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = FRAME_X_RADIUS - SMALL_BUFF,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8,\n",
        "        )\n",
        "        right_half_block.to_edge(RIGHT, buff = 0)\n",
        "\n",
        "        #Introduce parts\n",
        "        self.add(input_plane, output_plane, v_line)\n",
        "        self.play(\n",
        "            FadeIn(output_coloring), \n",
        "            Animation(output_plane),\n",
        "            output_plane.white_parts.set_color, BLACK,\n",
        "            output_plane.lines_to_fade.set_stroke, {\"width\" : 0},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(GrowFromCenter, dots, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "        #Hop over and back\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, dots, \n",
        "            path_arc = -TAU/4,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, dots,\n",
        "            lambda d : (d.set_fill, d.target_color),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, dots,\n",
        "            lambda d : (d.move_to, d.original_position),\n",
        "            path_arc = TAU/4,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(input_coloring),\n",
        "            Animation(input_plane),\n",
        "            input_plane.white_parts.set_color, BLACK,\n",
        "            input_plane.lines_to_fade.set_stroke, {\"width\" : 0},\n",
        "            FadeOut(dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Cover output half\n",
        "        right_half_block.save_state()\n",
        "        right_half_block.next_to(FRAME_X_RADIUS*RIGHT, RIGHT)\n",
        "        self.play(right_half_block.restore)\n",
        "        self.wait()\n",
        "\n",
        "        # Show yellow points\n",
        "        inspector = DashedLine(\n",
        "            ORIGIN, TAU*UP,\n",
        "            dash_length = TAU/24,\n",
        "            fill_opacity = 0,\n",
        "            stroke_width = 3,\n",
        "            stroke_color = WHITE,\n",
        "        )\n",
        "        inspector.add(*inspector.copy().set_color(BLACK).shift((TAU/24)*UP))\n",
        "        inspector.apply_complex_function(np.exp)\n",
        "        inspector.scale(0.15)\n",
        "\n",
        "        inspector_image = inspector.copy()\n",
        "        def update_inspector_image(inspector_image):\n",
        "            inspector_image.move_to(self.point_function(inspector.get_center()))\n",
        "\n",
        "        inspector_image_update_anim = UpdateFromFunc(\n",
        "            inspector_image, update_inspector_image\n",
        "        )\n",
        "        pink_points_label = OldTexText(\"Pink points\")\n",
        "        pink_points_label.scale(0.7)\n",
        "        pink_points_label.set_color(BLACK)\n",
        "\n",
        "        self.play(\n",
        "            inspector.move_to, input_plane.coords_to_point(-2.75, 2.75),\n",
        "            inspector.set_stroke, {\"width\" : 2},\n",
        "        )\n",
        "        pink_points_label.next_to(inspector, RIGHT)\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                inspector, about_point = inspector.get_center(),\n",
        "                rate_func = smooth,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            Write(pink_points_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(right_half_block.next_to, FRAME_X_RADIUS*RIGHT, RIGHT)\n",
        "        inspector_image_update_anim.update(0)\n",
        "        self.play(ReplacementTransform(\n",
        "            inspector.copy(), inspector_image,\n",
        "            path_arc = -TAU/4,\n",
        "        ))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                inspector.move_to, \n",
        "                input_plane.coords_to_point(-2, 0),\n",
        "                path_arc = -TAU/8,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            inspector_image_update_anim\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                inspector.move_to, \n",
        "                input_plane.coords_to_point(-2.75, 2.75),\n",
        "                path_arc = TAU/8,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            inspector_image_update_anim\n",
        "        )\n",
        "        self.play(FadeOut(pink_points_label))\n",
        "\n",
        "        # Show black zero\n",
        "        zeros = tuple(it.starmap(input_plane.coords_to_point, [\n",
        "            (-2., -1), (1, 1), (2, -2),\n",
        "        ]))\n",
        "        for x in range(2):\n",
        "            for zero in zeros:\n",
        "                path = ParametricCurve(\n",
        "                    bezier([\n",
        "                        inspector.get_center(), \n",
        "                        input_plane.coords_to_point(0, 0),\n",
        "                        zero\n",
        "                    ]),\n",
        "                    t_min = 0, t_max = 1\n",
        "                )\n",
        "                self.play(\n",
        "                    MoveAlongPath(inspector, path, run_time = 2),\n",
        "                    inspector_image_update_anim,\n",
        "                )\n",
        "                self.wait()\n",
        "        self.play(FadeOut(VGroup(inspector, inspector_image)))\n",
        "\n",
        "        # Show all dots and slowly fade them out\n",
        "        for dot in dots:\n",
        "            dot.scale(1.5)\n",
        "        self.play(\n",
        "            FadeOut(input_coloring),\n",
        "            input_plane.white_parts.set_color, WHITE,\n",
        "            LaggedStartMap(GrowFromCenter, dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        random.shuffle(dots.submobjects)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, dots,\n",
        "            lag_ratio = 0.05,\n",
        "            run_time = 10,\n",
        "        ))\n",
        "\n",
        "        # Ask about whether a region contains a zero\n",
        "        question = OldTexText(\"Does this region \\\\\\\\ contain a zero?\")\n",
        "        question.add_background_rectangle(opacity = 1)\n",
        "        question.next_to(input_plane.label, DOWN)\n",
        "        square = Square()\n",
        "        square.match_background_image_file(input_coloring)\n",
        "        square.move_to(input_plane)\n",
        "\n",
        "        self.play(ShowCreation(square), Write(question))\n",
        "        self.wait()\n",
        "        quads = [\n",
        "            (0, 0.5, 6, 6.25),\n",
        "            (1, 1, 0.5, 2),\n",
        "            (-1, -1, 3, 4.5),\n",
        "            (0, 1.25, 5, 1.7),\n",
        "            (-2, -1, 1, 1),\n",
        "        ]\n",
        "        for x, y, width, height in quads:\n",
        "            self.play(\n",
        "                square.stretch_to_fit_width, width,\n",
        "                square.stretch_to_fit_height, height,\n",
        "                square.move_to, input_plane.coords_to_point(x, y)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class SoWeFoundTheZeros(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Aha! So we \\\\\\\\ found the solutions!\",\n",
        "            target_mode = \"hooray\",\n",
        "            index = 2,\n",
        "            bubble_config = {\"direction\" : LEFT},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Er...only \\\\\\\\ kind of\",\n",
        "            target_mode = \"hesitant\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class Rearrange2DEquation(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        f_tex, g_tex, h_tex = [\n",
        "            \"%s(\\\\text{2d point})\"%char\n",
        "            for char in (\"f\", \"g\", \"h\") \n",
        "        ]\n",
        "        zero_tex = \"\\\\vec{\\\\textbf{0}}\"\n",
        "        equations = VGroup(\n",
        "            OldTex(g_tex, \"\", \"=\", h_tex, \"\"),\n",
        "            OldTex(g_tex, \"-\", h_tex, \"=\", zero_tex),\n",
        "        )\n",
        "        equations.move_to(self.hold_up_spot, DOWN)\n",
        "        equations.shift_onto_screen()\n",
        "\n",
        "        brace = Brace(equations[1], UP)\n",
        "        zero_eq = brace.get_tex(\"%s = %s\"%(f_tex, zero_tex))\n",
        "\n",
        "        for equation in equations:\n",
        "            equation.set_color_by_tex(g_tex, BLUE)\n",
        "            equation.set_color_by_tex(h_tex, YELLOW)\n",
        "            equation.sort_alphabetically()\n",
        "\n",
        "\n",
        "        self.teacher_holds_up(equations[0])\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.play(Transform(\n",
        "            *equations,\n",
        "            run_time = 1.5,\n",
        "            path_arc = TAU/2\n",
        "        ))\n",
        "        self.play(\n",
        "            Succession(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(zero_eq, run_time = 1)\n",
        "            ),\n",
        "            self.change_students(*[\"happy\"]*3)\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"thinking\", self.screen)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "class SearchForZerosInInputSpace(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "    }\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "        title = OldTexText(\"Input space\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        title.set_stroke(BLACK, 1)\n",
        "        title.add_background_rectangle()\n",
        "\n",
        "        plane = NumberPlane()\n",
        "        plane.fade(0.5)\n",
        "        plane.axes.set_stroke(WHITE, 3)\n",
        "\n",
        "        self.add(plane, title)\n",
        "\n",
        "        looking_glass = Circle()\n",
        "        looking_glass.set_stroke(WHITE, 3)\n",
        "        looking_glass.set_fill(WHITE, 0.6)\n",
        "        looking_glass.color_using_background_image(self.background_image_file)\n",
        "        question = OldTexText(\"Which points go to 0?\")\n",
        "        question.next_to(looking_glass, DOWN)\n",
        "        question.add_background_rectangle()\n",
        "\n",
        "        mover = VGroup(looking_glass, question)\n",
        "        mover.move_to(4*LEFT + UP)\n",
        "\n",
        "        self.play(FadeIn(mover))\n",
        "        points = [4*RIGHT+UP, 2*RIGHT+2*DOWN, 2*LEFT+2*DOWN, 3*RIGHT+2.5*DOWN]\n",
        "        for point in points:\n",
        "            self.play(mover.move_to, point, run_time = 1.5)\n",
        "            self.wait()\n",
        "\n",
        "class OneDRegionBoundary(Scene):\n",
        "    CONFIG = {\n",
        "        \"graph_color\" : BLUE,\n",
        "        \"region_rect_height\" : 0.1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        x0 = self.x0 = 3 \n",
        "        x1 = self.x1 = 6\n",
        "        fx0 = self.fx0 = -2\n",
        "        fx1 = self.fx1 = 2\n",
        "\n",
        "        axes = self.axes = Axes(\n",
        "            x_min = -1, x_max = 10,\n",
        "            y_min = -3, y_max = 3,\n",
        "        )\n",
        "        axes.center()\n",
        "        axes.set_stroke(width = 2)\n",
        "\n",
        "        input_word = OldTexText(\"Input\")\n",
        "        input_word.next_to(axes.x_axis, UP, SMALL_BUFF, RIGHT)\n",
        "        output_word = OldTexText(\"Output\")\n",
        "        output_word.next_to(axes.y_axis, UP)\n",
        "        axes.add(input_word, output_word)\n",
        "        self.add(axes)\n",
        "\n",
        "        graph = self.get_graph_part(1, 1)\n",
        "        alt_graphs = [\n",
        "            self.get_graph_part(*points)\n",
        "            for points in [\n",
        "                (-1, -2),\n",
        "                (-1, -1, -1),\n",
        "                (1, 1, 1),\n",
        "                (-0.75, 0, 1.75),\n",
        "                (-3, -2, -1),\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        #Region and boundary\n",
        "        line = Line(axes.coords_to_point(x0, 0), axes.coords_to_point(x1, 0))\n",
        "        region = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.5,\n",
        "            height = self.region_rect_height\n",
        "        )\n",
        "        region.match_width(line, stretch = True)\n",
        "        region.move_to(line)\n",
        "\n",
        "        region_words = OldTexText(\"Input region\")\n",
        "        region_words.set_width(0.8*region.get_width())\n",
        "        region_words.next_to(region, UP)\n",
        "\n",
        "        x0_arrow, x1_arrow = arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                axes.coords_to_point(x, 0),\n",
        "                axes.coords_to_point(x, fx),\n",
        "                color = color,\n",
        "                buff = 0\n",
        "            )\n",
        "            for x, fx, color in [(x0, fx0, RED), (x1, fx1, GREEN)]\n",
        "        ])\n",
        "        minus = OldTex(\"-\")\n",
        "        minus.match_color(x0_arrow)\n",
        "        minus.next_to(x0_arrow, UP)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.match_color(x1_arrow)\n",
        "        plus.next_to(x1_arrow, DOWN)\n",
        "        signs = VGroup(plus, minus)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(region),\n",
        "            FadeIn(region_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(GrowArrow, arrows)),\n",
        "            list(map(Write, signs))\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(graph), \n",
        "            FadeOut(region_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        for alt_graph in alt_graphs + alt_graphs:\n",
        "            self.play(Transform(graph, alt_graph, path_arc = 0.1*TAU))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_graph_part(self, *interim_values):\n",
        "        result = VMobject()\n",
        "        result.set_stroke(self.graph_color, 3)\n",
        "        result.set_fill(opacity = 0)\n",
        "        values = [self.fx0] + list(interim_values) + [self.fx1]\n",
        "        result.set_points_smoothly([\n",
        "            self.axes.coords_to_point(x, fx)\n",
        "            for x, fx in zip(\n",
        "                np.linspace(self.x0, self.x1, len(values)),\n",
        "                values\n",
        "            )\n",
        "        ])\n",
        "        return result\n",
        "\n",
        "class DirectionOfA2DFunctionAlongABoundary(InputOutputScene):\n",
        "    def construct(self):\n",
        "        colorings = self.get_colorings()\n",
        "        colorings.set_fill(opacity = 0.25)\n",
        "        input_plane, output_plane = planes = self.get_planes()\n",
        "        for plane in planes:\n",
        "            plane.lines_to_fade.set_stroke(width = 0)\n",
        "        v_line = self.get_v_line()\n",
        "\n",
        "        rect = Rectangle()\n",
        "        rect.set_stroke(WHITE, 5)\n",
        "        rect.set_fill(WHITE, 0)\n",
        "        line = Line(\n",
        "            input_plane.coords_to_point(-0.75, 2.5),\n",
        "            input_plane.coords_to_point(2.5, -1.5),\n",
        "        )\n",
        "        rect.replace(line, stretch = True)\n",
        "        rect.insert_n_curves(50)\n",
        "        rect.match_background_image_file(colorings[0])\n",
        "\n",
        "        rect_image = rect.copy()\n",
        "        rect_image.match_background_image_file(colorings[1])\n",
        "        def update_rect_image(rect_image):\n",
        "            rect_image.set_points(rect.get_points())\n",
        "            rect_image.apply_function(self.point_function)\n",
        "        rect_image_update_anim = UpdateFromFunc(rect_image, update_rect_image)\n",
        "\n",
        "\n",
        "        def get_input_point():\n",
        "            return rect.get_points()[-1]\n",
        "\n",
        "        def get_output_coords():\n",
        "            in_coords = input_plane.point_to_coords(get_input_point())\n",
        "            return self.func(in_coords)\n",
        "\n",
        "        def get_angle():\n",
        "            return angle_of_vector(get_output_coords())\n",
        "\n",
        "        def get_color():\n",
        "            return rev_to_color(get_angle()/TAU) #Negative?\n",
        "\n",
        "\n",
        "        out_vect = Vector(RIGHT, color = WHITE)\n",
        "        out_vect_update_anim = UpdateFromFunc(\n",
        "            out_vect,\n",
        "            lambda ov : ov.put_start_and_end_on(\n",
        "                output_plane.coords_to_point(0, 0),\n",
        "                rect_image.get_points()[-1]\n",
        "            ).set_color(get_color())\n",
        "        )\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.set_stroke(BLACK, 1)\n",
        "        dot_update_anim = UpdateFromFunc(\n",
        "            dot, lambda d : d.move_to(get_input_point()).set_fill(get_color())\n",
        "        )\n",
        "\n",
        "        in_vect = Vector(RIGHT)\n",
        "        def update_in_vect(in_vect):\n",
        "            in_vect.put_start_and_end_on(ORIGIN, 0.5*RIGHT)\n",
        "            in_vect.rotate(get_angle())\n",
        "            in_vect.set_color(get_color())\n",
        "            in_vect.shift(get_input_point() - in_vect.get_start())\n",
        "            return in_vect\n",
        "        in_vect_update_anim = UpdateFromFunc(in_vect, update_in_vect)\n",
        "\n",
        "        self.add(colorings, planes, v_line)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(out_vect),\n",
        "            GrowArrow(in_vect),\n",
        "            Animation(dot),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            ShowCreation(rect_image),\n",
        "            out_vect_update_anim,\n",
        "            in_vect_update_anim,\n",
        "            dot_update_anim,\n",
        "            rate_func = bezier([0, 0, 1, 1]),\n",
        "            run_time = 10,\n",
        "        )\n",
        "\n",
        "class AskAboutHowToGeneralizeSigns(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # 2d plane\n",
        "        plane = NumberPlane(x_radius = 2.5, y_radius = 2.5)\n",
        "        plane.scale(0.8)\n",
        "        plane.to_corner(UP+LEFT)\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        dot = Dot(color = YELLOW)\n",
        "        label = OldTexText(\"Sign?\")\n",
        "        label.add_background_rectangle()\n",
        "        label.scale(0.5)\n",
        "        label.next_to(dot, UP, SMALL_BUFF)\n",
        "        dot.add(label)\n",
        "        dot.move_to(plane.coords_to_point(1, 1))\n",
        "        dot.save_state()\n",
        "        dot.fade(1)\n",
        "        dot.center()\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"Wait...what would \\\\\\\\ positive and negative \\\\\\\\ be in 2d?\",\n",
        "        )\n",
        "        # question.set_color_by_tex_to_color_map({\n",
        "        #     \"+\" : \"green\", \n",
        "        #     \"textminus\" : \"red\"\n",
        "        # })\n",
        "\n",
        "\n",
        "        self.student_says(\n",
        "            question,\n",
        "            target_mode = \"sassy\",\n",
        "            index = 2,\n",
        "            added_anims = [\n",
        "                self.teacher.change, \"plain\",\n",
        "            ],\n",
        "            bubble_config = {\"direction\" : LEFT},\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(plane, run_time = 1),\n",
        "            self.students[0].change, \"confused\",\n",
        "            self.students[1].change, \"confused\",\n",
        "        )\n",
        "        self.play(dot.restore)\n",
        "        for coords in (-1, 1), (1, -1), (0, -2), (-2, 1):\n",
        "            self.wait(0.5)\n",
        "            self.play(dot.move_to, plane.coords_to_point(*coords))\n",
        "        self.wait()\n",
        "\n",
        "class HypothesisAboutFullyColoredBoundary(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda z : z**3),\n",
        "    }\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "        square = Square(side_length = 4)\n",
        "        square.color_using_background_image(self.background_image_file)\n",
        "        hypothesis = OldTexText(\n",
        "           \"Working Hypothesis: \\\\\\\\\",\n",
        "           \"If a 2d function hits outputs of all possible colors \\\\\\\\\" + \n",
        "           \"on the boundary of a 2d region,\", \n",
        "           \"that region \\\\\\\\ contains a zero.\",\n",
        "           alignment = \"\",\n",
        "        )\n",
        "        hypothesis[0].next_to(hypothesis[1:], UP)\n",
        "        hypothesis[0].set_color(YELLOW)\n",
        "        s = hypothesis[1].get_tex()\n",
        "        s = [c for c in s if c not in string.whitespace]\n",
        "        n = s.index(\"colors\")\n",
        "        hypothesis[1][n:n+len(\"colors\")].set_color_by_gradient(\n",
        "            # RED, GOLD_E, YELLOW, GREEN, BLUE, PINK,\n",
        "            BLUE, PINK, YELLOW,\n",
        "        )\n",
        "        hypothesis.to_edge(UP)\n",
        "        square.next_to(hypothesis, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(hypothesis[0])\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, hypothesis[1]),\n",
        "            ShowCreation(square, run_time = 8)\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, hypothesis[2]))\n",
        "        self.play(square.set_fill, {\"opacity\" : 1}, run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "class PiCreatureAsksWhatWentWrong(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.set_color(YELLOW_E)\n",
        "        randy.flip()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        question = OldTexText(\"What went wrong?\")\n",
        "        question.next_to(randy, UP)\n",
        "        question.shift_onto_screen()\n",
        "        question.save_state()\n",
        "        question.shift(DOWN).fade(1)\n",
        "\n",
        "        self.play(randy.change, \"erm\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(ORIGIN)),\n",
        "            question.restore,\n",
        "            randy.change, \"confused\",\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "class ForeverNarrowingLoop(InputOutputScene):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (1, 1),\n",
        "        \"input_plane_corner\" : UP+RIGHT,\n",
        "        \"shrink_time\" : 20,\n",
        "        \"circle_start_radius\" : 2.25,\n",
        "        \"start_around_target\" : False,\n",
        "\n",
        "        # Added as a flag to not mess up one clip already used and fine-timed\n",
        "        # but to make it more convenient to do the other TinyLoop edits\n",
        "        \"add_convenient_waits\" : False\n",
        "    }\n",
        "    def construct(self):\n",
        "        input_coloring, output_coloring = colorings = VGroup(*self.get_colorings())\n",
        "        input_plane, output_plane = planes = VGroup(*self.get_planes())\n",
        "        for plane in planes:\n",
        "            plane.white_parts.set_color(BLACK)\n",
        "            plane.lines_to_fade.set_stroke(width = 0)\n",
        "\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        v_line.set_stroke(WHITE, 5)\n",
        "\n",
        "        self.add(colorings, v_line, planes)\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ApplyMethod(coloring.set_fill, {\"opacity\" : 0.2})\n",
        "                for coloring in colorings\n",
        "            ],\n",
        "            [\n",
        "                ApplyMethod(plane.white_parts.set_color, WHITE)\n",
        "                for plane in planes\n",
        "            ]\n",
        "        ), run_time = 2)\n",
        "\n",
        "        # circle\n",
        "        circle = Circle(color = WHITE, radius = self.circle_start_radius)\n",
        "        circle.flip(axis = RIGHT)\n",
        "        circle.insert_n_curves(50)\n",
        "        if self.start_around_target:\n",
        "            circle.move_to(input_plane.coords_to_point(*self.target_coords))\n",
        "        else:\n",
        "            circle.next_to(\n",
        "                input_coloring.get_corner(self.input_plane_corner), \n",
        "                -self.input_plane_corner, \n",
        "                SMALL_BUFF\n",
        "            )\n",
        "        circle.set_stroke(width = 5)\n",
        "        circle_image = circle.copy()\n",
        "        circle.match_background_image_file(input_coloring)\n",
        "        circle_image.match_background_image_file(output_coloring)\n",
        "\n",
        "        def update_circle_image(circle_image):\n",
        "            circle_image.set_points(circle.get_points())\n",
        "            circle_image.apply_function(self.point_function)\n",
        "            circle_image.make_smooth()\n",
        "\n",
        "        circle_image_update_anim = UpdateFromFunc(\n",
        "            circle_image, update_circle_image\n",
        "        )\n",
        "\n",
        "        def optional_wait():\n",
        "            if self.add_convenient_waits:\n",
        "                self.wait()\n",
        "\n",
        "        optional_wait()\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            ShowCreation(circle_image),\n",
        "            run_time = 3,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        optional_wait()\n",
        "        self.play(\n",
        "            circle.scale, 0,\n",
        "            circle.move_to, input_plane.coords_to_point(*self.target_coords),\n",
        "            circle_image_update_anim,\n",
        "            run_time = self.shrink_time,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "\n",
        "class AltForeverNarrowingLoop(ForeverNarrowingLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (-2, -1),\n",
        "        \"input_plane_corner\" : DOWN+LEFT,\n",
        "        \"shrink_time\" : 3,\n",
        "    }\n",
        "\n",
        "class TinyLoop(ForeverNarrowingLoop):\n",
        "    CONFIG = {\n",
        "        \"circle_start_radius\" : 0.5,\n",
        "        \"start_around_target\" : True,\n",
        "        \"shrink_time\" : 1,\n",
        "        \"add_convenient_waits\" : True,\n",
        "    }\n",
        "\n",
        "class TinyLoopAroundZero(TinyLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (1, 1),\n",
        "    }\n",
        "\n",
        "class TinyLoopAroundBlue(TinyLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (2.4, 0),\n",
        "    }\n",
        "\n",
        "class TinyLoopAroundYellow(TinyLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (0, -1.3),\n",
        "    }\n",
        "\n",
        "class TinyLoopAroundOrange(TinyLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (0, -0.5),\n",
        "    }\n",
        "\n",
        "class TinyLoopAroundRed(TinyLoop):\n",
        "    CONFIG = {\n",
        "        \"target_coords\" : (-1, 1),\n",
        "    }\n",
        "\n",
        "class ConfusedPiCreature(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.set_color(YELLOW_E)\n",
        "        morty.flip()\n",
        "        morty.center()\n",
        "\n",
        "        self.play(morty.change, \"awe\", DOWN+3*RIGHT)\n",
        "        self.wait(2)\n",
        "        self.play(morty.change, \"confused\")\n",
        "        self.wait(2)\n",
        "        self.play(morty.change, \"pondering\")\n",
        "        self.wait(2)\n",
        "\n",
        "class FailureOfComposition(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda p : (\n",
        "            np.cos(TAU*p[1]/3.5), \n",
        "            np.sin(TAU*p[1]/3.5)\n",
        "        )\n",
        "    }\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        big_square = Square(side_length = 4)\n",
        "        big_square.move_to(ORIGIN, RIGHT)\n",
        "        small_squares = VGroup(*[\n",
        "            Square(side_length = 2) for x in range(2)\n",
        "        ])\n",
        "        small_squares.match_width(big_square, stretch = True)\n",
        "        small_squares.arrange(DOWN, buff = 0)\n",
        "        small_squares.move_to(big_square)\n",
        "        small_squares.space_out_submobjects(1.1)\n",
        "        all_squares = VGroup(big_square, *small_squares)\n",
        "        all_squares.set_stroke(width = 6)\n",
        "\n",
        "        for square in all_squares:\n",
        "            square.set_color(WHITE)\n",
        "            square.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        question = OldTexText(\"Does my border go through every color?\")\n",
        "        question.to_edge(UP)\n",
        "        no_answers = VGroup()\n",
        "        yes_answers = VGroup()\n",
        "        for square in all_squares:\n",
        "            if square is big_square:\n",
        "                square.answer = OldTexText(\"Yes\")\n",
        "                square.answer.set_color(GREEN)\n",
        "                yes_answers.add(square.answer)\n",
        "            else:\n",
        "                square.answer = OldTexText(\"No\")\n",
        "                square.answer.set_color(RED)\n",
        "                no_answers.add(square.answer)\n",
        "            square.answer.move_to(square)\n",
        "\n",
        "        no_answers_in_equation = no_answers.copy()\n",
        "        yes_answers_in_equation = yes_answers.copy()\n",
        "        plus, equals = plus_equals = OldTex(\"+=\")\n",
        "        equation = VGroup(\n",
        "            no_answers_in_equation[0], plus,\n",
        "            no_answers_in_equation[1], equals,\n",
        "            yes_answers_in_equation\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        equation.next_to(big_square, RIGHT, MED_LARGE_BUFF)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(equals, UP)\n",
        "\n",
        "\n",
        "        self.add(question)\n",
        "        self.play(LaggedStartMap(ShowCreation, small_squares, lag_ratio = 0.8))\n",
        "        self.play(LaggedStartMap(Write, no_answers))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            small_squares.arrange, DOWN, {\"buff\" : 0},\n",
        "            small_squares.move_to, big_square,\n",
        "            no_answers.space_out_submobjects, 0.9,\n",
        "        )\n",
        "        self.add(big_square)\n",
        "        no_answers_copy = no_answers.copy()\n",
        "        small_squares.save_state()\n",
        "        self.play(\n",
        "            Transform(no_answers, no_answers_in_equation),\n",
        "            Write(plus_equals),\n",
        "            small_squares.set_stroke, {\"width\" : 0},\n",
        "        )\n",
        "        self.play(\n",
        "            Write(yes_answers),\n",
        "            Write(yes_answers_in_equation),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, q_marks, run_time = 1, lag_ratio = 0.8))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            small_squares.restore,\n",
        "            FadeOut(yes_answers),\n",
        "            FadeIn(no_answers_copy),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            small_squares.set_stroke, {\"width\" : 0},\n",
        "            FadeOut(no_answers_copy),\n",
        "            FadeIn(yes_answers),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # We can find a better notion of what we want\n",
        "\n",
        "        cross = Cross(question)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(cross, run_time = 2),\n",
        "            FadeOut(equation),\n",
        "            FadeOut(no_answers),\n",
        "            FadeOut(q_marks),\n",
        "            FadeOut(yes_answers),\n",
        "        )\n",
        "\n",
        "        x, plus, y = x_plus_y = OldTex(\"x+y\")\n",
        "        x_plus_y.move_to(big_square)\n",
        "        x_plus_y.save_state()\n",
        "        x.move_to(no_answers_copy[0])\n",
        "        y.move_to(no_answers_copy[1])\n",
        "        plus.fade(1)\n",
        "\n",
        "        for square, char in zip(small_squares, [x, y]):\n",
        "            ghost = square.copy()\n",
        "            ghost.set_stroke(width = 5)\n",
        "            ghost.background_image_file = None\n",
        "            self.play(\n",
        "                small_squares.restore,\n",
        "                ShowPassingFlash(ghost),\n",
        "                Write(char)\n",
        "            )\n",
        "        self.wait()\n",
        "        ghost = big_square.copy()\n",
        "        ghost.background_image_file = None\n",
        "        self.play(\n",
        "            small_squares.set_stroke, {\"width\" : 0},\n",
        "            x_plus_y.restore,\n",
        "        )\n",
        "        self.play(ShowPassingFlash(ghost))\n",
        "        self.wait()\n",
        "\n",
        "class PathContainingZero(InputOutputScene, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\" : {\n",
        "            \"flip_at_start\" : False,\n",
        "            \"height\" : 1.5,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\" : DOWN+LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_planes()\n",
        "        self.draw_path_hitting_zero()\n",
        "        self.comment_on_zero()\n",
        "\n",
        "    def setup_planes(self):\n",
        "        colorings = VGroup(*self.get_colorings())\n",
        "        self.input_coloring, self.output_coloring = colorings\n",
        "        colorings.set_fill(opacity = 0.3)\n",
        "\n",
        "        planes = VGroup(*self.get_planes())\n",
        "        self.input_plane, self.output_plane = planes\n",
        "        for plane in planes:\n",
        "            # plane.white_parts.set_color(BLACK)\n",
        "            plane.lines_to_fade.set_stroke(width = 0)\n",
        "\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        v_line.set_stroke(WHITE, 5)\n",
        "\n",
        "        self.add(colorings, planes)\n",
        "        self.add(v_line)\n",
        "\n",
        "    def draw_path_hitting_zero(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        path = self.path = VMobject(\n",
        "            stroke_width = 5,\n",
        "            stroke_color = WHITE,\n",
        "            fill_opacity = 0,\n",
        "        )\n",
        "        path.match_background_image_file(self.input_coloring)\n",
        "        path.set_points_smoothly(list(it.starmap(\n",
        "            self.input_plane.coords_to_point, \n",
        "            [(1, 2.5), (2.5, 2.5), (2, 0.5), (1, 1), (0.5, 1), (0.5, 2), (1, 2.5)]\n",
        "        )))\n",
        "\n",
        "        out_path = self.out_path = path.copy()\n",
        "        out_path.apply_function(self.point_function)\n",
        "        out_path.match_background_image_file(self.output_coloring)\n",
        "        out_path.make_smooth()\n",
        "\n",
        "        self.play(\n",
        "            Flash(\n",
        "                VectorizedPoint(self.output_plane.coords_to_point(0, 0)),\n",
        "                color = WHITE,\n",
        "                flash_radius = 0.3,\n",
        "                line_length = 0.2,\n",
        "                num_lines = 13,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 0.6),\n",
        "            ),\n",
        "            morty.change, \"pondering\",\n",
        "            *[\n",
        "                ShowCreation(mob, rate_func = bezier([0, 0, 1, 1]))\n",
        "                for mob in (path, out_path)\n",
        "            ],\n",
        "            run_time = 5\n",
        "        )\n",
        "\n",
        "    def comment_on_zero(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Output is zero \\\\\\\\\",\n",
        "            \"which has no direction\"\n",
        "        )\n",
        "        origin = self.output_plane.coords_to_point(0, 0)\n",
        "        words.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        background_rect = BackgroundRectangle(\n",
        "            words, buff = SMALL_BUFF,\n",
        "            opacity = 1.0\n",
        "        )\n",
        "        background_rect.stretch_to_fit_width(0.1)\n",
        "\n",
        "        arrow = Arrow(words.get_top(), origin)\n",
        "\n",
        "        circles = VGroup()\n",
        "        for point in self.input_plane.coords_to_point(1, 1), origin:\n",
        "            circle = Circle(color = BLACK, radius = 0.5, stroke_width = 0)\n",
        "            circle.move_to(point)\n",
        "            circle.generate_target()\n",
        "            circle.target.scale(0)\n",
        "            circle.target.set_stroke(width = 4)\n",
        "            circles.add(circle)\n",
        "        in_circle, out_circle = circles\n",
        "\n",
        "        new_words = OldTexText(\n",
        "            \"But we want $\\\\vec{\\\\textbf{x}}$ \\\\\\\\\",\n",
        "            \"where $f(\\\\vec{\\\\textbf{x}}) = 0$\",\n",
        "        )\n",
        "        new_words.move_to(words)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(background_rect),\n",
        "            Write(words[0]),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words[1]),\n",
        "            morty.change, \"pleading\",\n",
        "            MoveToTarget(out_circle, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(words))\n",
        "        self.play(\n",
        "            FadeIn(new_words),\n",
        "            morty.change, \"happy\"\n",
        "        )\n",
        "        self.play(MoveToTarget(in_circle, run_time = 2))\n",
        "        self.play(morty.change, \"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "class TransitionFromPathsToBoundaries(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-2, 0, 2), (2, 0, 1)\n",
        "        ),\n",
        "        \"dot_fill_opacity\" : 1,\n",
        "        \"dot_stroke_width\" : 1,\n",
        "        \"include_walkers\" : True,\n",
        "        \"include_question_mark\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        #Setup paths\n",
        "        squares, joint_rect = self.get_squares_and_joint_rect()\n",
        "        left_square, right_square = squares\n",
        "\n",
        "        path1, path2 = paths = VGroup(*[\n",
        "            Line(square.get_corner(UP+LEFT), square.get_corner(UP+RIGHT))\n",
        "            for square in squares\n",
        "        ])\n",
        "        joint_path = Line(path1.get_start(), path2.get_end())\n",
        "\n",
        "        for mob in it.chain(paths, [joint_path]):\n",
        "            mob.set_stroke(WHITE, 4)\n",
        "            mob.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        dot = self.get_dot_and_add_continual_animations()\n",
        "\n",
        "        #Setup path braces\n",
        "        for mob, tex in (path1, \"x\"), (path2, \"y\"), (joint_path, \"x+y\"):\n",
        "            mob.brace = Brace(mob, DOWN)\n",
        "            label = OldTexText(\"Winding =\", \"$%s$\"%tex)\n",
        "            label.next_to(mob.brace, DOWN)\n",
        "            mob.brace.add(label)\n",
        "\n",
        "        #Setup region labels\n",
        "\n",
        "        sum_tex = \"x+y\"\n",
        "        if self.include_question_mark:\n",
        "            sum_tex += \"\\\\, ?\"\n",
        "        for square, tex in (left_square, \"x\"), (right_square, \"y\"), (joint_rect, sum_tex):\n",
        "            square.label = OldTexText(\"Winding = \", \"$%s$\"%tex)\n",
        "            square.label.move_to(square)\n",
        "\n",
        "        #Add paths\n",
        "        self.position_dot(path1.get_start())\n",
        "        for path in path1, path2:\n",
        "            self.position_dot(path.get_start())\n",
        "            self.play(\n",
        "                MoveAlongPath(dot, path.copy()),\n",
        "                ShowCreation(path),\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.play(GrowFromCenter(path.brace))\n",
        "        self.wait()\n",
        "        self.position_dot(joint_path.get_start())\n",
        "        self.play(\n",
        "            MoveAlongPath(dot, joint_path, run_time = 3),\n",
        "            FadeOut(VGroup(path1.brace, path2.brace)),\n",
        "            FadeIn(joint_path.brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Add regions\n",
        "        self.play(\n",
        "            FadeOut(paths),\n",
        "            FadeOut(joint_path.brace), \n",
        "            dot.move_to, path1.get_start()\n",
        "        )\n",
        "        for square in squares:\n",
        "            self.position_dot(square.get_points()[0])\n",
        "            kwargs = {\n",
        "                \"run_time\" : 4,\n",
        "                \"rate_func\" : bezier([0, 0, 1, 1]),\n",
        "            }\n",
        "            self.play(\n",
        "                MoveAlongPath(dot, square.copy(), **kwargs),\n",
        "                ShowCreation(square, **kwargs),\n",
        "                Write(square.label, run_time = 2),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            dot.move_to, joint_rect.get_points()[0],\n",
        "            FadeOut(squares),\n",
        "            FadeIn(joint_rect),\n",
        "        )\n",
        "        self.position_dot(joint_rect.get_points()[0])\n",
        "        self.play(\n",
        "            Transform(left_square.label[0], joint_rect.label[0]),\n",
        "            Transform(\n",
        "                left_square.label[1], joint_rect.label[1][0],\n",
        "                path_arc = TAU/6\n",
        "            ),\n",
        "            FadeIn(joint_rect.label[1][1]),\n",
        "            FadeIn(joint_rect.label[1][3:]),\n",
        "            FadeOut(right_square.label[0]),\n",
        "            Transform(\n",
        "                right_square.label[1], joint_rect.label[1][2],\n",
        "                path_arc = TAU/6\n",
        "            ),\n",
        "            MoveAlongPath(\n",
        "                dot, joint_rect,\n",
        "                run_time = 6,\n",
        "                rate_func = bezier([0, 0, 1, 1])\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_squares_and_joint_rect(self):\n",
        "        squares = VGroup(*[\n",
        "            Square(side_length = 4).next_to(ORIGIN, vect, buff = 0)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        joint_rect = SurroundingRectangle(squares, buff = 0)\n",
        "        for mob in it.chain(squares, [joint_rect]):\n",
        "            mob.set_stroke(WHITE, 4)\n",
        "            mob.color_using_background_image(self.background_image_file)\n",
        "        return squares, joint_rect\n",
        "\n",
        "    def get_dot_and_add_continual_animations(self):\n",
        "        #Define important functions for updates\n",
        "        get_output = lambda : self.func(tuple(dot.get_center()[:2]))\n",
        "        get_output_color = lambda : rgba_to_color(point_to_rgba(get_output()))\n",
        "        get_output_rev = lambda : -point_to_rev(get_output())\n",
        "        self.get_output_rev = get_output_rev\n",
        "\n",
        "        self.start_rev = 0\n",
        "        self.curr_winding = 0\n",
        "        def get_total_winding(dt = 0):\n",
        "            rev = (get_output_rev() - self.start_rev)%1\n",
        "            possible_windings = [\n",
        "                np.floor(self.curr_winding)+k+rev\n",
        "                for k in (-1, 0, 1)\n",
        "            ]\n",
        "            i = np.argmin([abs(pw - self.curr_winding) for pw in possible_windings])\n",
        "            self.curr_winding = possible_windings[i]\n",
        "            return self.curr_winding\n",
        "\n",
        "\n",
        "        #Setup dot, arrow and label\n",
        "        dot = self.dot = Dot(radius = 0.1)\n",
        "        dot.set_stroke(WHITE, self.dot_stroke_width)\n",
        "        update_dot_color = Mobject.add_updater(\n",
        "            dot, lambda d : d.set_fill(\n",
        "                get_output_color(),\n",
        "                self.dot_fill_opacity\n",
        "            )\n",
        "        )\n",
        "\n",
        "        label = DecimalNumber(0, num_decimal_places = 1)\n",
        "        label_upadte = ContinualChangingDecimal(\n",
        "            label, get_total_winding,\n",
        "            position_update_func = lambda l : l.next_to(dot, UP+LEFT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        arrow_length = 0.75\n",
        "        arrow = Vector(arrow_length*RIGHT)\n",
        "        arrow.set_stroke(WHITE, self.dot_stroke_width)\n",
        "        def arrow_update_func(arrow):\n",
        "            arrow.set_fill(get_output_color(), 1)\n",
        "            arrow.rotate(-TAU*get_output_rev() - arrow.get_angle())\n",
        "            arrow.scale(arrow_length/arrow.get_length())\n",
        "            arrow.shift(dot.get_center() - arrow.get_start())\n",
        "            return arrow\n",
        "        update_arrow = Mobject.add_updater(arrow, arrow_update_func)\n",
        "\n",
        "        if self.include_walkers:\n",
        "            self.add(update_arrow, update_dot_color, label_upadte)\n",
        "        return dot\n",
        "\n",
        "    def position_dot(self, point):\n",
        "        self.dot.move_to(point)\n",
        "        self.start_rev = self.get_output_rev()\n",
        "        self.curr_winding = 0\n",
        "\n",
        "class TransitionFromPathsToBoundariesArrowless(TransitionFromPathsToBoundaries):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-2, 0, 2), (2, 0, 1)\n",
        "        ),\n",
        "        \"dot_fill_opacity\" : 0,\n",
        "        \"dot_stroke_width\" : 0,\n",
        "        \"include_walkers\" : False,\n",
        "        \"include_question_mark\" : False,\n",
        "    }\n",
        "\n",
        "class BreakDownLoopWithNonzeroWinding(TransitionFromPathsToBoundaries):\n",
        "    def construct(self):\n",
        "        TransitionFromPathsToBoundaries.construct(self)\n",
        "        zero_point = 2*LEFT\n",
        "\n",
        "        squares, joint_rect = self.get_squares_and_joint_rect()\n",
        "        left_square, right_square = squares\n",
        "        VGroup(squares, joint_rect).shift(MED_LARGE_BUFF*DOWN)\n",
        "\n",
        "        dot = self.get_dot_and_add_continual_animations()\n",
        "\n",
        "        for rect, tex in (left_square, \"x\"), (right_square, \"y\"), (joint_rect, \"3\"):\n",
        "            rect.label = OldTexText(\"Winding = \", \"$%s$\"%tex)\n",
        "            rect.label.move_to(rect)\n",
        "        sum_label = OldTex(\"x\", \"+\", \"y\", \"=\", \"3\")\n",
        "        x, plus, y, equals, three = sum_label\n",
        "        sum_label.next_to(joint_rect, UP)\n",
        "\n",
        "        both_cannot_be_zero = OldTexText(\"These cannot both be 0\")\n",
        "        both_cannot_be_zero.move_to(plus)\n",
        "        both_cannot_be_zero.to_edge(UP)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(both_cannot_be_zero.get_bottom(), var.get_top(), buff = SMALL_BUFF)\n",
        "            for var in (x, y)\n",
        "        ])\n",
        "\n",
        "        self.position_dot(joint_rect.get_points()[0])\n",
        "        self.add(joint_rect)\n",
        "        self.play(\n",
        "            MoveAlongPath(dot, joint_rect, rate_func = bezier([0, 0, 1, 1])),\n",
        "            Write(joint_rect.label, rate_func = squish_rate_func(smooth, 0.7, 1)),\n",
        "            run_time = 4\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(joint_rect.label, left_square.label),\n",
        "            ReplacementTransform(joint_rect.label.copy(), right_square.label),\n",
        "            ReplacementTransform(joint_rect.label[1].copy(), three),\n",
        "            FadeIn(left_square),\n",
        "            FadeIn(right_square),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(left_square.label[1].copy(), x),\n",
        "            ReplacementTransform(right_square.label[1].copy(), y),\n",
        "            FadeIn(plus),\n",
        "            FadeIn(equals),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(both_cannot_be_zero),\n",
        "            *list(map(GrowArrow, arrows))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class BackToEquationSolving(AltTeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Back to solving \\\\\\\\ equations\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look_at, self.screen)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "class MonomialTerm(PathContainingZero):\n",
        "    CONFIG = {\n",
        "        \"non_renormalized_func\" : plane_func_from_complex_func(lambda z : z**5),\n",
        "        \"full_func_label\" : \"f(x) = x^5\",\n",
        "        \"func_label\" : \"x^5\",\n",
        "        \"loop_radius\" : 1.1,\n",
        "        \"label_buff\" : 0.3,\n",
        "        \"label_move_to_corner\" : ORIGIN,\n",
        "        \"should_end_with_rescaling\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_planes()\n",
        "        self.relabel_planes()\n",
        "        self.add_function_label()\n",
        "        self.show_winding()\n",
        "        if self.should_end_with_rescaling:\n",
        "            self.rescale_output_plane()\n",
        "\n",
        "    def relabel_planes(self):\n",
        "        for plane in self.input_plane, self.output_plane:\n",
        "            for mob in plane:\n",
        "                if isinstance(mob, Tex):\n",
        "                    plane.remove(mob)\n",
        "\n",
        "            if hasattr(plane, \"numbers_to_show\"):\n",
        "                _range = plane.numbers_to_show\n",
        "            else:\n",
        "                _range = list(range(-2, 3))\n",
        "            for x in _range:\n",
        "                if x == 0:\n",
        "                    continue\n",
        "                label = OldTex(str(x))\n",
        "                label.scale(0.5)\n",
        "                point = plane.coords_to_point(x, 0)\n",
        "                label.next_to(point, DOWN, MED_SMALL_BUFF)\n",
        "                plane.add(label)\n",
        "                self.add_foreground_mobject(label)\n",
        "                tick = Line(SMALL_BUFF*DOWN, SMALL_BUFF*UP)\n",
        "                tick.move_to(point)\n",
        "                plane.add(tick)\n",
        "            for y in _range:\n",
        "                if y == 0:\n",
        "                    continue\n",
        "                label = OldTex(\"%di\"%y)\n",
        "                label.scale(0.5)\n",
        "                point = plane.coords_to_point(0, y)\n",
        "                label.next_to(point, LEFT, MED_SMALL_BUFF)\n",
        "                plane.add(label)\n",
        "                self.add_foreground_mobject(label)\n",
        "                tick = Line(SMALL_BUFF*LEFT, SMALL_BUFF*RIGHT)\n",
        "                tick.move_to(point)\n",
        "                plane.add(tick)\n",
        "        self.add(self.input_plane, self.output_plane)\n",
        "\n",
        "    def add_function_label(self):\n",
        "        label = OldTex(self.full_func_label)\n",
        "        label.add_background_rectangle(opacity = 1, buff = SMALL_BUFF)\n",
        "        arrow = Arrow(\n",
        "            2*LEFT, 2*RIGHT, path_arc = -TAU/3,\n",
        "        )\n",
        "        arrow.pointwise_become_partial(arrow, 0, 0.95)\n",
        "        label.next_to(arrow, UP)\n",
        "        VGroup(arrow, label).to_edge(UP)\n",
        "        self.add(label, arrow)\n",
        "\n",
        "    def show_winding(self):\n",
        "        loop = Arc(color = WHITE, angle = 1.02*TAU, num_anchors = 42)\n",
        "        loop.scale(self.loop_radius)\n",
        "        loop.match_background_image_file(self.input_coloring)\n",
        "        loop.move_to(self.input_plane.coords_to_point(0, 0))\n",
        "\n",
        "        out_loop = loop.copy()\n",
        "        out_loop.apply_function(self.point_function)\n",
        "        out_loop.match_background_image_file(self.output_coloring)\n",
        "\n",
        "        get_in_point = lambda : loop.get_points()[-1]\n",
        "        get_out_point = lambda : out_loop.get_points()[-1]\n",
        "        in_origin = self.input_plane.coords_to_point(0, 0)\n",
        "        out_origin = self.output_plane.coords_to_point(0, 0)\n",
        "\n",
        "        dot = Dot()\n",
        "        update_dot = UpdateFromFunc(dot, lambda d : d.move_to(get_in_point()))\n",
        "\n",
        "        out_dot = Dot()\n",
        "        update_out_dot = UpdateFromFunc(out_dot, lambda d : d.move_to(get_out_point()))\n",
        "\n",
        "        buff = self.label_buff\n",
        "        def generate_label_update(label, point_func, origin):\n",
        "            return UpdateFromFunc(\n",
        "                label, lambda m : m.move_to(\n",
        "                    (1+buff)*point_func() - buff*origin,\n",
        "                    self.label_move_to_corner\n",
        "                )\n",
        "            )\n",
        "        x = OldTex(\"x\")\n",
        "        fx = OldTex(self.func_label)\n",
        "        update_x = generate_label_update(x, get_in_point, in_origin)\n",
        "        update_fx = generate_label_update(fx, get_out_point, out_origin)\n",
        "\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        kwargs = {\n",
        "            \"run_time\" : 15,\n",
        "            \"rate_func\" : None,\n",
        "        }\n",
        "        self.play(\n",
        "            ShowCreation(loop, **kwargs),\n",
        "            ShowCreation(out_loop, **kwargs),\n",
        "            update_dot,\n",
        "            update_out_dot,\n",
        "            update_x,\n",
        "            update_fx,\n",
        "            ApplyMethod(morty.change, \"pondering\", out_dot),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(VGroup(dot, out_dot, x, fx))\n",
        "        )\n",
        "        self.loop = loop\n",
        "        self.out_loop = out_loop\n",
        "\n",
        "    def rescale_output_plane(self):\n",
        "        output_stuff = VGroup(self.output_plane, self.output_coloring)\n",
        "        self.play(*list(map(FadeOut, [self.loop, self.out_loop])))\n",
        "        self.play(\n",
        "            output_stuff.scale, 3.0/50, run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def func(self, coords):\n",
        "        return self.non_renormalized_func(coords)\n",
        "\n",
        "class PolynomialTerms(MonomialTerm):\n",
        "    CONFIG = {\n",
        "        \"non_renormalized_func\" : plane_func_from_complex_func(lambda z : z**5 - z - 1),\n",
        "        \"full_func_label\" : \"f(x) = x^5 - x - 1\",\n",
        "        \"func_label\" : \"x^5 + \\\\cdots\",\n",
        "        \"loop_radius\" : 2.0,\n",
        "        \"label_buff\" : 0.15,\n",
        "        \"label_move_to_corner\" : DOWN+LEFT,\n",
        "        \"should_end_with_rescaling\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.pi_creature.change(\"pondering\", VectorizedPoint(ORIGIN))\n",
        "        MonomialTerm.construct(self)\n",
        "        self.cinch_loop()\n",
        "        # self.sweep_through_loop_interior()\n",
        "\n",
        "    def relabel_planes(self):\n",
        "        self.output_plane.x_radius = 50\n",
        "        self.output_plane.y_radius = 50\n",
        "        self.output_plane.numbers_to_show = list(range(-45, 50, 15))\n",
        "        MonomialTerm.relabel_planes(self)\n",
        "\n",
        "    def sweep_through_loop_interior(self):\n",
        "        loop = self.loop\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        line, line_target = [\n",
        "            Line(\n",
        "                loop.get_left(), loop.get_right(),\n",
        "                path_arc = u*TAU/2,\n",
        "                n_arc_anchors = 40,\n",
        "                background_image_file = self.input_coloring.background_image_file ,\n",
        "                stroke_width = 4,\n",
        "            )\n",
        "            for u in (-1, 1)\n",
        "        ]\n",
        "        out_line = line.copy()\n",
        "        update_out_line = UpdateFromFunc(\n",
        "            out_line, \n",
        "            lambda m : m.set_points(line.get_points()).apply_function(self.point_function),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                line, line_target,\n",
        "                run_time = 10,\n",
        "                rate_func = there_and_back\n",
        "            ),\n",
        "            update_out_line,\n",
        "            morty.change, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def cinch_loop(self):\n",
        "        loop = self.loop\n",
        "        out_loop = self.out_loop\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        update_out_loop = UpdateFromFunc(\n",
        "            out_loop,\n",
        "            lambda m : m.set_points(loop.get_points()).apply_function(self.point_function)\n",
        "        )\n",
        "\n",
        "        self.add(\n",
        "            loop.copy().set_stroke(width = 1),\n",
        "            out_loop.copy().set_stroke(width = 1),\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                loop.scale, 0, {\"about_point\" : self.input_plane.coords_to_point(0.2, 1)},\n",
        "                run_time = 12,\n",
        "                rate_func = bezier([0, 0, 1, 1])\n",
        "            ),\n",
        "            update_out_loop,\n",
        "            morty.change, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SearchSpacePerimeterVsArea(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"num_iterations\" : 15,\n",
        "        \"display_in_parallel\" : False,\n",
        "        \"use_fancy_lines\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        EquationSolver2d.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        all_parts = VGroup(*self.get_mobjects())\n",
        "        path_parts = VGroup()\n",
        "        non_path_parts = VGroup()\n",
        "        for part in all_parts:\n",
        "            if part.get_background_image_file() is not None:\n",
        "                path_parts.add(part)\n",
        "            else:\n",
        "                non_path_parts.add(part)\n",
        "        path_parts.save_state()\n",
        "        path_parts.generate_target()\n",
        "        for path_target in path_parts.target:\n",
        "            if isinstance(path_target, Line):\n",
        "                path_target.rotate(-path_target.get_angle())\n",
        "        path_parts.target.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        alt_path_parts = path_parts.copy()\n",
        "        size = lambda m : m.get_height() + m.get_width()\n",
        "        alt_path_parts.submobjects.sort(\n",
        "            key=lambda m1: -size(m1)\n",
        "        )\n",
        "\n",
        "        full_rect = SurroundingRectangle(\n",
        "            path_parts,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "            background_image_file = path_parts[0].background_image_file\n",
        "        )\n",
        "        full_rect.save_state()\n",
        "        full_rect.stretch(0, 1, about_edge = UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(non_path_parts),\n",
        "            path_parts.set_stroke, {\"width\" : 1},\n",
        "        )\n",
        "        self.remove(all_parts)\n",
        "        for x in range(2):\n",
        "            alt_path_parts.save_state()\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, alt_path_parts,\n",
        "                rate_func = there_and_back,\n",
        "                lag_ratio = 0.3,\n",
        "                run_time = 3,\n",
        "                remover = True\n",
        "            ))\n",
        "            alt_path_parts.restore()\n",
        "        self.play(\n",
        "            full_rect.restore,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(full_rect))\n",
        "        self.wait()\n",
        "\n",
        "class ShowPolynomialFinalState(SolveX5MinusXMinus1):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        SolveX5MinusXMinus1.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "class PiCreatureInAwe(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "\n",
        "\n",
        "        self.play(randy.change, \"awe\")\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look, UP, run_time = 2)\n",
        "        self.play(\n",
        "            randy.look, RIGHT, \n",
        "            run_time = 4, \n",
        "            rate_func = there_and_back,\n",
        "            path_arc = -TAU/4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ShowComplexFunction(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane()\n",
        "        plane.add_coordinates()\n",
        "        four_i = plane.coordinate_labels[-1]\n",
        "        plane.coordinate_labels.remove(four_i)\n",
        "        plane.remove(four_i)\n",
        "\n",
        "        title = OldTexText(\"Complex Plane\")\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        rect = BackgroundRectangle(title, fill_opacity = 1, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        x = complex(1, 0.4)\n",
        "        f = lambda x : x**5 - x - 1\n",
        "\n",
        "        x_point = plane.number_to_point(x)\n",
        "        fx_point = plane.number_to_point(f(x))\n",
        "\n",
        "        x_dot = Dot(x_point)\n",
        "        fx_dot = Dot(fx_point, color = YELLOW)\n",
        "        arrow = Arrow(\n",
        "            x_point, fx_point,\n",
        "            path_arc = TAU/3,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        arrow.pointwise_become_partial(arrow, 0, 0.95)\n",
        "\n",
        "        x_label = OldTex(\"x = %d+%.1fi\"%(x.real, x.imag))\n",
        "        x_label.next_to(x_dot, RIGHT)\n",
        "        x_label.add_background_rectangle()\n",
        "\n",
        "        fx_label = OldTex(\"f(x) = x^5 - x - 1\")\n",
        "        fx_label.next_to(fx_dot, DOWN, SMALL_BUFF)\n",
        "        fx_label.set_color(YELLOW)\n",
        "        fx_label.add_background_rectangle()\n",
        "        fx_label.generate_target()\n",
        "        fx_label.target.move_to(title)\n",
        "        fx_label.target[1].set_color(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            Write(plane),\n",
        "            FadeIn(rect),\n",
        "            LaggedStartMap(FadeIn, title)\n",
        "        )\n",
        "        self.play(*list(map(FadeIn, [x_dot, x_label])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(x_dot.copy(), fx_dot, path_arc = arrow.path_arc),\n",
        "            ShowCreation(arrow, rate_func = squish_rate_func(smooth, 0.2, 1))\n",
        "        )\n",
        "        self.play(FadeIn(fx_label))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            MoveToTarget(fx_label),\n",
        "            *list(map(FadeOut, [title, x_dot, x_label, arrow, fx_dot]))\n",
        "        )\n",
        "        self.play(FadeOut(plane.coordinate_labels))\n",
        "        self.wait()\n",
        "\n",
        "class WindingNumbersInInputOutputContext(PathContainingZero):\n",
        "    CONFIG = {\n",
        "        \"in_loop_center_coords\" : (-2, -1),\n",
        "        \"run_time\" : 10,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.setup_planes()\n",
        "\n",
        "        in_loop = Circle()\n",
        "        in_loop.flip(RIGHT)\n",
        "        # in_loop = Square(side_length = 2)\n",
        "        in_loop.insert_n_curves(100)\n",
        "        in_loop.move_to(self.input_plane.coords_to_point(\n",
        "            *self.in_loop_center_coords\n",
        "        ))\n",
        "        in_loop.match_background_image_file(self.input_coloring)\n",
        "\n",
        "        out_loop = in_loop.copy()\n",
        "        out_loop.match_background_image_file(self.output_coloring)\n",
        "        update_out_loop = Mobject.add_updater(\n",
        "            out_loop,\n",
        "            lambda m : m.set_points(in_loop.get_points()).apply_function(self.point_function)\n",
        "        )\n",
        "        # self.add(update_out_loop)\n",
        "\n",
        "        in_dot = Dot(radius = 0.04)\n",
        "        update_in_dot = Mobject.add_updater(\n",
        "            in_dot, lambda d : d.move_to(in_loop.point_from_proportion(1))\n",
        "        )\n",
        "        self.add(update_in_dot)\n",
        "\n",
        "        out_arrow = Arrow(LEFT, RIGHT)\n",
        "        update_out_arrow = Mobject.add_updater(\n",
        "            out_arrow, \n",
        "            lambda a : a.put_start_and_end_on(\n",
        "                self.output_plane.coords_to_point(0, 0),\n",
        "                out_loop.point_from_proportion(1)\n",
        "            )\n",
        "        )\n",
        "        update_out_arrow_color = Mobject.add_updater(\n",
        "            out_arrow,\n",
        "            lambda a : a.set_color(rev_to_color(a.get_angle()/TAU))\n",
        "        )\n",
        "        self.add(update_out_arrow, update_out_arrow_color)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"How many times does \\\\\\\\ the output wind around?\"\n",
        "        )\n",
        "        label = self.output_plane.label\n",
        "        words.move_to(label, UP)\n",
        "        self.output_plane.remove(label)\n",
        "        self.add(words)\n",
        "\n",
        "        decimal = DecimalNumber(0)\n",
        "        decimal.next_to(self.output_plane.get_corner(UP+RIGHT), DOWN+LEFT)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(in_loop),\n",
        "            ShowCreation(out_loop),\n",
        "            ChangeDecimalToValue(decimal, 2),\n",
        "            Animation(in_dot),\n",
        "            run_time = self.run_time,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "\n",
        "class SolveX5SkipToEnd(SolveX5MinusXMinus1):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        SolveX5MinusXMinus1.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        mobjects = VGroup(*self.get_mobjects())\n",
        "        lines = VGroup()\n",
        "        rects = VGroup()\n",
        "        for mob in mobjects:\n",
        "            if mob.background_image_file is not None:\n",
        "                mob.set_stroke(width = 2)\n",
        "                lines.add(mob)\n",
        "            elif isinstance(mob, Polygon):\n",
        "                rects.add(mob)\n",
        "            else:\n",
        "                self.remove(mob)\n",
        "\n",
        "        self.clear()\n",
        "        self.add(lines, rects)\n",
        "\n",
        "class ZeroFoundOnBoundary(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Vector(DOWN+LEFT, color = WHITE)\n",
        "        words = OldTexText(\"Found zero on boundary!\")\n",
        "        words.next_to(arrow.get_start(), UP)\n",
        "        words.shift(1.5*RIGHT)\n",
        "\n",
        "        point = VectorizedPoint()\n",
        "        point.next_to(arrow, DOWN+LEFT)\n",
        "\n",
        "        self.play(Flash(point))\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AllOfTheVideos(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\" : {\n",
        "            \"background_opacity\" : 1,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        thumbnail_dir = os.path.join(MEDIA_DIR, \"3b1b_videos/Winding/OldThumbnails\")\n",
        "        n = 4\n",
        "        images = Group(*[\n",
        "            ImageMobject(os.path.join(thumbnail_dir, file))\n",
        "            for file in os.listdir(thumbnail_dir)[:n**2]\n",
        "        ])\n",
        "        for image in images:\n",
        "            rect = SurroundingRectangle(image, buff = 0)\n",
        "            rect.set_stroke(WHITE, 1)\n",
        "            image.add(rect)\n",
        "        images.arrange_in_grid(n, n, buff = 0)\n",
        "        images.set_height(FRAME_HEIGHT)\n",
        "        random.shuffle(images.submobjects)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, images, run_time = 4))\n",
        "        self.wait()\n",
        "\n",
        "class EndingCredits(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\n",
        "            \"Written and animated by: \\\\\\\\\",\n",
        "            \"Sridhar Ramesh \\\\\\\\\",\n",
        "            \"Grant Sanderson\"\n",
        "        )\n",
        "        text[0].shift(MED_SMALL_BUFF*UP)\n",
        "        text.to_edge(UP)\n",
        "\n",
        "        pi = PiCreature(color = YELLOW_E, height = 2)\n",
        "        pi.to_edge(DOWN)\n",
        "        pi.change_mode(\"happy\")\n",
        "        self.add(pi)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, text), pi.look_at, text)\n",
        "        self.play(pi.change, \"wave_1\", text)\n",
        "        self.play(Blink(pi))\n",
        "        self.play(pi.change, \"happy\")\n",
        "        self.wait()\n",
        "\n",
        "class MentionQAndA(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Q\\\\&A with \", \"Ben\", \"and\", \"Sridhar\\\\\\\\\", \"at\", \"Patreon\")\n",
        "        title.set_color_by_tex_to_color_map({\n",
        "            \"Ben\" : MAROON,\n",
        "            \"Sridhar\" : YELLOW,\n",
        "        })\n",
        "        patreon_logo = VGroup(*PatreonLogo().family_members_with_points())\n",
        "        patreon_logo.sort()\n",
        "        patreon_logo.replace(title.get_parts_by_tex(\"Patreon\"))\n",
        "        patreon_logo.scale(1.3, about_edge = LEFT)\n",
        "        patreon_logo.shift(0.5*SMALL_BUFF*DOWN)\n",
        "        title.submobjects[-1] = patreon_logo\n",
        "\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        questions = VGroup(*list(map(TexText, [\n",
        "            \"If you think of the current videos as short stories, \\\\\\\\ what is the novel that you want to write?\",\n",
        "            \"How did you get into mathematics?\",\n",
        "            \"What motivated you to join 3b1b?\",\n",
        "            \"$\\\\vdots$\",\n",
        "        ])))\n",
        "        questions.arrange(DOWN, buff = 0.75)\n",
        "        questions.next_to(title, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, questions, run_time = 3))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(questions))\n",
        "        self.wait()\n",
        "\n",
        "class TickingClock(Scene):\n",
        "    CONFIG = {\n",
        "        \"run_time\" : 90,\n",
        "    }\n",
        "    def construct(self):\n",
        "        clock = Clock()\n",
        "        clock.set_height(FRAME_HEIGHT - 1)\n",
        "        clock.to_edge(LEFT)\n",
        "        lines = [clock.hour_hand, clock.minute_hand]\n",
        "        def update_line(line):\n",
        "            rev = line.get_angle()/TAU\n",
        "            line.set_color(rev_to_color(rev))\n",
        "\n",
        "        for line in lines:\n",
        "            self.add(Mobject.add_updater(line, update_line))\n",
        "\n",
        "        run_time = self.run_time\n",
        "        self.play(ClockPassesTime(\n",
        "            clock, \n",
        "            run_time = run_time,\n",
        "            hours_passed = 0.1*run_time\n",
        "        ))\n",
        "\n",
        "class InfiniteListOfTopics(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(width = 5, height = 7)\n",
        "        rect.to_edge(RIGHT)\n",
        "        title = OldTexText(\"Infinite list \\\\\\\\ of topics\")\n",
        "        title.next_to(rect.get_top(), DOWN)\n",
        "        lines = VGroup(*[\n",
        "            OldTexText(words).scale(0.5)\n",
        "            for words in [\n",
        "                \"Winding number\",\n",
        "                \"Laplace transform\",\n",
        "                \"Wallis product\",\n",
        "                \"Quantum information\",\n",
        "                \"Elliptic curve cryptography\",\n",
        "                \"Strange attractors\",\n",
        "                \"Convolutional neural networks\",\n",
        "                \"Fixed points\",\n",
        "            ]\n",
        "        ] + [Tex(\"\\\\vdots\")])\n",
        "        lines.arrange(DOWN, buff = MED_SMALL_BUFF, aligned_edge = LEFT)\n",
        "        lines.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        lines[-1].next_to(lines[-2], DOWN)\n",
        "\n",
        "        self.add(rect, title)\n",
        "        self.play(LaggedStartMap(FadeIn, lines, run_time = 5))\n",
        "        self.wait()\n",
        "\n",
        "class ManyIterations(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(*[\n",
        "            OldTexText(word, alignment = \"\")\n",
        "            for word in [\n",
        "                \"Winding numbers, v1\",\n",
        "                \"Winding numbers, v2 \\\\\\\\ (center on domain coloring)\",\n",
        "                \"Winding numbers, v3 \\\\\\\\ (clarify visuals of 2d functions)\",\n",
        "                \"Winding numbers, v4 \\\\\\\\ (postpone topology examples for part 2)\",\n",
        "                \"Winding numbers, v5 \\\\\\\\ (start down wrong path)\",\n",
        "            ]\n",
        "        ])\n",
        "        words.arrange(DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT)\n",
        "        words.scale(0.75)\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        self.add(words[0])\n",
        "        for last_word, word in zip(words, words[1:]):\n",
        "            cross = Cross(last_word)\n",
        "            self.play(ShowCreation(cross))\n",
        "            self.play(FadeIn(word))\n",
        "        self.wait()\n",
        "\n",
        "class MentionFree(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\" : {\n",
        "            \"flip_at_start\" : False,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\" : DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.shift(RIGHT)\n",
        "\n",
        "        items = VGroup(\n",
        "            OldTexText(\"Movie:\", \"$>\\\\$10.00$\"),\n",
        "            OldTexText(\"College course:\", \"$>\\\\$1{,}000.00$\"),\n",
        "            OldTexText(\"YouTube video:\", \"$=\\\\$0.00$\"),\n",
        "        )\n",
        "        # items.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        items.next_to(morty, UP, LARGE_BUFF)\n",
        "        right_x = morty.get_right()[0]\n",
        "        for item in items:\n",
        "            item[1].set_color(GREEN)\n",
        "            item.shift((right_x - item[0].get_right()[0])*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(items[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(items[1]),\n",
        "            items[0].shift, UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            items[:2].shift, UP,\n",
        "            FadeInFromDown(items[2]),\n",
        "            morty.change, \"surprised\"\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            morty.change, \"raise_left_hand\", VectorizedPoint(3*LEFT)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(morty.change, \"gracious\", OUT)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"run_time\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        PatreonEndScreen.construct(self)\n",
        "        randy, morty = self.pi_creatures\n",
        "        randy.change(\"plain\")\n",
        "        morty.change(\"plain\")\n",
        "\n",
        "        for mode in \"thinking\", \"confused\", \"pondering\", \"hooray\":\n",
        "            self.play(randy.change, mode)\n",
        "            self.wait()\n",
        "            self.play(morty.change, mode)\n",
        "            self.wait(2)\n",
        "\n",
        "class Thumbnail(SearchSpacePerimeterVsArea):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 18,\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-3, -1.3, 2), (0.1, 0.2, 1), (2.8, -2, 1)\n",
        "        ),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        EquationSolver2d.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        mobjects = VGroup(*self.get_mobjects())\n",
        "        lines = VGroup()\n",
        "        rects = VGroup()\n",
        "        get_length = lambda mob : max(mob.get_width(), mob.get_height())\n",
        "        for mob in mobjects:\n",
        "            if mob.background_image_file is not None:\n",
        "                mob.set_stroke(width = 4*np.sqrt(get_length(mob)))\n",
        "                lines.add(mob)\n",
        "            elif isinstance(mob, Polygon):\n",
        "                rects.add(mob)\n",
        "            else:\n",
        "                self.remove(mob)\n",
        "\n",
        "        self.clear()\n",
        "        self.add(lines)\n",
        "\n"
    ]
}