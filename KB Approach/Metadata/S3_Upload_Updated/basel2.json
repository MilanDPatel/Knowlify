{
    "topic": "The mathematical concept being demonstrated is the relationship between the angles of a triangle and the distance between its vertices",
    "code": [
        "#!/usr/bin/env python\n",
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "import warnings\n",
        "warnings.warn(\"\"\"\n",
        "    Warning: This file makes use of\n",
        "    ContinualAnimation, which has since\n",
        "    been deprecated\n",
        "\"\"\")\n",
        "\n",
        "\n",
        "import types\n",
        "import functools\n",
        "\n",
        "LIGHT_COLOR = YELLOW\n",
        "INDICATOR_RADIUS = 0.7\n",
        "INDICATOR_STROKE_WIDTH = 1\n",
        "INDICATOR_STROKE_COLOR = WHITE\n",
        "INDICATOR_TEXT_COLOR = WHITE\n",
        "INDICATOR_UPDATE_TIME = 0.2\n",
        "FAST_INDICATOR_UPDATE_TIME = 0.1\n",
        "OPACITY_FOR_UNIT_INTENSITY = 0.2\n",
        "SWITCH_ON_RUN_TIME = 1.5\n",
        "FAST_SWITCH_ON_RUN_TIME = 0.1\n",
        "NUM_LEVELS = 30\n",
        "NUM_CONES = 7 # in first lighthouse scene\n",
        "NUM_VISIBLE_CONES = 5 # ibidem\n",
        "ARC_TIP_LENGTH = 0.2\n",
        "AMBIENT_FULL = 0.5\n",
        "AMBIENT_DIMMED = 0.2\n",
        "SPOTLIGHT_FULL = 0.9\n",
        "SPOTLIGHT_DIMMED = 0.2\n",
        "\n",
        "LIGHT_COLOR = YELLOW\n",
        "DEGREES = TAU/360\n",
        "\n",
        "inverse_power_law = lambda maxint,scale,cutoff,exponent: \\\n",
        "    (lambda r: maxint * (cutoff/(r/scale+cutoff))**exponent)\n",
        "inverse_quadratic = lambda maxint, scale, cutoff: inverse_power_law(maxint,scale,cutoff,2)\n",
        "\n",
        "# A = np.array([5.,-3.,0.])\n",
        "# B = np.array([-5.,3.,0.])\n",
        "# C = np.array([-5.,-3.,0.])\n",
        "# xA = A[0]\n",
        "# yA = A[1]\n",
        "# xB = B[0]\n",
        "# yB = B[1]\n",
        "# xC = C[0]\n",
        "# yC = C[1]\n",
        "\n",
        "# find the coords of the altitude point H\n",
        "# as the solution of a certain LSE\n",
        "# prelim_matrix = np.array([[yA - yB, xB - xA], [xA - xB, yA - yB]]) # sic\n",
        "# prelim_vector = np.array([xB * yA - xA * yB, xC * (xA - xB) + yC * (yA - yB)])\n",
        "# H2 = np.linalg.solve(prelim_matrix,prelim_vector)\n",
        "# H = np.append(H2, 0.)\n",
        "\n",
        "class AngleUpdater(ContinualAnimation):\n",
        "    def __init__(self, angle_arc, spotlight, **kwargs):\n",
        "        self.angle_arc = angle_arc\n",
        "\n",
        "        self.spotlight = spotlight\n",
        "        ContinualAnimation.__init__(self, self.angle_arc, **kwargs)\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        new_arc = self.angle_arc.copy().set_bound_angles(\n",
        "            start = self.spotlight.start_angle(),\n",
        "            stop = self.spotlight.stop_angle()\n",
        "        )\n",
        "        new_arc.init_points()\n",
        "        new_arc.move_arc_center_to(self.spotlight.get_source_point())\n",
        "        self.angle_arc.set_points(new_arc.get_points())\n",
        "        self.angle_arc.add_tip(\n",
        "            tip_length = ARC_TIP_LENGTH,\n",
        "            at_start = True, at_end = True\n",
        "        )\n",
        "\n",
        "class LightIndicator(Mobject):\n",
        "    CONFIG = {\n",
        "        \"radius\": 0.5,\n",
        "        \"reading_height\" : 0.25,\n",
        "        \"intensity\": 0,\n",
        "        \"opacity_for_unit_intensity\": 1,\n",
        "        \"fill_color\" : YELLOW,\n",
        "        \"precision\": 3,\n",
        "        \"show_reading\": True,\n",
        "        \"measurement_point\": ORIGIN,\n",
        "        \"light_source\": None\n",
        "    }\n",
        "\n",
        "    def init_points(self):\n",
        "        self.background = Circle(color=BLACK, radius = self.radius)\n",
        "        self.background.set_fill(opacity = 1.0)\n",
        "        self.foreground = Circle(color=self.color, radius = self.radius)\n",
        "        self.foreground.set_stroke(\n",
        "            color=INDICATOR_STROKE_COLOR,\n",
        "            width=INDICATOR_STROKE_WIDTH\n",
        "        )\n",
        "        self.foreground.set_fill(color = self.fill_color)\n",
        "\n",
        "        self.add(self.background, self.foreground)\n",
        "        self.reading = DecimalNumber(self.intensity,num_decimal_places = self.precision)\n",
        "        self.reading.set_fill(color=INDICATOR_TEXT_COLOR)\n",
        "        self.reading.set_height(self.reading_height)\n",
        "        self.reading.move_to(self.get_center())\n",
        "        if self.show_reading:\n",
        "            self.add(self.reading)\n",
        "\n",
        "    def set_intensity(self, new_int):\n",
        "        self.intensity = new_int\n",
        "        new_opacity = min(1, new_int * self.opacity_for_unit_intensity)\n",
        "        self.foreground.set_fill(opacity=new_opacity)\n",
        "        ChangeDecimalToValue(self.reading, new_int).update(1)\n",
        "        if new_int > 1.1:\n",
        "            self.reading.set_fill(color = BLACK)\n",
        "        else:\n",
        "            self.reading.set_fill(color = WHITE)\n",
        "        return self\n",
        "\n",
        "    def get_measurement_point(self):\n",
        "        if self.measurement_point is not None:\n",
        "            return self.measurement_point\n",
        "        else:\n",
        "            return self.get_center()\n",
        "\n",
        "    def measured_intensity(self):\n",
        "        distance = get_norm(\n",
        "            self.get_measurement_point() - \n",
        "            self.light_source.get_source_point()\n",
        "        )\n",
        "        intensity = self.light_source.opacity_function(distance) / self.opacity_for_unit_intensity\n",
        "        return intensity\n",
        "\n",
        "    def update_mobjects(self):\n",
        "        if self.light_source == None:\n",
        "            print(\"Indicator cannot update, reason: no light source found\")\n",
        "        self.set_intensity(self.measured_intensity())\n",
        "\n",
        "class UpdateLightIndicator(AnimationGroup):\n",
        "\n",
        "    def __init__(self, indicator, intensity, **kwargs):\n",
        "        if not isinstance(indicator,LightIndicator):\n",
        "            raise Exception(\"This transform applies only to LightIndicator\")\n",
        "        \n",
        "        target_foreground = indicator.copy().set_intensity(intensity).foreground\n",
        "        change_opacity = Transform(\n",
        "            indicator.foreground, target_foreground\n",
        "        )\n",
        "        changing_decimal = ChangeDecimalToValue(indicator.reading, intensity)\n",
        "\n",
        "        AnimationGroup.__init__(self, changing_decimal, change_opacity, **kwargs)\n",
        "        self.mobject = indicator\n",
        "\n",
        "class ContinualLightIndicatorUpdate(ContinualAnimation):\n",
        "    def update_mobject(self,dt):\n",
        "        self.mobject.update_mobjects()\n",
        "\n",
        "def copy_func(f):\n",
        "    \"\"\"Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)\"\"\"\n",
        "    g = types.FunctionType(f.__code__, f.__globals__, name=f.__name__,\n",
        "                           argdefs=f.__defaults__,\n",
        "                           closure=f.__closure__)\n",
        "    g = functools.update_wrapper(g, f)\n",
        "    return g\n",
        "\n",
        "class ScaleLightSources(Transform):\n",
        "\n",
        "    def __init__(self, light_sources_mob, factor, about_point = None, **kwargs):\n",
        "\n",
        "        if about_point == None:\n",
        "            about_point = light_sources_mob.get_center()\n",
        "\n",
        "        ls_target = light_sources_mob.copy()\n",
        "\n",
        "        for submob in ls_target:\n",
        "\n",
        "            if type(submob) == LightSource:\n",
        "\n",
        "                new_sp = submob.source_point.copy() # a mob\n",
        "                new_sp.scale(factor,about_point = about_point)\n",
        "                submob.move_source_to(new_sp.get_location())\n",
        "\n",
        "                #ambient_of = copy_func(submob.ambient_light.opacity_function)\n",
        "                #new_of = lambda r: ambient_of(r/factor)\n",
        "                #submob.ambient_light.opacity_function = new_of\n",
        "\n",
        "                #spotlight_of = copy_func(submob.ambient_light.opacity_function)\n",
        "                #new_of = lambda r: spotlight_of(r/factor)\n",
        "                #submob.spotlight.change_opacity_function(new_of)\n",
        "\n",
        "                new_r = factor * submob.radius\n",
        "                submob.set_radius(new_r)\n",
        "\n",
        "                new_r = factor * submob.ambient_light.radius\n",
        "                submob.ambient_light.radius = new_r\n",
        "\n",
        "                new_r = factor * submob.spotlight.radius\n",
        "                submob.spotlight.radius = new_r\n",
        "\n",
        "                submob.ambient_light.scale_about_point(factor, new_sp.get_center())\n",
        "                submob.spotlight.scale_about_point(factor, new_sp.get_center())\n",
        "\n",
        "\n",
        "        Transform.__init__(self,light_sources_mob,ls_target,**kwargs)\n",
        "\n",
        "class ThreeDSpotlight(VGroup):\n",
        "    CONFIG = { \n",
        "        \"fill_color\" : YELLOW,\n",
        "    }\n",
        "    def __init__(self, screen, ambient_light, source_point_func, **kwargs):\n",
        "        self.screen = screen\n",
        "        self.ambient_light = ambient_light\n",
        "        self.source_point_func = source_point_func\n",
        "        self.dr = ambient_light.radius/ambient_light.num_levels\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "\n",
        "    def update(self):\n",
        "        screen = self.screen\n",
        "        source_point = self.source_point_func()\n",
        "        dr = self.dr\n",
        "        corners = screen.get_anchors()\n",
        "        self.submobjects = [VGroup() for a in screen.get_anchors()]\n",
        "\n",
        "        distance = get_norm(\n",
        "            screen.get_center() - source_point\n",
        "        )\n",
        "        n_parts = np.ceil(distance/dr)\n",
        "        alphas = np.linspace(0, 1, n_parts+1)\n",
        "        for face, (c1, c2) in zip(self, adjacent_pairs(corners)):\n",
        "            face.submobjects = []\n",
        "            for a1, a2 in zip(alphas, alphas[1:]):\n",
        "                face.add(Polygon(\n",
        "                    interpolate(source_point, c1, a1),\n",
        "                    interpolate(source_point, c1, a2),\n",
        "                    interpolate(source_point, c2, a2),\n",
        "                    interpolate(source_point, c2, a1),\n",
        "                    fill_color = self.fill_color,\n",
        "                    fill_opacity = self.ambient_light.opacity_function(a1*distance),\n",
        "                    stroke_width = 0\n",
        "                ))\n",
        "\n",
        "class ContinualThreeDLightConeUpdate(ContinualAnimation):\n",
        "    def update(self, dt):\n",
        "        self.mobject.update()\n",
        "\n",
        "###\n",
        "\n",
        "class ThinkAboutPondScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_class\" : Randolph,\n",
        "    }\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        bubble = ThoughtBubble(\n",
        "            width = 11,\n",
        "            height = 8,\n",
        "        )\n",
        "        circles = bubble[:3]\n",
        "        angle = -15*DEGREES\n",
        "        circles.rotate(angle, about_point = bubble.get_bubble_center())\n",
        "        circles.shift(LARGE_BUFF*LEFT)\n",
        "        for circle in circles:\n",
        "            circle.rotate(-angle)\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.shift(DOWN)\n",
        "        bubble[:3].rotate(np.pi, axis = UP+2*RIGHT, about_edge = UP+LEFT)\n",
        "        bubble[:3].scale(0.7, about_edge = DOWN+RIGHT)\n",
        "        bubble[:3].shift(1.5*DOWN)\n",
        "        for oval in bubble[:3]:\n",
        "            oval.rotate(TAU/3)\n",
        "\n",
        "        self.play(\n",
        "            randy.change, \"thinking\",\n",
        "            ShowCreation(bubble)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(randy.change, \"happy\", bubble)\n",
        "        self.wait(4)\n",
        "        self.play(randy.change, \"hooray\", bubble)\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"rect_height\" : 0.075,\n",
        "        \"duration\" : 1.0,\n",
        "        \"eq_spacing\" : 3 * MED_LARGE_BUFF,\n",
        "        \"n_rects_to_show\" : 30,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy.scale(0.7).to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.build_up_euler_sum()\n",
        "        self.show_history()\n",
        "        # self.other_pi_formulas()\n",
        "        # self.refocus_on_euler_sum()\n",
        "\n",
        "    def build_up_euler_sum(self):\n",
        "        morty = self.pi_creature\n",
        "        euler_sum = self.euler_sum = OldTex(\n",
        "           \"1\", \"+\", \n",
        "           \"{1 \\\\over 4}\", \"+\",\n",
        "           \"{1 \\\\over 9}\", \"+\",\n",
        "           \"{1 \\\\over 16}\", \"+\",\n",
        "           \"{1 \\\\over 25}\", \"+\",\n",
        "           \"\\\\cdots\", \"=\",\n",
        "            arg_separator = \" \\\\, \"\n",
        "        )\n",
        "        equals_sign = euler_sum.get_part_by_tex(\"=\")\n",
        "        plusses = euler_sum.get_parts_by_tex(\"+\")\n",
        "        term_mobjects = euler_sum.get_parts_by_tex(\"1\")\n",
        "\n",
        "        self.euler_sum.to_edge(UP)\n",
        "        self.euler_sum.shift(2*LEFT)\n",
        "       \n",
        "        max_n = self.n_rects_to_show\n",
        "        terms = [1./(n**2) for n in range(1, max_n + 1)]\n",
        "        series_terms = list(np.cumsum(terms))\n",
        "        series_terms.append(np.pi**2/6) ##Just force this up there\n",
        "\n",
        "        partial_sum_decimal = self.partial_sum_decimal = DecimalNumber(\n",
        "            series_terms[1],\n",
        "            num_decimal_places = 2\n",
        "        )\n",
        "        partial_sum_decimal.next_to(equals_sign, RIGHT)\n",
        "\n",
        "        ## Number line\n",
        "\n",
        "        number_line = self.number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            color = WHITE,\n",
        "            number_at_center = 1,\n",
        "            stroke_width = 1,\n",
        "            big_tick_numbers = [0,1,2,3],\n",
        "            numbers_to_show = np.arange(0,5),\n",
        "            unit_size = 5,\n",
        "            tick_frequency = 0.2,\n",
        "            line_to_number_buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        number_line.add_numbers()\n",
        "        number_line.to_edge(LEFT)\n",
        "        number_line.shift(MED_LARGE_BUFF*UP)\n",
        "\n",
        "        # create slabs for series terms\n",
        "\n",
        "        lines = VGroup()\n",
        "        rects = self.rects = VGroup()\n",
        "        rect_labels = VGroup()\n",
        "        slab_colors = it.cycle([YELLOW, BLUE])\n",
        "        rect_anims = []\n",
        "        rect_label_anims = []\n",
        "\n",
        "        for i, t1, t2 in zip(it.count(1), [0]+series_terms, series_terms):\n",
        "            color = next(slab_colors)\n",
        "            line = Line(*list(map(number_line.number_to_point, [t1, t2])))\n",
        "            rect = Rectangle(\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 1,\n",
        "                fill_color = color\n",
        "            )\n",
        "            rect.match_width(line)\n",
        "            rect.stretch_to_fit_height(self.rect_height)\n",
        "            rect.move_to(line)\n",
        "\n",
        "            if i <= 5:\n",
        "                if i == 1:\n",
        "                    rect_label = OldTex(\"1\")\n",
        "                else:\n",
        "                    rect_label = OldTex(\"\\\\frac{1}{%d}\"%(i**2))\n",
        "                    rect_label.scale(0.75)\n",
        "                max_width = 0.7*rect.get_width()\n",
        "                if rect_label.get_width() > max_width:\n",
        "                    rect_label.set_width(max_width)\n",
        "                rect_label.next_to(rect, UP, buff = MED_LARGE_BUFF/(i+1))\n",
        "\n",
        "                term_mobject = term_mobjects[i-1]\n",
        "                rect_anim = GrowFromPoint(rect, term_mobject.get_center())\n",
        "                rect_label_anim = ReplacementTransform(\n",
        "                    term_mobject.copy(), rect_label\n",
        "                )\n",
        "            else:\n",
        "                rect_label = VectorizedPoint()\n",
        "                rect_anim = GrowFromPoint(rect, rect.get_left())\n",
        "                rect_label_anim = FadeIn(rect_label)\n",
        "\n",
        "            rects.add(rect)\n",
        "            rect_labels.add(rect_label)\n",
        "            rect_anims.append(rect_anim)\n",
        "            rect_label_anims.append(rect_label_anim)\n",
        "            lines.add(line)\n",
        "        dots = OldTex(\"\\\\dots\").scale(0.5)\n",
        "        last_rect = rect_anims[-1].target_mobject\n",
        "        dots.set_width(0.9*last_rect.get_width())\n",
        "        dots.move_to(last_rect, UP+RIGHT)\n",
        "        rects.submobjects[-1] = dots\n",
        "        rect_anims[-1] = FadeIn(dots)\n",
        "\n",
        "        self.add(number_line)\n",
        "        self.play(FadeIn(euler_sum[0]))\n",
        "        self.play(\n",
        "            rect_anims[0],\n",
        "            rect_label_anims[0]\n",
        "        )\n",
        "        for i in range(4):\n",
        "            self.play(\n",
        "                FadeIn(term_mobjects[i+1]),\n",
        "                FadeIn(plusses[i]),\n",
        "            )\n",
        "            anims = [\n",
        "                rect_anims[i+1],\n",
        "                rect_label_anims[i+1],\n",
        "            ]\n",
        "            if i == 0:\n",
        "                anims += [\n",
        "                    FadeIn(equals_sign),\n",
        "                    FadeIn(partial_sum_decimal)\n",
        "                ]\n",
        "            elif i <= 5:\n",
        "                anims += [\n",
        "                    ChangeDecimalToValue(\n",
        "                        partial_sum_decimal,\n",
        "                        series_terms[i+1], \n",
        "                        run_time = 1,\n",
        "                        num_decimal_places = 6,\n",
        "                        position_update_func = lambda m: m.next_to(equals_sign, RIGHT)\n",
        "                    )\n",
        "                ]\n",
        "            self.play(*anims)\n",
        "\n",
        "        for i in range(4, len(series_terms)-2):\n",
        "            anims = [\n",
        "                rect_anims[i+1],\n",
        "                ChangeDecimalToValue(\n",
        "                    partial_sum_decimal,\n",
        "                    series_terms[i+1],\n",
        "                    num_decimal_places = 6,\n",
        "                ),\n",
        "            ]\n",
        "            if i == 5:\n",
        "                anims += [\n",
        "                    FadeIn(euler_sum[-3]), # +\n",
        "                    FadeIn(euler_sum[-2]), # ...\n",
        "                ]\n",
        "            self.play(*anims, run_time = 2./i)\n",
        "\n",
        "        brace = self.brace = Brace(partial_sum_decimal, DOWN)\n",
        "        q_marks = self.q_marks = OldTexText(\"???\")\n",
        "        q_marks.next_to(brace, DOWN)\n",
        "        q_marks.set_color(LIGHT_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(q_marks),\n",
        "            ChangeDecimalToValue(\n",
        "                partial_sum_decimal,\n",
        "                series_terms[-1],\n",
        "                num_decimal_places = 6,\n",
        "            ),\n",
        "            morty.change, \"confused\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.number_line_group = VGroup(\n",
        "            number_line, rects, rect_labels\n",
        "        )\n",
        "\n",
        "    def show_history(self):\n",
        "        # Pietro Mengoli in 1644\n",
        "        morty = self.pi_creature\n",
        "        pietro = ImageMobject(\"Pietro_Mengoli\")\n",
        "        euler = ImageMobject(\"Euler\")\n",
        "\n",
        "        pietro_words = OldTexText(\"Challenge posed by \\\\\\\\ Pietro Mengoli in 1644\")\n",
        "        pietro_words.scale(0.75)\n",
        "        pietro_words.next_to(pietro, DOWN)\n",
        "        pietro.add(pietro_words)\n",
        "\n",
        "        euler_words = OldTexText(\"Solved by Leonard \\\\\\\\ Euler in 1735\")\n",
        "        euler_words.scale(0.75)\n",
        "        euler_words.next_to(euler, DOWN)\n",
        "        euler.add(euler_words)\n",
        "\n",
        "        pietro.next_to(FRAME_X_RADIUS*LEFT, LEFT)\n",
        "        euler.next_to(FRAME_X_RADIUS*RIGHT, RIGHT)\n",
        "\n",
        "        pi_answer = self.pi_answer = OldTex(\"{\\\\pi^2 \\\\over 6}\")\n",
        "        pi_answer.set_color(YELLOW)\n",
        "        pi_answer.move_to(self.partial_sum_decimal, LEFT)\n",
        "        equals_sign = OldTex(\"=\")\n",
        "        equals_sign.next_to(pi_answer, RIGHT)\n",
        "        pi_answer.shift(SMALL_BUFF*UP)\n",
        "        self.partial_sum_decimal.generate_target()\n",
        "        self.partial_sum_decimal.target.next_to(equals_sign, RIGHT)\n",
        "\n",
        "        pi = pi_answer[0]\n",
        "        pi_rect = SurroundingRectangle(pi, color = RED)\n",
        "        pi_rect.save_state()\n",
        "        pi_rect.set_height(FRAME_Y_RADIUS)\n",
        "        pi_rect.center()\n",
        "        pi_rect.set_stroke(width = 0)\n",
        "        squared = pi_answer[1]\n",
        "        squared_rect = SurroundingRectangle(squared, color = BLUE)\n",
        "\n",
        "        brace = Brace(\n",
        "            VGroup(self.euler_sum, self.partial_sum_decimal.target),\n",
        "            DOWN, buff = SMALL_BUFF\n",
        "        )\n",
        "        basel_text = brace.get_text(\"Basel problem\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.number_line_group.save_state()\n",
        "        self.play(\n",
        "            pietro.next_to, ORIGIN, LEFT, LARGE_BUFF,\n",
        "            self.number_line_group.next_to, FRAME_Y_RADIUS*DOWN, DOWN,\n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(euler.next_to, ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(self.q_marks, pi_answer),\n",
        "            FadeIn(equals_sign),\n",
        "            FadeOut(self.brace),\n",
        "            MoveToTarget(self.partial_sum_decimal)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"surprised\")\n",
        "        self.play(pi_rect.restore)\n",
        "        self.wait()\n",
        "        self.play(Transform(pi_rect, squared_rect))\n",
        "        self.play(FadeOut(pi_rect))\n",
        "        self.play(morty.change, \"hesitant\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            euler.to_edge, DOWN,\n",
        "            pietro.to_edge, DOWN,\n",
        "            self.number_line_group.restore,\n",
        "            self.number_line_group.shift, LARGE_BUFF*RIGHT,\n",
        "        )\n",
        "        self.play(Write(basel_text))\n",
        "        self.play(morty.change, \"happy\")\n",
        "        self.wait(4)\n",
        "\n",
        "    def other_pi_formulas(self):\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.rects),\n",
        "            FadeOut(self.number_line)\n",
        "        )\n",
        "\n",
        "        self.leibniz_sum = OldTex(\n",
        "            \"1-{1\\\\over 3}+{1\\\\over 5}-{1\\\\over 7}+{1\\\\over 9}-\\\\cdots\",\n",
        "            \"=\", \"{\\\\pi \\\\over 4}\")\n",
        "\n",
        "        self.wallis_product = OldTex(\n",
        "            \"{2\\\\over 1} \\\\cdot {2\\\\over 3} \\\\cdot {4\\\\over 3} \\\\cdot {4\\\\over 5}\" +\n",
        "             \"\\\\cdot {6\\\\over 5} \\\\cdot {6\\\\over 7} \\\\cdots\",\n",
        "             \"=\", \"{\\\\pi \\\\over 2}\")\n",
        "\n",
        "        self.leibniz_sum.next_to(self.euler_sum.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = self.eq_spacing,\n",
        "            submobject_to_align = self.leibniz_sum.get_part_by_tex(\"=\")\n",
        "        )\n",
        "\n",
        "        self.wallis_product.next_to(self.leibniz_sum.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = self.eq_spacing,\n",
        "            submobject_to_align = self.wallis_product.get_part_by_tex(\"=\")\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Write(self.leibniz_sum)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(self.wallis_product)\n",
        "        )\n",
        "\n",
        "    def refocus_on_euler_sum(self):\n",
        "\n",
        "        self.euler_sum.add(self.pi_answer)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.leibniz_sum),\n",
        "            FadeOut(self.wallis_product),\n",
        "            ApplyMethod(self.euler_sum.shift,\n",
        "                ORIGIN + 2*UP - self.euler_sum.get_center())\n",
        "        )\n",
        "\n",
        "        # focus on pi squared\n",
        "        pi_squared = self.euler_sum.get_part_by_tex(\"\\\\pi\")[-3]\n",
        "        self.play(\n",
        "            ScaleInPlace(pi_squared,2,rate_func = wiggle)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        # Morty thinks of a circle\n",
        "\n",
        "        q_circle = Circle(\n",
        "            stroke_color = YELLOW,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.5,\n",
        "            radius = 0.4, \n",
        "            stroke_width = 10.0\n",
        "        )\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.next_to(q_circle)\n",
        "\n",
        "        thought = Group(q_circle, q_mark)\n",
        "        q_mark.set_height(0.8 * q_circle.get_height())\n",
        "        self.pi_creature_thinks(thought,target_mode = \"confused\",\n",
        "            bubble_config = { \"height\" : 2, \"width\" : 3 })\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class PiHidingWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Pi hiding in prime regularities\")\n",
        "        title.to_edge(UP)\n",
        "        screen = ScreenRectangle(height = 6)\n",
        "        screen.next_to(title, DOWN)\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen))\n",
        "        self.wait(2)\n",
        "\n",
        "class MathematicalWebOfConnections(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.complain_that_pi_is_not_about_circles()\n",
        "        self.show_other_pi_formulas()\n",
        "        self.question_fundamental()\n",
        "        self.draw_circle()\n",
        "        self.remove_all_but_basel_sum()\n",
        "        self.show_web_of_connections()\n",
        "        self.show_light()\n",
        "\n",
        "    def complain_that_pi_is_not_about_circles(self):\n",
        "        jerk, randy = self.pi_creatures\n",
        "\n",
        "        words = self.words = OldTexText(\n",
        "            \"I am not\",\n",
        "            \"fundamentally \\\\\\\\\", \n",
        "            \"about circles\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"fundamentally\", YELLOW)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            jerk, words,\n",
        "            target_mode = \"angry\"\n",
        "        ))\n",
        "        self.play(randy.change, \"guilty\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_other_pi_formulas(self):\n",
        "        jerk, randy = self.pi_creatures\n",
        "        words = self.words\n",
        "\n",
        "        basel_sum = OldTex(\n",
        "            \"1 + {1 \\\\over 4} + {1 \\\\over 9} + {1 \\\\over 16} + \\\\cdots\", \n",
        "            \"=\", \"{\\\\pi^2 \\\\over 6}\"\n",
        "        )\n",
        "        leibniz_sum = OldTex(\n",
        "            \"1-{1\\\\over 3}+{1\\\\over 5}-{1\\\\over 7}+{1\\\\over 9}-\\\\cdots\",\n",
        "            \"=\", \"{\\\\pi \\\\over 4}\")\n",
        "\n",
        "        wallis_product = OldTex(\n",
        "            \"{2\\\\over 1} \\\\cdot {2\\\\over 3} \\\\cdot {4\\\\over 3} \\\\cdot {4\\\\over 5}\" +\n",
        "             \"\\\\cdot {6\\\\over 5} \\\\cdot {6\\\\over 7} \\\\cdots\",\n",
        "             \"=\", \"{\\\\pi \\\\over 2}\")\n",
        "\n",
        "        basel_sum.move_to(randy)\n",
        "        basel_sum.to_edge(UP)\n",
        "        basel_equals = basel_sum.get_part_by_tex(\"=\")\n",
        "\n",
        "        formulas = VGroup(basel_sum, leibniz_sum, wallis_product)\n",
        "        formulas.scale(0.75)\n",
        "        formulas.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        for formula in formulas:\n",
        "            basel_equals_x = basel_equals.get_center()[0]\n",
        "            formula_equals_x = formula.get_part_by_tex(\"=\").get_center()[0]\n",
        "            formula.shift((basel_equals_x - formula_equals_x)*RIGHT)\n",
        "\n",
        "        formulas.to_corner(UP+RIGHT)\n",
        "        formulas.shift(2*LEFT)\n",
        "        self.formulas = formulas\n",
        "\n",
        "        self.play(\n",
        "            jerk.change, \"sassy\",\n",
        "            randy.change, \"raise_right_hand\",\n",
        "            FadeOut(jerk.bubble),\n",
        "            words.next_to, jerk, UP,\n",
        "            FadeIn(basel_sum, lag_ratio = 0.5, run_time = 3)\n",
        "        )\n",
        "        for formula in formulas[1:]:\n",
        "            self.play(\n",
        "                FadeIn(\n",
        "                    formula, \n",
        "                    lag_ratio = 0.5, \n",
        "                    run_time = 3\n",
        "                ),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def question_fundamental(self):\n",
        "        jerk, randy = self.pi_creatures\n",
        "        words = self.words\n",
        "        fundamentally = words.get_part_by_tex(\"fundamentally\")\n",
        "        words.remove(fundamentally)\n",
        "\n",
        "        self.play(\n",
        "            fundamentally.move_to, self.pi_creatures,\n",
        "            fundamentally.shift, UP,\n",
        "            FadeOut(words),\n",
        "            jerk.change, \"pondering\",\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        question = OldTexText(\"Does this mean \\\\\\\\ anything?\")\n",
        "        question.scale(0.8)\n",
        "        question.set_stroke(WHITE, 0.5)\n",
        "        question.next_to(fundamentally, DOWN, LARGE_BUFF)\n",
        "        arrow = Arrow(question, fundamentally)\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        fundamentally.add(question, arrow)\n",
        "        self.fundamentally = fundamentally\n",
        "\n",
        "    def draw_circle(self):\n",
        "        semi_circle = Arc(angle = np.pi, radius = 2)\n",
        "        radius = Line(ORIGIN, semi_circle.get_points()[0])\n",
        "        radius.set_color(BLUE)\n",
        "        semi_circle.set_color(YELLOW)\n",
        "\n",
        "        VGroup(radius, semi_circle).move_to(\n",
        "            FRAME_X_RADIUS*LEFT/2 + FRAME_Y_RADIUS*UP/2,\n",
        "        )\n",
        "\n",
        "        decimal = DecimalNumber(0)\n",
        "        def decimal_position_update_func(decimal):\n",
        "            decimal.move_to(semi_circle.get_points()[-1])\n",
        "            decimal.shift(0.3*radius.get_vector())\n",
        "\n",
        "        one = OldTex(\"1\")\n",
        "        one.next_to(radius, UP)\n",
        "\n",
        "        self.play(ShowCreation(radius), FadeIn(one))\n",
        "        self.play(\n",
        "            Rotate(radius, np.pi, about_point = radius.get_start()),\n",
        "            ShowCreation(semi_circle),\n",
        "            ChangeDecimalToValue(\n",
        "                decimal, np.pi, \n",
        "                position_update_func = decimal_position_update_func\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(one, radius),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.circle_group = VGroup(semi_circle, radius, one, decimal)\n",
        "\n",
        "    def remove_all_but_basel_sum(self):\n",
        "        to_shift_down = VGroup(\n",
        "            self.circle_group, self.pi_creatures,\n",
        "            self.fundamentally, self.formulas[1:],\n",
        "        )\n",
        "        to_shift_down.generate_target()\n",
        "        for part in to_shift_down.target:\n",
        "            part.move_to(FRAME_HEIGHT*DOWN)\n",
        "\n",
        "        basel_sum = self.formulas[0]\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(to_shift_down),\n",
        "            basel_sum.scale, 1.5,\n",
        "            basel_sum.move_to, 1.5*DOWN,\n",
        "        )\n",
        "\n",
        "        self.basel_sum = basel_sum\n",
        "\n",
        "    def show_web_of_connections(self):\n",
        "        self.remove(self.pi_creatures)\n",
        "        title = OldTexText(\"Interconnected web of mathematics\")\n",
        "        title.to_edge(UP)\n",
        "        basel_sum = self.basel_sum\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(radius = 0.1).move_to(\n",
        "                (j - 0.5*(i%2))*RIGHT + \\\n",
        "                (np.sqrt(3)/2.0)* i*DOWN + \\\n",
        "                0.5*(random.random()*RIGHT + random.random()*UP),\n",
        "            )\n",
        "            for i in range(4)\n",
        "            for j in range(7+(i%2))\n",
        "        ])\n",
        "        dots.set_height(3)\n",
        "        dots.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        edges = VGroup()\n",
        "        for x in range(100):\n",
        "            d1, d2 = random.sample(dots, 2)\n",
        "            edge = Line(d1.get_center(), d2.get_center())\n",
        "            edge.set_stroke(YELLOW, 0.5)\n",
        "            edges.add(edge)\n",
        "\n",
        "        ## Choose special path\n",
        "        path_dots = VGroup(\n",
        "            dots[-7],\n",
        "            dots[-14],\n",
        "            dots[9],\n",
        "            dots[19],\n",
        "            dots[14],\n",
        "        )\n",
        "        path_edges = VGroup(*[\n",
        "            Line(\n",
        "                d1.get_center(), d2.get_center(),\n",
        "                color = RED\n",
        "            )\n",
        "            for d1, d2 in zip(path_dots, path_dots[1:])\n",
        "        ])\n",
        "\n",
        "        circle = Circle(color = YELLOW, radius = 1)\n",
        "        radius = Line(circle.get_center(), circle.get_right())\n",
        "        radius.set_color(BLUE)\n",
        "        VGroup(circle, radius).next_to(path_dots[-1], RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            LaggedStartMap(ShowCreation, edges, run_time = 3),\n",
        "            LaggedStartMap(GrowFromCenter, dots, run_time = 3)\n",
        "        )\n",
        "        self.play(path_dots[0].set_color, RED)\n",
        "        for dot, edge in zip(path_dots[1:], path_edges):\n",
        "            self.play(\n",
        "                ShowCreation(edge),\n",
        "                dot.set_color, RED\n",
        "            )\n",
        "        self.play(ShowCreation(radius))\n",
        "        radius.set_points_as_corners(radius.get_anchors())\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotate(radius, angle = 0.999*TAU, about_point = radius.get_start()),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        graph = VGroup(dots, edges, path_edges, title)\n",
        "        circle.add(radius)\n",
        "        basel_sum.generate_target()\n",
        "        basel_sum.target.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            UP, DOWN, \n",
        "            rectangular_stem_width = 0.1,\n",
        "            tip_length = 0.45,\n",
        "            color = RED,\n",
        "        )\n",
        "        arrow.next_to(basel_sum.target, DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(basel_sum),\n",
        "            graph.next_to, basel_sum.target, UP, LARGE_BUFF,\n",
        "            circle.next_to, arrow, DOWN, MED_LARGE_BUFF,\n",
        "        )\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        self.arrow = arrow\n",
        "        self.circle = circle\n",
        "\n",
        "    def show_light(self):\n",
        "        light = AmbientLight(\n",
        "            num_levels = 500, radius = 13,\n",
        "            opacity_function = lambda r : 1.0/(r+1),\n",
        "        )\n",
        "        pi = self.basel_sum[-1][0]\n",
        "        pi.set_stroke(BLACK, 0.5)\n",
        "        light.move_to(pi)\n",
        "        self.play(\n",
        "            SwitchOn(light, run_time = 3),\n",
        "            Animation(self.arrow),\n",
        "            Animation(self.circle),\n",
        "            Animation(self.basel_sum),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        jerk = PiCreature(color = GREEN_D)\n",
        "        randy = Randolph().flip()\n",
        "        jerk.move_to(0.5*FRAME_X_RADIUS*LEFT).to_edge(DOWN)\n",
        "        randy.move_to(0.5*FRAME_X_RADIUS*RIGHT).to_edge(DOWN)\n",
        "\n",
        "        return VGroup(jerk, randy)\n",
        "\n",
        "class FirstLighthouseScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 100,\n",
        "        \"opacity_function\" : inverse_quadratic(1,2,1),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.show_lighthouses_on_number_line()\n",
        "        self.describe_brightness_of_each()\n",
        "        self.ask_about_rearrangements()\n",
        "\n",
        "    def show_lighthouses_on_number_line(self):\n",
        "        number_line = self.number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            color = WHITE,\n",
        "            number_at_center = 1.6,\n",
        "            stroke_width = 1,\n",
        "            big_tick_numbers = list(range(1,6)),\n",
        "            numbers_to_show = list(range(1,6)),\n",
        "            unit_size = 2,\n",
        "            tick_frequency = 0.2,\n",
        "            line_to_number_buff = LARGE_BUFF,\n",
        "            label_direction = DOWN,\n",
        "        )\n",
        "\n",
        "        number_line.add_numbers()\n",
        "        self.add(number_line)\n",
        "\n",
        "        origin_point = number_line.number_to_point(0)\n",
        "\n",
        "        morty = self.pi_creature\n",
        "        morty.scale(0.75)\n",
        "        morty.flip()\n",
        "        right_pupil = morty.eyes[1]\n",
        "        morty.next_to(origin_point, LEFT, buff = 0, submobject_to_align = right_pupil)\n",
        "\n",
        "\n",
        "        light_sources = VGroup()\n",
        "        for i in range(1,NUM_CONES+1):\n",
        "            light_source = LightSource(\n",
        "                opacity_function = self.opacity_function,\n",
        "                num_levels = self.num_levels,\n",
        "                radius = 12.0,\n",
        "            )\n",
        "            point = number_line.number_to_point(i)\n",
        "            light_source.move_source_to(point)\n",
        "            light_sources.add(light_source)\n",
        "\n",
        "        lighthouses = self.lighthouses = VGroup(*[\n",
        "            ls.lighthouse\n",
        "            for ls in light_sources[:NUM_VISIBLE_CONES+1]\n",
        "        ])\n",
        "\n",
        "        morty.save_state()\n",
        "        morty.scale(3)\n",
        "        morty.fade(1)\n",
        "        morty.center()\n",
        "        self.play(morty.restore)\n",
        "        self.play(\n",
        "            morty.change, \"pondering\",\n",
        "            LaggedStartMap(\n",
        "                FadeIn, lighthouses,\n",
        "                run_time = 1\n",
        "            )\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            SwitchOn, VGroup(*[\n",
        "                ls.ambient_light\n",
        "                for ls in light_sources\n",
        "            ]),\n",
        "            run_time = 5,\n",
        "            lag_ratio = 0.1,\n",
        "            rate_func = rush_into,\n",
        "        ), Animation(lighthouses))\n",
        "        self.wait()\n",
        "\n",
        "        self.light_sources = light_sources\n",
        "\n",
        "    def describe_brightness_of_each(self):\n",
        "        number_line = self.number_line\n",
        "        morty = self.pi_creature\n",
        "        light_sources = self.light_sources\n",
        "        lighthouses = self.lighthouses\n",
        "\n",
        "        light_indicator = LightIndicator(\n",
        "            radius = INDICATOR_RADIUS,\n",
        "            opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "            color = LIGHT_COLOR\n",
        "        )\n",
        "        light_indicator.reading.scale(0.8)\n",
        "        light_indicator.set_intensity(0)\n",
        "        intensities = np.cumsum(np.array([1./n**2 for n in range(1,NUM_CONES+1)]))\n",
        "        opacities = intensities * light_indicator.opacity_for_unit_intensity\n",
        "\n",
        "        bubble = ThoughtBubble(\n",
        "            direction = RIGHT,\n",
        "            width = 2.5, height = 3.5\n",
        "        )\n",
        "        bubble.pin_to(morty)\n",
        "        bubble.add_content(light_indicator)\n",
        "\n",
        "        euler_sum_above = OldTex(\n",
        "            \"1\", \"+\", \n",
        "            \"{1\\over 4}\", \"+\", \n",
        "            \"{1\\over 9}\", \"+\", \n",
        "            \"{1\\over 16}\", \"+\", \n",
        "            \"{1\\over 25}\", \"+\", \n",
        "            \"{1\\over 36}\"\n",
        "        )\n",
        "        euler_sum_terms = euler_sum_above[::2]\n",
        "        plusses = euler_sum_above[1::2]\n",
        "\n",
        "        for i, term in enumerate(euler_sum_above):\n",
        "            #horizontal alignment with tick marks\n",
        "            term.next_to(number_line.number_to_point(0.5*i+1), UP , buff = 2)\n",
        "            # vertical alignment with light indicator\n",
        "            old_y = term.get_center()[1]\n",
        "            new_y = light_indicator.get_center()[1]\n",
        "            term.shift([0,new_y - old_y,0])\n",
        "\n",
        "        # show limit value in light indicator and an equals sign\n",
        "        limit_reading = OldTex(\"{\\pi^2 \\over 6}\")\n",
        "        limit_reading.move_to(light_indicator.reading)\n",
        "\n",
        "        equals_sign = OldTex(\"=\")\n",
        "        equals_sign.next_to(morty, UP)\n",
        "        old_y = equals_sign.get_center()[1]\n",
        "        new_y = euler_sum_above.get_center()[1]\n",
        "        equals_sign.shift([0,new_y - old_y,0])\n",
        "\n",
        "        #Triangle of light to morty's eye\n",
        "        ls0 = light_sources[0]\n",
        "        ls0.save_state()\n",
        "        eye = morty.eyes[1]\n",
        "        triangle = Polygon(\n",
        "            number_line.number_to_point(1),\n",
        "            eye.get_top(), eye.get_bottom(),\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        triangle_anim = GrowFromPoint(\n",
        "            triangle, triangle.get_right(), \n",
        "            point_color = YELLOW\n",
        "        )\n",
        "\n",
        "        # First lighthouse has apparent reading\n",
        "        self.play(LaggedStartMap(FadeOut, light_sources[1:]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            triangle_anim,\n",
        "            # Animation(eye)\n",
        "        )\n",
        "        for x in range(4):\n",
        "            triangle_copy = triangle.copy()\n",
        "            self.play(\n",
        "                FadeOut(triangle.copy()),\n",
        "                triangle_anim,\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(triangle),\n",
        "            ShowCreation(bubble),\n",
        "            FadeIn(light_indicator),\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateLightIndicator(light_indicator, 1),\n",
        "            FadeIn(euler_sum_terms[0])\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Second lighthouse is 1/4, third is 1/9, etc.\n",
        "        for i in range(1, 5):\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    ls0.move_to, light_sources[i],\n",
        "                    run_time = 3\n",
        "                ),\n",
        "                UpdateLightIndicator(light_indicator, 1./(i+1)**2, run_time = 3),\n",
        "                FadeIn(\n",
        "                    euler_sum_terms[i],\n",
        "                    run_time = 3,\n",
        "                    rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(ls0.restore),\n",
        "            UpdateLightIndicator(light_indicator, 1)\n",
        "        )\n",
        "\n",
        "        #Switch them all on\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, lighthouses[1:]),\n",
        "            morty.change, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                SwitchOn, VGroup(*[\n",
        "                    ls.ambient_light\n",
        "                    for ls in light_sources[1:]\n",
        "                ]),\n",
        "                run_time = 5,\n",
        "                rate_func = rush_into,\n",
        "            ),\n",
        "            Animation(lighthouses),\n",
        "            Animation(euler_sum_above),\n",
        "            Write(plusses),\n",
        "            UpdateLightIndicator(light_indicator, np.pi**2/6, run_time = 5),\n",
        "            morty.change, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(light_indicator.reading),\n",
        "            FadeIn(limit_reading),\n",
        "            morty.change, \"confused\",\n",
        "        )\n",
        "        self.play(Write(equals_sign))\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_rearrangements(self):\n",
        "        light_sources = self.light_sources\n",
        "        origin = self.number_line.number_to_point(0)\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Rotate, light_sources,\n",
        "                lambda m : (m, (2*random.random()-1)*90*DEGREES),\n",
        "                about_point = origin, \n",
        "                rate_func = lambda t : wiggle(t, 4),\n",
        "                run_time = 10,\n",
        "                lag_ratio = 0.9,\n",
        "            ), \n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "\n",
        "class RearrangeWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Rearrange without changing \\\\\\\\ the apparent brightness\")\n",
        "        self.play(Write(words))\n",
        "        self.wait(5)\n",
        "\n",
        "class ThatJustSeemsUseless(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"How would \\\\\\\\ that help?\",\n",
        "            target_mode = \"sassy\",\n",
        "            index = 2,\n",
        "            bubble_config = {\"direction\" : LEFT},\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"guilty\",\n",
        "            self.change_students(*3*['sassy'])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutBrightness(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 200,\n",
        "        \"radius\" : 10,\n",
        "    }\n",
        "    def construct(self):\n",
        "        light_source = LightSource(\n",
        "            num_levels = self.num_levels,\n",
        "            radius = self.radius,\n",
        "            opacity_function = inverse_quadratic(1,2,1),\n",
        "        )\n",
        "        light_source.lighthouse.scale(0.5, about_edge = UP)\n",
        "        light_source.move_source_to(5*LEFT + 2*UP)\n",
        "\n",
        "        self.add_foreground_mobjects(self.pi_creatures)\n",
        "        self.student_says(\n",
        "            \"What do you mean \\\\\\\\ by ``brightness''?\",\n",
        "            added_anims = [\n",
        "                SwitchOn(light_source.ambient_light),\n",
        "                Animation(light_source.lighthouse)\n",
        "            ]\n",
        "        )\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(4)\n",
        "\n",
        "class IntroduceScreen(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 100,\n",
        "        \"radius\" : 10,\n",
        "        \"num_rays\" : 250,\n",
        "        \"min_ray_angle\" : 0,\n",
        "        \"max_ray_angle\" : TAU,\n",
        "        \"source_point\" : 2.5*LEFT,\n",
        "        \"observer_point\" : 3.5*RIGHT,\n",
        "        \"screen_height\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_elements()\n",
        "        self.setup_angle() # spotlight and angle msmt change when screen rotates\n",
        "        self.rotate_screen()\n",
        "        # self.morph_lighthouse_into_sun()\n",
        "\n",
        "    def setup_elements(self):\n",
        "        SCREEN_SIZE = 3.0\n",
        "        source_point = self.source_point\n",
        "        observer_point = self.observer_point,\n",
        "\n",
        "        # Light source\n",
        "        light_source = self.light_source = self.get_light_source()\n",
        "\n",
        "        # Screen\n",
        "\n",
        "        screen = self.screen = Rectangle(\n",
        "            width = 0.05,\n",
        "            height = self.screen_height,\n",
        "            mark_paths_closed = True,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1.0,\n",
        "            stroke_width = 0.0\n",
        "        )\n",
        "\n",
        "        screen.next_to(observer_point, LEFT)\n",
        "\n",
        "        screen_label = OldTexText(\"Screen\")\n",
        "        screen_label.next_to(screen, UP+LEFT)\n",
        "        screen_arrow = Arrow(\n",
        "            screen_label.get_bottom(),\n",
        "            screen.get_center(),\n",
        "        )\n",
        "\n",
        "        # Pi creature\n",
        "        morty = Mortimer()\n",
        "        morty.shift(screen.get_center() - morty.eyes.get_left())\n",
        "        morty.look_at(source_point)\n",
        "\n",
        "        # Camera\n",
        "        camera = SVGMobject(file_name = \"camera\")\n",
        "        camera.rotate(TAU/4)\n",
        "        camera.set_height(1.5)\n",
        "        camera.move_to(morty.eyes, LEFT)\n",
        "\n",
        "        # Animations\n",
        "        light_source.set_max_opacity_spotlight(0.001)\n",
        "        screen_tracker = self.screen_tracker = ScreenTracker(light_source)\n",
        "\n",
        "        self.add(light_source.lighthouse)\n",
        "        self.play(SwitchOn(light_source.ambient_light))\n",
        "        self.play(\n",
        "            Write(screen_label),\n",
        "            GrowArrow(screen_arrow),\n",
        "            FadeIn(screen)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [screen_label, screen_arrow])))\n",
        "        screen.save_state()\n",
        "        self.play(\n",
        "            FadeIn(morty),\n",
        "            screen.match_height, morty.eyes,\n",
        "            screen.next_to, morty.eyes, LEFT, SMALL_BUFF\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeOut(morty),\n",
        "            FadeIn(camera),\n",
        "            screen.scale, 2, {\"about_edge\" : UP},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(camera),\n",
        "            screen.restore,\n",
        "        )\n",
        "\n",
        "        light_source.set_screen(screen)\n",
        "        light_source.spotlight.opacity_function = lambda r : 0.2/(r+1)\n",
        "        screen_tracker.update(0)\n",
        "\n",
        "        ## Ask about proportion\n",
        "        self.add_foreground_mobjects(light_source.shadow, screen)\n",
        "        self.shoot_rays()\n",
        "\n",
        "        ##\n",
        "        self.play(SwitchOn(light_source.spotlight))\n",
        "\n",
        "    def setup_angle(self):\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # angle msmt (arc)\n",
        "        arc_angle = self.light_source.spotlight.opening_angle()\n",
        "        # draw arc arrows to show the opening angle\n",
        "        self.angle_arc = Arc(\n",
        "            radius = 3, \n",
        "            start_angle = self.light_source.spotlight.start_angle(),\n",
        "            angle = self.light_source.spotlight.opening_angle(),\n",
        "            tip_length = ARC_TIP_LENGTH\n",
        "        )\n",
        "        #angle_arc.add_tip(at_start = True, at_end = True)\n",
        "        self.angle_arc.move_arc_center_to(self.light_source.get_source_point())\n",
        "        \n",
        "\n",
        "        # angle msmt (decimal number)\n",
        "\n",
        "        self.angle_indicator = DecimalNumber(\n",
        "            arc_angle / DEGREES,\n",
        "            num_decimal_places = 0,\n",
        "            unit = \"^\\\\circ\"\n",
        "        )\n",
        "        self.angle_indicator.next_to(self.angle_arc, RIGHT)\n",
        "\n",
        "        angle_update_func = lambda x: self.light_source.spotlight.opening_angle() / DEGREES\n",
        "        self.angle_indicator.add_updater(\n",
        "            lambda d: d.set_value(angle_update_func())\n",
        "        )\n",
        "        self.add(self.angle_indicator)\n",
        "\n",
        "        arc_tracker = AngleUpdater(\n",
        "            self.angle_arc,\n",
        "            self.light_source.spotlight\n",
        "        )\n",
        "        self.add(arc_tracker)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.angle_arc),\n",
        "            ShowCreation(self.angle_indicator)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def rotate_screen(self):\n",
        "        self.add(\n",
        "            Mobject.add_updater(\n",
        "                self.light_source,\n",
        "                lambda m : m.update()\n",
        "            ),\n",
        "        )\n",
        "        self.add(\n",
        "            Mobject.add_updater(\n",
        "                self.angle_indicator,\n",
        "                lambda m : m.set_stroke(width = 0).set_fill(opacity = 1)\n",
        "            )\n",
        "        )\n",
        "        self.remove(self.light_source.ambient_light)\n",
        "        def rotate_screen(angle):\n",
        "            self.play(\n",
        "                Rotate(self.light_source.spotlight.screen, angle),\n",
        "                Animation(self.angle_arc),\n",
        "                run_time = 2,\n",
        "            )\n",
        "        for angle in TAU/8, -TAU/4, TAU/8, -TAU/6:\n",
        "            rotate_screen(angle)\n",
        "            self.wait()\n",
        "        self.shoot_rays()\n",
        "        rotate_screen(TAU/6)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_light_source(self):\n",
        "        light_source = LightSource(\n",
        "            opacity_function = inverse_quadratic(1,2,1),\n",
        "            num_levels = self.num_levels,\n",
        "            radius = self.radius,\n",
        "            max_opacity_ambient = AMBIENT_FULL,\n",
        "        )\n",
        "        light_source.move_source_to(self.source_point)\n",
        "        return light_source\n",
        "\n",
        "    def shoot_rays(self, show_creation_kwargs = None):\n",
        "        if show_creation_kwargs is None:\n",
        "            show_creation_kwargs = {}\n",
        "        source_point = self.source_point\n",
        "        screen = self.screen\n",
        "\n",
        "        # Rays \n",
        "        step_size = (self.max_ray_angle - self.min_ray_angle)/self.num_rays\n",
        "        rays = VGroup(*[\n",
        "            Line(ORIGIN, self.radius*rotate_vector(RIGHT, angle))\n",
        "            for angle in np.arange(\n",
        "                self.min_ray_angle,\n",
        "                self.max_ray_angle,\n",
        "                step_size\n",
        "            )\n",
        "        ])\n",
        "        rays.shift(source_point)\n",
        "        rays.set_stroke(YELLOW, 1)\n",
        "        max_angle = np.max([\n",
        "            angle_of_vector(point - source_point)\n",
        "            for point in screen.get_points()\n",
        "        ])\n",
        "        min_angle = np.min([\n",
        "            angle_of_vector(point - source_point)\n",
        "            for point in screen.get_points()\n",
        "        ])\n",
        "        for ray in rays:\n",
        "            if min_angle <= ray.get_angle() <= max_angle:\n",
        "                ray.target_color = GREEN\n",
        "            else:\n",
        "                ray.target_color = RED\n",
        "\n",
        "        self.play(*[\n",
        "            ShowCreation(ray, run_time = 3, **show_creation_kwargs)\n",
        "            for ray in rays\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ApplyMethod(ray.set_color, ray.target_color)\n",
        "            for ray in rays\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rays))\n",
        "\n",
        "class EarthScene(IntroduceScreen):\n",
        "    CONFIG = {\n",
        "        \"screen_height\" : 0.5,\n",
        "        \"screen_thickness\" : 0,\n",
        "        \"radius\" : 100 + FRAME_X_RADIUS,\n",
        "        \"source_point\" : 100*LEFT,\n",
        "        \"min_ray_angle\" : -1.65*DEGREES,\n",
        "        \"max_ray_angle\" : 1.65*DEGREES,\n",
        "        \"num_rays\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        # Earth\n",
        "        earth_radius = 3\n",
        "        earth = ImageMobject(\"earth\")\n",
        "        earth_circle = Circle(radius = earth_radius)\n",
        "        earth_circle.to_edge(RIGHT)\n",
        "        earth.replace(earth_circle)\n",
        "\n",
        "        black_rect = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = earth_radius + LARGE_BUFF,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1\n",
        "        )\n",
        "        black_rect.move_to(earth.get_center(), LEFT)\n",
        "\n",
        "        self.add_foreground_mobjects(black_rect, earth)\n",
        "\n",
        "        # screen\n",
        "        screen = self.screen = Line(\n",
        "            self.screen_height*UP, ORIGIN,\n",
        "            stroke_color = WHITE, \n",
        "            stroke_width = self.screen_thickness,\n",
        "        )\n",
        "        screen.move_to(earth.get_left())\n",
        "        screen.generate_target()\n",
        "        screen.target.rotate(\n",
        "            -60*DEGREES, about_point = earth_circle.get_center()\n",
        "        )\n",
        "\n",
        "        equator_arrow = Vector(\n",
        "            DOWN+2*RIGHT, color = WHITE,\n",
        "        )\n",
        "        equator_arrow.next_to(screen.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "        pole_arrow = Vector(\n",
        "            UP+3*RIGHT, \n",
        "            color = WHITE,\n",
        "            path_arc = -60*DEGREES,\n",
        "        )\n",
        "        pole_arrow.shift(\n",
        "            screen.target.get_center()+SMALL_BUFF*LEFT - \\\n",
        "            pole_arrow.get_end()\n",
        "        )\n",
        "        for arrow in equator_arrow, pole_arrow:\n",
        "            arrow.pointwise_become_partial(arrow, 0, 0.95)\n",
        "        equator_words = OldTexText(\"Some\", \"unit of area\")\n",
        "        pole_words = OldTexText(\"The same\\\\\\\\\", \"unit of area\")\n",
        "        pole_words.next_to(pole_arrow.get_start(), DOWN)\n",
        "        equator_words.next_to(equator_arrow.get_start(), UP)\n",
        "\n",
        "\n",
        "        # Light source (far-away Sun)\n",
        "\n",
        "        sun = sun = LightSource(\n",
        "            opacity_function = lambda r : 0.5,\n",
        "            max_opacity_ambient = 0,\n",
        "            max_opacity_spotlight = 0.5,\n",
        "            num_levels = 5,\n",
        "            radius = self.radius,\n",
        "            screen = screen\n",
        "        )\n",
        "        sun.move_source_to(self.source_point)\n",
        "        sunlight = sun.spotlight\n",
        "        sunlight.opacity_function = lambda r : 5./(r+1)\n",
        "\n",
        "        screen_tracker = ScreenTracker(sun)\n",
        "\n",
        "        # Add elements to scene\n",
        "\n",
        "        self.add(screen)\n",
        "        self.play(SwitchOn(\n",
        "            sunlight, \n",
        "            rate_func = squish_rate_func(smooth, 0.7, 0.8),\n",
        "        ))\n",
        "        self.add(screen_tracker)\n",
        "        self.play(\n",
        "            Write(equator_words),\n",
        "            GrowArrow(equator_arrow)\n",
        "        )\n",
        "        self.add_foreground_mobjects(equator_words, equator_arrow)\n",
        "        self.shoot_rays(show_creation_kwargs = {\n",
        "            \"rate_func\" : lambda t : interpolate(0.98, 1, smooth(t))\n",
        "        })\n",
        "        self.wait()\n",
        "        # Point to patch\n",
        "        self.play(\n",
        "            MoveToTarget(screen),\n",
        "            Transform(equator_arrow, pole_arrow),\n",
        "            Transform(\n",
        "                equator_words, pole_words, \n",
        "                rate_func = squish_rate_func(smooth, 0.6, 1),\n",
        "            ),\n",
        "            Animation(sunlight),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.shoot_rays(show_creation_kwargs = {\n",
        "            \"rate_func\" : lambda t : interpolate(0.98, 1, smooth(t))\n",
        "        })\n",
        "        self.wait()\n",
        "\n",
        "class ShowLightInThreeDimensions(IntroduceScreen, ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 200,\n",
        "    }\n",
        "    def construct(self):\n",
        "        light_source = self.get_light_source()\n",
        "        screens = VGroup(\n",
        "            Square(),\n",
        "            RegularPolygon(8),\n",
        "            Circle().insert_n_curves(25),\n",
        "        )\n",
        "        for screen in screens:\n",
        "            screen.set_height(self.screen_height)\n",
        "        screens.rotate(TAU/4, UP)\n",
        "        screens.next_to(self.observer_point, LEFT)\n",
        "        screens.set_stroke(WHITE, 2)\n",
        "        screens.set_fill(WHITE, 0.5)\n",
        "        screen = screens[0]\n",
        "\n",
        "        cone = ThreeDSpotlight(\n",
        "            screen, light_source.ambient_light,\n",
        "            light_source.get_source_point\n",
        "        )\n",
        "        cone_update_anim = ContinualThreeDLightConeUpdate(cone)\n",
        "\n",
        "        self.add(light_source, screen, cone)\n",
        "        self.add(cone_update_anim)\n",
        "        self.move_camera(\n",
        "            phi = 60*DEGREES,\n",
        "            theta = -155*DEGREES,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        kwargs = {\"run_time\" : 2}\n",
        "        self.play(screen.stretch, 0.5, 1, **kwargs)\n",
        "        self.play(screen.stretch, 2, 2, **kwargs)\n",
        "        self.play(Rotate(\n",
        "            screen, TAU/4, \n",
        "            axis = UP+OUT, \n",
        "            rate_func = there_and_back, \n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.play(Transform(screen, screens[1], **kwargs))\n",
        "        self.play(screen.stretch, 0.5, 2, **kwargs)\n",
        "        self.play(Transform(screen, screens[2], **kwargs))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            screen.stretch, 0.5, 1, \n",
        "            screen.stretch, 2, 2, \n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            screen.stretch, 3, 1, \n",
        "            screen.stretch, 0.7, 2, \n",
        "            **kwargs\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class LightInThreeDimensionsOverlay(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            ``Solid angle'' \\\\\\\\\n",
        "            (measured in ``steradians'')\n",
        "        \"\"\")\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class InverseSquareLaw(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"screen_height\" : 1.0,\n",
        "        \"source_point\" : 5*LEFT,\n",
        "        \"unit_distance\" : 4,\n",
        "        \"num_levels\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.move_screen_farther_away()\n",
        "        self.morph_into_3d()\n",
        "\n",
        "    def move_screen_farther_away(self):\n",
        "        source_point = self.source_point\n",
        "        unit_distance = self.unit_distance\n",
        "\n",
        "        # screen\n",
        "        screen = self.screen = Line(self.screen_height*UP, ORIGIN)\n",
        "        screen.get_reference_point = screen.get_center\n",
        "        screen.shift(\n",
        "            source_point + unit_distance*RIGHT -\\\n",
        "            screen.get_reference_point()\n",
        "        )\n",
        "        \n",
        "        # light source\n",
        "        light_source = self.light_source = LightSource(\n",
        "            # opacity_function = inverse_quadratic(1,5,1),\n",
        "            opacity_function = lambda r : 1./(r+1),\n",
        "            num_levels = self.num_levels,\n",
        "            radius = 10,\n",
        "            max_opacity = 0.2\n",
        "        )\n",
        "        light_source.set_max_opacity_spotlight(0.2)\n",
        "\n",
        "        light_source.set_screen(screen)\n",
        "        light_source.move_source_to(source_point)\n",
        "\n",
        "        # abbreviations\n",
        "        ambient_light = light_source.ambient_light\n",
        "        spotlight = light_source.spotlight\n",
        "        lighthouse = light_source.lighthouse\n",
        "        shadow = light_source.shadow\n",
        "\n",
        "        # Morty\n",
        "        morty = self.morty = Mortimer().scale(0.3)\n",
        "        morty.next_to(screen, RIGHT, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        #Screen tracker\n",
        "        def update_spotlight(spotlight):\n",
        "            spotlight.update_sectors()\n",
        "\n",
        "        spotlight_update = Mobject.add_updater(spotlight, update_spotlight)\n",
        "        shadow_update = Mobject.add_updater(\n",
        "            shadow, lambda m : light_source.update_shadow()\n",
        "        )\n",
        "\n",
        "        # Light indicator\n",
        "        light_indicator = self.light_indicator = LightIndicator(\n",
        "            opacity_for_unit_intensity = 0.5,\n",
        "        )\n",
        "        def update_light_indicator(light_indicator):\n",
        "            distance = get_norm(screen.get_reference_point() - source_point)\n",
        "            light_indicator.set_intensity(1.0/(distance/unit_distance)**2)\n",
        "            light_indicator.next_to(morty, UP, MED_LARGE_BUFF)\n",
        "        light_indicator_update = Mobject.add_updater(\n",
        "            light_indicator, update_light_indicator\n",
        "        )\n",
        "        light_indicator_update.update(0)\n",
        "\n",
        "        continual_updates = self.continual_updates = [\n",
        "            spotlight_update, light_indicator_update, shadow_update\n",
        "        ]\n",
        "\n",
        "        # Distance indicators\n",
        "\n",
        "        one_arrow = DoubleArrow(ORIGIN, unit_distance*RIGHT, buff = 0)\n",
        "        two_arrow = DoubleArrow(ORIGIN, 2*unit_distance*RIGHT, buff = 0)\n",
        "        arrows = VGroup(one_arrow, two_arrow)\n",
        "        arrows.set_color(WHITE)\n",
        "        one_arrow.move_to(source_point + DOWN, LEFT)\n",
        "        two_arrow.move_to(source_point + 1.75*DOWN, LEFT)\n",
        "        one = Integer(1).next_to(one_arrow, UP, SMALL_BUFF)\n",
        "        two = Integer(2).next_to(two_arrow, DOWN, SMALL_BUFF)\n",
        "        arrow_group = VGroup(one_arrow, one, two_arrow, two)\n",
        "\n",
        "        # Animations\n",
        "\n",
        "        self.add_foreground_mobjects(lighthouse, screen, morty)\n",
        "        self.add(shadow_update)\n",
        "\n",
        "        self.play(\n",
        "            SwitchOn(ambient_light),\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.play(\n",
        "            SwitchOn(spotlight),\n",
        "            FadeIn(light_indicator)\n",
        "        )\n",
        "        # self.remove(spotlight)\n",
        "        self.add(*continual_updates)\n",
        "        self.wait()\n",
        "        for distance in -0.5, 0.5:\n",
        "            self.shift_by_distance(distance)\n",
        "            self.wait()\n",
        "        self.add_foreground_mobjects(one_arrow, one)\n",
        "        self.play(GrowFromCenter(one_arrow), Write(one))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(two_arrow, two)\n",
        "        self.shift_by_distance(1,\n",
        "            GrowFromPoint(two_arrow, two_arrow.get_left()),\n",
        "            Write(two, rate_func = squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.next_to(light_indicator, UP)\n",
        "        self.play(\n",
        "            Write(q_marks),\n",
        "            morty.change, \"confused\", q_marks\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(FadeOut(q_marks), morty.change, \"pondering\")\n",
        "        self.wait()\n",
        "        self.shift_by_distance(-1, arrow_group.shift, DOWN)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            ambient_light, spotlight, shadow, lighthouse,\n",
        "            morty, arrow_group,\n",
        "            *continual_updates\n",
        "        )\n",
        "\n",
        "    def morph_into_3d(self):\n",
        "        # axes = ThreeDAxes()\n",
        "        old_screen = self.screen\n",
        "        spotlight = self.spotlight\n",
        "        source_point = self.source_point\n",
        "        ambient_light = self.ambient_light\n",
        "        unit_distance = self.unit_distance\n",
        "        light_indicator = self.light_indicator\n",
        "        morty = self.morty\n",
        "\n",
        "        new_screen = Square(\n",
        "            side_length = self.screen_height,\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 1,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 0.5\n",
        "        )\n",
        "        new_screen.rotate(TAU/4, UP)\n",
        "        new_screen.move_to(old_screen, IN)\n",
        "        old_screen.fade(1)\n",
        "\n",
        "        cone = ThreeDSpotlight(\n",
        "            new_screen, ambient_light,\n",
        "            source_point_func = lambda : source_point\n",
        "        )\n",
        "        cone_update_anim = ContinualThreeDLightConeUpdate(cone)\n",
        "\n",
        "\n",
        "        self.remove(self.spotlight_update, self.light_indicator_update)\n",
        "        self.add(\n",
        "            ContinualAnimation(new_screen),\n",
        "            cone_update_anim\n",
        "        )\n",
        "        self.remove(spotlight)\n",
        "        self.move_camera(\n",
        "            phi = 60*DEGREES,\n",
        "            theta = -145*DEGREES,\n",
        "            added_anims = [\n",
        "                # ApplyMethod(\n",
        "                #     old_screen.scale, 1.8, {\"about_edge\" : DOWN},\n",
        "                #     run_time = 2,\n",
        "                # ),\n",
        "                ApplyFunction(\n",
        "                    lambda m : m.fade(1).shift(1.5*DOWN),\n",
        "                    light_indicator,\n",
        "                    remover = True\n",
        "                ),\n",
        "                FadeOut(morty)\n",
        "            ],\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ## Create screen copies\n",
        "        def get_screen_copy_group(distance):\n",
        "            n = int(distance)**2\n",
        "            copies = VGroup(*[new_screen.copy() for x in range(n)])\n",
        "            copies.rotate(-TAU/4, axis = UP)\n",
        "            copies.arrange_in_grid(buff = 0)\n",
        "            copies.rotate(TAU/4, axis = UP)\n",
        "            copies.move_to(source_point, IN)\n",
        "            copies.shift(distance*RIGHT*unit_distance)\n",
        "            return copies\n",
        "        screen_copy_groups = list(map(get_screen_copy_group, list(range(1, 8))))\n",
        "        def get_screen_copy_group_anim(n):\n",
        "            group = screen_copy_groups[n]\n",
        "            prev_group = screen_copy_groups[n-1]\n",
        "            group.save_state()\n",
        "            group.fade(1)\n",
        "            group.replace(prev_group, dim_to_match = 1)\n",
        "            return ApplyMethod(group.restore)\n",
        "\n",
        "        # corner_directions = [UP+OUT, DOWN+OUT, DOWN+IN, UP+IN]\n",
        "        # edge_directions = [\n",
        "        #     UP, UP+OUT, OUT, DOWN+OUT, DOWN, DOWN+IN, IN, UP+IN, ORIGIN\n",
        "        # ]\n",
        "\n",
        "        # four_copies = VGroup(*[new_screen.copy() for x in range(4)])\n",
        "        # nine_copies = VGroup(*[new_screen.copy() for x in range(9)])\n",
        "        # def update_four_copies(four_copies):\n",
        "        #     for mob, corner_direction in zip(four_copies, corner_directions):\n",
        "        #         mob.move_to(new_screen, corner_direction)\n",
        "        # four_copies_update_anim = UpdateFromFunc(four_copies, update_four_copies)\n",
        "        # def update_nine_copies(nine_copies):\n",
        "        #     for mob, corner_direction in zip(nine_copies, edge_directions):\n",
        "        #         mob.move_to(new_screen, corner_direction)\n",
        "        # nine_copies_update_anim = UpdateFromFunc(nine_copies, update_nine_copies)\n",
        "\n",
        "        three_arrow = DoubleArrow(\n",
        "            source_point + 4*DOWN,\n",
        "            source_point + 4*DOWN + 3*unit_distance*RIGHT,\n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "        three = Integer(3)\n",
        "        three.next_to(three_arrow, DOWN)\n",
        "\n",
        "        new_screen.fade(1)\n",
        "        # self.add(\n",
        "        #     ContinualAnimation(screen_copy),\n",
        "        #     ContinualAnimation(four_copies),\n",
        "        # )\n",
        "\n",
        "        self.add(ContinualAnimation(screen_copy_groups[0]))\n",
        "        self.add(ContinualAnimation(screen_copy_groups[1]))\n",
        "        self.play(\n",
        "            new_screen.scale, 2, {\"about_edge\" : IN},\n",
        "            new_screen.shift, unit_distance*RIGHT,\n",
        "            get_screen_copy_group_anim(1),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_camera(\n",
        "            phi = 75*DEGREES,\n",
        "            theta = -155*DEGREES,\n",
        "            distance = 7,\n",
        "            run_time = 10,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate = -0.01)\n",
        "        self.add(ContinualAnimation(screen_copy_groups[2]))\n",
        "        self.play(\n",
        "            new_screen.scale, 3./2, {\"about_edge\" : IN},\n",
        "            new_screen.shift, unit_distance*RIGHT,\n",
        "            get_screen_copy_group_anim(2),\n",
        "            GrowFromPoint(three_arrow, three_arrow.get_left()),\n",
        "            Write(three, rate_func = squish_rate_func(smooth, 0.5, 1)),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate = -0.01)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, screen_copy_groups[2],\n",
        "            lambda m : (m.set_color, RED),\n",
        "            run_time = 5,\n",
        "            rate_func = there_and_back,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.move_camera(distance = 18)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 1)\n",
        "            for mob in screen_copy_groups[:2]\n",
        "        ])\n",
        "        last_group = screen_copy_groups[2]\n",
        "        for n in range(4, len(screen_copy_groups)+1):\n",
        "            group = screen_copy_groups[n-1]\n",
        "            self.add(ContinualAnimation(group))\n",
        "            self.play(\n",
        "                new_screen.scale, float(n)/(n-1), {\"about_edge\" : IN},\n",
        "                new_screen.shift, unit_distance*RIGHT,\n",
        "                get_screen_copy_group_anim(n-1),\n",
        "                last_group.fade, 1,\n",
        "            )\n",
        "            last_group = group\n",
        "            self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def shift_by_distance(self, distance, *added_anims):\n",
        "        anims = [\n",
        "            self.screen.shift, self.unit_distance*distance*RIGHT,\n",
        "        ]\n",
        "        if self.morty in self.mobjects:\n",
        "            anims.append(MaintainPositionRelativeTo(self.morty, self.screen))\n",
        "        anims += added_anims\n",
        "        self.play(*anims, run_time = 2)\n",
        "\n",
        "class OtherInstanceOfInverseSquareLaw(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Where the inverse square law shows up\")\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "\n",
        "        items = VGroup(*[\n",
        "            OldTexText(\"- %s\"%s).scale(1)\n",
        "            for s in [\n",
        "                \"Heat\", \"Sound\", \"Radio waves\", \"Electric fields\",\n",
        "            ]\n",
        "        ])\n",
        "        items.arrange(DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT)\n",
        "        items.next_to(h_line, DOWN, LARGE_BUFF)\n",
        "        items.to_edge(LEFT)\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.move_to(4*RIGHT)\n",
        "        self.add(dot)\n",
        "        def get_broadcast():\n",
        "            return Broadcast(dot, big_radius = 5, run_time = 5)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, items, run_time = 4, lag_ratio = 0.7),\n",
        "            Succession(*[\n",
        "                get_broadcast()\n",
        "                for x in range(2)\n",
        "            ])\n",
        "        )\n",
        "        self.play(get_broadcast())\n",
        "        self.wait()\n",
        "\n",
        "class ScreensIntroWrapper(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        point = VectorizedPoint(FRAME_X_RADIUS*LEFT/2 + FRAME_Y_RADIUS*UP/2)\n",
        "        self.play(self.teacher.change, \"raise_right_hand\")\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"erm\", \"confused\",\n",
        "            look_at = point,\n",
        "        )\n",
        "        self.play(self.teacher.look_at, point)\n",
        "        self.wait(5)\n",
        "\n",
        "class ManipulateLightsourceSetups(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 100,\n",
        "        \"radius\" : 10,\n",
        "        \"pi_creature_point\" : 2*LEFT + 2*DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        unit_distance = 3\n",
        "\n",
        "        # Morty\n",
        "        morty = self.pi_creature\n",
        "        observer_point = morty.eyes[1].get_center()\n",
        "\n",
        "        bubble = ThoughtBubble(height = 3, width = 4, direction = RIGHT)\n",
        "        bubble.set_fill(BLACK, 1)\n",
        "        bubble.pin_to(morty)\n",
        "\n",
        "        # Indicator\n",
        "        light_indicator = LightIndicator(\n",
        "            opacity_for_unit_intensity = 0.5,\n",
        "            fill_color = YELLOW,\n",
        "            radius = 0.4,\n",
        "            reading_height = 0.2,\n",
        "        )\n",
        "        light_indicator.move_to(bubble.get_bubble_center())\n",
        "        def update_light_indicator(light_indicator):\n",
        "            distance = get_norm(light_source.get_source_point()-observer_point)\n",
        "            light_indicator.set_intensity((unit_distance/distance)**2)\n",
        "\n",
        "        #Light source\n",
        "        light_source = LightSource(\n",
        "            opacity_function = inverse_quadratic(1,2,1),\n",
        "            num_levels = self.num_levels,\n",
        "            radius = self.radius,\n",
        "            max_opacity_ambient = AMBIENT_FULL,\n",
        "        )\n",
        "        light_source.move_to(observer_point + unit_distance*RIGHT)\n",
        "\n",
        "        #Light source copies\n",
        "        light_source_copies = VGroup(*[light_source.copy() for x in range(2)])\n",
        "        for lsc, vect in zip(light_source_copies, [RIGHT, UP]):\n",
        "            lsc.move_to(observer_point + np.sqrt(2)*unit_distance*vect)\n",
        "\n",
        "        self.add(light_source)\n",
        "        self.add_foreground_mobjects(morty, bubble, light_indicator)\n",
        "        self.add(Mobject.add_updater(light_indicator, update_light_indicator))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                light_source.shift, 0.66*unit_distance*LEFT,\n",
        "                rate_func = wiggle,\n",
        "                run_time = 5,\n",
        "            ),\n",
        "            morty.change, \"erm\",\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                light_source, \n",
        "                lambda ls, a : ls.move_to(\n",
        "                    observer_point + rotate_vector(\n",
        "                        unit_distance*RIGHT, (1+1./8)*a*TAU\n",
        "                    )\n",
        "                ),\n",
        "                run_time = 6,\n",
        "                rate_func = bezier([0, 0, 1, 1])\n",
        "            ),\n",
        "            morty.change, \"pondering\",\n",
        "            UpdateFromFunc(morty, lambda m : m.look_at(light_source))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        plus = OldTex(\"+\")\n",
        "        point = light_indicator.get_center()\n",
        "        plus.move_to(point)\n",
        "        light_indicator_copy = light_indicator.copy()\n",
        "        self.add_foreground_mobjects(plus, light_indicator_copy)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                light_source, light_source_copies[0]\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                light_source.copy().fade(1), \n",
        "                light_source_copies[1]\n",
        "            ),\n",
        "            FadeIn(plus),\n",
        "            UpdateFromFunc(\n",
        "                light_indicator_copy,\n",
        "                lambda li : update_light_indicator(li),\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                light_indicator, lambda m, a : m.move_to(\n",
        "                    point + a*0.75*RIGHT,\n",
        "                )\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                light_indicator_copy, lambda m, a : m.move_to(\n",
        "                    point + a*0.75*LEFT,\n",
        "                )\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(morty.change, \"hooray\")\n",
        "        self.wait(2)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.scale(0.5)\n",
        "        morty.move_to(self.pi_creature_point)\n",
        "        return morty\n",
        "\n",
        "class TwoLightSourcesScene(ManipulateLightsourceSetups):\n",
        "    CONFIG = {\n",
        "        \"num_levels\" : 200,\n",
        "        \"radius\" : 15,\n",
        "        \"a\" : 9,\n",
        "        \"b\" : 5,\n",
        "        \"origin_point\" : 5*LEFT + 2.5*DOWN\n",
        "    }\n",
        "    def construct(self):\n",
        "        MAX_OPACITY = 0.4\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        OPACITY_FOR_UNIT_INTENSITY = 0.5\n",
        "        origin_point = self.origin_point\n",
        "\n",
        "        #Morty\n",
        "        morty = self.pi_creature\n",
        "        morty.change(\"hooray\") # From last scen\n",
        "        morty.generate_target()\n",
        "        morty.target.change(\"plain\")\n",
        "        morty.target.scale(0.6)\n",
        "        morty.target.next_to(\n",
        "            origin_point, LEFT, buff = 0, \n",
        "            submobject_to_align = morty.target.eyes[1]\n",
        "        )\n",
        "\n",
        "        #Axes\n",
        "        axes = Axes(\n",
        "            x_min = -1, x_max = 10.5,\n",
        "            y_min = -1, y_max = 6.5,\n",
        "        )\n",
        "        axes.shift(origin_point)\n",
        "\n",
        "        #Important reference points\n",
        "        A = axes.coords_to_point(self.a, 0)\n",
        "        B = axes.coords_to_point(0, self.b)\n",
        "        C = axes.coords_to_point(0, 0)\n",
        "        xA = A[0]\n",
        "        yA = A[1]\n",
        "        xB = B[0]\n",
        "        yB = B[1]\n",
        "        xC = C[0]\n",
        "        yC = C[1]\n",
        "        # find the coords of the altitude point H\n",
        "        # as the solution of a certain LSE\n",
        "        prelim_matrix = np.array([\n",
        "            [yA - yB, xB - xA], \n",
        "            [xA - xB, yA - yB]\n",
        "        ]) # sic\n",
        "        prelim_vector = np.array(\n",
        "            [xB * yA - xA * yB, xC * (xA - xB) + yC * (yA - yB)]\n",
        "        )\n",
        "        H2 = np.linalg.solve(prelim_matrix, prelim_vector)\n",
        "        H = np.append(H2, 0.)\n",
        "\n",
        "        #Lightsources\n",
        "        lsA = LightSource(\n",
        "            radius = self.radius, \n",
        "            num_levels = self.num_levels,\n",
        "            opacity_function = inverse_power_law(2, 1, 1, 1.5),\n",
        "        )\n",
        "        lsB = lsA.deepcopy()\n",
        "        lsA.move_source_to(A)\n",
        "        lsB.move_source_to(B)\n",
        "        lsC = lsA.deepcopy()\n",
        "        lsC.move_source_to(H)\n",
        "\n",
        "        #Lighthouse labels\n",
        "        A_label = OldTexText(\"A\")\n",
        "        A_label.next_to(lsA.lighthouse, RIGHT)\n",
        "        B_label = OldTexText(\"B\")\n",
        "        B_label.next_to(lsB.lighthouse, LEFT)\n",
        "\n",
        "        #Identical lighthouse labels\n",
        "        identical_lighthouses_words = OldTexText(\"All identical \\\\\\\\ lighthouses\")\n",
        "        identical_lighthouses_words.to_corner(UP+RIGHT)\n",
        "        identical_lighthouses_words.shift(LEFT)\n",
        "        identical_lighthouses_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                identical_lighthouses_words.get_corner(DOWN+LEFT),\n",
        "                ls.get_source_point(), \n",
        "                buff = SMALL_BUFF,\n",
        "                color = WHITE,\n",
        "            )\n",
        "            for ls in (lsA, lsB, lsC)\n",
        "        ])\n",
        "\n",
        "        #Lines\n",
        "        line_a = Line(C, A)\n",
        "        line_a.set_color(BLUE)\n",
        "        line_b = Line(C, B)\n",
        "        line_b.set_color(RED)\n",
        "        line_c = Line(A, B)\n",
        "        line_h = Line(H, C)\n",
        "        line_h.set_color(GREEN)\n",
        "\n",
        "        label_a = OldTex(\"a\")\n",
        "        label_a.match_color(line_a)\n",
        "        label_a.next_to(line_a, DOWN, buff = SMALL_BUFF)\n",
        "        label_b = OldTex(\"b\")\n",
        "        label_b.match_color(line_b)\n",
        "        label_b.next_to(line_b, LEFT, buff = SMALL_BUFF)\n",
        "        label_h = OldTex(\"h\")\n",
        "        label_h.match_color(line_h)\n",
        "        label_h.next_to(line_h.get_center(), RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        perp_mark = VMobject().set_points_as_corners([\n",
        "            RIGHT, RIGHT+DOWN, DOWN\n",
        "        ])\n",
        "        perp_mark.scale(0.25, about_point = ORIGIN)\n",
        "        perp_mark.rotate(line_c.get_angle() + TAU/4, about_point = ORIGIN)\n",
        "        perp_mark.shift(H)\n",
        "        # perp_mark.set_color(BLACK)\n",
        "\n",
        "        #Indicators\n",
        "        indicator = LightIndicator(\n",
        "            color = LIGHT_COLOR,\n",
        "            radius = INDICATOR_RADIUS,\n",
        "            opacity_for_unit_intensity = OPACITY_FOR_UNIT_INTENSITY,\n",
        "            show_reading = True,\n",
        "            precision = 2,\n",
        "        )\n",
        "        indicator.next_to(origin_point, UP+LEFT)\n",
        "        def update_indicator(indicator):\n",
        "            intensity = 0\n",
        "            for ls in lsA, lsB, lsC:\n",
        "                if ls in self.mobjects:\n",
        "                    distance = get_norm(ls.get_source_point() - origin_point)\n",
        "                    d_indensity = fdiv(\n",
        "                        3./(distance**2),\n",
        "                        indicator.opacity_for_unit_intensity\n",
        "                    )\n",
        "                    d_indensity *= ls.ambient_light.submobjects[1].get_fill_opacity()\n",
        "                    intensity += d_indensity\n",
        "            indicator.set_intensity(intensity)\n",
        "        indicator_update_anim = Mobject.add_updater(indicator, update_indicator)\n",
        "\n",
        "        new_indicator = indicator.copy()\n",
        "        new_indicator.light_source = lsC\n",
        "        new_indicator.measurement_point = C\n",
        "\n",
        "        #Note sure what this is...\n",
        "        distance1 = get_norm(origin_point - lsA.get_source_point())\n",
        "        intensity = lsA.ambient_light.opacity_function(distance1) / indicator.opacity_for_unit_intensity\n",
        "        distance2 = get_norm(origin_point - lsB.get_source_point())\n",
        "        intensity += lsB.ambient_light.opacity_function(distance2) / indicator.opacity_for_unit_intensity\n",
        "\n",
        "        # IPT Theorem\n",
        "        theorem = OldTex(\n",
        "            \"{1 \\over \", \"a^2}\", \"+\", \n",
        "            \"{1 \\over\", \"b^2}\", \"=\", \"{1 \\over\",\"h^2}\"\n",
        "        )\n",
        "        theorem.set_color_by_tex_to_color_map({\n",
        "            \"a\" : line_a.get_color(),\n",
        "            \"b\" : line_b.get_color(),\n",
        "            \"h\" : line_h.get_color(),\n",
        "        })\n",
        "        theorem_name = OldTexText(\"Inverse Pythagorean Theorem\")\n",
        "        theorem_name.to_corner(UP+RIGHT)\n",
        "        theorem.next_to(theorem_name, DOWN, buff = MED_LARGE_BUFF)\n",
        "        theorem_box = SurroundingRectangle(theorem, color = WHITE)\n",
        "\n",
        "        #Transition from last_scene\n",
        "        self.play(\n",
        "            ShowCreation(axes, run_time = 2),\n",
        "            MoveToTarget(morty),\n",
        "            FadeIn(indicator),\n",
        "        )\n",
        "\n",
        "        #Move lsC around\n",
        "        self.add(lsC)\n",
        "        indicator_update_anim.update(0)\n",
        "        intensity = indicator.reading.number\n",
        "        self.play(\n",
        "            SwitchOn(lsC.ambient_light),\n",
        "            FadeIn(lsC.lighthouse),\n",
        "            UpdateFromAlphaFunc(\n",
        "                indicator, lambda i, a : i.set_intensity(a*intensity)\n",
        "            )\n",
        "        )\n",
        "        self.add(indicator_update_anim)\n",
        "        self.play(Animation(lsC), run_time = 0) #Why is this needed?\n",
        "        for point in axes.coords_to_point(5, 2), H:\n",
        "            self.play(\n",
        "                lsC.move_source_to, point,\n",
        "                path_arc = TAU/4,\n",
        "                run_time = 1.5,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Draw line\n",
        "        self.play(\n",
        "            ShowCreation(line_h),\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(line_c),\n",
        "            ShowCreation(perp_mark)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(line_c, line_h)\n",
        "\n",
        "        #Add alternate light_sources\n",
        "        for ls in lsA, lsB:\n",
        "            ls.save_state()\n",
        "            ls.move_to(lsC)\n",
        "            ls.fade(1)\n",
        "            self.add(ls)\n",
        "            self.play(\n",
        "                ls.restore, \n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "        A_label.save_state()\n",
        "        A_label.center().fade(1)\n",
        "        self.play(A_label.restore)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            A_label.copy().fade(1), B_label\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Compare combined of laA + lsB with lsC\n",
        "        rect = SurroundingRectangle(indicator, color = RED)\n",
        "        self.play(\n",
        "            FadeOut(lsA),\n",
        "            FadeOut(lsB),\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(FadeOut(lsC))\n",
        "        self.add(lsA, lsB)\n",
        "        self.play(\n",
        "            FadeIn(lsA),\n",
        "            FadeIn(lsB),\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait(2)\n",
        "\n",
        "        # All standard lighthouses\n",
        "        self.add(lsC)\n",
        "        self.play(FadeIn(lsC))\n",
        "        self.play(\n",
        "            Write(identical_lighthouses_words),\n",
        "            LaggedStartMap(GrowArrow, identical_lighthouses_arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            identical_lighthouses_words,\n",
        "            identical_lighthouses_arrows,\n",
        "        ])))\n",
        "\n",
        "        #Show labels of lengths\n",
        "        self.play(ShowCreation(line_a), Write(label_a))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(line_b), Write(label_b))\n",
        "        self.wait()\n",
        "        self.play(Write(label_h))\n",
        "        self.wait()\n",
        "\n",
        "        #Write IPT\n",
        "        a_part = theorem[:2]\n",
        "        b_part = theorem[2:5]\n",
        "        h_part = theorem[5:]\n",
        "        for part in a_part, b_part, h_part:\n",
        "            part.save_state()\n",
        "            part.scale(3)\n",
        "            part.fade(1)\n",
        "        a_part.move_to(lsA)\n",
        "        b_part.move_to(lsB)\n",
        "        h_part.move_to(lsC)\n",
        "\n",
        "        self.play(*list(map(FadeOut, [lsA, lsB, lsC, indicator])))\n",
        "        for ls, part in (lsA, a_part), (lsB, b_part), (lsC, h_part):\n",
        "            self.add(ls)\n",
        "            self.play(\n",
        "                SwitchOn(ls.ambient_light, run_time = 2),\n",
        "                FadeIn(ls.lighthouse),\n",
        "                part.restore\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(theorem_name),\n",
        "            ShowCreation(theorem_box)\n",
        "        )\n",
        "        self.play(morty.change, \"confused\")\n",
        "        self.wait(2)\n",
        "\n",
        "class MathologerVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"\"\"\n",
        "            Mathologer's excellent video on \\\\\\\\\n",
        "            the many Pythagorean theorem cousins\n",
        "        \"\"\")\n",
        "        # title.scale(0.7)\n",
        "        title.to_edge(UP)\n",
        "        logo = ImageMobject(\"mathologer_logo\")\n",
        "        logo.set_height(1)\n",
        "        logo.to_corner(UP+LEFT)\n",
        "        logo.shift(FRAME_WIDTH*RIGHT)\n",
        "        screen = ScreenRectangle(height = 5.5)\n",
        "        screen.next_to(title, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            logo.shift, FRAME_WIDTH*LEFT,\n",
        "            LaggedStartMap(FadeIn, title),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(ShowCreation(screen))\n",
        "        self.wait(5)\n",
        "\n",
        "class SimpleIPTProof(Scene):\n",
        "    def construct(self):\n",
        "        A = 5*RIGHT\n",
        "        B = 3*UP\n",
        "        C = ORIGIN\n",
        "        #Dumb and inefficient\n",
        "        alphas = np.linspace(0, 1, 500)\n",
        "        i = np.argmin([get_norm(interpolate(A, B, a)) for a in alphas])\n",
        "        H = interpolate(A, B, alphas[i])\n",
        "        triangle = VGroup(\n",
        "            Line(C, A, color = BLUE),\n",
        "            Line(C, B, color = RED),\n",
        "            Line(A, B, color = WHITE),\n",
        "            Line(C, H, color = GREEN)\n",
        "        )\n",
        "        for line, char in zip(triangle, [\"a\", \"b\", \"c\", \"h\"]):\n",
        "            label = OldTex(char)\n",
        "            label.match_color(line)\n",
        "            vect = line.get_center() - triangle.get_center()\n",
        "            vect /= get_norm(vect)\n",
        "            label.next_to(line.get_center(), vect)\n",
        "            triangle.add(label)\n",
        "            if char == \"h\":\n",
        "                label.next_to(line.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "\n",
        "        triangle.to_corner(UP+LEFT)\n",
        "        self.add(triangle)\n",
        "\n",
        "        argument_lines = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\text{Area} = \", \n",
        "                \"{1 \\\\over 2}\", \"a\", \"b\", \"=\",\n",
        "                \"{1 \\\\over 2}\", \"c\", \"h\"\n",
        "            ),\n",
        "            OldTex(\"\\\\Downarrow\"),\n",
        "            OldTex(\"a^2\", \"b^2\", \"=\", \"c^2\", \"h^2\"),\n",
        "            OldTex(\"\\\\Downarrow\"),\n",
        "            OldTex(\n",
        "                \"a^2\", \"b^2\", \"=\", \n",
        "                \"(\",  \"a^2\", \"+\", \"b^2\", \")\", \"h^2\"\n",
        "            ),\n",
        "            OldTex(\"\\\\Downarrow\"),\n",
        "            OldTex(\n",
        "                \"{1 \\\\over \", \"h^2}\", \"=\", \n",
        "                \"{1 \\\\over \", \"b^2}\", \"+\", \n",
        "                \"{1 \\\\over \", \"a^2}\",\n",
        "            ),\n",
        "        )\n",
        "        argument_lines.arrange(DOWN)\n",
        "        for line in argument_lines:\n",
        "            line.set_color_by_tex_to_color_map({\n",
        "                \"a\" : BLUE,\n",
        "                \"b\" : RED,\n",
        "                \"h\" : GREEN,\n",
        "                \"Area\" : WHITE,\n",
        "                \"Downarrow\" : WHITE,\n",
        "            })\n",
        "            all_equals = line.get_parts_by_tex(\"=\")\n",
        "            if all_equals:\n",
        "                line.alignment_mob = all_equals[-1]\n",
        "            else:\n",
        "                line.alignment_mob = line[0]\n",
        "            line.shift(-line.alignment_mob.get_center()[0]*RIGHT)\n",
        "        argument_lines.next_to(triangle, RIGHT)\n",
        "        argument_lines.to_edge(UP)\n",
        "\n",
        "        prev_line = argument_lines[0]\n",
        "        self.play(FadeIn(prev_line))\n",
        "        for arrow, line in zip(argument_lines[1::2], argument_lines[2::2]):\n",
        "            line.save_state()\n",
        "            line.shift(\n",
        "                prev_line.alignment_mob.get_center() - \\\n",
        "                line.alignment_mob.get_center() \n",
        "            )\n",
        "            line.fade(1)\n",
        "            self.play(\n",
        "                line.restore,\n",
        "                GrowFromPoint(arrow, arrow.get_top())\n",
        "            )\n",
        "            self.wait()\n",
        "            prev_line = line\n",
        "\n",
        "class WeCanHaveMoreFunThanThat(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        point = VectorizedPoint(FRAME_X_RADIUS*LEFT/2 + FRAME_Y_RADIUS*UP/2)\n",
        "        self.teacher_says(\n",
        "            \"We can have \\\\\\\\ more fun than that!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*3*[\"erm\"], look_at = point)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, \n",
        "                target_mode = \"raise_right_hand\",\n",
        "                look_at = point,\n",
        "            ),\n",
        "            self.change_students(*3*[\"pondering\"], look_at = point)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class IPTScene(TwoLightSourcesScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"max_opacity_ambient\" : 0.2,\n",
        "        \"num_levels\" : 200,\n",
        "    }\n",
        "    def construct(self):\n",
        "        #Copy pasting from TwoLightSourcesScene....Very bad...\n",
        "        origin_point = self.origin_point\n",
        "        self.remove(self.pi_creature)\n",
        "\n",
        "        #Axes\n",
        "        axes = Axes(\n",
        "            x_min = -1, x_max = 10.5,\n",
        "            y_min = -1, y_max = 6.5,\n",
        "        )\n",
        "        axes.shift(origin_point)\n",
        "\n",
        "        #Important reference points\n",
        "        A = axes.coords_to_point(self.a, 0)\n",
        "        B = axes.coords_to_point(0, self.b)\n",
        "        C = axes.coords_to_point(0, 0)\n",
        "        xA = A[0]\n",
        "        yA = A[1]\n",
        "        xB = B[0]\n",
        "        yB = B[1]\n",
        "        xC = C[0]\n",
        "        yC = C[1]\n",
        "        # find the coords of the altitude point H\n",
        "        # as the solution of a certain LSE\n",
        "        prelim_matrix = np.array([\n",
        "            [yA - yB, xB - xA], \n",
        "            [xA - xB, yA - yB]\n",
        "        ]) # sic\n",
        "        prelim_vector = np.array(\n",
        "            [xB * yA - xA * yB, xC * (xA - xB) + yC * (yA - yB)]\n",
        "        )\n",
        "        H2 = np.linalg.solve(prelim_matrix, prelim_vector)\n",
        "        H = np.append(H2, 0.)\n",
        "\n",
        "        #Lightsources\n",
        "        lsA = LightSource(\n",
        "            radius = self.radius, \n",
        "            num_levels = self.num_levels,\n",
        "            opacity_function = inverse_power_law(2, 1, 1, 1.5),\n",
        "            max_opacity_ambient = self.max_opacity_ambient,\n",
        "        )\n",
        "        lsA.lighthouse.scale(0.5, about_edge = UP)\n",
        "        lsB = lsA.deepcopy()\n",
        "        lsA.move_source_to(A)\n",
        "        lsB.move_source_to(B)\n",
        "        lsC = lsA.deepcopy()\n",
        "        lsC.move_source_to(H)\n",
        "\n",
        "        #Lighthouse labels\n",
        "        A_label = OldTexText(\"A\")\n",
        "        A_label.next_to(lsA.lighthouse, RIGHT)\n",
        "        B_label = OldTexText(\"B\")\n",
        "        B_label.next_to(lsB.lighthouse, LEFT)\n",
        "\n",
        "        #Lines\n",
        "        line_a = Line(C, A)\n",
        "        line_a.set_color(BLUE)\n",
        "        line_b = Line(C, B)\n",
        "        line_b.set_color(RED)\n",
        "        line_c = Line(A, B)\n",
        "        line_h = Line(H, C)\n",
        "        line_h.set_color(GREEN)\n",
        "\n",
        "        label_a = OldTex(\"a\")\n",
        "        label_a.match_color(line_a)\n",
        "        label_a.next_to(line_a, DOWN, buff = SMALL_BUFF)\n",
        "        label_b = OldTex(\"b\")\n",
        "        label_b.match_color(line_b)\n",
        "        label_b.next_to(line_b, LEFT, buff = SMALL_BUFF)\n",
        "        label_h = OldTex(\"h\")\n",
        "        label_h.match_color(line_h)\n",
        "        label_h.next_to(line_h.get_center(), RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        perp_mark = VMobject().set_points_as_corners([\n",
        "            RIGHT, RIGHT+DOWN, DOWN\n",
        "        ])\n",
        "        perp_mark.scale(0.25, about_point = ORIGIN)\n",
        "        perp_mark.rotate(line_c.get_angle() + TAU/4, about_point = ORIGIN)\n",
        "        perp_mark.shift(H)\n",
        "\n",
        "        # Mini triangle\n",
        "        m_hyp_a = Line(H, A)\n",
        "        m_a = line_a.copy()\n",
        "        m_hyp_b = Line(H, B)\n",
        "        m_b = line_b.copy()\n",
        "        mini_triangle = VGroup(m_a, m_hyp_a, m_b, m_hyp_b)\n",
        "        mini_triangle.set_stroke(width = 5)\n",
        "\n",
        "        mini_triangle.generate_target()\n",
        "        mini_triangle.target.scale(0.1, about_point = origin_point)\n",
        "        for part, part_target in zip(mini_triangle, mini_triangle.target):\n",
        "            part.target = part_target\n",
        "\n",
        "        # Screen label\n",
        "        screen_word = OldTexText(\"Screen\")\n",
        "        screen_word.next_to(mini_triangle.target, UP+RIGHT, LARGE_BUFF)\n",
        "        screen_arrow = Arrow(\n",
        "            screen_word.get_bottom(),\n",
        "            mini_triangle.target.get_center(),\n",
        "            color = WHITE,\n",
        "        )\n",
        "\n",
        "        # IPT Theorem\n",
        "        theorem = OldTex(\n",
        "            \"{1 \\over \", \"a^2}\", \"+\", \n",
        "            \"{1 \\over\", \"b^2}\", \"=\", \"{1 \\over\",\"h^2}\"\n",
        "        )\n",
        "        theorem.set_color_by_tex_to_color_map({\n",
        "            \"a\" : line_a.get_color(),\n",
        "            \"b\" : line_b.get_color(),\n",
        "            \"h\" : line_h.get_color(),\n",
        "        })\n",
        "        theorem_name = OldTexText(\"Inverse Pythagorean Theorem\")\n",
        "        theorem_name.to_corner(UP+RIGHT)\n",
        "        theorem.next_to(theorem_name, DOWN, buff = MED_LARGE_BUFF)\n",
        "        theorem_box = SurroundingRectangle(theorem, color = WHITE)\n",
        "\n",
        "        # Setup spotlights\n",
        "        spotlight_a = VGroup()\n",
        "        spotlight_a.screen = m_hyp_a\n",
        "        spotlight_b = VGroup()\n",
        "        spotlight_b.screen = m_hyp_b\n",
        "        for spotlight in spotlight_a, spotlight_b:\n",
        "            spotlight.get_source_point = lsC.get_source_point\n",
        "        dr = lsC.ambient_light.radius/lsC.ambient_light.num_levels\n",
        "        def update_spotlight(spotlight):\n",
        "            spotlight.submobjects = []\n",
        "            source_point = spotlight.get_source_point()\n",
        "            c1, c2 = spotlight.screen.get_start(), spotlight.screen.get_end()\n",
        "            distance = max(\n",
        "                get_norm(c1 - source_point),\n",
        "                get_norm(c2 - source_point),\n",
        "            )\n",
        "            n_parts = np.ceil(distance/dr)\n",
        "            alphas = np.linspace(0, 1, n_parts+1)\n",
        "            for a1, a2 in zip(alphas, alphas[1:]):\n",
        "                spotlight.add(Polygon(\n",
        "                    interpolate(source_point, c1, a1),\n",
        "                    interpolate(source_point, c1, a2),\n",
        "                    interpolate(source_point, c2, a2),\n",
        "                    interpolate(source_point, c2, a1),\n",
        "                    fill_color = YELLOW,\n",
        "                    fill_opacity = 2*lsC.ambient_light.opacity_function(a1*distance),\n",
        "                    stroke_width = 0\n",
        "                ))\n",
        "\n",
        "        def update_spotlights(spotlights):\n",
        "            for spotlight in spotlights:\n",
        "                update_spotlight(spotlight)\n",
        "\n",
        "        def get_spotlight_triangle(spotlight):\n",
        "            sp = spotlight.get_source_point()\n",
        "            c1 = spotlight.screen.get_start()\n",
        "            c2 = spotlight.screen.get_end()\n",
        "            return Polygon(\n",
        "                sp, c1, c2,\n",
        "                stroke_width = 0,\n",
        "                fill_color = YELLOW,\n",
        "                fill_opacity = 0.5,\n",
        "            )\n",
        "\n",
        "        spotlights = VGroup(spotlight_a, spotlight_b)\n",
        "        spotlights_update_anim = Mobject.add_updater(\n",
        "            spotlights, update_spotlights\n",
        "        )\n",
        "\n",
        "        # Add components\n",
        "        self.add(\n",
        "            axes,\n",
        "            lsA.ambient_light,\n",
        "            lsB.ambient_light,\n",
        "            lsC.ambient_light,\n",
        "            line_c,\n",
        "        )\n",
        "        self.add_foreground_mobjects(\n",
        "            lsA.lighthouse, A_label,\n",
        "            lsB.lighthouse, B_label,\n",
        "            lsC.lighthouse,  line_h,\n",
        "            theorem, theorem_name, theorem_box,\n",
        "        )\n",
        "\n",
        "        # Show miniature triangle\n",
        "        self.play(ShowCreation(mini_triangle, lag_ratio = 0))\n",
        "        self.play(\n",
        "            MoveToTarget(mini_triangle),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.add_foreground_mobject(mini_triangle)\n",
        "\n",
        "        # Show beams of light\n",
        "        self.play(\n",
        "            Write(screen_word),\n",
        "            GrowArrow(screen_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        spotlights_update_anim.update(0)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, spotlight_a),\n",
        "            LaggedStartMap(FadeIn, spotlight_b),\n",
        "            Animation(screen_arrow),\n",
        "        )\n",
        "        self.add(spotlights_update_anim)\n",
        "        self.play(*list(map(FadeOut, [screen_word, screen_arrow])))\n",
        "        self.wait()\n",
        "\n",
        "        # Reshape screen\n",
        "        m_hyps = [m_hyp_a, m_hyp_b]\n",
        "        for hyp, line in (m_hyp_a, m_a), (m_hyp_b, m_b):\n",
        "            hyp.save_state()\n",
        "            hyp.alt_version = line.copy()\n",
        "            hyp.alt_version.set_color(WHITE)\n",
        "\n",
        "        for x in range(2):\n",
        "            self.play(*[\n",
        "                Transform(m, m.alt_version)\n",
        "                for m in m_hyps\n",
        "            ])\n",
        "            self.wait()\n",
        "            self.play(*[m.restore for m in m_hyps])\n",
        "            self.wait()\n",
        "\n",
        "        # Show spotlight a key point\n",
        "        def show_beaming_light(spotlight):\n",
        "            triangle = get_spotlight_triangle(spotlight)\n",
        "            for x in range(3):\n",
        "                anims = []\n",
        "                if x > 0:\n",
        "                    anims.append(FadeOut(triangle.copy()))\n",
        "                anims.append(GrowFromPoint(triangle, triangle.get_points()[0]))\n",
        "                self.play(*anims)\n",
        "            self.play(FadeOut(triangle))\n",
        "            pass\n",
        "\n",
        "        def show_key_point(spotlight, new_point):\n",
        "            screen = spotlight.screen\n",
        "            update_spotlight_anim = UpdateFromFunc(spotlight, update_spotlight)\n",
        "            self.play(\n",
        "                Transform(screen, screen.alt_version),\n",
        "                update_spotlight_anim,\n",
        "            )\n",
        "            show_beaming_light(spotlight)\n",
        "            self.play(screen.restore, update_spotlight_anim)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                lsC.move_source_to, new_point,\n",
        "                Transform(screen, screen.alt_version),\n",
        "                update_spotlight_anim,\n",
        "                run_time = 2\n",
        "            )\n",
        "            show_beaming_light(spotlight)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                lsC.move_source_to, H,\n",
        "                screen.restore,\n",
        "                update_spotlight_anim,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.remove(spotlights_update_anim)\n",
        "        self.add(spotlight_b)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            spotlight_a, lsA.ambient_light, lsB.ambient_light\n",
        "        ])))\n",
        "        show_key_point(spotlight_b, A)\n",
        "        self.play(\n",
        "            FadeOut(spotlight_b),\n",
        "            FadeIn(spotlight_a),\n",
        "        )\n",
        "        show_key_point(spotlight_a, B)\n",
        "        self.wait()\n",
        "\n",
        "class HomeworkWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Homework\")\n",
        "        title.to_edge(UP)\n",
        "        screen = ScreenRectangle(height = 6)\n",
        "        screen.center()\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen))\n",
        "        self.wait(5)\n",
        "\n",
        "class HeresWhereThingsGetGood(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Now for the \\\\\\\\ good part!\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "class DiameterTheorem(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius = 2, color = WHITE)\n",
        "        circle.next_to(self.students[2], UP)\n",
        "        self.add(circle)\n",
        "\n",
        "        center = Dot(circle.get_center(), color = WHITE)\n",
        "        self.add_foreground_mobject(center)\n",
        "\n",
        "        diameter_word = OldTexText(\"Diameter\")\n",
        "        diameter_word.next_to(center, DOWN, SMALL_BUFF)\n",
        "\n",
        "        point = VectorizedPoint(circle.get_top())\n",
        "        triangle = Polygon(LEFT, RIGHT, UP)\n",
        "        triangle.set_stroke(BLUE)\n",
        "        triangle.set_fill(WHITE, 0.5)\n",
        "        def update_triangle(triangle):\n",
        "            triangle.set_points_as_corners([\n",
        "                circle.get_left(), circle.get_right(),\n",
        "                point.get_center(), circle.get_left(),\n",
        "            ])\n",
        "        triangle_update_anim = Mobject.add_updater(\n",
        "            triangle, update_triangle\n",
        "        )\n",
        "        triangle_update_anim.update(0)\n",
        "\n",
        "        perp_mark = VMobject()\n",
        "        perp_mark.set_points_as_corners([LEFT, DOWN, RIGHT])\n",
        "        perp_mark.shift(DOWN)\n",
        "        perp_mark.scale(0.15, about_point = ORIGIN)\n",
        "        perp_mark.shift(point.get_center())\n",
        "        perp_mark.add(point.copy())\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            DrawBorderThenFill(triangle),\n",
        "            Write(diameter_word),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(perp_mark),\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.add_foreground_mobjects(perp_mark)\n",
        "        self.add(triangle_update_anim)\n",
        "        for angle in 0.2*TAU, -0.4*TAU, 0.3*TAU:\n",
        "            point.generate_target()\n",
        "            point.target.rotate(angle, about_point = circle.get_center())\n",
        "\n",
        "            perp_mark.generate_target()\n",
        "            perp_mark.target.rotate(angle/2)\n",
        "            perp_mark.target.shift(\n",
        "                point.target.get_center() - \\\n",
        "                perp_mark.target[1].get_center()\n",
        "            )\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(point),\n",
        "                MoveToTarget(perp_mark),\n",
        "                path_arc = angle,\n",
        "                run_time = 3,\n",
        "            )\n",
        "\n",
        "class InscribedeAngleThreorem(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius = 2, color = WHITE)\n",
        "        circle.next_to(self.students[2], UP)\n",
        "        self.add(circle)\n",
        "\n",
        "        title = OldTexText(\"Inscribed angle \\\\\\\\ theorem\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.add(title)\n",
        "\n",
        "        center = Dot(circle.get_center(), color = WHITE)\n",
        "        self.add_foreground_mobject(center)\n",
        "\n",
        "        point = VectorizedPoint(circle.get_left())\n",
        "        shape = Polygon(UP+LEFT, ORIGIN, DOWN+LEFT, RIGHT)\n",
        "        shape.set_stroke(BLUE)\n",
        "        def update_shape(shape):\n",
        "            shape.set_points_as_corners([\n",
        "                point.get_center(),\n",
        "                circle.point_from_proportion(7./8), \n",
        "                circle.get_center(),\n",
        "                circle.point_from_proportion(1./8), \n",
        "                point.get_center(),\n",
        "            ])\n",
        "        shape_update_anim = Mobject.add_updater(\n",
        "            shape, update_shape\n",
        "        )\n",
        "        shape_update_anim.update(0)\n",
        "\n",
        "        angle_mark = Arc(start_angle = -TAU/8, angle = TAU/4)\n",
        "        angle_mark.scale(0.3, about_point = ORIGIN)\n",
        "        angle_mark.shift(circle.get_center())\n",
        "        theta = OldTex(\"\\\\theta\").set_color(RED)\n",
        "        theta.next_to(angle_mark, RIGHT, MED_SMALL_BUFF)\n",
        "        angle_mark.match_color(theta)\n",
        "\n",
        "        half_angle_mark = Arc(start_angle = -TAU/16, angle = TAU/8)\n",
        "        half_angle_mark.scale(0.3, about_point = ORIGIN)\n",
        "        half_angle_mark.shift(point.get_center())\n",
        "        half_angle_mark.add(point.copy())\n",
        "        theta_halves = OldTex(\"\\\\theta/2\").set_color(GREEN)\n",
        "        theta_halves.scale(0.7)\n",
        "        half_angle_mark.match_color(theta_halves)\n",
        "        theta_halves_update = UpdateFromFunc(\n",
        "            theta_halves, lambda m : m.move_to(interpolate(\n",
        "                point.get_center(), \n",
        "                half_angle_mark.point_from_proportion(0.5),\n",
        "                2.5,\n",
        "            ))\n",
        "        )\n",
        "        theta_halves_update.update(0)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            ShowCreation(shape, rate_func=linear),\n",
        "        )\n",
        "        self.play(*list(map(FadeIn, [angle_mark, theta])))\n",
        "        self.play(\n",
        "            ShowCreation(half_angle_mark),\n",
        "            Write(theta_halves),\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.add_foreground_mobjects(half_angle_mark, theta_halves)\n",
        "        self.add(shape_update_anim)\n",
        "        for angle in 0.25*TAU, -0.4*TAU, 0.3*TAU, -0.35*TAU:\n",
        "            point.generate_target()\n",
        "            point.target.rotate(angle, about_point = circle.get_center())\n",
        "\n",
        "            half_angle_mark.generate_target()\n",
        "            half_angle_mark.target.rotate(angle/2)\n",
        "            half_angle_mark.target.shift(\n",
        "                point.target.get_center() - \\\n",
        "                half_angle_mark.target[1].get_center()\n",
        "            )\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(point),\n",
        "                MoveToTarget(half_angle_mark),\n",
        "                theta_halves_update,\n",
        "                path_arc = angle,\n",
        "                run_time = 3,\n",
        "            )\n",
        "\n",
        "class PondScene(ThreeDScene):\n",
        "    def construct(self):\n",
        "\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = np.array([0,BASELINE_YPOS,0])\n",
        "        LAKE0_RADIUS = 1.5\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.5\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        LIGHT_MAX_INT = 1\n",
        "        LIGHT_SCALE = 2.5\n",
        "        LIGHT_CUTOFF = 1\n",
        "\n",
        "        RIGHT_ANGLE_SIZE = 0.3\n",
        "\n",
        "        self.cumulated_zoom_factor = 1\n",
        "\n",
        "        def right_angle(pointA, pointB, pointC, size = 1):\n",
        "\n",
        "            v1 = pointA - pointB\n",
        "            v1 = size * v1/get_norm(v1)\n",
        "            v2 = pointC - pointB\n",
        "            v2 = size * v2/get_norm(v2)\n",
        "            \n",
        "            P = pointB\n",
        "            Q = pointB + v1\n",
        "            R = Q + v2\n",
        "            S = R - v1\n",
        "            angle_sign = VMobject()\n",
        "            angle_sign.set_points_as_corners([P,Q,R,S,P])\n",
        "            angle_sign.mark_paths_closed = True\n",
        "            angle_sign.set_fill(color = WHITE, opacity = 1)\n",
        "            angle_sign.set_stroke(width = 0)\n",
        "            return angle_sign\n",
        "\n",
        "        def triangle(pointA, pointB, pointC):\n",
        "\n",
        "            mob = VMobject()\n",
        "            mob.set_points_as_corners([pointA, pointB, pointC, pointA])\n",
        "            mob.mark_paths_closed = True\n",
        "            mob.set_fill(color = WHITE, opacity = 0.5)\n",
        "            mob.set_stroke(width = 0)\n",
        "            return mob\n",
        "\n",
        "        def zoom_out_scene(factor):\n",
        "\n",
        "            self.remove_foreground_mobject(self.ls0_dot)\n",
        "            self.remove(self.ls0_dot)\n",
        "\n",
        "            phi0 = self.camera.get_phi() # default is 0 degs\n",
        "            theta0 = self.camera.get_theta() # default is -90 degs\n",
        "            distance0 = self.camera.get_distance()\n",
        "\n",
        "            distance1 = 2 * distance0\n",
        "            camera_target_point = self.camera.get_spherical_coords(phi0, theta0, distance1)\n",
        "\n",
        "            self.play(\n",
        "                ApplyMethod(self.camera.rotation_mobject.move_to, camera_target_point),\n",
        "                self.zoomable_mobs.shift, self.obs_dot.get_center(),\n",
        "                self.unzoomable_mobs.scale,2,{\"about_point\" : ORIGIN},\n",
        "            )\n",
        "\n",
        "            self.cumulated_zoom_factor *= factor\n",
        "\n",
        "            # place ls0_dot by hand\n",
        "            #old_radius = self.ls0_dot.radius\n",
        "            #self.ls0_dot.radius = 2 * old_radius\n",
        "\n",
        "            #v = self.ls0_dot.get_center() - self.obs_dot.get_center()\n",
        "            #self.ls0_dot.shift(v)\n",
        "            #self.ls0_dot.move_to(self.outer_lake.get_center())\n",
        "            self.ls0_dot.scale(2, about_point = ORIGIN)\n",
        "                \n",
        "            #self.add_foreground_mobject(self.ls0_dot)\n",
        "\n",
        "        def shift_scene(v):\n",
        "            self.play(\n",
        "                self.zoomable_mobs.shift,v,\n",
        "                self.unzoomable_mobs.shift,v\n",
        "            )\n",
        "\n",
        "        self.zoomable_mobs = VMobject()\n",
        "        self.unzoomable_mobs = VMobject()\n",
        "\n",
        "        baseline = VMobject()\n",
        "        baseline.set_points_as_corners([[-8,BASELINE_YPOS,0],[8,BASELINE_YPOS,0]])\n",
        "        baseline.set_stroke(width = 0) # in case it gets accidentally added to the scene\n",
        "        self.zoomable_mobs.add(baseline) # prob not necessary\n",
        "\n",
        "        obs_dot = self.obs_dot = Dot(OBSERVER_POINT, fill_color = DOT_COLOR)\n",
        "        ls0_dot = self.ls0_dot = Dot(OBSERVER_POINT + 2 * LAKE0_RADIUS * UP, fill_color = WHITE)\n",
        "        self.unzoomable_mobs.add(self.obs_dot)#, self.ls0_dot)\n",
        "\n",
        "        # lake\n",
        "        lake0 = Circle(radius = LAKE0_RADIUS,\n",
        "            stroke_width = 0,\n",
        "            fill_color = LAKE_COLOR,\n",
        "            fill_opacity = LAKE_OPACITY\n",
        "        )\n",
        "        lake0.move_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "        self.zoomable_mobs.add(lake0)\n",
        "\n",
        "        # Morty and indicator\n",
        "        morty = Mortimer().flip().scale(0.3)\n",
        "        morty.next_to(OBSERVER_POINT,DOWN)\n",
        "        indicator = LightIndicator(precision = 2,\n",
        "            radius = INDICATOR_RADIUS,\n",
        "            show_reading  = False,\n",
        "            color = LIGHT_COLOR\n",
        "        )\n",
        "        indicator.next_to(morty,LEFT)\n",
        "        self.unzoomable_mobs.add(morty, indicator)\n",
        "\n",
        "        # first lighthouse\n",
        "        original_op_func = inverse_quadratic(LIGHT_MAX_INT,LIGHT_SCALE,LIGHT_CUTOFF)\n",
        "        ls0 = LightSource(opacity_function = original_op_func, radius = 15.0, num_levels = 150)\n",
        "        ls0.lighthouse.set_height(LIGHTHOUSE_HEIGHT)\n",
        "        ls0.lighthouse.height = LIGHTHOUSE_HEIGHT\n",
        "        ls0.move_source_to(OBSERVER_POINT + LAKE0_RADIUS * 2 * UP)\n",
        "        self.zoomable_mobs.add(ls0, ls0.lighthouse, ls0.ambient_light)\n",
        "\n",
        "        # self.add(lake0, morty, obs_dot, ls0_dot, ls0.lighthouse)\n",
        "\n",
        "        # shore arcs\n",
        "        arc_left = Arc(-TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_left.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_left = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_left.next_to(arc_left,LEFT)\n",
        "    \n",
        "        arc_right = Arc(TAU/2,\n",
        "            radius = LAKE0_RADIUS,\n",
        "            start_angle = -TAU/4,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR\n",
        "        )\n",
        "        arc_right.move_arc_center_to(OBSERVER_POINT + LAKE0_RADIUS * UP)\n",
        "\n",
        "        one_right = OldTex(\"1\", color = LAKE_COLOR).scale(TEX_SCALE)\n",
        "        one_right.next_to(arc_right,RIGHT)\n",
        "\n",
        "        # New introduction\n",
        "        lake0.save_state()\n",
        "        morty.save_state()\n",
        "        lake0.set_height(6)\n",
        "        morty.to_corner(UP+LEFT)\n",
        "        morty.fade(1)\n",
        "        lake0.center()\n",
        "\n",
        "        lake_word = OldTexText(\"Lake\")\n",
        "        lake_word.scale(2)\n",
        "        lake_word.move_to(lake0)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(lake0, stroke_width = 1),\n",
        "            Write(lake_word)\n",
        "        )\n",
        "        self.play(\n",
        "            lake0.restore,\n",
        "            lake_word.scale, 0.5, {\"about_point\" : lake0.get_bottom()},\n",
        "            lake_word.fade, 1\n",
        "        )\n",
        "        self.remove(lake_word)\n",
        "        self.play(morty.restore)\n",
        "        self.play(\n",
        "            GrowFromCenter(obs_dot),\n",
        "            GrowFromCenter(ls0_dot),\n",
        "            FadeIn(ls0.lighthouse)\n",
        "        )\n",
        "        self.add_foreground_mobjects(ls0.lighthouse, obs_dot, ls0_dot)\n",
        "        self.play(\n",
        "            SwitchOn(ls0.ambient_light),\n",
        "            Animation(ls0.lighthouse),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.move_to, ls0.lighthouse, \n",
        "            run_time = 3,\n",
        "            path_arc = TAU/2,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc_right),\n",
        "            Write(one_right),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arc_left),\n",
        "            Write(one_left),\n",
        "        )\n",
        "        self.play(\n",
        "            lake0.set_stroke, {\n",
        "                \"color\": LAKE_STROKE_COLOR, \n",
        "                \"width\" : LAKE_STROKE_WIDTH\n",
        "            },\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(morty)\n",
        "\n",
        "\n",
        "        # Show indicator\n",
        "        self.play(FadeIn(indicator))\n",
        "\n",
        "        self.play(indicator.set_intensity, 0.5)\n",
        "\n",
        "        diameter_start = interpolate(OBSERVER_POINT,ls0.get_source_point(),0.02)\n",
        "        diameter_stop = interpolate(OBSERVER_POINT,ls0.get_source_point(),0.98)\n",
        "\n",
        "        # diameter\n",
        "        diameter = DoubleArrow(diameter_start,\n",
        "            diameter_stop,\n",
        "            buff = 0,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        diameter_text = OldTex(\"d\").scale(TEX_SCALE)\n",
        "        diameter_text.next_to(diameter,RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(diameter),\n",
        "            Write(diameter_text),\n",
        "            #FadeOut(self.obs_dot),\n",
        "            FadeOut(ls0_dot)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        indicator_reading = OldTex(\"{1 \\over d^2}\").scale(TEX_SCALE)\n",
        "        indicator_reading.move_to(indicator)\n",
        "        self.unzoomable_mobs.add(indicator_reading)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                diameter_text[0].copy(),\n",
        "                indicator_reading[2],\n",
        "            ),\n",
        "            FadeIn(indicator_reading)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # replace d with its value\n",
        "        new_diameter_text = OldTex(\"{2 \\over \\pi}\").scale(TEX_SCALE)\n",
        "        new_diameter_text.color = LAKE_COLOR\n",
        "        new_diameter_text.move_to(diameter_text)\n",
        "        self.play(FadeOut(diameter_text))\n",
        "        self.play(FadeIn(new_diameter_text))\n",
        "        self.wait(2)\n",
        "\n",
        "        # insert into indicator reading\n",
        "        new_reading = OldTex(\"{\\pi^2 \\over 4}\").scale(TEX_SCALE)\n",
        "        new_reading.move_to(indicator)\n",
        "        new_diameter_text_copy = new_diameter_text.copy()\n",
        "        new_diameter_text_copy.submobjects.reverse()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(indicator_reading),\n",
        "            ReplacementTransform(\n",
        "                new_diameter_text_copy,\n",
        "                new_reading,\n",
        "                parth_arc = 30*DEGREES\n",
        "            )\n",
        "        )\n",
        "        indicator_reading = new_reading\n",
        "\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(one_left),\n",
        "            FadeOut(one_right),\n",
        "            FadeOut(new_diameter_text),\n",
        "            FadeOut(arc_left),\n",
        "            FadeOut(arc_right)\n",
        "        )\n",
        "        self.add_foreground_mobjects(indicator, indicator_reading)\n",
        "        self.unzoomable_mobs.add(indicator_reading)\n",
        "\n",
        "        def indicator_wiggle():\n",
        "            INDICATOR_WIGGLE_FACTOR = 1.3\n",
        "\n",
        "            self.play(\n",
        "                ScaleInPlace(indicator, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle),\n",
        "                ScaleInPlace(indicator_reading, INDICATOR_WIGGLE_FACTOR, rate_func = wiggle)\n",
        "            )\n",
        "\n",
        "        def angle_for_index(i,step):\n",
        "            return -TAU/4 + TAU/2**step * (i + 0.5)\n",
        "\n",
        "\n",
        "        def position_for_index(i, step, scaled_down = False):\n",
        "\n",
        "            theta = angle_for_index(i,step)\n",
        "            radial_vector = np.array([np.cos(theta),np.sin(theta),0])\n",
        "            position = self.lake_center + self.lake_radius * radial_vector\n",
        "\n",
        "            if scaled_down:\n",
        "                return position.scale_about_point(self.obs_dot.get_center(),0.5)\n",
        "            else:\n",
        "                return position\n",
        "\n",
        "\n",
        "        def split_light_source(i, step, show_steps = True, animate = True, run_time = 1):\n",
        "\n",
        "            ls_new_loc1 = position_for_index(i,step + 1)\n",
        "            ls_new_loc2 = position_for_index(i + 2**step,step + 1)\n",
        "\n",
        "            hyp = VMobject()\n",
        "            hyp1 = Line(self.lake_center,ls_new_loc1)\n",
        "            hyp2 = Line(self.lake_center,ls_new_loc2)\n",
        "            hyp.add(hyp2,hyp1)\n",
        "            self.new_hypotenuses.append(hyp)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(hyp, run_time = run_time)\n",
        "                )\n",
        "\n",
        "            leg1 = Line(self.obs_dot.get_center(),ls_new_loc1)\n",
        "            leg2 = Line(self.obs_dot.get_center(),ls_new_loc2)\n",
        "            self.new_legs_1.append(leg1)\n",
        "            self.new_legs_2.append(leg2)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(\n",
        "                    ShowCreation(leg1, run_time = run_time),\n",
        "                    ShowCreation(leg2, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            ls1 = self.light_sources_array[i]\n",
        "\n",
        "\n",
        "            ls2 = ls1.copy()\n",
        "            if animate == True:\n",
        "                self.add(ls2)\n",
        "\n",
        "            self.additional_light_sources.append(ls2)\n",
        "\n",
        "            # check if the light sources are on screen\n",
        "            ls_old_loc = np.array(ls1.get_source_point())\n",
        "            onscreen_old = np.any(np.abs(ls_old_loc) < 10)\n",
        "            onscreen_1 = np.any(np.abs(ls_new_loc1) < 10)\n",
        "            onscreen_2 = np.any(np.abs(ls_new_loc2) < 10)\n",
        "            show_animation = (onscreen_old or onscreen_1 or onscreen_2)\n",
        "\n",
        "            if show_animation or animate:\n",
        "                ls1.generate_target()\n",
        "                ls2.generate_target()\n",
        "                ls1.target.move_source_to(ls_new_loc1)\n",
        "                ls2.target.move_source_to(ls_new_loc2)\n",
        "                ls1.fade(1)\n",
        "                self.play(\n",
        "                    MoveToTarget(ls1), MoveToTarget(ls2),\n",
        "                    run_time = run_time\n",
        "                )\n",
        "            else:\n",
        "                ls1.move_source_to(ls_new_loc1)\n",
        "                ls2.move_source_to(ls_new_loc1)\n",
        "\n",
        "\n",
        "        def construction_step(n, show_steps = True, run_time = 1,\n",
        "            simultaneous_splitting = False):\n",
        "\n",
        "            # we assume that the scene contains:\n",
        "            # an inner lake, self.inner_lake\n",
        "            # an outer lake, self.outer_lake\n",
        "            # light sources, self.light_sources\n",
        "            # legs from the observer point to each light source\n",
        "            # self.legs\n",
        "            # altitudes from the observer point to the\n",
        "            # locations of the light sources in the previous step\n",
        "            # self.altitudes\n",
        "            # hypotenuses connecting antipodal light sources\n",
        "            # self.hypotenuses\n",
        "\n",
        "            # these are mobjects!\n",
        "\n",
        "\n",
        "            # first, fade out all of the hypotenuses and altitudes\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.zoomable_mobs.remove(self.hypotenuses, self.altitudes, self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.hypotenuses),\n",
        "                    FadeOut(self.altitudes),\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "            else:\n",
        "                self.zoomable_mobs.remove(self.inner_lake)\n",
        "                self.play(\n",
        "                    FadeOut(self.inner_lake)\n",
        "                )\n",
        "\n",
        "            # create a new, outer lake\n",
        "            self.lake_center = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "\n",
        "            new_outer_lake = Circle(radius = self.lake_radius,\n",
        "                stroke_width = LAKE_STROKE_WIDTH,\n",
        "                fill_color = LAKE_COLOR,\n",
        "                fill_opacity = LAKE_OPACITY,\n",
        "                stroke_color = LAKE_STROKE_COLOR\n",
        "            )\n",
        "            new_outer_lake.move_to(self.lake_center)\n",
        "\n",
        "            if show_steps == True: \n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                    FadeIn(self.ls0_dot)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    FadeIn(new_outer_lake, run_time = run_time),\n",
        "                )\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            self.inner_lake = self.outer_lake\n",
        "            self.outer_lake = new_outer_lake\n",
        "            self.altitudes = self.legs\n",
        "            #self.lake_center = self.outer_lake.get_center()\n",
        "\n",
        "            self.additional_light_sources = []\n",
        "            self.new_legs_1 = []\n",
        "            self.new_legs_2 = []\n",
        "            self.new_hypotenuses = []\n",
        "\n",
        "            if simultaneous_splitting == False:\n",
        "\n",
        "                for i in range(2**n):\n",
        "                    \n",
        "                    split_light_source(i,\n",
        "                        step = n,\n",
        "                        show_steps = show_steps,\n",
        "                        run_time = run_time\n",
        "                    )\n",
        "\n",
        "                    if n == 1 and i == 0:\n",
        "                        # show again where the right angles are\n",
        "                        A = self.light_sources[0].get_center()\n",
        "                        B = self.additional_light_sources[0].get_center()\n",
        "                        C = self.obs_dot.get_center()\n",
        "\n",
        "                        triangle1 = triangle(\n",
        "                            A, C, B\n",
        "                        )\n",
        "                        right_angle1 = right_angle(\n",
        "                            A, C, B, size = 2 * RIGHT_ANGLE_SIZE\n",
        "                        )\n",
        "\n",
        "                        self.play(\n",
        "                            FadeIn(triangle1),\n",
        "                            FadeIn(right_angle1)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        self.play(\n",
        "                            FadeOut(triangle1),\n",
        "                            FadeOut(right_angle1)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        H = self.inner_lake.get_center() + self.lake_radius/2 * RIGHT\n",
        "                        L = self.outer_lake.get_center()\n",
        "                        triangle2 = triangle(\n",
        "                            L, H, C\n",
        "                        )\n",
        "\n",
        "                        right_angle2 = right_angle(\n",
        "                            L, H, C, size = 2 * RIGHT_ANGLE_SIZE\n",
        "                        )\n",
        "\n",
        "                        self.play(\n",
        "                            FadeIn(triangle2),\n",
        "                            FadeIn(right_angle2)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "                        self.play(\n",
        "                            FadeOut(triangle2),\n",
        "                            FadeOut(right_angle2)\n",
        "                        )\n",
        "\n",
        "                        self.wait()\n",
        "\n",
        "            else: # simultaneous splitting\n",
        "\n",
        "                old_lake = self.outer_lake.copy()\n",
        "                old_ls = self.light_sources.copy()\n",
        "                old_ls2 = old_ls.copy()\n",
        "                for submob in old_ls2.submobjects:\n",
        "                    old_ls.add(submob)\n",
        "\n",
        "                self.remove(self.outer_lake, self.light_sources)\n",
        "                self.add(old_lake, old_ls)\n",
        "\n",
        "                for i in range(2**n):\n",
        "                    split_light_source(i,\n",
        "                        step = n,\n",
        "                        show_steps = show_steps,\n",
        "                        run_time = run_time,\n",
        "                        animate = False\n",
        "                    )\n",
        "\n",
        "                self.play(\n",
        "                    ReplacementTransform(old_ls, self.light_sources, run_time = run_time),\n",
        "                    ReplacementTransform(old_lake, self.outer_lake, run_time = run_time),\n",
        "                )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "            # collect the newly created mobs (in arrays)\n",
        "            # into the appropriate Mobject containers\n",
        "\n",
        "            self.legs = VMobject()\n",
        "            for leg in self.new_legs_1:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "            for leg in self.new_legs_2:\n",
        "                self.legs.add(leg)\n",
        "                self.zoomable_mobs.add(leg)\n",
        "\n",
        "            for hyp in self.hypotenuses.submobjects:\n",
        "                self.zoomable_mobs.remove(hyp)\n",
        "\n",
        "            self.hypotenuses = VMobject()\n",
        "            for hyp in self.new_hypotenuses:\n",
        "                self.hypotenuses.add(hyp)\n",
        "                self.zoomable_mobs.add(hyp)\n",
        "\n",
        "            for ls in self.additional_light_sources:\n",
        "                self.light_sources.add(ls)\n",
        "                self.light_sources_array.append(ls)\n",
        "                self.zoomable_mobs.add(ls)\n",
        "\n",
        "            # update scene\n",
        "            self.add(\n",
        "                self.light_sources,\n",
        "                self.inner_lake,\n",
        "                self.outer_lake,\n",
        "            )\n",
        "            self.zoomable_mobs.add(self.light_sources, self.inner_lake, self.outer_lake)\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.add(\n",
        "                    self.legs,\n",
        "                    self.hypotenuses,\n",
        "                    self.altitudes,\n",
        "                )\n",
        "                self.zoomable_mobs.add(self.legs, self.hypotenuses, self.altitudes)\n",
        "\n",
        "\n",
        "            self.wait()\n",
        "\n",
        "            if show_steps == True:\n",
        "                self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "            #self.lake_center = ls0_loc = self.obs_dot.get_center() + self.lake_radius * UP\n",
        "            self.lake_radius *= 2\n",
        "\n",
        "        self.lake_center = ls0_loc = ls0.get_source_point()\n",
        "\n",
        "        self.inner_lake = VMobject()\n",
        "        self.outer_lake = lake0\n",
        "        self.legs = VMobject()\n",
        "        self.legs.add(Line(OBSERVER_POINT,self.lake_center))\n",
        "        self.altitudes = VMobject()\n",
        "        self.hypotenuses = VMobject()\n",
        "        self.light_sources_array = [ls0]\n",
        "        self.light_sources = VMobject()\n",
        "        self.light_sources.add(ls0)\n",
        "\n",
        "        self.lake_radius = 2 * LAKE0_RADIUS # don't ask...\n",
        "\n",
        "        self.zoomable_mobs.add(self.inner_lake, self.outer_lake, self.altitudes, self.light_sources)\n",
        "\n",
        "        self.add(\n",
        "            self.inner_lake,\n",
        "            self.outer_lake,\n",
        "            self.legs,\n",
        "            self.altitudes,\n",
        "            self.hypotenuses\n",
        "        )\n",
        "\n",
        "        self.play(FadeOut(diameter))\n",
        "        \n",
        "        self.additional_light_sources = []\n",
        "        self.new_legs_1 = []\n",
        "        self.new_legs_2 = []\n",
        "        self.new_hypotenuses = []\n",
        "\n",
        "        construction_step(0)\n",
        "\n",
        "        my_triangle = triangle(\n",
        "            self.light_sources[0].get_source_point(),\n",
        "            OBSERVER_POINT,\n",
        "            self.light_sources[1].get_source_point()\n",
        "        )\n",
        "\n",
        "        angle_sign1 = right_angle(\n",
        "            self.light_sources[0].get_source_point(),\n",
        "            OBSERVER_POINT,\n",
        "            self.light_sources[1].get_source_point(),\n",
        "            size = RIGHT_ANGLE_SIZE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(angle_sign1),\n",
        "            FadeIn(my_triangle)\n",
        "        )\n",
        "\n",
        "        angle_sign2 = right_angle(\n",
        "            self.light_sources[1].get_source_point(),\n",
        "            self.lake_center,\n",
        "            OBSERVER_POINT,\n",
        "            size = RIGHT_ANGLE_SIZE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(angle_sign2)\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(angle_sign1),\n",
        "            FadeOut(angle_sign2),\n",
        "            FadeOut(my_triangle)\n",
        "        )\n",
        "\n",
        "        indicator_wiggle()\n",
        "        self.remove(self.ls0_dot)\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "        \n",
        "        construction_step(1)\n",
        "        indicator_wiggle()\n",
        "        #self.play(FadeOut(self.ls0_dot))\n",
        "        zoom_out_scene(2)\n",
        "\n",
        "\n",
        "        construction_step(2)\n",
        "        indicator_wiggle()\n",
        "        self.play(FadeOut(self.ls0_dot))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.altitudes),\n",
        "            FadeOut(self.hypotenuses),\n",
        "            FadeOut(self.legs)\n",
        "        )\n",
        "\n",
        "        max_it = 6\n",
        "        scale = 2**(max_it - 4)\n",
        "        TEX_SCALE *= scale\n",
        "\n",
        "\n",
        "\n",
        "        # for i in range(3,max_it + 1):\n",
        "        #     construction_step(i, show_steps = False, run_time = 4.0/2**i,\n",
        "        #         simultaneous_splitting = True)\n",
        "\n",
        "\n",
        "\n",
        "        # simultaneous expansion of light sources from now on\n",
        "        self.play(FadeOut(self.inner_lake))\n",
        "\n",
        "        for n in range(3,max_it + 1):\n",
        "\n",
        "            new_lake = self.outer_lake.copy().scale(2,about_point = self.obs_dot.get_center())\n",
        "            for ls in self.light_sources_array:\n",
        "                lsp = ls.copy()\n",
        "                self.light_sources.add(lsp)\n",
        "                self.add(lsp)\n",
        "                self.light_sources_array.append(lsp)\n",
        "\n",
        "            new_lake_center = new_lake.get_center()\n",
        "            new_lake_radius = 0.5 * new_lake.get_width()\n",
        "\n",
        "            shift_list = (Transform(self.outer_lake,new_lake),)\n",
        "\n",
        "\n",
        "            for i in range(2**n):\n",
        "                theta = -TAU/4 + (i + 0.5) * TAU / 2**n\n",
        "                v = np.array([np.cos(theta), np.sin(theta),0])\n",
        "                pos1 = new_lake_center + new_lake_radius * v\n",
        "                pos2 = new_lake_center - new_lake_radius * v\n",
        "                shift_list += (self.light_sources.submobjects[i].move_source_to,pos1)\n",
        "                shift_list += (self.light_sources.submobjects[i+2**n].move_source_to,pos2)\n",
        "\n",
        "            self.play(*shift_list)\n",
        "\n",
        "        #self.revert_to_original_skipping_status()\n",
        "\n",
        "        # Now create a straight number line and transform into it\n",
        "        MAX_N = 17\n",
        "\n",
        "        origin_point = self.obs_dot.get_center()\n",
        "\n",
        "        self.number_line = NumberLine(\n",
        "            x_min = -MAX_N,\n",
        "            x_max = MAX_N + 1,\n",
        "            color = WHITE,\n",
        "            number_at_center = 0,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            #big_tick_numbers = range(-MAX_N,MAX_N + 1),\n",
        "            numbers_to_show = list(range(-MAX_N,MAX_N + 1,2)),\n",
        "            unit_size = LAKE0_RADIUS * TAU/4 / 2 * scale,\n",
        "            tick_frequency = 1,\n",
        "            line_to_number_buff = LARGE_BUFF,\n",
        "            label_direction = UP,\n",
        "        ).shift(scale * 2.5 * DOWN)\n",
        "\n",
        "        self.number_line.label_direction = DOWN\n",
        "\n",
        "        self.number_line_labels = self.number_line.get_number_mobjects()\n",
        "        self.wait()\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "        nl_sources = VMobject()\n",
        "        pond_sources = VMobject()\n",
        "\n",
        "        for i in range(-MAX_N,MAX_N+1):\n",
        "            anchor = self.number_line.number_to_point(2*i + 1)\n",
        "            ls = self.light_sources_array[i].copy()\n",
        "            ls.move_source_to(anchor)\n",
        "            nl_sources.add(ls)\n",
        "            pond_sources.add(self.light_sources_array[i].copy())\n",
        "\n",
        "        self.add(pond_sources)\n",
        "        self.remove(self.light_sources)\n",
        "\n",
        "        self.outer_lake.rotate(TAU/8)\n",
        "\n",
        "        # open sea\n",
        "        open_sea = Rectangle(\n",
        "            width = 20 * scale,\n",
        "            height = 10 * scale,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            fill_color = LAKE_COLOR,\n",
        "            fill_opacity = LAKE_OPACITY,\n",
        "        ).flip().next_to(origin_point,UP,buff = 0)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(pond_sources,nl_sources),\n",
        "            ReplacementTransform(self.outer_lake,open_sea),\n",
        "            FadeOut(self.inner_lake)\n",
        "        )\n",
        "        self.play(FadeIn(self.number_line))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        v = 4 * scale * UP\n",
        "        self.play(\n",
        "            nl_sources.shift,v,\n",
        "            morty.shift,v,\n",
        "            self.number_line.shift,v,\n",
        "            indicator.shift,v,\n",
        "            indicator_reading.shift,v,\n",
        "            open_sea.shift,v,\n",
        "            self.obs_dot.shift,v,\n",
        "        )\n",
        "        self.number_line_labels.shift(v)\n",
        "\n",
        "        origin_point = self.number_line.number_to_point(0)\n",
        "        #self.remove(self.obs_dot)\n",
        "        self.play(\n",
        "            indicator.move_to, origin_point + scale * UP,\n",
        "            indicator_reading.move_to, origin_point + scale * UP,\n",
        "            FadeOut(open_sea),\n",
        "            FadeOut(morty),\n",
        "            FadeIn(self.number_line_labels)\n",
        "        )\n",
        "\n",
        "        two_sided_sum = OldTex(\"\\dots\", \"+\", \"{1\\over (-11)^2}\",\\\n",
        "         \"+\", \"{1\\over (-9)^2}\", \" + \", \"{1\\over (-7)^2}\", \" + \", \"{1\\over (-5)^2}\", \" + \", \\\n",
        "         \"{1\\over (-3)^2}\", \" + \", \"{1\\over (-1)^2}\", \" + \", \"{1\\over 1^2}\", \" + \", \\\n",
        "         \"{1\\over 3^2}\", \" + \", \"{1\\over 5^2}\", \" + \", \"{1\\over 7^2}\", \" + \", \\\n",
        "         \"{1\\over 9^2}\", \" + \", \"{1\\over 11^2}\", \" + \", \"\\dots\")\n",
        "\n",
        "        nb_symbols = len(two_sided_sum.submobjects)\n",
        "\n",
        "        two_sided_sum.scale(TEX_SCALE)\n",
        "        \n",
        "        for (i,submob) in zip(list(range(nb_symbols)),two_sided_sum.submobjects):\n",
        "            submob.next_to(self.number_line.number_to_point(i - 13),DOWN, buff = 2*scale)\n",
        "            if (i == 0 or i % 2 == 1 or i == nb_symbols - 1): # non-fractions\n",
        "                submob.shift(0.3 * scale * DOWN)\n",
        "\n",
        "        self.play(Write(two_sided_sum))\n",
        "\n",
        "        for i in range(MAX_N - 5, MAX_N):\n",
        "            self.remove(nl_sources.submobjects[i].ambient_light)\n",
        "        \n",
        "        for i in range(MAX_N, MAX_N + 5):\n",
        "            self.add_foreground_mobject(nl_sources.submobjects[i].ambient_light)\n",
        "\n",
        "        self.wait()        \n",
        "\n",
        "        covering_rectangle = Rectangle(\n",
        "            width = FRAME_X_RADIUS * scale,\n",
        "            height = 2 * FRAME_Y_RADIUS * scale,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        covering_rectangle.next_to(ORIGIN,LEFT,buff = 0)\n",
        "        for i in range(10):\n",
        "            self.add_foreground_mobject(nl_sources.submobjects[i])\n",
        "\n",
        "        self.add_foreground_mobject(indicator)\n",
        "        self.add_foreground_mobject(indicator_reading)\n",
        "\n",
        "\n",
        "        half_indicator_reading = OldTex(\"{\\pi^2 \\over 8}\").scale(TEX_SCALE)\n",
        "        half_indicator_reading.move_to(indicator)\n",
        "\n",
        "        central_plus_sign = two_sided_sum[13]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(covering_rectangle),\n",
        "            Transform(indicator_reading, half_indicator_reading),\n",
        "            FadeOut(central_plus_sign)\n",
        "        )\n",
        "\n",
        "        equals_sign = OldTex(\"=\").scale(TEX_SCALE)\n",
        "        equals_sign.move_to(central_plus_sign)\n",
        "        p = 2 * scale * LEFT + central_plus_sign.get_center()[1] * UP\n",
        "\n",
        "        self.play(\n",
        "            indicator.move_to,p,\n",
        "            indicator_reading.move_to,p,\n",
        "            FadeIn(equals_sign),\n",
        "        )\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        # show Randy admiring the result\n",
        "        randy = Randolph(color = MAROON_E).scale(scale).move_to(2*scale*DOWN+5*scale*LEFT)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change,\"happy\")\n",
        "        self.play(randy.change,\"hooray\")\n",
        "\n",
        "class CircumferenceText(Scene):\n",
        "    CONFIG = {\"n\" : 16}\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Circumference %d\"%self.n)\n",
        "        words.scale(1.25)\n",
        "        words.to_corner(UP+LEFT)\n",
        "        self.add(words)\n",
        "\n",
        "class CenterOfLargerCircleOverlayText(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Center of \\\\\\\\ larger circle\")\n",
        "        arrow = Vector(DOWN+LEFT, color = WHITE)\n",
        "        arrow.shift(words.get_bottom() + SMALL_BUFF*DOWN - arrow.get_start())\n",
        "        group = VGroup(words, arrow)\n",
        "        group.set_height(FRAME_HEIGHT - 1)\n",
        "        group.to_edge(UP)\n",
        "        self.add(group)\n",
        "\n",
        "class DiameterWordOverlay(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"Diameter\")\n",
        "        word.set_width(FRAME_X_RADIUS)\n",
        "        word.rotate(-45*DEGREES)\n",
        "        self.play(Write(word))\n",
        "        self.wait()\n",
        "\n",
        "class YayIPTApplies(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Heyo!  The Inverse \\\\\\\\ Pythagorean Theorem \\\\\\\\ applies!\",\n",
        "            bubble_config = {\"width\" : 5},\n",
        "            target_mode = \"surprised\"\n",
        "        )\n",
        "        self.play_student_changes(*3*[\"hooray\"])\n",
        "        self.wait(2)\n",
        "\n",
        "class WalkThroughOneMoreStep(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            Wait...can you walk \\\\\\\\\n",
        "            through one more step?\n",
        "        \"\"\")\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(4)\n",
        "\n",
        "class ThinkBackToHowAmazingThisIs(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"x_radius\" : 100,\n",
        "        \"max_shown_n\" : 20,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_sum()\n",
        "        self.show_giant_circle()\n",
        "\n",
        "    def show_sum(self):\n",
        "        number_line = NumberLine(\n",
        "            x_min = -self.x_radius, \n",
        "            x_max = self.x_radius,\n",
        "            numbers_to_show = list(range(-self.max_shown_n, self.max_shown_n)),\n",
        "        )\n",
        "        number_line.add_numbers()\n",
        "        number_line.shift(2*DOWN)\n",
        "\n",
        "        positive_dots, negative_dots = [\n",
        "            VGroup(*[\n",
        "                Dot(number_line.number_to_point(u*x))\n",
        "                for x in range(1, int(self.x_radius), 2)\n",
        "            ])\n",
        "            for u in (1, -1)\n",
        "        ]\n",
        "        dot_pairs = it.starmap(VGroup, list(zip(positive_dots, negative_dots)))\n",
        "\n",
        "        # Decimal\n",
        "        decimal = DecimalNumber(0, num_decimal_places = 6)\n",
        "        decimal.to_edge(UP)\n",
        "        terms = [2./(n**2) for n in range(1, 100, 2)]\n",
        "        partial_sums = np.cumsum(terms)\n",
        "\n",
        "        # pi^2/4 label\n",
        "        brace = Brace(decimal, DOWN)\n",
        "        pi_term = OldTex(\"\\pi^2 \\over 4\")\n",
        "        pi_term.next_to(brace, DOWN)\n",
        "\n",
        "        term_mobjects = VGroup()\n",
        "        for n in range(1, self.max_shown_n, 2):\n",
        "            p_term = OldTex(\"\\\\left(\\\\frac{1}{%d}\\\\right)^2\"%n)\n",
        "            n_term = OldTex(\"\\\\left(\\\\frac{-1}{%d}\\\\right)^2\"%n)\n",
        "            group = VGroup(p_term, n_term)\n",
        "            group.scale(0.7)\n",
        "            p_term.next_to(number_line.number_to_point(n), UP, LARGE_BUFF)\n",
        "            n_term.next_to(number_line.number_to_point(-n), UP, LARGE_BUFF)\n",
        "            term_mobjects.add(group)\n",
        "        term_mobjects.set_color_by_gradient(BLUE, YELLOW)\n",
        "        plusses = VGroup(*[\n",
        "            VGroup(*[\n",
        "                OldTex(\"+\").next_to(\n",
        "                    number_line.number_to_point(u*n), UP, buff = 1.25,\n",
        "                )\n",
        "                for u in (-1, 1)\n",
        "            ])\n",
        "            for n in range(0, self.max_shown_n, 2)\n",
        "        ])\n",
        "\n",
        "        zoom_out = always_shift(\n",
        "            self.camera.rotation_mobject,\n",
        "            direction = OUT, rate = 0.4\n",
        "        )\n",
        "        def update_decimal(decimal):\n",
        "            z = self.camera.rotation_mobject.get_center()[2]\n",
        "            decimal.set_height(0.07*z)\n",
        "            decimal.move_to(0.7*z*UP)\n",
        "        scale_decimal = Mobject.add_updater(decimal, update_decimal)\n",
        "\n",
        "\n",
        "        self.add(number_line, *dot_pairs)\n",
        "        self.add(zoom_out, scale_decimal)\n",
        "\n",
        "        tuples = list(zip(term_mobjects, plusses, partial_sums))\n",
        "        run_time = 1\n",
        "        for term_mobs, plus_pair, partial_sum in tuples:\n",
        "            self.play(\n",
        "                FadeIn(term_mobs),\n",
        "                Write(plus_pair, run_time = 1),\n",
        "                ChangeDecimalToValue(decimal, partial_sum),\n",
        "                run_time = run_time\n",
        "            )\n",
        "            self.wait(run_time)\n",
        "            run_time *= 0.9\n",
        "        self.play(ChangeDecimalToValue(decimal, np.pi**2/4, run_time = 5))\n",
        "        zoom_out.begin_wind_down()\n",
        "        self.wait()\n",
        "        self.remove(zoom_out, scale_decimal)\n",
        "        self.play(*list(map(FadeOut, it.chain(\n",
        "            term_mobjects, plusses, \n",
        "            number_line.numbers, [decimal]\n",
        "        ))))\n",
        "\n",
        "        self.number_line = number_line\n",
        "\n",
        "    def show_giant_circle(self):\n",
        "        self.number_line.insert_n_curves(10000)\n",
        "        everything = VGroup(*self.mobjects)\n",
        "        circle = everything.copy()\n",
        "        circle.move_to(ORIGIN)\n",
        "        circle.apply_function(\n",
        "            lambda x_y_z : complex_to_R3(7*np.exp(complex(0, 0.0315*x_y_z[0])))\n",
        "        )\n",
        "        circle.rotate(-TAU/4, about_point = ORIGIN)\n",
        "        circle.center()\n",
        "\n",
        "        self.play(Transform(everything, circle, run_time = 6))\n",
        "\n",
        "class ButWait(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"But wait!\",\n",
        "            target_mode = \"angry\",\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"sassy\", \"angry\", \"sassy\",\n",
        "            added_anims = [self.teacher.change, \"guilty\"],\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            You promised us \\\\\\\\\n",
        "            $1+{1 \\\\over 4} + {1 \\\\over 9} + {1 \\\\over 16} + \\\\cdots$\n",
        "            \"\"\",\n",
        "            target_mode = \"sassy\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\"Yes, but that's \\\\\\\\ very close.\")\n",
        "        self.play_student_changes(*[\"plain\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class FinalSumManipulationScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "\n",
        "        LIGHT_COLOR2 = RED\n",
        "        LIGHT_COLOR3 = BLUE\n",
        "\n",
        "        unit_length = 1.5\n",
        "        vertical_spacing = 2.5 * DOWN\n",
        "        switch_on_time = 0.2\n",
        "\n",
        "        sum_vertical_spacing = 1.5\n",
        "\n",
        "        randy = self.get_primary_pi_creature()\n",
        "        randy.set_color(MAROON_D)\n",
        "        randy.color = MAROON_D\n",
        "        randy.scale(0.7).flip().to_edge(DOWN + LEFT)\n",
        "        self.wait()\n",
        "\n",
        "        ls_template = LightSource(\n",
        "            radius = 1,\n",
        "            num_levels = 10,\n",
        "            max_opacity_ambient = 0.5,\n",
        "            opacity_function = inverse_quadratic(1,0.75,1)\n",
        "        )\n",
        "\n",
        "\n",
        "        odd_range = np.arange(1,9,2)\n",
        "        even_range = np.arange(2,16,2)\n",
        "        full_range = np.arange(1,8,1)\n",
        "\n",
        "        self.number_line1 = NumberLine(\n",
        "            x_min = 0,\n",
        "            x_max = 11,\n",
        "            color = LAKE_STROKE_COLOR,\n",
        "            number_at_center = 0,\n",
        "            stroke_width = LAKE_STROKE_WIDTH,\n",
        "            stroke_color = LAKE_STROKE_COLOR,\n",
        "            #numbers_to_show = full_range,\n",
        "            number_scale_val = 0.5,\n",
        "            big_tick_numbers = [],\n",
        "            unit_size = unit_length,\n",
        "            tick_frequency = 1,\n",
        "            line_to_number_buff = MED_SMALL_BUFF,\n",
        "            include_tip = True,\n",
        "            label_direction = UP,\n",
        "        )\n",
        "\n",
        "        self.number_line1.next_to(2.5 * UP + 3 * LEFT, RIGHT, buff = 0.3)\n",
        "        self.number_line1.add_numbers()\n",
        "\n",
        "        odd_lights = VMobject()\n",
        "        for i in odd_range:\n",
        "            pos = self.number_line1.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.move_source_to(pos)\n",
        "            odd_lights.add(ls)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.number_line1, run_time = 5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        odd_terms = VMobject()\n",
        "        for i in odd_range:\n",
        "            if i == 1:\n",
        "                term = OldTex(\"\\phantom{+\\,\\,\\,}{1\\over \" + str(i) + \"^2}\",\n",
        "                    fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "            else:\n",
        "                term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\",\n",
        "                    fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "\n",
        "            term.next_to(self.number_line1.number_to_point(i), DOWN, buff = 1.5)\n",
        "            odd_terms.add(term)\n",
        "\n",
        "\n",
        "        for (ls, term) in zip(odd_lights.submobjects, odd_terms.submobjects):\n",
        "            self.play(\n",
        "                FadeIn(ls.lighthouse, run_time = switch_on_time),\n",
        "                SwitchOn(ls.ambient_light, run_time = switch_on_time),\n",
        "                Write(term, run_time = switch_on_time)\n",
        "            )\n",
        "\n",
        "        result1 = OldTex(\"{\\pi^2\\over 8} =\", fill_color = LIGHT_COLOR,\n",
        "            stroke_color = LIGHT_COLOR)\n",
        "        result1.next_to(self.number_line1, LEFT, buff = 0.5)\n",
        "        result1.shift(0.87 * vertical_spacing)\n",
        "        self.play(Write(result1))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        self.number_line2 = self.number_line1.copy()\n",
        "        self.number_line2.numbers_to_show = full_range\n",
        "        self.number_line2.shift(2 * vertical_spacing)\n",
        "        self.number_line2.add_numbers()\n",
        "\n",
        "        full_lights = VMobject()\n",
        "\n",
        "        for i in full_range:\n",
        "            pos = self.number_line2.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.color = LIGHT_COLOR3\n",
        "            ls.move_source_to(pos)\n",
        "            full_lights.add(ls)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(self.number_line2, run_time = 5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        full_lighthouses = VMobject()\n",
        "        full_ambient_lights = VMobject()\n",
        "        for ls in full_lights:\n",
        "            full_lighthouses.add(ls.lighthouse)\n",
        "            full_ambient_lights.add(ls.ambient_light)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, full_lighthouses, lag_ratio = 0.2, run_time = 3),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(SwitchOn, full_ambient_lights, lag_ratio = 0.2, run_time = 3)\n",
        "        )\n",
        "\n",
        "        # for ls in full_lights.submobjects:\n",
        "        #     self.play(\n",
        "        #         FadeIn(ls.lighthouse, run_time = 0.1),#5 * switch_on_time),\n",
        "        #         SwitchOn(ls.ambient_light, run_time = 0.1)#5 * switch_on_time),\n",
        "        #     )\n",
        "\n",
        "\n",
        "\n",
        "        even_terms = VMobject()\n",
        "        for i in even_range:\n",
        "            term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR2, stroke_color = LIGHT_COLOR)\n",
        "            term.next_to(self.number_line1.number_to_point(i), DOWN, buff = sum_vertical_spacing)\n",
        "            even_terms.add(term)\n",
        "\n",
        "\n",
        "        even_lights = VMobject()\n",
        "\n",
        "        for i in even_range:\n",
        "            pos = self.number_line1.number_to_point(i)\n",
        "            ls = ls_template.copy()\n",
        "            ls.color = LIGHT_COLOR2\n",
        "            ls.move_source_to(pos)\n",
        "            even_lights.add(ls)\n",
        "\n",
        "        for (ls, term) in zip(even_lights.submobjects, even_terms.submobjects):\n",
        "            self.play(\n",
        "                SwitchOn(ls.ambient_light, run_time = switch_on_time),\n",
        "                Write(term)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "        # now morph the even lights into the full lights\n",
        "        full_lights_copy = full_lights.copy()\n",
        "        even_lights_copy = even_lights.copy()\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Transform(even_lights,full_lights, run_time = 2)\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for i in range(6):\n",
        "            self.play(\n",
        "                Transform(even_lights[i], even_lights_copy[i])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # draw arrows\n",
        "        P1 = self.number_line2.number_to_point(1)\n",
        "        P2 = even_terms.submobjects[0].get_center()\n",
        "        Q1 = interpolate(P1, P2, 0.2)\n",
        "        Q2 = interpolate(P1, P2, 0.8)\n",
        "        quarter_arrow = Arrow(Q1, Q2,\n",
        "            color = LIGHT_COLOR2)\n",
        "        quarter_label = OldTex(\"\\\\times {1\\over 4}\", fill_color = LIGHT_COLOR2, stroke_color = LIGHT_COLOR2)\n",
        "        quarter_label.scale(0.7)\n",
        "        quarter_label.next_to(quarter_arrow.get_center(), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(quarter_arrow),\n",
        "            Write(quarter_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        P3 = odd_terms.submobjects[0].get_center()\n",
        "        R1 = interpolate(P1, P3, 0.2)\n",
        "        R2 = interpolate(P1, P3, 0.8)\n",
        "        three_quarters_arrow = Arrow(R1, R2,\n",
        "            color = LIGHT_COLOR)\n",
        "        three_quarters_label = OldTex(\"\\\\times {3\\over 4}\", fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "        three_quarters_label.scale(0.7)\n",
        "        three_quarters_label.next_to(three_quarters_arrow.get_center(), LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(three_quarters_arrow),\n",
        "            Write(three_quarters_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        four_thirds_arrow = Arrow(R2, R1, color = LIGHT_COLOR)\n",
        "        four_thirds_label = OldTex(\"\\\\times {4\\over 3}\", fill_color = LIGHT_COLOR, stroke_color = LIGHT_COLOR)\n",
        "        four_thirds_label.scale(0.7)\n",
        "        four_thirds_label.next_to(four_thirds_arrow.get_center(), LEFT)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(quarter_label),\n",
        "            FadeOut(quarter_arrow),\n",
        "            FadeOut(even_lights),\n",
        "            FadeOut(even_terms)\n",
        "\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(three_quarters_arrow, four_thirds_arrow),\n",
        "            ReplacementTransform(three_quarters_label, four_thirds_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        full_terms = VMobject()\n",
        "        for i in range(1,8): #full_range:\n",
        "            if i == 1:\n",
        "                term = OldTex(\"\\phantom{+\\,\\,\\,}{1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "            elif i == 7:\n",
        "                term = OldTex(\"+\\,\\,\\,\\dots\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "            else:\n",
        "                term = OldTex(\"+\\,\\,\\, {1\\over \" + str(i) + \"^2}\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "\n",
        "            term.move_to(self.number_line2.number_to_point(i))\n",
        "            full_terms.add(term)\n",
        "\n",
        "        #return\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.number_line1),\n",
        "            FadeOut(odd_lights),\n",
        "            FadeOut(self.number_line2),\n",
        "            FadeOut(full_lights),\n",
        "            FadeIn(full_terms)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        v = (sum_vertical_spacing + 0.5) * UP\n",
        "        self.play(\n",
        "            odd_terms.shift, v,\n",
        "            result1.shift, v,\n",
        "            four_thirds_arrow.shift, v,\n",
        "            four_thirds_label.shift, v,\n",
        "            odd_terms.shift, v,\n",
        "            full_terms.shift, v\n",
        "        )\n",
        "\n",
        "        arrow_copy = four_thirds_arrow.copy()\n",
        "        label_copy = four_thirds_label.copy()\n",
        "        arrow_copy.shift(2.5 * LEFT)\n",
        "        label_copy.shift(2.5 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(arrow_copy),\n",
        "            FadeIn(label_copy)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        final_result = OldTex(\"{\\pi^2 \\over 6}=\", fill_color = LIGHT_COLOR3, stroke_color = LIGHT_COLOR3)\n",
        "        final_result.next_to(arrow_copy, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(final_result),\n",
        "            randy.change_mode,\"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        equation = VMobject()\n",
        "        equation.add(final_result)\n",
        "        equation.add(full_terms)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(result1),\n",
        "            FadeOut(odd_terms),\n",
        "            FadeOut(arrow_copy),\n",
        "            FadeOut(label_copy),\n",
        "            FadeOut(four_thirds_arrow),\n",
        "            FadeOut(four_thirds_label),\n",
        "            full_terms.shift,LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(equation.shift, -equation.get_center()[1] * UP + UP + 1.5 * LEFT)\n",
        "\n",
        "        result_box = Rectangle(width = 1.1 * equation.get_width(),\n",
        "            height = 2 * equation.get_height(), color = LIGHT_COLOR3)\n",
        "        result_box.move_to(equation)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(result_box)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class LabeledArc(Arc):\n",
        "    CONFIG = {\n",
        "        \"length\" : 1\n",
        "    }\n",
        "\n",
        "    def __init__(self, angle, **kwargs):\n",
        "\n",
        "        BUFFER = 0.8\n",
        "\n",
        "        Arc.__init__(self,angle,**kwargs)\n",
        "\n",
        "        label = DecimalNumber(self.length, num_decimal_places = 0)\n",
        "        r = BUFFER * self.radius\n",
        "        theta = self.start_angle + self.angle/2\n",
        "        label_pos = r * np.array([np.cos(theta), np.sin(theta), 0])\n",
        "\n",
        "        label.move_to(label_pos)\n",
        "        self.add(label)\n",
        "\n",
        "class ArcHighlightOverlaySceneCircumferenceEight(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        BASELINE_YPOS = -2.5\n",
        "        OBSERVER_POINT = [0,BASELINE_YPOS,0]\n",
        "        LAKE0_RADIUS = 2.5\n",
        "        INDICATOR_RADIUS = 0.6\n",
        "        TICK_SIZE = 0.5\n",
        "        LIGHTHOUSE_HEIGHT = 0.2\n",
        "        LAKE_COLOR = BLUE\n",
        "        LAKE_OPACITY = 0.15\n",
        "        LAKE_STROKE_WIDTH = 5.0\n",
        "        LAKE_STROKE_COLOR = BLUE\n",
        "        TEX_SCALE = 0.8\n",
        "        DOT_COLOR = BLUE\n",
        "\n",
        "        FLASH_TIME = 1\n",
        "\n",
        "        def flash_arcs(n):\n",
        "\n",
        "            angle = TAU/2**n\n",
        "            arcs = []\n",
        "            arcs.append(LabeledArc(angle/2, start_angle = -TAU/4, radius = LAKE0_RADIUS, length = 1))\n",
        "\n",
        "            for i in range(1,2**n):\n",
        "                arcs.append(LabeledArc(angle, start_angle = -TAU/4 + (i-0.5)*angle, radius = LAKE0_RADIUS, length = 2))\n",
        "        \n",
        "            arcs.append(LabeledArc(angle/2, start_angle = -TAU/4 - angle/2, radius = LAKE0_RADIUS, length = 1))\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(arcs[0], run_time = FLASH_TIME)\n",
        "            )\n",
        "\n",
        "            for i in range(1,2**n + 1):\n",
        "                self.play(\n",
        "                    FadeOut(arcs[i-1], run_time = FLASH_TIME),\n",
        "                    FadeIn(arcs[i], run_time = FLASH_TIME)\n",
        "                )\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(arcs[2**n], run_time = FLASH_TIME),\n",
        "            )\n",
        "\n",
        "        flash_arcs(self.n)\n",
        "\n",
        "class ArcHighlightOverlaySceneCircumferenceSixteen(ArcHighlightOverlaySceneCircumferenceEight):\n",
        "    CONFIG = {\n",
        "        \"n\" : 3,\n",
        "    }\n",
        "\n",
        "class InfiniteCircleScene(PiCreatureScene):\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        morty = self.get_primary_pi_creature()\n",
        "        morty.set_color(MAROON_D).flip()\n",
        "        morty.color = MAROON_D\n",
        "        morty.scale(0.5).move_to(ORIGIN)\n",
        "\n",
        "        arrow = Arrow(ORIGIN, 2.4 * RIGHT)\n",
        "        dot = Dot(color = BLUE).next_to(arrow)\n",
        "        ellipsis = OldTex(\"\\dots\")\n",
        "\n",
        "        infsum = VGroup()\n",
        "        infsum.add(ellipsis.copy())\n",
        "\n",
        "        for i in range(3):\n",
        "            infsum.add(arrow.copy().next_to(infsum.submobjects[-1]))\n",
        "            infsum.add(dot.copy().next_to(infsum.submobjects[-1]))\n",
        "\n",
        "        infsum.add(arrow.copy().next_to(infsum.submobjects[-1]))\n",
        "        infsum.add(ellipsis.copy().next_to(infsum.submobjects[-1]))\n",
        "\n",
        "        infsum.next_to(morty,DOWN, buff = 1)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn,infsum,lag_ratio = 0.2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        A = infsum.submobjects[-1].get_center() + 0.5 * RIGHT\n",
        "        B = A + RIGHT + 1.3 * UP + 0.025 * LEFT\n",
        "        right_arc = DashedLine(TAU/4*UP, ORIGIN, stroke_color = YELLOW,\n",
        "            stroke_width = 8).apply_complex_function(np.exp)\n",
        "        right_arc.rotate(-TAU/4).next_to(infsum, RIGHT).shift(0.5 * UP)\n",
        "        right_tip_line = Arrow(B - UP, B, color = WHITE)\n",
        "        right_tip_line.add_tip()\n",
        "        right_tip = right_tip_line.get_tip()\n",
        "        right_tip.set_fill(color = YELLOW)\n",
        "        right_arc.add(right_tip)\n",
        "        \n",
        "\n",
        "        C = B + 3.2 * UP\n",
        "        right_line = DashedLine(B + 0.2 * DOWN,C + 0.2 * UP, stroke_color = YELLOW,\n",
        "            stroke_width = 8)\n",
        "\n",
        "        ru_arc = right_arc.copy().rotate(angle = TAU/4)\n",
        "        ru_arc.remove(ru_arc.submobjects[-1])\n",
        "        ru_arc.to_edge(UP+RIGHT, buff = 0.15)\n",
        "\n",
        "        D = np.array([5.85, 3.85,0])\n",
        "        E = np.array([-D[0],D[1],0])\n",
        "        up_line = DashedLine(D, E, stroke_color = YELLOW,\n",
        "            stroke_width = 8)\n",
        "\n",
        "        lu_arc = ru_arc.copy().flip().to_edge(LEFT + UP, buff = 0.15)\n",
        "        left_line = right_line.copy().flip(axis = RIGHT).to_edge(LEFT, buff = 0.15)\n",
        "\n",
        "        left_arc = right_arc.copy().rotate(-TAU/4)\n",
        "        left_arc.next_to(infsum, LEFT).shift(0.5 * UP + 0.1 * LEFT)\n",
        "\n",
        "        right_arc.shift(0.2 * RIGHT)\n",
        "        right_line.shift(0.2 * RIGHT)\n",
        "\n",
        "        self.play(FadeIn(right_arc))\n",
        "        self.play(ShowCreation(right_line))\n",
        "        self.play(FadeIn(ru_arc))\n",
        "        self.play(ShowCreation(up_line))\n",
        "        self.play(FadeIn(lu_arc))\n",
        "        self.play(ShowCreation(left_line))\n",
        "        self.play(FadeIn(left_arc))\n",
        "\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class Credits(Scene):\n",
        "    def construct(self):\n",
        "        credits = VGroup(*[\n",
        "            VGroup(*list(map(TexText, pair)))\n",
        "            for pair in [\n",
        "                (\"Primary writer and animator:\", \"Ben Hambrecht\"),\n",
        "                (\"Editing, advising, narrating:\", \"Grant Sanderson\"),\n",
        "                (\"Based on a paper originally by:\", \"Johan W\u00e4stlund\"),\n",
        "            ]\n",
        "        ])\n",
        "        for credit, color in zip(credits, [MAROON_D, BLUE_D, WHITE]):\n",
        "            credit[1].set_color(color)\n",
        "            credit.arrange(DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        credits.arrange(DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        credits.center()\n",
        "        patreon_logo = PatreonLogo()\n",
        "        patreon_logo.to_edge(UP)\n",
        "\n",
        "        for credit in credits:\n",
        "            self.play(LaggedStartMap(FadeIn, credit[0]))\n",
        "            self.play(FadeIn(credit[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            credits.next_to, patreon_logo.get_bottom(), DOWN, MED_LARGE_BUFF,\n",
        "            DrawBorderThenFill(patreon_logo)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"https://brilliant.org/3b1b/\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "        self.remove(rect)\n",
        "        self.play(\n",
        "            url.next_to, self.pi_creature, UP+LEFT\n",
        "        )\n",
        "        url_rect = SurroundingRectangle(url)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(FadeOut(url_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class BaselPatreonThanks(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"CrypticSwarm \",\n",
        "            \"Ali Yahya\",\n",
        "            \"Juan Benet\",\n",
        "            \"Markus Persson\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Sh\u00ecm\u00edn Ku$\\\\overline{\\\\text{a}}$ng\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Robert Teed\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Mark Govea\",\n",
        "            \"John Haley\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Desmos  \",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Randall Hunt\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Awoo\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Linh Tran\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James H. Park\",\n",
        "            \"Ankalagon   \",\n",
        "            \"Devin Scott\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Eric Chow\",\n",
        "            \"Michael Gardner\",\n",
        "            \"David Kedmey\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"supershabam \",\n",
        "            \"1stViewMaths \",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Ross Garber\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Isak Hietala\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"David B\",\n",
        "            \"Delton Ding\",\n",
        "            \"James Thornton\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"George Chiesa\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Alexander Feldman\",\n",
        "            \"David MacCumber\",\n",
        "            \"Jacob Kohl\",\n",
        "            \"Sergei  \",\n",
        "            \"Frank Secilia\",\n",
        "            \"Patrick M\u00e9zard\",\n",
        "            \"George John\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ignacio Freiberg\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Karl Niu\",\n",
        "            \"Dan Esposito\",\n",
        "            \"Michael Kunze\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Andrejs Olins\",\n",
        "            \"Cody Brocious\",\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        next_video = OldTexText(\"$\\\\uparrow$  Next video $\\\\uparrow$\")\n",
        "        next_video.to_edge(RIGHT, buff = 1.5)\n",
        "        next_video.shift(MED_SMALL_BUFF*UP)\n",
        "        next_video.set_color(YELLOW)\n",
        "        self.add_foreground_mobject(next_video)\n",
        "        PatreonEndScreen.construct(self)\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    CONFIG = {\n",
        "        \"light_source_config\" : {\n",
        "            \"num_levels\" : 250,\n",
        "            \"radius\" : 10.0, \n",
        "            \"max_opacity_ambient\" : 1.0,\n",
        "            \"opacity_function\" : inverse_quadratic(1,0.25,1)\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"1\", \"+\", \"{1\\over 4}\", \"+\", \n",
        "            \"{1\\over 9}\",\"+\", \"{1\\over 16}\",\"+\", \n",
        "            \"{1\\over 25}\", \"+\", \"\\cdots\"\n",
        "        )\n",
        "        equation.scale(1.8)\n",
        "        equation.move_to(2*UP)\n",
        "        equation.set_stroke(RED, 1)\n",
        "        answer = OldTex(\"= \\\\frac{\\\\pi^2}{6}\", color = LIGHT_COLOR)\n",
        "        answer.scale(3)\n",
        "        answer.set_stroke(RED, 1)\n",
        "        # answer.next_to(equation, DOWN, buff = 1)\n",
        "        answer.move_to(1.25*DOWN)\n",
        "        #equation.move_to(2 * UP)\n",
        "        #answer = OldTex(\"={\\pi^2\\over 6}\", color = LIGHT_COLOR).scale(3)\n",
        "        #answer.next_to(equation, DOWN, buff = 1)\n",
        "\n",
        "        lake_radius = 6\n",
        "        lake_center = ORIGIN\n",
        "\n",
        "        lake = Circle(\n",
        "            fill_color = BLUE, \n",
        "            fill_opacity = 0.15,\n",
        "            radius = lake_radius,\n",
        "            stroke_color = BLUE_D, \n",
        "            stroke_width = 3,\n",
        "        )\n",
        "        lake.move_to(lake_center)\n",
        "\n",
        "        for i in range(16):\n",
        "            theta = -TAU/4 + (i + 0.5) * TAU/16\n",
        "            pos = lake_center + lake_radius * np.array([np.cos(theta), np.sin(theta), 0])\n",
        "            ls = LightSource(**self.light_source_config)\n",
        "            ls.move_source_to(pos)\n",
        "            lake.add(ls.ambient_light)\n",
        "            lake.add(ls.lighthouse)\n",
        "\n",
        "        self.add(lake)\n",
        "        self.add(equation, answer)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}