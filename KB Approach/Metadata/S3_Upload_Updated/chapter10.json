{
    "topic": "is demonstrating the concept of Taylor series approximation for functions. The `derivative`",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "def derivative(func, x, n = 1, dx = 0.01):\n",
        "    samples = [func(x + (k - n/2)*dx) for k in range(n+1)]\n",
        "    while len(samples) > 1:\n",
        "        samples = [\n",
        "            (s_plus_dx - s)/dx\n",
        "            for s, s_plus_dx in zip(samples, samples[1:])\n",
        "        ]\n",
        "    return samples[0]\n",
        "\n",
        "def taylor_approximation(func, highest_term, center_point = 0):\n",
        "    derivatives = [\n",
        "        derivative(func, center_point, n = n)\n",
        "        for n in range(highest_term + 1)\n",
        "    ]\n",
        "    coefficients = [\n",
        "        d/math.factorial(n) \n",
        "        for n, d in enumerate(derivatives)\n",
        "    ]\n",
        "    return lambda x : sum([\n",
        "        c*((x-center_point)**n) \n",
        "        for n, c in enumerate(coefficients)\n",
        "    ])\n",
        "\n",
        "class Chapter10OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"For me, mathematics is a collection of \", \n",
        "            \"examples\", \"; a \",\n",
        "            \"theorem\", \" is a statement about a collection of \",\n",
        "            \"examples\", \" and the purpose of proving \",\n",
        "            \"theorems\", \" is to classify and explain the \",\n",
        "            \"examples\", \".\"\n",
        "        ],\n",
        "        \"quote_arg_separator\" : \"\",\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"examples\" : BLUE,\n",
        "        },\n",
        "        \"author\" : \"John B. Conway\",\n",
        "        \"fade_in_kwargs\" : {\n",
        "            \"run_time\" : 7,\n",
        "        }\n",
        "    }\n",
        "\n",
        "class ExampleApproximation(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"function\" : lambda x : np.exp(-x**2),\n",
        "        \"function_tex\" : \"e^{-x^2}\", \n",
        "        \"function_color\" : BLUE,\n",
        "        \"order_sequence\" : [0, 2, 4],\n",
        "        \"center_point\" : 0,\n",
        "        \"approximation_terms\" : [\"1 \", \"-x^2\", \"+\\\\frac{1}{2}x^4\"],\n",
        "        \"approximation_color\" : GREEN,\n",
        "        \"x_min\" : -3,\n",
        "        \"x_max\" : 3,\n",
        "        \"y_min\" : -1,\n",
        "        \"y_max\" : 2,\n",
        "        \"graph_origin\" : DOWN + 2*LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        func_graph = self.get_graph(\n",
        "            self.function,\n",
        "            self.function_color,\n",
        "        )\n",
        "        approx_graphs = [\n",
        "            self.get_graph(\n",
        "                taylor_approximation(self.function, n),\n",
        "                self.approximation_color\n",
        "            )\n",
        "            for n in self.order_sequence\n",
        "        ]\n",
        "\n",
        "        near_text = OldTexText(\n",
        "            \"Near %s $= %d$\"%(\n",
        "                self.x_axis_label, self.center_point\n",
        "            )\n",
        "        )\n",
        "        near_text.to_corner(UP + RIGHT)\n",
        "        near_text.add_background_rectangle()\n",
        "        equation = OldTex(\n",
        "            self.function_tex, \n",
        "            \"\\\\approx\",\n",
        "            *self.approximation_terms\n",
        "        )\n",
        "        equation.next_to(near_text, DOWN, MED_LARGE_BUFF)\n",
        "        equation.to_edge(RIGHT)\n",
        "        near_text.next_to(equation, UP, MED_LARGE_BUFF)\n",
        "        equation.set_color_by_tex(\n",
        "            self.function_tex, self.function_color,\n",
        "            substring = False\n",
        "        )\n",
        "        approx_terms = VGroup(*[\n",
        "            equation.get_part_by_tex(tex, substring = False)\n",
        "            for tex in self.approximation_terms\n",
        "        ])\n",
        "        approx_terms.set_fill(\n",
        "            self.approximation_color,\n",
        "            opacity = 0,\n",
        "        )\n",
        "        equation.add_background_rectangle()\n",
        "\n",
        "        approx_graph = VectorizedPoint(\n",
        "            self.input_to_graph_point(self.center_point, func_graph)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(func_graph, run_time = 2),\n",
        "            Animation(equation),\n",
        "            Animation(near_text),\n",
        "        )\n",
        "        for graph, term in zip(approx_graphs, approx_terms):\n",
        "            self.play(\n",
        "                Transform(approx_graph, graph, run_time = 2),\n",
        "                Animation(equation),\n",
        "                Animation(near_text),\n",
        "                term.set_fill, None, 1,\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "class ExampleApproximationWithSine(ExampleApproximation):\n",
        "    CONFIG = {\n",
        "        \"function\" : np.sin,\n",
        "        \"function_tex\" : \"\\\\sin(x)\", \n",
        "        \"order_sequence\" : [1, 3, 5],\n",
        "        \"center_point\" : 0,\n",
        "        \"approximation_terms\" : [\n",
        "            \"x\", \n",
        "            \"-\\\\frac{1}{6}x^3\", \n",
        "            \"+\\\\frac{1}{120}x^5\",\n",
        "        ],\n",
        "        \"approximation_color\" : GREEN,\n",
        "        \"x_min\" : -2*np.pi,\n",
        "        \"x_max\" : 2*np.pi,\n",
        "        \"x_tick_frequency\" : np.pi/2,\n",
        "        \"y_min\" : -2,\n",
        "        \"y_max\" : 2,\n",
        "        \"graph_origin\" : DOWN + 2*LEFT,\n",
        "    }\n",
        "\n",
        "class ExampleApproximationWithExp(ExampleApproximation):\n",
        "    CONFIG = {\n",
        "        \"function\" : np.exp,\n",
        "        \"function_tex\" : \"e^x\", \n",
        "        \"order_sequence\" : [1, 2, 3, 4],\n",
        "        \"center_point\" : 0,\n",
        "        \"approximation_terms\" : [\n",
        "            \"1 + x\", \n",
        "            \"+\\\\frac{1}{2}x^2\", \n",
        "            \"+\\\\frac{1}{6}x^3\",\n",
        "            \"+\\\\frac{1}{24}x^4\",\n",
        "        ],\n",
        "        \"approximation_color\" : GREEN,\n",
        "        \"x_min\" : -3,\n",
        "        \"x_max\" : 4,\n",
        "        \"y_min\" : -1,\n",
        "        \"y_max\" : 10,\n",
        "        \"graph_origin\" : 2*DOWN + 3*LEFT,\n",
        "    }\n",
        "\n",
        "class Pendulum(ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_point\" : 3*UP + 4*LEFT,\n",
        "        \"radius\" : 4,\n",
        "        \"weight_radius\" : 0.2,\n",
        "        \"angle\" : np.pi/6,\n",
        "        \"approx_tex\" : [\n",
        "            \"\\\\approx 1 - \", \"{\\\\theta\", \"^2\", \"\\\\over\", \"2}\"\n",
        "        ],\n",
        "        \"leave_original_cosine\" : False,\n",
        "        \"perform_substitution\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_pendulum()\n",
        "        self.show_oscillation()\n",
        "        self.show_height()\n",
        "        self.get_angry_at_cosine()\n",
        "        self.substitute_approximation()\n",
        "        self.show_confusion()\n",
        "\n",
        "    def draw_pendulum(self):\n",
        "        pendulum = self.get_pendulum()\n",
        "        ceiling = self.get_ceiling()\n",
        "\n",
        "        self.add(ceiling)\n",
        "        self.play(ShowCreation(pendulum.line))\n",
        "        self.play(DrawBorderThenFill(pendulum.weight, run_time = 1))\n",
        "\n",
        "        self.pendulum = pendulum\n",
        "\n",
        "    def show_oscillation(self):\n",
        "        trajectory_dots = self.get_trajectory_dots()\n",
        "        kwargs = self.get_swing_kwargs()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                trajectory_dots,\n",
        "                rate_func=linear,\n",
        "                run_time = kwargs[\"run_time\"]\n",
        "            ),\n",
        "            Rotate(self.pendulum, -2*self.angle, **kwargs),\n",
        "        )\n",
        "        for m in 2, -2, 2:\n",
        "            self.play(Rotate(self.pendulum, m*self.angle, **kwargs))\n",
        "        self.wait()\n",
        "\n",
        "    def show_height(self):\n",
        "        v_line = self.get_v_line()\n",
        "        h_line = self.get_h_line()\n",
        "        radius_brace = self.get_radius_brace()\n",
        "        height_brace = self.get_height_brace()\n",
        "        height_tex = self.get_height_brace_tex(height_brace)\n",
        "        arc, theta = self.get_arc_and_theta()\n",
        "\n",
        "        height_tex_R = height_tex.get_part_by_tex(\"R\")\n",
        "        height_tex_theta = height_tex.get_part_by_tex(\"\\\\theta\")\n",
        "        to_write = VGroup(*[\n",
        "            part\n",
        "            for part in height_tex\n",
        "            if part not in [height_tex_R, height_tex_theta]\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            GrowFromCenter(height_brace)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(radius_brace)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(to_write),\n",
        "            ReplacementTransform(\n",
        "                radius_brace[-1].copy(),\n",
        "                height_tex_R\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                theta.copy(),\n",
        "                height_tex_theta\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.arc = arc\n",
        "        self.theta = theta\n",
        "        self.height_tex_R = height_tex_R\n",
        "        self.cosine = VGroup(*[\n",
        "            height_tex.get_part_by_tex(tex)\n",
        "            for tex in (\"cos\", \"theta\", \")\")\n",
        "        ])\n",
        "        self.one_minus = VGroup(*[\n",
        "            height_tex.get_part_by_tex(tex)\n",
        "            for tex in (\"\\\\big(1-\", \"\\\\big)\")\n",
        "        ])\n",
        "\n",
        "    def get_angry_at_cosine(self):\n",
        "        cosine = self.cosine\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        cosine.generate_target()\n",
        "        cosine.save_state()\n",
        "        cosine.target.next_to(morty, UP)\n",
        "        if self.leave_original_cosine:\n",
        "            cosine_copy = cosine.copy()\n",
        "            self.add(cosine_copy)\n",
        "            self.one_minus.add(cosine_copy)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            MoveToTarget(cosine),\n",
        "            morty.change, \"angry\", cosine.target,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        self.morty = morty\n",
        "\n",
        "    def substitute_approximation(self):\n",
        "        morty = self.morty\n",
        "        cosine = self.cosine\n",
        "        cosine.generate_target()\n",
        "        cosine_approx = self.get_cosine_approx()\n",
        "        cosine_approx.next_to(cosine, UP+RIGHT)\n",
        "        cosine_approx.to_edge(RIGHT)\n",
        "        cosine.target.next_to(\n",
        "            cosine_approx, LEFT,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        kwargs = self.get_swing_kwargs()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                cosine_approx,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            MoveToTarget(cosine),\n",
        "            morty.change, \"pondering\", cosine_approx\n",
        "        )\n",
        "        self.wait()\n",
        "        if not self.perform_substitution:\n",
        "            return\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                cosine_approx.theta_squared_over_two.copy().next_to,\n",
        "                self.height_tex_R,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            FadeOut(self.one_minus),\n",
        "            morty.look_at, self.height_tex_R,\n",
        "        )\n",
        "        self.play(morty.change, \"thinking\", self.height_tex_R)\n",
        "        self.transition_to_alt_config(\n",
        "            angle = np.pi/12,\n",
        "            transformation_kwargs = {\"run_time\" : 2},\n",
        "        )\n",
        "\n",
        "    def show_confusion(self):\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.scale(0.8)\n",
        "        randy.next_to(self.cosine, DOWN+LEFT)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change, \"confused\", self.cosine\n",
        "        )\n",
        "        self.play(randy.look_at, self.height_tex_R)\n",
        "        self.wait()\n",
        "        self.play(randy.look_at, self.cosine)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    #######\n",
        "\n",
        "    def get_pendulum(self):\n",
        "        line = Line(\n",
        "            self.anchor_point,\n",
        "            self.anchor_point + self.radius*DOWN,\n",
        "            color = WHITE\n",
        "        )\n",
        "        weight = Circle(\n",
        "            radius = self.weight_radius,\n",
        "            fill_color = GREY,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        weight.move_to(line.get_end())\n",
        "        result = VGroup(line, weight)\n",
        "        result.rotate(\n",
        "            self.angle, \n",
        "            about_point = self.anchor_point\n",
        "        )\n",
        "        result.line = line\n",
        "        result.weight = weight\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_ceiling(self):\n",
        "        line = Line(LEFT, RIGHT, color = GREY)\n",
        "        line.scale(FRAME_X_RADIUS)\n",
        "        line.move_to(self.anchor_point[1]*UP)\n",
        "        return line\n",
        "\n",
        "    def get_trajectory_dots(self, n_dots = 40, color = YELLOW):\n",
        "        arc_angle = np.pi/6\n",
        "        proportions = self.swing_rate_func(\n",
        "            np.linspace(0, 1, n_dots)\n",
        "        )\n",
        "        angles = -2*arc_angle*proportions\n",
        "        angle_to_point = lambda a : np.cos(a)*RIGHT + np.sin(a)*UP\n",
        "        dots = VGroup(*[\n",
        "            # Line(*map(angle_to_point, pair))\n",
        "            Dot(angle_to_point(angle), radius = 0.005)\n",
        "            for angle in angles\n",
        "        ])\n",
        "            \n",
        "        dots.set_color(color)\n",
        "        dots.scale(self.radius)\n",
        "        dots.rotate(-np.pi/2 + arc_angle)\n",
        "        dots.shift(self.anchor_point)\n",
        "        return dots\n",
        "\n",
        "    def get_v_line(self):\n",
        "        return DashedLine(\n",
        "            self.anchor_point, \n",
        "            self.anchor_point + self.radius*DOWN,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "    def get_h_line(self, color = BLUE):\n",
        "        start = self.anchor_point + self.radius*DOWN\n",
        "        end = start + self.radius*np.sin(self.angle)*RIGHT\n",
        "\n",
        "        return Line(start, end, color = color)\n",
        "\n",
        "    def get_radius_brace(self):\n",
        "        v_line = self.get_v_line()\n",
        "        brace = Brace(v_line, RIGHT)\n",
        "        brace.rotate(self.angle, about_point = self.anchor_point)\n",
        "        brace.add(brace.get_text(\"$R$\", buff = SMALL_BUFF))\n",
        "        return brace\n",
        "\n",
        "    def get_height_brace(self):\n",
        "        h_line = self.get_h_line()\n",
        "        height = (1 - np.cos(self.angle))*self.radius\n",
        "        line = Line(\n",
        "            h_line.get_end(),\n",
        "            h_line.get_end() + height*UP,\n",
        "        )\n",
        "        brace = Brace(line, RIGHT)\n",
        "        return brace\n",
        "\n",
        "    def get_height_brace_tex(self, brace):\n",
        "        tex_mob = OldTex(\n",
        "            \"R\", \"\\\\big(1-\", \"\\\\cos(\", \"\\\\theta\", \")\", \"\\\\big)\"\n",
        "        )\n",
        "        tex_mob.set_color_by_tex(\"theta\", YELLOW)\n",
        "        tex_mob.next_to(brace, RIGHT)\n",
        "        return tex_mob\n",
        "\n",
        "    def get_arc_and_theta(self):\n",
        "        arc = Arc(\n",
        "            start_angle = -np.pi/2,\n",
        "            angle = self.angle,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.set_color(YELLOW)\n",
        "        theta.next_to(\n",
        "            arc.point_from_proportion(0.5), \n",
        "            DOWN, SMALL_BUFF\n",
        "        )\n",
        "        for mob in arc, theta:\n",
        "            mob.shift(self.anchor_point)\n",
        "        return arc, theta\n",
        "\n",
        "    def get_cosine_approx(self):\n",
        "        approx = OldTex(*self.approx_tex)\n",
        "        approx.set_color_by_tex(\"theta\", YELLOW)\n",
        "        approx.theta_squared_over_two = VGroup(*approx[1:5])\n",
        "\n",
        "        return approx\n",
        "\n",
        "    def get_swing_kwargs(self):\n",
        "        return {\n",
        "            \"about_point\" : self.anchor_point,\n",
        "            \"run_time\" : 1.7,\n",
        "            \"rate_func\" : self.swing_rate_func,\n",
        "        }\n",
        "\n",
        "    def swing_rate_func(self, t):\n",
        "        return (1-np.cos(np.pi*t))/2.0\n",
        "\n",
        "class PendulumWithBetterApprox(Pendulum):\n",
        "    CONFIG = {\n",
        "        \"approx_tex\" : [\n",
        "            \"\\\\approx 1 - \", \"{\\\\theta\", \"^2\", \"\\\\over\", \"2}\",\n",
        "            \"+\", \"{\\\\theta\", \"^4\", \"\\\\over\", \"24}\"\n",
        "        ],\n",
        "        \"leave_original_cosine\" : True,\n",
        "        \"perform_substitution\" : False,\n",
        "    }\n",
        "    def show_confusion(self):\n",
        "        pass\n",
        "\n",
        "class ExampleApproximationWithCos(ExampleApproximationWithSine):\n",
        "    CONFIG = {\n",
        "        \"function\" : np.cos,\n",
        "        \"function_tex\" : \"\\\\cos(\\\\theta)\", \n",
        "        \"order_sequence\" : [0, 2],\n",
        "        \"approximation_terms\" : [\n",
        "            \"1\", \n",
        "            \"-\\\\frac{1}{2} \\\\theta ^2\", \n",
        "        ],\n",
        "        \"x_axis_label\" : \"$\\\\theta$\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_axis_width\" : 13,\n",
        "        \"graph_origin\" : DOWN,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ExampleApproximationWithSine.construct(self)\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        high_graph = self.get_graph(lambda x : 4)\n",
        "        v_lines, alt_v_lines = [\n",
        "            VGroup(*[\n",
        "                self.get_vertical_line_to_graph(\n",
        "                    u*dx, high_graph,\n",
        "                    line_class = DashedLine,\n",
        "                    color = YELLOW\n",
        "                )\n",
        "                for u in (-1, 1)\n",
        "            ])\n",
        "            for dx in (0.01, 0.7)\n",
        "        ]\n",
        "\n",
        "        self.play(*list(map(ShowCreation, v_lines)), run_time = 2)\n",
        "        self.play(Transform(\n",
        "            v_lines, alt_v_lines,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"How...?\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            look_at = self.graph_origin,\n",
        "            target_mode = \"confused\"\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        x_val_label_pairs = [\n",
        "            (-np.pi, \"-\\\\pi\"),\n",
        "            (np.pi, \"\\\\pi\"),\n",
        "            (2*np.pi, \"2\\\\pi\"),\n",
        "        ]\n",
        "        self.x_axis_labels = VGroup()\n",
        "        for x_val, label in x_val_label_pairs:\n",
        "            tex = OldTex(label)\n",
        "            tex.next_to(self.coords_to_point(x_val, 0), DOWN)\n",
        "            self.add(tex)\n",
        "            self.x_axis_labels.add(tex)\n",
        "\n",
        "class ConstructQuadraticApproximation(ExampleApproximationWithCos):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"$x$\",\n",
        "        \"colors\" : [BLUE, YELLOW, GREEN],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_cosine_graph()\n",
        "        self.add_quadratic_graph()\n",
        "        self.introduce_quadratic_constants()\n",
        "        self.show_value_at_zero()\n",
        "        self.set_c0_to_one()\n",
        "        self.let_c1_and_c2_vary()\n",
        "        self.show_tangent_slope()\n",
        "        self.compute_cosine_derivative()\n",
        "        self.compute_polynomial_derivative()\n",
        "        self.let_c2_vary()\n",
        "        self.point_out_negative_concavity()\n",
        "        self.compute_cosine_second_derivative()\n",
        "        self.show_matching_curvature()\n",
        "        self.show_matching_tangent_lines()\n",
        "        self.compute_polynomial_second_derivative()\n",
        "        self.box_final_answer()\n",
        "\n",
        "    def add_cosine_graph(self):\n",
        "        cosine_label = OldTex(\"\\\\cos(x)\")\n",
        "        cosine_label.to_corner(UP+LEFT)\n",
        "        cosine_graph = self.get_graph(np.cos)\n",
        "        dot = Dot(color = WHITE)\n",
        "        dot.move_to(cosine_label)\n",
        "        for mob in cosine_label, cosine_graph:\n",
        "            mob.set_color(self.colors[0])\n",
        "\n",
        "        def update_dot(dot):\n",
        "            dot.move_to(cosine_graph.get_points()[-1])\n",
        "            return dot\n",
        "\n",
        "        self.play(Write(cosine_label, run_time = 1))\n",
        "        self.play(dot.move_to, cosine_graph.get_points()[0])\n",
        "        self.play(\n",
        "            ShowCreation(cosine_graph),\n",
        "            UpdateFromFunc(dot, update_dot),\n",
        "            run_time = 4\n",
        "        )\n",
        "        self.play(FadeOut(dot))\n",
        "\n",
        "        self.cosine_label = cosine_label\n",
        "        self.cosine_graph = cosine_graph\n",
        "\n",
        "    def add_quadratic_graph(self):\n",
        "        quadratic_graph = self.get_quadratic_graph()\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.cosine_graph.copy(),\n",
        "            quadratic_graph,\n",
        "            run_time = 3\n",
        "        ))\n",
        "\n",
        "        self.quadratic_graph = quadratic_graph\n",
        "\n",
        "    def introduce_quadratic_constants(self):\n",
        "        quadratic_tex = self.get_quadratic_tex(\"c_0\", \"c_1\", \"c_2\")\n",
        "        const_terms = quadratic_tex.get_parts_by_tex(\"c\")\n",
        "        free_to_change = OldTexText(\"Free to change\")\n",
        "        free_to_change.next_to(const_terms, DOWN, LARGE_BUFF)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                free_to_change.get_top(),\n",
        "                const.get_bottom(),\n",
        "                tip_length = 0.75*Arrow.CONFIG[\"tip_length\"],\n",
        "                color = const.get_color()\n",
        "            )\n",
        "            for const in const_terms\n",
        "        ])\n",
        "        alt_consts_list = [\n",
        "            (0, -1, -0.25),\n",
        "            (1, -1, -0.25),\n",
        "            (1, 0, -0.25),\n",
        "            (),\n",
        "        ]\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            quadratic_tex, \n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(free_to_change),\n",
        "            *list(map(ShowCreation, arrows))\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                const.scale, 0.8,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(there_and_back, a, a + 0.75)\n",
        "            )\n",
        "            for const, a in zip(const_terms, np.linspace(0, 0.25, len(const_terms)))\n",
        "        ])\n",
        "        for alt_consts in alt_consts_list:\n",
        "            self.change_quadratic_graph(\n",
        "                self.quadratic_graph, *alt_consts\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.quadratic_tex = quadratic_tex\n",
        "        self.free_to_change_group = VGroup(free_to_change, *arrows)\n",
        "        self.free_to_change_group.arrows = arrows\n",
        "\n",
        "    def show_value_at_zero(self):\n",
        "        arrow, x_equals_0 = ax0_group = self.get_arrow_x_equals_0_group()\n",
        "        ax0_group.next_to(\n",
        "            self.cosine_label, RIGHT,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        one = OldTex(\"1\")\n",
        "        one.next_to(arrow, RIGHT)\n",
        "        one.save_state()\n",
        "        one.move_to(self.cosine_label)\n",
        "        one.set_fill(opacity = 0)\n",
        "\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            0, self.cosine_graph,\n",
        "            line_class = DashedLine, \n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(x_equals_0, run_time = 2)\n",
        "        )\n",
        "        self.play(one.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.v_line = v_line\n",
        "        self.equals_one_group = VGroup(arrow, x_equals_0, one)\n",
        "\n",
        "    def set_c0_to_one(self):\n",
        "        poly_at_zero = self.get_quadratic_tex(\n",
        "            \"c_0\", \"c_1\", \"c_2\", arg = \"0\"\n",
        "        )\n",
        "        poly_at_zero.next_to(self.quadratic_tex, DOWN)\n",
        "        equals_c0 = OldTex(\"=\", \"c_0\", \"+0\")\n",
        "        equals_c0.set_color_by_tex(\"c_0\", self.colors[0])\n",
        "        equals_c0.next_to(\n",
        "            poly_at_zero.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        poly_group = VGroup(\n",
        "            equals_c0,\n",
        "            poly_at_zero,\n",
        "            self.quadratic_tex,\n",
        "        )\n",
        "        poly_group_target = VGroup(\n",
        "            OldTex(\"=\", \"1\", \"+0\").set_color_by_tex(\"1\", self.colors[0]),\n",
        "            self.get_quadratic_tex(\"1\", \"c_1\", \"c_2\", arg = \"0\"),\n",
        "            self.get_quadratic_tex(\"1\", \"c_1\", \"c_2\"),\n",
        "        )\n",
        "        for start, target in zip(poly_group, poly_group_target):\n",
        "            target.move_to(start)\n",
        "\n",
        "        self.play(FadeOut(self.free_to_change_group))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.quadratic_tex.copy(),\n",
        "            poly_at_zero\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(equals_c0))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            poly_group, poly_group_target,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [poly_at_zero, equals_c0])))\n",
        "\n",
        "        self.free_to_change_group.remove(\n",
        "            self.free_to_change_group.arrows[0]\n",
        "        )\n",
        "        self.play(FadeIn(self.free_to_change_group))\n",
        "\n",
        "    def let_c1_and_c2_vary(self):\n",
        "        alt_consts_list = [\n",
        "            (1, 1, -0.25),\n",
        "            (1, -1, -0.25),\n",
        "            (1, -1, 0.25),\n",
        "            (1, 1, -0.1),\n",
        "        ]\n",
        "\n",
        "        for alt_consts in alt_consts_list:\n",
        "            self.change_quadratic_graph(\n",
        "                self.quadratic_graph,\n",
        "                *alt_consts\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_tangent_slope(self):\n",
        "        graph_point_at_zero = self.input_to_graph_point(\n",
        "            0, self.cosine_graph\n",
        "        ) \n",
        "        tangent_line = self.get_tangent_line(0, self.cosine_graph)\n",
        "\n",
        "        self.play(ShowCreation(tangent_line))\n",
        "        self.change_quadratic_graph(\n",
        "            self.quadratic_graph, 1, 0, -0.1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_quadratic_graph(\n",
        "            self.quadratic_graph, 1, 1, -0.1\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.change_quadratic_graph(\n",
        "            self.quadratic_graph, 1, 0, -0.1\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.tangent_line = tangent_line\n",
        "\n",
        "    def compute_cosine_derivative(self):\n",
        "        derivative, rhs = self.get_cosine_derivative()\n",
        "\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            VGroup(derivative, *rhs[:2]),\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(Write(VGroup(*rhs[2:])), run_time = 2)\n",
        "        self.wait()\n",
        "        self.play(Rotate(\n",
        "            self.tangent_line, np.pi/12,\n",
        "            in_place = True,\n",
        "            run_time = 3,\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def compute_polynomial_derivative(self):\n",
        "        derivative = self.get_quadratic_derivative(\"c_1\", \"c_2\")\n",
        "        derivative_at_zero = self.get_quadratic_derivative(\n",
        "            \"c_1\", \"c_2\", arg = \"0\"\n",
        "        )\n",
        "        equals_c1 = OldTex(\"=\", \"c_1\", \"+0\")\n",
        "        equals_c1.next_to(\n",
        "            derivative_at_zero.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        equals_c1.set_color_by_tex(\"c_1\", self.colors[1])\n",
        "        poly_group = VGroup(\n",
        "            equals_c1,\n",
        "            derivative,\n",
        "            self.quadratic_tex\n",
        "        )\n",
        "        poly_group_target = VGroup(\n",
        "            OldTex(\"=\", \"0\", \"+0\").set_color_by_tex(\n",
        "                \"0\", self.colors[1], substring = False\n",
        "            ),\n",
        "            self.get_quadratic_derivative(\"0\", \"c_2\", arg = \"0\"),\n",
        "            self.get_quadratic_tex(\"1\", \"0\", \"c_2\")\n",
        "        )\n",
        "        for start, target in zip(poly_group, poly_group_target):\n",
        "            target.move_to(start)\n",
        "\n",
        "        self.play(FadeOut(self.free_to_change_group))\n",
        "        self.play(FadeIn(\n",
        "            derivative, \n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            derivative, derivative_at_zero,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(Write(equals_c1))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            poly_group, poly_group_target,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(*list(map(FadeOut, poly_group[:-1])))\n",
        "        self.free_to_change_group.remove(\n",
        "            self.free_to_change_group.arrows[1]\n",
        "        )\n",
        "        self.play(FadeIn(self.free_to_change_group))\n",
        "\n",
        "    def let_c2_vary(self):\n",
        "        alt_c2_values = [-1, -0.05, 1, -0.2]\n",
        "        for alt_c2 in alt_c2_values:\n",
        "            self.change_quadratic_graph(\n",
        "                self.quadratic_graph,\n",
        "                1, 0, alt_c2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def point_out_negative_concavity(self):\n",
        "        partial_cosine_graph = self.get_graph(\n",
        "            np.cos,\n",
        "            x_min = -1, \n",
        "            x_max = 1,\n",
        "            color = PINK\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(partial_cosine_graph, run_time = 2))\n",
        "        self.wait()\n",
        "        for x, run_time in (-1, 2), (1, 4):\n",
        "            self.play(self.get_tangent_line_change_anim(\n",
        "                self.tangent_line, x, self.cosine_graph,\n",
        "                run_time = run_time\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            partial_cosine_graph, self.tangent_line\n",
        "        ])))\n",
        "\n",
        "    def compute_cosine_second_derivative(self):\n",
        "        second_deriv, rhs = self.get_cosine_second_derivative()\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            VGroup(second_deriv, *rhs[1][:2]),\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.play(Write(VGroup(*rhs[1][2:]), run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def show_matching_curvature(self):\n",
        "        alt_consts_list = [\n",
        "            (1, 1, -0.2),\n",
        "            (1, 0, -0.2),\n",
        "            (1, 0, -0.5),\n",
        "        ]\n",
        "        for alt_consts in alt_consts_list:\n",
        "            self.change_quadratic_graph(\n",
        "                self.quadratic_graph,\n",
        "                *alt_consts\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_matching_tangent_lines(self):\n",
        "        graphs = [self.quadratic_graph, self.cosine_graph]\n",
        "        tangent_lines = [\n",
        "            self.get_tangent_line(0, graph, color = color)\n",
        "            for graph, color in zip(graphs, [WHITE, YELLOW])\n",
        "        ]\n",
        "        tangent_change_anims = [\n",
        "            self.get_tangent_line_change_anim(\n",
        "                line, np.pi/2, graph, \n",
        "                run_time = 6,\n",
        "                rate_func = there_and_back,\n",
        "            )\n",
        "            for line, graph in zip(tangent_lines, graphs)\n",
        "        ]\n",
        "\n",
        "        self.play(*list(map(ShowCreation, tangent_lines)))\n",
        "        self.play(*tangent_change_anims)\n",
        "        self.play(*list(map(FadeOut, tangent_lines)))\n",
        "\n",
        "    def compute_polynomial_second_derivative(self):\n",
        "        c2s = [\"c_2\", \"\\\\text{\\\\tiny $\\\\left(-\\\\frac{1}{2}\\\\right)$}\"]\n",
        "        derivs = [\n",
        "            self.get_quadratic_derivative(\"0\", c2)\n",
        "            for c2 in c2s\n",
        "        ]\n",
        "        second_derivs = [\n",
        "            OldTex(\n",
        "                \"{d^2 P \\\\over dx^2}\", \"(x)\", \"=\", \"2\", c2\n",
        "            )\n",
        "            for c2 in c2s\n",
        "        ]\n",
        "        for deriv, second_deriv in zip(derivs, second_derivs):\n",
        "            second_deriv[0].scale(\n",
        "                0.7, about_point = second_deriv[0].get_right()\n",
        "            )\n",
        "            second_deriv[-1].set_color(self.colors[-1])\n",
        "            second_deriv.next_to(\n",
        "                deriv, DOWN, \n",
        "                buff = MED_LARGE_BUFF,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "\n",
        "        poly_group = VGroup(\n",
        "            second_derivs[0], \n",
        "            derivs[0],\n",
        "            self.quadratic_tex\n",
        "        )\n",
        "        poly_group_target = VGroup(\n",
        "            second_derivs[1],\n",
        "            derivs[1],\n",
        "            self.get_quadratic_tex(\"1\", \"0\", c2s[1])\n",
        "        )\n",
        "        for tex_mob in poly_group_target:\n",
        "            tex_mob.get_part_by_tex(c2s[1]).shift(SMALL_BUFF*UP)\n",
        "\n",
        "        self.play(FadeOut(self.free_to_change_group))\n",
        "        self.play(FadeIn(derivs[0]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(second_derivs[0]))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            poly_group, poly_group_target,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "    def box_final_answer(self):\n",
        "        box = Rectangle(stroke_color = PINK)\n",
        "        box.stretch_to_fit_width(\n",
        "            self.quadratic_tex.get_width() + MED_LARGE_BUFF\n",
        "        )\n",
        "        box.stretch_to_fit_height(\n",
        "            self.quadratic_tex.get_height() + MED_LARGE_BUFF\n",
        "        )\n",
        "        box.move_to(self.quadratic_tex)\n",
        "\n",
        "        self.play(ShowCreation(box, run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def change_quadratic_graph(self, graph, *args, **kwargs):\n",
        "        transformation_kwargs = {}\n",
        "        transformation_kwargs[\"run_time\"] = kwargs.pop(\"run_time\", 2)\n",
        "        transformation_kwargs[\"rate_func\"] = kwargs.pop(\"rate_func\", smooth)\n",
        "        new_graph = self.get_quadratic_graph(*args, **kwargs)\n",
        "        self.play(Transform(graph, new_graph, **transformation_kwargs))\n",
        "        graph.underlying_function = new_graph.underlying_function\n",
        "\n",
        "    def get_quadratic_graph(self, c0 = 1, c1 = 0, c2 = -0.5):\n",
        "        return self.get_graph(\n",
        "            lambda x : c0 + c1*x + c2*x**2,\n",
        "            color = self.colors[2]\n",
        "        )\n",
        "\n",
        "    def get_quadratic_tex(self, c0, c1, c2, arg = \"x\"):\n",
        "        tex_mob = OldTex(\n",
        "            \"P(\", arg, \")\", \"=\", \n",
        "            c0, \"+\", c1, arg, \"+\", c2, arg, \"^2\"\n",
        "        )\n",
        "        for tex, color in zip([c0, c1, c2], self.colors):\n",
        "            tex_mob.set_color_by_tex(tex, color)\n",
        "        tex_mob.to_corner(UP+RIGHT)\n",
        "        return tex_mob\n",
        "\n",
        "    def get_quadratic_derivative(self, c1, c2, arg = \"x\"):\n",
        "        result = OldTex(\n",
        "            \"{dP \\\\over dx}\", \"(\", arg, \")\", \"=\",\n",
        "            c1, \"+\", \"2\", c2, arg\n",
        "        )\n",
        "        result[0].scale(0.7, about_point = result[0].get_right())\n",
        "        for index, color in zip([5, 8], self.colors[1:]):\n",
        "            result[index].set_color(color)\n",
        "        if hasattr(self, \"quadratic_tex\"):\n",
        "            result.next_to(\n",
        "                self.quadratic_tex, DOWN,\n",
        "                buff = MED_LARGE_BUFF,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "        return result\n",
        "\n",
        "    def get_arrow_x_equals_0_group(self):\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        x_equals_0 = OldTex(\"x = 0\")\n",
        "        x_equals_0.scale(0.75)\n",
        "        x_equals_0.next_to(arrow.get_center(), UP, 2*SMALL_BUFF)\n",
        "        x_equals_0.shift(SMALL_BUFF*LEFT)\n",
        "        return VGroup(arrow, x_equals_0)\n",
        "\n",
        "    def get_tangent_line(self, x, graph, color = YELLOW):\n",
        "        tangent_line = Line(LEFT, RIGHT, color = color)\n",
        "        tangent_line.rotate(self.angle_of_tangent(x, graph))\n",
        "        tangent_line.scale(2)\n",
        "        tangent_line.move_to(self.input_to_graph_point(x, graph))\n",
        "        return tangent_line\n",
        "\n",
        "    def get_tangent_line_change_anim(self, tangent_line, new_x, graph, **kwargs):\n",
        "        start_x = self.x_axis.point_to_number(\n",
        "            tangent_line.get_center()\n",
        "        )\n",
        "        def update(tangent_line, alpha):\n",
        "            x = interpolate(start_x, new_x, alpha)\n",
        "            new_line = self.get_tangent_line(\n",
        "                x, graph, color = tangent_line.get_color()\n",
        "            )\n",
        "            Transform(tangent_line, new_line).update(1)\n",
        "            return tangent_line\n",
        "        return UpdateFromAlphaFunc(tangent_line, update, **kwargs)\n",
        "\n",
        "    def get_cosine_derivative(self):\n",
        "        if not hasattr(self, \"cosine_label\"):\n",
        "            self.cosine_label = OldTex(\"\\\\cos(x)\")\n",
        "            self.cosine_label.to_corner(UP+LEFT)\n",
        "        derivative = OldTex(\n",
        "            \"{d(\", \"\\\\cos\", \")\", \"\\\\over\", \"dx}\", \"(0)\",\n",
        "        )\n",
        "        derivative.set_color_by_tex(\"\\\\cos\", self.colors[0])\n",
        "        derivative.scale(0.7)\n",
        "        derivative.next_to(\n",
        "            self.cosine_label, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rhs = OldTex(\"=\", \"-\\\\sin(0)\", \"=\", \"0\")\n",
        "        rhs.set_color_by_tex(\"\\\\sin\", self.colors[1])\n",
        "        rhs.scale(0.75)\n",
        "        rhs.next_to(\n",
        "            derivative, RIGHT,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "\n",
        "        self.cosine_derivative = VGroup(derivative, rhs)\n",
        "        return self.cosine_derivative\n",
        "\n",
        "    def get_cosine_second_derivative(self):\n",
        "        if not hasattr(self, \"cosine_derivative\"):\n",
        "            self.get_cosine_derivative()\n",
        "        second_deriv = OldTex(\n",
        "            \"{d^2(\", \"\\\\cos\", \")\", \"\\\\over\", \"dx^2}\", \n",
        "            \"(\", \"0\", \")\",\n",
        "        )\n",
        "        second_deriv.set_color_by_tex(\"cos\", self.colors[0])\n",
        "        second_deriv.set_color_by_tex(\"-\\\\cos\", self.colors[2])\n",
        "        second_deriv.scale(0.75)\n",
        "        second_deriv.add_background_rectangle()\n",
        "        second_deriv.next_to(\n",
        "            self.cosine_derivative, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rhs = OldTex(\"=\", \"-\\\\cos(0)\", \"=\", \"-1\")\n",
        "        rhs.set_color_by_tex(\"cos\", self.colors[2])\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(\n",
        "            second_deriv, RIGHT, \n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        rhs.add_background_rectangle()\n",
        "\n",
        "        self.cosine_second_derivative = VGroup(second_deriv, rhs)\n",
        "        return self.cosine_second_derivative\n",
        "\n",
        "class ReflectOnQuadraticApproximation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.show_example_approximation()\n",
        "        # self.add_polynomial()\n",
        "        # self.show_c0()\n",
        "        # self.show_c1()\n",
        "        # self.show_c2()\n",
        "\n",
        "    def show_example_approximation(self):\n",
        "        approx_at_x, approx_at_point = [\n",
        "            OldTex(\n",
        "                \"\\\\cos(\", s, \")\", \"\\\\approx\",\n",
        "                \"1 - \\\\frac{1}{2}\", \"(\", s, \")\", \"^2\"\n",
        "            ).next_to(self.get_students(), UP, 2)\n",
        "            for s in (\"x\", \"0.1\",)\n",
        "        ]\n",
        "        approx_rhs = OldTex(\"=\", \"0.995\")\n",
        "        approx_rhs.next_to(approx_at_point, RIGHT)\n",
        "        real_result = OldTex(\n",
        "            \"\\\\cos(\", \"0.1\", \")\", \"=\", \n",
        "            \"%.7f\\\\dots\"%np.cos(0.1)\n",
        "        )\n",
        "        real_result.shift(\n",
        "            approx_rhs.get_part_by_tex(\"=\").get_center() -\\\n",
        "            real_result.get_part_by_tex(\"=\").get_center()\n",
        "        )\n",
        "        for mob in approx_at_point, real_result:\n",
        "            mob.set_color_by_tex(\"0.1\", YELLOW)\n",
        "        real_result.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            Write(approx_at_x, run_time = 2),\n",
        "            self.teacher.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            approx_at_x, approx_at_point,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(approx_rhs))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            real_result.shift, 1.5*DOWN,\n",
        "            real_result.set_fill, None, 1,\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            *[\"plain\"]*3,\n",
        "            added_anims = list(map(FadeOut, [\n",
        "                approx_at_point, approx_rhs, real_result\n",
        "            ])),\n",
        "            look_at = approx_at_x\n",
        "        )\n",
        "\n",
        "    def add_polynomial(self):\n",
        "        polynomial = self.get_polynomial()\n",
        "        const_terms = polynomial.get_parts_by_tex(\"c\")\n",
        "\n",
        "        self.play(\n",
        "            Write(polynomial),\n",
        "            self.teacher.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                const.shift, MED_LARGE_BUFF*UP,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(there_and_back, a, a+0.7)\n",
        "            )\n",
        "            for const, a in zip(const_terms, np.linspace(0, 0.3, len(const_terms)))\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.const_terms = const_terms\n",
        "        self.polynomial = polynomial\n",
        "\n",
        "    def show_c0(self):\n",
        "        c0 = self.polynomial.get_part_by_tex(\"c_0\")\n",
        "        c0.save_state()\n",
        "        equation = OldTex(\"P(0) = \\\\cos(0)\")\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        new_polynomial = self.get_polynomial(c0 = \"1\")\n",
        "\n",
        "        self.play(c0.shift, UP)\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "        self.play(Transform(self.polynomial, new_polynomial))\n",
        "        self.play(FadeOut(equation))\n",
        "\n",
        "    def show_c1(self):\n",
        "        c1 = self.polynomial.get_part_by_tex(\"c_1\")\n",
        "        c1.save_state()\n",
        "        equation = OldTex(\n",
        "            \"\\\\frac{dP}{dx}(0) = \\\\frac{d(\\\\cos)}{dx}(0)\"\n",
        "        )\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        new_polynomial = self.get_polynomial(c0 = \"1\", c1 = \"0\")\n",
        "\n",
        "        self.play(c1.shift, UP)\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "        self.play(Transform(self.polynomial, new_polynomial))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(equation))\n",
        "\n",
        "    def show_c2(self):\n",
        "        c2 = self.polynomial.get_part_by_tex(\"c_2\")\n",
        "        c2.save_state()\n",
        "        equation = OldTex(\n",
        "            \"\\\\frac{d^2 P}{dx^2}(0) = \\\\frac{d^2(\\\\cos)}{dx^2}(0)\"\n",
        "        )\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        alt_c2_tex = \"\\\\text{\\\\tiny $\\\\left(-\\\\frac{1}{2}\\\\right)$}\"\n",
        "        new_polynomial = self.get_polynomial(\n",
        "            c0 = \"1\", c1 = \"0\", c2 = alt_c2_tex\n",
        "        )\n",
        "        new_polynomial.get_part_by_tex(alt_c2_tex).shift(SMALL_BUFF*UP)\n",
        "\n",
        "        self.play(c2.shift, UP)\n",
        "        self.play(FadeIn(equation))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(self.polynomial, new_polynomial))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(equation))\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_polynomial(self, c0 = \"c_0\", c1 = \"c_1\", c2 = \"c_2\"):\n",
        "        polynomial = OldTex(\n",
        "            \"P(x) = \", c0, \"+\", c1, \"x\", \"+\", c2, \"x^2\"\n",
        "        )\n",
        "        colors = ConstructQuadraticApproximation.CONFIG[\"colors\"]\n",
        "        for tex, color in zip([c0, c1, c2], colors):\n",
        "            polynomial.set_color_by_tex(tex, color, substring = False)\n",
        "\n",
        "        polynomial.next_to(self.teacher, UP, LARGE_BUFF)\n",
        "        polynomial.to_edge(RIGHT)\n",
        "        return polynomial\n",
        "\n",
        "class ReflectionOnQuadraticSupplement(ConstructQuadraticApproximation):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add(self.get_graph(np.cos, color = self.colors[0]))\n",
        "        quadratic_graph = self.get_quadratic_graph()\n",
        "        self.add(quadratic_graph)\n",
        "\n",
        "        self.wait()\n",
        "        for c0 in 0, 2, 1:\n",
        "            self.change_quadratic_graph(\n",
        "                quadratic_graph,\n",
        "                c0 = c0\n",
        "            )\n",
        "        self.wait(2)\n",
        "        for c1 in 1, -1, 0:\n",
        "            self.change_quadratic_graph(\n",
        "                quadratic_graph,\n",
        "                c1 = c1\n",
        "            )\n",
        "        self.wait(2)\n",
        "        for c2 in -0.1, -1, -0.5:\n",
        "            self.change_quadratic_graph(\n",
        "                quadratic_graph,\n",
        "                c2 = c2\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "class SimilarityOfChangeBehavior(ConstructQuadraticApproximation):\n",
        "    def construct(self):\n",
        "        colors = [YELLOW, WHITE]\n",
        "        max_x = np.pi/2\n",
        "\n",
        "        self.setup_axes()        \n",
        "        cosine_graph = self.get_graph(np.cos, color = self.colors[0])\n",
        "        quadratic_graph = self.get_quadratic_graph()\n",
        "        graphs = VGroup(cosine_graph, quadratic_graph)\n",
        "        dots = VGroup()\n",
        "        for graph, color in zip(graphs, colors):\n",
        "            dot = Dot(color = color)\n",
        "            dot.move_to(self.input_to_graph_point(0, graph))\n",
        "            dot.graph = graph\n",
        "            dots.add(dot)\n",
        "\n",
        "        def update_dot(dot, alpha):\n",
        "            x = interpolate(0, max_x, alpha)\n",
        "            dot.move_to(self.input_to_graph_point(x, dot.graph))\n",
        "        dot_anims = [\n",
        "            UpdateFromAlphaFunc(dot, update_dot, run_time = 3)\n",
        "            for dot in dots\n",
        "        ]\n",
        "        tangent_lines = VGroup(*[\n",
        "            self.get_tangent_line(0, graph, color)\n",
        "            for graph, color in zip(graphs, colors)\n",
        "        ])\n",
        "        tangent_line_movements = [\n",
        "            self.get_tangent_line_change_anim(\n",
        "                line, max_x, graph,\n",
        "                run_time = 5,\n",
        "            )\n",
        "            for line, graph in zip(tangent_lines, graphs)\n",
        "        ]\n",
        "\n",
        "        self.add(cosine_graph, quadratic_graph)\n",
        "        self.play(FadeIn(dots))\n",
        "        self.play(*dot_anims)\n",
        "        self.play(\n",
        "            FadeIn(tangent_lines),\n",
        "            FadeOut(dots)\n",
        "        )\n",
        "        self.play(*tangent_line_movements + dot_anims, run_time = 6)\n",
        "        self.play(*list(map(FadeOut, [tangent_lines, dots])))\n",
        "        self.wait()\n",
        "\n",
        "class MoreTerms(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"More terms!\",\n",
        "            target_mode = \"surprised\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class CubicAndQuarticApproximations(ConstructQuadraticApproximation):\n",
        "    CONFIG = {\n",
        "        \"colors\": [BLUE, YELLOW, GREEN, RED, MAROON_B],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_background()\n",
        "        self.take_third_derivative_of_cubic()\n",
        "        self.show_third_derivative_of_cosine()\n",
        "        self.set_c3_to_zero()\n",
        "        self.show_cubic_curves()\n",
        "        self.add_quartic_term()\n",
        "        self.show_fourth_derivative_of_cosine()\n",
        "        self.take_fourth_derivative_of_quartic()\n",
        "        self.solve_for_c4()\n",
        "        self.show_quartic_approximation()\n",
        "\n",
        "\n",
        "    def add_background(self):\n",
        "        self.setup_axes()\n",
        "        self.cosine_graph = self.get_graph(\n",
        "            np.cos, color = self.colors[0]\n",
        "        )\n",
        "        self.quadratic_graph = self.get_quadratic_graph()\n",
        "        self.big_rect = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = FRAME_WIDTH,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        self.add(\n",
        "            self.cosine_graph, self.quadratic_graph,\n",
        "            self.big_rect\n",
        "        )\n",
        "\n",
        "        self.cosine_label = OldTex(\"\\\\cos\", \"(0)\", \"=1\")\n",
        "        self.cosine_label.set_color_by_tex(\"cos\", self.colors[0])\n",
        "        self.cosine_label.scale(0.75)\n",
        "        self.cosine_label.to_corner(UP+LEFT)\n",
        "        self.add(self.cosine_label)\n",
        "        self.add(self.get_cosine_derivative())\n",
        "        self.add(self.get_cosine_second_derivative())\n",
        "\n",
        "        self.polynomial = OldTex(\n",
        "            \"P(x)=\", \"1\", \"-\\\\frac{1}{2}\", \"x^2\"\n",
        "        )\n",
        "        self.polynomial.set_color_by_tex(\"1\", self.colors[0])\n",
        "        self.polynomial.set_color_by_tex(\"-\\\\frac{1}{2}\", self.colors[2])\n",
        "        self.polynomial.to_corner(UP+RIGHT)\n",
        "        self.polynomial.quadratic_part = VGroup(\n",
        "            *self.polynomial[1:]\n",
        "        )\n",
        "        self.add(self.polynomial)\n",
        "\n",
        "    def take_third_derivative_of_cubic(self):\n",
        "        polynomial = self.polynomial\n",
        "        plus_cubic_term = OldTex(\"+\\\\,\", \"c_3\", \"x^3\")\n",
        "        plus_cubic_term.next_to(polynomial, RIGHT)\n",
        "        plus_cubic_term.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        plus_cubic_term.set_color_by_tex(\"c_3\", self.colors[3])\n",
        "        plus_cubic_copy = plus_cubic_term.copy()\n",
        "\n",
        "        polynomial.generate_target()\n",
        "        polynomial.target.next_to(plus_cubic_term, LEFT)\n",
        "\n",
        "        self.play(FocusOn(polynomial))\n",
        "        self.play(\n",
        "            MoveToTarget(polynomial),\n",
        "            GrowFromCenter(plus_cubic_term)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        brace = Brace(polynomial.quadratic_part, DOWN)\n",
        "        third_derivative = OldTex(\n",
        "            \"\\\\frac{d^3 P}{dx^3}(x) = \", \"0\"\n",
        "        )\n",
        "        third_derivative.shift(\n",
        "            brace.get_bottom() + MED_SMALL_BUFF*DOWN -\\\n",
        "            third_derivative.get_part_by_tex(\"0\").get_top()\n",
        "        )        \n",
        "\n",
        "        self.play(Write(third_derivative[0]))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(ReplacementTransform(\n",
        "            polynomial.quadratic_part.copy(),\n",
        "            VGroup(third_derivative[1])\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(plus_cubic_copy.next_to, third_derivative, RIGHT)\n",
        "        derivative_term = self.take_derivatives_of_monomial(\n",
        "            VGroup(*plus_cubic_copy[1:])\n",
        "        )\n",
        "        third_derivative.add(plus_cubic_copy[0], derivative_term)\n",
        "\n",
        "        self.plus_cubic_term = plus_cubic_term\n",
        "        self.polynomial_third_derivative = third_derivative\n",
        "        self.polynomial_third_derivative_brace = brace\n",
        "\n",
        "    def show_third_derivative_of_cosine(self):\n",
        "        cosine_third_derivative = self.get_cosine_third_derivative()\n",
        "        dot = Dot(fill_opacity = 0.5)\n",
        "        dot.move_to(self.polynomial_third_derivative)\n",
        "\n",
        "        self.play(\n",
        "            dot.move_to, cosine_third_derivative,\n",
        "            dot.set_fill, None, 0\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            self.cosine_second_derivative.copy(),\n",
        "            cosine_third_derivative\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        dot.set_fill(opacity = 0.5)\n",
        "        self.play(\n",
        "            dot.move_to, self.polynomial_third_derivative.get_right(),\n",
        "            dot.set_fill, None, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def set_c3_to_zero(self):\n",
        "        c3s = VGroup(\n",
        "            self.polynomial_third_derivative[-1][-1],\n",
        "            self.plus_cubic_term.get_part_by_tex(\"c_3\")\n",
        "        )\n",
        "        zeros = VGroup(*[\n",
        "            OldTex(\"0\").move_to(c3)\n",
        "            for c3 in c3s\n",
        "        ])\n",
        "        zeros.set_color(self.colors[3])\n",
        "        zeros.shift(SMALL_BUFF*UP)\n",
        "        zeros[0].shift(0.25*SMALL_BUFF*(UP+LEFT))\n",
        "\n",
        "        self.play(Transform(\n",
        "            c3s, zeros, \n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_cubic_curves(self):\n",
        "        real_graph = self.quadratic_graph\n",
        "        real_graph.save_state()\n",
        "        graph = real_graph.copy()\n",
        "        graph.save_state()\n",
        "        alt_graphs = [\n",
        "            self.get_graph(func, color = real_graph.get_color())\n",
        "            for func in [\n",
        "                lambda x : x*(x-1)*(x+1),\n",
        "                lambda x : 1 - 0.5*(x**2) + 0.2*(x**3)\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        self.play(FadeIn(graph))\n",
        "        real_graph.set_stroke(width = 0)\n",
        "        for alt_graph in alt_graphs:\n",
        "            self.play(Transform(graph, alt_graph, run_time = 2))\n",
        "            self.wait()\n",
        "        self.play(graph.restore, run_time = 2)\n",
        "        real_graph.restore()\n",
        "        self.play(FadeOut(graph))\n",
        "\n",
        "    def add_quartic_term(self):\n",
        "        polynomial = self.polynomial\n",
        "        plus_quartic_term = OldTex(\"+\\\\,\", \"c_4\", \"x^4\")\n",
        "        plus_quartic_term.next_to(polynomial, RIGHT)\n",
        "        plus_quartic_term.set_color_by_tex(\"c_4\", self.colors[4])\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.plus_cubic_term,\n",
        "            self.polynomial_third_derivative,\n",
        "            self.polynomial_third_derivative_brace,\n",
        "        ])))\n",
        "        self.play(Write(plus_quartic_term))\n",
        "        self.wait()\n",
        "\n",
        "        self.plus_quartic_term = plus_quartic_term\n",
        "\n",
        "    def show_fourth_derivative_of_cosine(self):\n",
        "        cosine_fourth_derivative = self.get_cosine_fourth_derivative()\n",
        "\n",
        "        self.play(FocusOn(self.cosine_third_derivative))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.cosine_third_derivative.copy(),\n",
        "            cosine_fourth_derivative\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "    def take_fourth_derivative_of_quartic(self):\n",
        "        quartic_term = VGroup(*self.plus_quartic_term.copy()[1:])\n",
        "        fourth_deriv_lhs = OldTex(\"{d^4 P \\\\over dx^4}(x)\", \"=\")\n",
        "        fourth_deriv_lhs.next_to(\n",
        "            self.polynomial, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        alt_rhs = OldTex(\"=\", \"24 \\\\cdot\", \"c_4\")\n",
        "        alt_rhs.next_to(\n",
        "            fourth_deriv_lhs.get_part_by_tex(\"=\"), DOWN,\n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        alt_rhs.set_color_by_tex(\"c_4\", self.colors[4])\n",
        "\n",
        "        self.play(Write(fourth_deriv_lhs))\n",
        "        self.play(\n",
        "            quartic_term.next_to, fourth_deriv_lhs, RIGHT\n",
        "        )\n",
        "        self.wait()\n",
        "        fourth_deriv_rhs = self.take_derivatives_of_monomial(quartic_term)\n",
        "        self.wait()\n",
        "        self.play(Write(alt_rhs))\n",
        "        self.wait()\n",
        "\n",
        "        self.fourth_deriv_lhs = fourth_deriv_lhs\n",
        "        self.fourth_deriv_rhs = fourth_deriv_rhs\n",
        "        self.fourth_deriv_alt_rhs = alt_rhs\n",
        "\n",
        "    def solve_for_c4(self):\n",
        "        c4s = VGroup(\n",
        "            self.fourth_deriv_alt_rhs.get_part_by_tex(\"c_4\"),\n",
        "            self.fourth_deriv_rhs[-1],\n",
        "            self.plus_quartic_term.get_part_by_tex(\"c_4\")\n",
        "        )\n",
        "        fraction = OldTex(\"\\\\text{\\\\small $\\\\frac{1}{24}$}\")\n",
        "        fraction.set_color(self.colors[4])\n",
        "        fractions = VGroup(*[\n",
        "            fraction.copy().move_to(c4, LEFT)\n",
        "            for c4 in c4s\n",
        "        ])\n",
        "        fractions.shift(SMALL_BUFF*UP)\n",
        "        x_to_4 = self.plus_quartic_term.get_part_by_tex(\"x^4\")\n",
        "        x_to_4.generate_target()\n",
        "        x_to_4.target.shift(MED_SMALL_BUFF*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                c4s, fractions,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            MoveToTarget(x_to_4, run_time = 2)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_quartic_approximation(self):\n",
        "        real_graph = self.quadratic_graph\n",
        "        graph = real_graph.copy()\n",
        "        quartic_graph = self.get_graph(\n",
        "            lambda x : 1 - (x**2)/2.0 + (x**4)/24.0,\n",
        "            color = graph.get_color(),\n",
        "        )\n",
        "        tex_mobs = VGroup(*[\n",
        "            self.polynomial,\n",
        "            self.fourth_deriv_rhs,\n",
        "            self.fourth_deriv_alt_rhs,\n",
        "            self.cosine_label,\n",
        "            self.cosine_derivative,\n",
        "            self.cosine_second_derivative,\n",
        "            self.cosine_third_derivative[1],\n",
        "        ])\n",
        "        for tex_mob in tex_mobs:\n",
        "            tex_mob.add_to_back(BackgroundRectangle(tex_mob))\n",
        "\n",
        "\n",
        "        self.play(FadeIn(graph))\n",
        "        real_graph.set_stroke(width = 0)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                graph, quartic_graph,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            Animation(tex_mobs)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def take_derivatives_of_monomial(self, term, *added_anims):\n",
        "        \"\"\"\n",
        "        Must be a group of pure Texs,\n",
        "        last part must be of the form x^n\n",
        "        \"\"\"\n",
        "        n = int(term[-1].get_tex()[-1])\n",
        "        curr_term = term\n",
        "        added_anims_iter = iter(added_anims)\n",
        "        for k in range(n, 0, -1):\n",
        "            exponent = curr_term[-1][-1]\n",
        "            exponent_copy = exponent.copy()\n",
        "            front_num = OldTex(\"%d \\\\cdot\"%k)\n",
        "            front_num.move_to(curr_term[0][0], LEFT)\n",
        "\n",
        "            new_monomial = OldTex(\"x^%d\"%(k-1))\n",
        "            new_monomial.replace(curr_term[-1])\n",
        "            Transform(curr_term[-1], new_monomial).update(1)\n",
        "            curr_term.generate_target()\n",
        "            curr_term.target.shift(\n",
        "                (front_num.get_width()+SMALL_BUFF)*RIGHT\n",
        "            )\n",
        "            curr_term[-1][-1].set_fill(opacity = 0)\n",
        "\n",
        "            possibly_added_anims = []\n",
        "            try:\n",
        "                possibly_added_anims.append(next(added_anims_iter))\n",
        "            except:\n",
        "                pass\n",
        "\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    exponent_copy.replace, front_num[0],\n",
        "                    path_arc = np.pi,\n",
        "                ),\n",
        "                Write(\n",
        "                    front_num[1], \n",
        "                    rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "                ),\n",
        "                MoveToTarget(curr_term),\n",
        "                *possibly_added_anims,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.remove(exponent_copy)\n",
        "            self.add(front_num)\n",
        "            curr_term = VGroup(front_num, *curr_term)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(curr_term[-1]))\n",
        "\n",
        "        return VGroup(*curr_term[:-1])\n",
        "\n",
        "    def get_cosine_third_derivative(self):\n",
        "        if not hasattr(self, \"cosine_second_derivative\"):\n",
        "            self.get_cosine_second_derivative()\n",
        "        third_deriv = OldTex(\n",
        "            \"{d^3(\", \"\\\\cos\", \")\", \"\\\\over\", \"dx^3}\", \n",
        "            \"(\", \"0\", \")\",\n",
        "        )\n",
        "        third_deriv.set_color_by_tex(\"cos\", self.colors[0])\n",
        "        third_deriv.set_color_by_tex(\"-\\\\cos\", self.colors[3])\n",
        "        third_deriv.scale(0.75)\n",
        "        third_deriv.add_background_rectangle()\n",
        "        third_deriv.next_to(\n",
        "            self.cosine_second_derivative, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rhs = OldTex(\"=\", \"\\\\sin(0)\", \"=\", \"0\")\n",
        "        rhs.set_color_by_tex(\"sin\", self.colors[3])\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(\n",
        "            third_deriv, RIGHT, \n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        rhs.add_background_rectangle()\n",
        "        rhs.background_rectangle.scale(1.2)\n",
        "\n",
        "        self.cosine_third_derivative = VGroup(third_deriv, rhs)\n",
        "        return self.cosine_third_derivative\n",
        "\n",
        "    def get_cosine_fourth_derivative(self):\n",
        "        if not hasattr(self, \"cosine_third_derivative\"):\n",
        "            self.get_cosine_third_derivative()\n",
        "        fourth_deriv = OldTex(\n",
        "            \"{d^4(\", \"\\\\cos\", \")\", \"\\\\over\", \"dx^4}\", \n",
        "            \"(\", \"0\", \")\",\n",
        "        )\n",
        "        fourth_deriv.set_color_by_tex(\"cos\", self.colors[0])\n",
        "        fourth_deriv.scale(0.75)\n",
        "        fourth_deriv.add_background_rectangle()\n",
        "        fourth_deriv.next_to(\n",
        "            self.cosine_third_derivative, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rhs = OldTex(\"=\", \"\\\\cos(0)\", \"=\", \"1\")\n",
        "        rhs.set_color_by_tex(\"cos\", self.colors[4])\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(\n",
        "            fourth_deriv, RIGHT, \n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        rhs.add_background_rectangle()\n",
        "        rhs.background_rectangle.scale(1.2)\n",
        "\n",
        "        self.cosine_fourth_derivative = VGroup(fourth_deriv, rhs)\n",
        "        return self.cosine_fourth_derivative\n",
        "\n",
        "class NoticeAFewThings(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Notice a few things\",\n",
        "            target_mode = \"hesitant\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class FactorialTerms(CubicAndQuarticApproximations):\n",
        "    def construct(self):\n",
        "        lhs_list = [\n",
        "            OldTex(\n",
        "                \"{d%s\"%s, \"\\\\over\", \"dx%s}\"%s, \"(\", \"c_8\", \"x^8\", \")=\"\n",
        "            )\n",
        "            for i in range(9)\n",
        "            for s in [\"^%d\"%i if i > 1 else \"\"]\n",
        "        ]\n",
        "        for lhs in lhs_list:\n",
        "            lhs.set_color_by_tex(\"c_8\", YELLOW)\n",
        "            lhs.next_to(ORIGIN, LEFT)\n",
        "        lhs_list[0].set_fill(opacity = 0)\n",
        "        added_anims = [\n",
        "            ReplacementTransform(\n",
        "                start_lhs, target_lhs,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "            )\n",
        "            for start_lhs, target_lhs in zip(lhs_list, lhs_list[1:])\n",
        "        ]\n",
        "\n",
        "        term = OldTex(\"c_8\", \"x^8\")\n",
        "        term.next_to(lhs[-1], RIGHT)\n",
        "        term.set_color_by_tex(\"c_8\", YELLOW)\n",
        "\n",
        "        self.add(term)\n",
        "        self.wait()\n",
        "        result = self.take_derivatives_of_monomial(term, *added_anims)\n",
        "\n",
        "        factorial_term = VGroup(*result[:-1])\n",
        "        brace = Brace(factorial_term)\n",
        "        eight_factorial = brace.get_text(\"$8!$\")\n",
        "\n",
        "        coefficient = result[-1]\n",
        "        words = OldTexText(\n",
        "            \"Set\", \"$c_8$\", \n",
        "            \"$ = \\\\frac{\\\\text{Desired derivative value}}{8!}\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"c_8\", YELLOW)\n",
        "        words.shift(2*UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(eight_factorial)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                coefficient.copy(),\n",
        "                words.get_part_by_tex(\"c_8\")\n",
        "            ),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class HigherTermsDontMessUpLowerTerms(Scene):\n",
        "    CONFIG = {\n",
        "        \"colors\" : CubicAndQuarticApproximations.CONFIG[\"colors\"][::2],\n",
        "\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_polynomial()\n",
        "        self.show_second_derivative()\n",
        "\n",
        "    def add_polynomial(self):\n",
        "        c0_tex = \"1\"\n",
        "        c2_tex = \"\\\\text{\\\\small $\\\\left(-\\\\frac{1}{2}\\\\right)$}\"\n",
        "        c4_tex = \"c_4\"\n",
        "\n",
        "        polynomial = OldTex(\n",
        "            \"P(x) = \", \n",
        "            c0_tex, \"+\", \n",
        "            c2_tex, \"x^2\", \"+\",\n",
        "            c4_tex, \"x^4\",\n",
        "        )\n",
        "        polynomial.shift(2*LEFT + UP)\n",
        "        c0, c2, c4 = [\n",
        "            polynomial.get_part_by_tex(tex)\n",
        "            for tex in (c0_tex, c2_tex, c4_tex)\n",
        "        ]\n",
        "        for term, color in zip([c0, c2, c4], self.colors):\n",
        "            term.set_color(color)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                c4.get_top(), c.get_top(), \n",
        "                path_arc = arc,\n",
        "                color = c.get_color()\n",
        "            )\n",
        "            for c, arc in [(c2, 0.9*np.pi), (c0, np.pi)]\n",
        "        ])\n",
        "        no_affect_words = OldTexText(\n",
        "            \"Doesn't affect \\\\\\\\ previous terms\"\n",
        "        )\n",
        "        no_affect_words.next_to(arrows, RIGHT)\n",
        "        no_affect_words.shift(MED_SMALL_BUFF*(UP+LEFT))\n",
        "\n",
        "        self.add(*polynomial[:-2])\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(*polynomial[-2:])))\n",
        "        self.play(\n",
        "            Write(no_affect_words),\n",
        "            ShowCreation(arrows),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.polynomial = polynomial\n",
        "        self.c0_tex = c0_tex\n",
        "        self.c2_tex = c2_tex\n",
        "        self.c4_tex = c4_tex\n",
        "\n",
        "    def show_second_derivative(self):\n",
        "        second_deriv = OldTex(\n",
        "            \"{d^2 P \\\\over dx^2}(\", \"0\", \")\", \"=\",\n",
        "            \"2\", self.c2_tex, \"+\", \n",
        "            \"3 \\\\cdot 4\", self.c4_tex, \"(\", \"0\", \")\", \"^2\"\n",
        "        )\n",
        "        second_deriv.set_color_by_tex(self.c2_tex, self.colors[1])\n",
        "        second_deriv.set_color_by_tex(self.c4_tex, self.colors[2])\n",
        "        second_deriv.set_color_by_tex(\"0\", YELLOW)\n",
        "        second_deriv.next_to(\n",
        "            self.polynomial, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        higher_terms = VGroup(*second_deriv[-6:])\n",
        "        brace = Brace(higher_terms, DOWN)\n",
        "        equals_zero = brace.get_text(\"=0\")\n",
        "\n",
        "        second_deriv.save_state()\n",
        "        second_deriv.move_to(self.polynomial, LEFT)\n",
        "        second_deriv.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(second_deriv.restore)\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        self.play(Write(equals_zero))\n",
        "        self.wait(3)\n",
        "\n",
        "class EachTermControlsOneDerivative(Scene):\n",
        "    def construct(self):\n",
        "        colors = CubicAndQuarticApproximations.CONFIG[\"colors\"]\n",
        "        polynomial = OldTex(\n",
        "            \"P(x) = \", \"c_0\", \"+\", \"c_1\", \"x\", *it.chain(*[\n",
        "                [\"+\", \"c_%d\"%n, \"x^%d\"%n]\n",
        "                for n in range(2, 5)\n",
        "            ])\n",
        "        )\n",
        "        consts = polynomial.get_parts_by_tex(\"c\")\n",
        "        deriv_words = VGroup(*[\n",
        "            OldTexText(\"Controls \\\\\\\\ $%s(0)$\"%tex)\n",
        "            for tex in [\n",
        "                \"P\",\n",
        "                \"\\\\frac{dP}{dx}\",\n",
        "            ] + [\n",
        "                \"\\\\frac{d^%d P}{dx^%d}\"%(n, n)\n",
        "                for n in range(2, 5)\n",
        "            ]\n",
        "        ])\n",
        "        deriv_words.arrange(\n",
        "            RIGHT, \n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = UP\n",
        "        )\n",
        "        deriv_words.set_width(FRAME_WIDTH - MED_LARGE_BUFF)\n",
        "        deriv_words.to_edge(UP)\n",
        "\n",
        "        for const, deriv, color in zip(consts, deriv_words, colors):\n",
        "            for mob in const, deriv:\n",
        "                mob.set_color(color)\n",
        "            arrow = Arrow(\n",
        "                const.get_top(),\n",
        "                deriv.get_bottom(),\n",
        "                # buff = SMALL_BUFF,\n",
        "                color = color\n",
        "            )\n",
        "            deriv.arrow = arrow\n",
        "\n",
        "        self.add(polynomial)\n",
        "        for deriv in deriv_words:\n",
        "            self.play(\n",
        "                ShowCreation(deriv.arrow),\n",
        "                FadeIn(deriv)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class ApproximateNearNewPoint(CubicAndQuarticApproximations):\n",
        "    CONFIG = {\n",
        "        \"target_approx_centers\" : [np.pi/2, np.pi],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_cosine_graph()\n",
        "        self.shift_approximation_center()\n",
        "        self.show_polynomials()\n",
        "\n",
        "    def add_cosine_graph(self):\n",
        "        self.cosine_graph = self.get_graph(\n",
        "            np.cos, self.colors[0]\n",
        "        )\n",
        "        self.add(self.cosine_graph)\n",
        "\n",
        "    def shift_approximation_center(self):\n",
        "        quartic_graph = self.get_quartic_approximation(0)\n",
        "        dot = Dot(color = YELLOW)\n",
        "        dot.move_to(self.coords_to_point(0, 1))\n",
        "\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.target_approx_centers[-1], self.cosine_graph,\n",
        "            line_class = DashedLine,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        pi = self.x_axis_labels[1]\n",
        "        pi.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.cosine_graph.copy(),\n",
        "                quartic_graph,\n",
        "            ),\n",
        "            DrawBorderThenFill(dot, run_time = 1)\n",
        "        )\n",
        "        for target, rt in zip(self.target_approx_centers, [3, 4, 4]):\n",
        "            self.change_approximation_center(\n",
        "                quartic_graph, dot, target, run_time = rt\n",
        "            )\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            Animation(pi)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def change_approximation_center(self, graph, dot, target, **kwargs):\n",
        "        start = self.x_axis.point_to_number(dot.get_center())\n",
        "        def update_quartic(graph, alpha):\n",
        "            new_a = interpolate(start, target, alpha)\n",
        "            new_graph = self.get_quartic_approximation(new_a)\n",
        "            Transform(graph, new_graph).update(1)\n",
        "            return graph\n",
        "\n",
        "        def update_dot(dot, alpha):\n",
        "            new_x = interpolate(start, target, alpha)\n",
        "            dot.move_to(self.input_to_graph_point(new_x, self.cosine_graph))\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(graph, update_quartic),\n",
        "            UpdateFromAlphaFunc(dot, update_dot),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def show_polynomials(self):\n",
        "        poly_around_pi = self.get_polynomial(\"(x-\\\\pi)\", \"\\\\pi\")\n",
        "        poly_around_pi.to_corner(UP+LEFT)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            poly_around_pi,\n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", poly_around_pi)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(randy.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_polynomial(self, arg, center_tex):\n",
        "        result = OldTex(\n",
        "            \"P_{%s}(x)\"%center_tex, \"=\", \"c_0\", *it.chain(*[\n",
        "                [\"+\", \"c_%d\"%d, \"%s^%d\"%(arg, d)]\n",
        "                for d in range(1, 5)\n",
        "            ])\n",
        "        )\n",
        "        for d, color in enumerate(self.colors):\n",
        "            result.set_color_by_tex(\"c_%d\"%d, color)\n",
        "        result.scale(0.85)\n",
        "        result.add_background_rectangle()\n",
        "        return result\n",
        "\n",
        "    def get_quartic_approximation(self, a):\n",
        "        coefficients = [\n",
        "            derivative(np.cos, a, n)\n",
        "            for n in range(5)\n",
        "        ]\n",
        "        func = lambda x : sum([\n",
        "            (c/math.factorial(n))*(x - a)**n\n",
        "            for n, c in enumerate(coefficients)\n",
        "        ])\n",
        "        return self.get_graph(func, color = GREEN)\n",
        "\n",
        "class OnAPhilosophicalLevel(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"And on a \\\\\\\\ philosophical level\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class TranslationOfInformation(CubicAndQuarticApproximations):\n",
        "    def construct(self):\n",
        "        self.add_background()\n",
        "        self.mention_information_exchange()\n",
        "        self.show_derivative_pattern()\n",
        "        self.show_polynomial()\n",
        "        self.name_taylor_polynomial()\n",
        "        self.draw_new_function_graph()\n",
        "        self.write_general_function_derivative()\n",
        "        self.replace_coefficients_in_generality()\n",
        "        self.walk_through_terms()\n",
        "        self.show_polynomial_around_a()\n",
        "\n",
        "    def add_background(self):\n",
        "        self.setup_axes()\n",
        "        self.cosine_graph = self.get_graph(\n",
        "            np.cos, color = self.colors[0]\n",
        "        )\n",
        "        self.add(self.cosine_graph)\n",
        "\n",
        "    def mention_information_exchange(self):\n",
        "        deriv_info = OldTexText(\n",
        "            \"Derivative \\\\\\\\ information \\\\\\\\ at a point\"\n",
        "        )\n",
        "        deriv_info.next_to(ORIGIN, LEFT, LARGE_BUFF)\n",
        "        deriv_info.to_edge(UP)\n",
        "        output_info = OldTexText(\n",
        "            \"Output \\\\\\\\ information \\\\\\\\ near that point\"\n",
        "        )\n",
        "        output_info.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        output_info.to_edge(UP)\n",
        "        arrow = Arrow(deriv_info, output_info)\n",
        "\n",
        "        center_v_line = self.get_vertical_line_to_graph(\n",
        "            0, self.cosine_graph,\n",
        "            line_class = DashedLine,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        outer_v_lines = VGroup(*[\n",
        "            center_v_line.copy().shift(vect)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        outer_v_lines.set_color(GREEN)\n",
        "        dot = Dot(color = YELLOW)\n",
        "        dot.move_to(center_v_line.get_top())\n",
        "        dot.save_state()\n",
        "        dot.move_to(deriv_info)\n",
        "        dot.set_fill(opacity = 0)\n",
        "\n",
        "        quadratic_graph = self.get_quadratic_graph()\n",
        "\n",
        "\n",
        "        self.play(Write(deriv_info, run_time = 2))\n",
        "        self.play(dot.restore)\n",
        "        self.play(ShowCreation(center_v_line))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(output_info, run_time = 2))\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(center_v_line).copy(), \n",
        "            outer_v_lines\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.cosine_graph.copy(),\n",
        "            quadratic_graph\n",
        "        ), Animation(dot))\n",
        "        for x in -1, 1, 0:\n",
        "            start_x = self.x_axis.point_to_number(dot.get_center())\n",
        "            self.play(UpdateFromAlphaFunc(\n",
        "                dot,\n",
        "                lambda d, a : d.move_to(self.input_to_graph_point(\n",
        "                    interpolate(start_x, x, a), \n",
        "                    self.cosine_graph\n",
        "                )),\n",
        "                run_time = 2\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            deriv_info, arrow, output_info, outer_v_lines\n",
        "        ])))\n",
        "\n",
        "        self.quadratic_graph = quadratic_graph\n",
        "        self.v_line = center_v_line\n",
        "        self.dot = dot\n",
        "\n",
        "    def show_derivative_pattern(self):\n",
        "        derivs_at_x, derivs_at_zero = [\n",
        "            VGroup(*[\n",
        "                OldTex(tex, \"(\", arg, \")\")\n",
        "                for tex in [\n",
        "                    \"\\\\cos\", \"-\\\\sin\", \n",
        "                    \"-\\\\cos\", \"\\\\sin\", \"\\\\cos\"\n",
        "                ]\n",
        "            ])\n",
        "            for arg in (\"x\", \"0\")\n",
        "        ]\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                UP, ORIGIN, \n",
        "                color = WHITE,\n",
        "                buff = 0,\n",
        "                tip_length = MED_SMALL_BUFF\n",
        "            ) \n",
        "            for d in derivs_at_x\n",
        "        ])\n",
        "        group = VGroup(*it.chain(*list(zip(\n",
        "            derivs_at_x,\n",
        "            arrows\n",
        "        ))))\n",
        "        group.add(OldTex(\"\\\\vdots\"))\n",
        "        group.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        group.set_height(FRAME_HEIGHT - MED_LARGE_BUFF)\n",
        "        group.to_edge(LEFT)\n",
        "        for dx, d0, color in zip(derivs_at_x, derivs_at_zero, self.colors):\n",
        "            for d in dx, d0:\n",
        "                d.set_color(color)\n",
        "            d0.replace(dx)\n",
        "        rhs_group = VGroup(*[\n",
        "            OldTex(\"=\", \"%d\"%d).scale(0.7).next_to(deriv, RIGHT)\n",
        "            for deriv, d in zip(derivs_at_zero, [1, 0, -1, 0, 1])\n",
        "        ])\n",
        "        derivative_values = VGroup(*[\n",
        "            rhs[1] for rhs in rhs_group\n",
        "        ])\n",
        "        for value, color in zip(derivative_values, self.colors):\n",
        "            value.set_color(color)\n",
        "        zeros = VGroup(*[\n",
        "            deriv.get_part_by_tex(\"0\")\n",
        "            for deriv in derivs_at_zero\n",
        "        ])\n",
        "\n",
        "        self.play(FadeIn(derivs_at_x[0]))\n",
        "        self.wait()\n",
        "        for start_d, arrow, target_d in zip(group[::2], group[1::2], group[2::2]):\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    start_d.copy(), target_d\n",
        "                ),\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            derivs_at_x, derivs_at_zero\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Write, rhs_group)))\n",
        "        self.wait()\n",
        "        for rhs in rhs_group:\n",
        "            self.play(Indicate(rhs[1]), color = WHITE)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                zero.copy(), self.dot,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.4)\n",
        "            )\n",
        "            for zero, a in zip(zeros, np.linspace(0, 0.6, len(zeros)))\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.cosine_derivative_group = VGroup(\n",
        "            derivs_at_zero, arrows, group[-1], rhs_group\n",
        "        )\n",
        "        self.derivative_values = derivative_values\n",
        "\n",
        "    def show_polynomial(self):\n",
        "        derivative_values = self.derivative_values.copy()\n",
        "        polynomial = self.get_polynomial(\"x\", 1, 0, -1, 0, 1)\n",
        "        polynomial.to_corner(UP+RIGHT)\n",
        "\n",
        "        monomial = OldTex(\"\\\\frac{1}{4!}\", \"x^4\")\n",
        "        monomial = VGroup(VGroup(monomial[0]), monomial[1])\n",
        "        monomial.next_to(polynomial, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                dv, pc,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            for dv, pc, a in zip(\n",
        "                derivative_values, \n",
        "                polynomial.coefficients,\n",
        "                np.linspace(0, 0.6, len(derivative_values))\n",
        "            )\n",
        "        ])\n",
        "        self.play(\n",
        "            Write(polynomial, run_time = 5),\n",
        "            Animation(derivative_values)\n",
        "        )\n",
        "        self.remove(derivative_values)\n",
        "        self.wait(2)\n",
        "        to_fade = self.take_derivatives_of_monomial(monomial)\n",
        "        self.play(FadeOut(to_fade))\n",
        "        self.wait()\n",
        "\n",
        "        self.polynomial = polynomial\n",
        "\n",
        "    def name_taylor_polynomial(self):\n",
        "        brace = Brace(\n",
        "            VGroup(\n",
        "                self.polynomial.coefficients, \n",
        "                self.polynomial.factorials\n",
        "            ),\n",
        "            DOWN\n",
        "        )\n",
        "        name = brace.get_text(\"``Taylor polynomial''\")\n",
        "        name.shift(MED_SMALL_BUFF*RIGHT)\n",
        "        quartic_graph = self.get_graph(\n",
        "            lambda x : 1 - (x**2)/2.0 + (x**4)/24.0,\n",
        "            color = GREEN,\n",
        "            x_min = -3.2, \n",
        "            x_max = 3.2,\n",
        "        )\n",
        "        quartic_graph.set_color(self.colors[4])\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(name))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                self.quadratic_graph, quartic_graph,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Animation(self.dot)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.taylor_name_group = VGroup(brace, name)\n",
        "\n",
        "    def draw_new_function_graph(self):\n",
        "        def func(x):\n",
        "            return (np.sin(x**2 + x)+0.5)*np.exp(-x**2)\n",
        "        graph = self.get_graph(\n",
        "            func, color = self.colors[0]\n",
        "        )\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.cosine_derivative_group,\n",
        "            self.cosine_graph,\n",
        "            self.quadratic_graph,\n",
        "            self.v_line,\n",
        "            self.dot\n",
        "        ])))\n",
        "        self.play(ShowCreation(graph))\n",
        "\n",
        "        self.graph = graph\n",
        "\n",
        "    def write_general_function_derivative(self):\n",
        "        derivs_at_x, derivs_at_zero, derivs_at_a = deriv_lists = [\n",
        "            VGroup(*[\n",
        "                OldTex(\"\\\\text{$%s$}\"%args[0], *args[1:])\n",
        "                for args in [\n",
        "                    (\"f\", \"(\", arg, \")\"),\n",
        "                    (\"\\\\frac{df}{dx}\", \"(\", arg, \")\"),\n",
        "                    (\"\\\\frac{d^2 f}{dx^2}\", \"(\", arg, \")\"),\n",
        "                    (\"\\\\frac{d^3 f}{dx^3}\", \"(\", arg, \")\"),\n",
        "                    (\"\\\\frac{d^4 f}{dx^4}\", \"(\", arg, \")\"),\n",
        "                ]\n",
        "            ])\n",
        "            for arg in (\"x\", \"0\", \"a\")\n",
        "        ]\n",
        "        derivs_at_x.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        derivs_at_x.set_height(FRAME_HEIGHT - MED_LARGE_BUFF)\n",
        "        derivs_at_x.to_edge(LEFT)\n",
        "        zeros = VGroup(*[\n",
        "            deriv.get_part_by_tex(\"0\")\n",
        "            for deriv in derivs_at_zero\n",
        "        ])\n",
        "        self.dot.move_to(self.input_to_graph_point(0, self.graph))\n",
        "        self.v_line.put_start_and_end_on(\n",
        "            self.graph_origin, self.dot.get_center()\n",
        "        )\n",
        "\n",
        "        for color, dx, d0, da in zip(self.colors, *deriv_lists):\n",
        "            for d in dx, d0, da:\n",
        "                d.set_color(color)\n",
        "                d.add_background_rectangle()\n",
        "            d0.replace(dx)\n",
        "            da.replace(dx)\n",
        "\n",
        "        self.play(FadeIn(derivs_at_x[0]))\n",
        "        self.wait()\n",
        "        for start, target in zip(derivs_at_x, derivs_at_x[1:]):\n",
        "            self.play(ReplacementTransform(\n",
        "                start.copy(), target\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            derivs_at_x, derivs_at_zero,\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            zeros.copy(), self.dot,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.play(ShowCreation(self.v_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.derivs_at_zero = derivs_at_zero\n",
        "        self.derivs_at_a = derivs_at_a\n",
        "\n",
        "    def replace_coefficients_in_generality(self):\n",
        "        new_polynomial = self.get_polynomial(\"x\", *[\n",
        "            tex_mob.get_tex()\n",
        "            for tex_mob in self.derivs_at_zero[:-1]\n",
        "        ])\n",
        "        new_polynomial.to_corner(UP+RIGHT)\n",
        "        polynomial_fourth_term = VGroup(\n",
        "            *self.polynomial[-7:-1]\n",
        "        )\n",
        "        self.polynomial.remove(*polynomial_fourth_term)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.polynomial, new_polynomial,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            FadeOut(polynomial_fourth_term),\n",
        "            FadeOut(self.taylor_name_group),\n",
        "        )\n",
        "        self.polynomial = new_polynomial\n",
        "        self.wait(3)\n",
        "\n",
        "    def walk_through_terms(self):\n",
        "        func = self.graph.underlying_function\n",
        "        approx_graphs = [\n",
        "            self.get_graph(\n",
        "                taylor_approximation(func, n),\n",
        "                color = WHITE\n",
        "            )\n",
        "            for n in range(7)\n",
        "        ]\n",
        "        for graph, color in zip(approx_graphs, self.colors):\n",
        "            graph.set_color(color)\n",
        "\n",
        "        left_mob = self.polynomial.coefficients[0]\n",
        "        right_mobs = list(self.polynomial.factorials)\n",
        "        right_mobs.append(self.polynomial[-1])\n",
        "        braces = [\n",
        "            Brace(\n",
        "                VGroup(left_mob, *right_mobs[:n]),\n",
        "                DOWN\n",
        "            )\n",
        "            for n in range(len(approx_graphs))\n",
        "        ]\n",
        "        brace = braces[0]\n",
        "        brace.stretch_to_fit_width(MED_LARGE_BUFF)\n",
        "        approx_graph = approx_graphs[0]\n",
        "\n",
        "        self.polynomial.add_background_rectangle()\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(ShowCreation(approx_graph))\n",
        "        self.wait()\n",
        "        for new_brace, new_graph in zip(braces[1:], approx_graphs[1:]):\n",
        "            self.play(Transform(brace, new_brace))\n",
        "            self.play(\n",
        "                Transform(approx_graph, new_graph, run_time = 2),\n",
        "                Animation(self.polynomial),\n",
        "                Animation(self.dot),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(brace))\n",
        "\n",
        "        self.approx_graph = approx_graph\n",
        "        self.approx_order = len(approx_graphs) - 1\n",
        "\n",
        "    def show_polynomial_around_a(self):\n",
        "        new_polynomial = self.get_polynomial(\"(x-a)\", *[\n",
        "            tex_mob.get_tex()\n",
        "            for tex_mob in self.derivs_at_a[:-2]\n",
        "        ])\n",
        "        new_polynomial.to_corner(UP+RIGHT)\n",
        "        new_polynomial.add_background_rectangle()\n",
        "\n",
        "        polynomial_third_term = VGroup(\n",
        "            *self.polynomial[1][-7:-1]\n",
        "        )\n",
        "        self.polynomial[1].remove(*polynomial_third_term)\n",
        "\n",
        "        group = VGroup(self.approx_graph, self.dot, self.v_line)\n",
        "        def get_update_function(target_x):\n",
        "            def update(group, alpha):\n",
        "                graph, dot, line = group\n",
        "                start_x = self.x_axis.point_to_number(dot.get_center())\n",
        "                x = interpolate(start_x, target_x, alpha)\n",
        "                graph_point = self.input_to_graph_point(x, self.graph)\n",
        "                dot.move_to(graph_point)\n",
        "                line.put_start_and_end_on(\n",
        "                    self.coords_to_point(x, 0),\n",
        "                    graph_point,\n",
        "                )\n",
        "                new_approx_graph = self.get_graph(\n",
        "                    taylor_approximation(\n",
        "                        self.graph.underlying_function,\n",
        "                        self.approx_order,\n",
        "                        center_point = x\n",
        "                    ),\n",
        "                    color = graph.get_color()\n",
        "                )\n",
        "                Transform(graph, new_approx_graph).update(1)\n",
        "                return VGroup(graph, dot, line)\n",
        "            return update\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                group, get_update_function(1), run_time = 2\n",
        "            ),\n",
        "            Animation(self.polynomial),\n",
        "            Animation(polynomial_third_term)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            self.derivs_at_zero, \n",
        "            self.derivs_at_a\n",
        "        ))\n",
        "        self.play(\n",
        "            Transform(self.polynomial, new_polynomial),\n",
        "            FadeOut(polynomial_third_term)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in -1, np.pi/6:\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    group, get_update_function(x), \n",
        "                ),\n",
        "                Animation(self.polynomial),\n",
        "                run_time = 4,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_polynomial(self, arg, *coefficients):\n",
        "        result = OldTex(\n",
        "            \"P(x) = \", str(coefficients[0]), *list(it.chain(*[\n",
        "                [\"+\", str(c), \"{%s\"%arg, \"^%d\"%n, \"\\\\over\", \"%d!}\"%n]\n",
        "                for n, c in zip(it.count(1), coefficients[1:])\n",
        "            ])) + [\n",
        "                \"+ \\\\cdots\"\n",
        "            ]\n",
        "        )\n",
        "        result.scale(0.8)\n",
        "        coefs = VGroup(result[1], *result[3:-1:6])\n",
        "        for coef, color in zip(coefs, self.colors):\n",
        "            coef.set_color(color)\n",
        "        result.coefficients = coefs\n",
        "        result.factorials = VGroup(*result[7::6])\n",
        "\n",
        "        return result\n",
        "\n",
        "class ThisIsAStandardFormula(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"You will see this \\\\\\\\ in your texts\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"sad\"]*3,\n",
        "            look_at = FRAME_Y_RADIUS*UP\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ExpPolynomial(TranslationOfInformation, ExampleApproximationWithExp):\n",
        "    CONFIG = {\n",
        "        \"x_tick_frequency\" : 1,\n",
        "        \"x_leftmost_tick\" : -3,\n",
        "        \"graph_origin\" : 2*(DOWN+LEFT),\n",
        "        \"y_axis_label\" : \"\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graph()\n",
        "        self.show_derivatives()\n",
        "        self.show_polynomial()\n",
        "        self.walk_through_terms()\n",
        "\n",
        "    def add_graph(self):\n",
        "        graph = self.get_graph(np.exp)\n",
        "        e_to_x = self.get_graph_label(graph, \"e^x\")\n",
        "    \n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(\n",
        "                e_to_x, \n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.e_to_x = e_to_x\n",
        "\n",
        "    def show_derivatives(self):\n",
        "        self.e_to_x.generate_target()\n",
        "        derivs_at_x, derivs_at_zero = [\n",
        "            VGroup(*[\n",
        "                OldTex(\"e^%s\"%s).set_color(c)\n",
        "                for c in self.colors\n",
        "            ])\n",
        "            for s in (\"x\", \"0\")\n",
        "        ]\n",
        "        derivs_at_x.submobjects[0] = self.e_to_x.target\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                UP, ORIGIN, \n",
        "                color = WHITE,\n",
        "                buff = SMALL_BUFF,\n",
        "                tip_length = 0.2,\n",
        "            ) \n",
        "            for d in derivs_at_x\n",
        "        ])\n",
        "        group = VGroup(*it.chain(*list(zip(\n",
        "            derivs_at_x,\n",
        "            arrows\n",
        "        ))))\n",
        "        group.add(OldTex(\"\\\\vdots\"))\n",
        "        group.arrange(DOWN, buff = 2*SMALL_BUFF)\n",
        "        group.set_height(FRAME_HEIGHT - MED_LARGE_BUFF)\n",
        "        group.to_edge(LEFT)\n",
        "        for dx, d0 in zip(derivs_at_x, derivs_at_zero):\n",
        "            for d in dx, d0:\n",
        "                d.add_background_rectangle()\n",
        "            d0.replace(dx)\n",
        "        rhs_group = VGroup(*[\n",
        "            OldTex(\"=\", \"1\").scale(0.7).next_to(deriv, RIGHT)\n",
        "            for deriv in derivs_at_zero\n",
        "        ])\n",
        "        derivative_values = VGroup(*[\n",
        "            rhs[1] for rhs in rhs_group\n",
        "        ])\n",
        "        for value, color in zip(derivative_values, self.colors):\n",
        "            value.set_color(color)\n",
        "\n",
        "        for arrow in arrows:\n",
        "            d_dx = OldTex(\"d/dx\")\n",
        "            d_dx.scale(0.5)\n",
        "            d_dx.next_to(arrow, RIGHT, SMALL_BUFF)\n",
        "            d_dx.shift(SMALL_BUFF*UP)\n",
        "            arrow.add(d_dx)\n",
        "\n",
        "        self.play(MoveToTarget(self.e_to_x))\n",
        "        derivs_at_x.submobjects[0] = self.e_to_x\n",
        "        for start_d, arrow, target_d in zip(group[::2], group[1::2], group[2::2]):\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    start_d.copy(), target_d\n",
        "                ),\n",
        "                Write(arrow, run_time = 1)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            derivs_at_x, derivs_at_zero\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Write, rhs_group)))\n",
        "\n",
        "        self.derivative_values = derivative_values\n",
        "\n",
        "    def show_polynomial(self):\n",
        "        derivative_values = self.derivative_values.copy()\n",
        "        polynomial = self.get_polynomial(\"x\", 1, 1, 1, 1, 1)\n",
        "        polynomial.to_corner(UP+RIGHT)\n",
        "\n",
        "        ##These are to make the walk_through_terms method work\n",
        "        self.polynomial = polynomial.copy()\n",
        "        self.dot = Dot(fill_opacity = 0)\n",
        "        ###\n",
        "        polynomial.add_background_rectangle()\n",
        "\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                dv, pc,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            for dv, pc in zip(\n",
        "                derivative_values, \n",
        "                polynomial.coefficients,\n",
        "            )\n",
        "        ])\n",
        "        self.play(\n",
        "            Write(polynomial, run_time = 4),\n",
        "            Animation(derivative_values)\n",
        "        )\n",
        "\n",
        "    ####\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "\n",
        "class ShowSecondTerm(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        colors = CubicAndQuarticApproximations.CONFIG[\"colors\"]\n",
        "        polynomial = OldTex(\n",
        "            \"f(a)\", \"+\", \n",
        "            \"\\\\frac{df}{dx}(a)\", \"(x - a)\", \"+\",\n",
        "            \"\\\\frac{d^2 f}{dx^2}(a)\", \"(x - a)^2\"\n",
        "        )\n",
        "        for tex, color in zip([\"f(a)\", \"df\", \"d^2 f\"], colors):\n",
        "            polynomial.set_color_by_tex(tex, color)\n",
        "        polynomial.next_to(self.teacher, UP+LEFT)\n",
        "        polynomial.shift(MED_LARGE_BUFF*UP)\n",
        "        second_term = VGroup(*polynomial[-2:])\n",
        "        box = Rectangle(color = colors[2])\n",
        "        box.replace(second_term, stretch = True)\n",
        "        box.stretch_in_place(1.1, 0)\n",
        "        box.stretch_in_place(1.2, 1)\n",
        "        words = OldTexText(\"Geometric view\")\n",
        "        words.next_to(box, UP)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"Now for \\\\\\\\ something fun!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode = \"raise_right_hand\"\n",
        "            ),\n",
        "            Write(polynomial)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(box),\n",
        "            FadeIn(words),\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class SecondTermIntuition(AreaIsDerivative):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda x : x*(x-1)*(x-2) + 2,\n",
        "        \"num_rects\" : 300,\n",
        "        \"t_max\" : 2.3,\n",
        "        \"x_max\" : 4,\n",
        "        \"x_labeled_nums\" : None,\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_labeled_nums\" : None,\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"y_min\" : -1,\n",
        "        \"y_max\" : 5,\n",
        "        \"y_tick_frequency\" : 1,\n",
        "        \"variable_point_label\" : \"x\",\n",
        "        \"area_opacity\" : 1,\n",
        "        \"default_riemann_start_color\" : BLUE_E,\n",
        "        \"dx\" : 0.15,\n",
        "        \"skip_reconfiguration\" : False,\n",
        "    }\n",
        "    def setup(self):\n",
        "        GraphScene.setup(self)\n",
        "        ReconfigurableScene.setup(self)\n",
        "        self.foreground_mobjects = []\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.introduce_area()\n",
        "        self.write_derivative()\n",
        "        self.nudge_end_point()\n",
        "        self.point_out_triangle()\n",
        "        self.relabel_start_and_end()\n",
        "        self.compute_triangle_area()\n",
        "        self.walk_through_taylor_terms()\n",
        "\n",
        "    def introduce_area(self):\n",
        "        graph = self.v_graph = self.get_graph(\n",
        "            self.func, color = WHITE,\n",
        "        )\n",
        "        self.foreground_mobjects.append(graph)\n",
        "        area = self.area = self.get_area(0, self.t_max)\n",
        "\n",
        "        func_name = OldTex(\"f_{\\\\text{area}}(x)\")\n",
        "        func_name.move_to(self.coords_to_point(0.6, 1))\n",
        "        self.foreground_mobjects.append(func_name)\n",
        "\n",
        "        self.add(graph, area, func_name)\n",
        "        self.add_T_label(self.t_max)\n",
        "\n",
        "        if not self.skip_animations:\n",
        "            for target in 1.6, 2.7, self.t_max:\n",
        "                self.change_area_bounds(\n",
        "                    new_t_max = target,\n",
        "                    run_time = 3,\n",
        "                )\n",
        "        self.__name__ = func_name\n",
        "\n",
        "    def write_derivative(self):\n",
        "        deriv = OldTex(\"\\\\frac{df_{\\\\text{area}}}{dx}(x)\")\n",
        "        deriv.next_to(\n",
        "            self.input_to_graph_point(2.7, self.v_graph),\n",
        "            RIGHT\n",
        "        )\n",
        "        deriv.shift_onto_screen()\n",
        "\n",
        "        self.play(ApplyWave(self.v_graph, direction = UP))\n",
        "        self.play(Write(deriv, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.deriv_label = deriv\n",
        "\n",
        "    def nudge_end_point(self):\n",
        "        dark_area = self.area.copy()\n",
        "        dark_area.set_fill(BLACK, opacity = 0.5)\n",
        "        curr_x = self.x_axis.point_to_number(self.area.get_right())\n",
        "        new_x = curr_x + self.dx\n",
        "\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.75\n",
        "        )\n",
        "        rect.replace(\n",
        "            VGroup(\n",
        "                VectorizedPoint(self.coords_to_point(new_x, 0)),\n",
        "                self.right_v_line,\n",
        "            ),\n",
        "            stretch = True\n",
        "        )\n",
        "\n",
        "        dx_brace = Brace(rect, DOWN, buff = 0)\n",
        "        dx_label = dx_brace.get_text(\"$dx$\", buff = SMALL_BUFF)\n",
        "        dx_label_group = VGroup(dx_label, dx_brace)\n",
        "\n",
        "        height_brace = Brace(rect, LEFT, buff = SMALL_BUFF)\n",
        "\n",
        "        self.change_area_bounds(new_t_max = new_x)\n",
        "        self.play(\n",
        "            FadeIn(dark_area),\n",
        "            *list(map(Animation, self.foreground_mobjects))\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.T_label_group),\n",
        "            FadeIn(dx_label_group),\n",
        "            FadeIn(rect),\n",
        "            FadeIn(height_brace)\n",
        "        )\n",
        "        self.wait()\n",
        "        if not self.skip_reconfiguration:\n",
        "            self.transition_to_alt_config(\n",
        "                dx = self.dx/10.0,\n",
        "                run_time = 3,\n",
        "            )\n",
        "        self.play(FadeOut(height_brace))\n",
        "\n",
        "        self.dx_label_group = dx_label_group\n",
        "        self.rect = rect\n",
        "        self.dark_area = dark_area\n",
        "\n",
        "    def point_out_triangle(self):\n",
        "        triangle = Polygon(LEFT, ORIGIN, UP)\n",
        "        triangle.set_stroke(width = 0)\n",
        "        triangle.set_fill(MAROON_B, opacity = 1)\n",
        "        triangle.replace(\n",
        "            Line(\n",
        "                self.rect.get_corner(UP+LEFT),\n",
        "                self.right_v_line.get_top()\n",
        "            ),\n",
        "            stretch = True\n",
        "        )\n",
        "        circle = Circle(color = RED)\n",
        "        circle.set_height(triangle.get_height())\n",
        "        circle.replace(triangle, dim_to_match = 1)\n",
        "        circle.scale(1.3)\n",
        "\n",
        "        self.play(DrawBorderThenFill(triangle))\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(FadeOut(circle))\n",
        "\n",
        "        self.triangle = triangle\n",
        "\n",
        "    def relabel_start_and_end(self):\n",
        "        dx_label, dx_brace = self.dx_label_group\n",
        "        x_minus_a = OldTex(\"(x-a)\")\n",
        "        x_minus_a.scale(0.7)\n",
        "        x_minus_a.move_to(dx_label)\n",
        "        labels = VGroup()\n",
        "        arrows = VGroup()\n",
        "        for vect, tex in (LEFT, \"a\"), (RIGHT, \"x\"):\n",
        "            point = self.rect.get_corner(DOWN+vect)\n",
        "            label = OldTex(tex)\n",
        "            label.next_to(point, DOWN+vect)\n",
        "            label.shift(LARGE_BUFF*vect)\n",
        "            arrow = Arrow(\n",
        "                label.get_corner(UP-vect),\n",
        "                point,\n",
        "                buff = SMALL_BUFF,\n",
        "                tip_length = 0.2,\n",
        "                color = WHITE\n",
        "            )\n",
        "            labels.add(label)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "\n",
        "        for label, arrow in zip(labels, arrows):\n",
        "            self.play(\n",
        "                Write(label),\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            dx_label, x_minus_a\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.x_minus_a = x_minus_a\n",
        "\n",
        "    def compute_triangle_area(self):\n",
        "        triangle = self.triangle.copy()\n",
        "        tex_scale_factor = 0.7\n",
        "        base_line = Line(*[\n",
        "            triangle.get_corner(DOWN+vect)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        base_line.set_color(RED)\n",
        "        base_label = OldTexText(\"Base = \", \"$(x-a)$\")\n",
        "        base_label.scale(tex_scale_factor)\n",
        "        base_label.next_to(base_line, DOWN+RIGHT, MED_LARGE_BUFF)\n",
        "        base_label.shift(SMALL_BUFF*UP)\n",
        "        base_term = base_label[1].copy()\n",
        "        base_arrow = Arrow(\n",
        "            base_label.get_left(), \n",
        "            base_line.get_center(),\n",
        "            buff = SMALL_BUFF,\n",
        "            color = base_line.get_color(),\n",
        "            tip_length = 0.2\n",
        "        )\n",
        "\n",
        "        height_brace = Brace(triangle, RIGHT, buff = SMALL_BUFF)\n",
        "        height_labels = [\n",
        "            OldTex(\"\\\\text{Height} = \", s, \"(x-a)\")\n",
        "            for s in [\n",
        "                \"(\\\\text{Slope})\", \n",
        "                \"\\\\frac{d^2 f_{\\\\text{area}}}{dx^2}(a)\"\n",
        "            ]\n",
        "        ]\n",
        "        for label in height_labels:\n",
        "            label.scale(tex_scale_factor)\n",
        "            label.next_to(height_brace, RIGHT)\n",
        "        height_term = VGroup(*height_labels[1][1:]).copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(base_label),\n",
        "            ShowCreation(base_arrow),\n",
        "            ShowCreation(base_line)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowFromCenter(height_brace),\n",
        "            Write(height_labels[0])\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(*height_labels))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Show area formula\n",
        "        equals_half = OldTex(\"=\\\\frac{1}{2}\")\n",
        "        equals_half.scale(tex_scale_factor)\n",
        "        group = VGroup(triangle, equals_half, height_term, base_term)\n",
        "        group.generate_target()\n",
        "        group.target.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        group.target[-1].next_to(\n",
        "            group.target[-2], RIGHT,\n",
        "            buff = SMALL_BUFF,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        group.target[1].shift(0.02*DOWN)\n",
        "        group.target.to_corner(UP+RIGHT)\n",
        "        exp_2 = OldTex(\"2\").scale(0.8*tex_scale_factor)\n",
        "        exp_2.next_to(\n",
        "            group.target[-2], UP+RIGHT,\n",
        "            buff = 0,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        equals_half.scale(0.1)\n",
        "        equals_half.move_to(triangle)\n",
        "        equals_half.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.deriv_label),\n",
        "            MoveToTarget(group, run_time = 2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            group[-1], exp_2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def walk_through_taylor_terms(self):\n",
        "        mini_area, mini_rect, mini_triangle = [\n",
        "            mob.copy()\n",
        "            for mob in (self.dark_area, self.rect, self.triangle)\n",
        "        ]\n",
        "        mini_area.set_fill(BLUE_E, opacity = 1)\n",
        "        mini_area.set_height(1)\n",
        "        mini_rect.set_height(1)\n",
        "        mini_triangle.set_height(0.5)\n",
        "\n",
        "        geometric_taylor = VGroup(\n",
        "            OldTex(\"f(x) \\\\approx \"), mini_area,\n",
        "            OldTex(\"+\"), mini_rect,\n",
        "            OldTex(\"+\"), mini_triangle,\n",
        "        )\n",
        "        geometric_taylor.arrange(\n",
        "            RIGHT, buff = MED_SMALL_BUFF\n",
        "        )\n",
        "        geometric_taylor.to_corner(UP+LEFT)\n",
        "\n",
        "        analytic_taylor = OldTex(\n",
        "            \"f(x) \\\\approx\", \"f(a)\", \"+\",\n",
        "            \"\\\\frac{df}{dx}(a)(x-a)\", \"+\",\n",
        "            \"\\\\frac{1}{2}\\\\frac{d^2 f}{dx^2}(a)(x-a)^2\"\n",
        "        )\n",
        "        analytic_taylor.set_color_by_tex(\"f(a)\", BLUE)\n",
        "        analytic_taylor.set_color_by_tex(\"df\", YELLOW)\n",
        "        analytic_taylor.set_color_by_tex(\"d^2 f\", MAROON_B)\n",
        "        analytic_taylor.scale(0.7)\n",
        "        analytic_taylor.next_to(\n",
        "            geometric_taylor, DOWN,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        for part in analytic_taylor:\n",
        "            part.add_to_back(BackgroundRectangle(part))\n",
        "\n",
        "        new_func_name = OldTex(\"f_{\\\\text{area}}(a)\")\n",
        "        new_func_name.replace(self.__name__)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            geometric_taylor,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(VGroup(*analytic_taylor[:3])),\n",
        "            self.dark_area.set_fill, BLUE_E, 1,\n",
        "            Transform(self.__name__, new_func_name)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.rect.scale, 0.5,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(FadeIn(VGroup(*analytic_taylor[3:5])))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.triangle.scale, 0.5,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(FadeIn(VGroup(*analytic_taylor[5:])))\n",
        "        self.wait(3)\n",
        "\n",
        "class EachTermHasMeaning(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.get_pi_creatures().scale(0.8).shift(UP)\n",
        "        self.teacher_says(\n",
        "            \"Each term \\\\\\\\ has meaning!\",\n",
        "            target_mode = \"hooray\",\n",
        "            bubble_config = {\"height\" : 3, \"width\" : 4}\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"thinking\"]*3,\n",
        "            look_at = 4*UP\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class AskAboutInfiniteSum(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.ask_question()\n",
        "        self.name_taylor_series()\n",
        "        self.be_careful()\n",
        "\n",
        "\n",
        "    def ask_question(self):\n",
        "        big_rect = Rectangle(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = FRAME_HEIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color =  BLACK,\n",
        "            fill_opacity = 0.7,\n",
        "        )\n",
        "        randy = self.get_students()[1]\n",
        "        series = OldTex(\n",
        "            \"\\\\cos(x)\", \"\\\\approx\", \n",
        "            \"1 - \\\\frac{x^2}{2!} + \\\\frac{x^4}{4!}\",\n",
        "            \" - \\\\frac{x^6}{6!}\",\n",
        "            \"+\\\\cdots\"\n",
        "        )\n",
        "        series.next_to(randy, UP, 2)\n",
        "        series.shift_onto_screen()\n",
        "        rhs = VGroup(*series[2:])\n",
        "        arrow = Arrow(rhs.get_left(), rhs.get_right())\n",
        "        arrow.next_to(rhs, UP)\n",
        "        words = OldTexText(\"Add infinitely many\")\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"We could call \\\\\\\\ it an end here\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"erm\"]*3)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher),\n",
        "            self.get_students()[0].change_mode, \"plain\",\n",
        "            self.get_students()[2].change_mode, \"plain\",\n",
        "            FadeIn(big_rect),\n",
        "            randy.change_mode, \"pondering\"\n",
        "        )\n",
        "        crowd = VGroup(*self.get_pi_creatures())\n",
        "        crowd.remove(randy)\n",
        "        self.crowd_copy = crowd.copy()\n",
        "        self.remove(crowd)\n",
        "        self.add(self.crowd_copy, big_rect, randy)\n",
        "\n",
        "        self.play(Write(series))\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.arrow = arrow\n",
        "        self.words = words\n",
        "        self.series = series\n",
        "        self.randy = randy\n",
        "\n",
        "    def name_taylor_series(self):\n",
        "        series_def = OldTexText(\n",
        "            \"Infinite sum $\\\\Leftrightarrow$ series\"\n",
        "        )\n",
        "        taylor_series = OldTexText(\"Taylor series\")\n",
        "        for mob in series_def, taylor_series:\n",
        "            mob.move_to(self.words)\n",
        "        brace = Brace(self.series.get_part_by_tex(\"4!\"), DOWN)\n",
        "        taylor_polynomial = brace.get_text(\"Taylor polynomial\")\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.words, series_def\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(taylor_polynomial)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            series_def.scale, 0.7,\n",
        "            series_def.to_corner, UP+RIGHT,\n",
        "            FadeIn(taylor_series)\n",
        "        )\n",
        "        self.play(self.randy.change, \"thinking\", taylor_series)\n",
        "        self.wait()\n",
        "\n",
        "    def be_careful(self):\n",
        "        self.play(FadeIn(self.teacher))\n",
        "        self.remove(self.crowd_copy[0])\n",
        "        self.teacher_says(\n",
        "            \"Be careful\",\n",
        "            bubble_config = {\n",
        "                \"width\" : 3,\n",
        "                \"height\" : 2\n",
        "            },\n",
        "            added_anims = [self.randy.change, \"hesitant\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(self.randy.change, \"confused\", self.series)\n",
        "        self.wait(3)\n",
        "\n",
        "class ConvergenceExample(Scene):\n",
        "    def construct(self):\n",
        "        max_shown_power = 6\n",
        "        max_computed_power = 13\n",
        "        series = OldTex(*list(it.chain(*[\n",
        "            [\"\\\\frac{1}{%d}\"%(3**n), \"+\"]\n",
        "            for n in range(1, max_shown_power)\n",
        "        ])) + [\"\\\\cdots\"])\n",
        "        series_nums = [3**(-n) for n in range(1, max_computed_power)]\n",
        "        partial_sums = np.cumsum(series_nums)\n",
        "        braces = self.get_partial_sum_braces(series, partial_sums)\n",
        "\n",
        "        convergence_words = OldTexText(\"``Converges'' to $\\\\frac{1}{2}$\")\n",
        "        convergence_words.next_to(series, UP, LARGE_BUFF)\n",
        "        convergence_words.set_color(YELLOW)\n",
        "        rhs = OldTex(\"= \\\\frac{1}{2}\")\n",
        "        rhs.next_to(series, RIGHT)\n",
        "        rhs.set_color(BLUE)\n",
        "\n",
        "        brace = braces[0]\n",
        "        self.add(series, brace)\n",
        "        for i, new_brace in enumerate(braces[1:]):\n",
        "            self.play(Transform(brace, new_brace))\n",
        "            if i == 4:\n",
        "                self.play(FadeIn(convergence_words))\n",
        "            else:\n",
        "                self.wait()\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            Write(rhs)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_partial_sum_braces(self, series, partial_sums):\n",
        "        braces = [\n",
        "            Brace(VGroup(*series[:n]))\n",
        "            for n in range(1, len(series)-1, 2)\n",
        "        ]\n",
        "        last_brace = braces[-1]\n",
        "        braces += [\n",
        "            braces[-1].copy().stretch_in_place(\n",
        "                1 + 0.1 + 0.02*(n+1), dim = 0,\n",
        "            ).move_to(last_brace, LEFT)\n",
        "            for n in range(len(partial_sums) - len(braces))\n",
        "        ]\n",
        "        for brace, partial_sum in zip(braces, partial_sums):\n",
        "            number = brace.get_text(\"%.7f\"%partial_sum)\n",
        "            number.set_color(YELLOW)\n",
        "            brace.add(number)\n",
        "        return braces\n",
        "\n",
        "class ExpConvergenceExample(ConvergenceExample):\n",
        "    def construct(self):\n",
        "        e_to_x, series_with_x = x_group = self.get_series(\"x\")\n",
        "        x_group.to_edge(UP)\n",
        "        e_to_1, series_with_1 = one_group = self.get_series(\"1\")\n",
        "        terms = [1./math.factorial(n) for n in range(11)]\n",
        "        partial_sums = np.cumsum(terms)\n",
        "        braces = self.get_partial_sum_braces(series_with_1, partial_sums)\n",
        "        brace = braces[1]\n",
        "\n",
        "        for lhs, s in (e_to_x, \"x\"), (e_to_1, \"1\"):\n",
        "            new_lhs = OldTex(\"e^%s\"%s, \"=\")\n",
        "            new_lhs.move_to(lhs, RIGHT)\n",
        "            lhs.target = new_lhs\n",
        "\n",
        "        self.add(x_group)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(x_group.copy(), one_group))\n",
        "        self.play(FadeIn(brace))\n",
        "        self.wait()\n",
        "        for new_brace in braces[2:]:\n",
        "            self.play(Transform(brace, new_brace))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(e_to_1))\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_series(self, arg, n_terms = 5):\n",
        "        series = OldTex(\"1\", \"+\", *list(it.chain(*[\n",
        "            [\"\\\\frac{%s^%d}{%d!}\"%(arg, n, n), \"+\"]\n",
        "            for n in range(1, n_terms+1)\n",
        "        ])) + [\"\\\\cdots\"])\n",
        "        colors = list(CubicAndQuarticApproximations.CONFIG[\"colors\"])\n",
        "        colors += [BLUE_C]\n",
        "        for term, color in zip(series[::2], colors):\n",
        "            term.set_color(color)\n",
        "\n",
        "        lhs = OldTex(\"e^%s\"%arg, \"\\\\rightarrow\")\n",
        "        lhs.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        group = VGroup(lhs, series)\n",
        "        group.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        return group\n",
        "\n",
        "class ExpGraphConvergence(ExpPolynomial, ExpConvergenceExample):\n",
        "    CONFIG = {\n",
        "        \"example_input\" : 2,\n",
        "        \"graph_origin\" : 3*DOWN + LEFT,\n",
        "        \"n_iterations\" : 8,\n",
        "        \"y_max\" : 20,\n",
        "        \"num_graph_anchor_points\" : 50,\n",
        "        \"func\" : np.exp,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_series()\n",
        "        approx_graphs = self.get_approx_graphs()\n",
        "\n",
        "        graph = self.get_graph(self.func, color = self.colors[0])\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.example_input, graph,\n",
        "            line_class = DashedLine,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        dot = Dot(color = YELLOW)\n",
        "        dot.to_corner(UP+LEFT)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.replace(self.arrow)\n",
        "        equals.scale(0.8)\n",
        "\n",
        "        brace = self.braces[1]\n",
        "        approx_graph = approx_graphs[1]\n",
        "        x = self.example_input\n",
        "        self.add(graph, self.series)\n",
        "        self.wait()\n",
        "        self.play(dot.move_to, self.coords_to_point(x, 0))\n",
        "        self.play(\n",
        "            dot.move_to, self.input_to_graph_point(x, graph),\n",
        "            ShowCreation(v_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(approx_graph)\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_brace, new_graph in zip(self.braces[2:], approx_graphs[2:]):\n",
        "            self.play(\n",
        "                Transform(brace, new_brace),\n",
        "                Transform(approx_graph, new_graph),\n",
        "                Animation(self.series),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FocusOn(equals))\n",
        "        self.play(Transform(self.arrow, equals))\n",
        "        self.wait(2)\n",
        "\n",
        "    def add_series(self):\n",
        "        series_group = self.get_series(\"x\")\n",
        "        e_to_x, series = series_group\n",
        "        series_group.scale(0.8)\n",
        "        series_group.to_corner(UP+LEFT)\n",
        "        braces = self.get_partial_sum_braces(\n",
        "            series, np.zeros(self.n_iterations)\n",
        "        )\n",
        "        for brace in braces:\n",
        "            brace.remove(brace[-1])\n",
        "\n",
        "        series.add_background_rectangle()\n",
        "        self.add(series_group)\n",
        "\n",
        "        self.braces = braces\n",
        "        self.series = series\n",
        "        self.arrow = e_to_x[1]\n",
        "\n",
        "    def get_approx_graphs(self):\n",
        "        def get_nth_approximation(n):\n",
        "            return lambda x : sum([\n",
        "                float(x**k)/math.factorial(k)\n",
        "                for k in range(n+1)\n",
        "            ])\n",
        "        approx_graphs = [\n",
        "            self.get_graph(get_nth_approximation(n))\n",
        "            for n in range(self.n_iterations)\n",
        "        ]\n",
        "\n",
        "        colors = it.chain(self.colors, it.repeat(WHITE))\n",
        "        for approx_graph, color in zip(approx_graphs, colors):\n",
        "            approx_graph.set_color(color)\n",
        "            dot = Dot(color = WHITE)\n",
        "            dot.move_to(self.input_to_graph_point(\n",
        "                self.example_input, approx_graph\n",
        "            ))\n",
        "            approx_graph.add(dot)\n",
        "\n",
        "        return approx_graphs\n",
        "\n",
        "class SecondExpGraphConvergence(ExpGraphConvergence):\n",
        "    CONFIG = {\n",
        "        \"example_input\" : 3,\n",
        "        \"n_iterations\" : 12,\n",
        "    }\n",
        "\n",
        "class BoundedRadiusOfConvergence(CubicAndQuarticApproximations):\n",
        "    CONFIG = {\n",
        "        \"num_graph_anchor_points\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        func = lambda x : (np.sin(x**2 + x)+0.5)*(np.log(x+1.01)+1)*np.exp(-x)\n",
        "        graph = self.get_graph(\n",
        "            func, color = self.colors[0],\n",
        "            x_min = -0.99,\n",
        "            x_max = self.x_max,\n",
        "        )\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            0, graph,\n",
        "            line_class = DashedLine,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        dot = Dot(color = YELLOW).move_to(v_line.get_top())\n",
        "        two_graph = self.get_graph(lambda x : 2)\n",
        "        outer_v_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                self.coords_to_point(x, -2),\n",
        "                self.coords_to_point(x, 2),\n",
        "                color = WHITE\n",
        "            )\n",
        "            for x in (-1, 1)\n",
        "        ])\n",
        "\n",
        "        colors = list(self.colors) + [GREEN, MAROON_B, PINK]\n",
        "        approx_graphs = [\n",
        "            self.get_graph(\n",
        "                taylor_approximation(func, n),\n",
        "                color = color\n",
        "            )\n",
        "            for n, color in enumerate(colors)\n",
        "        ]\n",
        "        approx_graph = approx_graphs[1]\n",
        "\n",
        "        self.add(graph, v_line, dot)\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(v_line.copy()), outer_v_lines\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(approx_graph),\n",
        "            Animation(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_graph in approx_graphs[2:]:\n",
        "            self.play(\n",
        "                Transform(approx_graph, new_graph),\n",
        "                Animation(dot)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "class RadiusOfConvergenceForLnX(ExpGraphConvergence):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -1,\n",
        "        \"x_leftmost_tick\" : None,\n",
        "        \"x_max\" : 5,\n",
        "        \"y_min\" : -2,\n",
        "        \"y_max\" : 3,\n",
        "        \"graph_origin\" : DOWN+2*LEFT,\n",
        "        \"func\" : np.log,\n",
        "        \"num_graph_anchor_points\" : 100,\n",
        "        \"initial_n_iterations\" : 7,\n",
        "        \"n_iterations\" : 11,\n",
        "        \"convergent_example\" : 1.5,\n",
        "        \"divergent_example\" : 2.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.add_series()\n",
        "        self.show_bounds()\n",
        "        self.show_converging_point()\n",
        "        self.show_diverging_point()\n",
        "        self.write_divergence()\n",
        "        self.write_radius_of_convergence()\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.setup_axes()\n",
        "        self.graph = self.get_graph(\n",
        "            self.func,\n",
        "            x_min = 0.01\n",
        "        )\n",
        "        self.add(self.graph)\n",
        "\n",
        "    def add_series(self):\n",
        "        series = OldTex(\n",
        "            \"\\\\ln(x) \\\\rightarrow\", \n",
        "            \"(x-1)\", \"-\",\n",
        "            \"\\\\frac{(x-1)^2}{2}\", \"+\",\n",
        "            \"\\\\frac{(x-1)^3}{3}\", \"-\",\n",
        "            \"\\\\frac{(x-1)^4}{4}\", \"+\",\n",
        "            \"\\\\cdots\"\n",
        "        )\n",
        "        lhs = VGroup(*series[1:])\n",
        "        series.add_background_rectangle()\n",
        "        series.scale(0.8)\n",
        "        series.to_corner(UP+LEFT)\n",
        "        for n in range(4):\n",
        "            lhs[2*n].set_color(self.colors[n+1])\n",
        "        self.braces = self.get_partial_sum_braces(\n",
        "            lhs, np.zeros(self.n_iterations)\n",
        "        )\n",
        "        for brace in self.braces:\n",
        "            brace.remove(brace[-1])\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            series, \n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.series = series\n",
        "        self.foreground_mobjects = [series]\n",
        "\n",
        "    def show_bounds(self):\n",
        "        dot = Dot(fill_opacity = 0)\n",
        "        dot.move_to(self.series)\n",
        "        v_lines = [\n",
        "            DashedLine(*[\n",
        "                self.coords_to_point(x, y)\n",
        "                for y in (-2, 2)\n",
        "            ])\n",
        "            for x in (0, 1, 2)\n",
        "        ]\n",
        "        outer_v_lines = VGroup(*v_lines[::2])\n",
        "        center_v_line = VGroup(v_lines[1])\n",
        "        input_v_line = Line(*[\n",
        "            self.coords_to_point(self.convergent_example, y)\n",
        "            for y in (-4, 3)\n",
        "        ])\n",
        "        input_v_line.set_stroke(WHITE, width = 2)\n",
        "\n",
        "        self.play(\n",
        "            dot.move_to, self.coords_to_point(1, 0),\n",
        "            dot.set_fill, YELLOW, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(center_v_line),\n",
        "            Animation(dot)\n",
        "        )\n",
        "        self.play(Transform(center_v_line, outer_v_lines))\n",
        "\n",
        "        self.foreground_mobjects.append(dot)\n",
        "\n",
        "    def show_converging_point(self):\n",
        "        approx_graphs = [\n",
        "            self.get_graph(\n",
        "                taylor_approximation(self.func, n, 1),\n",
        "                color = WHITE\n",
        "            )\n",
        "            for n in range(1, self.n_iterations+1)\n",
        "        ]\n",
        "        colors = it.chain(\n",
        "            self.colors[1:],\n",
        "            [GREEN, MAROON_B],\n",
        "            it.repeat(PINK)\n",
        "        )\n",
        "        for graph, color in zip(approx_graphs, colors):\n",
        "            graph.set_color(color)\n",
        "        for graph in approx_graphs:\n",
        "            dot = Dot(color = WHITE)\n",
        "            dot.move_to(self.input_to_graph_point(\n",
        "                self.convergent_example, graph\n",
        "            ))\n",
        "            graph.dot = dot\n",
        "            graph.add(dot)\n",
        "\n",
        "        approx_graph = approx_graphs[0].deepcopy()\n",
        "        approx_dot = approx_graph.dot\n",
        "        brace = self.braces[0].copy()\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeIn, [approx_graph, brace])),\n",
        "            list(map(Animation, self.foreground_mobjects))\n",
        "        ))\n",
        "        self.wait()\n",
        "        new_graphs = approx_graphs[1:self.initial_n_iterations]\n",
        "        for new_graph, new_brace in zip(new_graphs, self.braces[1:]):\n",
        "            self.play(\n",
        "                Transform(approx_graph, new_graph),\n",
        "                Transform(brace, new_brace),\n",
        "                *list(map(Animation, self.foreground_mobjects))\n",
        "            )\n",
        "            self.wait()\n",
        "        approx_graph.remove(approx_dot)\n",
        "        self.play(\n",
        "            approx_dot.move_to, self.coords_to_point(self.divergent_example, 0),\n",
        "            *it.chain(\n",
        "                list(map(FadeOut, [approx_graph, brace])),\n",
        "                list(map(Animation, self.foreground_mobjects))\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.approx_graphs = approx_graphs\n",
        "        self.approx_dot = approx_dot\n",
        "        \n",
        "    def show_diverging_point(self):\n",
        "        for graph in self.approx_graphs:\n",
        "            graph.dot.move_to(self.input_to_graph_point(\n",
        "                self.divergent_example, graph\n",
        "            ))\n",
        "\n",
        "        approx_graph = self.approx_graphs[0].deepcopy()\n",
        "        brace = self.braces[0].copy()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.approx_dot, approx_graph.dot\n",
        "            ),\n",
        "            FadeIn(approx_graph[0]),\n",
        "            FadeIn(brace),\n",
        "            *list(map(Animation, self.foreground_mobjects))\n",
        "        )\n",
        "\n",
        "        new_graphs = self.approx_graphs[1:self.initial_n_iterations]\n",
        "        for new_graph, new_brace in zip(self.approx_graphs[1:], self.braces[1:]):\n",
        "            self.play(\n",
        "                Transform(approx_graph, new_graph),\n",
        "                Transform(brace, new_brace),\n",
        "                *list(map(Animation, self.foreground_mobjects))\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.approx_dot = approx_graph.dot\n",
        "        self.approx_graph = approx_graph\n",
        "\n",
        "    def write_divergence(self):\n",
        "        word = OldTexText(\"``Diverges''\")\n",
        "        word.next_to(self.approx_dot, RIGHT, LARGE_BUFF)\n",
        "        word.shift(MED_SMALL_BUFF*DOWN)\n",
        "        word.add_background_rectangle()\n",
        "        arrow = Arrow(\n",
        "            word.get_left(), self.approx_dot,\n",
        "            buff = SMALL_BUFF,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(word),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        new_graphs = self.approx_graphs[self.initial_n_iterations:]\n",
        "        for new_graph in new_graphs:\n",
        "            self.play(\n",
        "                Transform(self.approx_graph, new_graph),\n",
        "                *list(map(Animation, self.foreground_mobjects))\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def write_radius_of_convergence(self):\n",
        "        line = Line(*[\n",
        "            self.coords_to_point(x, 0)\n",
        "            for x in (1, 2)\n",
        "        ])\n",
        "        line.set_color(YELLOW)\n",
        "        brace = Brace(line, DOWN)\n",
        "        words = brace.get_text(\"``Radius of convergence''\")\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait(3)\n",
        "\n",
        "class MoreToBeSaid(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Lagrange error bounds, \", \n",
        "            \"convergence tests, \",\n",
        "            \"$\\\\dots$\"\n",
        "        )\n",
        "        words[0].set_color(BLUE)\n",
        "        words[1].set_color(GREEN)\n",
        "        words.to_edge(UP)\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        rect = Rectangle(height = 9, width = 16)        \n",
        "        rect.set_height(FRAME_Y_RADIUS)\n",
        "        rect.to_corner(UP+RIGHT)\n",
        "        randy = self.get_students()[1]\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"There's still \\\\\\\\ more to learn!\",\n",
        "            target_mode = \"surprised\",\n",
        "            bubble_config = {\"height\" : 3, \"width\" : 4}\n",
        "        )\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word))\n",
        "            self.wait()\n",
        "        self.teacher_says(\n",
        "            \"About everything\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait()\n",
        "        self.remove()\n",
        "        self.pi_creatures = []##Hack\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher),\n",
        "            FadeOut(words),\n",
        "            FadeIn(fade_rect),\n",
        "            randy.change, \"happy\", rect\n",
        "        )\n",
        "        self.pi_creatures = [randy]\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(4)\n",
        "\n",
        "class Chapter10Thanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek Dai\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ahmad Bamieh\",\n",
        "            \"Mark Govea\",\n",
        "            \"Zac Wentzell\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(ExampleApproximationWithSine):\n",
        "    CONFIG = {\n",
        "        \"graph_origin\" : DOWN,\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_axis_width\" : 14,\n",
        "        \"graph_stroke_width\" : 8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "\n",
        "        cos_graph = self.get_graph(np.cos)\n",
        "        cos_graph.set_stroke(BLUE, self.graph_stroke_width)\n",
        "        quad_graph = self.get_graph(taylor_approximation(np.cos, 2))\n",
        "        quad_graph.set_stroke(GREEN, self.graph_stroke_width)\n",
        "        quartic = self.get_graph(taylor_approximation(np.cos, 4))\n",
        "        quartic.set_stroke(PINK, self.graph_stroke_width)\n",
        "        self.add(cos_graph, quad_graph, quartic)\n",
        "\n",
        "        title = OldTexText(\"Taylor Series\")\n",
        "        title.set_width(1.5*FRAME_X_RADIUS)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}