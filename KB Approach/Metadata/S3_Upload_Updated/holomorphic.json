{
    "topic": "The mathematical concept being demonstrated is the transformation of complex numbers under the function $z \\mapsto z",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class ComplexAnalysisOverlay(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Complex analysis\")\n",
        "        words.scale(1.25)\n",
        "        words.to_edge(UP)\n",
        "        words.add_background_rectangle()\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AnalyzeZSquared(ComplexTransformationScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"plane_config\": {\n",
        "            \"line_frequency\": 0.1,\n",
        "        },\n",
        "        \"num_anchors_to_add_per_line\": 20,\n",
        "        \"complex_homotopy\": lambda z, t: z**(1.0 + t),\n",
        "        \"zoom_factor\": 0.05,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        ComplexTransformationScene.setup(self)\n",
        "        ZoomedScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.edit_background_plane()\n",
        "        self.add_title()\n",
        "        # self.add_transforming_planes()\n",
        "        # self.preview_some_numbers()\n",
        "        self.zoom_in_to_one_plus_half_i()\n",
        "        self.write_derivative()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"z \\\\rightarrow z^2\")\n",
        "        title.add_background_rectangle()\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        self.add_foreground_mobject(title)\n",
        "\n",
        "    def edit_background_plane(self):\n",
        "        self.backgrounds.set_stroke(GREY, 2)\n",
        "        self.background.secondary_lines.set_stroke(GREY_D, 1)\n",
        "        self.add_foreground_mobject(self.background.coordinate_labels)\n",
        "\n",
        "    def add_transforming_planes(self):\n",
        "        self.plane = self.get_plane()\n",
        "        self.add_transformable_mobjects(self.plane)\n",
        "\n",
        "    def preview_some_numbers(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot().move_to(self.background.number_to_point(z))\n",
        "            for z in [\n",
        "                1, 2, complex(0, 1),\n",
        "                -1, complex(2, 0.5), complex(-1, -1), complex(3, 0.5),\n",
        "            ]\n",
        "        ])\n",
        "        dots.set_color_by_gradient(RED, YELLOW)\n",
        "        d_angle = 30 * DEGREES\n",
        "\n",
        "        dot_groups = VGroup()\n",
        "        for dot in dots:\n",
        "            point = dot.get_center()\n",
        "            z = self.background.point_to_number(point)\n",
        "            z_out = self.complex_homotopy(z, 1)\n",
        "            out_point = self.background.number_to_point(z_out)\n",
        "            path_arc = angle_of_vector(point)\n",
        "            if abs(z - 1) < 0.01:\n",
        "                # One is special\n",
        "                arrow = Arc(\n",
        "                    start_angle=(-90 * DEGREES + d_angle),\n",
        "                    angle=(360 * DEGREES - 2 * d_angle),\n",
        "                    radius=0.25\n",
        "                )\n",
        "                arrow.add_tip(tip_length=0.15)\n",
        "                arrow.pointwise_become_partial(arrow, 0, 0.9)\n",
        "                arrow.next_to(dot, UP, buff=0)\n",
        "            else:\n",
        "                arrow = Arrow(\n",
        "                    point, out_point,\n",
        "                    path_arc=path_arc,\n",
        "                    buff=SMALL_BUFF,\n",
        "                )\n",
        "            arrow.match_color(dot)\n",
        "\n",
        "            out_dot = dot.copy()\n",
        "            # out_dot.set_fill(opacity=0.5)\n",
        "            out_dot.set_stroke(BLUE, 1)\n",
        "            out_dot.move_to(out_point)\n",
        "            dot.path_arc = path_arc\n",
        "            dot.out_dot = out_dot\n",
        "\n",
        "            dot_group = VGroup(dot, arrow, out_dot)\n",
        "            dot_groups.add(dot_group)\n",
        "\n",
        "            dot_copy = dot.copy()\n",
        "            dot.save_state()\n",
        "            dot.scale(3)\n",
        "            dot.fade(1)\n",
        "\n",
        "            dot_group.anim = Succession(\n",
        "                ApplyMethod(dot.restore),\n",
        "                AnimationGroup(\n",
        "                    ShowCreation(arrow),\n",
        "                    ReplacementTransform(\n",
        "                        dot_copy, out_dot,\n",
        "                        path_arc=path_arc\n",
        "                    )\n",
        "                )\n",
        "            )\n",
        "\n",
        "        for dot_group in dot_groups[:3]:\n",
        "            self.play(dot_group.anim)\n",
        "            self.wait()\n",
        "        self.play(*[dg.anim for dg in dot_groups[3:]])\n",
        "\n",
        "        self.apply_complex_homotopy(\n",
        "            self.complex_homotopy,\n",
        "            added_anims=[Animation(dot_groups)]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(dot_groups))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.plane))\n",
        "        self.transformable_mobjects.remove(self.plane)\n",
        "\n",
        "    def zoom_in_to_one_plus_half_i(self):\n",
        "        z = complex(1, 0.5)\n",
        "        point = self.background.number_to_point(z)\n",
        "        point_mob = VectorizedPoint(point)\n",
        "        frame = self.zoomed_camera.frame\n",
        "        frame.move_to(point)\n",
        "        tiny_plane = NumberPlane(\n",
        "            x_radius=2, y_radius=2,\n",
        "            color=GREEN,\n",
        "            secondary_color=GREEN_E\n",
        "        )\n",
        "        tiny_plane.replace(frame)\n",
        "\n",
        "        plane = self.get_plane()\n",
        "\n",
        "        words = OldTexText(\"What does this look like\")\n",
        "        words.add_background_rectangle()\n",
        "        words.next_to(self.zoomed_display, LEFT, aligned_edge=UP)\n",
        "        arrow = Arrow(words.get_bottom(), self.zoomed_display.get_left())\n",
        "        VGroup(words, arrow).set_color(YELLOW)\n",
        "\n",
        "        self.play(FadeIn(plane))\n",
        "        self.activate_zooming(animate=True)\n",
        "        self.play(ShowCreation(tiny_plane))\n",
        "        self.wait()\n",
        "        self.add_transformable_mobjects(plane, tiny_plane, point_mob)\n",
        "        self.add_foreground_mobjects(words, arrow)\n",
        "        self.apply_complex_homotopy(\n",
        "            self.complex_homotopy,\n",
        "            added_anims=[\n",
        "                Write(words),\n",
        "                GrowArrow(arrow),\n",
        "                MaintainPositionRelativeTo(frame, point_mob)\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def write_derivative(self):\n",
        "        pass\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_plane(self):\n",
        "        top_plane = NumberPlane(\n",
        "            y_radius=FRAME_HEIGHT / 2,\n",
        "            x_line_frequency=0.1,\n",
        "            y_line_frequency=0.1,\n",
        "        )\n",
        "        self.prepare_for_transformation(top_plane)\n",
        "        bottom_plane = top_plane.copy()\n",
        "        tiny_tiny_buff = 0.001\n",
        "        top_plane.next_to(ORIGIN, UP, buff=tiny_tiny_buff)\n",
        "        bottom_plane.next_to(ORIGIN, DOWN, buff=tiny_tiny_buff)\n",
        "        return VGroup(top_plane, bottom_plane)\n"
    ]
}