{
    "topic": "The mathematical concept being demonstrated is the transformation of a sine wave using the complex exponential function.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from _2018.lost_lecture import Orbiting\n",
        "from _2018.lost_lecture import ShowWord\n",
        "\n",
        "\n",
        "class LogoGeneration(LogoGenerationTemplate):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def get_logo_animations(self, logo):\n",
        "        layers = logo.spike_layers\n",
        "        for layer in layers:\n",
        "            random.shuffle(layer.submobjects)\n",
        "            for spike in layer:\n",
        "                spike.save_state()\n",
        "                spike.scale(0.5)\n",
        "                spike.apply_complex_function(np.log)\n",
        "                spike.rotate(-90 * DEGREES, about_point=ORIGIN)\n",
        "                spike.set_fill(opacity=0)\n",
        "\n",
        "        return [\n",
        "            FadeIn(\n",
        "                logo.iris_background,\n",
        "                rate_func=squish_rate_func(smooth, 0.25, 1),\n",
        "                run_time=3,\n",
        "            ),\n",
        "            AnimationGroup(*[\n",
        "                LaggedStartMap(\n",
        "                    Restore, layer,\n",
        "                    run_time=3,\n",
        "                    path_arc=180 * DEGREES,\n",
        "                    rate_func=squish_rate_func(smooth, a / 3.0, (a + 0.9) / 3.0),\n",
        "                    lag_ratio=0.8,\n",
        "                )\n",
        "                for layer, a in zip(layers, [0, 2, 1, 0])\n",
        "            ]),\n",
        "            Animation(logo.pupil),\n",
        "        ]\n",
        "\n",
        "\n",
        "class ThinkingAboutAProof(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.scale(0.5, about_edge=DL)\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.shift(MED_SMALL_BUFF * RIGHT)\n",
        "        cloud = bubble[-1]\n",
        "        cloud.rotate(90 * DEGREES)\n",
        "        cloud.set_height(FRAME_HEIGHT - 0.5)\n",
        "        cloud.stretch(2.8, 0)\n",
        "        cloud.next_to(bubble[2], RIGHT)\n",
        "        cloud.to_edge(UP, buff=0.25)\n",
        "        bubble[1].shift(0.25 * UL)\n",
        "\n",
        "        you_arrow = Vector(LEFT, color=WHITE)\n",
        "        you_arrow.next_to(randy, RIGHT)\n",
        "        you = OldTexText(\"You\")\n",
        "        you.next_to(you_arrow, RIGHT)\n",
        "        lm_arrow = Vector(DOWN, color=WHITE)\n",
        "        lm_arrow.next_to(randy, UP)\n",
        "        love_math = OldTexText(\"Love math\")\n",
        "        love_math.next_to(lm_arrow, UP)\n",
        "        love_math.shift_onto_screen()\n",
        "\n",
        "        self.add(bubble)\n",
        "        self.play(\n",
        "            FadeIn(you, LEFT),\n",
        "            GrowArrow(you_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(love_math),\n",
        "            GrowArrow(lm_arrow),\n",
        "            randy.change, \"erm\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\", cloud\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SumOfIntegersProof(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\": 6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"1\", \"+\", \"2\", \"+\", \"3\", \"+\",\n",
        "            \"\\\\cdots\", \"+\", \"n\",\n",
        "            \"=\", \"\\\\frac{n(n+1)}{2}\"\n",
        "        )\n",
        "        equation.scale(1.5)\n",
        "        equation.to_edge(UP)\n",
        "        one, two, three, dots, n = numbers = VGroup(*[\n",
        "            equation.get_part_by_tex(tex, substring=False).copy()\n",
        "            for tex in (\"1\", \"2\", \"3\", \"\\\\cdots\", \"n\",)\n",
        "        ])\n",
        "        for number in numbers:\n",
        "            number.generate_target()\n",
        "            number.target.scale(0.75)\n",
        "\n",
        "        rows = self.get_rows()\n",
        "        rows.next_to(equation, DOWN, buff=MED_LARGE_BUFF)\n",
        "        flipped_rows = self.get_flipped_rows(rows)\n",
        "\n",
        "        for row, num in zip(rows, [one, two, three]):\n",
        "            num.target.next_to(row, LEFT)\n",
        "        dots.target.rotate(90 * DEGREES)\n",
        "        dots.target.next_to(rows[3:-1], LEFT)\n",
        "        dots.target.align_to(one.target, LEFT)\n",
        "        n.target.next_to(rows[-1], LEFT)\n",
        "\n",
        "        for row in rows:\n",
        "            row.save_state()\n",
        "            for square in row:\n",
        "                square.stretch(0, 0)\n",
        "                square.move_to(row, LEFT)\n",
        "            row.fade(1)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, equation[:-1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, numbers,\n",
        "                path_arc=-90 * DEGREES,\n",
        "                lag_ratio=1,\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        self.play(LaggedStartMap(Restore, rows))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                rows.copy().set_fill(opacity=0), flipped_rows,\n",
        "                path_arc=-PI,\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(equation[-1]))\n",
        "        self.wait(5)\n",
        "\n",
        "    def get_rows(self):\n",
        "        rows = VGroup()\n",
        "        for count in range(1, self.n + 1):\n",
        "            row = VGroup(*[Square() for k in range(count)])\n",
        "            row.arrange(RIGHT, buff=0)\n",
        "            rows.add(row)\n",
        "        rows.arrange(DOWN, buff=0, aligned_edge=LEFT)\n",
        "        rows.set_height(5)\n",
        "        rows.set_stroke(WHITE, 3)\n",
        "        rows.set_fill(BLUE, 0.5)\n",
        "        return rows\n",
        "\n",
        "    def get_flipped_rows(self, rows):\n",
        "        result = rows.copy()\n",
        "        result.rotate(PI)\n",
        "        result.set_fill(RED_D, 0.5)\n",
        "        result.move_to(rows, LEFT)\n",
        "        result.shift(rows[0][0].get_width() * RIGHT)\n",
        "        return result\n",
        "\n",
        "\n",
        "class FeynmansLostLectureWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Feynman's Lost Lecture\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HoldUpProof(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"One of my all-time favorite proofs\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\", self.screen,\n",
        "            self.change_students(\n",
        "                \"pondering\", \"confused\", \"maybe\",\n",
        "                look_at=title\n",
        "            )\n",
        "        )\n",
        "        self.look_at(title)\n",
        "        self.wait(5)\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"thinking\", \"hooray\",\n",
        "            look_at=title\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class MultipleDefinitionsOfAnEllipse(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\"Multiple definitions of ``ellipse''\")\n",
        "        self.add(title)\n",
        "\n",
        "        definitions = VGroup(\n",
        "            OldTexText(\"1. Stretch a circle\"),\n",
        "            OldTexText(\"2. Thumbtack \\\\\\\\ \\\\quad\\\\, construction\"),\n",
        "            OldTexText(\"3. Slice a cone\"),\n",
        "        )\n",
        "        definitions.arrange(\n",
        "            DOWN, buff=LARGE_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        definitions.next_to(title, DOWN, LARGE_BUFF)\n",
        "        definitions.to_edge(LEFT)\n",
        "\n",
        "        for definition in definitions:\n",
        "            definition.saved_state = definition.copy()\n",
        "            definition.saved_state.set_fill(GREY_B, 0.5)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, definitions,\n",
        "            lambda m: (m, RIGHT),\n",
        "            run_time=4\n",
        "        ))\n",
        "        self.wait()\n",
        "        for definition in definitions:\n",
        "            others = [d for d in definitions if d is not definition]\n",
        "            self.play(\n",
        "                definition.set_fill, WHITE, 1,\n",
        "                definition.scale, 1.2, {\"about_edge\": LEFT},\n",
        "                *list(map(Restore, others))\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class StretchACircle(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane(\n",
        "            x_unit_size=2,\n",
        "            y_unit_size=2\n",
        "        )\n",
        "\n",
        "        circle = Circle(radius=2)\n",
        "        circle.set_stroke(YELLOW, 5)\n",
        "        circle_ghost = circle.copy()\n",
        "        circle_ghost.set_stroke(width=1)\n",
        "\n",
        "        plane_circle_group = VGroup(plane, circle)\n",
        "        plane_circle_group.save_state()\n",
        "\n",
        "        arrows = self.get_arrows()\n",
        "\n",
        "        prop = 1.0 / 8\n",
        "        start_point = Dot(circle.point_from_proportion(prop))\n",
        "        end_point = start_point.copy().stretch(2, 0, about_point=ORIGIN)\n",
        "        end_point.stretch(0.5, 0)\n",
        "        end_point.set_color(RED)\n",
        "\n",
        "        xy = OldTex(\"(x, y)\")\n",
        "        cxy = OldTex(\"(c \\\\cdot x, y)\")\n",
        "        cxy[1].set_color(RED)\n",
        "        for tex in xy, cxy:\n",
        "            tex.scale(1.5)\n",
        "            tex.add_background_rectangle()\n",
        "\n",
        "        xy_arrow = Vector(DOWN, color=WHITE)\n",
        "        cxy_arrow = Vector(DL, color=WHITE)\n",
        "        xy_arrow.next_to(start_point, UP, SMALL_BUFF)\n",
        "        xy.next_to(xy_arrow, UP, SMALL_BUFF)\n",
        "        cxy_arrow.next_to(end_point, UR, SMALL_BUFF)\n",
        "        cxy.next_to(cxy_arrow, UR, SMALL_BUFF)\n",
        "\n",
        "        self.add(plane_circle_group)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                plane_circle_group.stretch, 2, 0,\n",
        "                run_time=2,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                GrowArrow, arrows,\n",
        "                run_time=1,\n",
        "                lag_ratio=1\n",
        "            ),\n",
        "        )\n",
        "        self.play(FadeOut(arrows))\n",
        "        self.wait()\n",
        "        self.play(Restore(plane_circle_group))\n",
        "        self.play(\n",
        "            GrowArrow(xy_arrow),\n",
        "            Write(xy),\n",
        "            FadeIn(start_point, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(circle_ghost)\n",
        "        self.play(\n",
        "            circle.stretch, 2, 0,\n",
        "            ReplacementTransform(start_point.copy(), end_point),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(cxy_arrow),\n",
        "            Write(cxy)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_arrows(self):\n",
        "        result = VGroup()\n",
        "        for vect in [LEFT, RIGHT]:\n",
        "            for y in range(-3, 4):\n",
        "                arrow = Vector(vect)\n",
        "                arrow.move_to(2 * vect + y * UP)\n",
        "                result.add(arrow)\n",
        "        result.set_color(RED)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShowArrayOfEccentricities(Scene):\n",
        "    def construct(self):\n",
        "        eccentricities = np.linspace(0, 0.99, 6)\n",
        "        eccentricity_labels = VGroup(*list(map(\n",
        "            DecimalNumber, eccentricities\n",
        "        )))\n",
        "        ellipses = self.get_ellipse_row(eccentricities)\n",
        "        ellipses.set_color_by_gradient(BLUE, YELLOW)\n",
        "        ellipses.move_to(DOWN)\n",
        "\n",
        "        for label, ellipse in zip(eccentricity_labels, ellipses):\n",
        "            label.next_to(ellipse, UP)\n",
        "\n",
        "        name = OldTexText(\"Eccentricity\")\n",
        "        name.scale(1.5)\n",
        "        name.to_edge(UP)\n",
        "        alt_name = OldTexText(\"(read ``squishification'')\")\n",
        "        alt_name.set_color(YELLOW)\n",
        "        alt_name.next_to(name, RIGHT)\n",
        "        alt_name.shift_onto_screen()\n",
        "        name.generate_target()\n",
        "        name.target.next_to(alt_name, LEFT)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(name.get_bottom(), label.get_top())\n",
        "            for label in eccentricity_labels\n",
        "        ])\n",
        "        arrows.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        for label, arrow in zip(eccentricity_labels, arrows):\n",
        "            label.save_state()\n",
        "            label.fade(1)\n",
        "            label.scale(0.1)\n",
        "            label.move_to(arrow.get_start())\n",
        "\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.next_to(alt_name, DOWN)\n",
        "\n",
        "        self.add(ellipses[0])\n",
        "        for e1, e2 in zip(ellipses[:-1], ellipses[1:]):\n",
        "            self.play(ReplacementTransform(\n",
        "                e1.copy(), e2,\n",
        "                path_arc=10 * DEGREES\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(name),\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "            LaggedStartMap(Restore, eccentricity_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(alt_name),\n",
        "            MoveToTarget(name),\n",
        "            morty.change, \"hooray\", alt_name,\n",
        "            VFadeIn(morty),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"thinking\", ellipses)\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        for i in 0, -1:\n",
        "            e_copy = ellipses[i].copy()\n",
        "            e_copy.set_color(RED)\n",
        "            self.play(ShowCreation(e_copy))\n",
        "            self.play(\n",
        "                ShowCreationThenFadeAround(\n",
        "                    eccentricity_labels[i],\n",
        "                ),\n",
        "                FadeOut(e_copy)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        circle = ellipses[0]\n",
        "        group = VGroup(*it.chain(\n",
        "            eccentricity_labels,\n",
        "            ellipses[1:],\n",
        "            arrows,\n",
        "            name,\n",
        "            alt_name,\n",
        "            [morty]\n",
        "        ))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOutAndShiftDown, group),\n",
        "            circle.set_height, 5,\n",
        "            circle.center,\n",
        "        )\n",
        "\n",
        "    def get_ellipse(self, eccentricity, width=2):\n",
        "        result = Circle(color=WHITE)\n",
        "        result.set_width(width)\n",
        "        a = width / 2.0\n",
        "        c = eccentricity * a\n",
        "        b = np.sqrt(a**2 - c**2)\n",
        "        result.stretch(b / a, 1)\n",
        "        result.shift(c * LEFT)\n",
        "\n",
        "        result.eccentricity = eccentricity\n",
        "        return result\n",
        "\n",
        "    def get_ellipse_row(self, eccentricities, buff=MED_SMALL_BUFF, **kwargs):\n",
        "        result = VGroup(*[\n",
        "            self.get_ellipse(e, **kwargs)\n",
        "            for e in eccentricities\n",
        "        ])\n",
        "        result.arrange(RIGHT, buff=buff)\n",
        "        return result\n",
        "\n",
        "    def get_eccentricity(self, ellipse):\n",
        "        \"\"\"\n",
        "        Assumes that it's major/minor axes line up\n",
        "        with x and y axes\n",
        "        \"\"\"\n",
        "        a = ellipse.get_width()\n",
        "        b = ellipse.get_height()\n",
        "        if b > a:\n",
        "            a, b = b, a\n",
        "        c = np.sqrt(a**2 - b**2)\n",
        "        return fdiv(c, a)\n",
        "\n",
        "\n",
        "class ShowOrbits(ShowArrayOfEccentricities):\n",
        "    CONFIG = {\"camera_config\": {\"background_opacity\": 1}}\n",
        "\n",
        "    def construct(self):\n",
        "        earth_eccentricity = 0.0167\n",
        "        comet_eccentricity = 0.9671\n",
        "        earth_orbit = self.get_ellipse(eccentricity=earth_eccentricity)\n",
        "        comet_orbit = self.get_ellipse(eccentricity=comet_eccentricity)\n",
        "        earth_orbit.set_height(5)\n",
        "        comet_orbit.set_width(\n",
        "            0.7 * FRAME_WIDTH,\n",
        "            about_point=ORIGIN,\n",
        "        )\n",
        "\n",
        "        sun = ImageMobject(\"Sun\")\n",
        "        earth = ImageMobject(\"Earth\")\n",
        "        comet = ImageMobject(\"Comet\")\n",
        "        sun.set_height(1)\n",
        "        earth.set_height(0.5)\n",
        "        comet.set_height(0.1)\n",
        "\n",
        "        earth_parts = VGroup(sun, earth_orbit, earth)\n",
        "\n",
        "        eccentricity_label = DecimalNumber(\n",
        "            earth_eccentricity,\n",
        "            num_decimal_places=4\n",
        "        )\n",
        "        eccentricity_equals = OldTexText(\n",
        "            \"Eccentricity = \"\n",
        "        )\n",
        "        earth_orbit_words = OldTexText(\"Earth's orbit\")\n",
        "        earth_orbit_words.set_color(BLUE)\n",
        "        full_label = VGroup(\n",
        "            earth_orbit_words,\n",
        "            eccentricity_equals, eccentricity_label\n",
        "        )\n",
        "        full_label.arrange(RIGHT, SMALL_BUFF)\n",
        "        earth_orbit_words.shift(0.5 * SMALL_BUFF * UL)\n",
        "        full_label.to_edge(UP)\n",
        "\n",
        "        comet_orbit_words = OldTexText(\"Halley's comet orbit\")\n",
        "        comet_orbit_words.set_color(GREY_B)\n",
        "        comet_orbit_words.move_to(earth_orbit_words, RIGHT)\n",
        "\n",
        "        orbiting_earth = Orbiting(earth, sun, earth_orbit)\n",
        "        orbiting_comet = Orbiting(comet, sun, comet_orbit)\n",
        "\n",
        "        self.add(full_label, earth_orbit_words)\n",
        "        self.add(sun, earth_orbit, orbiting_earth)\n",
        "        self.wait(10)\n",
        "        orbiting_earth.rate = 1.5\n",
        "        orbiting_comet.rate = 1.5\n",
        "        self.play(\n",
        "            earth_parts.set_height,\n",
        "            comet_orbit.get_height() / 4.53,\n",
        "            earth_parts.shift, 3 * RIGHT\n",
        "        )\n",
        "        comet_orbit.shift(3 * RIGHT)\n",
        "        comet_orbit.save_state()\n",
        "        Transform(comet_orbit, earth_orbit).update(1)\n",
        "        self.play(\n",
        "            Restore(comet_orbit, run_time=2),\n",
        "            ChangingDecimal(\n",
        "                eccentricity_label,\n",
        "                lambda a: self.get_eccentricity(comet_orbit)\n",
        "            ),\n",
        "            FadeOut(earth_orbit_words, UP),\n",
        "            FadeInFromDown(comet_orbit_words)\n",
        "        )\n",
        "        self.add(orbiting_comet)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class EccentricityInThumbtackCase(ShowArrayOfEccentricities):\n",
        "    def construct(self):\n",
        "        ellipse = self.get_ellipse(0.2, width=5)\n",
        "        ellipse_target = self.get_ellipse(0.9, width=5)\n",
        "        ellipse_target.scale(fdiv(\n",
        "            sum(self.get_abc(ellipse)),\n",
        "            sum(self.get_abc(ellipse_target)),\n",
        "        ))\n",
        "        for mob in ellipse, ellipse_target:\n",
        "            mob.center()\n",
        "            mob.set_color(BLUE)\n",
        "        thumbtack_update = self.get_thumbtack_update(ellipse)\n",
        "        ellipse_point_update = self.get_ellipse_point_update(ellipse)\n",
        "        focal_lines_update = self.get_focal_lines_update(\n",
        "            ellipse, ellipse_point_update.mobject\n",
        "        )\n",
        "        focus_to_focus_line_update = self.get_focus_to_focus_line_update(ellipse)\n",
        "        eccentricity_label = self.get_eccentricity_label()\n",
        "        eccentricity_value_update = self.get_eccentricity_value_update(\n",
        "            eccentricity_label, ellipse,\n",
        "        )\n",
        "        inner_brace_update = self.get_focus_line_to_focus_line_brace_update(\n",
        "            focus_to_focus_line_update.mobject\n",
        "        )\n",
        "        outer_lines = self.get_outer_dashed_lines(ellipse)\n",
        "        outer_lines_brace = Brace(outer_lines, DOWN)\n",
        "\n",
        "        focus_distance = OldTexText(\"Focus distance\")\n",
        "        focus_distance.set_color(GREEN)\n",
        "        focus_distance.next_to(inner_brace_update.mobject, DOWN, SMALL_BUFF)\n",
        "        focus_distance.add_to_back(focus_distance.copy().set_stroke(BLACK, 5))\n",
        "        focus_distance_update = Mobject.add_updater(\n",
        "            focus_distance,\n",
        "            lambda m: m.set_width(\n",
        "                inner_brace_update.mobject.get_width(),\n",
        "            ).next_to(inner_brace_update.mobject, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "        diameter = OldTexText(\"Diameter\")\n",
        "        diameter.set_color(RED)\n",
        "        diameter.next_to(outer_lines_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        fraction = OldTex(\n",
        "            \"{\\\\text{Focus distance}\", \"\\\\over\",\n",
        "            \"\\\\text{Diameter}}\"\n",
        "        )\n",
        "        numerator = fraction.get_part_by_tex(\"Focus\")\n",
        "        numerator.set_color(GREEN)\n",
        "        fraction.set_color_by_tex(\"Diameter\", RED)\n",
        "        fraction.move_to(2 * UP)\n",
        "        fraction.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        numerator_update = Mobject.add_updater(\n",
        "            numerator,\n",
        "            lambda m: m.set_width(focus_distance.get_width()).next_to(\n",
        "                fraction[1], UP, MED_SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "        fraction_arrow = Arrow(\n",
        "            eccentricity_label.get_right(),\n",
        "            fraction.get_top() + MED_SMALL_BUFF * UP,\n",
        "            path_arc=-60 * DEGREES,\n",
        "        )\n",
        "        fraction_arrow.pointwise_become_partial(fraction_arrow, 0, 0.95)\n",
        "\n",
        "        ellipse_transformation = Transform(\n",
        "            ellipse, ellipse_target,\n",
        "            rate_func=there_and_back,\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "        self.add(ellipse)\n",
        "        self.add(thumbtack_update)\n",
        "        self.add(ellipse_point_update)\n",
        "        self.add(focal_lines_update)\n",
        "        self.add(focus_to_focus_line_update)\n",
        "        self.add(eccentricity_label)\n",
        "        self.add(eccentricity_value_update)\n",
        "\n",
        "        self.play(ellipse_transformation)\n",
        "\n",
        "        self.add(inner_brace_update)\n",
        "        self.add(outer_lines)\n",
        "        self.add(outer_lines_brace)\n",
        "\n",
        "        self.add(fraction)\n",
        "        self.add(fraction_arrow)\n",
        "        self.add(focus_distance)\n",
        "        self.add(diameter)\n",
        "\n",
        "        self.add(focus_distance_update)\n",
        "        self.add(numerator_update)\n",
        "\n",
        "        self.play(\n",
        "            ellipse_transformation,\n",
        "            VFadeIn(inner_brace_update.mobject),\n",
        "            VFadeIn(outer_lines),\n",
        "            VFadeIn(outer_lines_brace),\n",
        "            VFadeIn(fraction),\n",
        "            VFadeIn(fraction_arrow),\n",
        "            VFadeIn(focus_distance),\n",
        "            VFadeIn(diameter),\n",
        "        )\n",
        "\n",
        "    def get_thumbtack_update(self, ellipse):\n",
        "        thumbtacks = VGroup(*[\n",
        "            self.get_thumbtack()\n",
        "            for x in range(2)\n",
        "        ])\n",
        "\n",
        "        def update_thumbtacks(thumbtacks):\n",
        "            foci = self.get_foci(ellipse)\n",
        "            for thumbtack, focus in zip(thumbtacks, foci):\n",
        "                thumbtack.move_to(focus, DR)\n",
        "            return thumbtacks\n",
        "\n",
        "        return Mobject.add_updater(thumbtacks, update_thumbtacks)\n",
        "\n",
        "    def get_ellipse_point_update(self, ellipse):\n",
        "        dot = Dot(color=RED)\n",
        "        return cycle_animation(MoveAlongPath(\n",
        "            dot, ellipse,\n",
        "            run_time=5,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "\n",
        "    def get_focal_lines_update(self, ellipse, ellipse_point):\n",
        "        lines = VGroup(*[Line(LEFT, RIGHT) for x in range(2)])\n",
        "        lines.set_color_by_gradient(YELLOW, PINK)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            foci = self.get_foci(ellipse)\n",
        "            Q = ellipse_point.get_center()\n",
        "            for line, focus in zip(lines, foci):\n",
        "                line.put_start_and_end_on(focus, Q)\n",
        "            return lines\n",
        "\n",
        "        return Mobject.add_updater(lines, update_lines)\n",
        "\n",
        "    def get_focus_to_focus_line_update(self, ellipse):\n",
        "        return Mobject.add_updater(\n",
        "            Line(LEFT, RIGHT, color=WHITE),\n",
        "            lambda m: m.put_start_and_end_on(*self.get_foci(ellipse))\n",
        "        )\n",
        "\n",
        "    def get_focus_line_to_focus_line_brace_update(self, line):\n",
        "        brace = Brace(Line(LEFT, RIGHT))\n",
        "        brace.add_to_back(brace.copy().set_stroke(BLACK, 5))\n",
        "        return Mobject.add_updater(\n",
        "            brace,\n",
        "            lambda b: b.match_width(line, stretch=True).next_to(\n",
        "                line, DOWN, buff=SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def get_eccentricity_label(self):\n",
        "        words = OldTexText(\"Eccentricity = \")\n",
        "        decimal = DecimalNumber(0, num_decimal_places=2)\n",
        "        group = VGroup(words, decimal)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP)\n",
        "        return group\n",
        "\n",
        "    def get_eccentricity_value_update(self, eccentricity_label, ellipse):\n",
        "        decimal = eccentricity_label[1]\n",
        "        decimal.add_updater(lambda d: d.set_value(\n",
        "            self.get_eccentricity(ellipse)\n",
        "        ))\n",
        "        return decimal\n",
        "\n",
        "    def get_outer_dashed_lines(self, ellipse):\n",
        "        line = DashedLine(2.5 * UP, 2.5 * DOWN)\n",
        "        return VGroup(\n",
        "            line.move_to(ellipse, RIGHT),\n",
        "            line.copy().move_to(ellipse, LEFT),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_abc(self, ellipse):\n",
        "        a = ellipse.get_width() / 2\n",
        "        b = ellipse.get_height() / 2\n",
        "        c = np.sqrt(a**2 - b**2)\n",
        "        return a, b, c\n",
        "\n",
        "    def get_foci(self, ellipse):\n",
        "        a, b, c = self.get_abc(ellipse)\n",
        "        return [\n",
        "            ellipse.get_center() + c * RIGHT,\n",
        "            ellipse.get_center() + c * LEFT,\n",
        "        ]\n",
        "\n",
        "    def get_thumbtack(self):\n",
        "        angle = 10 * DEGREES\n",
        "        result = SVGMobject(file_name=\"push_pin\")\n",
        "        result.set_height(0.5)\n",
        "        result.set_fill(GREY_B)\n",
        "        result.rotate(angle)\n",
        "        return result\n",
        "\n",
        "\n",
        "class EccentricityForSlicedConed(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{Eccentricity} = \",\n",
        "            \"{\\\\sin(\", \"\\\\text{angle of plane}\", \")\", \"\\\\over\",\n",
        "            \"\\\\sin(\", \"\\\\text{angle of cone slant}\", \")}\"\n",
        "        )\n",
        "        equation.set_color_by_tex(\"plane\", YELLOW)\n",
        "        equation.set_color_by_tex(\"cone\", BLUE)\n",
        "        equation.to_edge(LEFT)\n",
        "        self.play(FadeInFromDown(equation))\n",
        "\n",
        "\n",
        "class AskWhyAreTheyTheSame(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        self.student_says(\n",
        "            \"Why on earth \\\\\\\\ are these the same?\",\n",
        "            index=2,\n",
        "            target_mode=\"sassy\",\n",
        "            bubble_config={\"direction\": LEFT}\n",
        "        )\n",
        "        bubble = self.students[2].bubble\n",
        "        self.play(\n",
        "            morty.change, \"awe\",\n",
        "            self.change_students(\"confused\", \"confused\", \"sassy\")\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "        self.play(morty.change, \"thinking\", self.screen)\n",
        "        self.play_student_changes(\"maybe\", \"erm\", \"confused\")\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "        baby_morty = BabyPiCreature()\n",
        "        baby_morty.match_style(morty)\n",
        "        baby_morty.to_corner(DL)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShift, self.students,\n",
        "                lambda m: (m, 3 * DOWN),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                morty, baby_morty,\n",
        "                path_arc=30 * DEGREES,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.pi_creatures = VGroup(baby_morty)\n",
        "        bubble = ThoughtBubble(height=6, width=7)\n",
        "        bubble.set_fill(GREY_D, 0.5)\n",
        "        bubble.pin_to(baby_morty)\n",
        "\n",
        "        egg = Circle(radius=0.4)\n",
        "        egg.stretch(0.75, 1)\n",
        "        egg.move_to(RIGHT)\n",
        "        egg.apply_function(\n",
        "            lambda p: np.array([\n",
        "                p[0], p[0] * p[1], p[2]\n",
        "            ])\n",
        "        )\n",
        "        egg.flip()\n",
        "        egg.set_width(3)\n",
        "        egg.set_stroke(RED, 5)\n",
        "        egg.move_to(bubble.get_bubble_center())\n",
        "\n",
        "        self.play(baby_morty.change, \"confused\", 2 * DOWN)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            baby_morty.change, \"thinking\",\n",
        "            LaggedStartMap(DrawBorderThenFill, bubble)\n",
        "        )\n",
        "        self.play(ShowCreation(egg))\n",
        "        self.wait(3)\n",
        "\n",
        "        bubble_group = VGroup(bubble, egg)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                bubble_group.shift, FRAME_WIDTH * LEFT,\n",
        "                rate_func=running_start,\n",
        "            ),\n",
        "            baby_morty.change, \"awe\"\n",
        "        )\n",
        "        self.play(Blink(baby_morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TriangleOfEquivalences(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\"How do you prove this\\\\textinterrobang.\")\n",
        "        self.add(title)\n",
        "        rects = VGroup(*[ScreenRectangle() for x in range(3)])\n",
        "        rects.set_height(2)\n",
        "        rects[:2].arrange(RIGHT, buff=2)\n",
        "        rects[2].next_to(rects[:2], DOWN, buff=1.5)\n",
        "        rects.next_to(title, DOWN)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            OldTex(\"\\\\Leftrightarrow\")\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        arrows.scale(2)\n",
        "        arrows[0].move_to(rects[:2])\n",
        "        arrows[1].rotate(60 * DEGREES)\n",
        "        arrows[1].move_to(rects[1:])\n",
        "        arrows[2].rotate(-60 * DEGREES)\n",
        "        arrows[2].move_to(rects[::2])\n",
        "        arrows[1:].shift(0.5 * DOWN)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, arrows,\n",
        "            lag_ratio=0.7,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrows[1:]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SliceCone(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TiltPlane(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class IntroduceConeEllipseFocalSum(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowMeasurementBook(TeacherStudentsScene):\n",
        "    CONFIG = {\"camera_config\": {\"background_opacity\": 1}}\n",
        "\n",
        "    def construct(self):\n",
        "        measurement = ImageMobject(\"MeasurementCover\")\n",
        "        measurement.set_height(3.5)\n",
        "        measurement.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        words = OldTexText(\"Highly recommended\")\n",
        "        arrow = Vector(RIGHT, color=WHITE)\n",
        "        arrow.next_to(measurement, LEFT)\n",
        "        words.next_to(arrow, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(measurement)\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(words, RIGHT),\n",
        "            self.change_students(\n",
        "                \"thinking\", \"happy\", \"pondering\",\n",
        "                look_at=arrow\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class IntroduceSpheres(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TangencyAnimation(Scene):\n",
        "    def construct(self):\n",
        "        rings = VGroup(*[\n",
        "            Circle(color=YELLOW, stroke_width=3, radius=0.5)\n",
        "            for x in range(5)\n",
        "        ])\n",
        "        for ring in rings:\n",
        "            ring.save_state()\n",
        "            ring.scale(0)\n",
        "            ring.saved_state.set_stroke(width=0)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            Restore, rings,\n",
        "            run_time=2,\n",
        "            lag_ratio=0.7\n",
        "        ))\n",
        "\n",
        "\n",
        "class TwoSpheresRotating(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TiltSlopeWithOnlySpheres(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TiltSlopeWithOnlySpheresSideView(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AskAboutWhyYouWouldAddSpheres(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.flip()\n",
        "        randy.set_height(2)\n",
        "        randy.set_color(BLUE_C)\n",
        "        randy.to_edge(RIGHT)\n",
        "        randy.shift(2 * UP)\n",
        "        randy.look(UP)\n",
        "\n",
        "        graph_spot = VectorizedPoint()\n",
        "\n",
        "        why = OldTexText(\"...why?\")\n",
        "        why.next_to(randy, UP)\n",
        "\n",
        "        bubble = ThoughtBubble(height=2, width=2)\n",
        "        bubble.pin_to(randy)\n",
        "\n",
        "        self.play(FadeInFromDown(randy))\n",
        "        self.play(\n",
        "            Animation(graph_spot),\n",
        "            randy.change, \"maybe\",\n",
        "            Write(why),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.play(\n",
        "            why.to_corner, DR,\n",
        "            why.set_fill, GREY_B, 0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            randy.change, \"thinking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(graph_spot)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ShowTangencyPoints(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowFocalLinesAsTangent(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class UseDefiningFeatures(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Problem-solving tip:\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        tip = OldTexText(\n",
        "            \"\"\"\n",
        "            - Make sure you're using all the \\\\\\\\\n",
        "            \\\\phantom{-} defining features of the objects \\\\\\\\\n",
        "            \\\\phantom{-} involved.\n",
        "            \"\"\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        tip.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        tip.shift(MED_SMALL_BUFF * RIGHT)\n",
        "        tip.set_color(YELLOW)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(Write(tip, run_time=4))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RemindAboutTangencyToCone(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowCircleToCircleLine(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowSegmentSplit(Scene):\n",
        "    CONFIG = {\n",
        "        \"include_image\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        if self.include_image:\n",
        "            image = ImageMobject(\"ShowCircleToCircleLine\")\n",
        "            image.set_height(FRAME_HEIGHT)\n",
        "            self.add(image)\n",
        "\n",
        "        brace1 = Brace(Line(ORIGIN, 1.05 * UP), LEFT)\n",
        "        brace2 = Brace(Line(1.7 * DOWN, ORIGIN), LEFT)\n",
        "        braces = VGroup(brace1, brace2)\n",
        "        braces.rotate(-14 * DEGREES)\n",
        "        braces.move_to(0.85 * UP + 1.7 * LEFT)\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Top segment\"),\n",
        "            OldTexText(\"Bottom segment\")\n",
        "        )\n",
        "        for word, brace in zip(words, braces):\n",
        "            word.next_to(\n",
        "                brace.get_center(), LEFT,\n",
        "                buff=0.35\n",
        "            )\n",
        "        words[0].set_color(PINK)\n",
        "        words[1].set_color(GOLD)\n",
        "\n",
        "        for mob in it.chain(braces, words):\n",
        "            mob.add_to_back(mob.copy().set_stroke(BLACK, 5))\n",
        "\n",
        "        for brace in braces:\n",
        "            brace.save_state()\n",
        "            brace.set_stroke(width=0)\n",
        "            brace.scale(0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Restore, braces,\n",
        "                lag_ratio=0.7\n",
        "            ),\n",
        "        )\n",
        "        for word in words:\n",
        "            self.play(Write(word, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowSegmentSplitWithoutImage(ShowSegmentSplit):\n",
        "    CONFIG = {\n",
        "        \"include_image\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowCircleToCircleLineAtMultiplePoints(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ConjectureLineEquivalence(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class WriteConjecture(Scene):\n",
        "    CONFIG = {\n",
        "        \"image_name\": \"ConjectureLineEquivalenceBigSphere\",\n",
        "        \"q_coords\": 1.28 * UP + 0.15 * LEFT,\n",
        "        \"circle_point_coords\": 0.84 * RIGHT + 0.05 * DOWN,\n",
        "        \"tangent_point_coords\": 0.85 * UP + 1.75 * LEFT,\n",
        "        \"plane_line_color\": GOLD,\n",
        "        \"text_scale_factor\": 0.75,\n",
        "        \"shift_plane_word_down\": False,\n",
        "        \"include_image\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        if self.include_image:\n",
        "            image = ImageMobject(self.image_name)\n",
        "            image.set_height(FRAME_HEIGHT)\n",
        "            self.add(image)\n",
        "\n",
        "        title = OldTexText(\"Conjecture:\")\n",
        "        title.to_corner(UR)\n",
        "\n",
        "        cone_line = Line(self.q_coords, self.circle_point_coords)\n",
        "        plane_line = Line(self.q_coords, self.tangent_point_coords)\n",
        "        plane_line.set_color(self.plane_line_color)\n",
        "        lines = VGroup(cone_line, plane_line)\n",
        "\n",
        "        cone_line_words = OldTexText(\"Cone line\")\n",
        "        plane_line_words = OldTexText(\"Plane line\")\n",
        "        plane_line_words.set_color(self.plane_line_color)\n",
        "        words = VGroup(cone_line_words, plane_line_words)\n",
        "\n",
        "        for word in words:\n",
        "            word.add_to_back(word.copy().set_stroke(BLACK, 5))\n",
        "            word.in_equation = word.copy()\n",
        "\n",
        "        equation = VGroup(\n",
        "            OldTex(\"||\"),\n",
        "            words[0].in_equation,\n",
        "            OldTex(\"||\"),\n",
        "            OldTex(\"=\"),\n",
        "            OldTex(\"||\"),\n",
        "            words[1].in_equation,\n",
        "            OldTex(\"||\"),\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.scale(0.75)\n",
        "        equation.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        equation.shift_onto_screen()\n",
        "        title.next_to(equation, UP)\n",
        "\n",
        "        for word, line in zip(words, lines):\n",
        "            word.scale(self.text_scale_factor)\n",
        "            word.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "            if self.shift_plane_word_down and (word is plane_line_words):\n",
        "                word.next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "            angle = line.get_angle()\n",
        "            if abs(angle) > 90 * DEGREES:\n",
        "                angle += PI\n",
        "            word.rotate(angle, about_point=ORIGIN)\n",
        "            word.shift(line.get_center())\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown,\n",
        "            VGroup(title, equation),\n",
        "            lag_ratio=0.7\n",
        "        ))\n",
        "        self.wait()\n",
        "        for word, line in zip(words, lines):\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(WiggleOutThenIn(line))\n",
        "            self.play(ReplacementTransform(\n",
        "                word.in_equation.copy(), word\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class WriteConjectureV2(WriteConjecture):\n",
        "    CONFIG = {\n",
        "        \"image_name\": \"ConjectureLineEquivalenceSmallSphere\",\n",
        "        \"q_coords\": 2.2 * LEFT + 1.3 * UP,\n",
        "        \"circle_point_coords\": 1.4 * LEFT + 2.25 * UP,\n",
        "        \"tangent_point_coords\": 0.95 * LEFT + 1.51 * UP,\n",
        "        \"plane_line_color\": PINK,\n",
        "        \"text_scale_factor\": 0.5,\n",
        "        \"shift_plane_word_down\": True,\n",
        "        \"include_image\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowQ(Scene):\n",
        "    def construct(self):\n",
        "        mob = OldTex(\"Q\")\n",
        "        mob.scale(2)\n",
        "        mob.add_to_back(mob.copy().set_stroke(BLACK, 5))\n",
        "        self.play(FadeInFromDown(mob))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowBigSphereTangentLines(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class LinesTangentToSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class QuickGeometryProof(Scene):\n",
        "    def construct(self):\n",
        "        radius = 2\n",
        "        circle = Circle(color=BLUE, radius=radius)\n",
        "        circle.shift(0.5 * DOWN)\n",
        "        angle = 60 * DEGREES\n",
        "        O = circle.get_center()\n",
        "        p1 = circle.point_from_proportion(angle / TAU)\n",
        "        p2 = circle.point_from_proportion(1 - angle / TAU)\n",
        "        Q = O + (radius / np.cos(angle)) * RIGHT\n",
        "\n",
        "        O_p1 = Line(O, p1)\n",
        "        O_p2 = Line(O, p2)\n",
        "        p1_Q = Line(p1, Q, color=MAROON_B)\n",
        "        p2_Q = Line(p2, Q, color=MAROON_B)\n",
        "        O_Q = DashedLine(O, Q)\n",
        "\n",
        "        elbow = VGroup(Line(RIGHT, UR), Line(UR, UP))\n",
        "        elbow.set_stroke(WHITE, 1)\n",
        "        elbow.scale(0.2, about_point=ORIGIN)\n",
        "\n",
        "        ticks = VGroup(Line(DOWN, UP), Line(DOWN, UP))\n",
        "        ticks.scale(0.1)\n",
        "        ticks.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\Delta OP_1Q \\\\cong \\\\Delta OP_2Q\",\n",
        "            tex_to_color_map={\n",
        "                \"O\": BLUE,\n",
        "                \"P_1\": MAROON_B,\n",
        "                \"P_2\": MAROON_B,\n",
        "                \"Q\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "        self.add(*equation)\n",
        "\n",
        "        self.add(circle)\n",
        "        self.add(\n",
        "            OldTex(\"O\").next_to(O, LEFT),\n",
        "            OldTex(\"P_1\").next_to(p1, UP).set_color(MAROON_B),\n",
        "            OldTex(\"P_2\").next_to(p2, DOWN).set_color(MAROON_B),\n",
        "            OldTex(\"Q\").next_to(Q, RIGHT).set_color(YELLOW),\n",
        "        )\n",
        "        self.add(O_p1, O_p2, p1_Q, p2_Q, O_Q)\n",
        "        self.add(\n",
        "            Dot(O, color=BLUE),\n",
        "            Dot(p1, color=MAROON_B),\n",
        "            Dot(p2, color=MAROON_B),\n",
        "            Dot(Q, color=YELLOW)\n",
        "        )\n",
        "        self.add(\n",
        "            elbow.copy().rotate(angle + PI, about_point=ORIGIN).shift(p1),\n",
        "            elbow.copy().rotate(-angle + PI / 2, about_point=ORIGIN).shift(p2),\n",
        "        )\n",
        "        self.add(\n",
        "            ticks.copy().rotate(angle).move_to(O_p1),\n",
        "            ticks.copy().rotate(-angle).move_to(O_p2),\n",
        "        )\n",
        "\n",
        "        everything = VGroup(*self.mobjects)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            GrowFromCenter, everything,\n",
        "            lag_ratio=0.25,\n",
        "            run_time=4\n",
        "        ))\n",
        "\n",
        "\n",
        "class ShowFocalSumEqualsCircleDistance(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class FinalMovingEllipsePoint(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TiltPlaneWithSpheres(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class NameDandelin(Scene):\n",
        "    CONFIG = {\"camera_config\": {\"background_opacity\": 1}}\n",
        "\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"Proof by\\\\\\\\\",\n",
        "            \"Germinal Pierre Dandelin (1822)\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        portrait = ImageMobject(\"GerminalDandelin\")\n",
        "        portrait.set_height(5)\n",
        "        portrait.next_to(title, DOWN)\n",
        "\n",
        "        google_result = ImageMobject(\"GoogleDandelin\")\n",
        "        google_result.set_height(4)\n",
        "        google_result.center()\n",
        "        google_result.to_corner(DR)\n",
        "\n",
        "        cmon_google = OldTexText(\"C'mon Google...\")\n",
        "        cmon_google.set_color(RED)\n",
        "        cmon_google.next_to(google_result, RIGHT)\n",
        "        cmon_google.next_to(google_result, UP, aligned_edge=RIGHT)\n",
        "\n",
        "        dandelion = ImageMobject(\"DandelionSphere\", height=1.5)\n",
        "        dandelion.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        dandelion.shift(UP)\n",
        "        big_dandelion = dandelion.copy().scale(2)\n",
        "        big_dandelion.next_to(dandelion, DOWN, buff=0)\n",
        "        dandelions = Group(dandelion, big_dandelion)\n",
        "\n",
        "        self.add(title[0])\n",
        "        self.play(FadeInFromDown(portrait))\n",
        "        self.play(Write(title[1]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(google_result, LEFT))\n",
        "        self.play(Write(cmon_google, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, dandelions,\n",
        "            lag_ratio=0.7,\n",
        "            run_time=1\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DandelinSpheresInCylinder(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ProjectCircleOntoTiltedPlane(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class CylinderDandelinSpheresChangingSlope(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class DetailsLeftAsHomework(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "            \"flip_at_start\": False,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DL,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # morty = self.pi_creature\n",
        "        self.pi_creature_says(\n",
        "            \"Details left \\\\\\\\ as homework\",\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class AskWhyYouWouldChooseThisProof(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy, other = self.pi_creatures\n",
        "        screen = ScreenRectangle(height=4).to_edge(UP)\n",
        "\n",
        "        for pi, vect, word in (randy, UP, \"You\"), (other, LEFT, \"Non-math \\\\\\\\ enthusiast\"):\n",
        "            arrow = Vector(-vect, color=WHITE)\n",
        "            arrow.next_to(pi, vect)\n",
        "            label = OldTexText(word)\n",
        "            label.next_to(arrow, vect)\n",
        "            pi.arrow = arrow\n",
        "            pi.label = label\n",
        "\n",
        "        for pi, mode in (randy, \"hooray\"), (other, \"tired\"):\n",
        "            self.play(\n",
        "                GrowArrow(pi.arrow),\n",
        "                FadeIn(pi.label, RIGHT),\n",
        "                pi.change, mode,\n",
        "            )\n",
        "        self.play(\n",
        "            randy.change, \"raise_right_hand\", screen,\n",
        "            other.look_at, screen,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(other.change, \"thinking\", screen)\n",
        "        self.wait(5)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        other = PiCreature(color=RED_D)\n",
        "        other.flip()\n",
        "        group = VGroup(randy, other)\n",
        "        group.arrange(RIGHT, buff=5)\n",
        "        group.to_edge(DOWN)\n",
        "        return group\n",
        "\n",
        "\n",
        "class CreativeConstruction(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        self.remove(randy)\n",
        "\n",
        "        dandelin = ImageMobject(\"GerminalDandelin\")\n",
        "        dandelin.set_height(4)\n",
        "        dandelin.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "\n",
        "        lightbulb = Lightbulb()\n",
        "        lightbulb.next_to(dandelin, UP)\n",
        "\n",
        "        kant = ImageMobject(\"Kant\")\n",
        "        kant.set_height(3)\n",
        "        bubble = ThoughtBubble(height=3, width=4)\n",
        "        bubble.pin_to(kant)\n",
        "        kant_words = OldTexText(\n",
        "            \"How is synthetic a priori\\\\\\\\\" +\n",
        "            \"reasoning possible?\"\n",
        "        )\n",
        "        kant_words.scale(0.75)\n",
        "        bubble.position_mobject_inside(kant_words)\n",
        "        kant_group = VGroup(bubble, kant_words, kant)\n",
        "        kant_group.to_corner(UR)\n",
        "\n",
        "        self.add(dandelin)\n",
        "        self.add(lightbulb)\n",
        "        self.play(\n",
        "            Write(lightbulb, run_time=1),\n",
        "            self.get_light_shine(lightbulb)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lightbulb.next_to, randy, RIGHT,\n",
        "            {\"buff\": LARGE_BUFF, \"aligned_edge\": UP},\n",
        "            randy.change, \"pondering\",\n",
        "            VFadeIn(randy),\n",
        "            FadeOut(dandelin, DOWN),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            self.get_light_shine(lightbulb),\n",
        "            Blink(randy),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(kant),\n",
        "            Write(bubble),\n",
        "            Write(kant_words),\n",
        "        )\n",
        "\n",
        "        lightbulb.generate_target()\n",
        "        q_marks = VGroup()\n",
        "        for submob in lightbulb.target.family_members_with_points():\n",
        "            if True or get_norm(submob.get_center() - lightbulb.get_center()) > 0.25:\n",
        "                q_mark = OldTex(\"?\")\n",
        "                q_mark.set_height(0.25)\n",
        "                q_mark.move_to(submob)\n",
        "                Transform(submob, q_mark).update(1)\n",
        "                q_marks.add(submob)\n",
        "        q_marks.space_out_submobjects(2)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(randy.change, 'confused', lightbulb)\n",
        "        self.play(MoveToTarget(\n",
        "            lightbulb,\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back,\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    def get_rings(self, center, max_radius, delta_r):\n",
        "        radii = np.arange(0, max_radius, delta_r)\n",
        "        rings = VGroup(*[\n",
        "            Annulus(\n",
        "                inner_radius=r1,\n",
        "                outer_radius=r2,\n",
        "                fill_opacity=0.75 * (1 - fdiv(r1, max_radius)),\n",
        "                fill_color=YELLOW\n",
        "            )\n",
        "            for r1, r2 in zip(radii, radii[1:])\n",
        "        ])\n",
        "        rings.move_to(center)\n",
        "        return rings\n",
        "\n",
        "    def get_light_shine(self, lightbulb, max_radius=15.0, delta_r=0.025):\n",
        "        rings = self.get_rings(\n",
        "            lightbulb.get_center(),\n",
        "            max_radius=15.0,\n",
        "            delta_r=0.025,\n",
        "        )\n",
        "        return LaggedStartMap(\n",
        "            FadeIn, rings,\n",
        "            rate_func=there_and_back,\n",
        "            run_time=2,\n",
        "            lag_ratio=0.5\n",
        "        )\n",
        "\n",
        "\n",
        "class LockhartQuote(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        mb_string = \"Madame\\\\,\\\\,Bovary\"\n",
        "        ml_string = \"Mona\\\\,\\\\,Lisa.\"\n",
        "        strings = (mb_string, ml_string)\n",
        "        quote_text = \"\"\"\n",
        "            \\\\large\n",
        "            How do people come up with such ingenious arguments?\n",
        "            It's the same way people come up with %s or %s\n",
        "            I have no idea how it happens.  I only know that\n",
        "            when it happens to me, I feel very fortunate.\n",
        "        \"\"\" % strings\n",
        "        quote_parts = [s for s in quote_text.split(\" \") if s]\n",
        "        quote = OldTexText(\n",
        "            *quote_parts,\n",
        "            tex_to_color_map={\n",
        "                mb_string: BLUE,\n",
        "                ml_string: YELLOW,\n",
        "            },\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        quote.set_width(FRAME_WIDTH - 2)\n",
        "        quote.to_edge(UP)\n",
        "\n",
        "        measurement = ImageMobject(\"MeasurementCover\")\n",
        "        madame_bovary = ImageMobject(\"MadameBovary\")\n",
        "        mona_lisa = ImageMobject(\"MonaLisa\")\n",
        "        pictures = Group(measurement, madame_bovary, mona_lisa)\n",
        "        for picture in pictures:\n",
        "            picture.set_height(4)\n",
        "        pictures.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        pictures.to_edge(DOWN)\n",
        "\n",
        "        measurement.save_state()\n",
        "        measurement.set_width(FRAME_WIDTH)\n",
        "        measurement.center()\n",
        "        measurement.fade(1)\n",
        "        self.play(Restore(measurement))\n",
        "        self.wait()\n",
        "        for word in quote:\n",
        "            anims = [ShowWord(word)]\n",
        "            for text, picture in zip(strings, pictures[1:]):\n",
        "                if word is quote.get_part_by_tex(text):\n",
        "                    anims.append(FadeInFromDown(\n",
        "                        picture, run_time=1\n",
        "                    ))\n",
        "            self.play(*anims)\n",
        "            self.wait(0.005 * len(word)**1.5)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShiftDown, quote,\n",
        "                lag_ratio=0.2,\n",
        "                run_time=5,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShiftDown, pictures,\n",
        "                run_time=3,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "\n",
        "class ImmersedInGeometryProblems(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "        randy.center().to_edge(DOWN)\n",
        "\n",
        "        for vect in compass_directions(start_vect=UL):\n",
        "            self.play(randy.change, \"pondering\", 4 * vect)\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class ShowApollonianCircles(Scene):\n",
        "    def construct(self):\n",
        "        radii = [1.0, 2.0, 3.0]\n",
        "        curvatures = [1.0 / r for r in radii]\n",
        "        k4 = sum(curvatures) - 2 * np.sqrt(\n",
        "            sum([\n",
        "                k1 * k2\n",
        "                for k1, k2 in it.combinations(curvatures, 2)\n",
        "            ])\n",
        "        )\n",
        "        radii.append(1.0 / k4)\n",
        "        centers = [\n",
        "            ORIGIN, 3 * RIGHT, 4 * UP,\n",
        "            4 * UP + 3 * RIGHT,\n",
        "        ]\n",
        "        circles = VGroup(*[\n",
        "            Circle(radius=r).shift(c)\n",
        "            for r, c in zip(radii, centers)\n",
        "        ])\n",
        "\n",
        "        circles.set_height(FRAME_HEIGHT - 3)\n",
        "        circles.center().to_edge(DOWN)\n",
        "        # circles.set_fill(opacity=1)\n",
        "        circles.submobjects.reverse()\n",
        "        circles.set_stroke(width=5)\n",
        "        circles.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        equation = OldTex(\"\"\"\n",
        "            \\\\left(\n",
        "            {1 \\\\over r_1} + {1 \\\\over r_2} +\n",
        "            {1 \\\\over r_3} + {1 \\\\over r_4}\n",
        "            \\\\right)^2 = \n",
        "            2\\\\left(\n",
        "            {1 \\\\over r_1^2} + {1 \\\\over r_2^2} +\n",
        "            {1 \\\\over r_3^2} + {1 \\\\over r_4^2}\n",
        "            \\\\right)\n",
        "        \"\"\")\n",
        "        # equation.scale(1.5)\n",
        "        equation.next_to(circles, UP)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, circles\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EllipseLengthsLinedUp(EccentricityInThumbtackCase):\n",
        "    def construct(self):\n",
        "        ellipse = self.get_ellipse(eccentricity=0.6)\n",
        "        ellipse.scale(2)\n",
        "        foci = self.get_foci(ellipse)\n",
        "\n",
        "        point = VectorizedPoint()\n",
        "        point_movement = cycle_animation(\n",
        "            MoveAlongPath(\n",
        "                point, ellipse,\n",
        "                run_time=5,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        arrow = Vector(RIGHT, color=WHITE)\n",
        "        arrow.to_edge(LEFT)\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.next_to(arrow, UP)\n",
        "\n",
        "        lines = VGroup(*[Line(UP, DOWN) for x in range(2)])\n",
        "        lines.set_color_by_gradient(PINK, GOLD)\n",
        "        lines.set_stroke(width=5)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT, color=WHITE)\n",
        "        h_line.set_width(0.25)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for line, focus in zip(lines, foci):\n",
        "                d = get_norm(point.get_center() - focus)\n",
        "                line.put_start_and_end_on(\n",
        "                    ORIGIN, d * UP\n",
        "                )\n",
        "            lines.arrange(DOWN, buff=0)\n",
        "            lines.next_to(arrow, RIGHT)\n",
        "            h_line.move_to(lines[0].get_bottom())\n",
        "        lines_animation = Mobject.add_updater(\n",
        "            lines, update_lines\n",
        "        )\n",
        "\n",
        "        self.add(point_movement)\n",
        "        self.add(arrow)\n",
        "        self.add(q_mark)\n",
        "        self.add(h_line)\n",
        "        self.add(lines_animation)\n",
        "\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class ReactionToGlimpseOfGenius(TeacherStudentsScene, CreativeConstruction):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "\n",
        "        lightbulb = Lightbulb()\n",
        "        lightbulb.set_stroke(width=4)\n",
        "        lightbulb.scale(1.5)\n",
        "        lightbulb.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        rings = self.get_rings(\n",
        "            lightbulb.get_center(),\n",
        "            max_radius=15,\n",
        "            delta_r=0.1,\n",
        "        )\n",
        "\n",
        "        arrow = Vector(RIGHT, color=WHITE)\n",
        "        arrow.next_to(lightbulb, LEFT)\n",
        "\n",
        "        clock = Clock()\n",
        "        clock.next_to(arrow, LEFT)\n",
        "\n",
        "        pi_lights = VGroup()\n",
        "        for pi in self.students:\n",
        "            light = Lightbulb()\n",
        "            light.scale(0.75)\n",
        "            light.next_to(pi, UP)\n",
        "            pi.light = light\n",
        "            pi_lights.add(light)\n",
        "\n",
        "        q_marks = VGroup()\n",
        "        for submob in lightbulb:\n",
        "            q_mark = OldTex(\"?\")\n",
        "            q_mark.move_to(submob)\n",
        "            q_marks.add(q_mark)\n",
        "        q_marks.space_out_submobjects(2)\n",
        "\n",
        "        self.student_says(\n",
        "            \"I think Lockhart was \\\\\\\\\"\n",
        "            \"speaking more generally.\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[morty.change, \"guilty\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(lightbulb),\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.change_students(*3 * [\"confused\"]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            lightbulb, q_marks,\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(\n",
        "            ClockPassesTime(clock, hours_passed=4, run_tim=4),\n",
        "            VFadeIn(clock),\n",
        "            GrowArrow(arrow),\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=clock\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            ClockPassesTime(clock, run_time=1, hours_passed=1),\n",
        "            VFadeOut(clock),\n",
        "            FadeOut(arrow),\n",
        "            lightbulb.scale, 1.5,\n",
        "            lightbulb.move_to, 2 * UP,\n",
        "            self.change_students(\n",
        "                *3 * [\"awe\"],\n",
        "                look_at=2 * UP\n",
        "            ),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(self.get_light_shine(lightbulb))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(lightbulb),\n",
        "                pi_lights\n",
        "            ),\n",
        "            morty.change, \"happy\",\n",
        "            *[\n",
        "                ApplyMethod(pi.change, mode, pi.get_top())\n",
        "                for pi, mode in zip(self.students, [\n",
        "                    \"hooray\", \"tease\", \"surprised\"\n",
        "                ])\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class DandelinEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Matt Russell\",\n",
        "            \"Soekul\",\n",
        "            \"Keith Smith\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Brian Tiger Chow\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Roy Larson\",\n",
        "            \"Andrew Sachs\",\n",
        "            \"Devin Scott\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Fela\",\n",
        "            \"Fred Ehrsam\",\n",
        "            \"Gary Kong\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Michael Faust\",\n",
        "            \"Solara570\",\n",
        "            \"George M. Botros\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ludwig\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Marek Cirkos\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Cooper Jones\",\n",
        "            \"James Hughes\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Chris Giddings\",\n",
        "            \"Song Gao\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"John Griffith\",\n",
        "            \"Chris Connett\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Bong Choung\",\n",
        "            \"Ignacio Freiberg\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"James H. Park\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"Dave B\",\n",
        "            \"supershabam\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Awoo\",\n",
        "            \"Dr . David G. Stork\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n"
    ]
}