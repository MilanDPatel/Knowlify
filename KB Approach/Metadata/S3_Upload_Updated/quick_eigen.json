{
    "topic": "The mathematical concept being demonstrated is the computation of the determinant of a matrix using the formula:",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "# Colors\n",
        "\n",
        "COL_COLORS = [MAROON_B, MAROON_C]\n",
        "EIGEN_COLORS = [TEAL_A, TEAL_D]\n",
        "MEAN_COLOR = BLUE_B\n",
        "PROD_COLOR = BLUE_D\n",
        "\n",
        "\n",
        "def det_path_anim(matrix, run_time=2):\n",
        "    path = VMobject()\n",
        "    path.set_points_smoothly([\n",
        "        matrix.get_corner(UL),\n",
        "        *[\n",
        "            matrix.get_entries()[i].get_center()\n",
        "            for i in [0, 3, 1, 2]\n",
        "        ],\n",
        "        matrix.get_corner(DL),\n",
        "    ])\n",
        "    path.set_stroke(BLUE, 3)\n",
        "\n",
        "    return VShowPassingFlash(path, time_width=1, run_time=run_time, rate_function=linear)\n",
        "\n",
        "\n",
        "def get_diag_rects(matrix, color=MEAN_COLOR, off_diagonal=False):\n",
        "    if off_diagonal:\n",
        "        entries = matrix.get_entries()[1:3]\n",
        "    else:\n",
        "        entries = matrix.get_entries()[0::3]\n",
        "    return VGroup(*(\n",
        "        SurroundingRectangle(entry, buff=SMALL_BUFF, color=color)\n",
        "        for entry in entries\n",
        "    ))\n",
        "\n",
        "\n",
        "def get_prism(verts, depth=2):\n",
        "    result = VGroup()\n",
        "    result.add(Polygon(*verts))\n",
        "    zv = depth * OUT\n",
        "    for v1, v2 in zip(verts, [*verts[1:], verts[0]]):\n",
        "        result.add(Polygon(v1, v2, v2 + zv, v1 + zv))\n",
        "    result.add(Polygon(*verts).shift(zv))\n",
        "    result.set_stroke(width=0)\n",
        "    result.set_fill(GREY, 1)\n",
        "    result.set_gloss(1)\n",
        "    for mob in list(result):\n",
        "        m2 = mob.copy()\n",
        "        m2.reverse_points()\n",
        "        result.add(m2)\n",
        "    result.apply_depth_test()\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_mod_mat(matrix, h_buff=1.3, v_buff=0.8, t2c={}):\n",
        "    t2c[\"\\\\lambda\"] = EIGEN_COLORS[1]\n",
        "    mod_mat = Matrix(\n",
        "        [\n",
        "            [matrix[0][0] + \" - \\\\lambda\", matrix[0][1]],\n",
        "            [matrix[1][0], matrix[1][1] + \" - \\\\lambda\"],\n",
        "        ],\n",
        "        element_to_mobject_config={\"tex_to_color_map\": t2c},\n",
        "        h_buff=h_buff,\n",
        "        v_buff=v_buff,\n",
        "    )\n",
        "    return mod_mat\n",
        "\n",
        "\n",
        "def get_det_mod_mat(mod_mat):\n",
        "    parens = OldTex(\"(\", \")\")\n",
        "    parens.stretch(2, 1)\n",
        "    parens.match_height(mod_mat)\n",
        "    parens[0].next_to(mod_mat, LEFT, SMALL_BUFF)\n",
        "    parens[1].next_to(mod_mat, RIGHT, SMALL_BUFF)\n",
        "    det = Text(\"det\")\n",
        "    det.next_to(parens, LEFT, SMALL_BUFF)\n",
        "    return VGroup(det, parens, mod_mat)\n",
        "\n",
        "\n",
        "def get_shadow(vmobject, width=50, n_copies=25):\n",
        "    shadow = VGroup()\n",
        "    for w in np.linspace(width, 0, n_copies):\n",
        "        part = vmobject.copy()\n",
        "        part.set_fill(opacity=0)\n",
        "        part.set_stroke(BLACK, width=w, opacity=1.0 / width)\n",
        "        shadow.add(part)\n",
        "    return shadow\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        grid = NumberPlane(faded_line_ratio=0)\n",
        "        grid.apply_matrix([[3, 1], [0, 2]])\n",
        "        grid.set_opacity(0.5)\n",
        "        self.add(grid)\n",
        "\n",
        "        mat_mob = IntegerMatrix([[3, 1], [4, 3]], h_buff=0.8)\n",
        "        mat_mob.set_height(3)\n",
        "        mat_mob.add_to_back(BackgroundRectangle(mat_mob))\n",
        "        mat_mob.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.add(mat_mob)\n",
        "\n",
        "        a, b, c, d = mat_mob.get_entries()\n",
        "        a_to_d = d.get_center() - a.get_center()\n",
        "        rect = Rectangle(height=1, width=get_norm(a_to_d) + 1)\n",
        "        rect.round_corners()\n",
        "        rect.set_stroke(MEAN_COLOR, 3)\n",
        "        rect.rotate(angle_of_vector(a_to_d))\n",
        "        rect.move_to(VGroup(a, d))\n",
        "        rect2 = rect.copy()\n",
        "        rect2.set_color(PROD_COLOR)\n",
        "        rect2.rotate(-2 * angle_of_vector(a_to_d))\n",
        "        rect2.move_to(rect)\n",
        "\n",
        "        dashed_rects = VGroup(\n",
        "            DashedVMobject(rect.insert_n_curves(100), num_dashes=50),\n",
        "            DashedVMobject(rect2.insert_n_curves(100), num_dashes=50),\n",
        "        )\n",
        "\n",
        "        self.add(dashed_rects)\n",
        "\n",
        "        answer = OldTex(\n",
        "            \"\\\\lambda_1, \\\\lambda_2 = {3} \\\\pm \\\\sqrt{\\\\,{3}^2 - {5}} = 5, 1\",\n",
        "            tex_to_color_map={\"{3}\": MEAN_COLOR, \"{p}\": PROD_COLOR}\n",
        "        )\n",
        "        answer.add_background_rectangle()\n",
        "        answer.set_width(12)\n",
        "        answer.to_edge(DOWN)\n",
        "        # answer.shift(SMALL_BUFF * UP)\n",
        "        self.add(answer)\n",
        "\n",
        "        arrow = Arrow(mat_mob, answer, fill_color=YELLOW, thickness=0.15, buff=0.3)\n",
        "        arrow.set_stroke(BLACK, 30, background=True)\n",
        "        arrow.shift(0.2 * UP)\n",
        "        self.add(arrow)\n",
        "\n",
        "        return\n",
        "        #old\n",
        "        backdrop = ImageMobject(\"QuickEigenThumbnailBackdrop\")\n",
        "        backdrop.set_height(FRAME_HEIGHT)\n",
        "        backdrop.set_opacity(0.5)\n",
        "        self.add(backdrop)\n",
        "\n",
        "        buff = 0.75\n",
        "        det = get_det_mod_mat(get_mod_mat([[\"3\", \"1\"], [\"4\", \"1\"]]))\n",
        "        det.set_height(2.25)\n",
        "        det.to_corner(UR, buff=buff)\n",
        "        self.add(get_shadow(det), det)\n",
        "\n",
        "        not_this = OldTexText(\"Not\\\\\\\\this\")\n",
        "        not_this.match_height(det)\n",
        "        not_this.to_corner(UL, buff=buff)\n",
        "        not_this.set_color(RED)\n",
        "        self.add(not_this)\n",
        "\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "                \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "                \"M\": YELLOW,\n",
        "            }\n",
        "        }\n",
        "        facts = VGroup(\n",
        "            OldTex(\"\\\\text{det}(M) = \\\\,\\\\, \\\\lambda_1 \\\\cdot \\\\lambda_2\", **kw),\n",
        "            OldTex(\"\\\\text{tr}(M) = \\\\lambda_1 + \\\\lambda_2\", **kw),\n",
        "        )\n",
        "        facts.arrange(DOWN, buff=MED_SMALL_BUFF, index_of_submobject_to_align=2)\n",
        "        facts.match_height(det)\n",
        "        facts.match_x(det)\n",
        "        facts.set_y(-det.get_y())\n",
        "        self.add(get_shadow(facts), facts)\n",
        "\n",
        "        use_these = OldTexText(\"Use\\\\\\\\these\")\n",
        "        use_these.match_height(not_this)\n",
        "        use_these.to_corner(DL, buff=buff)\n",
        "        use_these.set_color(BLUE)\n",
        "        not_this.match_x(use_these)\n",
        "        self.add(use_these)\n",
        "\n",
        "        not_arrow = Arrow(not_this, det, fill_color=RED, thickness=0.1, buff=0.5)\n",
        "        use_arrow = Arrow(use_these, facts, fill_color=BLUE, thickness=0.1, buff=0.5)\n",
        "        self.add(get_shadow(not_arrow), not_arrow)\n",
        "        self.add(get_shadow(use_arrow), use_arrow)\n",
        "\n",
        "        ## DELETE\n",
        "        # mp = OldTex(\n",
        "        #     \"{m} \\\\pm \\\\sqrt{\\\\,{m}^2 - {p}}\",\n",
        "        #     tex_to_color_map={\n",
        "        #         \"{m}\": MEAN_COLOR,\n",
        "        #         \"{p}\": MEAN_COLOR,\n",
        "        #     }\n",
        "        # )\n",
        "        # for mob, u in [(det, -1), (mp, 1)]:\n",
        "        #     mob.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        #     mob.set_x(u * FRAME_WIDTH / 4)\n",
        "        #     mob.set_y(-1)\n",
        "\n",
        "        # v_line = DashedLine(4 * UP, 4 * DOWN)\n",
        "\n",
        "        # ex = Exmark()\n",
        "        # check = Checkmark()\n",
        "        # VGroup(ex, check).scale(5)\n",
        "        # ex.move_to(det).to_edge(UP, LARGE_BUFF)\n",
        "        # check.move_to(mp).to_edge(UP, LARGE_BUFF)\n",
        "\n",
        "        # self.add(v_line)\n",
        "        # self.add(det)\n",
        "        # self.add(mp)\n",
        "        # self.add(ex)\n",
        "        # self.add(check)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class Assumptions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            PiCreatureSays(self.teacher, OldTexText(\"I'm assuming you know\\\\\\\\ what eigenvalues are.\")),\n",
        "            self.change_students(\n",
        "                \"erm\", \"happy\", \"tease\",\n",
        "                look_at=ORIGIN,\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(self.students[0].change(\"guilty\").look(LEFT))\n",
        "        self.wait()\n",
        "\n",
        "        eigen_expression = OldTex(\"\"\"\n",
        "            \\\\text{det}\\\\left( \\\\left[ \\\\begin{array}{cc}\n",
        "                3 - \\\\lambda & 1 \\\\\\\\\n",
        "                4 & 1 - \\\\lambda\n",
        "            \\\\end{array} \\\\right] \\\\right)\n",
        "        \"\"\")\n",
        "        eigen_expression.move_to(self.hold_up_spot, DOWN)\n",
        "        eigen_expression.to_edge(RIGHT, buff=2)\n",
        "        VGroup(eigen_expression[0][7], eigen_expression[0][12]).set_color(TEAL)\n",
        "        cross = Cross(eigen_expression)\n",
        "        cross.set_stroke(RED, width=(2, 5, 5, 2))\n",
        "        words = Text(\"Not this!\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(cross, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"raise_right_hand\"),\n",
        "            FadeIn(eigen_expression, UP),\n",
        "            self.students[1].change(\"hesitant\"),\n",
        "            self.students[2].change(\"sassy\"),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            FadeIn(words, 0.25 * UP),\n",
        "            self.teacher.change(\"tease\", cross),\n",
        "            self.students[1].change(\"pondering\", cross),\n",
        "            self.students[2].change(\"hesitant\", cross),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        fade_rect.set_fill(BLACK, opacity=0.7)\n",
        "        self.add(fade_rect, self.students[0])\n",
        "        self.play(FadeIn(fade_rect))\n",
        "        self.play(self.students[0].change(\"maybe\", cross))\n",
        "        self.play(Blink(self.students[0]))\n",
        "\n",
        "\n",
        "class ExamplesStart(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Examples start\\\\\\\\at\", \" 4:53\")\n",
        "        words.set_width(8)\n",
        "        words[-1].set_color(YELLOW)\n",
        "        self.play(Write(words, run_time=1))\n",
        "        self.play(FlashAround(words[1], stroke_width=8))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PreviousVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        screen = ScreenRectangle(height=6)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.set_stroke(BLUE, 3)\n",
        "        screen.to_edge(DOWN)\n",
        "        im = ImageMobject(\"eigen_thumbnail\")\n",
        "        im.replace(screen)\n",
        "        screen = Group(screen, im)\n",
        "        title = Text(\"Introduction\", font_size=48)\n",
        "        # title.match_width(screen)\n",
        "        title.next_to(screen, UP, MED_LARGE_BUFF)\n",
        "        # screen.next_to(title, DOWN)\n",
        "\n",
        "        self.add(screen)\n",
        "        self.play(Write(title))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(title, UP),\n",
        "            screen.animate.set_height(7).center(),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GoalOfRediscovery(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            PiCreatureSays(self.teacher, OldTexText(\"The goal is\\\\\\\\rediscovery\")),\n",
        "            self.change_students(\n",
        "                \"happy\", \"tease\", \"hooray\",\n",
        "                run_time=1.5,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        recap_words = Text(\"Quick recap\")\n",
        "        recap_words.move_to(self.screen, UP)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"raise_right_hand\", look_at=recap_words),\n",
        "            self.change_students(\"pondering\", \"hesitant\", \"pondering\", look_at=recap_words),\n",
        "            GrowFromPoint(recap_words, self.teacher.get_corner(UL)),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class RecapWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screen = ScreenRectangle(height=6.75)\n",
        "        screen.set_stroke(BLUE_B, 2)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.to_edge(DOWN, buff=0.25)\n",
        "        title = Text(\"Quick review\")\n",
        "        title.to_edge(UP, buff=0.25)\n",
        "        self.add(title, screen)\n",
        "\n",
        "\n",
        "class VisualizeEigenvector(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane(faded_line_ratio=0)\n",
        "        plane.set_stroke(width=3)\n",
        "        coords = [-1, 1]\n",
        "        vector = Vector(plane.c2p(*coords), fill_color=YELLOW)\n",
        "        array = IntegerMatrix([[-1], [1]], v_buff=0.9)\n",
        "        array.scale(0.7)\n",
        "        array.set_color(vector.get_color())\n",
        "        array.add_to_back(BackgroundRectangle(array))\n",
        "        array.generate_target()\n",
        "        array.next_to(vector.get_end(), LEFT)\n",
        "        array.target.next_to(2 * vector.get_end(), LEFT)\n",
        "        two_times = OldTex(\"2 \\\\cdot\")\n",
        "        two_times.set_stroke(BLACK, 8, background=True)\n",
        "        two_times.next_to(array.target, LEFT)\n",
        "        span_line = Line(-4 * vector.get_end(), 4 * vector.get_end())\n",
        "        span_line.set_stroke(YELLOW_E, 1)\n",
        "\n",
        "        matrix = [[3, 1], [0, 2]]\n",
        "        mat_mob = IntegerMatrix(matrix)\n",
        "        mat_mob.set_x(4).to_edge(UP)\n",
        "        mat_mob.set_column_colors(GREEN, RED)\n",
        "        mat_mob.add_to_back(BackgroundRectangle(mat_mob))\n",
        "        plane.set_stroke(background=True)\n",
        "\n",
        "        bases = VGroup(\n",
        "            Vector(RIGHT, fill_color=GREEN_E),\n",
        "            Vector(UP, fill_color=RED_E),\n",
        "        )\n",
        "        faint_plane = plane.copy()\n",
        "        faint_plane.set_stroke(GREY, width=1, opacity=0.5)\n",
        "\n",
        "        self.add(faint_plane, plane, bases)\n",
        "        self.add(vector)\n",
        "        self.add(mat_mob)\n",
        "\n",
        "        self.play(Write(array))\n",
        "        self.add(span_line, vector, array)\n",
        "        self.play(ShowCreation(span_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            plane.animate.apply_matrix(matrix),\n",
        "            bases[0].animate.put_start_and_end_on(ORIGIN, plane.c2p(3, 0)),\n",
        "            bases[1].animate.put_start_and_end_on(ORIGIN, plane.c2p(1, 2)),\n",
        "            vector.animate.scale(2, about_point=ORIGIN),\n",
        "            MoveToTarget(array),\n",
        "            GrowFromPoint(two_times, array.get_left() + SMALL_BUFF * LEFT),\n",
        "            run_time=3,\n",
        "            path_arc=0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(mat_mob)\n",
        "        self.remove(array)\n",
        "        self.remove(two_times)\n",
        "\n",
        "\n",
        "class EigenvalueEquationRearranging(Scene):\n",
        "    def construct(self):\n",
        "        v_tex = \"\\\\vec{\\\\textbf{v}}\"\n",
        "        zero_tex = \"\\\\vec{\\\\textbf{0}}\"\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"A\": BLUE,\n",
        "                \"\\\\lambda\": EIGEN_COLORS[1],\n",
        "                v_tex: YELLOW,\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        }\n",
        "        lines = VGroup(\n",
        "            OldTex(\"A\", v_tex, \"=\", \"\\\\lambda \", v_tex, **kw),\n",
        "            OldTex(\"A\", v_tex, \"=\", \"\\\\lambda \", \" I \", v_tex, **kw),\n",
        "            OldTex(\"A\", v_tex, \"-\", \"\\\\lambda \", \" I \", v_tex, \"=\", zero_tex, **kw),\n",
        "            OldTex(\"(A\", \"-\", \"\\\\lambda \", \"I)\", v_tex, \"=\", zero_tex, **kw),\n",
        "            OldTex(\"\\\\text{det}\", \"(A\", \"-\", \"\\\\lambda \", \"I)\", \"=\", \"0\", **kw),\n",
        "        )\n",
        "        for line in lines:\n",
        "            line.shift(-line.get_part_by_tex(\"=\").get_center())\n",
        "\n",
        "        mat_prod_brace = Brace(lines[0][:2])\n",
        "        mat_prod_label = Text(\"Matrix product\", color=BLUE, font_size=24)\n",
        "        mat_prod_label.next_to(mat_prod_brace, DOWN, SMALL_BUFF, aligned_edge=RIGHT)\n",
        "        scalar_prod_brace = Brace(lines[0][3:5])\n",
        "        scalar_prod_label = Text(\"Scalar product\", color=EIGEN_COLORS[1], font_size=24)\n",
        "        scalar_prod_label.next_to(scalar_prod_brace, DOWN, SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(lines[0])\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                GrowFromCenter(mat_prod_brace),\n",
        "                GrowFromCenter(scalar_prod_brace),\n",
        "                lag_ratio=0.3\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(mat_prod_label, 0.25 * DOWN),\n",
        "                FadeIn(scalar_prod_label, 0.25 * DOWN),\n",
        "                lag_ratio=0.3\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        id_brace = Brace(lines[1].get_part_by_tex(\"I\"))\n",
        "        id_label = Text(\"Identity matrix\", font_size=24)\n",
        "        id_label.next_to(id_brace, DOWN, SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(lines[0], lines[1]),\n",
        "            ReplacementTransform(scalar_prod_brace, id_brace),\n",
        "            FadeTransform(scalar_prod_label, id_label),\n",
        "            VGroup(mat_prod_label, mat_prod_brace).animate.shift(lines[1].get_left() - lines[0].get_left()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for shift_value, line in zip(it.count(1), lines[2:5]):\n",
        "            line.shift(shift_value * 0.75 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(lines[1].copy(), lines[2], path_arc=-45 * DEGREES),\n",
        "            FadeOut(VGroup(mat_prod_label, mat_prod_brace, id_brace, id_label), 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(lines[2].copy(), lines[3]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        v_part = lines[3].get_part_by_tex(v_tex)\n",
        "        nz_label = Text(\"Non-zero vector\", color=YELLOW, font_size=24)\n",
        "        nz_label.next_to(v_part, DR, MED_LARGE_BUFF)\n",
        "        arrow = Arrow(nz_label.get_corner(UL), v_part, fill_color=YELLOW, buff=0.1, thickness=0.025)\n",
        "\n",
        "        self.play(\n",
        "            Write(nz_label, run_time=2),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(lines[3].copy(), lines[4]),\n",
        "            FadeOut(nz_label),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SneakierEigenVector(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TypicalComputation(Scene):\n",
        "    def construct(self):\n",
        "        # Task\n",
        "        words, mat = task = VGroup(\n",
        "            Text(\"Find the eigenvalues of \", t2c={\"eigenvalues\": TEAL}),\n",
        "            IntegerMatrix([[3, 1], [4, 1]]).set_height(1),\n",
        "        )\n",
        "        task.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        task.to_edge(UP)\n",
        "        self.add(task)\n",
        "\n",
        "        # Top line of the computation\n",
        "        det_expression = OldTex(\"\"\"\n",
        "            \\\\text{det}\\\\left( \\\\left[ \\\\begin{array}{cc}\n",
        "                3 - \\\\lambda & 1 \\\\\\\\\n",
        "                4 & 1 - \\\\lambda\n",
        "            \\\\end{array} \\\\right] \\\\right)\n",
        "        \"\"\")[0]\n",
        "        lambdas = VGroup(det_expression[7], det_expression[12])\n",
        "        lambdas.set_color(TEAL)\n",
        "        t0, t1, t2, t3 = terms = VGroup(\n",
        "            det_expression[5:8],\n",
        "            det_expression[8:9],\n",
        "            det_expression[9:10],\n",
        "            det_expression[10:13],\n",
        "        ).copy()\n",
        "        p_height = terms[0].get_height() * 1.5\n",
        "        for term in terms:\n",
        "            parens = OldTex(\"(\", \")\")\n",
        "            parens.set_height(p_height)\n",
        "            parens[0].next_to(term, LEFT, 0.5 * SMALL_BUFF)\n",
        "            parens[1].next_to(term, RIGHT, 0.5 * SMALL_BUFF)\n",
        "            term.parens = parens\n",
        "            term.parens.set_opacity(0)\n",
        "            term.add(term.parens)\n",
        "\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(det_expression, RIGHT)\n",
        "        rhs = VGroup(\n",
        "            t0.copy(), t3.copy(), OldTex(\"-\"), t1.copy(), t2.copy()\n",
        "        )\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.next_to(eq, RIGHT)\n",
        "        rhs.set_opacity(1)\n",
        "        VGroup(det_expression, terms, eq, rhs).next_to(task, DOWN, LARGE_BUFF)\n",
        "\n",
        "        movers = VGroup(det_expression[5], det_expression[10])\n",
        "        movers.save_state()\n",
        "        movers[0].move_to(det_expression[6])\n",
        "        movers[1].move_to(det_expression[11])\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(mat.get_brackets(), VGroup(*(det_expression[i] for i in [4, 13]))),\n",
        "            TransformFromCopy(mat.get_entries(), VGroup(*(det_expression[i] for i in [5, 8, 9, 10]))),\n",
        "            FadeTransform(\n",
        "                mat.get_brackets().copy().set_opacity(0),\n",
        "                VGroup(*(det_expression[i] for i in [0, 1, 2, 3, 14]))\n",
        "            ),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            Write(VGroup(*(det_expression[i] for i in [6, 7, 11, 12]))),\n",
        "            Restore(movers),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(det_expression)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(eq),\n",
        "            TransformFromCopy(VGroup(t0, t3), rhs[:2]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(rhs[2]),\n",
        "            TransformFromCopy(VGroup(t1, t2), rhs[3:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Line 2\n",
        "        eq2 = eq.copy()\n",
        "        eq2.shift(DOWN)\n",
        "        self.add(eq2)\n",
        "        rhs2 = OldTex(\"\\\\left( 3 - 4\\\\lambda + \\\\lambda^2 \\\\right) - 4\")[0]\n",
        "        rhs2.next_to(eq2, RIGHT)\n",
        "        VGroup(rhs2[4], rhs2[6]).set_color(TEAL)\n",
        "\n",
        "        top_terms = VGroup(\n",
        "            VGroup(rhs[0][0], rhs[0][2]),\n",
        "            VGroup(rhs[1][0], rhs[1][2]),\n",
        "        )\n",
        "        alt_mid = OldTex(\"-3\\\\lambda\", tex_to_color_map={\"\\\\lambda\": TEAL})\n",
        "        alt_mid.move_to(rhs2[2:5], DL)\n",
        "        bottom_terms = VGroup(rhs2[1], alt_mid, rhs2[2:5], rhs2[5:8])\n",
        "        for pair, bt in zip(it.product(*top_terms), bottom_terms):\n",
        "            rects = VGroup(*(SurroundingRectangle(t, buff=SMALL_BUFF) for t in pair))\n",
        "            self.add(rects)\n",
        "            self.add(bt)\n",
        "            self.wait(0.5)\n",
        "            if bt is alt_mid:\n",
        "                self.remove(bt)\n",
        "            self.remove(rects)\n",
        "        self.play(\n",
        "            FadeIn(VGroup(rhs2[0], rhs2[8])),\n",
        "            FadeTransform(rhs[2:].copy(), rhs2[9:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Line 3\n",
        "        eq3 = eq2.copy().shift(DOWN)\n",
        "        rhs3 = OldTex(\"\\\\lambda^2 - 4 \\\\lambda - 1\")[0]\n",
        "        rhs3.next_to(eq3, RIGHT)\n",
        "        VGroup(rhs3[0], rhs3[4]).set_color(TEAL)\n",
        "\n",
        "        kw = {\"path_arc\": 45 * DEGREES}\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(eq2, eq3, **kw),\n",
        "            Transform(rhs2[1].copy(), rhs3[6].copy(), remover=True, **kw),\n",
        "            TransformFromCopy(rhs2[9:11], rhs3[5:], **kw),\n",
        "            TransformFromCopy(rhs2[2:5], rhs3[2:5], **kw),\n",
        "            TransformFromCopy(rhs2[6:8], rhs3[0:2], **kw),\n",
        "            run_time=1.5, lag_ratio=0.02,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Characteristic polynomial\n",
        "        brace = Brace(rhs3, DOWN)\n",
        "        char_poly = VGroup(\n",
        "            Text(\"Characteristic polynomial of\", font_size=30, fill_color=BLUE),\n",
        "            mat.copy()\n",
        "        )\n",
        "        char_poly.arrange(RIGHT)\n",
        "        char_poly.next_to(brace, DOWN)\n",
        "        char_poly.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(char_poly, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Roots\n",
        "        equals_zero = OldTex(\"= 0\")\n",
        "        equals_zero.next_to(rhs3, RIGHT)\n",
        "        root_words = OldTex(\n",
        "            \"\\\\lambda_1, \\\\lambda_2 \\\\,=\\\\, \\\\text{roots}\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\lambda_1\": TEAL_C,\n",
        "                \"\\\\lambda_2\": TEAL_B,\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        new_rhs3 = VGroup(rhs3, equals_zero)\n",
        "        root_words.next_to(brace, DOWN)\n",
        "        root_words.match_x(new_rhs3)\n",
        "        self.play(\n",
        "            FadeIn(root_words, DOWN),\n",
        "            FadeOut(char_poly, DOWN),\n",
        "            brace.animate.become(Brace(new_rhs3)),\n",
        "            Write(equals_zero),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Quadratic formula\n",
        "        formula = OldTex(\"\\\\frac{4 \\\\pm \\\\sqrt{4^2 - 4(1)(-1)}}{2}\")\n",
        "        formula2 = OldTex(\"=\\\\frac{4 \\\\pm \\\\sqrt{20}}{2}\")\n",
        "        formula3 = OldTex(\"= 2 \\\\pm \\\\sqrt{5}\")\n",
        "        formula.move_to(root_words[-1], LEFT)\n",
        "        formula.shift(0.5 * DL)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(rhs3.copy(), formula),\n",
        "            FadeOut(root_words[-1]),\n",
        "            root_words[:-1].animate.shift(0.5 * DL),\n",
        "        )\n",
        "        self.wait()\n",
        "        solution = VGroup(root_words[:-1], formula)\n",
        "        self.play(\n",
        "            solution.animate.shift(formula2.get_width() * LEFT),\n",
        "        )\n",
        "        formula2.next_to(formula, RIGHT)\n",
        "        self.play(FadeIn(formula2))\n",
        "        self.wait()\n",
        "        solution.add(formula2)\n",
        "        self.play(\n",
        "            solution.animate.shift(formula3.get_width() * LEFT),\n",
        "        )\n",
        "        formula3.next_to(formula2, RIGHT)\n",
        "        self.play(FadeIn(formula3))\n",
        "        self.wait()\n",
        "\n",
        "        # Straight line\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "        arrow = Arrow(mat, formula3, thickness=0.05)\n",
        "        arrow.set_fill(YELLOW)\n",
        "\n",
        "        self.add(full_rect, task, formula3)\n",
        "        self.play(FadeIn(full_rect))\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TweakDiagonalValue(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class DetEquationLineOfReasoning(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class OutlineThreeFacts(Scene):\n",
        "    def construct(self):\n",
        "        # Matrix to lambdas\n",
        "        mat = Matrix([[\"a\", \"b\"], [\"c\", \"d\"]], v_buff=0.8, h_buff=0.8)\n",
        "        mat.set_column_colors(COL_COLORS[0], COL_COLORS[1])\n",
        "\n",
        "        lambdas = OldTex(\"\\\\lambda_1\", \"\\\\,,\\\\,\", \"\\\\lambda_2\")\n",
        "        lambdas[0].set_color(EIGEN_COLORS[0])\n",
        "        lambdas[2].set_color(EIGEN_COLORS[1])\n",
        "        arrow = Vector(1.5 * RIGHT)\n",
        "        group = VGroup(mat, arrow, lambdas)\n",
        "        group.arrange(RIGHT)\n",
        "        arrow_label = Text(\"Quick?\", font_size=24)\n",
        "        arrow_label.next_to(arrow, UP, buff=0)\n",
        "\n",
        "        self.add(mat)\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(arrow_label, run_time=1),\n",
        "            LaggedStart(*(\n",
        "                AnimationGroup(*(\n",
        "                    Transform(entry, lambdas[i])\n",
        "                    for entry in mat.get_entries().deepcopy()\n",
        "                ))\n",
        "                for i in [0, 2]\n",
        "            ), lag_ratio=0.3),\n",
        "            FadeIn(lambdas[1]),\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(group, arrow_label)\n",
        "        self.wait()\n",
        "\n",
        "        # Three steps\n",
        "        indices = VGroup(*(Text(str(i) + \")\", font_size=48) for i in range(1, 4)))\n",
        "        indices.set_color(GREY_B)\n",
        "        indices.arrange(DOWN, aligned_edge=LEFT, buff=2)\n",
        "        indices.to_edge(LEFT)\n",
        "\n",
        "        group.generate_target()\n",
        "        group.target[1].rotate(-90 * DEGREES)\n",
        "        group.target[1].scale(0.5)\n",
        "        group.target.arrange(DOWN)\n",
        "        group.target.to_corner(DR)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, indices, shift=0.25 * UP, lag_ratio=0.3),\n",
        "            FadeOut(arrow_label),\n",
        "            MoveToTarget(group),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Trace\n",
        "        tr_mat = mat.deepcopy()\n",
        "        tr = OldTex(\"\\\\text{tr}\", \"\\\\Big(\", \"\\\\Big)\", font_size=60)\n",
        "        tr[1:].match_height(tr_mat, stretch=True)\n",
        "        tr.set_submobjects([*tr[:-1], tr_mat, tr[-1]])\n",
        "        tr.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        tr.next_to(indices[0], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        tr_rects = VGroup(\n",
        "            SurroundingRectangle(tr_mat.get_entries()[0]),\n",
        "            SurroundingRectangle(tr_mat.get_entries()[3]),\n",
        "        )\n",
        "        tr_rects.set_color(BLUE_C)\n",
        "        moving_tr_rects = tr_rects.copy()\n",
        "        moving_tr_rects.generate_target()\n",
        "\n",
        "        tex_kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"a\": COL_COLORS[0],\n",
        "                \"b\": COL_COLORS[1],\n",
        "                \"c\": COL_COLORS[0],\n",
        "                \"d\": COL_COLORS[1],\n",
        "                \"=\": WHITE,\n",
        "                \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "                \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "            }\n",
        "        }\n",
        "        tr_rhs = OldTex(\"= a + d = \\\\lambda_1 + \\\\lambda_2\", **tex_kw)\n",
        "        tr_rhs.next_to(tr, RIGHT)\n",
        "\n",
        "        for term, rect in zip(tr_rhs[1:4:2], moving_tr_rects.target):\n",
        "            rect.move_to(term)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(mat, tr_mat),\n",
        "            Write(VGroup(*tr[:2], tr[-1])),\n",
        "        )\n",
        "        self.play(LaggedStart(*map(ShowCreation, tr_rects)))\n",
        "        tr.add(tr_rects)\n",
        "        self.play(\n",
        "            MoveToTarget(moving_tr_rects),\n",
        "            TransformFromCopy(tr_mat.get_entries()[0], tr_rhs.get_part_by_tex(\"a\")),\n",
        "            TransformFromCopy(tr_mat.get_entries()[3], tr_rhs.get_part_by_tex(\"d\")),\n",
        "            FadeIn(tr_rhs[0:4:2]),\n",
        "        )\n",
        "        self.play(FadeOut(moving_tr_rects))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(lambdas.copy(), tr_rhs[4:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Mean of eigenvalues\n",
        "        half = OldTex(\"1 \\\\over 2\")\n",
        "        half.move_to(tr, LEFT)\n",
        "        tr.generate_target()\n",
        "        tr.target.next_to(half, RIGHT, SMALL_BUFF)\n",
        "        new_tr_rhs = OldTex(\"= {a + d \\\\over 2} = {\\\\lambda_1 + \\\\lambda_2 \\\\over 2}\", **tex_kw)\n",
        "        new_tr_rhs.next_to(tr.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(half),\n",
        "            MoveToTarget(tr),\n",
        "            TransformMatchingShapes(tr_rhs, new_tr_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Determinant\n",
        "        det_mat = mat.deepcopy()\n",
        "        det = OldTex(\"\\\\text{det}\", \"\\\\Big(\", \"\\\\Big)\", font_size=60)\n",
        "        det[1:].match_height(det_mat, stretch=True)\n",
        "        det.set_submobjects([*det[:-1], det_mat, det[-1]])\n",
        "        det.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        det.next_to(indices[1], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        det_rhs = OldTex(\"= ad - bc = \\\\lambda_1 \\\\lambda_2\", **tex_kw)\n",
        "        det_rhs.next_to(det, RIGHT)\n",
        "        self.play(\n",
        "            TransformFromCopy(mat, det_mat),\n",
        "            Write(VGroup(*det[:2], det[-1])),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            det_path_anim(det_mat),\n",
        "            LaggedStart(\n",
        "                Animation(Mobject(), remover=True),\n",
        "                FadeIn(det_rhs[:3]),\n",
        "                FadeIn(det_rhs[3:6]),\n",
        "                lag_ratio=0.7,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(lambdas.copy(), det_rhs[6:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Mean and product\n",
        "        eq_m = OldTexText(\"=\", \" $m$\", \"\\\\quad (mean)\")\n",
        "        eq_m[1].set_color(MEAN_COLOR)\n",
        "        eq_m.next_to(new_tr_rhs, RIGHT)\n",
        "        eq_p = OldTexText(\"=\", \" $p$\", \"\\\\quad (product)\")\n",
        "        eq_p[1].set_color(PROD_COLOR)\n",
        "        eq_p.next_to(det_rhs, RIGHT)\n",
        "\n",
        "        form_lhs = lambdas.copy()\n",
        "        form_rhs = OldTex(\"= {m} \\\\pm \\\\sqrt{\\\\,{m}^2 - {p}}\", tex_to_color_map={\"{m}\": MEAN_COLOR, \"{p}\": PROD_COLOR})\n",
        "        form_lhs.next_to(indices[2], RIGHT)\n",
        "        form_rhs.next_to(form_lhs, RIGHT)\n",
        "\n",
        "        third_point_placeholder = Text(\"(We'll get to this...)\", font_size=30)\n",
        "        third_point_placeholder.set_fill(GREY_C)\n",
        "        third_point_placeholder.next_to(indices[2], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        form = VGroup(indices[2], form_lhs, form_rhs)\n",
        "        rect = SurroundingRectangle(VGroup(form), buff=MED_SMALL_BUFF)\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.next_to(rect, RIGHT)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(third_point_placeholder),\n",
        "            VFadeIn(randy),\n",
        "            randy.change(\"erm\", third_point_placeholder)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change(\"thinking\", eq_m),\n",
        "            Write(eq_m)\n",
        "        )\n",
        "        self.play(\n",
        "            randy.animate.look_at(eq_p),\n",
        "            Write(eq_p),\n",
        "            mat.animate.set_height(1, about_edge=DOWN)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Example matrix\n",
        "        ex_mat = IntegerMatrix([[8, 4], [2, 6]])\n",
        "        ex_mat.set_height(1.25)\n",
        "        ex_mat.set_column_colors(COL_COLORS[0], COL_COLORS[1])\n",
        "        ex_mat.next_to(randy, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        kw = {\"tex_to_color_map\": {\"m\": MEAN_COLOR, \"p\": PROD_COLOR, \"=\": WHITE, \"-\": WHITE}}\n",
        "        m_eq = OldTex(\"m = 7\", **kw)\n",
        "        p_eq1 = OldTex(\"p = 48 - 8\", **kw)\n",
        "        p_eq2 = OldTex(\"p = 40\", **kw)\n",
        "\n",
        "        for mob in (m_eq, p_eq1, p_eq2):\n",
        "            mob.next_to(ex_mat, RIGHT, buff=MED_LARGE_BUFF)\n",
        "        m_eq.shift(0.5 * UP)\n",
        "        VGroup(p_eq1, p_eq2).shift(0.5 * DOWN)\n",
        "\n",
        "        diag_rects = VGroup(\n",
        "            SurroundingRectangle(ex_mat.get_entries()[0]),\n",
        "            SurroundingRectangle(ex_mat.get_entries()[3]),\n",
        "        )\n",
        "        off_diag_rects = VGroup(\n",
        "            SurroundingRectangle(ex_mat.get_entries()[1]),\n",
        "            SurroundingRectangle(ex_mat.get_entries()[2]),\n",
        "        )\n",
        "        diag_rects.set_color(PROD_COLOR)\n",
        "        off_diag_rects.set_color(PROD_COLOR)\n",
        "        mean_rect = SurroundingRectangle(m_eq[2])\n",
        "        mean_rect.set_color(MEAN_COLOR)\n",
        "\n",
        "        tr_rect = SurroundingRectangle(VGroup(indices[0], tr, eq_m)).set_stroke(MEAN_COLOR)\n",
        "        det_rect = SurroundingRectangle(VGroup(indices[1], det, eq_p)).set_stroke(PROD_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            randy.change(\"raise_right_hand\", ex_mat),\n",
        "            FadeIn(ex_mat, RIGHT),\n",
        "            FadeOut(group, RIGHT),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(tr_rect), randy.change(\"pondering\", tr_rhs))\n",
        "        self.play(\n",
        "            Write(m_eq[:2]),\n",
        "            LaggedStartMap(ShowCreation, diag_rects, lag_ratio=0.5, run_time=1),\n",
        "            randy.animate.look_at(m_eq),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(diag_rects)\n",
        "        self.play(\n",
        "            TransformFromCopy(diag_rects, mean_rect),\n",
        "            FadeTransform(ex_mat.get_entries()[0].copy(), m_eq[2]),\n",
        "            FadeTransform(ex_mat.get_entries()[3].copy(), m_eq[2]),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(tr_rect), FadeIn(det_rect), randy.animate.look_at(tr_rhs))\n",
        "        self.play(\n",
        "            Write(p_eq1[:2]),\n",
        "            randy.change(\"hesitant\", p_eq1),\n",
        "            FadeOut(mean_rect),\n",
        "        )\n",
        "\n",
        "        self.play(det_path_anim(ex_mat))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(diag_rects),\n",
        "            FadeIn(p_eq1[2]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(diag_rects),\n",
        "            FadeIn(off_diag_rects),\n",
        "            FadeIn(p_eq1[3:]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(off_diag_rects),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change(\"tease\", p_eq2),\n",
        "            FadeOut(p_eq1),\n",
        "            FadeIn(p_eq2),\n",
        "        )\n",
        "        self.play(FadeOut(det_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Let other stuff happen up top\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "        full_rect.set_fill(BLACK, 1)\n",
        "\n",
        "        ex = VGroup(ex_mat, m_eq, p_eq2)\n",
        "\n",
        "        self.add(full_rect, randy, ex)\n",
        "        self.play(\n",
        "            FadeIn(full_rect),\n",
        "            randy.change(\"pondering\", ORIGIN)\n",
        "        )\n",
        "        for x in range(10):\n",
        "            if random.random() < 0.5:\n",
        "                self.play(Blink(randy))\n",
        "            else:\n",
        "                self.wait()\n",
        "\n",
        "        # Show final formula\n",
        "        ex_rect = SurroundingRectangle(ex, buff=0.35)\n",
        "        ex_rect.set_stroke(GREY_A)\n",
        "        ex_rect.set_fill(interpolate_color(GREY_E, BLACK, 0.25))\n",
        "        ex_rect.set_opacity(0)\n",
        "        ex_group = VGroup(ex_rect, ex)\n",
        "        ex_group.generate_target()\n",
        "        ex_group.target.set_height(1.5)\n",
        "        ex_group.target.to_corner(DR)\n",
        "        ex_group.target[0].set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(full_rect),\n",
        "            FadeOut(randy),\n",
        "            MoveToTarget(ex_group)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(form_lhs, 0.25 * UP),\n",
        "            FadeOut(third_point_placeholder, 0.25 * UP)\n",
        "        )\n",
        "        self.play(TransformMatchingShapes(\n",
        "            VGroup(m_eq[0], p_eq2[0]).copy(),\n",
        "            form_rhs,\n",
        "        ))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MeansMatch(Scene):\n",
        "    def construct(self):\n",
        "        t2c = {\n",
        "            \"{a}\": COL_COLORS[0],\n",
        "            \"{d}\": COL_COLORS[1],\n",
        "            \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "            \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "            \"=\": WHITE,\n",
        "        }\n",
        "        equation = OldTex(\n",
        "            \"{{a} + {d} \\\\over 2} = {\\\\lambda_1 + \\\\lambda_2 \\\\over 2}\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        mean_eq = OldTex(\n",
        "            \"\\\\text{mean}({a}, {d}) = \\\\text{mean}(\\\\lambda_1, \\\\lambda_2)\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "\n",
        "        mean_eq.next_to(equation, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "\n",
        "        self.play(TransformMatchingShapes(equation[5:].copy(), mean_eq[6:]))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(equation[:5].copy(), mean_eq[:6]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowSquishingAndStretching(Scene):\n",
        "    def construct(self):\n",
        "        self.camera.frame.set_height((3 / 4) * FRAME_HEIGHT)\n",
        "\n",
        "        # Transform\n",
        "        plane = NumberPlane(\n",
        "            (-20, 20), (-20, 20),\n",
        "            background_line_style={\"stroke_width\": 3},\n",
        "            faded_line_ratio=0,\n",
        "        )\n",
        "        plane.axes.set_stroke(BLUE, 3)\n",
        "        back_plane = NumberPlane(\n",
        "            faded_line_ratio=0,\n",
        "        )\n",
        "        back_plane.set_stroke(GREY_B, 1, opacity=0.5)\n",
        "        mat = [[2, 2], [1, 2]]\n",
        "        eigenvalues, eigenvectors = np.linalg.eig(mat)\n",
        "        eigenvectors = [normalize(v) for v in eigenvectors.T]\n",
        "        eigenlines = VGroup(*(\n",
        "            Line(10 * ev, -10 * ev, color=color)\n",
        "            for ev, color in zip(eigenvectors, EIGEN_COLORS)\n",
        "        ))\n",
        "        eigenlines.set_stroke(GREY_B, 2)\n",
        "\n",
        "        eigenvect_mobs = VGroup(*(\n",
        "            Vector(ev, fill_color=color)\n",
        "            for ev, color in zip(eigenvectors, EIGEN_COLORS)\n",
        "        ))\n",
        "        eigenvect_mobs[0].add_updater(lambda m: m.put_start_and_end_on(plane.c2p(0, 0), plane.c2p(*eigenvectors[0][:2])))\n",
        "        eigenvect_mobs[1].add_updater(lambda m: m.put_start_and_end_on(plane.c2p(0, 0), plane.c2p(*eigenvectors[1][:2])))\n",
        "\n",
        "        # Basis vectors\n",
        "        bases = VGroup(\n",
        "            Vector(RIGHT, fill_color=GREEN, thickness=0.05),\n",
        "            Vector(UP, fill_color=RED, thickness=0.05),\n",
        "        )\n",
        "        bases[0].add_updater(lambda m: m.put_start_and_end_on(plane.c2p(0, 0), plane.c2p(1, 0)))\n",
        "        bases[1].add_updater(lambda m: m.put_start_and_end_on(plane.c2p(0, 0), plane.c2p(0, 1)))\n",
        "\n",
        "        disk = Circle(radius=1)\n",
        "        disk.set_fill(YELLOW, 0.25)\n",
        "        disk.set_stroke(YELLOW, 3)\n",
        "\n",
        "        morpher = VGroup(plane, disk)\n",
        "\n",
        "        self.add(back_plane, morpher, eigenlines, *eigenvect_mobs)\n",
        "\n",
        "        self.play(\n",
        "            morpher.animate.apply_matrix(mat), run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Labels\n",
        "        labels = VGroup(*(\n",
        "            OldTex(\"\\\\text{Stretch by }\", f\"\\\\lambda_{i}\", color=color, font_size=30)\n",
        "            for i, color in zip((1, 2), EIGEN_COLORS)\n",
        "        ))\n",
        "        for label, vect in zip(labels, eigenvect_mobs):\n",
        "            label.next_to(\n",
        "                vect.get_center(),\n",
        "                rotate_vector(normalize(vect.get_vector()), 90 * DEGREES),\n",
        "                buff=0.1,\n",
        "                index_of_submobject_to_align=1,\n",
        "            )\n",
        "        labels.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, labels, lag_ratio=0.7))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MeanProductExample(Scene):\n",
        "    def construct(self):\n",
        "        # Number line and midpoint\n",
        "        number_line = NumberLine((0, 14))\n",
        "        number_line.add_numbers()\n",
        "        number_line.set_width(FRAME_WIDTH - 1)\n",
        "        number_line.to_edge(UP, buff=1.5)\n",
        "        nl = number_line\n",
        "\n",
        "        mean = 7\n",
        "        m_dot = Dot(nl.n2p(mean))\n",
        "        m_dot.set_color(MEAN_COLOR)\n",
        "        m_label = OldTex(\"m\", color=MEAN_COLOR)\n",
        "        m_label.next_to(m_dot, UP, buff=MED_SMALL_BUFF)\n",
        "        label7 = OldTex(\"7\", color=MEAN_COLOR)\n",
        "\n",
        "        # Distance tracking\n",
        "        d_tracker = ValueTracker(4)\n",
        "\n",
        "        def get_l1_point():\n",
        "            return nl.n2p(mean - d_tracker.get_value())\n",
        "\n",
        "        def get_l2_point():\n",
        "            return nl.n2p(mean + d_tracker.get_value())\n",
        "\n",
        "        l1_dot, l2_dot = (Dot(color=TEAL) for x in range(2))\n",
        "        l1_label = OldTex(\"\\\\lambda_1\", color=EIGEN_COLORS[0])\n",
        "        l2_label = OldTex(\"\\\\lambda_2\", color=EIGEN_COLORS[1])\n",
        "        l1_arrow, l2_arrow = (Arrow(color=WHITE) for x in range(2))\n",
        "\n",
        "        l1_dot.add_updater(lambda m: m.move_to(get_l1_point()))\n",
        "        l2_dot.add_updater(lambda m: m.move_to(get_l2_point()))\n",
        "        always(l1_label.next_to, l1_dot, UP, buff=MED_SMALL_BUFF)\n",
        "        always(l2_label.next_to, l2_dot, UP, buff=MED_SMALL_BUFF)\n",
        "        m_label.match_y(l1_label)\n",
        "        l1_arrow.add_updater(lambda m: m.set_points_by_ends(\n",
        "            m_label.get_left() + SMALL_BUFF * LEFT, l1_label.get_right() + SMALL_BUFF * RIGHT,\n",
        "        ))\n",
        "        l2_arrow.add_updater(lambda m: m.set_points_by_ends(\n",
        "            m_label.get_right() + SMALL_BUFF * RIGHT, l2_label.get_left() + SMALL_BUFF * LEFT,\n",
        "        ))\n",
        "\n",
        "        minus_d = OldTex(\"-d\")\n",
        "        plus_d = OldTex(\"+d\")\n",
        "        always(minus_d.next_to, l1_arrow, UP, SMALL_BUFF)\n",
        "        always(plus_d.next_to, l2_arrow, UP, SMALL_BUFF)\n",
        "        plus_qm = OldTex(\"+??\")\n",
        "        minus_qm = OldTex(\"-??\")\n",
        "        always(plus_qm.move_to, plus_d)\n",
        "        always(minus_qm.move_to, minus_d)\n",
        "\n",
        "        VGroup(plus_d, minus_d).set_opacity(0)\n",
        "\n",
        "        label7.move_to(m_label)\n",
        "        self.add(number_line)\n",
        "        self.add(m_dot)\n",
        "        self.add(label7)\n",
        "        self.add(l1_dot)\n",
        "        self.add(l2_dot)\n",
        "        self.add(l1_label)\n",
        "        self.add(l2_label)\n",
        "        self.add(l1_arrow)\n",
        "        self.add(l2_arrow)\n",
        "        self.add(minus_d)\n",
        "        self.add(plus_d)\n",
        "        self.add(minus_qm)\n",
        "        self.add(plus_qm)\n",
        "\n",
        "        d_tracker.add_updater(lambda m: m.set_value(4 - 2.5 * np.sin(0.25 * self.time)))\n",
        "        self.add(d_tracker)\n",
        "        self.wait(20)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                Mobject(),\n",
        "                lambda m, a: VGroup(plus_d, minus_d).set_opacity(a),\n",
        "                remover=True\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                Mobject(),\n",
        "                lambda m, a: VGroup(plus_qm, minus_qm).set_opacity(1 - a),\n",
        "                remover=True\n",
        "            ),\n",
        "        )\n",
        "        self.remove(plus_qm, minus_qm)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Write the product\n",
        "        kw = {\"tex_to_color_map\": {\"\\\\,7\": MEAN_COLOR, \"d\": GREY_A, \"=\": WHITE, \"-\": WHITE}}\n",
        "        texs = VGroup(*(OldTex(tex, **kw) for tex in [\n",
        "            \"(\\\\,7 + d\\\\,)(\\\\,7 - d\\\\,)\",\n",
        "            \"\\\\,7^2 - d^2 = \",\n",
        "            \"40 =\",\n",
        "            \"d^2 = \\\\,7^2 - 40\",\n",
        "            \"d^2 = 9\",\n",
        "            \"d = 3\",\n",
        "        ]))\n",
        "        texs[:3].arrange(LEFT)\n",
        "        texs[1].align_to(texs[2], DOWN)\n",
        "        texs[:3].next_to(nl, DOWN, MED_LARGE_BUFF).to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        for t1, t2 in zip(texs[2:], texs[3:]):\n",
        "            t2.next_to(t1, DOWN, MED_LARGE_BUFF)\n",
        "            t2.shift((t1.get_part_by_tex(\"=\").get_x() - t2.get_part_by_tex(\"=\").get_x()) * RIGHT)\n",
        "\n",
        "        texs[0].save_state()\n",
        "        texs[0].move_to(texs[1], UL)\n",
        "\n",
        "        self.play(Write(VGroup(texs[2], texs[0])))\n",
        "        self.wait(3)\n",
        "        self.play(Restore(texs[0]))\n",
        "        self.play(TransformMatchingShapes(texs[0].copy(), texs[1], path_arc=45 * DEGREES))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(texs[2][0], texs[3][6], path_arc=-45 * DEGREES),\n",
        "            TransformFromCopy(texs[2][1], texs[3][2]),\n",
        "            TransformFromCopy(texs[1][:3], texs[3][3:6]),\n",
        "            TransformFromCopy(texs[1][3:5], texs[3][0:2], path_arc=45 * DEGREES),\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(texs[4], DOWN))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(texs[5], DOWN))\n",
        "\n",
        "        # Show final d geometrically\n",
        "        d_tracker.clear_updaters()\n",
        "        self.play(d_tracker.animate.set_value(3), rate_func=rush_into)\n",
        "        minus_d.clear_updaters()\n",
        "        plus_d.clear_updaters()\n",
        "\n",
        "        plus_3 = OldTex(\"+3\").move_to(plus_d)\n",
        "        minus_3 = OldTex(\"-3\").move_to(minus_d)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(minus_d, 0.25 * UP),\n",
        "                FadeOut(plus_d, 0.25 * UP),\n",
        "                lag_ratio=0.25\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(minus_3, 0.25 * UP),\n",
        "                FadeIn(plus_3, 0.25 * UP),\n",
        "                lag_ratio=0.25\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight solutions\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(VGroup(l1_label, nl.numbers[4])),\n",
        "            SurroundingRectangle(VGroup(l2_label, nl.numbers[10])),\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, rects), lag_ratio=0.3)\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(FadeOut, rects), lag_ratio=0.3)\n",
        "\n",
        "        # Replace with general variables\n",
        "        ms = VGroup(m_label.copy())\n",
        "        sevens = VGroup(label7)\n",
        "        ps = VGroup()\n",
        "        fourties = VGroup()\n",
        "        for tex in texs[:-2]:\n",
        "            for fourty in tex.get_parts_by_tex(\"40\"):\n",
        "                fourties.add(fourty)\n",
        "                ps.add(OldTex(\"p\").set_color(PROD_COLOR).move_to(fourty).shift(0.1 * DOWN))\n",
        "            for seven in tex.get_parts_by_tex(\"7\"):\n",
        "                sevens.add(seven)\n",
        "                m = OldTex(\"m\").set_color(MEAN_COLOR)\n",
        "                m.scale(0.95)\n",
        "                m.move_to(seven, DR)\n",
        "                m.shift(0.04 * RIGHT)\n",
        "                ms.add(m)\n",
        "        ps[0].shift(0.05 * RIGHT)\n",
        "        ps[1].shift(0.1 * LEFT)\n",
        "\n",
        "        for g1, g2 in ((sevens, ms), (fourties, ps)):\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeOut, g1, shift=0.25 * UP, lag_ratio=0.3),\n",
        "                LaggedStartMap(FadeIn, g2, shift=0.25 * UP, lag_ratio=0.3),\n",
        "                texs[-2:].animate.set_opacity(0)\n",
        "            )\n",
        "        self.remove(texs[-2:])\n",
        "        self.wait()\n",
        "        self.play(FlashUnder(texs[3]))\n",
        "        self.wait()\n",
        "\n",
        "        plus_form, minus_form = [\n",
        "            OldTex(\n",
        "                c + \"\\\\sqrt{\\\\,m^2 - p}\",\n",
        "                tex_to_color_map={\"m\": MEAN_COLOR, \"p\": PROD_COLOR},\n",
        "                font_size=24,\n",
        "            ).move_to(d, DOWN)\n",
        "            for c, d in [(\"+\", plus_d), (\"-\", minus_d)]\n",
        "        ]\n",
        "        pre_group = VGroup(*texs[3][4:6], ms[-1], ps[-1])\n",
        "        self.play(\n",
        "            TransformMatchingShapes(pre_group.copy(), minus_form),\n",
        "            TransformMatchingShapes(pre_group.copy(), plus_form),\n",
        "            FadeOut(VGroup(minus_3, plus_3), shift=0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskIfThatsBetter(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(height=2)\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.change(\"pondering\", UL)\n",
        "\n",
        "        self.add(BackgroundRectangle(randy, fill_opacity=1), randy)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, \"Is that better?\", target_mode=\"sassy\",\n",
        "                bubble_config={\"direction\": LEFT, \"width\": 4, \"height\": 2},\n",
        "                look_at=UL\n",
        "            )\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(randy, target_mode=\"thinking\")\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(randy.change(\"pondering\", UL))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OutstandingChannel(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, OldTexText(\"Outstanding\\\\\\\\channel\"), target_mode=\"hooray\",\n",
        "            bubble_config={\"height\": 3, \"width\": 4}\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class JingleAnimation(Scene):\n",
        "    def construct(self):\n",
        "        form = OldTex(\"m \\\\pm \\\\sqrt{m^2 - p}\")[0]\n",
        "        form.set_height(2)\n",
        "        m, old_pm, sqrt, root, m2, squared, minus, p = form\n",
        "        VGroup(m, m2).set_color(MEAN_COLOR)\n",
        "        VGroup(p).set_color(PROD_COLOR)\n",
        "        m.refresh_bounding_box()  # Why?\n",
        "        p.refresh_bounding_box()  # Why?\n",
        "\n",
        "        pm = VGroup(OldTex(\"+\"), OldTex(\"-\"))\n",
        "        pm.arrange(DOWN, buff=0)\n",
        "        pm.replace(old_pm)\n",
        "        pm.save_state()\n",
        "        pm.scale(1.5)\n",
        "        pm.arrange(DOWN, buff=2)\n",
        "\n",
        "        mean = Text(\"mean\", color=WHITE).next_to(m, DOWN)\n",
        "        product = Text(\"product\", color=WHITE).next_to(p, DOWN)\n",
        "        plus_word = Text(\"plus\", color=YELLOW).next_to(pm, UP)\n",
        "        minus_word = Text(\"minus\", color=YELLOW).next_to(pm, DOWN)\n",
        "\n",
        "        def snap(t):\n",
        "            return t**5\n",
        "\n",
        "        self.play(FadeIn(m, scale=0.5, rate_func=snap, run_time=0.5))\n",
        "        self.add(mean)\n",
        "        self.wait(0.4)\n",
        "        self.add(pm[0], plus_word)\n",
        "        self.wait(0.2)\n",
        "        self.add(pm[1], minus_word)\n",
        "        self.wait(0.2)\n",
        "        self.play(\n",
        "            Restore(pm, rate_func=smooth, run_time=0.5),\n",
        "            FadeOut(VGroup(plus_word, minus_word, mean), run_time=0.5),\n",
        "        )\n",
        "\n",
        "        sqrt_outline = sqrt.copy()\n",
        "        sqrt_outline.set_stroke(YELLOW, 10)\n",
        "        sqrt_outline.set_fill(opacity=0)\n",
        "        sqrt_outline.insert_n_curves(100)\n",
        "        root.save_state()\n",
        "        root.stretch(0, 0, about_edge=LEFT)\n",
        "        self.play(\n",
        "            FadeIn(sqrt, rate_func=squish_rate_func(smooth, 0.25, 0.75)),\n",
        "            VShowPassingFlash(sqrt_outline, time_width=2),\n",
        "            Restore(root, rate_func=squish_rate_func(snap, 0.25, 1)),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(m, m2, path_arc=-120 * DEGREES, rate_func=smooth, run_time=0.6),\n",
        "        )\n",
        "        self.play(FadeTransform(m2.copy(), squared, run_time=0.5))\n",
        "        minus.save_state()\n",
        "        minus.stretch(0, 0, about_edge=LEFT)\n",
        "        self.play(Restore(minus), run_time=0.5, rate_func=smooth)\n",
        "        self.wait(0.2)\n",
        "        self.play(\n",
        "            FadeIn(p, scale=0.5, rate_func=snap, run_time=0.5),\n",
        "        )\n",
        "        self.add(product)\n",
        "        self.wait(0.4)\n",
        "        self.play(\n",
        "            Flash(p, flash_radius=0.8 * p.get_height(), run_time=0.5),\n",
        "        )\n",
        "        self.wait(0.3)\n",
        "        self.remove(product)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Example1(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Show matrix\n",
        "        mat = IntegerMatrix([[3, 1], [4, 1]])\n",
        "        mat.set_column_colors(*COL_COLORS)\n",
        "        mat.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\", mat),\n",
        "            FadeIn(mat.get_brackets(), UP)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(mat.get_entries(), lag_ratio=0.1, run_time=2),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"thinking\", look_at=mat)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        bubble = ThoughtBubble(height=4, width=7)\n",
        "        bubble.pin_to(self.students[2])\n",
        "        self.play(\n",
        "            self.students[2].change(\"tease\", bubble),\n",
        "            Write(bubble)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Write formula\n",
        "        shift_vect = 5 * LEFT\n",
        "        arrow = Vector(0.75 * RIGHT)\n",
        "        arrow.next_to(mat, RIGHT)\n",
        "        formula = OldTex(\n",
        "            \"\\\\lambda_1, \\\\, \\\\lambda_2 = {2} \\\\pm \\\\sqrt{\\\\,{2}^2 - (-1)}\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "                \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "                \"(-1)\": PROD_COLOR,\n",
        "                \"{2}\": MEAN_COLOR,\n",
        "            }\n",
        "        )\n",
        "        formula.next_to(arrow, RIGHT)\n",
        "        VGroup(formula, arrow).shift(shift_vect)\n",
        "\n",
        "        twos = formula.get_parts_by_tex(\"{2}\")\n",
        "        min1 = formula.get_part_by_tex(\"(-1)\")\n",
        "        m_rects = VGroup(*(SurroundingRectangle(two, buff=0) for two in twos))\n",
        "        m_rects.set_stroke(MEAN_COLOR)\n",
        "        p_rect = SurroundingRectangle(min1, buff=0)\n",
        "        p_rect.set_stroke(PROD_COLOR)\n",
        "        form_rects = VGroup(m_rects, p_rect)\n",
        "        VGroup(twos, min1).set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            mat.animate.shift(shift_vect),\n",
        "            FadeIn(arrow, shift_vect),\n",
        "            FadeIn(formula),\n",
        "            FadeIn(form_rects),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"pondering\", look_at=ORIGIN)\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change(\"tease\", formula),\n",
        "            *(pi.animate.look_at(formula) for pi in self.students),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show mean\n",
        "        m_eq = OldTex(\"m\", \"=\", \"2\", tex_to_color_map={\"m\": MEAN_COLOR, \"2\": MEAN_COLOR})\n",
        "        m_eq.next_to(mat, UP, LARGE_BUFF)\n",
        "        t2c = {\n",
        "            \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "            \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "            \"{m}\": MEAN_COLOR,\n",
        "            \"{p}\": PROD_COLOR,\n",
        "            \"=\": WHITE,\n",
        "        }\n",
        "        diag_rects = VGroup(*(SurroundingRectangle(mat.get_entries()[i]) for i in [0, 3]))\n",
        "        diag_rects.set_stroke(MEAN_COLOR)\n",
        "        two_rect = SurroundingRectangle(m_eq[2])\n",
        "        two_rect.set_stroke(MEAN_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            Write(m_eq[:2]),\n",
        "            *(pi.animate.look_at(m_eq) for pi in self.pi_creatures)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(diag_rects),\n",
        "            self.teacher.change(\"tease\", diag_rects),\n",
        "            *(pi.animate.look_at(diag_rects) for pi in self.students),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(diag_rects[0].copy(), m_eq[2], remover=True),\n",
        "            FadeTransform(diag_rects[1].copy(), m_eq[2], remover=True),\n",
        "            *(pi.animate.look_at(two_rect) for pi in self.pi_creatures),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.remove(twos, min1)\n",
        "        VGroup(twos, min1).set_opacity(1)\n",
        "        for i in (0, 1):\n",
        "            self.play(\n",
        "                TransformFromCopy(m_eq[2], twos[i]),\n",
        "                FadeOut(m_rects[i]),\n",
        "                self.teacher.change(\"raise_right_hand\", twos),\n",
        "                *(pi.change(\"thinking\", twos) for pi in self.students)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show product\n",
        "        prod_eq = OldTex(\n",
        "            # \"\\\\lambda_1 \\\\lambda_2 =\",\n",
        "            \"{p} = {3} - {4} = -1\",\n",
        "            tex_to_color_map={\n",
        "                \"{3}\": COL_COLORS[0],\n",
        "                \"{4}\": COL_COLORS[0],\n",
        "                **t2c\n",
        "            }\n",
        "        )\n",
        "        prod_eq.next_to(mat, UP, LARGE_BUFF)\n",
        "        prod_eq.set_x(mat.get_center()[0], LEFT)\n",
        "\n",
        "        lhs = prod_eq[:1]\n",
        "\n",
        "        self.play(\n",
        "            m_eq.animate.scale(0.7).next_to(mat, LEFT).to_edge(LEFT),\n",
        "            FadeIn(lhs),\n",
        "            FadeOut(diag_rects),\n",
        "            self.teacher.change(\"happy\"),\n",
        "            self.change_students(\"erm\", \"hesitant\", \"thinking\", look_at=prod_eq)\n",
        "        )\n",
        "        self.play(det_path_anim(mat, run_time=1))\n",
        "        self.play(\n",
        "            FadeIn(prod_eq[1]),\n",
        "            FadeTransform(mat.get_entries()[0].copy(), prod_eq[2]),\n",
        "            FadeTransform(mat.get_entries()[3].copy(), prod_eq[2]),\n",
        "            VFadeInThenOut(VGroup(*(SurroundingRectangle(e) for e in mat.get_entries()[0::3]))),\n",
        "            self.teacher.change(\"coin_flip_1\"),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(prod_eq[3]),\n",
        "            FadeTransform(mat.get_entries()[1].copy(), prod_eq[4]),\n",
        "            FadeTransform(mat.get_entries()[2].copy(), prod_eq[4]),\n",
        "            VFadeInThenOut(VGroup(*(SurroundingRectangle(e) for e in mat.get_entries()[1:3]))),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(prod_eq[-2:]),\n",
        "            self.change_students(\"tease\", \"tease\", \"happy\", look_at=prod_eq.get_right()),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(p_rect),\n",
        "            FadeTransform(prod_eq[-1].copy(), min1),\n",
        "            self.teacher.change(\"raise_left_hand\", min1),\n",
        "            *(pi.animate.look_at(min1) for pi in self.students)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            prod_eq.animate.scale(0.7).next_to(m_eq, UP).to_edge(LEFT)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Final answer\n",
        "        rhs = OldTex(\"2\\\\pm\\\\sqrt{5}\")\n",
        "        rhs.move_to(formula[4], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"tease\", rhs),\n",
        "            TransformMatchingShapes(formula[4:6].copy(), rhs),\n",
        "            formula[4:].animate.shift(UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SameExampleWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screen = ScreenRectangle()\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.set_stroke(BLUE, 3)\n",
        "        screen.set_height(6)\n",
        "        screen.to_edge(DOWN)\n",
        "        title = Text(\"Same example from before\")\n",
        "        title.next_to(screen, UP)\n",
        "        self.add(screen, title)\n",
        "\n",
        "\n",
        "class GeneralExample(Scene):\n",
        "    matrix = [[3, 1], [4, 1]]\n",
        "\n",
        "    def construct(self):\n",
        "        mat = IntegerMatrix(self.matrix)\n",
        "        mat.move_to(2 * LEFT)\n",
        "        mat.set_column_colors(*COL_COLORS)\n",
        "\n",
        "        matrix = np.array(self.matrix)\n",
        "        a, b, c, d = matrix.flatten()\n",
        "\n",
        "        mean = (a + d) / 2\n",
        "        if (a + d) % 2 == 0:\n",
        "            mean = int(mean)\n",
        "        prod = a * d - b * c\n",
        "        mean_str = \"{\" + str(mean) + \"}\"\n",
        "        prod_str = \"{\" + str(prod) + \"}\"\n",
        "\n",
        "        self.add(mat)\n",
        "        self.wait()\n",
        "\n",
        "        mean_eq = OldTex(f\"m = {mean_str}\", tex_to_color_map={\"m\": MEAN_COLOR, mean_str: MEAN_COLOR})\n",
        "        mean_eq.next_to(mat, UP, LARGE_BUFF)\n",
        "        diag_rects = get_diag_rects(mat)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(mean_eq[:2], 0.25 * UP)\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, diag_rects, lag_ratio=0.3, run_time=1))\n",
        "        self.play(\n",
        "            FadeTransform(diag_rects[0].copy(), mean_eq[2]),\n",
        "            FadeTransform(diag_rects[1].copy(), mean_eq[2]),\n",
        "        )\n",
        "        self.play(FadeOut(diag_rects))\n",
        "\n",
        "        last_part = \"(\" + prod_str + \")}\" if prod < 0 else prod_str + \"}\"\n",
        "        formula = OldTex(\n",
        "            mean_str, \"\\\\pm \\\\sqrt{\\\\,\", mean_str, \"^2 - \", last_part,\n",
        "            font_size=60,\n",
        "            tex_to_color_map={mean_str: MEAN_COLOR, prod_str: PROD_COLOR},\n",
        "        )\n",
        "        formula.next_to(mat, RIGHT, buff=1.5)\n",
        "\n",
        "        self.play(\n",
        "            Write(formula[1]),\n",
        "            Write(formula[3]),\n",
        "            FadeTransform(mean_eq[2].copy(), formula[0]),\n",
        "            FadeTransform(mean_eq[2].copy(), formula[2]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Product\n",
        "        prod_eq = OldTex(\n",
        "            f\"p = {a * d} - {b * c} = {prod}\",\n",
        "            tex_to_color_map={\n",
        "                str(prod): PROD_COLOR,\n",
        "                str(a * d): COL_COLORS[0],\n",
        "                str(b * c): COL_COLORS[0],\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        prod_eq.move_to(mean_eq)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(prod_eq[:2]),\n",
        "            mean_eq.animate.shift(UP),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(prod_eq[2]),\n",
        "            VFadeInThenOut(get_diag_rects(mat, color=YELLOW), run_time=1.5),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(prod_eq[3:5]),\n",
        "            VFadeInThenOut(get_diag_rects(mat, color=YELLOW, off_diagonal=True), run_time=1.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(prod_eq[5:]))\n",
        "        self.play(FadeTransform(prod_eq[-1].copy(), formula[4:]))\n",
        "        self.wait()\n",
        "\n",
        "        # Simplify\n",
        "        line2 = OldTex(mean_str, \"\\\\pm\", \"\\\\sqrt{\\\\,\", str(mean**2 - prod), \"}\", font_size=60)\n",
        "        if mean == 0:\n",
        "            line2[0].scale(0, about_point=line2[1].get_left())\n",
        "        line2[0].set_color(MEAN_COLOR)\n",
        "        line2.next_to(formula, DOWN, buff=0.7, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(FadeTransform(formula.copy()[:4], line2))\n",
        "        self.wait()\n",
        "\n",
        "        line3 = self.get_final_simplification()\n",
        "        if line3:\n",
        "            line3.next_to(line2, DOWN, buff=0.7, aligned_edge=LEFT)\n",
        "            self.play(FadeIn(line3, DOWN))\n",
        "            self.wait()\n",
        "            answer = line3[-1]\n",
        "        else:\n",
        "            answer = line2\n",
        "        self.play(ShowCreation(SurroundingRectangle(answer)))\n",
        "        self.wait()\n",
        "\n",
        "    def get_final_simplification(self):\n",
        "        return None\n",
        "\n",
        "\n",
        "class Example2(GeneralExample):\n",
        "    matrix = [[2, 7], [1, 8]]\n",
        "\n",
        "    def get_final_simplification(self):\n",
        "        return OldTex(\"5 \\\\pm 4\", \"=\", \"9,\\\\,1\", font_size=60)\n",
        "\n",
        "\n",
        "class Example3(GeneralExample):\n",
        "    matrix = [[3, 11], [1, 11]]\n",
        "\n",
        "\n",
        "class Example4(GeneralExample):\n",
        "    matrix = [[2, -1], [2, 0]]\n",
        "\n",
        "\n",
        "class Example5(GeneralExample):\n",
        "    matrix = [[2, 3], [5, 7]]\n",
        "\n",
        "\n",
        "class PauliMatrices(Scene):\n",
        "    def construct(self):\n",
        "        self.camera.frame.focal_distance = 20\n",
        "\n",
        "        # Matrices\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "        lhss, matrices = self.get_lhss_and_matrices(colors)\n",
        "\n",
        "        self.add(lhss)\n",
        "        self.play(LaggedStartMap(FadeIn, matrices, shift=0.25 * RIGHT, lag_ratio=0.3, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Title\n",
        "        title = Text(\"Pauli spin matrices\")\n",
        "        title.next_to(group, RIGHT, buff=1.25)\n",
        "        self.play(Write(title, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Axes\n",
        "        axes = ThreeDAxes(\n",
        "            (-2, 2), (-2, 2), (-2, 2),\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        axes.set_flat_stroke(False)\n",
        "        axes.rotate(20 * DEGREES, OUT)\n",
        "        axes.rotate(70 * DEGREES, LEFT)\n",
        "        axes.set_height(1.7)\n",
        "        axes.labels = VGroup(*(\n",
        "            OldTex(ch, font_size=24).next_to(axis.get_end(), vect, buff=SMALL_BUFF)\n",
        "            for ch, axis, vect in zip(\"xyz\", axes.get_axes(), [RIGHT, UP, UP])\n",
        "        ))\n",
        "        axes.add(axes.labels)\n",
        "        axes.set_stroke(background=True)\n",
        "\n",
        "        axes_copies = VGroup()\n",
        "        for i, matrix, color, (v1, v2) in zip(it.count(), matrices, colors, [(UP, DOWN), (LEFT, RIGHT), (RIGHT, RIGHT)]):\n",
        "            ac = axes.deepcopy()\n",
        "            ac.labels.set_fill(GREY_C, 1)\n",
        "            ac.labels[i].set_fill(color, 1)\n",
        "            axis = ac.get_axes()[i]\n",
        "            vp1, vm1 = (\n",
        "                Arrow(axis.n2p(0), axis.n2p(n), buff=0.05, fill_color=color, thickness=0.05)\n",
        "                for n in (2, -2)\n",
        "            )\n",
        "            for vector, tex, v in [(vp1, \"+1\", v1), (vm1, \"-1\", v2)]:\n",
        "                vector.add(OldTex(tex, font_size=24).next_to(vector, v, buff=0.05))\n",
        "            ac.add(vp1, vm1)\n",
        "            ac.next_to(matrix, RIGHT, buff=LARGE_BUFF)\n",
        "            axes_copies.add(ac)\n",
        "\n",
        "        acx, acy, acz = axes_copies\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            Write(acx, stroke_width=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(acx, acy))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(acy, acz))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, axes_copies, shift=0.25 * DOWN, run_time=1, lag_ratio=0.3))\n",
        "\n",
        "        # Compute means\n",
        "        means_rects = VGroup(*(\n",
        "            get_diag_rects(matrix)\n",
        "            for matrix in matrices\n",
        "        ))\n",
        "        mean_eqs = VGroup(*(\n",
        "            OldTex(\"m = 0\", tex_to_color_map={\"m\": MEAN_COLOR, \"0\": WHITE}).next_to(matrix, RIGHT, buff=MED_LARGE_BUFF)\n",
        "            for matrix in matrices\n",
        "        ))\n",
        "\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"0\": MEAN_COLOR,\n",
        "                \"{p}\": PROD_COLOR,\n",
        "            }\n",
        "        }\n",
        "        forms = VGroup(*(\n",
        "            OldTex(\"0 \\\\pm \\\\sqrt{\\\\,0^2 - {p}}\", **kw).next_to(matrix, RIGHT).to_edge(RIGHT)\n",
        "            for matrix in matrices\n",
        "        ))\n",
        "        simple_forms = VGroup(*(\n",
        "            OldTex(\"\\\\pm \\\\sqrt{-{p}}\", **kw).move_to(form, LEFT)\n",
        "            for form in forms\n",
        "        ))\n",
        "\n",
        "        for me, mr, form in zip(mean_eqs, means_rects, forms):\n",
        "            self.play(\n",
        "                FadeIn(mr),\n",
        "                Write(me[:2], run_time=1),\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(mr, me[2], run_time=0.7)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeIn(VGroup(form[1], form[3], form[4]))\n",
        "                for form in forms\n",
        "            ), lag_ratio=0.2),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(me.get_parts_by_tex(\"0\"), form.get_parts_by_tex(\"0\"))\n",
        "                for me, form in zip(mean_eqs, forms)\n",
        "            ), lag_ratio=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            TransformMatchingShapes(form, simple_form)\n",
        "            for form, simple_form in zip(forms, simple_forms)\n",
        "        )))\n",
        "        self.wait()\n",
        "\n",
        "        # Products\n",
        "        prod_eqs = VGroup(*(\n",
        "            OldTex(\"p = -1\", tex_to_color_map={\"p\": PROD_COLOR, \"-1\": WHITE}).next_to(\n",
        "                matrix, RIGHT, buff=MED_LARGE_BUFF\n",
        "            ).shift(0.5 * DOWN)\n",
        "            for matrix in matrices\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            mean_eqs.animate.shift(0.5 * UP),\n",
        "            LaggedStart(*(FadeIn(pe[:2]) for pe in prod_eqs)),\n",
        "            FadeOut(means_rects)\n",
        "        )\n",
        "        self.play(LaggedStart(*(det_path_anim(matrix) for matrix in matrices), lag_ratio=0.2))\n",
        "\n",
        "        for matrix, pe in zip(matrices, prod_eqs):\n",
        "            r1 = get_diag_rects(matrix)\n",
        "            r2 = get_diag_rects(matrix, off_diagonal=True)\n",
        "            VGroup(r1, r2).set_color(YELLOW)\n",
        "            self.play(FadeIn(r1))\n",
        "            self.play(FadeOut(r1), FadeIn(r2), FadeIn(pe[2]))\n",
        "            self.play(FadeOut(r2))\n",
        "            self.wait()\n",
        "\n",
        "        final_forms = VGroup(*(\n",
        "            OldTex(\"= \\\\pm 1\").move_to(sf.get_center(), LEFT)\n",
        "            for sf in simple_forms\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(pe[2].copy(), ff)\n",
        "                for pe, ff in zip(prod_eqs, final_forms)\n",
        "            ), lag_ratio=0.3),\n",
        "            LaggedStart(*(\n",
        "                sf.animate.next_to(ff, LEFT)\n",
        "                for sf, ff in zip(simple_forms, final_forms)\n",
        "            ))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring back axes\n",
        "        axes_copies.shift(2 * RIGHT)\n",
        "        self.play(\n",
        "            FadeOut(simple_forms), FadeOut(final_forms),\n",
        "            FadeIn(acx),\n",
        "        )\n",
        "        self.play(FadeIn(acy))\n",
        "        self.play(FadeIn(acz))\n",
        "        self.wait()\n",
        "\n",
        "    def get_lhss_and_matrices(self, colors):\n",
        "        lhss = VGroup(*(OldTex(f\"\\\\sigma_{c} = \") for c in \"xyz\"))\n",
        "        kw = {\"h_buff\": 0.7, \"v_buff\": 0.7}\n",
        "        matrices = VGroup(\n",
        "            Matrix([[\"0\", \"1\"], [\"1\", \"0\"]], **kw),\n",
        "            Matrix([[\"0\", \"-i\"], [\"i\", \"0\"]], **kw),\n",
        "            Matrix([[\"1\", \"0\"], [\"0\", \"-1\"]], **kw),\n",
        "        )\n",
        "        lhss.set_submobject_colors_by_gradient(*colors)\n",
        "        lhss.arrange(DOWN, buff=2.5)\n",
        "        for lhs, matrix in zip(lhss, matrices):\n",
        "            matrix.set_height(1.5)\n",
        "            matrix.next_to(lhs, RIGHT)\n",
        "\n",
        "        group = VGroup(lhss, matrices)\n",
        "        group.move_to(2 * LEFT)\n",
        "        return group\n",
        "\n",
        "\n",
        "class SpinMeasurements(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Reorient\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-70, 70)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(0.01 * dt))\n",
        "        self.add(frame)\n",
        "\n",
        "        # Create machine\n",
        "        north_verts = [UL + 0.5 * DOWN, UR + 0.5 * DOWN, DR, 2 * DOWN, DL]\n",
        "        south_verts = [DOWN + 2 * LEFT, UP + 2 * LEFT, UL, LEFT, RIGHT, UR, UP + 2 * RIGHT, DOWN + 2 * RIGHT]\n",
        "\n",
        "        north_bar = get_prism(north_verts, depth=2)\n",
        "        south_bar = get_prism(south_verts, depth=2)\n",
        "        N_text = Text(\"N\").move_to(north_bar, OUT).shift(0.025 * OUT)\n",
        "        S_text = Text(\"S\").move_to(south_bar, OUT).shift(0.025 * OUT)\n",
        "        S_text.set_y(-0.5)\n",
        "        north_bar.add(N_text)\n",
        "        south_bar.add(S_text)\n",
        "        south_bar.move_to(ORIGIN, UP).shift(0.5 * UP)\n",
        "        north_bar.move_to(south_bar.get_top(), DOWN)\n",
        "\n",
        "        machine = VGroup(north_bar, south_bar)\n",
        "        machine.set_stroke(width=0)\n",
        "        # for bar in machine:\n",
        "        #     bar.space_out_submobjects(1.1)\n",
        "\n",
        "        # Screen\n",
        "        screen = FullScreenRectangle()\n",
        "        axes = Axes((-3, 3), (-3, 3))\n",
        "        for sm in axes.get_family():\n",
        "            sm.flat_stroke = False\n",
        "            sm.insert_n_curves(10)\n",
        "        axes.add(OldTex(\"+z\").next_to(axes.c2p(0, 2), RIGHT))\n",
        "        axes.add(OldTex(\"-z\").next_to(axes.c2p(0, -2), RIGHT))\n",
        "        axes.shift(0.1 * OUT)\n",
        "        screen.set_height(5)\n",
        "        screen.set_fill(GREY_D, 1)\n",
        "        screen.set_stroke(WHITE, 2)\n",
        "        screen.shift(5 * IN)\n",
        "        axes.shift(5 * IN)\n",
        "\n",
        "        # Rotate all\n",
        "        everything = VGroup(screen, axes, machine)\n",
        "        everything.apply_depth_test()\n",
        "        self.add(everything)\n",
        "        self.update_frame()  # Why?\n",
        "        everything.rotate(89.5 * DEGREES, RIGHT, about_point=ORIGIN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(screen),\n",
        "            FadeIn(axes),\n",
        "            FadeIn(machine, lag_ratio=0.05),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Paths\n",
        "        def path(t):\n",
        "            if t < -1:\n",
        "                z = 0\n",
        "            elif t < 1:\n",
        "                z = (1 / 4) * (t + 1)**2\n",
        "            else:\n",
        "                z = t\n",
        "\n",
        "            return [0, t, z]\n",
        "\n",
        "        high_beam = ParametricCurve(path, (-5, 5))\n",
        "        high_beam.set_stroke(BLUE, 10)\n",
        "        high_beam.set_depth(1, stretch=True, about_point=ORIGIN)\n",
        "        high_beam.apply_depth_test()\n",
        "        low_beam = high_beam.copy()\n",
        "        low_beam.stretch(-1, 2, about_point=ORIGIN)\n",
        "\n",
        "        def hit_anim(spin=1):\n",
        "            circ = Circle(radius=0.5)\n",
        "            circ.set_stroke(BLUE, 0)\n",
        "            circ.rotate(90 * DEGREES, RIGHT)\n",
        "            circ.move_to(5 * UP + spin * OUT)\n",
        "            tex = OldTex(\"+1\" if spin == 1 else \"-1\")\n",
        "            tex.shift(20 * OUT)\n",
        "            self.add(tex)\n",
        "            self.update_frame()\n",
        "            tex.rotate(90 * DEGREES, RIGHT)\n",
        "            tex.move_to(circ.get_left())\n",
        "            pre_circ = circ.copy()\n",
        "            pre_circ.scale(0)\n",
        "            pre_circ.set_stroke(BLUE, 10)\n",
        "            return AnimationGroup(\n",
        "                Transform(pre_circ, circ, remover=True),\n",
        "                VFadeInThenOut(tex),\n",
        "            )\n",
        "\n",
        "        for x in range(20):\n",
        "            if random.random() < 0.5:\n",
        "                beam = high_beam\n",
        "                spin = +1\n",
        "            else:\n",
        "                beam = low_beam\n",
        "                spin = -1\n",
        "            self.play(LaggedStart(\n",
        "                VShowPassingFlash(beam, time_width=0.5),\n",
        "                hit_anim(spin),\n",
        "                lag_ratio=0.6\n",
        "            ))\n",
        "\n",
        "\n",
        "class HeresTheThing(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait, why?\",\n",
        "            target_mode=\"raise_right_hand\",\n",
        "            look_at=self.screen,\n",
        "            index=2,\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(\"maybe\", \"confused\", \"raise_right_hand\", look_at=self.screen),\n",
        "            self.teacher.change(\"happy\"),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Here's the thing...\"),\n",
        "            added_anims=[self.change_students(\"sassy\", \"plain\", \"hesitant\")],\n",
        "            target_mode=\"hesitant\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(RemovePiCreatureBubble(self.teacher, target_mode=\"raise_right_hand\"))\n",
        "        for pi in self.pi_creatures:\n",
        "            for eye in pi.eyes:\n",
        "                eye.refresh_bounding_box()\n",
        "        self.look_at(self.screen)\n",
        "        self.play_student_changes(\"tease\", \"thinking\", \"happy\", look_at=self.screen)\n",
        "        self.wait(3)\n",
        "        words = OldTexText(\"Somewhat\\\\\\\\self-defeating\")\n",
        "        words.next_to(self.screen, RIGHT)\n",
        "        words.shift(RIGHT)\n",
        "        self.play(\n",
        "            self.teacher.change(\"guilty\"),\n",
        "            self.change_students(\"sassy\", \"hesitant\", \"sassy\"),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class NotAllHopeIsLost(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"There's still a\\\\\\\\good example here\"),\n",
        "            target_mode=\"speaking\",\n",
        "            bubble_config={\"height\": 3, \"width\": 4},\n",
        "            added_anims=[self.change_students(\"erm\", \"sassy\", \"hesitant\")],\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class PauliMatricesWithCharacteristicPolynomial(PauliMatrices):\n",
        "    def construct(self):\n",
        "        # Set up determinants\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "        lhss, matrices = group = self.get_lhss_and_matrices(colors)\n",
        "        group.to_edge(LEFT)\n",
        "\n",
        "        kw = {\n",
        "            \"element_to_mobject_config\": {\n",
        "                \"tex_to_color_map\": {\n",
        "                    \"-\\\\lambda\": EIGEN_COLORS[1],\n",
        "                }\n",
        "            },\n",
        "            \"v_buff\": 0.7,\n",
        "            \"h_buff\": 1.3,\n",
        "        }\n",
        "        new_matrices = VGroup(\n",
        "            Matrix([[\"-\\\\lambda\", \"1\"], [\"1\", \"-\\\\lambda\"]], **kw),\n",
        "            Matrix([[\"-\\\\lambda\", \"-i\"], [\"i\", \"-\\\\lambda\"]], **kw),\n",
        "            Matrix([[\"1 -\\\\lambda\", \"0\"], [\"0\", \"-1 -\\\\lambda\"]], **kw),\n",
        "        )\n",
        "        arrows = VGroup()\n",
        "        det_terms = VGroup()\n",
        "        for mat, new_mat in zip(matrices, new_matrices):\n",
        "            mat.set_height(1.0, about_edge=LEFT)\n",
        "            new_mat.replace(mat, dim_to_match=1)\n",
        "            new_mat.shift(3.75 * RIGHT)\n",
        "\n",
        "            parens = OldTex(\"()\", font_size=60)[0]\n",
        "            parens.match_height(new_mat, stretch=True)\n",
        "            parens[0].next_to(new_mat, LEFT, buff=0.1)\n",
        "            parens[1].next_to(new_mat, RIGHT, buff=0.1)\n",
        "            det = Text(\"det\", font_size=30)\n",
        "            det.next_to(parens, LEFT, SMALL_BUFF)\n",
        "\n",
        "            det_terms.add(VGroup(det, parens, new_mat))\n",
        "            arrows.add(Arrow(mat, det, buff=0.2))\n",
        "\n",
        "        self.add(lhss, matrices)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformMatchingShapes(mat.copy(), det_term)\n",
        "                for mat, det_term in zip(matrices, det_terms)\n",
        "            ), lag_ratio=0.8),\n",
        "            LaggedStartMap(GrowArrow, arrows, lag_ratio=0.8),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Polynomials\n",
        "        kw = {\"tex_to_color_map\": {\n",
        "            \"\\\\lambda\": EIGEN_COLORS[1],\n",
        "            \"=\": WHITE,\n",
        "        }}\n",
        "        rhss = VGroup(\n",
        "            OldTex(\"= \\\\lambda^2 - 1 = 0\", **kw),\n",
        "            OldTex(\"= \\\\lambda^2 - 1 = 0\", **kw),\n",
        "            OldTex(\"= (1 - \\\\lambda)(-1 - \\\\lambda) = 0\", **kw),\n",
        "        )\n",
        "\n",
        "        lpm1s = VGroup()\n",
        "        for rhs, det_term in zip(rhss, det_terms):\n",
        "            rhs.next_to(det_term, RIGHT, SMALL_BUFF, submobject_to_align=rhs[0])\n",
        "            self.play(LaggedStart(\n",
        "                det_path_anim(det_term[-1]),\n",
        "                TransformMatchingShapes(det_term[-1].get_entries().copy(), rhs),\n",
        "                lag_ratio=0.5\n",
        "            ))\n",
        "            if rhs is rhss[-1]:\n",
        "                continue\n",
        "\n",
        "            self.play(FlashUnder(rhs))\n",
        "            self.wait()\n",
        "            lpm1 = OldTex(\"\\\\lambda = \\\\pm 1\", **kw)\n",
        "            lpm1.next_to(rhs, DOWN, buff=0.75)\n",
        "            lpm1s.add(lpm1)\n",
        "            self.play(TransformMatchingShapes(rhs[1:4].copy(), lpm1))\n",
        "            self.wait()\n",
        "\n",
        "        # Comment on last\n",
        "        rect = SurroundingRectangle(matrices[2])\n",
        "        words = Text(\"Already diagonal!\", font_size=24)\n",
        "        words.next_to(rect, UP)\n",
        "        words.set_color(YELLOW)\n",
        "        diag_rects = get_diag_rects(matrices[2], color=EIGEN_COLORS[1])\n",
        "\n",
        "        self.play(FadeInFromLarge(rect))\n",
        "        self.play(Write(words, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(diag_rects))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            *arrows, *det_terms, *rhss, *lpm1s,\n",
        "            rect, words, diag_rects,\n",
        "        )))\n",
        "\n",
        "        # Show combinations\n",
        "        colors = [YELLOW_B, YELLOW_C, YELLOW_D]\n",
        "\n",
        "        def get_combo(triplet):\n",
        "            group = VGroup(\n",
        "                OldTex(\"a\"), triplet[0].copy(), OldTex(\"+\"),\n",
        "                OldTex(\"b\"), triplet[1].copy(), OldTex(\"+\"),\n",
        "                OldTex(\"c\"), triplet[2].copy()\n",
        "            )\n",
        "            group.arrange(RIGHT, buff=0.15)\n",
        "            group[3].align_to(group[0], DOWN)\n",
        "            group[6].align_to(group[0], DOWN)\n",
        "            group.set_color(WHITE)\n",
        "            group[0::3].set_submobject_colors_by_gradient(*colors)\n",
        "            return group\n",
        "\n",
        "        true_lhss = VGroup(*(lhs[0][:2] for lhs in lhss))\n",
        "        row1 = get_combo(true_lhss)\n",
        "        row1[1::3].shift(0.06 * DOWN)\n",
        "        row2 = get_combo(matrices)\n",
        "        rows = VGroup(row1, row2)\n",
        "        rows.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        rows.to_corner(UR, buff=LARGE_BUFF)\n",
        "\n",
        "        kw = {\"tex_to_color_map\": {\n",
        "            \"a\": colors[0],\n",
        "            \"b\": colors[1],\n",
        "            \"c\": colors[2],\n",
        "            \"\\\\lambda\": EIGEN_COLORS[1],\n",
        "        }}\n",
        "        normalized_eq = OldTex(\"\\\\left(a^2 + b^2 + c^2 = 1\\\\right)\", **kw)\n",
        "        normalized_eq.next_to(row2, DOWN, LARGE_BUFF)\n",
        "        normalized_eq.to_edge(DOWN)\n",
        "\n",
        "        full_mat = Matrix(\n",
        "            [\n",
        "                [\"c\", \"a - bi\"],\n",
        "                [\"a + bi\", \"-c\"],\n",
        "            ],\n",
        "            element_to_mobject_config=kw,\n",
        "            h_buff=1.5\n",
        "        )\n",
        "        full_mat.next_to(row2, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(TransformMatchingShapes(true_lhss.copy(), row1))\n",
        "        self.wait()\n",
        "        self.play(FadeTransformPieces(row1.copy(), row2))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(row2.copy(), full_mat))\n",
        "        self.wait()  # Let some physics happen\n",
        "        self.play(TransformMatchingShapes(row2[0::3].copy(), normalized_eq))\n",
        "        self.wait()\n",
        "\n",
        "        # Talk about eigen computations\n",
        "        self.play(FadeOut(lhss), FadeOut(matrices))\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.set_height(2)\n",
        "        randy.next_to(full_mat, LEFT).to_edge(DOWN)\n",
        "        randy.set_opacity(0)\n",
        "        diag_rects = get_diag_rects(full_mat)\n",
        "        bubble = ThoughtBubble(height=2, width=2)\n",
        "        bubble.pin_to(randy)\n",
        "        m_eq = OldTex(\"m = 0\", tex_to_color_map={\"m\": MEAN_COLOR})\n",
        "        p_eq = OldTex(\"p = ??\", tex_to_color_map={\"p\": PROD_COLOR})\n",
        "        bubble.position_mobject_inside(m_eq)\n",
        "        bubble.position_mobject_inside(p_eq)\n",
        "\n",
        "        p_eq2 = OldTex(\"p = -1\", tex_to_color_map={\"p\": PROD_COLOR})\n",
        "        p_eq2.next_to(full_mat, RIGHT, aligned_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(randy),\n",
        "            randy.animate.set_opacity(1).change(\"hesitant\", full_mat)\n",
        "        )\n",
        "        self.play(ShowCreation(diag_rects))\n",
        "        self.play(\n",
        "            Write(bubble),\n",
        "            Write(m_eq),\n",
        "            randy.change(\"pondering\", bubble)\n",
        "        )\n",
        "        self.play(randy.change(\"thinking\", bubble))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(p_eq, 0.25 * UP),\n",
        "            m_eq.animate.next_to(full_mat, RIGHT, aligned_edge=UP),\n",
        "            randy.change(\"hesitant\", full_mat),\n",
        "            FadeOut(diag_rects),\n",
        "        )\n",
        "        self.play(det_path_anim(full_mat))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            randy.change(\"tease\", p_eq2),\n",
        "            Transform(p_eq, p_eq2),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Characteristic polynomial\n",
        "        mod_mat = Matrix(\n",
        "            [\n",
        "                [\"c - \\\\lambda\", \"a - bi\"],\n",
        "                [\"a + bi\", \"-c - \\\\lambda\"],\n",
        "            ],\n",
        "            element_to_mobject_config=kw,\n",
        "            h_buff=2.0\n",
        "        )\n",
        "        parens = OldTex(\"(\", \")\")\n",
        "        parens.stretch(2, 1)\n",
        "        parens.match_height(mod_mat)\n",
        "        parens[0].next_to(mod_mat, LEFT, SMALL_BUFF)\n",
        "        parens[1].next_to(mod_mat, RIGHT, SMALL_BUFF)\n",
        "        det = Text(\"det\")\n",
        "        det.next_to(parens, LEFT, SMALL_BUFF)\n",
        "        char_poly = VGroup(det, parens, mod_mat)\n",
        "        char_poly.next_to(randy, UL)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(full_mat.copy(), char_poly, run_time=2),\n",
        "            randy.change(\"raise_left_hand\", char_poly),\n",
        "        )\n",
        "        self.play(randy.change(\"horrified\", char_poly))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change(\"tired\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeSpinExamples(Scene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.focal_distance = 20\n",
        "        frame.reorient(-20, 70)\n",
        "\n",
        "        axes = ThreeDAxes(\n",
        "            (-1, 1), (-1, 1), (-1, 1),\n",
        "            axis_config={\"tick_size\": 0, \"include_tip\": False}\n",
        "        )\n",
        "        axes.insert_n_curves(10)\n",
        "        axes.flat_stroke = False\n",
        "        axes.set_stroke(WHITE, 3)\n",
        "        axes.apply_depth_test()\n",
        "\n",
        "        all_axes = axes.get_grid(3, 1)\n",
        "        all_axes.arrange(IN, buff=0.8)\n",
        "        self.add(all_axes)\n",
        "\n",
        "        for axes, vect, color in zip(all_axes, [RIGHT, UP, OUT], [RED, GREEN, BLUE]):\n",
        "            sphere = Sphere()\n",
        "            sphere.scale(0.9)\n",
        "            mesh = SurfaceMesh(sphere, resolution=(21, 11))\n",
        "            mesh.set_stroke(color, width=1, opacity=0.8)\n",
        "            mesh.apply_matrix(z_to_vector(vect))\n",
        "            sphere = Group(sphere, mesh)\n",
        "            sphere.scale(0.5)\n",
        "            sphere.move_to(axes)\n",
        "            axes.sphere = sphere\n",
        "            sphere.vect = vect\n",
        "            sphere.add_updater(lambda m, dt: m.rotate(dt, m.vect))\n",
        "            self.add(sphere)\n",
        "\n",
        "        self.wait(2 * TAU)\n",
        "\n",
        "\n",
        "class GeneralDirection(Scene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-30, 70)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(0.01 * dt))\n",
        "        self.add(frame)\n",
        "\n",
        "        axes = ThreeDAxes(\n",
        "            (-2, 2), (-2, 2), (-4, 4),\n",
        "            axis_config={'include_tip': False},\n",
        "            depth=6,\n",
        "        )\n",
        "        axes.set_stroke(width=1)\n",
        "        self.add(axes)\n",
        "\n",
        "        vect = axes.c2p(2, 2, 2)\n",
        "        vector = Vector(vect)\n",
        "        vector.set_fill(YELLOW)\n",
        "\n",
        "        label = Matrix([[\"a\"], [\"b\"], [\"c\"]], v_buff=0.6)\n",
        "        # label.get_entries().set_submobject_colors_by_gradient(\n",
        "        #     YELLOW_B, YELLOW_C, YELLOW_D\n",
        "        # )\n",
        "        label.get_entries().set_color(YELLOW)\n",
        "        label.rotate(89 * DEGREES, RIGHT)\n",
        "        label.next_to(vector.get_end(), RIGHT)\n",
        "\n",
        "        sphere = Sphere()\n",
        "        sphere.scale(0.5)\n",
        "        mesh = SurfaceMesh(sphere, resolution=(21, 11))\n",
        "        mesh.set_stroke(BLUE, width=0.5, opacity=0.5)\n",
        "        for mob in sphere, mesh:\n",
        "            mob.apply_matrix(z_to_vector(vect))\n",
        "            mob.add_updater(lambda m, dt: m.rotate(0.75 * dt, axis=vect))\n",
        "\n",
        "        axes.apply_depth_test()\n",
        "        for sm in axes.get_family():\n",
        "            sm.insert_n_curves(10)\n",
        "\n",
        "        self.add(vector, sphere, mesh)\n",
        "        self.play(\n",
        "            GrowArrow(vector),\n",
        "            UpdateFromAlphaFunc(sphere, lambda m, a: m.set_opacity(a)),\n",
        "            Write(mesh),\n",
        "        )\n",
        "        self.play(Write(label))\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            vector.animate.scale(0.5, about_point=ORIGIN),\n",
        "            label.animate.shift(-0.5 * vect)\n",
        "        )\n",
        "        self.wait(24)\n",
        "\n",
        "\n",
        "class TwoValuesEvenlySpaceAroundZero(Scene):\n",
        "    def construct(self):\n",
        "        nl = NumberLine((-2, 2, 0.25), width=6)\n",
        "        nl.add_numbers(np.arange(-2, 3, 1.0), num_decimal_places=1, font_size=24)\n",
        "        d_tracker = ValueTracker(2)\n",
        "        get_d = d_tracker.get_value\n",
        "        dots = VGroup(*(Dot() for x in range(2)))\n",
        "        labels = VGroup(OldTex(\"\\\\lambda_1\"), OldTex(\"\\\\lambda_2\"))\n",
        "        for group in dots, labels:\n",
        "            group.set_submobject_colors_by_gradient(*EIGEN_COLORS)\n",
        "\n",
        "        def update_dots(dots):\n",
        "            dots[0].move_to(nl.n2p(-get_d()))\n",
        "            dots[1].move_to(nl.n2p(get_d()))\n",
        "\n",
        "        def update_labels(labels):\n",
        "            for label, dot in zip(labels, dots):\n",
        "                label.match_color(dot)\n",
        "                label.next_to(dot, UP, SMALL_BUFF)\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "        labels.add_updater(update_labels)\n",
        "\n",
        "        prod_label = VGroup(\n",
        "            labels.copy().clear_updaters().arrange(RIGHT, buff=SMALL_BUFF),\n",
        "            OldTex(\"=\"),\n",
        "            DecimalNumber(-4),\n",
        "        )\n",
        "        prod_label[-1].match_height(prod_label[0])\n",
        "        prod_label.arrange(RIGHT)\n",
        "        prod_label.next_to(labels, UP, LARGE_BUFF)\n",
        "        prod_label[-1].add_updater(lambda m: m.set_value(-get_d()**2))\n",
        "\n",
        "        self.add(nl, dots, labels, prod_label)\n",
        "\n",
        "        self.play(d_tracker.animate.set_value(0.5), run_time=3)\n",
        "        self.play(d_tracker.animate.set_value(1.5), run_time=3)\n",
        "        self.play(d_tracker.animate.set_value(1.0), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MPIsSolvingCharPoly(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\n",
        "            \"{m} \\\\pm \\\\sqrt{\\\\,{m}^2 - {p}}\",\n",
        "            tex_to_color_map={\"{m}\": MEAN_COLOR, \"{p}\": PROD_COLOR},\n",
        "            font_size=72\n",
        "        )\n",
        "        char_poly = get_det_mod_mat(get_mod_mat([[\"a\", \"b\"], [\"c\", \"d\"]]))\n",
        "        eq0 = OldTex(\"=0\")\n",
        "        eq0.next_to(char_poly, RIGHT, SMALL_BUFF)\n",
        "        char_poly.add(eq0)\n",
        "        char_poly.move_to(self.hold_up_spot, DOWN)\n",
        "        arrow = Arrow(RIGHT, LEFT)\n",
        "        arrow.next_to(char_poly, LEFT)\n",
        "\n",
        "        self.teacher_holds_up(formula)\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"thinking\", \"tease\",\n",
        "            look_at=formula\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change(\"hooray\", char_poly),\n",
        "            formula.animate.next_to(arrow, LEFT),\n",
        "            FadeIn(char_poly, 0.5 * UP),\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"pondering\", \"pondering\",\n",
        "            look_at=char_poly,\n",
        "            added_anims=[GrowArrow(arrow)]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class QuadraticPolynomials(Scene):\n",
        "    def construct(self):\n",
        "        # Set up equation\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"\\\\lambda_1\": EIGEN_COLORS[0],\n",
        "                \"\\\\lambda_2\": EIGEN_COLORS[1],\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        }\n",
        "        equation = VGroup(\n",
        "            OldTex(\"x^2 - 10x + 9\", **kw)[0],\n",
        "            OldTex(\"=\").rotate(PI / 2),\n",
        "            OldTex(\"x^2 - (\\\\lambda_1 + \\\\lambda_2)x + \\\\lambda_1 \\\\lambda_2\", **kw),\n",
        "            OldTex(\"=\").rotate(PI / 2),\n",
        "            OldTex(\"(x - \\\\lambda_1)(x - \\\\lambda_2)\", **kw),\n",
        "        )\n",
        "        equation.arrange(DOWN)\n",
        "        equation.to_edge(LEFT)\n",
        "        line1, eq1, line2, eq2, line3 = equation\n",
        "        for line in line2, line3:\n",
        "            line.set_submobjects(line.family_members_with_points())\n",
        "\n",
        "        line3.save_state()\n",
        "        line3.move_to(line2)\n",
        "\n",
        "        # Graph\n",
        "        axes = Axes(\n",
        "            (-5, 10),\n",
        "            (-20, 20),\n",
        "            height=7,\n",
        "            width=FRAME_WIDTH / 2,\n",
        "        )\n",
        "        axes.y_axis.ticks.stretch(0.75, 0)\n",
        "        axes.to_edge(RIGHT)\n",
        "        graph = axes.get_graph(lambda x: x**2 - 10 * x + 9)\n",
        "        graph.set_color(BLUE)\n",
        "        graph_label = line1.copy()\n",
        "        graph_label.set_color(BLUE)\n",
        "        graph_label.next_to(graph.get_end(), UP)\n",
        "        graph_label.to_edge(RIGHT)\n",
        "\n",
        "        root_dots = VGroup()\n",
        "        root_labels = VGroup()\n",
        "        for i, n, vect in zip((0, 1), (1, 9), (RIGHT, LEFT)):\n",
        "            dot = Dot(axes.c2p(n, 0), color=EIGEN_COLORS[i])\n",
        "            label = OldTex(f\"\\\\lambda_{i + 1}\")\n",
        "            label.match_color(dot)\n",
        "            label.next_to(dot, UP + vect, buff=0.05)\n",
        "            root_dots.add(dot)\n",
        "            root_labels.add(label)\n",
        "        root_dots.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(Write(axes))\n",
        "        self.play(\n",
        "            ShowCreation(graph, run_time=3),\n",
        "            FadeIn(graph_label, UP)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, root_dots),\n",
        "            LaggedStart(\n",
        "                GrowFromPoint(root_labels[0], root_dots[0].get_center()),\n",
        "                GrowFromPoint(root_labels[1], root_dots[1].get_center()),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Animate to equation\n",
        "        self.play(TransformFromCopy(graph_label, line1))\n",
        "        self.play(\n",
        "            Write(eq1),\n",
        "            TransformMatchingShapes(root_labels.copy(), line3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(line3))\n",
        "        xs = VGroup(line3[1], line3[7])\n",
        "        self.play(TransformFromCopy(xs, line2[:2]))  # x^2\n",
        "        self.play(LaggedStart(  # x\n",
        "            AnimationGroup(\n",
        "                TransformFromCopy(line3[1], line2[10].copy()),\n",
        "                TransformFromCopy(line3[9:11], line2[7:9]),\n",
        "                FadeIn(line2[2])\n",
        "            ),\n",
        "            AnimationGroup(\n",
        "                TransformFromCopy(line3[7], line2[10].copy(), remover=True),\n",
        "                TransformFromCopy(line3[3:5], line2[4:6]),\n",
        "                FadeIn(VGroup(line2[3], line2[6], line2[9]))\n",
        "            ),\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                VGroup(*line3[3:5], *line3[9:11]),\n",
        "                VGroup(*line2[12:16]),\n",
        "            ),\n",
        "            FadeIn(line2[11]),\n",
        "            FadeIn(eq2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight sum and product\n",
        "        for i, j, k, l in [(3, 5, 3, 10), (7, 8, 12, 16)]:\n",
        "            self.play(\n",
        "                FadeIn(SurroundingRectangle(line1[i:j])),\n",
        "                FadeIn(SurroundingRectangle(line2[k:l])),\n",
        "                run_time=2,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                remover=True\n",
        "            )\n",
        "\n",
        "        # Show mean and product\n",
        "        line2 = VGroup(*line2.family_members_with_points())\n",
        "        line3 = VGroup(*line3.family_members_with_points())\n",
        "        quad_terms = VGroup(line1[0:2], line2[0:2])\n",
        "        lin_terms = VGroup(line1[2:5], line2[2:10])\n",
        "        const_terms = VGroup(line1[6:], line2[11:])\n",
        "\n",
        "        mean_arrow = Vector(UP)\n",
        "        mean_arrow.next_to(lin_terms[0], UP, MED_SMALL_BUFF)\n",
        "        times_half = OldTex(\"\\\\times -\\\\frac{1}{2}\", font_size=24)\n",
        "        times_half.next_to(mean_arrow, RIGHT, buff=0)\n",
        "        m_eq = OldTex(\n",
        "            \"{\\\\lambda_1 + \\\\lambda_2 \\\\over 2}\", \"=\", \"5\",\n",
        "            tex_to_color_map={\"\\\\lambda_1\": EIGEN_COLORS[0], \"\\\\lambda_2\": EIGEN_COLORS[1]}\n",
        "        )\n",
        "        m_eq.next_to(mean_arrow, UP, SMALL_BUFF, submobject_to_align=m_eq[-1])\n",
        "        m_eq[:-2].scale(0.7, about_edge=RIGHT)\n",
        "        m_dot = Dot(axes.c2p(5, 0))\n",
        "        m_dot.scale(0.5)\n",
        "        m_label = Integer(5, font_size=30)\n",
        "        m_label.next_to(m_dot, UP, SMALL_BUFF)\n",
        "\n",
        "        p_rects = VGroup(*map(SurroundingRectangle, const_terms))\n",
        "        p_rects.set_stroke(PROD_COLOR)\n",
        "\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        fade_rect.set_fill(BLACK, 0.75)\n",
        "        fade_rect.replace(equation, stretch=True)\n",
        "\n",
        "        self.add(fade_rect, *quad_terms)\n",
        "        self.play(FadeIn(fade_rect))\n",
        "        self.wait()\n",
        "        self.add(fade_rect, *lin_terms)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(mean_arrow),\n",
        "            FadeIn(times_half, shift=0.25 * UP, scale=2),\n",
        "            FadeIn(m_eq[:-1])\n",
        "        )\n",
        "        self.play(Write(m_eq[-1]))\n",
        "        self.play(\n",
        "            FadeTransform(m_eq[-1].copy(), m_dot),\n",
        "            FadeTransform(m_eq[-1].copy(), m_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(fade_rect, *const_terms)\n",
        "        VGroup(mean_arrow, times_half).set_opacity(0.5)\n",
        "        self.play(ShowCreation(p_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # Show final roots\n",
        "        d_terms = VGroup(*(\n",
        "            OldTex(u, \"\\\\sqrt{25 - 9}\", font_size=24)\n",
        "            for u in [\"+\", \"-\"]\n",
        "        ))\n",
        "        my = m_label.get_y()\n",
        "        arrows = VGroup(\n",
        "            Arrow(m_label.get_left(), [root_dots[0].get_left()[0], my, 0], buff=0.1),\n",
        "            Arrow(m_label.get_right(), [root_dots[1].get_right()[0], my, 0], buff=0.1),\n",
        "        )\n",
        "        for d_term, arrow in zip(d_terms, arrows):\n",
        "            d_term.next_to(arrow, UP, buff=0)\n",
        "\n",
        "        self.play(FadeOut(p_rects))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(equation[0][-2:].copy(), d_terms),\n",
        "            FadeOut(root_labels),\n",
        "            *map(GrowArrow, arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(fade_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimplerQuadraticFormula(Scene):\n",
        "    def construct(self):\n",
        "        # Show comparison\n",
        "        form1 = OldTex(\n",
        "            \"{m} \\\\pm \\\\sqrt{\\\\,{m}^2 - {p}}\",\n",
        "            tex_to_color_map={\"{m}\": MEAN_COLOR, \"{p}\": PROD_COLOR},\n",
        "            font_size=72\n",
        "        )\n",
        "        words = OldTexText(\"takes less to\\\\\\\\remember than\")\n",
        "        form2 = OldTex(\n",
        "            \"{-b \\\\pm \\\\sqrt{\\\\,b^2 - 4ac} \\\\over 2a}\",\n",
        "            tex_to_color_map={\n",
        "                \"a\": MAROON_A,\n",
        "                \"b\": MAROON_B,\n",
        "                \"c\": MAROON_C,\n",
        "            },\n",
        "            font_size=72\n",
        "        )\n",
        "        group = VGroup(form1, words, form2)\n",
        "        group.arrange(DOWN, buff=1.5)\n",
        "\n",
        "        self.add(form1)\n",
        "        self.play(Write(words, run_time=1))\n",
        "        self.play(FadeIn(form2, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SkipTheMiddleStep(Scene):\n",
        "    def construct(self):\n",
        "        matrix = IntegerMatrix([[3, 1], [4, 1]])\n",
        "        matrix.set_column_colors(*COL_COLORS)\n",
        "        char_poly = OldTex(\n",
        "            \"\\\\lambda^2 - 4\\\\lambda - 1\",\n",
        "            tex_to_color_map={\"\\\\lambda\": EIGEN_COLORS[0]}\n",
        "        )\n",
        "        mp_formula = OldTex(\n",
        "            \"{2} \\\\pm \\\\sqrt{\\\\,{2}^2 - (-1)}\",\n",
        "            tex_to_color_map={\n",
        "                \"{2}\": MEAN_COLOR,\n",
        "                \"(-1)\": PROD_COLOR,\n",
        "            }\n",
        "        )\n",
        "\n",
        "        group = VGroup(matrix, char_poly, mp_formula)\n",
        "        group.arrange(RIGHT, buff=2)\n",
        "\n",
        "        mat_label, char_poly_label, eigen_label = labels = VGroup(\n",
        "            OldTexText(\"Matrix\"),\n",
        "            OldTexText(\"Characteristic\\\\\\\\polynomial\"),\n",
        "            OldTexText(\"Eigenvalues\"),\n",
        "        )\n",
        "        for label, mob, color in zip(labels, group, [COL_COLORS[0], EIGEN_COLORS[0], MEAN_COLOR]):\n",
        "            label.set_color(color)\n",
        "            label.next_to(mob, DOWN, MED_LARGE_BUFF)\n",
        "            label.align_to(labels[0], UP)\n",
        "\n",
        "        arc = -90 * DEGREES\n",
        "        arrows = VGroup(\n",
        "            Arrow(matrix.get_corner(UR), char_poly.get_top(), path_arc=arc),\n",
        "            Arrow(char_poly.get_top(), mp_formula.get_top(), path_arc=arc),\n",
        "            Arrow(matrix.get_corner(UR), mp_formula.get_top(), path_arc=0.8 * arc),\n",
        "        )\n",
        "        arrows.shift(0.5 * UP)\n",
        "\n",
        "        self.add(matrix, mat_label)\n",
        "        self.play(\n",
        "            DrawBorderThenFill(arrows[0]),\n",
        "            GrowFromPoint(char_poly, matrix.get_top(), path_arc=arc),\n",
        "            FadeTransform(mat_label.copy(), char_poly_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            DrawBorderThenFill(arrows[1]),\n",
        "            TransformFromCopy(char_poly, mp_formula),\n",
        "            FadeTransform(char_poly_label.copy(), eigen_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VFadeInThenOut(get_diag_rects(matrix), run_time=2),\n",
        "            LaggedStart(*(\n",
        "                ShowCreationThenFadeOut(SurroundingRectangle(sm, buff=0.1, color=WHITE), run_time=2)\n",
        "                for sm in mp_formula.get_parts_by_tex(\"{2}\")\n",
        "            ))\n",
        "        )\n",
        "        self.play(\n",
        "            det_path_anim(matrix),\n",
        "            ShowCreationThenFadeOut(SurroundingRectangle(\n",
        "                mp_formula.get_parts_by_tex(\"(-1)\"), buff=0.1, color=WHITE,\n",
        "            ), run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(arrows[0], arrows[2]),\n",
        "            Transform(arrows[1], arrows[2]),\n",
        "            VGroup(char_poly, char_poly_label).animate.set_opacity(0.15),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #\n",
        "        frame = self.camera.frame\n",
        "        quad_form = OldTex(\n",
        "            \"{-b \\\\pm \\\\sqrt{\\\\,b^2 - 4ac} \\\\over 2a}\",\n",
        "            tex_to_color_map={\n",
        "                \"a\": BLUE_B,\n",
        "                \"b\": BLUE_C,\n",
        "                \"c\": BLUE_D,\n",
        "            }\n",
        "        )\n",
        "        words = OldTexText(\"Never could\\\\\\\\have worked!\")\n",
        "        group = VGroup(quad_form, words)\n",
        "        group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        group.next_to(arrows, UP, LARGE_BUFF)\n",
        "        cross = Cross(quad_form)\n",
        "        cross.set_stroke(width=(1, 3, 3, 1))\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_y(1),\n",
        "            FadeIn(quad_form, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(cross)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GeneralCharPoly(Scene):\n",
        "    def construct(self):\n",
        "        t2c = {\n",
        "            \"a\": COL_COLORS[0],\n",
        "            \"b\": COL_COLORS[1],\n",
        "            \"c\": COL_COLORS[0],\n",
        "            \"d\": COL_COLORS[1],\n",
        "            \"\\\\lambda\": EIGEN_COLORS[1],\n",
        "            \"-\": WHITE,\n",
        "            \"+\": WHITE,\n",
        "            \"=\": WHITE,\n",
        "        }\n",
        "        det = get_det_mod_mat(get_mod_mat([[\"a\", \"b\"], [\"c\", \"d\"]], t2c=t2c))\n",
        "        rhs1 = OldTex(\"= (a - \\\\lambda)(d - \\\\lambda) - bc\", tex_to_color_map=t2c)\n",
        "        rhs2 = OldTex(\"= \\\\lambda^2 - (a + d)\\\\lambda + (ad - bc)\", tex_to_color_map=t2c)\n",
        "\n",
        "        rhs1.next_to(det, RIGHT)\n",
        "        rhs2.next_to(rhs1, DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        VGroup(det, rhs1, rhs2).center()\n",
        "\n",
        "        self.add(det)\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(\n",
        "            det[-1].get_entries()[0::3].copy(),\n",
        "            rhs1[:10],\n",
        "        ))\n",
        "        self.play(TransformMatchingShapes(\n",
        "            det[-1].get_entries()[1:3].copy(),\n",
        "            rhs1[10:],\n",
        "            path_arc=45 * DEGREES,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(rhs1.copy(), rhs2, run_time=1.5))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(SurroundingRectangle(rhs2[3:9], buff=0.05, color=MEAN_COLOR)))\n",
        "        self.play(ShowCreation(SurroundingRectangle(rhs2[11:], buff=0.05, color=PROD_COLOR)))\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass\n"
    ]
}