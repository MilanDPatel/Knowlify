{
    "topic": "demonstrates the concept of a quiz with multiple-choice questions and answers. The",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.blocks_and_grover.qc_supplements import *\n",
        "from _2025.blocks_and_grover.state_vectors import DisectAQuantumComputer\n",
        "\n",
        "\n",
        "class Quiz(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up terms\n",
        "        choices = VGroup(\n",
        "            TexText(R\"A) $\\mathcal{O}\\big(\\sqrt{N}\\big)$\"),\n",
        "            TexText(R\"B) $\\mathcal{O}\\big(\\log(N)\\big)$\"),\n",
        "            TexText(R\"C) $\\mathcal{O}\\big(\\log(\\log(N))\\big)$\"),\n",
        "            TexText(R\"D) $\\mathcal{O}(1)$\"),\n",
        "        )\n",
        "        choices.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        choices.to_edge(LEFT, buff=1.0)\n",
        "\n",
        "        covers = VGroup(\n",
        "            SurroundingRectangle(choice[2:], buff=SMALL_BUFF)\n",
        "            for choice in choices\n",
        "        )\n",
        "        covers.set_fill(GREY_D, 1)\n",
        "        covers.set_stroke(WHITE, 1)\n",
        "        for cover, choice in zip(covers, choices):\n",
        "            choice[2:].set_fill(opacity=0)\n",
        "            cover.set_width(choices.get_width(), about_edge=LEFT, stretch=True)\n",
        "            cover.align_to(covers, LEFT)\n",
        "            cover.save_state()\n",
        "            cover.stretch(0, 0, about_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, covers, lag_ratio=0.25),\n",
        "            LaggedStartMap(FadeIn, choices, lag_ratio=0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reference mostly wrong answers\n",
        "        pis = Randolph().get_grid(6, 6, buff=2.0)\n",
        "        pis.set_height(7)\n",
        "        pis.to_edge(RIGHT)\n",
        "        pis.sort(lambda p: np.dot(p, DR))\n",
        "\n",
        "        symbol_height = 0.35\n",
        "        symbols = [\n",
        "            Exmark().set_color(RED).set_height(symbol_height),\n",
        "            Checkmark().set_color(GREEN).set_height(symbol_height),\n",
        "        ]\n",
        "        all_symbols = VGroup()\n",
        "        for pi in pis:\n",
        "            pi.body.set_color(interpolate_color(BLUE_E, BLUE_C, random.random()))\n",
        "            pi.change_mode(\"pondering\")\n",
        "            correct = random.random() < 0.2\n",
        "            symbol = symbols[correct].copy()\n",
        "            symbol.next_to(pi, UR, buff=0)\n",
        "            all_symbols.add(symbol)\n",
        "            pi.generate_target()\n",
        "            pi.target.change_mode([\"sad\", \"hooray\"][correct])\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, pis, run_time=2))\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, pis, lag_ratio=0.01),\n",
        "            LaggedStartMap(Write, all_symbols, lag_ratio=0.01),\n",
        "        )\n",
        "        pis.shuffle()\n",
        "        self.play(LaggedStartMap(Blink, pis[::4]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(pis, lag_ratio=1e-3),\n",
        "            FadeOut(all_symbols, lag_ratio=1e-3),\n",
        "        )\n",
        "\n",
        "        # Show question\n",
        "        frame = self.frame\n",
        "\n",
        "        question = VGroup(\n",
        "            get_quantum_computer_symbol(),\n",
        "            Clock(),\n",
        "            Tex(R\"?\"),\n",
        "        )\n",
        "        for mob in question:\n",
        "            mob.set_height(1.5)\n",
        "        question.arrange(RIGHT, buff=0.5)\n",
        "        question.set_width(4)\n",
        "        question[2].scale(0.7)\n",
        "        question.next_to(choices, UP, aligned_edge=LEFT)\n",
        "\n",
        "        clock = question[1]\n",
        "        cycle_animation(ClockPassesTime(clock, hours_passed=12, run_time=24))\n",
        "        self.play(\n",
        "            VFadeIn(question, suspend_mobject_updating=True, lag_ratio=0.01),\n",
        "            VGroup(choices, covers).animate.shift(DOWN).set_anim_args(run_time=2),\n",
        "            frame.animate.match_x(choices).set_anim_args(run_time=2),\n",
        "        )\n",
        "        self.add(choices, Point(), covers)\n",
        "        choices.set_opacity(1)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (cover.animate.stretch(0, 0, about_edge=RIGHT).set_opacity(0)\n",
        "                for cover in covers),\n",
        "                lag_ratio=0.25,\n",
        "            ),\n",
        "        )\n",
        "        self.wait(16)\n",
        "\n",
        "        # Show distribution\n",
        "        question.clear_updaters()\n",
        "        dists = [\n",
        "            np.array([18, 20, 8, 54], dtype=float),\n",
        "            np.array([51, 55, 37, 65], dtype=float),  # Stanford\n",
        "            np.array([17, 25, 5, 39], dtype=float),   # IMO, IIRC\n",
        "        ]\n",
        "        for dist in dists:\n",
        "            dist[:] = dist / dist.sum()\n",
        "\n",
        "        max_bar_width = 5.0\n",
        "        prob_bar_group = VGroup()\n",
        "        for dist in dists:\n",
        "            prob_bars = VGroup()\n",
        "            for choice, prob in zip(choices, dist):\n",
        "                bar = Rectangle(width=prob * max_bar_width, height=0.35)\n",
        "                bar.next_to(choice, LEFT)\n",
        "                bar.set_fill(interpolate_color(BLUE_D, GREEN, prob * 1.5), 1)\n",
        "                bar.set_stroke(WHITE, 1)\n",
        "                prob_bars.add(bar)\n",
        "            prob_bar_group.add(prob_bars)\n",
        "\n",
        "        prob_bars = prob_bar_group[0].copy()\n",
        "\n",
        "        prob_labels = VGroup()\n",
        "        for bar in prob_bars:\n",
        "            label = Integer(100, font_size=36, unit=R\"\\%\")\n",
        "            label.bar = bar\n",
        "            label.add_updater(lambda m: m.set_value(np.round(100 * m.bar.get_width() / max_bar_width)))\n",
        "            label.add_updater(lambda m: m.next_to(m.bar, LEFT))\n",
        "            prob_labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (GrowFromPoint(bar, bar.get_right())\n",
        "                for bar in prob_bars),\n",
        "                lag_ratio=0.2,\n",
        "            ),\n",
        "            VFadeIn(prob_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "        for index in [1, 2, 0]:\n",
        "            self.play(Transform(prob_bars, prob_bar_group[index]))\n",
        "            self.wait()\n",
        "\n",
        "        # Go through each answer\n",
        "        covers = VGroup(\n",
        "            SurroundingRectangle(VGroup(bar, label, choice))\n",
        "            for bar, label, choice in zip(prob_bars, prob_labels, choices)\n",
        "        )\n",
        "        covers.set_stroke(width=0)\n",
        "        covers.set_fill(BLACK, 0.8)\n",
        "\n",
        "        self.add(Point())\n",
        "        self.play(FadeIn(covers[:3]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(covers[1]),\n",
        "            FadeIn(covers[3])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(covers[0]),\n",
        "            FadeIn(covers[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add two additional answers\n",
        "\n",
        "\n",
        "class ShowOptionGraphs(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        x_max = 15\n",
        "        axes = Axes((-1, x_max), (-1, x_max))\n",
        "        axes.set_height(7)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Add graphs\n",
        "        graphs = VGroup(\n",
        "            axes.get_graph(func, x_range=(0.01, x_max))\n",
        "            for func in [\n",
        "                lambda n: n,\n",
        "                lambda n: math.sqrt(n),\n",
        "                lambda n: 0.8 * math.log(n + 1),\n",
        "                lambda n: math.log(math.log(n + 1) + 1),\n",
        "                lambda n: 1,\n",
        "            ]\n",
        "        )\n",
        "        graphs.set_submobject_colors_by_gradient(YELLOW, ORANGE, RED, RED_E, BLUE)\n",
        "        labels = VGroup(\n",
        "            Tex(sym, font_size=30).match_color(graph).next_to(graph.get_end(), RIGHT, SMALL_BUFF)\n",
        "            for graph, sym in zip(graphs, [\n",
        "                R\"\\mathcal{O}\\left(N\\right)\",\n",
        "                R\"\\mathcal{O}\\left(\\sqrt{N}\\right)\",\n",
        "                R\"\\mathcal{O}\\left(\\log(N)\\right)\",\n",
        "                R\"\\mathcal{O}\\left(\\log(\\log(N))\\right)\",\n",
        "                R\"\\mathcal{O}\\left(1\\right)\",\n",
        "            ])\n",
        "        )\n",
        "        labels[-1].shift(2 * SMALL_BUFF * DOWN)\n",
        "\n",
        "        for graph, label in zip(graphs, labels):\n",
        "            vect = label.get_center() - graph.get_end()\n",
        "            self.play(\n",
        "                ShowCreation(graph),\n",
        "                VFadeIn(label),\n",
        "                UpdateFromFunc(label, lambda m: m.move_to(graph.get_end() + vect)),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NeedleInAHaystackProblem(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up terms\n",
        "        shown_numbers = list(range(20))\n",
        "        number_strs = list(map(str, shown_numbers))\n",
        "        number_set = Tex(\"\".join([\n",
        "            R\"\\{\",\n",
        "            *[str(n) + \",\" for n in shown_numbers],\n",
        "            R\"\\dots N - 1\"\n",
        "            R\"\\}\",\n",
        "        ]), isolate=number_strs)\n",
        "        number_mobs = VGroup(number_set[n_str][0] for n_str in number_strs)\n",
        "        number_set.set_width(FRAME_WIDTH - 1)\n",
        "        number_set.to_edge(UP)\n",
        "\n",
        "        machine = get_blackbox_machine()\n",
        "        machine.set_z_index(2)\n",
        "\n",
        "        self.play(FadeIn(number_set, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "\n",
        "        # Show mystery machine\n",
        "        q_marks = Tex(R\"???\", font_size=90)\n",
        "        q_marks.space_out_submobjects(1.2)\n",
        "        q_marks.next_to(machine, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(machine, scale=2),\n",
        "            Write(q_marks)\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeOut, q_marks, shift=0.25 * DOWN, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Plug in key value\n",
        "        key_number = 12\n",
        "        key_input = number_mobs[key_number]\n",
        "        key_icon = SVGMobject(\"key\").rotate(135 * DEG)\n",
        "        key_icon.set_fill(YELLOW)\n",
        "        key_icon.match_width(key_input)\n",
        "        key_icon.next_to(key_input, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(key_input),\n",
        "            key_input.animate.set_color(YELLOW),\n",
        "            FadeIn(key_icon, 0.25 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        in_mob = key_input.copy().set_color(YELLOW)\n",
        "        self.play(in_mob.animate.scale(1.5).next_to(machine, LEFT, MED_LARGE_BUFF))\n",
        "        self.play(self.evaluation_animation(in_mob, machine, True))\n",
        "        self.wait()\n",
        "\n",
        "        # Plug in other values\n",
        "        other_inputs = number_mobs.copy()\n",
        "        other_inputs.remove(other_inputs[key_number])\n",
        "        other_inputs.add(number_set[\"N - 1\"][0].copy())\n",
        "        other_inputs.generate_target()\n",
        "        other_inputs.target.arrange_in_grid(n_cols=3, buff=MED_SMALL_BUFF)\n",
        "        other_inputs.target.next_to(machine, LEFT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(in_mob, DOWN),\n",
        "            FadeOut(machine.output_group, DOWN),\n",
        "            MoveToTarget(other_inputs, lag_ratio=0.01),\n",
        "        )\n",
        "        machine.output_group.clear()\n",
        "        self.play(LaggedStart(\n",
        "            (self.evaluation_animation(mob, machine)\n",
        "            for mob in other_inputs),\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(other_inputs, shift=0.25 * DOWN, lag_ratio=0.01),\n",
        "            FadeOut(machine.output_group, 0.25 * DOWN),\n",
        "        )\n",
        "        machine.output_group.clear()\n",
        "        self.wait()\n",
        "\n",
        "        # Show innards\n",
        "        innards = Code(\"\"\"\n",
        "            def f(n):\n",
        "                return (n == 12)\n",
        "        \"\"\", font_size=16)\n",
        "        innards[8:].shift(0.5 * RIGHT)\n",
        "        innards.move_to(machine).shift(0.25 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            machine.animate.set_fill(opacity=0),\n",
        "            FadeIn(innards)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(innards),\n",
        "            machine.animate.set_fill(opacity=1),\n",
        "            FadeIn(q_marks, shift=0.25 * UP, lag_ratio=0.25)\n",
        "        )\n",
        "        self.play(FadeOut(q_marks))\n",
        "        self.wait()\n",
        "\n",
        "        # Guess and check\n",
        "        last_group = VGroup()\n",
        "        for n, in_mob in enumerate(number_mobs[:key_number + 1].copy()):\n",
        "            self.play(\n",
        "                FadeOut(last_group),\n",
        "                in_mob.animate.scale(1.5).next_to(machine, LEFT, MED_LARGE_BUFF)\n",
        "            )\n",
        "            output = (n == key_number)\n",
        "            self.play(self.evaluation_animation(in_mob, machine, output))\n",
        "            last_group = VGroup(in_mob, machine.output_group[0])\n",
        "            machine.output_group.clear()\n",
        "\n",
        "        self.wait()\n",
        "        self.play(FadeOut(last_group))\n",
        "\n",
        "        # Put into a superposition\n",
        "        pile = number_mobs.copy()\n",
        "        for mob in pile:\n",
        "            mob.scale(0.5)\n",
        "        superposition = Superposition(pile)\n",
        "        superposition.set_offset_multiple(0)\n",
        "        superposition.set_glow_opacity(0)\n",
        "        superposition.update()\n",
        "\n",
        "        superposition.generate_target()\n",
        "        for piece in superposition.pieces:\n",
        "            piece.scale(2)\n",
        "\n",
        "        for point in superposition.target[2]:\n",
        "            point.next_to(machine, LEFT, buff=2.0)\n",
        "            point.scale(0.5)\n",
        "            point.shift(np.random.normal(0, 0.5, 3))\n",
        "\n",
        "        superposition.target[2].arrange(DOWN, buff=0.25).next_to(machine, LEFT, buff=1.5)\n",
        "\n",
        "        superposition.target.set_offset_multiple(0.1)\n",
        "        superposition.target.set_glow_opacity(0.1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(superposition, run_time=2),\n",
        "        )\n",
        "\n",
        "        # Pass superposition through the function\n",
        "        answers = VGroup(\n",
        "            Text(\"True\").set_color(GREEN) if n == key_number else Text(\"False\").set_color(RED)\n",
        "            for n, piece in enumerate(superposition.pieces)\n",
        "        )\n",
        "        answers.match_height(superposition.pieces[0])\n",
        "        answers.arrange_to_fit_height(superposition.get_height())\n",
        "        answers.next_to(machine, RIGHT, buff=1.5)\n",
        "        answers.shuffle()\n",
        "        answer_superposition = Superposition(answers, glow_color=RED)\n",
        "        answer_superposition.set_offset_multiple(0)\n",
        "        answer_superposition.set_glow_opacity(0)\n",
        "        answer_superposition.update()\n",
        "\n",
        "        superposition.set_z_index(2)\n",
        "        self.play(LaggedStart(\n",
        "            LaggedStart(\n",
        "                (FadeOutToPoint(glow.copy(), machine.get_left() + 0.5 * RIGHT)\n",
        "                for glow in superposition.glows),\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (FadeInFromPoint(answer, machine.get_right() + 0.5 * LEFT)\n",
        "                for answer in answer_superposition.pieces),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(answer_superposition.animate.set_offset_multiple(0.025).set_glow_opacity(1e-2))\n",
        "        self.wait(10)\n",
        "\n",
        "    def evaluation_animation(self, input_mob, machine, output=False, run_time=1.0):\n",
        "        if output:\n",
        "            out_mob = Text(\"True\").set_color(GREEN)\n",
        "        else:\n",
        "            out_mob = Text(\"False\").set_color(RED)\n",
        "        out_mob.scale(1.25)\n",
        "        out_mob.next_to(machine, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        moving_input = input_mob.copy()\n",
        "        input_mob.set_opacity(0.25)\n",
        "\n",
        "        machine.output_group.add(out_mob)\n",
        "        in_point = interpolate(machine.get_left(), machine.get_center(), 0.5)\n",
        "\n",
        "        return AnimationGroup(\n",
        "            FadeOutToPoint(moving_input, in_point, time_span=(0, 0.75 * run_time)),\n",
        "            FadeInFromPoint(out_mob, machine.get_left(), time_span=(0.25 * run_time, run_time)),\n",
        "        )\n",
        "\n",
        "\n",
        "class LargeGuessAndCheck(InteractiveScene):\n",
        "    key_value = 42\n",
        "    wait_time_per_mob = 0.1\n",
        "    row_size = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # Create grid of values and machine\n",
        "        N = self.row_size\n",
        "        grid = VGroup(Integer(n) for n in range(int(self.row_size**2)))\n",
        "        grid.arrange_in_grid(buff=0.75, fill_rows_first=False)\n",
        "        grid.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        output = Text(\"False\").set_color(RED)\n",
        "        output.match_height(grid[0])\n",
        "\n",
        "        machine = get_blackbox_machine(height=1.5 * grid[0].get_height())\n",
        "        machine.next_to(output, LEFT, SMALL_BUFF)\n",
        "        machine_group = VGroup(machine, output)\n",
        "        extra_width = machine_group.get_width()\n",
        "        grid.shift(0.5 * extra_width * RIGHT)\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        # Sweep through\n",
        "        self.add(machine_group)\n",
        "        for n, mob in enumerate(grid):\n",
        "            if n % self.row_size == 0:\n",
        "                grid[n:n + self.row_size].shift(extra_width * LEFT)\n",
        "            machine_group.next_to(mob, RIGHT, buff=0.5 * mob.get_width())\n",
        "            if n != self.key_value:\n",
        "                self.play(grid[n].animate.set_opacity(0.5), run_time=self.wait_time_per_mob)\n",
        "                continue\n",
        "\n",
        "            new_output = Text(\"True\").set_color(GREEN)\n",
        "            new_output.replace(machine_group[1])\n",
        "            machine_group.replace_submobject(1, new_output)\n",
        "            break\n",
        "\n",
        "        rect = SurroundingRectangle(grid[n])\n",
        "        self.play(ShowCreation(rect), grid[n].animate.set_color(YELLOW))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GuessAndCheckEarlyGet(LargeGuessAndCheck):\n",
        "    key_value = 12\n",
        "\n",
        "\n",
        "class GuessAndCheckLateGet(LargeGuessAndCheck):\n",
        "    key_value = 92\n",
        "\n",
        "\n",
        "class GuessAndCheckMidGet(LargeGuessAndCheck):\n",
        "    key_value = 53\n",
        "\n",
        "\n",
        "class BigGuessAndCheck(LargeGuessAndCheck):\n",
        "    key_value = 573\n",
        "    wait_time_per_mob = 0.01\n",
        "    row_size = 30\n",
        "\n",
        "\n",
        "class WriteClassicalBigO(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        self.add(FullScreenRectangle().set_fill(GREY_E))\n",
        "\n",
        "        # Terms\n",
        "        avg = TexText(R\"Avg: $\\displaystyle \\frac{1}{2} N$\")\n",
        "        arrow = Tex(R\"\\longrightarrow\")\n",
        "        big_o = Tex(R\"\\mathcal{O}(N)\")\n",
        "        group = VGroup(avg, arrow, big_o)\n",
        "        group.arrange(RIGHT, SMALL_BUFF)\n",
        "        group.scale(1.25)\n",
        "        group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        avg.save_state()\n",
        "        avg.set_x(0)\n",
        "\n",
        "        self.play(Write(avg))\n",
        "        self.wait()\n",
        "        self.play(Restore(avg))\n",
        "        self.play(\n",
        "            Write(arrow),\n",
        "            TransformFromCopy(avg[-1], big_o[2], path_arc=45 * DEG),\n",
        "            Write(big_o[:2]),\n",
        "            Write(big_o[3:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReferenceNeedleInAHaystack(InteractiveScene):\n",
        "    key = 61\n",
        "\n",
        "    def construct(self):\n",
        "        # Show that grid of 100 values, with arrows to exes or checks\n",
        "        N = 10\n",
        "        grid = VGroup(Integer(n) for n in range(int(N * N)))\n",
        "        grid.arrange_in_grid(fill_rows_first=False, h_buff=1.35, v_buff=0.75)\n",
        "        grid.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        # Show marks\n",
        "        key = self.key\n",
        "        symbols = VGroup()\n",
        "        for n in range(N * N):\n",
        "            if n == key:\n",
        "                symbol = Checkmark().set_color(GREEN)\n",
        "            else:\n",
        "                symbol = Exmark().set_color(RED)\n",
        "            symbol.set_height(grid[0].get_height())\n",
        "            symbol.next_to(grid[n], RIGHT, SMALL_BUFF)\n",
        "            symbols.add(symbol)\n",
        "\n",
        "        key_group = VGroup(grid[key], symbols[key])\n",
        "        symbols.shuffle()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, symbols, shift=0.25 * RIGHT, lag_ratio=0.05))\n",
        "        self.wait()\n",
        "\n",
        "        # Show key\n",
        "        rect = SurroundingRectangle(key_group)\n",
        "        rect.set_stroke(GREEN, 2)\n",
        "        fader = FullScreenFadeRectangle(fill_opacity=0.5)\n",
        "        self.add(fader, key_group, rect)\n",
        "        self.play(\n",
        "            FadeIn(fader),\n",
        "            ShowCreation(rect),\n",
        "        )\n",
        "\n",
        "\n",
        "class ReferenceNeedleInAHaystack2(ReferenceNeedleInAHaystack):\n",
        "    key = 31\n",
        "\n",
        "\n",
        "class SuperpositionAsParallelization(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        classical, quantum = symbols = VGroup(\n",
        "            get_classical_computer_symbol(),\n",
        "            get_quantum_computer_symbol(),\n",
        "        )\n",
        "        for symbol, vect in zip(symbols, [LEFT, RIGHT]):\n",
        "            symbol.set_height(1)\n",
        "            symbol.move_to(vect * FRAME_WIDTH / 4)\n",
        "            symbol.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.add(symbols)\n",
        "        self.add(v_line)\n",
        "\n",
        "        # Bit string\n",
        "        boxes = Square().get_grid(1, 4, buff=0)\n",
        "        boxes.set_height(0.5)\n",
        "        boxes.match_x(classical)\n",
        "        boxes.set_stroke(WHITE, 2)\n",
        "\n",
        "        bit_mobs = VGroup(Integer(0).move_to(box) for box in boxes)\n",
        "\n",
        "        def match_value(bit_mobs, value):\n",
        "            bit_str = bin(int(value))[2:].zfill(4)\n",
        "            for bit, mob in zip(bit_str, bit_mobs):\n",
        "                mob.set_value(int(bit))\n",
        "            return bit_mobs\n",
        "\n",
        "        self.play(\n",
        "            Write(boxes),\n",
        "            Write(bit_mobs)\n",
        "        )\n",
        "        value_tracker = ValueTracker(0)\n",
        "        self.play(\n",
        "            value_tracker.animate.set_value(12),\n",
        "            UpdateFromFunc(bit_mobs, lambda m: match_value(m, value_tracker.get_value())),\n",
        "            run_time=3,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Superposition\n",
        "        bit_strings = VGroup()\n",
        "        for bits in it.product(* 4 * [[0, 1]]):\n",
        "            bit_string = VGroup(Integer(b) for b in bits)\n",
        "            bit_string.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            bit_strings.add(bit_string)\n",
        "        bit_strings.arrange(DOWN)\n",
        "        bit_strings.set_height(5.5)\n",
        "        bit_strings.next_to(quantum, DOWN, MED_LARGE_BUFF)\n",
        "        bit_strings.set_fill(opacity=0.75)\n",
        "\n",
        "        superposition = Superposition(bit_strings)\n",
        "        superposition.set_offset_multiple(0)\n",
        "        superposition.set_glow_opacity(0)\n",
        "        superposition.update()\n",
        "\n",
        "        superposition_name = TexText(R\"``Superposition''\")\n",
        "        superposition_name.set_color(TEAL)\n",
        "        superposition_name.next_to(superposition, RIGHT, aligned_edge=UP).shift(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(bit_mobs, bit_string)\n",
        "                for bit_string in bit_strings),\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            superposition.animate.set_offset_multiple(0.1).set_glow_opacity(0.05).shift(1.5 * LEFT),\n",
        "            Write(superposition_name, run_time=1)\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "        # Show parallelization lines\n",
        "        mini_classical = VGroup(\n",
        "            classical.copy().set_height(0.25).move_to(point).match_x(quantum)\n",
        "            for point in superposition.center_points\n",
        "        )\n",
        "        lines = VGroup(\n",
        "            VGroup(\n",
        "                Line(mc.get_left() + 1.1 * LEFT, mc.get_left(), buff=0.1),\n",
        "                Line(mc.get_right(), mc.get_right() + 1.1 * RIGHT, buff=0.1),\n",
        "            )\n",
        "            for mc in mini_classical\n",
        "        )\n",
        "        lines.set_stroke(GREY, 2)\n",
        "\n",
        "        outputs = VGroup(\n",
        "            Integer(int(n == 12), font_size=24).next_to(line, RIGHT)\n",
        "            for n, line in enumerate(lines)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            superposition.animate.set_offset_multiple(0.025),\n",
        "            FadeOut(superposition_name),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(classical, mc)\n",
        "                for mc in mini_classical),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            (TransformFromCopy(piece, output)\n",
        "            for piece, output in zip(superposition.pieces, outputs)),\n",
        "            lag_ratio=0.01,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class ListTwoMisconceptions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Add title and two misconceptions\n",
        "        pass\n",
        "\n",
        "\n",
        "class LogTable(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up table\n",
        "        n_samples = 9\n",
        "        line_width = 8\n",
        "        line_buff = 0.75\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT).set_width(line_width)\n",
        "        h_lines = h_line.get_grid(n_samples, 1, buff=line_buff)\n",
        "        h_lines.set_stroke(WHITE, 1)\n",
        "        h_lines.shift(0.25 * DOWN)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(7)\n",
        "        v_line.set_stroke(WHITE, 2)\n",
        "\n",
        "        N_title, logN_title = titles = VGroup(\n",
        "            Tex(\"N\"),\n",
        "            Tex(R\"\\log_2(N)\"),\n",
        "        )\n",
        "        titles.scale(1.25)\n",
        "        for sign, title in zip([-1, 1], titles):\n",
        "            title.set_x(sign * 2)\n",
        "            title.to_edge(UP)\n",
        "\n",
        "        self.add(h_lines, v_line)\n",
        "        self.add(titles)\n",
        "\n",
        "        # Fill with numbers\n",
        "        N_values = VGroup()\n",
        "        logN_values = VGroup()\n",
        "\n",
        "        for n, line in enumerate(h_lines[1:]):\n",
        "            N = 10**(n + 1)\n",
        "            N_value = Integer(N)\n",
        "            logN_value = DecimalNumber(np.log2(N))\n",
        "            N_value.next_to(line, UP, SMALL_BUFF).match_x(N_title)\n",
        "            logN_value.next_to(line, UP, SMALL_BUFF).match_x(logN_title)\n",
        "            N_value.align_to(logN_value, UP)\n",
        "            N_values.add(N_value)\n",
        "            logN_values.add(logN_value)\n",
        "\n",
        "        self.add(N_values[0], logN_values[0])\n",
        "        for index in range(len(N_values) - 1):\n",
        "            self.play(\n",
        "                TransformMatchingShapes(N_values[index].copy(), N_values[index + 1]),\n",
        "                FadeIn(logN_values[index + 1], shift=0.5 * DOWN),\n",
        "                run_time=1\n",
        "            )\n",
        "        self.add(N_values)\n",
        "        self.add(logN_values)\n",
        "\n",
        "        # Show addition\n",
        "        all_arrows = VGroup()\n",
        "        for line in h_lines[1:-1]:\n",
        "            arrow = Arrow(\n",
        "                logN_values[0].get_right(),\n",
        "                logN_values[1].get_right(),\n",
        "                path_arc=-PI,\n",
        "                buff=0\n",
        "            )\n",
        "            arrow.scale(0.8)\n",
        "            arrow.next_to(line, RIGHT, SMALL_BUFF)\n",
        "            plus_label = Tex(R\"+\\log_2(10)\", font_size=24)\n",
        "            plus_label.set_color(BLUE)\n",
        "            plus_label.next_to(arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "            all_arrows.add(VGroup(arrow, plus_label))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, all_arrows, lag_ratio=0.25), run_time=3)\n",
        "\n",
        "\n",
        "class SecondMisconception(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        title = Text(\"Misconception #2\", font_size=90)\n",
        "        title.to_edge(UP, buff=LARGE_BUFF)\n",
        "        title.add(Underline(title))\n",
        "        title.set_color(BLUE)\n",
        "\n",
        "        words = Text(\n",
        "            \"Quantum Computers would make\\n\" + \\\n",
        "            \"everything exponentially faster\",\n",
        "            font_size=60\n",
        "        )\n",
        "        words.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        red_cross = Cross(words[\"everything\"])\n",
        "        red_cross.set_stroke(RED, [0, 8, 8, 8, 0])\n",
        "        new_words = Text(\"some very\\nspecial problems\", alignment=\"LEFT\")\n",
        "        new_words.set_color(RED)\n",
        "        new_words.next_to(red_cross, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(Write(words, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(red_cross),\n",
        "            FadeIn(new_words, lag_ratio=0.1),\n",
        "            FadeOut(title),\n",
        "            lag_ratio=0.35\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show factoring number\n",
        "        factors = VGroup(Integer(314159), Integer(271829))\n",
        "        factors.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        product = Integer(factors[0].get_value() * factors[1].get_value())\n",
        "        product.next_to(factors, UP, LARGE_BUFF)\n",
        "        lines = VGroup(\n",
        "            Line(product.get_bottom(), factor.get_top(), buff=0.2)\n",
        "            for factor in factors\n",
        "        )\n",
        "        lines.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        product.set_color(TEAL)\n",
        "        factors.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        times = Tex(R\"\\times\")\n",
        "        times.move_to(factors)\n",
        "\n",
        "        factor_group = VGroup(product, lines, factors, times)\n",
        "        factor_group.next_to(words, DOWN, LARGE_BUFF, aligned_edge=RIGHT)\n",
        "\n",
        "        self.play(FadeIn(product))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines, lag_ratio=0.25),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(product, factor)\n",
        "                for factor in factors),\n",
        "                lag_ratio=0.25\n",
        "            ),\n",
        "            Write(times, time_span=(0.5, 1.5)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GroverTimeline(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        timeline = NumberLine(\n",
        "            (1990, 2025, 1),\n",
        "            big_tick_spacing=5,\n",
        "            width=FRAME_WIDTH - 1\n",
        "        )\n",
        "        timeline.set_y(-2)\n",
        "        timeline.add_numbers(\n",
        "            range(1990, 2030, 5),\n",
        "            group_with_commas=False,\n",
        "            font_size=24,\n",
        "        )\n",
        "        self.add(timeline)\n",
        "\n",
        "        # BBBV\n",
        "        bbbv_statement = VGroup(\n",
        "            Text(\"Quantum Search\", font_size=36),\n",
        "            Tex(R\"\\ge\", font_size=42),\n",
        "            Tex(R\"\\mathcal{O}(\\sqrt{N})\", font_size=36),\n",
        "        )\n",
        "        bbbv_statement.arrange(RIGHT, SMALL_BUFF)\n",
        "        bbbv_statement.to_corner(UL)\n",
        "        bbbv_statement.set_color(RED)\n",
        "\n",
        "        bbbv_attribution = TexText(\"BBBV$^*$ Theorem (1994)\", font_size=36)\n",
        "        bbbv_attribution.next_to(bbbv_statement, DOWN, aligned_edge=LEFT)\n",
        "        bbbv_attribution.set_color(RED_B)\n",
        "\n",
        "        bbbv_attribution.to_corner(UL)\n",
        "        bbbv_statement.next_to(bbbv_attribution, DOWN, MED_SMALL_BUFF)\n",
        "        bbbv_statement.set_x(-3.5)\n",
        "\n",
        "        footnote = Text(\"*Bennett, Bernstein, Brassard, Vazirani\", font_size=24)\n",
        "        footnote.set_color(GREY_C)\n",
        "        footnote.to_corner(DL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        bbbv_dots = VGroup(\n",
        "            Dot(timeline.n2p(1994)),\n",
        "            Dot().next_to(bbbv_attribution, LEFT, SMALL_BUFF),\n",
        "        )\n",
        "        bbbv_dots.set_color(RED_B)\n",
        "        arc = -45 * DEG\n",
        "        bbbv_line = Line(\n",
        "            bbbv_dots[0].get_center(),\n",
        "            bbbv_dots[1].get_center(),\n",
        "            path_arc=arc,\n",
        "        )\n",
        "        bbbv_line.set_stroke(RED_B)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(bbbv_dots[0]),\n",
        "            TransformFromCopy(*bbbv_dots, path_arc=arc),\n",
        "            ShowCreation(bbbv_line),\n",
        "            FadeIn(bbbv_attribution, UP),\n",
        "            FadeIn(footnote),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(bbbv_statement, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Lov Grover\n",
        "        grover_name = TexText(\"Grover's Algorithm (1996)\", font_size=36)\n",
        "        grover_name.next_to(bbbv_statement, DOWN, buff=0.75)\n",
        "        grover_name.set_color(BLUE)\n",
        "        grover_name.shift(0.5 * LEFT)\n",
        "\n",
        "        grover_statement = bbbv_statement.copy()\n",
        "        eq = Tex(R\"=\").replace(grover_statement[1], dim_to_match=0)\n",
        "        grover_statement[1].become(eq)\n",
        "        grover_statement.set_color(BLUE_D)\n",
        "        grover_statement.next_to(grover_name, DOWN)\n",
        "        grover_statement.match_x(bbbv_statement)\n",
        "\n",
        "        grover_dots = VGroup(\n",
        "            Dot(timeline.n2p(1996)),\n",
        "            Dot().next_to(grover_name, LEFT, SMALL_BUFF),\n",
        "        )\n",
        "        arc = -35 * DEG\n",
        "        grover_line = Line(\n",
        "            grover_dots[0].get_center(),\n",
        "            grover_dots[1].get_center(),\n",
        "            path_arc=arc,\n",
        "        )\n",
        "        VGroup(grover_dots, grover_line).set_color(BLUE_B)\n",
        "\n",
        "        self.play(TransformFromCopy(bbbv_dots[0], grover_dots[0], path_arc=-PI))\n",
        "        self.play(\n",
        "            TransformFromCopy(*grover_dots, path_arc=arc),\n",
        "            ShowCreation(grover_line),\n",
        "            FadeIn(grover_name, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(bbbv_statement, grover_statement),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show examples\n",
        "        examples = VGroup()\n",
        "        for n in [6, 12]:\n",
        "            n_eq = VGroup(Tex(R\"N = \"), Integer(10**n))\n",
        "            n_eq.arrange(RIGHT, SMALL_BUFF)\n",
        "            n_eq.to_corner(UR, buff=MED_LARGE_BUFF)\n",
        "            steps = VGroup(Tex(R\"\\sim\"), Integer(10**(n / 2)), Dot().set_fill(opacity=0), Text(\"Steps\"))\n",
        "            steps.arrange(RIGHT, buff=0.05)\n",
        "            steps.next_to(n_eq, DOWN, LARGE_BUFF)\n",
        "\n",
        "            arrow = Arrow(n_eq, steps, buff=0.15)\n",
        "\n",
        "            examples.add(VGroup(n_eq, arrow, steps))\n",
        "\n",
        "        sqrt_N = grover_statement[2][2:4]\n",
        "\n",
        "        for n, example in enumerate(examples):\n",
        "            if n == 0:\n",
        "                self.play(\n",
        "                    CountInFrom(example[0][1], 0),\n",
        "                    VFadeIn(example[0]),\n",
        "                )\n",
        "            elif n == 1:\n",
        "                self.play(\n",
        "                    ReplacementTransform(examples[0][0], examples[1][0]),\n",
        "                    FadeOut(examples[0][1:])\n",
        "                )\n",
        "            sqrt_rect = SurroundingRectangle(sqrt_N, buff=SMALL_BUFF)\n",
        "            sqrt_rect.set_stroke(WHITE, 2)\n",
        "            self.play(ShowCreation(sqrt_rect))\n",
        "            self.play(\n",
        "                GrowArrow(example[1]),\n",
        "                sqrt_rect.animate.surround(example[2][1]).set_stroke(opacity=0),\n",
        "                FadeTransform(sqrt_N.copy(), example[2][1]),\n",
        "                FadeIn(example[2][0]),\n",
        "                FadeIn(example[2][-1]),\n",
        "            )\n",
        "            self.add(example)\n",
        "            self.wait()\n",
        "\n",
        "        # Show the \u03c0 / 4\n",
        "        big_O = grover_statement[2]\n",
        "        runtime = Tex(R\"\\left\\lceil \\frac{\\pi}{4} \\right\\rceil \\sqrt{N}\", font_size=36)\n",
        "        runtime.move_to(big_O, LEFT)\n",
        "        runtime.set_color(BLUE_B)\n",
        "\n",
        "        rect = SurroundingRectangle(big_O)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(rect, big_O).animate.shift(DOWN),\n",
        "            FadeIn(runtime, scale=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(runtime[1], buff=0.05))\n",
        "\n",
        "\n",
        "class NPProblemExamples(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Examples\n",
        "        example_images = Group(\n",
        "            self.get_sudoku(),\n",
        "            ImageMobject(\"US_color_graph\"),\n",
        "            Square().set_opacity(0),\n",
        "        )\n",
        "        for img in example_images:\n",
        "            img.set_height(2)\n",
        "        example_images.arrange_in_grid(2, 2, buff=1.5)\n",
        "        example_images[2].match_x(example_images[:2])\n",
        "\n",
        "        example_names = VGroup(\n",
        "            Text(\"Sudoku\"),\n",
        "            Text(\"Graph Coloring\"),\n",
        "            Text(\"Reversing Cryptographic\\nHash Functions\"),\n",
        "        )\n",
        "        examples = Group()\n",
        "        for name, img in zip(example_names, example_images):\n",
        "            name.scale(0.65)\n",
        "            name.next_to(img, DOWN)\n",
        "            examples.add(Group(img, name))\n",
        "        examples.move_to(2 * LEFT)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, examples, lag_ratio=0.5))\n",
        "\n",
        "        # Name them\n",
        "        big_rect = SurroundingRectangle(examples, buff=0.35)\n",
        "        big_rect.set_stroke(BLUE, 3)\n",
        "        big_rect.round_corners(radius=0.5)\n",
        "        name = Text(\"NP Problems\", font_size=60)\n",
        "        name.next_to(big_rect, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(big_rect),\n",
        "            Write(name),\n",
        "            # self.frame.animate.set_x(2),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def get_sudoku(self):\n",
        "        sudoku = SVGMobject(\"sudoku_example\")\n",
        "        small_width = sudoku[0].get_width()\n",
        "        for part in sudoku.submobjects:\n",
        "            if len(part.get_anchors()) == 5:\n",
        "                part.set_fill(opacity=0)\n",
        "                part.set_stroke(WHITE, 1, 0.5)\n",
        "                if part.get_width() > 2 * small_width:\n",
        "                    part.set_stroke(WHITE, 2, 1)\n",
        "            else:\n",
        "                part.set_fill(WHITE, 1)\n",
        "\n",
        "        return sudoku\n",
        "\n",
        "\n",
        "class ShowSha256(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        import hashlib\n",
        "\n",
        "        input_int = Integer(0, min_total_width=8, group_with_commas=False)\n",
        "        output_text = Text(\"\")\n",
        "        lhs = VGroup(Text(R\"SHA256(\"), input_int, Text(\")\"))\n",
        "        lhs.arrange(RIGHT, buff=SMALL_BUFF),\n",
        "        equation = VGroup(lhs, Tex(\"=\").rotate(90 * DEG), output_text)\n",
        "        equation.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        def update_hash(text_mob):\n",
        "            input_bytes = str(input_int.get_value()).encode()\n",
        "            sha256_hash = hashlib.new('sha256')\n",
        "            sha256_hash.update(input_bytes)\n",
        "            hash_hex = sha256_hash.hexdigest()\n",
        "\n",
        "            new_text = \"\\n\".join(\n",
        "                \"\".join(row)\n",
        "                for row in np.array(list(hash_hex)).reshape((4, 16))\n",
        "            )\n",
        "\n",
        "            new_text = Text(new_text, font=\"Consolas\")\n",
        "            new_text.move_to(text_mob, UP)\n",
        "            text_mob.set_submobjects(new_text.submobjects)\n",
        "\n",
        "        output_text.add_updater(update_hash)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(input_int, 2400, rate_func=linear, run_time=24)\n",
        "        )\n",
        "\n",
        "\n",
        "class ContrastTwoAlgorithmsFrame(DisectAQuantumComputer):\n",
        "    def construct(self):\n",
        "        # Set up screens\n",
        "        background = FullScreenFadeRectangle()\n",
        "        background.set_fill(GREY_E, 1)\n",
        "        screens = Rectangle(6, 5).get_grid(1, 2, buff=LARGE_BUFF)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.set_stroke(WHITE, 2)\n",
        "        screens.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        self.add(background)\n",
        "        self.add(screens)\n",
        "\n",
        "        # Titles\n",
        "        titles = VGroup(\n",
        "            VGroup(get_classical_computer_symbol(), Tex(R\"\\mathcal{O}(N)\")),\n",
        "            VGroup(get_quantum_computer_symbol(), Tex(R\"\\mathcal{O}(\\sqrt{N})\")),\n",
        "        )\n",
        "        for title, screen in zip(titles, screens):\n",
        "            title[0].set_height(1.5)\n",
        "            title[1].set_height(0.75)\n",
        "            title.arrange(RIGHT, buff=0.5)\n",
        "            title.next_to(screen, UP, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(titles)\n",
        "\n",
        "        # Preview quantum search\n",
        "        boxes = Square(0.1).get_grid(25, 4, fill_rows_first=False, v_buff=0.05, h_buff=1.1)\n",
        "        boxes.set_height(screens[1].get_height() - MED_LARGE_BUFF)\n",
        "        boxes.move_to(screens[1], UL).shift(MED_SMALL_BUFF * DR)\n",
        "\n",
        "        values = VGroup(\n",
        "            Integer(n, font_size=12).replace(box, dim_to_match=1)\n",
        "            for n, box in enumerate(boxes)\n",
        "        )\n",
        "\n",
        "        dist = np.ones(100)\n",
        "        width_ratio = 5\n",
        "        bars = self.get_dist_bars(dist, boxes, width_ratio=width_ratio)\n",
        "\n",
        "        q_dots = DotCloud().to_grid(4, 25).rotate(-90 * DEG)\n",
        "        q_dots.replace(titles[1][0], dim_to_match=1)\n",
        "        q_dots.stretch(0.5, 1)\n",
        "        lines = VGroup(\n",
        "            Line(point, box.get_center())\n",
        "            for point, box in zip(q_dots.get_points(), boxes)\n",
        "        )\n",
        "        for line in lines:\n",
        "            line.insert_n_curves(20)\n",
        "            color = random_bright_color(hue_range=(0.3, 0.4))\n",
        "            line.set_stroke(color, [0, 2, 2, 0], opacity=0.5)\n",
        "\n",
        "        self.add(values)\n",
        "        self.add(bars)\n",
        "\n",
        "        for n in range(1, 10):\n",
        "            dist[42] += n\n",
        "            width_ratio *= 0.9\n",
        "            lines.shuffle\n",
        "            self.play(\n",
        "                LaggedStartMap(VShowPassingFlash, lines, time_width=1.5, lag_ratio=2e-3),\n",
        "                Transform(bars, self.get_dist_bars(dist, boxes, width_ratio=width_ratio), time_span=(0.5, 1))\n",
        "            )\n",
        "\n",
        "\n",
        "class QuantumCompilation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show circuitry\n",
        "        machine = get_blackbox_machine()\n",
        "        label = machine.submobjects[0]\n",
        "        machine.remove(label)\n",
        "        circuit = SVGMobject(\"BinaryFunctionCircuit\")\n",
        "        circuit.flip(RIGHT)\n",
        "        circuit.set_stroke(width=0)\n",
        "        circuit.set_fill(BLUE_B, 1)\n",
        "        circuit.set_height(machine.get_height() * 0.8)\n",
        "        circuit.move_to(machine).shift(0.25 * RIGHT)\n",
        "        circuit.scale(2, about_point=ORIGIN)\n",
        "        circuit.sort(lambda p: np.dot(p, DR))\n",
        "\n",
        "        self.add(machine, label)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            machine.animate.scale(2, about_point=ORIGIN).set_fill(GREY_E),\n",
        "            FadeOut(label, scale=2),\n",
        "        )\n",
        "        self.play(Write(circuit, lag_ratio=0.05))\n",
        "        self.wait()\n",
        "\n",
        "        # Show binary input\n",
        "        number = Integer(13, font_size=72, edge_to_fix=ORIGIN)\n",
        "        bit_string = BitString(number.get_value())\n",
        "        bit_string.next_to(machine, LEFT)\n",
        "        number.next_to(machine, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        bit_string.set_z_index(-1)\n",
        "        output = BitString(0, length=1).scale(1.5)\n",
        "        output.set_z_index(-1)\n",
        "        output.next_to(machine, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(number, RIGHT))\n",
        "        self.play(\n",
        "            number.animate.next_to(bit_string, UP, MED_LARGE_BUFF),\n",
        "            TransformFromCopy(number.replicate(5), bit_string, lag_ratio=0.01),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(bit_string.copy(), 2 * RIGHT, lag_ratio=0.05, path_arc=45 * DEG),\n",
        "            FadeIn(output, RIGHT, time_span=(0.75, 1.5))\n",
        "        )\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(number, 5),\n",
        "            UpdateFromFunc(bit_string, lambda m: m.set_value(number.get_value())),\n",
        "            run_time=1\n",
        "        )\n",
        "        output.set_value(1)\n",
        "        self.wait()\n",
        "\n",
        "        # Show quantum case\n",
        "        c_machine = VGroup(machine, circuit)\n",
        "        c_machine.target = c_machine.generate_target()\n",
        "        c_machine.target.scale(0.5).to_edge(UP)\n",
        "\n",
        "        q_machine = Square().match_style(machine).set_height(0.5 * machine.get_height())\n",
        "        lines = Line(ORIGIN, 0.75 * RIGHT).get_grid(4, 1, v_buff=0.25)\n",
        "        lines.next_to(q_machine, LEFT, buff=0)\n",
        "        q_machine.add(lines)\n",
        "        q_machine.add(lines.copy().next_to(q_machine, RIGHT, buff=0))\n",
        "        q_machine.to_edge(DOWN, buff=1.5)\n",
        "\n",
        "        q_label = Text(\"Quantum\\nGates\")  # If I were ambitious, I'd show the proper quantum circuit here\n",
        "        q_label.set_color(TEAL)\n",
        "        q_label.set_height(q_machine.get_height() * 0.4)\n",
        "        q_label.move_to(q_machine)\n",
        "\n",
        "        arrow = Arrow(c_machine.target, q_machine, thickness=5)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(c_machine),\n",
        "            bit_string.animate.next_to(c_machine.target, LEFT),\n",
        "            output.animate.next_to(c_machine.target, RIGHT, MED_LARGE_BUFF),\n",
        "            FadeOut(number, UP),\n",
        "        )\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.play(\n",
        "            FadeTransform(c_machine[0].copy(), q_machine),\n",
        "            TransformFromCopy(c_machine[1], q_label, lag_ratio=0.01, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Map to quantum input\n",
        "        q_input = KetGroup(bit_string.copy())\n",
        "        q_input.next_to(q_machine, LEFT)\n",
        "        q_output = q_input.copy()\n",
        "        neg = Tex(R\"-\").next_to(q_output, LEFT, SMALL_BUFF)\n",
        "        q_output.add(neg)\n",
        "        q_output.next_to(q_machine, RIGHT)\n",
        "\n",
        "        input_rect = SurroundingRectangle(bit_string)\n",
        "        input_rect.set_stroke(YELLOW, 2)\n",
        "        output_rect = SurroundingRectangle(output)\n",
        "        output_rect.set_stroke(GREEN, 2)\n",
        "        check = Checkmark()\n",
        "        check.match_height(output)\n",
        "        check.set_color(GREEN)\n",
        "        check.next_to(output, RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(input_rect))\n",
        "        self.play(TransformFromCopy(input_rect, output_rect, path_arc=-45 * DEG))\n",
        "        self.play(\n",
        "            FadeOut(output_rect),\n",
        "            Write(check[0], run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            input_rect.animate.surround(q_input),\n",
        "            TransformFromCopy(VGroup(VectorizedPoint(bit_string.get_center()), bit_string), q_input)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(input_rect),\n",
        "            FadeOut(q_input.copy(), 3 * RIGHT),\n",
        "            FadeIn(q_output, 3 * RIGHT, time_span=(0.5, 1.5))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show False inputs\n",
        "        flipped_input = q_input.copy()\n",
        "        flipped_output = q_output.copy()\n",
        "\n",
        "        input_value_tracker = ValueTracker(number.get_value())\n",
        "        ex = Exmark()\n",
        "        ex.set_color(RED)\n",
        "        ex.replace(check, 1)\n",
        "\n",
        "        self.remove(q_output, check)\n",
        "        self.add(ex)\n",
        "        output.set_value(0)\n",
        "\n",
        "        input_value_tracker.increment_value(1)\n",
        "        self.play(\n",
        "            input_value_tracker.animate.set_value(13).set_anim_args(rate_func=linear),\n",
        "            UpdateFromFunc(bit_string, lambda m: m.set_value(int(input_value_tracker.get_value()))),\n",
        "            UpdateFromFunc(q_input[1], lambda m: m.set_value(int(input_value_tracker.get_value()))),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        q_output2 = q_input.copy()\n",
        "        q_output2.next_to(q_machine, RIGHT, MED_LARGE_BUFF)\n",
        "        self.play(TransformFromCopy(q_input, q_output2, path_arc=45 * DEG))\n",
        "        self.wait()\n",
        "\n",
        "        # Show combination\n",
        "        combined_input = VGroup(q_input.copy(), Tex(R\"+\"), flipped_input)\n",
        "        combined_input.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        combined_input.next_to(q_machine, LEFT)\n",
        "        key_icon = get_key_icon()\n",
        "        key_icon.match_height(q_input)\n",
        "        key_icon.next_to(combined_input[2], LEFT, SMALL_BUFF)\n",
        "\n",
        "        combined_output = VGroup(q_output2.copy(), Tex(R\"+\"), flipped_output)\n",
        "        combined_output.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        combined_output.next_to(q_machine, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(q_input, combined_input[0]),\n",
        "            Write(combined_input[1:]),\n",
        "            ReplacementTransform(q_output2, combined_output[0]),\n",
        "            Write(combined_output[1:]),\n",
        "            FadeIn(key_icon)\n",
        "        )\n",
        "        self.play(\n",
        "            input_value_tracker.animate.set_value(5).set_anim_args(rate_func=linear),\n",
        "            UpdateFromFunc(bit_string, lambda m: m.set_value(int(input_value_tracker.get_value()))),\n",
        "        )\n",
        "        output.set_value(1)\n",
        "        self.remove(ex)\n",
        "        self.add(check)\n",
        "        self.wait()\n"
    ]
}