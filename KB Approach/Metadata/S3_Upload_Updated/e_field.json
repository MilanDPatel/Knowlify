{
    "topic": "What is the electric field between two charged particles? \"\"\").scale(0.7),",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.optics_puzzles.objects import *\n",
        "\n",
        "\n",
        "\n",
        "def get_influence_ring(center_point, color=WHITE, speed=2.0, max_width=3.0, width_decay_exp=0.5):\n",
        "    ring = Circle()\n",
        "    ring.set_stroke(color)\n",
        "    ring.move_to(center_point)\n",
        "    ring.time = 0\n",
        "\n",
        "    def update_ring(ring, dt):\n",
        "        ring.time += dt\n",
        "        radius = ring.time * speed\n",
        "        ring.set_width(max(2 * radius, 1e-3))\n",
        "        ring.set_stroke(width=max_width / (1 + radius)**width_decay_exp)\n",
        "        return ring\n",
        "\n",
        "    ring.add_updater(update_ring)\n",
        "    return ring\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class TestFields(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test coulomb field\n",
        "        particles = ChargedParticle(rotation=0).replicate(1)\n",
        "        particles.arrange(DOWN)\n",
        "        particles.move_to(6 * LEFT)\n",
        "\n",
        "        field = CoulombField(*particles)\n",
        "\n",
        "        self.add(field, particles)\n",
        "        self.play(particles.animate.move_to(0.2 * UP), run_time=3)\n",
        "\n",
        "        self.clear()\n",
        "\n",
        "        # Test Lorenz field\n",
        "        def pos_func(time):\n",
        "            return 0.1 * np.sin(5 * time) * OUT\n",
        "\n",
        "        particle = ChargedParticle(\n",
        "            rotation=0,\n",
        "            radius=0.1,\n",
        "            track_position_history=True\n",
        "        )\n",
        "        particles = particle.get_grid(20, 1, buff=0.25)\n",
        "        particles.add_updater(lambda m: m.move_to(pos_func(self.time)))\n",
        "\n",
        "        field = LorentzField(\n",
        "            *particles,\n",
        "            radius_of_suppression=1.0,\n",
        "            x_density=4,\n",
        "            y_density=4,\n",
        "            max_vect_len=1,\n",
        "            height=10,\n",
        "        )\n",
        "        field.set_stroke(opacity=0.7)\n",
        "\n",
        "        self.frame.reorient(-20, 70)\n",
        "        self.add(field, particles)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class IntroduceEField(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show two neighboring particles\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(1 * DEGREES)\n",
        "\n",
        "        charges = ChargedParticle(rotation=0).replicate(2)\n",
        "        charges.arrange(RIGHT, buff=4)\n",
        "\n",
        "        question = VGroup(\n",
        "            Text(\"\"\"\n",
        "                How does the position\n",
        "                and motion of this...\n",
        "            \"\"\"),\n",
        "            Text(\"influence this?\"),\n",
        "        )\n",
        "        for q, charge, vect in zip(question, charges, [LEFT, RIGHT]):\n",
        "            q.next_to(charge, UP + vect, buff=1.0).shift(-2 * vect)\n",
        "\n",
        "        question[1].align_to(question[0], DOWN)\n",
        "        q0_bottom = question[0].get_bottom()\n",
        "        arrow0 = always_redraw(lambda: Arrow(q0_bottom, charges[0]))\n",
        "        arrow1 = Arrow(question[1].get_bottom(), charges[1])\n",
        "        arrows = VGroup(arrow0, arrow1)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, charges, shift=UP, lag_ratio=0.5))\n",
        "        self.add(arrow0)\n",
        "        self.play(\n",
        "            Write(question[0]),\n",
        "            charges[0].animate.shift(UR).set_anim_args(\n",
        "                rate_func=wiggle,\n",
        "                time_span=(1, 3),\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(question[1]),\n",
        "            ShowCreation(arrow1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show force arrows\n",
        "        def show_coulomb_force(arrow, charge1, charge2):\n",
        "            root = charge2.get_center()\n",
        "            vect = 4 * coulomb_force(\n",
        "                charge2.get_center()[np.newaxis, :],\n",
        "                charge1\n",
        "            )[0]\n",
        "            arrow.put_start_and_end_on(root, root + vect)\n",
        "\n",
        "        coulomb_vects = Vector(RIGHT, stroke_width=5, stroke_color=YELLOW).replicate(2)\n",
        "        coulomb_vects[0].add_updater(lambda a: show_coulomb_force(a, *charges))\n",
        "        coulomb_vects[1].add_updater(lambda a: show_coulomb_force(a, *charges[::-1]))\n",
        "\n",
        "        self.add(*coulomb_vects, *charges)\n",
        "        self.play(\n",
        "            FadeOut(question, time_span=(0, 1)),\n",
        "            FadeOut(arrows, time_span=(0, 1)),\n",
        "            charges.animate.arrange(RIGHT, buff=1.25),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Show force word\n",
        "        force_words = Text(\"Force\", font_size=48).replicate(2)\n",
        "        force_words.set_fill(border_width=1)\n",
        "        fw_width = force_words.get_width()\n",
        "\n",
        "        def place_force_word_on_arrow(word, arrow):\n",
        "            word.set_width(min(0.5 * arrow.get_width(), fw_width))\n",
        "            word.next_to(arrow, UP, buff=0.2)\n",
        "\n",
        "        force_words[0].add_updater(lambda w: place_force_word_on_arrow(w, coulomb_vects[0]))\n",
        "        force_words[1].add_updater(lambda w: place_force_word_on_arrow(w, coulomb_vects[1]))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, force_words, run_time=1, lag_ratio=0.5))\n",
        "        self.add(force_words, charges)\n",
        "        self.wait()\n",
        "\n",
        "        # Add distance label\n",
        "        d_line = always_redraw(lambda: DashedLine(\n",
        "            charges[0].get_right(), charges[1].get_left(),\n",
        "            dash_length=0.025\n",
        "        ))\n",
        "        d_label = Tex(\"r = 0.00\", font_size=36)\n",
        "        d_label.next_to(d_line, DOWN, buff=0.35)\n",
        "        d_label.add_updater(lambda m: m.match_x(d_line))\n",
        "        dist_decimal = d_label.make_number_changeable(\"0.00\")\n",
        "\n",
        "        def get_d():\n",
        "            return get_norm(charges[0].get_center() - charges[1].get_center())\n",
        "\n",
        "        dist_decimal.add_updater(lambda m: m.set_value(get_d()))\n",
        "\n",
        "        # Show graph\n",
        "        axes = Axes((0, 10), (0, 1, 0.25), width=10, height=5)\n",
        "        axes.shift(charges[0].get_center() + 1 * UP - axes.get_origin())\n",
        "        axes.add(\n",
        "            Text(\"Distance\", font_size=36).next_to(axes.c2p(10, 0), UP),\n",
        "            Text(\"Force\", font_size=36).next_to(axes.c2p(0, 0.8), LEFT),\n",
        "        )\n",
        "        graph = axes.get_graph(lambda x: 0.5 / x**2, x_range=(0.01, 10, 0.05))\n",
        "        graph.make_jagged()\n",
        "        graph.set_stroke(YELLOW, 2)\n",
        "\n",
        "        graph_dot = GlowDot(color=WHITE)\n",
        "        graph_dot.add_updater(lambda d: d.move_to(axes.i2gp(get_d(), graph)))\n",
        "\n",
        "        d_label.update()\n",
        "        self.play(\n",
        "            frame.animate.move_to([3.5, 2.5, 0.0]),\n",
        "            LaggedStart(\n",
        "                FadeIn(axes),\n",
        "                ShowCreation(graph),\n",
        "                FadeIn(graph_dot),\n",
        "                ShowCreation(d_line),\n",
        "                FadeIn(d_label, 0.25 * UP),\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for buff in (0.4, 8, 1.25):\n",
        "            self.play(\n",
        "                charges[1].animate.next_to(charges[0], RIGHT, buff=buff),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Write Coulomb's law\n",
        "        coulombs_law = Tex(R\"\"\"\n",
        "            F = {q_1 q_2 \\over 4 \\pi \\epsilon_0} \\cdot \\frac{1}{r^2}\n",
        "        \"\"\")\n",
        "        coulombs_law_title = TexText(\"Coulomb's law\")\n",
        "        coulombs_law_title.move_to(axes, UP)\n",
        "        coulombs_law.next_to(coulombs_law_title, DOWN, buff=0.75)\n",
        "\n",
        "        rect = SurroundingRectangle(coulombs_law[\"q_1 q_2\"])\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        rect.set_fill(YELLOW, 0.25)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(coulombs_law_title),\n",
        "            FadeIn(coulombs_law, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(rect, coulombs_law)\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(coulombs_law[R\"4 \\pi \\epsilon_0\"]))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(coulombs_law[R\"\\frac{1}{r^2}\"]))\n",
        "        self.wait()\n",
        "        self.play(charges[1].animate.next_to(charges[0], RIGHT, buff=3.0), run_time=3)\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Remove graph\n",
        "        d_line.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.center(),\n",
        "            VGroup(coulombs_law, coulombs_law_title).animate.to_corner(UL),\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                axes, graph, graph_dot, d_line, d_label,\n",
        "                force_words, coulomb_vects\n",
        "            )),\n",
        "            charges[0].animate.center(),\n",
        "            FadeOut(charges[1]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show Coulomb's law vector field\n",
        "        coulombs_law.add_background_rectangle()\n",
        "        coulombs_law_title.add_background_rectangle()\n",
        "        field = CoulombField(charges[0], x_density=3.0, y_density=3.0)\n",
        "        dots = DotCloud(field.sample_points, radius=0.025, color=RED)\n",
        "        dots.make_3d()\n",
        "\n",
        "        self.add(dots, coulombs_law_title, coulombs_law)\n",
        "        self.play(ShowCreation(dots))\n",
        "        self.wait()\n",
        "        self.add(field, coulombs_law_title, coulombs_law)\n",
        "        self.play(FadeIn(field))\n",
        "        for vect in [2 * RIGHT, 4 * LEFT, 2 * RIGHT]:\n",
        "            self.play(charges[0].animate.shift(vect).set_anim_args(path_arc=PI, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Electric field\n",
        "        e_coulombs_law = Tex(R\"\"\"\n",
        "            \\vec{E}(\\vec{r}) = {q \\over 4 \\pi \\epsilon_0}\n",
        "            \\cdot \\frac{1}{||\\vec{r}||^2}\n",
        "            \\cdot \\frac{\\vec{r}}{||\\vec{r}||}\n",
        "        \"\"\")\n",
        "        e_coulombs_law.move_to(coulombs_law, LEFT)\n",
        "        ebr = BackgroundRectangle(e_coulombs_law)\n",
        "        r_vect = Vector(2 * RIGHT + UP)\n",
        "        r_vect.set_stroke(GREEN)\n",
        "        r_label = e_coulombs_law[R\"\\vec{r}\"][0].copy()\n",
        "        r_label.next_to(r_vect.get_center(), UP, buff=0.1)\n",
        "        r_label.set_backstroke(BLACK, 20)\n",
        "\n",
        "        e_words = VGroup(\n",
        "            Text(\"Electric Field:\"),\n",
        "            Text(\n",
        "                \"\"\"\n",
        "                What force would be\n",
        "                applied to a unit charge\n",
        "                at a given point\n",
        "                \"\"\",\n",
        "                t2s={\"would\": ITALIC},\n",
        "                t2c={\"unit charge\": RED},\n",
        "                alignment=\"LEFT\",\n",
        "                font_size=36\n",
        "            ),\n",
        "        )\n",
        "        e_words.set_backstroke(BLACK, 20)\n",
        "        e_words.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        e_words.next_to(e_coulombs_law, DOWN, buff=0.5)\n",
        "        e_words.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        rect.surround(e_coulombs_law[R\"\\vec{E}\"])\n",
        "        rect.scale(0.9, about_edge=DR)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(coulombs_law, UP),\n",
        "            FadeIn(ebr, UP),\n",
        "            FadeIn(e_coulombs_law, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(ebr, rect, e_coulombs_law)\n",
        "        self.play(FadeIn(rect))\n",
        "        self.play(Write(e_words, stroke_color=BLACK))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(e_words),\n",
        "            rect.animate.surround(e_coulombs_law[R\"(\\vec{r})\"][0], buff=0)\n",
        "        )\n",
        "        self.add(r_vect, charges[0])\n",
        "        self.play(\n",
        "            field.animate.set_stroke(opacity=0.4),\n",
        "            FadeTransform(e_coulombs_law[R\"\\vec{r}\"][0].copy(), r_label),\n",
        "            ShowCreation(r_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(e_coulombs_law[R\"\\frac{\\vec{r}}{||\\vec{r}||}\"])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Example E vect\n",
        "        e_vect = r_vect.copy()\n",
        "        e_vect.scale(0.25)\n",
        "        e_vect.set_stroke(BLUE)\n",
        "        e_vect.shift(r_vect.get_end() - e_vect.get_start())\n",
        "        e_vect_label = Tex(R\"\\vec{E}\", font_size=36)\n",
        "        e_vect_label.set_backstroke(BLACK, 5)\n",
        "        e_vect_label.next_to(e_vect.get_center(), UL, buff=0.1).shift(0.05 * UR)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(r_vect, e_vect, path_arc=PI / 2),\n",
        "            FadeTransform(e_coulombs_law[:2].copy(), e_vect_label),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Not the full story!\n",
        "        words = Text(\"Not the full story!\", font_size=60)\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(coulombs_law_title, RIGHT)\n",
        "        arrow.set_color(RED)\n",
        "        words.set_color(RED)\n",
        "        words.set_backstroke(BLACK, 20)\n",
        "        words.next_to(arrow, RIGHT)\n",
        "        charges[1].move_to(20 * RIGHT)\n",
        "\n",
        "        self.remove(field)\n",
        "        field = CoulombField(*charges, x_density=3.0, y_density=3.0)\n",
        "        field.set_stroke(opacity=float(field.get_stroke_opacity()))\n",
        "        self.add(field)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words, lag_ratio=0.1),\n",
        "            ShowCreation(arrow),\n",
        "            FadeOut(rect),\n",
        "            FadeOut(r_vect),\n",
        "            FadeOut(r_label),\n",
        "            FadeOut(e_vect),\n",
        "            FadeOut(e_vect_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                dots, coulombs_law_title, e_coulombs_law,\n",
        "                words, arrow,\n",
        "            )),\n",
        "            FadeOut(ebr),\n",
        "            charges[0].animate.to_edge(LEFT, buff=1.0),\n",
        "            charges[1].animate.to_edge(RIGHT, buff=1.0),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Wiggle here -> wiggle there\n",
        "        tmp_charges = Group(*(ChargedParticle(track_position_history=True, charge=0.3) for x in range(2)))\n",
        "        tmp_charges[0].add_updater(lambda m: m.move_to(charges[0]))\n",
        "        tmp_charges[1].add_updater(lambda m: m.move_to(charges[1]))\n",
        "        for charge in tmp_charges:\n",
        "            charge.ignore_last_motion()\n",
        "        lorentz_field = ColoumbPlusLorentzField(\n",
        "            *tmp_charges,\n",
        "            x_density=6.0,\n",
        "            y_density=6.0,\n",
        "            norm_to_opacity_func=lambda n: np.clip(0.5 * n, 0, 0.75)\n",
        "        )\n",
        "        self.remove(field)\n",
        "        self.add(lorentz_field, *tmp_charges)\n",
        "\n",
        "        influence_ring0 = self.get_influence_ring(charges[0].get_center()).set_stroke(opacity=0)\n",
        "        influence_ring1 = self.get_influence_ring(charges[1].get_center()).set_stroke(opacity=0)\n",
        "        dist = get_norm(charges[1].get_center() - charges[0].get_center())\n",
        "        wiggle_kwargs = dict(\n",
        "            rate_func=lambda t: wiggle(t, 3),\n",
        "            run_time=1.5,\n",
        "            suspend_mobject_updating=False,\n",
        "        )\n",
        "\n",
        "        self.add(influence_ring0, charges)\n",
        "        self.play(charges[0].animate.shift(UP).set_anim_args(**wiggle_kwargs))\n",
        "        self.wait_until(lambda: influence_ring0.get_radius() > dist, max_time=dist / 2.0)\n",
        "\n",
        "        self.add(influence_ring1)\n",
        "        self.play(charges[1].animate.shift(0.5 * DOWN).set_anim_args(**wiggle_kwargs))\n",
        "        self.wait_until(lambda: influence_ring1.get_radius() > dist, max_time=dist / 2.0)\n",
        "        self.play(charges[0].animate.shift(0.25 * UP).set_anim_args(**wiggle_kwargs))\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            FadeOut(influence_ring0),\n",
        "            FadeOut(influence_ring1),\n",
        "            FadeOut(lorentz_field)\n",
        "        )\n",
        "        self.remove(tmp_charges)\n",
        "\n",
        "        # Show this the force\n",
        "        ring = self.get_influence_ring(charges[0].get_center())\n",
        "\n",
        "        ghost_charge = charges[0].copy().set_opacity(0.25)\n",
        "        ghost_charge.shift(0.1 * IN)\n",
        "        a_vect = Vector(UP).shift(charges[0].get_center())\n",
        "        a_vect.set_stroke(PINK)\n",
        "        a_label = Tex(R\"\\vec{a}(t_0)\", font_size=48)\n",
        "        a_label.set_color(PINK)\n",
        "        a_label.next_to(a_vect, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        f_vect = Vector(1.0 * DOWN).shift(charges[1].get_center())\n",
        "        f_vect.set_stroke(BLUE)\n",
        "        f_label = Tex(R\"\\vec{F}(t)\")\n",
        "        f_label.set_color(BLUE)\n",
        "        f_label.next_to(f_vect, LEFT, buff=0.15)\n",
        "\n",
        "        time_label = Tex(\"t = 0.00\")\n",
        "        time_label.to_corner(UL)\n",
        "        time_decimal = time_label.make_number_changeable(\"0.00\")\n",
        "        time_decimal.add_updater(lambda m: m.set_value(ring.time))\n",
        "\n",
        "        start_point = charges[0].get_center().copy()\n",
        "        speed = 2.0\n",
        "\n",
        "        def field_func(points):\n",
        "            time = ring.time\n",
        "            diffs = (points - start_point)\n",
        "            norms = np.linalg.norm(diffs, axis=1)\n",
        "            past_times = time - (norms / speed)\n",
        "            mags = np.exp(-3 * past_times)\n",
        "            mags[past_times < 0] = 0\n",
        "            return mags[:, np.newaxis] * DOWN\n",
        "\n",
        "        field = VectorField(\n",
        "            field_func,\n",
        "            height=0,\n",
        "            x_density=4.0,\n",
        "            max_vect_len=1.0,\n",
        "        )\n",
        "        field.add_updater(lambda f: f.update_vectors())\n",
        "\n",
        "        self.add(time_label, a_vect, a_label, charges)\n",
        "        self.wait()\n",
        "        self.add(ring, ghost_charge, field, charges)\n",
        "\n",
        "        target = charges[0].get_center() + 2 * UP\n",
        "        charges[0].add_updater(lambda m, dt: m.shift(3 * dt * (target - m.get_center())))\n",
        "        self.wait_until(lambda: ring.get_radius() > dist)\n",
        "\n",
        "        self.add(f_vect, f_label, charges)\n",
        "        ring.suspend_updating()\n",
        "        charges[0].suspend_updating()\n",
        "        self.add(f_vect, charges[1])\n",
        "        self.play(\n",
        "            FadeIn(f_vect),\n",
        "            FadeIn(f_label),\n",
        "            FadeOut(field),\n",
        "        )\n",
        "\n",
        "        # Write the Lorentz force\n",
        "        lorentz_law = Tex(R\"\"\"\n",
        "            \\vec{F}(t) = \n",
        "            {-q_1 q_2 \\over 4\\pi \\epsilon_0 c^2}\n",
        "            {1 \\over r}\n",
        "            \\vec{a}_\\perp(t - r / c)\n",
        "        \"\"\")\n",
        "        lorentz_law.to_edge(UP)\n",
        "        lorentz_law[R\"\\vec{F}(t)\"][0].match_style(f_label)\n",
        "\n",
        "        a_hat_perp = lorentz_law[R\"\\vec{a}_\\perp\"][0]\n",
        "        a_hat_perp.match_style(a_label)\n",
        "        a_hat_perp.save_state()\n",
        "        a_hat_perp[2].set_opacity(0)\n",
        "        a_hat_perp[:2].move_to(a_hat_perp, RIGHT)\n",
        "        a_hat_perp[:2].scale(1.25, about_edge=DR)\n",
        "\n",
        "        lorentz_law[\"(\"][1].match_style(a_label)\n",
        "        lorentz_law[\")\"][1].match_style(a_label)\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                f_label.copy(),\n",
        "                lorentz_law[R\"\\vec{F}(t)\"][0].copy(),\n",
        "                remover=True,\n",
        "                run_time=1.5,\n",
        "            ),\n",
        "            FadeIn(lorentz_law, time_span=(1, 2))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go through parts of the equation\n",
        "        rect = SurroundingRectangle(lorentz_law[\"-q_1 q_2\"])\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        rect.set_fill(YELLOW, 0.2)\n",
        "\n",
        "        r_line = DashedLine(ghost_charge.get_right(), charges[1].get_left())\n",
        "        r_label = Tex(\"r\").next_to(r_line, UP)\n",
        "\n",
        "        self.add(rect, lorentz_law)\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(lorentz_law[R\"4\\pi \\epsilon_0 c^2\"]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(lorentz_law[R\"{1 \\over r}\"]),\n",
        "            ShowCreation(r_line),\n",
        "        )\n",
        "        self.play(TransformFromCopy(lorentz_law[R\"r\"][1], r_label))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(lorentz_law[R\"\\vec{a}_\\perp(t - r / c)\"]))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(lorentz_law[R\"t - r / c\"], buff=0.05))\n",
        "        self.wait()\n",
        "\n",
        "        # Indicate back in time\n",
        "        new_a_label = Tex(R\"\\vec{a}(t - r / c)\")\n",
        "        new_a_label.match_style(a_label)\n",
        "        new_a_label.move_to(a_label, LEFT)\n",
        "\n",
        "        ring.clear_updaters()\n",
        "        time_decimal.clear_updaters()\n",
        "        charges[0].clear_updaters()\n",
        "        self.add(charges[0])\n",
        "        self.play(\n",
        "            ring.animate.scale(1e-3),\n",
        "            UpdateFromFunc(time_decimal, lambda m: m.set_value(\n",
        "                ring.get_radius() / 2\n",
        "            )),\n",
        "            charges[0].animate.shift(2 * DOWN).set_anim_args(\n",
        "                time_span=(1, 4),\n",
        "                rate_func=lambda t: smooth(t)**0.5,\n",
        "            ),\n",
        "            run_time=4,\n",
        "        )\n",
        "        time_decimal.set_value(0)\n",
        "        self.play(\n",
        "            TransformMatchingStrings(a_label, new_a_label),\n",
        "            FadeOut(rect),\n",
        "        )\n",
        "        self.remove(rect)\n",
        "        self.remove(ring)\n",
        "\n",
        "        # Do another wiggle\n",
        "        ring = self.get_influence_ring(charges[0].get_center())\n",
        "        time_decimal.add_updater(lambda m: m.set_value(ring.time))\n",
        "\n",
        "        self.add(ring)\n",
        "        self.play(charges[0].animate.shift(UP).set_anim_args(**wiggle_kwargs))\n",
        "        self.wait_until(lambda: ring.get_radius() > dist)\n",
        "        self.play(charges[1].animate.shift(0.5 * DOWN).set_anim_args(**wiggle_kwargs))\n",
        "        self.remove(ring)\n",
        "        self.play(FadeOut(time_label))\n",
        "\n",
        "        # Add back perpenducular part\n",
        "        charges.target = charges.generate_target()\n",
        "        charges.target.arrange(UR, buff=3).center()\n",
        "        r_line.target = r_line.generate_target()\n",
        "        r_line.target.become(DashedLine(\n",
        "            charges.target[0].get_center(),\n",
        "            charges.target[1].get_center(),\n",
        "        ))\n",
        "        f_vect.target = f_vect.generate_target()\n",
        "        f_vect.target.rotate(45 * DEGREES)\n",
        "        f_vect.target.shift(charges.target[1].get_center() - f_vect.target.get_start())\n",
        "        rect = SurroundingRectangle(a_hat_perp.saved_state, buff=0.1)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        rect.set_fill(YELLOW, 0.25)\n",
        "\n",
        "        self.add(rect, lorentz_law)\n",
        "        self.play(FadeIn(rect, scale=0.5))\n",
        "        self.play(Restore(a_hat_perp))\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(ghost_charge)\n",
        "        self.play(\n",
        "            MoveToTarget(charges),\n",
        "            MoveToTarget(r_line),\n",
        "            MoveToTarget(f_vect),\n",
        "            r_label.animate.next_to(r_line.target.get_center(), UL, SMALL_BUFF),\n",
        "            f_label.animate.next_to(f_vect.target.get_center(), UR, buff=0),\n",
        "            new_a_label.animate.next_to(charges.target[0], UL, buff=0),\n",
        "            MaintainPositionRelativeTo(a_vect, charges[0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        r_unit = normalize(charges[1].get_center() - charges[0].get_center())\n",
        "        a_perp_vect = Vector(\n",
        "            a_vect.get_vector() - np.dot(a_vect.get_vector(), r_unit) * r_unit,\n",
        "        )\n",
        "        a_perp_vect.match_style(a_vect)\n",
        "        a_perp_vect.set_stroke(interpolate_color(PINK, WHITE, 0.5))\n",
        "        a_perp_vect.shift(a_vect.get_end() - a_perp_vect.get_end())\n",
        "\n",
        "        a_hat_perp2 = a_hat_perp.copy()\n",
        "        a_hat_perp2.scale(0.9)\n",
        "        a_hat_perp2.next_to(a_perp_vect.get_center(), UR, buff=0.1)\n",
        "        a_hat_perp2.match_color(a_perp_vect)\n",
        "\n",
        "        self.play(TransformFromCopy(a_vect, a_perp_vect))\n",
        "        self.play(TransformFromCopy(a_hat_perp, a_hat_perp2))\n",
        "        self.wait()\n",
        "        rings = VGroup()\n",
        "        for x in range(2):\n",
        "            wiggle_kwargs = dict(\n",
        "                run_time=2,\n",
        "                rate_func=lambda t: wiggle(t, 5)\n",
        "            )\n",
        "            ring = self.get_influence_ring(charges[0].get_center())\n",
        "            rings.add(ring)\n",
        "            dist = get_norm(charges[0].get_center() - charges[1].get_center())\n",
        "\n",
        "            self.add(ring)\n",
        "            self.play(charges[0].animate.shift(0.5 * UP).set_anim_args(**wiggle_kwargs))\n",
        "            self.wait_until(lambda: ring.get_radius() > dist)\n",
        "            self.play(charges[1].animate.shift(0.25 * DR).set_anim_args(**wiggle_kwargs))\n",
        "        self.play(FadeOut(rings))\n",
        "\n",
        "        # Clear the canvas\n",
        "        plane = NumberPlane(\n",
        "            background_line_style=dict(stroke_color=GREY_D, stroke_opacity=0.75, stroke_width=1),\n",
        "            axis_config=dict(stroke_opacity=(0.25))\n",
        "        )\n",
        "        new_lorentz = Tex(R\"\"\"\n",
        "            \\vec{E}_{\\text{rad}}(\\vec{r}, t) = \n",
        "            {-q \\over 4\\pi \\epsilon_0 c^2}\n",
        "            {1 \\over ||\\vec{r}||}\n",
        "            \\vec{a}_\\perp(t - ||\\vec{r}|| / c)\n",
        "        \"\"\", font_size=36)\n",
        "        new_lorentz.to_corner(UL)\n",
        "        lhs = new_lorentz[R\"\\vec{E}_{\\text{rad}}(\\vec{r}, t)\"]\n",
        "        lhs.set_color(BLUE)\n",
        "        new_lorentz[R\"\\vec{a}_\\perp(\"].set_color(PINK)\n",
        "        new_lorentz[R\")\"][1].set_color(PINK)\n",
        "\n",
        "        lhs_rect = SurroundingRectangle(lhs)\n",
        "        arrow = Vector(UP).next_to(lhs_rect, DOWN)\n",
        "\n",
        "        self.add(plane, lorentz_law, *charges)\n",
        "        self.remove(rect)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                r_line, r_label,\n",
        "                a_hat_perp2, a_perp_vect,\n",
        "                a_vect, new_a_label, new_a_label,\n",
        "                f_vect, f_label, charges[1],\n",
        "            )),\n",
        "            FadeIn(plane, time_span=(1, 2)),\n",
        "            charges[0].animate.center().set_anim_args(time_span=(1, 2)),\n",
        "            FadeTransform(lorentz_law, new_lorentz),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lhs_rect),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(lhs_rect), FadeOut(arrow))\n",
        "\n",
        "        # Show vector field\n",
        "        charge = ChargedParticle(\n",
        "            track_position_history=True\n",
        "        )\n",
        "        field = LorentzField(\n",
        "            charge,\n",
        "            stroke_width=3,\n",
        "            x_density=4.0,\n",
        "            y_density=4.0,\n",
        "            max_vect_len=0.25,\n",
        "            norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 1),\n",
        "        )\n",
        "        a_vect = AccelerationVector(charge)\n",
        "        small_charges = DotCloud(field.sample_points, radius=0.02)\n",
        "        small_charges.match_color(charges[1][0])\n",
        "        small_charges.make_3d()\n",
        "        new_lorentz.set_backstroke(BLACK, 20)\n",
        "\n",
        "        self.add(small_charges, new_lorentz)\n",
        "        self.play(ShowCreation(small_charges))\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(charges[0])\n",
        "        self.add(field, a_vect, charge, new_lorentz)\n",
        "        charge.ignore_last_motion()\n",
        "\n",
        "        # Have some fun with the charge\n",
        "        wiggle_kwargs = dict(\n",
        "            rate_func=lambda t: wiggle(t, 3),\n",
        "            run_time=3.0,\n",
        "            suspend_mobject_updating=False,\n",
        "        )\n",
        "        lemniscate = ParametricCurve(\n",
        "            lambda t: np.sin(t)**2 * (np.cos(t) * RIGHT + np.sin(t) * UP),\n",
        "            t_range=(0, TAU, TAU / 200)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            charge.animate.shift(0.4 * UP).set_anim_args(**wiggle_kwargs),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            MoveAlongPath(charge, lemniscate, run_time=6)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        for point in [2 * RIGHT, ORIGIN]:\n",
        "            self.play(charge.animate.move_to(point).set_anim_args(path_arc=PI, run_time=5, suspend_mobject_updating=False))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Set it oscillating\n",
        "        charge.init_clock()\n",
        "        charge.ignore_last_motion()\n",
        "        charge.add_updater(lambda m: m.move_to(\n",
        "            0.25 * np.sin(0.5 * TAU * m.get_internal_time()) * UP\n",
        "        ))\n",
        "        self.wait(30)\n",
        "\n",
        "    def get_influence_ring(self, center_point, color=WHITE, speed=2.0, max_width=3.0, width_decay_exp=0.5):\n",
        "        return get_influence_ring(center_point, color, speed, max_width, width_decay_exp)\n",
        "\n",
        "\n",
        "class AltEFieldIntroduction(IntroduceEField):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title1 = TexText(R\"Light $\\rightarrow$ Wave in the Electromagnetic field\")\n",
        "        title2 = TexText(R\"Electric field\")\n",
        "        title2.scale(1.5)\n",
        "        VGroup(title1, title2).to_edge(UP)\n",
        "\n",
        "        self.add(title1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(title1, title2)\n",
        "        )\n",
        "        title2.add_to_back(BackgroundRectangle(title2))\n",
        "\n",
        "        # Add field\n",
        "        density = 4.0\n",
        "        charges = Group(\n",
        "            ChargedParticle(ORIGIN, 1),\n",
        "            ChargedParticle(3 * UL, -1, color=BLUE, sign=\"-\"),\n",
        "            ChargedParticle([3, -2, 0], 2),\n",
        "            ChargedParticle([5, 1, 0], -2, color=BLUE, sign=\"-\"),\n",
        "        )\n",
        "        field_config = dict(\n",
        "            x_density=density,\n",
        "            y_density=density,\n",
        "            width=2 * FRAME_WIDTH,\n",
        "        )        \n",
        "        c_field = CoulombField(*charges, **field_config)\n",
        "        c_field_opacity_tracker = ValueTracker(0)\n",
        "        c_field.add_updater(lambda m: m.set_stroke(opacity=c_field_opacity_tracker.get_value()))\n",
        "        points = DotCloud(c_field.sample_points, radius=0.02)\n",
        "        points.make_3d()\n",
        "        points.set_color(BLUE)\n",
        "        points.move_to(0.01 * IN)\n",
        "\n",
        "        self.add(points, charges, title2)\n",
        "        self.play(\n",
        "            ShowCreation(points),\n",
        "            FadeIn(charges),\n",
        "        )\n",
        "        self.add(points, c_field, charges, title2)\n",
        "        self.play(\n",
        "            charges[0].animate.shift(0.0001 * UP).set_anim_args(rate_func=there_and_back),\n",
        "            c_field_opacity_tracker.animate.set_value(1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show example charge\n",
        "        for charge in charges:\n",
        "            charge.save_state()\n",
        "            charge.target = charge.generate_target()\n",
        "            charge.target.fade(0.5)\n",
        "            charge.target.scale(1e-3)\n",
        "\n",
        "        hyp_charge = ChargedParticle(sign=\"+1\")\n",
        "        hyp_charge.move_to(UR)\n",
        "        vect = Vector(stroke_color=YELLOW)\n",
        "        vect.charge = hyp_charge\n",
        "        vect.field = c_field\n",
        "        glow = GlowDot(hyp_charge.get_center(), color=RED, radius=0.5)\n",
        "        hyp_charge.add_to_back(glow)\n",
        "\n",
        "        hyp_words = Text(\"Hypothetical\\nunit charge\", font_size=24)\n",
        "        hyp_words.set_backstroke(BLACK, 5)\n",
        "        hyp_words.charge = hyp_charge\n",
        "        hyp_words.add_updater(lambda m: m.next_to(m.charge, buff=-SMALL_BUFF))\n",
        "\n",
        "        def update_vect(vect):\n",
        "            p = vect.charge.get_center()\n",
        "            vect.put_start_and_end_on(p, p + vect.field.func([p])[0])\n",
        "            return vect\n",
        "\n",
        "        vect.add_updater(update_vect)\n",
        "\n",
        "        self.play(\n",
        "            *map(MoveToTarget, charges),\n",
        "            c_field_opacity_tracker.animate.set_value(0.5),\n",
        "            VFadeIn(vect),\n",
        "            FadeIn(hyp_charge),\n",
        "            FadeIn(hyp_words),\n",
        "        )\n",
        "        for point in [UL, (-3, 2, 0), (2, -3, 0)]:\n",
        "            self.play(hyp_charge.animate.move_to(point + 0.05 * OUT), run_time=5)\n",
        "\n",
        "        # Emphasize coulombenss\n",
        "        c1 = charges[0]\n",
        "        c2 = ChargedParticle((FRAME_WIDTH - 2) * RIGHT)\n",
        "        c1.charge = c2.charge = 0.5\n",
        "        l_field = ColoumbPlusLorentzField(\n",
        "            c1, c2,\n",
        "            norm_to_opacity_func=lambda n: np.arctan(n),\n",
        "            **field_config\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(points),\n",
        "            ReplacementTransform(c_field, l_field),\n",
        "            Restore(c1),\n",
        "            FadeOut(hyp_charge),\n",
        "            FadeOut(hyp_words),\n",
        "            FadeOut(vect),\n",
        "            *(\n",
        "                c.animate.move_to(10 * c.get_center())\n",
        "                for c in charges[1:]\n",
        "            ),\n",
        "        )\n",
        "        self.add(l_field, charges[0], title2)\n",
        "        self.wait()\n",
        "\n",
        "        hyp_charge.next_to(charges[0], RIGHT, buff=0.5)\n",
        "        vect.field = l_field\n",
        "        self.play(\n",
        "            VFadeIn(vect),\n",
        "            FadeIn(hyp_charge),\n",
        "        )\n",
        "        self.play(\n",
        "            hyp_charge.animate.next_to(charges[0], LEFT, buff=0.5).set_anim_args(path_arc=PI),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(hyp_charge),\n",
        "            FadeOut(vect),\n",
        "            FadeOut(title2),\n",
        "        )\n",
        "\n",
        "        # Shake the charge\n",
        "        def wiggle_charge(charge, direction, run_time=2):\n",
        "            return charge.animate.shift(direction).set_anim_args(\n",
        "                rate_func=lambda t: wiggle(t, 3),\n",
        "                run_time=run_time,\n",
        "                suspend_mobject_updating=False,\n",
        "            )\n",
        "\n",
        "        self.play(wiggle_charge(c1, 0.5 * UP))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Indicate speed\n",
        "        ring = self.get_influence_ring(c1.get_center())\n",
        "        speed_words = Text(\"Speed = c\", font_size=36)\n",
        "        speed_words.set_backstroke(BLACK, 5)\n",
        "        speed_words.ring = ring\n",
        "        speed_words.add_updater(lambda m: m.next_to(m.ring.get_right(), LEFT, SMALL_BUFF))\n",
        "        self.add(ring, speed_words)\n",
        "        self.play(\n",
        "            wiggle_charge(c1, 0.5 * UP),\n",
        "            VFadeIn(speed_words)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show second charge\n",
        "        self.add(c2)\n",
        "        self.play(\n",
        "            self.frame.animate.move_to(Group(c1, c2)),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        amp = 0.5\n",
        "        for sign in [1, -1, 1, -1]:\n",
        "            q1, q2 = (c1, c2) if sign > 0 else (c2, c1)\n",
        "            ring = self.get_influence_ring(q1.get_center())\n",
        "            ring.set_stroke(opacity=0)\n",
        "            dist = get_norm(q1.get_center() - q2.get_center())\n",
        "            self.add(ring)\n",
        "            self.play(wiggle_charge(q1, sign * amp * UP))\n",
        "            self.wait_until(lambda: ring.get_radius() > dist)\n",
        "            amp *= 0.4\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TestForMithuna(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        n_rows = 10\n",
        "        n_cols = 16\n",
        "        n_charges = n_rows * n_cols\n",
        "        charges = Group(*(\n",
        "            ChargedParticle(\n",
        "                track_position_history=True,\n",
        "                charge=10 / n_charges,\n",
        "                radius=0.1,\n",
        "                show_sign=False,\n",
        "            )\n",
        "            for _ in range(n_charges)\n",
        "        ))\n",
        "        charges.arrange_in_grid(n_rows, n_cols, buff=0.5)\n",
        "        charges.center()\n",
        "        self.add(charges)\n",
        "\n",
        "        columns = Group(*(charges[i::n_cols] for i in range(n_cols)))\n",
        "\n",
        "        field = LorentzField(\n",
        "            *charges,\n",
        "            stroke_width=3,\n",
        "            x_density=4.0,\n",
        "            y_density=4.0,\n",
        "            radius_of_suppression=0.1,\n",
        "            # max_vect_len=np.inf,\n",
        "            max_vect_len=None,\n",
        "            norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 0.7),\n",
        "        )\n",
        "        self.add(field)\n",
        "\n",
        "        c_dot = GlowDot().get_grid(1, 100, buff=0.5)\n",
        "        c_dot.move_to(charges)\n",
        "        c_dot.add_updater(lambda m, dt: m.shift(field.c * dt * RIGHT))\n",
        "\n",
        "        self.wait(0.1)\n",
        "        # self.add(c_dot)\n",
        "        self.play(LaggedStart(\n",
        "            *(\n",
        "                col.animate.shift(0.5 * UP).set_anim_args(\n",
        "                    rate_func=lambda t: wiggle(t, 6),\n",
        "                    suspend_mobject_updating=False,\n",
        "                    run_time=8,\n",
        "                )\n",
        "                for col in columns\n",
        "            ),\n",
        "            lag_ratio=1 / n_cols\n",
        "        ))\n",
        "        self.wait(5)\n",
        "\n",
        "        # # Rotate\n",
        "        # self.play(\n",
        "        #     Rotate(\n",
        "        #         charges,\n",
        "        #         TAU,\n",
        "        #         # rate_func=wiggle,\n",
        "        #         suspend_mobject_updating=False,\n",
        "        #         run_time=5,\n",
        "        #     )\n",
        "        # )\n",
        "\n",
        "\n",
        "class ShowTheEffectsOfOscillatingCharge(InteractiveScene):\n",
        "    amplitude = 0.25\n",
        "    frequency = 0.5\n",
        "    direction = UP\n",
        "\n",
        "    show_acceleration_vector = True\n",
        "    origin = None\n",
        "\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        x_range=(-10, 10),\n",
        "        y_range=(-5, 5),\n",
        "        z_range=(-3, 3),\n",
        "    )\n",
        "    particle_config = dict(\n",
        "        track_position_history=True,\n",
        "        radius=0.15,\n",
        "    )\n",
        "    acceleration_vector_config = dict()\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.35,\n",
        "        stroke_opacity=0.75,\n",
        "        radius_of_suppression=1.0,\n",
        "        height=10,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(2 * n, 0, 0.8)\n",
        "    )\n",
        "    field_class = LorentzField\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add_axes()\n",
        "        self.add_axis_labels(self.axes)\n",
        "        self.add_particles(self.axes)\n",
        "        self.add_field(self.particles)\n",
        "        if self.show_acceleration_vector:\n",
        "            self.add_acceleration_vectors(self.particles)\n",
        "\n",
        "    def add_axes(self):\n",
        "        self.axes = ThreeDAxes(**self.axes_config)\n",
        "        if self.origin is not None:\n",
        "            self.axes.shift(self.origin - self.axes.get_origin())\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def add_axis_labels(self, axes):\n",
        "        axis_labels = label = Tex(\"xyz\")\n",
        "        if axes.z_axis.get_stroke_opacity() > 0:\n",
        "            axis_labels.rotate(PI / 2, RIGHT)\n",
        "            axis_labels[0].next_to(axes.x_axis.get_right(), OUT)\n",
        "            axis_labels[1].next_to(axes.y_axis.get_top(), OUT)\n",
        "            axis_labels[2].next_to(axes.z_axis.get_zenith(), RIGHT)\n",
        "        else:\n",
        "            axis_labels[1].clear_points()\n",
        "            axis_labels[0].next_to(axes.x_axis.get_right(), UP)\n",
        "            axis_labels[2].next_to(axes.y_axis.get_top(), RIGHT)\n",
        "\n",
        "        self.axis_labels = axis_labels\n",
        "        self.add(self.axis_labels)\n",
        "\n",
        "    def add_particles(self, axes):\n",
        "        self.particles = self.get_particles()\n",
        "        self.particles.add_updater(lambda m: m.move_to(\n",
        "            axes.c2p(*self.oscillation_function(self.time))\n",
        "        ))\n",
        "        for particle in self.particles:\n",
        "            particle.ignore_last_motion()\n",
        "        self.add(self.particles)\n",
        "\n",
        "    def get_particles(self):\n",
        "        return Group(ChargedParticle(**self.particle_config))\n",
        "\n",
        "    def add_field(self, particles):\n",
        "        self.field = self.field_class(*particles, **self.field_config)\n",
        "        self.add(self.field, particles)\n",
        "\n",
        "    def add_acceleration_vectors(self, particles):\n",
        "        self.acceleration_vectors = VGroup(*(\n",
        "            AccelerationVector(particle)\n",
        "            for particle in particles\n",
        "        ))\n",
        "        self.add(self.acceleration_vectors, self.particles)\n",
        "\n",
        "    def oscillation_function(self, time):\n",
        "        return self.amplitude * np.sin(TAU * self.frequency * time) * self.direction\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class SendingLittlePulses(ShowTheEffectsOfOscillatingCharge):\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        x_range=(0, 10),\n",
        "        y_range=(-3, 3),\n",
        "        z_range=(-1, 1),\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.25,\n",
        "        stroke_opacity=0.75,\n",
        "        radius_of_suppression=1.0,\n",
        "        height=10,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "    def add_axis_labels(self, axes):\n",
        "        pass\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.axes.z_axis.set_stroke(opacity=0)\n",
        "        self.axes.y_axis[-1]\n",
        "        particle = self.particles[0]\n",
        "        particle.clear_updaters()\n",
        "\n",
        "        # Test\n",
        "        for _ in range(10):\n",
        "            shake_size = 0.5 + random.random()\n",
        "            self.play(\n",
        "                particle.animate.shift(0.06 * shake_size * UP),\n",
        "                rate_func=lambda t: wiggle(t, 2), run_time=(shake_size),\n",
        "            )\n",
        "            self.wait(random.choice([1, 2]))\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class OscillateOnYOneDField(ShowTheEffectsOfOscillatingCharge):\n",
        "    origin = 5 * LEFT\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        z_axis_config=dict(stroke_opacity=0),\n",
        "        x_range=(-3, 12),\n",
        "        y_range=(-3, 3)\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=1,\n",
        "        stroke_opacity=1.0,\n",
        "        radius_of_suppression=0.25,\n",
        "        height=0,\n",
        "        x_density=4.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=None\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Start wiggling\n",
        "        axes = self.axes\n",
        "        field = self.field\n",
        "        particles = self.particles\n",
        "\n",
        "        points = DotCloud(field.sample_points, color=BLUE)\n",
        "        points.make_3d()\n",
        "        points.set_radius(0.03)\n",
        "        field.suspend_updating()\n",
        "        particles.suspend_updating()\n",
        "\n",
        "        self.add(points, particles)\n",
        "        self.play(ShowCreation(points))\n",
        "        self.wait()\n",
        "        self.time = 0\n",
        "        particles.resume_updating()\n",
        "        for particle in particles:\n",
        "            particle.ignore_last_motion()\n",
        "        field.resume_updating()\n",
        "        self.wait(24.5)\n",
        "        paused_time = float(self.time)\n",
        "\n",
        "        # Zoom in\n",
        "        field.suspend_updating()\n",
        "        particles.suspend_updating()\n",
        "        self.remove(particles)\n",
        "        self.remove(field)\n",
        "        field_copy = field.copy()\n",
        "        field_copy.clear_updaters()\n",
        "        particle = particles[0].copy()\n",
        "        particle.clear_updaters()\n",
        "        self.add(field_copy, particle)\n",
        "\n",
        "        frame = self.frame\n",
        "        particle.save_state()\n",
        "        particle.target = particle.generate_target()\n",
        "        particle.target[0].set_radius(0.075)\n",
        "        particle.target[1].scale(0.5)\n",
        "        particle.target[1].set_stroke(width=1)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(3, about_point=axes.get_origin()),\n",
        "            MoveToTarget(particle),\n",
        "            self.acceleration_vectors.animate.set_stroke(opacity=0.2),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Go through points\n",
        "        last_line = VMobject()\n",
        "        last_ghost = Group()\n",
        "        step = get_norm(field.sample_points[0] - field.sample_points[1])\n",
        "        for x in np.arange(1, 9):\n",
        "            ghost = particle.copy()\n",
        "            ghost.fade(0.5)\n",
        "            dist = get_norm(axes.c2p(x * step, 0) - particle.get_center())\n",
        "            ghost.move_to(particle.get_past_position(dist / field.c))\n",
        "            line = Line(\n",
        "                ghost.get_center(),\n",
        "                axes.c2p(x * step, 0)\n",
        "            )\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            elbow = Elbow(width=0.1)\n",
        "            angle = line.get_angle() + 90 * DEGREES\n",
        "            if x > 3:\n",
        "                angle += 90 * DEGREES\n",
        "            elbow.rotate(angle, about_point=ORIGIN)\n",
        "            elbow.shift(line.get_end())\n",
        "            elbow.set_stroke(WHITE, 1)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeOut(last_line),\n",
        "                FadeOut(last_ghost, scale=0),\n",
        "                GrowFromCenter(ghost),\n",
        "                FadeIn(elbow, time_span=(0.5, 1)),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            last_line = Group(line, elbow)\n",
        "            last_ghost = ghost\n",
        "        self.play(FadeOut(last_line))\n",
        "\n",
        "        self.time = paused_time\n",
        "        self.play(\n",
        "            Restore(particle),\n",
        "            frame.animate.to_default_state().set_anim_args(run_time=3)\n",
        "        )\n",
        "        self.remove(field_copy, particle)\n",
        "        self.add(particles, field)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class OscillateOnYTwoDField(ShowTheEffectsOfOscillatingCharge):\n",
        "    particle_config = dict(\n",
        "        track_position_history=True,\n",
        "        radius=0.15,\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.25,\n",
        "        stroke_opacity=0.75,\n",
        "        radius_of_suppression=0.25,\n",
        "        height=10,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 1.0)\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Start wiggling\n",
        "        axes = self.axes\n",
        "        field = self.field\n",
        "        particles = self.particles\n",
        "\n",
        "        self.wait(60)\n",
        "\n",
        "\n",
        "class DiscussDecay(OscillateOnYOneDField):\n",
        "    def construct(self):\n",
        "        # Start wiggling\n",
        "        axes = self.axes\n",
        "        particles = self.particles\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show graph\n",
        "        axes_config = dict(self.axes_config)\n",
        "        axes_config.pop(\"z_axis_config\")\n",
        "        axes2d = Axes(**axes_config)\n",
        "        axes2d.shift(axes.get_origin() - axes2d.get_origin())\n",
        "        graph = axes2d.get_graph(lambda x: 2 / x, x_range=(0.5, 12))\n",
        "        graph.set_stroke(TEAL, 2)\n",
        "\n",
        "        words = TexText(R\"Decays proportionally to $\\frac{1}{r}$\")\n",
        "        words[R\"$\\frac{1}{r}$\"].scale(1.5, about_edge=LEFT).set_color(TEAL)\n",
        "        words.move_to(2 * UP)\n",
        "\n",
        "        particles[0].ignore_last_motion()\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class ChargeOnZAxis(ShowTheEffectsOfOscillatingCharge):\n",
        "    default_frame_orientation = (-20, 70)\n",
        "    direction = OUT\n",
        "\n",
        "    origin = ORIGIN\n",
        "\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        x_range=(-8, 8),\n",
        "        y_range=(-6, 6),\n",
        "        z_range=(-3, 3),\n",
        "    )\n",
        "    particle_config = dict(\n",
        "        show_sign=False,\n",
        "        rotation=PI / 2,\n",
        "        track_position_history=True,\n",
        "        radius=0.2,\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.5,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=40,\n",
        "        height=40,\n",
        "        depth=0,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(self.frame.animate.reorient(16, 71, 0), run_time=12)\n",
        "        self.play(self.frame.animate.reorient(-15, 84, 0), run_time=6)\n",
        "        self.play(self.frame.animate.reorient(-38, 64, 0), run_time=10)\n",
        "        self.play(self.frame.animate.reorient(24, 66, 0), run_time=10)\n",
        "\n",
        "\n",
        "class ThreeCharges(ChargeOnZAxis):\n",
        "    def get_particles(self):\n",
        "        return Group(*(\n",
        "            ChargedParticle(**self.particle_config)\n",
        "            for n in range(3)\n",
        "        )).arrange(UP, buff=2)\n",
        "\n",
        "\n",
        "class Introduce3dMovements(ChargeOnZAxis):\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        x_range=(-5, 5),\n",
        "        y_range=(-5, 5),\n",
        "        z_range=(-3, 3),\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        charge = self.particles[0]\n",
        "        self.remove(self.particles)\n",
        "        self.add(charge)\n",
        "\n",
        "        # Test\n",
        "        kw = dict(suspend_mobject_updating=False)\n",
        "        frame = self.frame\n",
        "        frame.reorient(-13, 71, 0).move_to([-0.24, 0.12, 0.04]).set_height(4.88)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(charge, TAU, axis=UP, about_point=RIGHT, **kw),\n",
        "            self.frame.animate.reorient(-17, 71, 0).move_to([-0.12, 0.17, 0.27]).set_height(7.16),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-20, 69, 0).set_height(8).center(),\n",
        "            Rotate(charge, TAU, axis=OUT, about_point=RIGHT, **kw),\n",
        "            run_time=6,\n",
        "        )\n",
        "        # self.wait(4)\n",
        "        self.play(\n",
        "            charge.animate.shift(0.8 * (UP + OUT)).set_anim_args(rate_func=lambda t: wiggle(t, 6), **kw),\n",
        "            self.frame.animate.reorient(20, 71, 0).move_to([0.31, 0.54, -0.3]).set_height(8.22),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            charge.animate.shift(4 * DOWN).set_anim_args(rate_func=there_and_back, **kw),\n",
        "            self.frame.animate.reorient(-21, 64, 0).move_to([0.31, 0.54, -0.3]).set_height(8.22),\n",
        "            run_time=9,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class Introduce3dMovements3DVects(Introduce3dMovements):\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.25,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=20,\n",
        "        height=20,\n",
        "        depth=8,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 0.6)\n",
        "    )\n",
        "\n",
        "\n",
        "class CoulombLorentzExample(Introduce3dMovements):\n",
        "    field_class = ColoumbPlusLorentzField\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.3,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=40,\n",
        "        height=40,\n",
        "        depth=0,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "\n",
        "class CoulombLorentzExample3D(Introduce3dMovements3DVects):\n",
        "    field_class = ColoumbPlusLorentzField\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.35,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=10,\n",
        "        height=10,\n",
        "        depth=8,\n",
        "        x_density=2.0,\n",
        "        y_density=2.0,\n",
        "        z_density=2.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 0.75)\n",
        "    )\n",
        "\n",
        "\n",
        "class RowOfCharges(ChargeOnZAxis):\n",
        "    n_charges = 17\n",
        "    particle_buff = 0.25\n",
        "    particle_config = dict(\n",
        "        rotation=PI / 2,\n",
        "        track_position_history=True,\n",
        "        radius=0.1,\n",
        "        show_sign=False,\n",
        "        charge=0.15\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.5,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=30,\n",
        "        height=30,\n",
        "        depth=0,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 0.8)\n",
        "    )\n",
        "    show_acceleration_vector = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(self.frame.animate.reorient(-7, 62, 0).set_height(16), run_time=12)\n",
        "        self.play(self.frame.animate.reorient(26, 70, 0), run_time=12)\n",
        "        self.play(self.frame.animate.reorient(-26, 70, 0), run_time=12)\n",
        "\n",
        "    def get_particles(self):\n",
        "        return Group(*(\n",
        "            ChargedParticle(**self.particle_config)\n",
        "            for n in range(self.n_charges)\n",
        "        )).arrange(UP, buff=self.particle_buff)\n",
        "\n",
        "\n",
        "class PlaneOfCharges(RowOfCharges):\n",
        "    n_rows = 20\n",
        "    n_cols = 20\n",
        "    particle_buff = 0.1\n",
        "    grid_height = 6\n",
        "\n",
        "    particle_config = dict(\n",
        "        rotation=PI / 2,\n",
        "        track_position_history=True,\n",
        "        radius=0.05,\n",
        "        show_sign=False,\n",
        "        charge=2.0 / 400.0,\n",
        "    )\n",
        "\n",
        "    def get_particles(self):\n",
        "        result = Group(*(\n",
        "            ChargedParticle(**self.particle_config)\n",
        "            for _ in range(self.n_rows * self.n_cols)\n",
        "        ))\n",
        "        result.arrange_in_grid(\n",
        "            self.n_rows, self.n_cols,\n",
        "            buff=self.particle_buff\n",
        "        )\n",
        "        result.set_width(self.grid_height)\n",
        "        result.rotate(PI / 2, UP)\n",
        "        return result\n",
        "\n",
        "\n",
        "class RowOfChargesMoreCharges(RowOfCharges):\n",
        "    n_charges = 100\n",
        "    particle_buff = 0.01\n",
        "\n",
        "    particle_config = dict(\n",
        "        rotation=PI / 2,\n",
        "        track_position_history=True,\n",
        "        radius=0.05,\n",
        "        show_sign=False,\n",
        "        charge=0.0,\n",
        "    )\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.5,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=1.0,\n",
        "        width=30,\n",
        "        height=30,\n",
        "        depth=0,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "\n",
        "class AltRowOfCharges(RowOfCharges):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(self.frame.animate.reorient(-4, 82, 0).move_to([3.12, -0.06, 1.0]).set_height(5.23), run_time=12)\n",
        "        self.play(self.frame.animate.reorient(-20, 69, 0).set_height(8.00), run_time=12)\n",
        "        self.play(self.frame.animate.reorient(-13, 78, 0).move_to([4.32, -0.91, 0.42]).set_height(5.27), run_time=12)\n",
        "\n",
        "\n",
        "class RowOfChargesXAxis(RowOfCharges):\n",
        "    field_config = dict(\n",
        "        max_vect_len=1.0,\n",
        "        stroke_opacity=0.7,\n",
        "        radius_of_suppression=0.25,\n",
        "        width=40,\n",
        "        height=0,\n",
        "        depth=0,\n",
        "        x_density=8.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(1.5 * n, 0, 0.8)\n",
        "    )\n",
        "    axes_config = dict(\n",
        "        axis_config=dict(stroke_opacity=0.7),\n",
        "        x_range=(-20, 20),\n",
        "        y_range=(-6, 6),\n",
        "        z_range=(-3, 3),\n",
        "    )\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.frame.reorient(-26, 70, 0).set_height(16)\n",
        "        self.axis_labels[0].set_x(8)\n",
        "\n",
        "    def construct(self):\n",
        "        # Form the field\n",
        "        self.wait(20)\n",
        "\n",
        "        # Zoom in\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-15, 84, 0).move_to([4.36, -1.83, 0.37]).set_height(5.59),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Show graph\n",
        "        axes_kw = dict(self.axes_config)\n",
        "        axes_kw.pop(\"z_range\")\n",
        "        axes = Axes(**axes_kw)\n",
        "        graph1 = axes.get_graph(lambda r: 2.0 / r, x_range=(0.01, 20, 0.1))\n",
        "        graph2 = axes.get_graph(lambda r: 1.0 / r**0.3, x_range=(0.01, 20, 0.1))\n",
        "        graphs = VGroup(graph1, graph2)\n",
        "        graphs.rotate(PI / 2, RIGHT, about_point=axes.get_origin())\n",
        "        graphs.set_flat_stroke(False)\n",
        "        graphs.set_stroke(TEAL, 2)\n",
        "\n",
        "        words = VGroup(\n",
        "            TexText(R\"Instead of decaying like $\\frac{1}{r}$\"),\n",
        "            TexText(R\"It decays much more gently\"),\n",
        "        )\n",
        "        words.fix_in_frame()\n",
        "        words.to_edge(UP, buff=1.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph1, run_time=2),\n",
        "            FadeIn(words[0], 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words[0], 0.5 * UP),\n",
        "            FadeIn(words[1], 0.5 * UP),\n",
        "            Transform(*graphs)\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class RowOfChargesXAxisMoreCharges(RowOfChargesXAxis):\n",
        "    n_charges = 100\n",
        "    particle_buff = 0.1\n",
        "    particle_config = dict(\n",
        "        rotation=PI / 2,\n",
        "        track_position_history=True,\n",
        "        radius=0.05,\n",
        "        show_sign=False,\n",
        "        charge=3.0 / 50,\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.wait(12)  # Let the field form\n",
        "\n",
        "\n",
        "class RowOfChargesWiggleOnY(RowOfCharges):\n",
        "    direction = UP\n",
        "\n",
        "\n",
        "class WavesIn3D(ChargeOnZAxis):\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.5,\n",
        "        stroke_opacity=0.25,\n",
        "        radius_of_suppression=1.0,\n",
        "        height=10,\n",
        "        depth=10,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=1.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(0.5 * n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "\n",
        "class WiggleHereWiggleThere(IntroduceEField):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        charges = Group(*(\n",
        "            ChargedParticle(track_position_history=True)\n",
        "            for _ in range(2)\n",
        "        ))\n",
        "        charges[0].to_edge(LEFT, buff=2.0)\n",
        "        charges[1].to_edge(RIGHT, buff=2.0)\n",
        "        dist = get_norm(charges[0].get_center() - charges[1].get_center())\n",
        "        for charge in charges:\n",
        "            charge.ignore_last_motion()\n",
        "\n",
        "        field = LorentzField(\n",
        "            *charges,\n",
        "            x_density=6.0,\n",
        "            y_density=6.0,\n",
        "            norm_to_opacity_func=lambda n: np.clip(0.5 * n, 0, 0.75)\n",
        "        )\n",
        "        self.add(field)\n",
        "        self.add(*charges)\n",
        "\n",
        "        # Wiggles\n",
        "        wiggle_kwargs = dict(\n",
        "            rate_func=lambda t: wiggle(t, 3),\n",
        "            run_time=1.5,\n",
        "            suspend_mobject_updating=False,\n",
        "        )\n",
        "\n",
        "        def wiggle_charge(charge, vect):\n",
        "            ring = self.get_influence_ring(charge.get_center())\n",
        "            ring.set_stroke(opacity=2 * get_norm(vect))\n",
        "            self.add(ring)\n",
        "            self.play(charge.animate.shift(vect).set_anim_args(**wiggle_kwargs))\n",
        "            self.wait_until(lambda: ring.get_radius() > dist, max_time=dist / 2.0)\n",
        "\n",
        "        for n, charge in zip(range(6), it.cycle((charges))):\n",
        "            wiggle_charge(charge, UP * (-1)**n / 2**n)\n",
        "\n",
        "\n",
        "class ScatteringOfPolarizedBeam(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class CircularPolarization1D(ShowTheEffectsOfOscillatingCharge):\n",
        "    default_frame_orientation = (-20, 70)\n",
        "    amplitude = 0.2\n",
        "    field_config = dict(\n",
        "        max_vect_len=1.0,\n",
        "        stroke_opacity=0.85,\n",
        "        radius_of_suppression=0.4,\n",
        "        height=0,\n",
        "        width=30,\n",
        "        x_density=5.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(2 * n, 0, 0.8)\n",
        "    )\n",
        "    particle_config = dict(\n",
        "        track_position_history=True,\n",
        "        radius=0.15,\n",
        "        show_sign=False,\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = Square()\n",
        "        frame.set_stroke(WHITE, 2)\n",
        "        frame.set_fill(WHITE, 0.25)\n",
        "        frame.rotate(PI / 2, UP)\n",
        "        frame.move_to(self.axes.c2p(3, 0, 0))\n",
        "        frame.set_flat_stroke(False)\n",
        "\n",
        "        field = self.field\n",
        "        field_opacity_tracker = ValueTracker(1)\n",
        "        field.add_updater(lambda m: m.set_stroke(opacity=field_opacity_tracker.get_value()))\n",
        "\n",
        "        lone_vect_config = dict(self.field_config)\n",
        "        lone_vect_config[\"width\"] = 0\n",
        "        lone_vect_config[\"stroke_width\"] = 3\n",
        "        lone_vect = LorentzField(self.particles[0], **lone_vect_config)\n",
        "        lone_vect.sample_points = np.array([frame.get_center()])\n",
        "\n",
        "        # Pan\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(81, 86, 0),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.add(lone_vect)\n",
        "        self.play(\n",
        "            FadeIn(frame),\n",
        "            field_opacity_tracker.animate.set_value(0.25),\n",
        "            self.frame.animate.reorient(41, 76, 0),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(79, 70, 0),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.play(\n",
        "            field_opacity_tracker.animate.set_value(0.15),\n",
        "            self.frame.animate.reorient(97, 84, 0),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.play(\n",
        "            field_opacity_tracker.animate.set_value(0.35),\n",
        "            self.frame.animate.reorient(59, 73, 0),\n",
        "            run_time=12,\n",
        "        )\n",
        "\n",
        "    def oscillation_function(self, time):\n",
        "        angle = TAU * self.frequency * time\n",
        "        return self.amplitude * np.array([-0, np.sin(angle), np.cos(angle)])\n",
        "\n",
        "\n",
        "class PIPHelper(InteractiveScene):\n",
        "    def construct(self):\n",
        "        frame = Square(side_length=3)\n",
        "        frame.set_stroke(WHITE, 4)\n",
        "        frame.set_fill(WHITE, 0.25)\n",
        "        frame.to_corner(UR)\n",
        "\n",
        "        vect = Vector(RIGHT, stroke_color=BLUE)\n",
        "        vect.shift(frame.get_center())\n",
        "        self.add(frame)\n",
        "        self.play(\n",
        "            Rotating(vect, -15 * TAU, about_point=frame.get_center()),\n",
        "            run_time=30,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "\n",
        "class CircularPolarization2D(CircularPolarization1D):\n",
        "    field_config = dict(\n",
        "        max_vect_len=0.35,\n",
        "        stroke_opacity=0.85,\n",
        "        radius_of_suppression=0.5,\n",
        "        height=30,\n",
        "        width=30,\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        c=2.0,\n",
        "        norm_to_opacity_func=lambda n: np.clip(2 * n, 0, 0.8)\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(79, 78, 0),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-83, 80, 0),\n",
        "            run_time=24,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(17, 62, 0),\n",
        "            run_time=18\n",
        "        )\n",
        "\n",
        "\n",
        "class RandomRicochet(InteractiveScene):\n",
        "    default_frame_orientation = (-36, 70)\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        plane, axes = self.get_plane_and_axes()\n",
        "        self.add(plane, axes)\n",
        "\n",
        "        # Light and Ball\n",
        "        ball = TrueDot(radius=0.1)\n",
        "        ball.make_3d()\n",
        "        ball.set_color(RED)\n",
        "\n",
        "        light = GlowDot(radius=2)\n",
        "        light.move_to(5 * DOWN)\n",
        "        self.add(light, ball)\n",
        "\n",
        "        # Beams\n",
        "        n_beams = 15\n",
        "        beams = VGroup()\n",
        "        for _ in range(n_beams):\n",
        "            point = 5 * normalize(np.random.uniform(-5, 5, 3))\n",
        "            beam = VMobject().set_points_as_corners([\n",
        "                light.get_center(), ball.get_center(), point\n",
        "            ])\n",
        "            beam.set_stroke(YELLOW, 5)\n",
        "            beam.set_flat_stroke(False)\n",
        "            beam.insert_n_curves(100)\n",
        "            beams.add(beam)\n",
        "\n",
        "        frame.reorient(-36, 70, 0) \n",
        "        frame.clear_updaters()\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(dt * 3 * DEGREES))\n",
        "        for beam in beams:\n",
        "            self.play(\n",
        "                VShowPassingFlash(\n",
        "                    beam,\n",
        "                    time_width=0.3,\n",
        "                    run_time=1.5\n",
        "                )\n",
        "            )\n",
        "\n",
        "    def get_plane_and_axes(self):\n",
        "        axes = ThreeDAxes(axis_config=dict(tick_size=0))\n",
        "        axes.set_stroke(opacity=0.5)\n",
        "        plane = NumberPlane(\n",
        "            x_range=axes.x_range,\n",
        "            y_range=axes.y_range,\n",
        "            background_line_style=dict(\n",
        "                stroke_color=GREY_B,\n",
        "                stroke_width=1.0,\n",
        "                stroke_opacity=0.5,\n",
        "            )\n",
        "        )\n",
        "        plane.axes.set_opacity(0)\n",
        "        return plane, axes\n",
        "\n",
        "\n",
        "class PolarizedScattering(RandomRicochet):\n",
        "    field_config = dict(\n",
        "        width=20,\n",
        "        height=20,\n",
        "        x_density=5.0,\n",
        "        y_density=5.0,\n",
        "        stroke_color=BLUE,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 0.75)\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        plane, axes = self.get_plane_and_axes()\n",
        "        self.add(plane, axes)\n",
        "\n",
        "        # Wave\n",
        "        wave = OscillatingWave(\n",
        "            axes,\n",
        "            wave_len=2.0,\n",
        "            color=YELLOW\n",
        "        )\n",
        "        vects = OscillatingFieldWave(axes, wave)\n",
        "        wave.set_stroke(opacity=0)\n",
        "        vects_opacity_tracker = ValueTracker(0.75)\n",
        "        vects.add_updater(lambda m: m.set_stroke(opacity=vects_opacity_tracker.get_value()))\n",
        "\n",
        "        self.add(wave, vects)\n",
        "\n",
        "        # Charge\n",
        "        charge = ChargedParticle(show_sign=False, radius=0.1, track_position_history=True)\n",
        "        charge.add_updater(lambda m: m.move_to(\n",
        "            -0.5 * wave.xt_to_point(0, self.time)\n",
        "        ))\n",
        "        a_vect = AccelerationVector(\n",
        "            charge,\n",
        "            norm_func=lambda n: 0.5 * np.tanh(n)\n",
        "        )\n",
        "\n",
        "        self.add(a_vect, charge)\n",
        "        self.wait(6)\n",
        "\n",
        "        # Result field\n",
        "        charge.charge = 1.0\n",
        "        field = LorentzField(charge, **self.field_config)\n",
        "        field_opacity_multiple = ValueTracker(1)\n",
        "\n",
        "        def update_field(f):\n",
        "            mult = field_opacity_multiple.get_value()\n",
        "            f.set_stroke(opacity=mult * f.get_stroke_opacities())\n",
        "            return f\n",
        "\n",
        "        field.add_updater(update_field)\n",
        "\n",
        "        charge.ignore_last_motion()\n",
        "        self.add(field, vects)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(15, 70, 0),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Show propagation\n",
        "        rings = ProbagatingRings(axes.z_axis, n_rings=5, spacing=0.4)\n",
        "        direction_vectors = VGroup(*(\n",
        "            Arrow(v, 3 * v) for v in compass_directions(8)\n",
        "        ))\n",
        "\n",
        "        self.add(rings)\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, direction_vectors, lag_ratio=0.1),\n",
        "            field_opacity_multiple.animate.set_value(0.5),\n",
        "            vects_opacity_tracker.animate.set_value(0.25),\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-32, 73, 0),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(VFadeOut(rings))\n",
        "\n",
        "        # More vertical direction\n",
        "        direction_vectors.generate_target()\n",
        "        for dv in direction_vectors.target:\n",
        "            dv.scale(0.5)\n",
        "            dv.shift(-0.5 * dv.get_start())\n",
        "            dv.rotate(\n",
        "                70 * DEGREES, axis=cross(dv.get_vector(), OUT),\n",
        "                about_point=ORIGIN\n",
        "            )\n",
        "\n",
        "        self.play(MoveToTarget(direction_vectors, run_time=2))\n",
        "        self.play(FadeOut(direction_vectors))\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class PolarizedScatteringYZ(PolarizedScattering):\n",
        "    field_config = dict(\n",
        "        width=0,\n",
        "        height=20,\n",
        "        depth=20,\n",
        "        x_density=5.0,\n",
        "        y_density=5.0,\n",
        "        stroke_color=BLUE,\n",
        "        norm_to_opacity_func=lambda n: np.clip(n, 0, 1.0)\n",
        "    )\n",
        "\n",
        "\n",
        "class OneOfManyCharges(InteractiveScene):\n",
        "    speed = 1.5\n",
        "    wave_len = 3\n",
        "    default_frame_orientation=(0, 70, 0)\n",
        "    dot_amplitude_factor = 0.2\n",
        "    plane_wave_field_config = dict(\n",
        "        x_density=4.0,\n",
        "        y_density=0.5,\n",
        "        z_density=1.0,\n",
        "        width=28,\n",
        "        height=0,\n",
        "        depth=12,\n",
        "        tip_width_ratio=3,\n",
        "        stroke_color=TEAL,\n",
        "        stroke_width=3,\n",
        "        stroke_opacity=0.5,\n",
        "        norm_to_opacity_func=(lambda n: 2 * n),\n",
        "        max_vect_len=1.0\n",
        "    )\n",
        "    plane_wave_amlpitude = 0.5\n",
        "    charge_field_config = dict(\n",
        "        x_density=4.0,\n",
        "        y_density=4.0,\n",
        "        z_density=4.0,\n",
        "        width=28,\n",
        "        height=0,\n",
        "        depth=16,\n",
        "        tip_width_ratio=3,\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=3,\n",
        "        norm_to_opacity_func=(lambda n: np.tanh(n)),\n",
        "    )\n",
        "    charge_index = 3155\n",
        "\n",
        "    dots_dims = (11, 20, 20)\n",
        "    dots_shape = (6, 4, 4)\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "\n",
        "        # Axes\n",
        "        self.axes = ThreeDAxes()\n",
        "        self.add(self.axes)\n",
        "\n",
        "        # Add incoming wave\n",
        "        omega = TAU * self.speed / self.wave_len\n",
        "        k = TAU / self.wave_len\n",
        "        amplitude = 0.5\n",
        "\n",
        "        def plane_wave_func(points, t):\n",
        "            return self.plane_wave_amlpitude * np.outer(\n",
        "                np.cos(k * np.dot(points, RIGHT) - omega * t),\n",
        "                OUT\n",
        "            )\n",
        "\n",
        "        plane_wave = TimeVaryingVectorField(\n",
        "            plane_wave_func,\n",
        "            **self.plane_wave_field_config\n",
        "        )\n",
        "\n",
        "        plane_wave.opacity_multiplier = ValueTracker(1)\n",
        "        plane_wave.add_updater(lambda m: m.set_stroke(opacity=m.opacity_multiplier.get_value() * m.get_stroke_opacities()))\n",
        "\n",
        "        self.plane_wave_func = plane_wave_func\n",
        "        self.plane_wave = plane_wave\n",
        "        self.add(plane_wave)\n",
        "\n",
        "        # Add 3d grid of charges\n",
        "        dots = DotCloud(color=BLUE)\n",
        "        dots.to_grid(*self.dots_dims, height=None)\n",
        "        dots.set_radius(0)\n",
        "        dots.set_shape(*self.dots_shape)\n",
        "        dots.set_radius(0.05)\n",
        "        dots.make_3d(0.1)\n",
        "\n",
        "        self.dot_center_refs = dots.copy()\n",
        "        self.dot_center_refs.set_opacity(0)\n",
        "        self.dot_center_refs.set_radius(0)\n",
        "\n",
        "        def update_dots(dots):\n",
        "            centers = self.dot_center_refs.get_points()\n",
        "            offsets =  plane_wave.func(centers)\n",
        "            offsets *= self.dot_amplitude_factor\n",
        "            dots.set_points(centers + offsets)\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        dots.opacity_multiplier = ValueTracker(0.75)\n",
        "        dots.add_updater(lambda m: m.set_opacity(m.opacity_multiplier.get_value()))\n",
        "\n",
        "        self.dots = dots\n",
        "        self.add(dots)\n",
        "\n",
        "\n",
        "    def construct(self):\n",
        "        # Pan a little to start\n",
        "        frame = self.frame\n",
        "        self.play(\n",
        "            frame.animate.reorient(25, 72, 0),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Create field based on the charges\n",
        "        if self.charge_index > 0:\n",
        "            charge = ChargedParticle(\n",
        "                charge=-5,\n",
        "                color=BLUE,\n",
        "                show_sign=False,\n",
        "                radius=0.1\n",
        "            )\n",
        "            charge.add_updater(lambda m: m.move_to(self.dots.get_points()[self.charge_index]))\n",
        "            charge.update()\n",
        "            charge.ignore_last_motion()\n",
        "            charge_field = LorentzField(\n",
        "                charge,\n",
        "                center=charge.get_y() * UP,\n",
        "                radius_of_suppression=0.2,\n",
        "                **self.charge_field_config\n",
        "            )\n",
        "            # acc_vect = AccelerationVector(charge)\n",
        "            acc_vect = VectorizedPoint()\n",
        "\n",
        "            self.add(charge_field, acc_vect, charge, self.dots)\n",
        "            self.play(\n",
        "                self.plane_wave.opacity_multiplier.animate.set_value(0),\n",
        "                self.dots.opacity_multiplier.animate.set_value(0.1),\n",
        "                FadeIn(charge, suspend_mobject_updating=False),\n",
        "                VFadeIn(acc_vect),\n",
        "                run_time=2,\n",
        "            )\n",
        "        else:\n",
        "            self.play(\n",
        "                self.dots.opacity_multiplier.animate.set_value(0.2),\n",
        "                run_time=2\n",
        "            )\n",
        "        self.play(\n",
        "            frame.animate.reorient(25, 72, 0),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-25, 72, 0),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "\n",
        "class AlternateCompositeChargesInPlane(OneOfManyCharges):\n",
        "    dots_dims = (11, 10, 10)\n",
        "    dots_shape = (6, 4, 4)\n",
        "    random_seed = 2\n",
        "\n",
        "    def construct(self):\n",
        "        # Objects\n",
        "        frame = self.frame\n",
        "        plane_wave = self.plane_wave\n",
        "        dots = self.dots\n",
        "        dots.set_radius(0.075)\n",
        "        dots.opacity_multiplier.set_value(1)\n",
        "\n",
        "        # Some panning\n",
        "        frame.reorient(-17, 76, 0)\n",
        "        self.play(\n",
        "            frame.animate.reorient(16, 77, 0),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Reorient\n",
        "        self.play(\n",
        "            dots.animate.set_height(0, stretch=True),\n",
        "            self.dot_center_refs.animate.set_height(0, stretch=True),\n",
        "            frame.animate.reorient(0, 90).set_height(6),\n",
        "            self.axes.y_axis.animate.set_stroke(opacity=0),\n",
        "            plane_wave.opacity_multiplier.animate.set_value(0.5),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            dots.opacity_multiplier.animate.set_value(0.25),\n",
        "            plane_wave.opacity_multiplier.animate.set_value(0.0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add charges\n",
        "        w, h, d = self.dots_dims\n",
        "        indices = np.arange(0, w * h * d, w)\n",
        "        charge = ChargedParticle(\n",
        "            color=BLUE,\n",
        "            radius=dots.get_radius(),\n",
        "            show_sign=False,\n",
        "        )\n",
        "        charges = charge.replicate(len(indices))\n",
        "        charges.apply_depth_test(False)\n",
        "        for charge, index in zip(charges, indices):\n",
        "            charge.index = index\n",
        "            charge.add_updater(lambda m: m.move_to(dots.get_points()[m.index] + 0.01 * DOWN))\n",
        "        \n",
        "        charges.shuffle()\n",
        "\n",
        "        charges[0].update()\n",
        "        charges[0].ignore_last_motion()\n",
        "        charge_field = LorentzField(\n",
        "            charges[0],\n",
        "            radius_of_suppression=0.2,\n",
        "            **self.charge_field_config\n",
        "        )\n",
        "        self.add(charges[0])\n",
        "        self.add(charge_field)\n",
        "        self.wait(3)\n",
        "\n",
        "        start_time = float(self.time)\n",
        "        for n, charge in enumerate(charges[1:]):\n",
        "            charge.update()\n",
        "            charge.ignore_last_motion()\n",
        "\n",
        "            if n < 2:\n",
        "                time = 3\n",
        "            if n < 5:\n",
        "                time = 2\n",
        "            elif n < 15:\n",
        "                time = 1\n",
        "            else:\n",
        "                time = 0.2\n",
        "\n",
        "            charge_field.charges.append(charge)\n",
        "            n_charges = len(charge_field.charges)\n",
        "            alpha = inverse_interpolate(start_time, start_time + 30, self.time)\n",
        "            q_per_particle = interpolate(1, 0.5, alpha)\n",
        "            for c2 in charge_field.charges:\n",
        "                c2.charge = q_per_particle\n",
        "\n",
        "            self.add(charge)\n",
        "            self.wait(time)\n",
        "\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class FullCompositeEffect(OneOfManyCharges):\n",
        "    default_frame_orientation = (-25, 72, 0)\n",
        "    dot_amplitude_factor = 0.1\n",
        "    index = 1.75\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        dots = self.dots\n",
        "        plane_wave = self.plane_wave\n",
        "\n",
        "        min_x = dots.get_x(LEFT)\n",
        "        max_x = dots.get_x(RIGHT)\n",
        "\n",
        "        def new_pw_func(points, time):\n",
        "            adj_points = points.copy()\n",
        "            to_left = np.clip(adj_points[:, 0] - min_x, 0, np.inf)\n",
        "            to_right = np.clip(adj_points[:, 0] - max_x, 0, np.inf)\n",
        "            adj_points[:, 0] += (self.index - 1) * to_left - (self.index - 1) * to_right\n",
        "            return self.plane_wave_func(adj_points, time)\n",
        "\n",
        "        new_wave = TimeVaryingVectorField(\n",
        "            new_pw_func,\n",
        "            stroke_color=YELLOW,\n",
        "            x_density=10,\n",
        "            z_density=1,\n",
        "            width=14,\n",
        "            height=0,\n",
        "            depth=0,\n",
        "            max_vect_len=np.inf,\n",
        "            norm_to_opacity_func=lambda n: 2 * n,\n",
        "        )\n",
        "\n",
        "        new_wave.opacity_multiplier = ValueTracker(0)\n",
        "        new_wave.add_updater(lambda m: m.set_stroke(opacity=m.get_stroke_opacities() * m.opacity_multiplier.get_value()))\n",
        "\n",
        "        # Test\n",
        "        self.add(new_wave)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 90, 0).set_height(8).set_focal_distance(100),\n",
        "            dots.opacity_multiplier.animate.set_value(0.75),\n",
        "            plane_wave.opacity_multiplier.animate.set_value(0),\n",
        "            new_wave.opacity_multiplier.animate.set_value(1),\n",
        "            VFadeIn(new_wave),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class FullCompositeEffectIndexLessThanOne(FullCompositeEffect):\n",
        "    index = 0.7\n",
        "\n",
        "\n",
        "class ManyParallelPropagations(OneOfManyCharges):\n",
        "    dots_dims = (11, 20, 20)\n",
        "    dots_shape = (6, 0, 4)\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        dots = self.dots\n",
        "        plane_wave = self.plane_wave\n",
        "        self.axes.y_axis.set_opacity(0)\n",
        "\n",
        "        frame = self.frame\n",
        "        frame.reorient(0, 90, 0)\n",
        "        frame.set_focal_distance(10)\n",
        "\n",
        "        dots.set_radius(0.05)\n",
        "        dots.opacity_multiplier.set_value(1)\n",
        "        plane_wave.opacity_multiplier.set_value(0)\n",
        "\n",
        "        rings = []\n",
        "        for _ in range(10):\n",
        "            min_x, min_y, min_z = self.dot_centers[0]\n",
        "            max_x, max_y, max_z = self.dot_centers[-1]\n",
        "            for x in np.linspace(min_x, max_x, 6):\n",
        "                for z in np.linspace(min_z, max_z, 10):\n",
        "                    ring = get_influence_ring([x, 0, z], speed=self.speed, max_width=1, width_decay_exp=2)\n",
        "                    ring.rotate(PI / 2, RIGHT)\n",
        "                    rings.append(ring)\n",
        "                    self.add(ring)\n",
        "            self.wait()\n",
        "            for ring in rings:\n",
        "                if ring.get_stroke_width() < 0.01:\n",
        "                    self.remove(ring)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ResponsiveCharge(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Driving chrage\n",
        "        charge1 = ChargedParticle(charge=0.25)\n",
        "        charge1.add_spring_force(k=10)\n",
        "        charge1.move_to(0.3 * DOWN)\n",
        "\n",
        "        # Responsive charge\n",
        "        k = 20\n",
        "        charge2 = ChargedParticle(charge=1.0, radius=0.1, show_sign=False)\n",
        "        charge2.move_to(2.5 * RIGHT)\n",
        "        # charge2.add_field_force(field)\n",
        "        charge2.add_spring_force(k=k)\n",
        "        charge2.add_force(lambda p: wave.xt_to_point(p[0], wave.time) * [0, 1, 1])\n",
        "        # charge2.fix_x()\n",
        "        self.add(charge2)\n",
        "\n",
        "        # E field\n",
        "        # field_type = ColoumbPlusLorentzField\n",
        "        field_type = LorentzField\n",
        "        field = field_type(\n",
        "            charge1, charge2,\n",
        "            x_density=4.0,\n",
        "            y_density=4.0,\n",
        "            norm_to_opacity_func=lambda n: np.clip(0.5 * n, 0, 1),\n",
        "            c=1.0,\n",
        "        )\n",
        "        self.add(field)\n",
        "\n",
        "        # Pure wave\n",
        "        axes = ThreeDAxes()\n",
        "        wave = OscillatingWave(axes, y_amplitude=1.0, z_amplitude=0.0, wave_len=2.0)\n",
        "        field_wave = OscillatingFieldWave(axes, wave)\n",
        "        wave.set_stroke(opacity=0.5)\n",
        "\n",
        "\n",
        "        self.add(axes, wave, field_wave)\n",
        "\n",
        "        # omega = (wave.speed / wave.wave_len) * TAU\n",
        "        # omega_0 = math.sqrt(k / charge2.mass)\n",
        "        # v0 = omega / (omega_0**2 - omega**2)\n",
        "        # charge2.velocity = v0 * UP\n",
        "\n",
        "        self.wait(20)\n",
        "\n",
        "        # Plane\n",
        "        plane = NumberPlane()\n",
        "        plane.fade(0.5)\n",
        "        self.add(plane)\n",
        "\n",
        "        # Test wiggle\n",
        "        self.play(\n",
        "            charge1.animate.shift(UP).set_anim_args(\n",
        "                rate_func=wiggle,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        self.wait(4)\n"
    ]
}