{
    "topic": "is demonstrating the concept of a step function, which is a mathematical function that takes on",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part2.heat_equation import BringTwoRodsTogether\n",
        "from _2019.diffyq.part3.staging import FourierSeriesIllustraiton\n",
        "\n",
        "\n",
        "class StepFunctionExample(BringTwoRodsTogether, FourierSeriesIllustraiton):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"y_min\": -1.5,\n",
        "            \"y_max\": 1.5,\n",
        "            \"y_axis_config\": {\n",
        "                \"unit_size\": 2.5,\n",
        "                \"tick_frequency\": 0.5,\n",
        "            },\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 1,\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 8,\n",
        "                \"tick_frequency\": 0.1,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "        },\n",
        "        \"y_labels\": [-1, 1],\n",
        "        \"graph_x_min\": 0,\n",
        "        \"graph_x_max\": 1,\n",
        "        \"midpoint\": 0.5,\n",
        "        \"min_temp\": -1,\n",
        "        \"max_temp\": 1,\n",
        "        \"alpha\": 0.25,\n",
        "        \"step_size\": 0.01,\n",
        "        \"n_range\": range(1, 41, 2),\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_graph()\n",
        "        self.setup_clock()\n",
        "\n",
        "        self.bring_rods_together()\n",
        "        self.let_evolve_for_a_bit()\n",
        "        self.add_labels()\n",
        "        self.compare_to_sine_wave()\n",
        "        self.sum_of_sine_waves()\n",
        "\n",
        "    def bring_rods_together(self):\n",
        "        rods = VGroup(\n",
        "            self.get_rod(0, 0.5),\n",
        "            self.get_rod(0.5, 1),\n",
        "        )\n",
        "        rods.add_updater(self.update_rods)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Vector(RIGHT).next_to(rods[0], UP),\n",
        "            Vector(LEFT).next_to(rods[1], UP),\n",
        "        )\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Hot\").next_to(rods[0], DOWN),\n",
        "            OldTexText(\"Cold\").next_to(rods[1], DOWN),\n",
        "        )\n",
        "\n",
        "        for pair in rods, words:\n",
        "            pair.save_state()\n",
        "            pair.space_out_submobjects(1.2)\n",
        "\n",
        "        black_rects = VGroup(*[\n",
        "            Square(\n",
        "                side_length=1,\n",
        "                fill_color=BLACK,\n",
        "                fill_opacity=1,\n",
        "                stroke_width=0,\n",
        "            ).move_to(self.axes.c2p(0, u))\n",
        "            for u in [1, -1]\n",
        "        ])\n",
        "        black_rects[0].add_updater(\n",
        "            lambda m: m.align_to(rods[0].get_right(), LEFT)\n",
        "        )\n",
        "        black_rects[1].add_updater(\n",
        "            lambda m: m.align_to(rods[1].get_left(), RIGHT)\n",
        "        )\n",
        "\n",
        "        self.add(\n",
        "            self.axes,\n",
        "            self.graph,\n",
        "            self.clock,\n",
        "        )\n",
        "        self.add(rods, words)\n",
        "        self.add(black_rects)\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 2,\n",
        "            \"rate_func\": rush_into,\n",
        "        }\n",
        "        self.play(\n",
        "            Restore(rods, **kw),\n",
        "            Restore(words, **kw),\n",
        "            *map(ShowCreation, arrows)\n",
        "        )\n",
        "        self.remove(black_rects)\n",
        "\n",
        "        self.to_fade = VGroup(words, arrows)\n",
        "        self.rods = rods\n",
        "\n",
        "    def let_evolve_for_a_bit(self):\n",
        "        rods = self.rods\n",
        "        # axes = self.axes\n",
        "        time_label = self.time_label\n",
        "        graph = self.graph\n",
        "        graph.save_state()\n",
        "\n",
        "        graph.add_updater(self.update_graph)\n",
        "        time_label.next_to(self.clock, DOWN)\n",
        "        time_label.add_updater(\n",
        "            lambda d, dt: d.increment_value(dt)\n",
        "        )\n",
        "        rods.add_updater(self.update_rods)\n",
        "\n",
        "        self.add(time_label)\n",
        "        self.play(\n",
        "            FadeOut(self.to_fade),\n",
        "            self.get_clock_anim(1)\n",
        "        )\n",
        "        self.play(self.get_clock_anim(3))\n",
        "\n",
        "        time_label.clear_updaters()\n",
        "        graph.clear_updaters()\n",
        "        self.play(\n",
        "            self.get_clock_anim(\n",
        "                -4,\n",
        "                run_time=1,\n",
        "                rate_func=smooth,\n",
        "            ),\n",
        "            graph.restore,\n",
        "            time_label.set_value, 0,\n",
        "        )\n",
        "        rods.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "    def add_labels(self):\n",
        "        axes = self.axes\n",
        "        y_axis = axes.y_axis\n",
        "        x_axis = axes.x_axis\n",
        "        y_numbers = y_axis.get_number_mobjects(\n",
        "            *np.arange(-1, 1.5, 0.5),\n",
        "            unit=\"^\\\\circ\",\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "        x_numbers = x_axis.get_number_mobjects(\n",
        "            *np.arange(0.2, 1.2, 0.2),\n",
        "            num_decimal_places=1,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(y_numbers))\n",
        "        self.play(ShowCreationThenFadeAround(y_numbers[-1]))\n",
        "        self.play(ShowCreationThenFadeAround(y_numbers[0]))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, x_numbers,\n",
        "                lambda m: (m, UP)\n",
        "            ),\n",
        "            self.rods.set_opacity, 0.8,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def compare_to_sine_wave(self):\n",
        "        phi_tracker = ValueTracker(0)\n",
        "        get_phi = phi_tracker.get_value\n",
        "        k_tracker = ValueTracker(TAU)\n",
        "        get_k = k_tracker.get_value\n",
        "        A_tracker = ValueTracker(1)\n",
        "        get_A = A_tracker.get_value\n",
        "\n",
        "        sine_wave = always_redraw(lambda: self.axes.get_graph(\n",
        "            lambda x: get_A() * np.sin(\n",
        "                get_k() * x - get_phi()\n",
        "            ),\n",
        "            x_min=self.graph_x_min,\n",
        "            x_max=self.graph_x_max,\n",
        "        ).color_using_background_image(\"VerticalTempGradient\"))\n",
        "\n",
        "        self.play(ShowCreation(sine_wave, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(A_tracker.set_value, 1.25)\n",
        "        self.play(A_tracker.set_value, 0.75)\n",
        "        self.play(phi_tracker.set_value, -PI / 2)\n",
        "        self.play(k_tracker.set_value, 3 * TAU)\n",
        "        self.play(k_tracker.set_value, 2 * TAU)\n",
        "        self.play(\n",
        "            k_tracker.set_value, PI,\n",
        "            A_tracker.set_value, 4 / PI,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.sine_wave = sine_wave\n",
        "\n",
        "    def sum_of_sine_waves(self):\n",
        "        curr_sine_wave = self.sine_wave\n",
        "        axes = self.axes\n",
        "\n",
        "        sine_graphs = self.get_sine_graphs(axes)\n",
        "        partial_sums = self.get_partial_sums(axes, sine_graphs)\n",
        "\n",
        "        curr_partial_sum = partial_sums[0]\n",
        "        curr_partial_sum.set_color(WHITE)\n",
        "        self.play(\n",
        "            FadeOut(curr_sine_wave),\n",
        "            FadeIn(curr_partial_sum),\n",
        "            FadeOut(self.rods),\n",
        "        )\n",
        "        # Copy-pasting from superclass...in theory,\n",
        "        # this should be better abstracted, but eh.\n",
        "        pairs = list(zip(sine_graphs, partial_sums))[1:]\n",
        "        for sine_graph, partial_sum in pairs:\n",
        "            anims1 = [\n",
        "                ShowCreation(sine_graph)\n",
        "            ]\n",
        "            partial_sum.set_stroke(BLACK, 4, background=True)\n",
        "            anims2 = [\n",
        "                curr_partial_sum.set_stroke,\n",
        "                {\"width\": 1, \"opacity\": 0.25},\n",
        "                curr_partial_sum.set_stroke,\n",
        "                {\"width\": 0, \"background\": True},\n",
        "                ReplacementTransform(\n",
        "                    sine_graph, partial_sum,\n",
        "                    remover=True\n",
        "                ),\n",
        "            ]\n",
        "            self.play(*anims1)\n",
        "            self.play(*anims2)\n",
        "            curr_partial_sum = partial_sum\n",
        "\n",
        "    #\n",
        "    def setup_axes(self):\n",
        "        super().setup_axes()\n",
        "        self.axes.shift(\n",
        "            self.axes.c2p(0, 0)[1] * DOWN\n",
        "        )\n",
        "\n",
        "\n",
        "class BreakDownStepFunction(StepFunctionExample):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_axis_config\": {\n",
        "                \"stroke_width\": 2,\n",
        "            },\n",
        "            \"y_axis_config\": {\n",
        "                \"tick_frequency\": 0.25,\n",
        "                \"stroke_width\": 2,\n",
        "            },\n",
        "            \"y_min\": -1.25,\n",
        "            \"y_max\": 1.25,\n",
        "        },\n",
        "        \"alpha\": 0.1,\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_graph()\n",
        "        self.setup_clock()\n",
        "        self.add_rod()\n",
        "\n",
        "        self.wait()\n",
        "        self.init_updaters()\n",
        "        self.play(\n",
        "            self.get_clock_anim(self.wait_time)\n",
        "        )\n",
        "\n",
        "    def setup_axes(self):\n",
        "        super().setup_axes()\n",
        "        axes = self.axes\n",
        "        axes.to_edge(LEFT)\n",
        "\n",
        "        mini_axes = VGroup(*[\n",
        "            axes.deepcopy()\n",
        "            for x in range(4)\n",
        "        ])\n",
        "        for n, ma in zip(it.count(1, 2), mini_axes):\n",
        "            if n == 1:\n",
        "                t1 = OldTex(\"1\")\n",
        "                t2 = OldTex(\"-1\")\n",
        "            else:\n",
        "                t1 = OldTex(\"1 / \" + str(n))\n",
        "                t2 = OldTex(\"-1 / \" + str(n))\n",
        "            VGroup(t1, t2).scale(1.5)\n",
        "            t1.next_to(ma.y_axis.n2p(1), LEFT, MED_SMALL_BUFF)\n",
        "            t2.next_to(ma.y_axis.n2p(-1), LEFT, MED_SMALL_BUFF)\n",
        "            ma.y_axis.numbers.set_opacity(0)\n",
        "            ma.y_axis.add(t1, t2)\n",
        "\n",
        "        for mob in mini_axes.get_family():\n",
        "            if isinstance(mob, Line):\n",
        "                mob.set_stroke(width=1, family=False)\n",
        "        mini_axes.arrange(DOWN, buff=2)\n",
        "        mini_axes.set_height(FRAME_HEIGHT - 1.5)\n",
        "        mini_axes.to_corner(UR)\n",
        "        self.scale_factor = fdiv(\n",
        "            mini_axes[0].get_width(),\n",
        "            axes.get_width(),\n",
        "        )\n",
        "\n",
        "        # mini_axes.arrange(RIGHT, buff=2)\n",
        "        # mini_axes.set_width(FRAME_WIDTH - 1.5)\n",
        "        # mini_axes.to_edge(LEFT)\n",
        "\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(mini_axes, DOWN)\n",
        "        dots.shift_onto_screen()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(mini_axes)\n",
        "        self.add(dots)\n",
        "\n",
        "        self.mini_axes = mini_axes\n",
        "\n",
        "    def setup_graph(self):\n",
        "        super().setup_graph()\n",
        "        graph = self.graph\n",
        "        self.add(graph)\n",
        "\n",
        "        mini_axes = self.mini_axes\n",
        "        mini_graphs = VGroup()\n",
        "        for axes, u, n in zip(mini_axes, it.cycle([1, -1]), it.count(1, 2)):\n",
        "            mini_graph = axes.get_graph(\n",
        "                lambda x: (4 / PI) * (u / 1) * np.cos(PI * n * x),\n",
        "            )\n",
        "            mini_graph.set_stroke(WHITE, width=2)\n",
        "            mini_graphs.add(mini_graph)\n",
        "        # mini_graphs.set_color_by_gradient(\n",
        "        #     BLUE, GREEN, RED, YELLOW,\n",
        "        # )\n",
        "\n",
        "        self.mini_graphs = mini_graphs\n",
        "        self.add(mini_graphs)\n",
        "\n",
        "    def setup_clock(self):\n",
        "        super().setup_clock()\n",
        "        clock = self.clock\n",
        "        time_label = self.time_label\n",
        "\n",
        "        clock.move_to(3 * RIGHT)\n",
        "        clock.to_corner(UP)\n",
        "        time_label.next_to(clock, DOWN)\n",
        "\n",
        "        self.add(clock)\n",
        "        self.add(time_label)\n",
        "\n",
        "    def add_rod(self):\n",
        "        self.rod = self.get_rod(0, 1)\n",
        "        self.add(self.rod)\n",
        "\n",
        "    def init_updaters(self):\n",
        "        self.graph.add_updater(self.update_graph)\n",
        "        for mg in self.mini_graphs:\n",
        "            mg.add_updater(\n",
        "                lambda m, dt: self.update_graph(\n",
        "                    m, dt,\n",
        "                    alpha=self.scale_factor * self.alpha\n",
        "                )\n",
        "            )\n",
        "        self.time_label.add_updater(\n",
        "            lambda d, dt: d.increment_value(dt)\n",
        "        )\n",
        "        self.rod.add_updater(\n",
        "            lambda r: self.update_rods([r])\n",
        "        )\n"
    ]
}