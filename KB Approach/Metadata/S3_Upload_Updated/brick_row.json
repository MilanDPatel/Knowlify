{
    "topic": "demonstrates the concept of a \"Brick Row\" animation, which is a visual representation",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.eop.reusables.eop_helpers import *\n",
        "from _2018.eop.reusables.eop_constants import *\n",
        "from _2018.eop.reusables.upright_coins import *\n",
        "\n",
        "class BrickRow(VMobject):\n",
        "\n",
        "    CONFIG = {\n",
        "        \"left_color\" : COLOR_HEADS,\n",
        "        \"right_color\" : COLOR_TAILS,\n",
        "        \"height\" : 1.0,\n",
        "        \"width\" : 8.0,\n",
        "        \"outcome_shrinkage_factor_x\" : 0.95,\n",
        "        \"outcome_shrinkage_factor_y\" : 0.94\n",
        "    }\n",
        "\n",
        "    def __init__(self, n, **kwargs):\n",
        "        self.subdiv_level = n\n",
        "        self.coloring_level = n\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "\n",
        "\n",
        "    def init_points(self):\n",
        "\n",
        "        self.submobjects = []\n",
        "        self.rects = self.get_rects_for_level(self.coloring_level)\n",
        "        self.add(self.rects)\n",
        "        self.subdivs = self.get_subdivs_for_level(self.subdiv_level)\n",
        "        self.add(self.subdivs)\n",
        "\n",
        "        self.border = SurroundingRectangle(self,\n",
        "            buff = 0, color = WHITE)\n",
        "        self.add(self.border)\n",
        "\n",
        "\n",
        "\n",
        "    def get_rects_for_level(self,r):\n",
        "        rects = VGroup()\n",
        "        for k in range(r + 1):\n",
        "            proportion = float(choose(r,k)) / 2**r\n",
        "            new_rect = Rectangle(\n",
        "                width = proportion * self.width, \n",
        "                height = self.height,\n",
        "                fill_color = graded_color(r,k),\n",
        "                fill_opacity = 1,\n",
        "                stroke_width = 0\n",
        "            )\n",
        "            if len(rects.submobjects) > 0:\n",
        "                new_rect.next_to(rects,RIGHT,buff = 0)\n",
        "            else:\n",
        "                new_rect.next_to(self.get_center() + 0.5 * self.width * LEFT, RIGHT, buff = 0)\n",
        "            rects.add(new_rect)\n",
        "        return rects\n",
        "\n",
        "\n",
        "    def get_subdivs_for_level(self,r):\n",
        "        subdivs = VGroup()\n",
        "        x = - 0.5 * self.width\n",
        "        for k in range(0, r):\n",
        "            proportion = float(choose(r,k)) / 2**r\n",
        "            x += proportion * self.width\n",
        "            subdiv = Line(\n",
        "                x * RIGHT + 0.5 * self.height * UP,\n",
        "                x * RIGHT + 0.5 * self.height * DOWN,\n",
        "            )\n",
        "            subdivs.add(subdiv)\n",
        "        subdivs.move_to(self.get_center())\n",
        "        return subdivs\n",
        "\n",
        "\n",
        "    def get_sequence_subdivs_for_level(self,r):\n",
        "        subdivs = VGroup()\n",
        "        x = - 0.5 * self.width\n",
        "        dx = 1.0 / 2**r\n",
        "        for k in range(1, 2 ** r):\n",
        "            proportion = dx\n",
        "            x += proportion * self.width\n",
        "            subdiv = DashedLine(\n",
        "                x * RIGHT + 0.5 * self.height * UP,\n",
        "                x * RIGHT + 0.5 * self.height * DOWN,\n",
        "            )\n",
        "            subdivs.add(subdiv)\n",
        "        subdivs.move_to(self.get_center())\n",
        "        return subdivs\n",
        "\n",
        "\n",
        "    def get_outcome_centers_for_level(self,r):\n",
        "        \n",
        "        dpos = float(self.width) / (2 ** r) * RIGHT\n",
        "        pos = 0.5 * self.width * LEFT + 0.5 * dpos\n",
        "        centers = []\n",
        "        for k in range(0, 2 ** r):\n",
        "            centers.append(self.get_center() + pos + k * dpos)\n",
        "\n",
        "        return centers\n",
        "\n",
        "    def get_outcome_rects_for_level(self, r, inset = False, with_labels = False):\n",
        "\n",
        "        centers = self.get_outcome_centers_for_level(r)\n",
        "        if inset == True:\n",
        "            outcome_width = self.outcome_shrinkage_factor_x * float(self.width) / (2 ** r)\n",
        "            outcome_height = self.outcome_shrinkage_factor_y * self.height\n",
        "        else:\n",
        "            outcome_width = float(self.width) / (2 ** r)\n",
        "            outcome_height = self.height\n",
        "        \n",
        "        corner_radius = 0.1 # max(0.1, 0.3 * min(outcome_width, outcome_height))\n",
        "        # this scales down the corner radius for very narrow rects\n",
        "        rect = RoundedRectangle(\n",
        "            width = outcome_width,\n",
        "            height = outcome_height,\n",
        "            corner_radius = corner_radius,\n",
        "            fill_color = OUTCOME_COLOR,\n",
        "            fill_opacity = OUTCOME_OPACITY,\n",
        "            stroke_width = 0\n",
        "        )\n",
        "        rects = VGroup()\n",
        "        for center in centers:\n",
        "            rects.add(rect.copy().move_to(center))\n",
        "\n",
        "        rects.move_to(self.get_center())\n",
        "\n",
        "\n",
        "        if with_labels == False:\n",
        "            return rects\n",
        "\n",
        "        # else\n",
        "        sequences = self.get_coin_sequences_for_level(r)\n",
        "        labels = VGroup()\n",
        "        for (seq, rect) in zip(sequences, rects):\n",
        "            coin_seq = CoinSequence(seq, direction = DOWN)\n",
        "            coin_seq.shift(rect.get_center() - coin_seq.get_center())\n",
        "            # not simply move_to bc coin_seq is not centered\n",
        "            rect.add(coin_seq)\n",
        "            rect.label = coin_seq\n",
        "\n",
        "        return rects\n",
        "\n",
        "    def get_coin_sequences_for_level(self,r):\n",
        "        # array of arrays of characters\n",
        "        if r < 0 or int(r) != r:\n",
        "            raise Exception(\"Level must be a positive integer\")\n",
        "        if r == 0:\n",
        "            return []\n",
        "        if r == 1:\n",
        "            return [[\"H\"], [\"T\"]]\n",
        "\n",
        "        previous_seq_array = self.get_coin_sequences_for_level(r - 1)\n",
        "        subdiv_lengths = [choose(r - 1, k) for k in range(r)]\n",
        "\n",
        "        seq_array = []\n",
        "        index = 0\n",
        "        for length in subdiv_lengths:\n",
        "            \n",
        "            for seq in previous_seq_array[index:index + length]:\n",
        "                seq_copy = copy.copy(seq)\n",
        "                seq_copy.append(\"H\")\n",
        "                seq_array.append(seq_copy)\n",
        "\n",
        "            for seq in previous_seq_array[index:index + length]:\n",
        "                seq_copy = copy.copy(seq)\n",
        "                seq_copy.append(\"T\")\n",
        "                seq_array.append(seq_copy)\n",
        "            index += length\n",
        "\n",
        "        return seq_array\n",
        "\n",
        "\n",
        "    def get_outcome_width_for_level(self,r):\n",
        "        return self.width / (2**r)\n",
        "\n",
        "    def get_rect_widths_for_level(self, r):\n",
        "        ret_arr = []\n",
        "        for k in range(0, r):\n",
        "            proportion = float(choose(r,k)) / 2**r\n",
        "            ret_arr.append(proportion * self.width)\n",
        "        return ret_arr\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class SplitRectsInBrickWall(AnimationGroup):\n",
        "\n",
        "    def __init__(self, mobject, **kwargs):\n",
        "\n",
        "        #print mobject.height, mobject.get_height()\n",
        "        r = self.subdiv_level = mobject.subdiv_level + 1\n",
        "        \n",
        "        subdivs = VGroup()\n",
        "        x = -0.5 * mobject.get_width()\n",
        "\n",
        "        anims = []\n",
        "        for k in range(0, r):\n",
        "            proportion = float(choose(r,k)) / 2**r\n",
        "            x += proportion * mobject.get_width()\n",
        "            subdiv = DashedLine(\n",
        "                mobject.get_top() + x * RIGHT,\n",
        "                mobject.get_bottom() + x * RIGHT,\n",
        "                dash_length = 0.05\n",
        "            )\n",
        "            subdivs.add(subdiv)\n",
        "            anims.append(ShowCreation(subdiv))\n",
        "\n",
        "        mobject.add(subdivs)\n",
        "        AnimationGroup.__init__(self, *anims, **kwargs)\n",
        "\n",
        "\n",
        "\n"
    ]
}