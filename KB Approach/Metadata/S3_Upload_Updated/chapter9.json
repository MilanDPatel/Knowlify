{
    "topic": "demonstrates the concept of finding the average value of a continuous variable by graphing the function",
    "code": [
        "import scipy\n",
        "import fractions\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "class Chapter9OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"We often hear that mathematics consists mainly of\", \n",
        "            \"proving theorems.\",\n",
        "            \"Is a writer's job mainly that of\\\\\\\\\",\n",
        "            \"writing sentences?\"\n",
        "        ],\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"proving theorems.\" : MAROON_B,\n",
        "            \"writing sentences?\" : MAROON_B,\n",
        "        },\n",
        "        \"author\" : \"Gian-Carlo Rota\",\n",
        "    }\n",
        "\n",
        "class AverageOfContinuousVariable(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"bounds\" : [1, 7],\n",
        "        \"bound_colors\" : [RED, GREEN],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(\n",
        "            lambda x : 0.1*x*(x-3)*(x-6) + 4\n",
        "        )\n",
        "        graph_label = self.get_graph_label(graph, \"f(x)\")\n",
        "        boundary_lines = self.get_vertical_lines_to_graph(\n",
        "            graph, *self.bounds, num_lines = 2,\n",
        "            line_class = DashedLine\n",
        "        )\n",
        "        for line, color in zip(boundary_lines, self.bound_colors):\n",
        "            line.set_color(color)\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.bounds[0], graph, color = YELLOW,\n",
        "        )\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"What is the average \\\\\\\\ value of $f(x)$?\"\n",
        "        )\n",
        "        question.next_to(boundary_lines, UP)\n",
        "\n",
        "        self.play(ShowCreation(graph), Write(graph_label))\n",
        "        self.play(ShowCreation(boundary_lines))\n",
        "        self.play(FadeIn(\n",
        "            question,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.play(ShowCreation(v_line))\n",
        "        for bound in reversed(self.bounds):\n",
        "            self.play(self.get_v_line_change_anim(\n",
        "                v_line, graph, bound, \n",
        "                run_time = 3,\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "    def get_v_line_change_anim(self, v_line, graph, target_x, **kwargs):\n",
        "        start_x = self.x_axis.point_to_number(v_line.get_bottom())\n",
        "        def update(v_line, alpha):\n",
        "            new_x = interpolate(start_x, target_x, alpha)\n",
        "            v_line.put_start_and_end_on(\n",
        "                self.coords_to_point(new_x, 0),\n",
        "                self.input_to_graph_point(new_x, graph)\n",
        "            )\n",
        "            return v_line\n",
        "        return UpdateFromAlphaFunc(v_line, update, **kwargs)\n",
        "\n",
        "class ThisVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[8]\n",
        "\n",
        "        self.play(FadeIn(series, lag_ratio = 0.5))\n",
        "        self.teacher_says(\n",
        "            \"A new view of \\\\\\\\ the fundamental theorem\",\n",
        "            bubble_config = {\"height\" : 3},\n",
        "            added_anims = [\n",
        "                this_video.shift, this_video.get_height()*DOWN/2,\n",
        "                this_video.set_color, YELLOW,\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class AverageOfSineStart(AverageOfContinuousVariable):\n",
        "    CONFIG = {\n",
        "        \"y_min\" : -2, \n",
        "        \"y_max\" : 2,\n",
        "        \"x_min\" : -1,\n",
        "        \"x_max\" : 2.5*np.pi,\n",
        "        \"x_leftmost_tick\" : 0,\n",
        "        \"x_tick_frequency\" : np.pi/4,\n",
        "        \"x_axis_width\" : 12,\n",
        "        \"graph_origin\" : 5*LEFT,\n",
        "        \"x_label_scale_val\" : 0.75,\n",
        "        \"func\" : np.sin,\n",
        "        \"graph_color\" : BLUE,\n",
        "        \"bounds\" : [0, np.pi],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graph()\n",
        "        self.ask_about_average()\n",
        "\n",
        "    def add_graph(self, run_time = 1):\n",
        "        graph = self.get_graph(self.func, color = self.graph_color)\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, \"\\\\sin(x)\",\n",
        "            direction = UP\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(graph_label),\n",
        "            run_time = run_time\n",
        "        )\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "\n",
        "    def ask_about_average(self):\n",
        "        half_period_graph = self.get_graph_portion_between_bounds()\n",
        "        question = OldTexText(\"Average height?\")\n",
        "        question.to_edge(UP)\n",
        "        arrow = Arrow(question.get_bottom(), half_period_graph.get_top())\n",
        "        midpoint = np.mean(self.bounds)\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            midpoint, self.graph,\n",
        "            line_class = DashedLine,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(half_period_graph))\n",
        "        self.play(\n",
        "            Write(question, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        for bound in self.bounds + [midpoint]:\n",
        "            self.play(self.get_v_line_change_anim(\n",
        "                v_line, self.graph, bound,\n",
        "                run_time = 3\n",
        "            ))\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_graph_portion_between_bounds(self):\n",
        "        self.graph_portion_between_bounds = self.get_graph(\n",
        "            self.func,\n",
        "            x_min = self.bounds[0],\n",
        "            x_max = self.bounds[1],\n",
        "            color = YELLOW\n",
        "        )\n",
        "        return self.graph_portion_between_bounds\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        self.add_x_axis_labels()\n",
        "\n",
        "    def add_x_axis_labels(self):\n",
        "        labels_and_x_values = [\n",
        "            (\"\\\\pi/2\", np.pi/2),\n",
        "            (\"\\\\pi\", np.pi),\n",
        "            (\"3\\\\pi/2\", 3*np.pi/2),\n",
        "            (\"2\\\\pi\", 2*np.pi),\n",
        "        ]\n",
        "        self.x_axis_labels = VGroup()\n",
        "        for label, x in labels_and_x_values:\n",
        "            tex_mob = OldTex(label)\n",
        "            tex_mob.scale(self.x_label_scale_val)\n",
        "            tex_mob.move_to(\n",
        "                self.coords_to_point(x, -3*self.x_axis.tick_size), \n",
        "            )\n",
        "            self.add(tex_mob)\n",
        "            self.x_axis_labels.add(tex_mob)\n",
        "\n",
        "class LengthOfDayGraph(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 365,\n",
        "        \"x_axis_width\" : 12,\n",
        "        \"x_tick_frequency\" : 25,\n",
        "        \"x_labeled_nums\" : list(range(50, 365, 50)),\n",
        "        \"x_axis_label\" : \"Days since March 21\",\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 16,\n",
        "        \"y_axis_height\" : 6,\n",
        "        \"y_tick_frequency\" : 1,\n",
        "        \"y_labeled_nums\" : list(range(2, 15, 2)),\n",
        "        \"y_axis_label\" : \"Hours of daylight\",\n",
        "        \"graph_origin\" : 6*LEFT + 3*DOWN,\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "        \"camera_config\" : {\n",
        "            \"shading_factor\" : 1,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graph()\n",
        "        self.show_solar_pannel()\n",
        "        self.set_color_summer_months()\n",
        "        self.mention_constants()\n",
        "\n",
        "    def add_graph(self):\n",
        "        x_label = self.x_axis_label_mob\n",
        "        y_label = self.y_axis_label_mob\n",
        "\n",
        "        graph = self.get_graph(\n",
        "            lambda x : 2.7*np.sin((2*np.pi)*x/365 ) + 12.4,\n",
        "            color = GREEN,\n",
        "        )\n",
        "        graph_label = OldTex(\"2.7\\\\sin(2\\\\pi x/365) + 12.4\")\n",
        "        graph_label.to_corner(UP+RIGHT).shift(LEFT)\n",
        "        VGroup(*graph_label[3:6]).set_color(graph.get_color())\n",
        "        graph_label[9].set_color(YELLOW)\n",
        "\n",
        "        self.remove(x_label, y_label)\n",
        "        for label in y_label, x_label:\n",
        "            self.play(FadeIn(\n",
        "                label, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.play(\n",
        "            ShowCreation(graph, rate_func=linear),\n",
        "            FadeIn(\n",
        "                graph_label,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph \n",
        "        self.graph_label = graph_label\n",
        "\n",
        "    def show_solar_pannel(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        panel = ThreeDMobject(*[\n",
        "            Rectangle(\n",
        "                height = 0.7, width = 0.25,\n",
        "                fill_color = GREY_D,\n",
        "                fill_opacity = 1,\n",
        "                stroke_width = 1,\n",
        "                stroke_color = GREY,\n",
        "            )\n",
        "            for x in range(6)\n",
        "        ])\n",
        "        panel.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        panel.center()\n",
        "        panels = ThreeDMobject(panel, panel.copy(), panel.copy())\n",
        "        panels.arrange(DOWN)\n",
        "        panels.rotate(4*np.pi/12, DOWN)\n",
        "        panels.rotate(-np.pi/6, OUT)\n",
        "        side_vect = RIGHT\n",
        "        side_vect = rotate_vector(side_vect, 4*np.pi/12, DOWN)\n",
        "        side_vect = rotate_vector(side_vect, -np.pi/3, OUT)\n",
        "        panels.next_to(randy.get_corner(UP+RIGHT), RIGHT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change, \"thinking\", panels.get_right(),\n",
        "            FadeIn(\n",
        "                panels, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "        )\n",
        "        for angle in -np.pi/4, np.pi/4:\n",
        "            self.play(*[\n",
        "                Rotate(\n",
        "                    panel, angle,\n",
        "                    axis = side_vect,\n",
        "                    in_place = True,\n",
        "                    run_time = 2,\n",
        "                    rate_func = squish_rate_func(smooth, a, a+0.8)              \n",
        "                )\n",
        "                for panel, a in zip(panels, np.linspace(0, 0.2, len(panels)))\n",
        "            ])\n",
        "        self.play(Blink(randy))\n",
        "        self.play(*list(map(FadeOut, [randy, panels])))\n",
        "\n",
        "    def set_color_summer_months(self):\n",
        "        summer_rect = Rectangle()\n",
        "        summer_rect.set_stroke(width = 0)\n",
        "        summer_rect.set_fill(YELLOW, opacity = 0.25)\n",
        "        summer_rect.replace(Line(\n",
        "            self.graph_origin,\n",
        "            self.coords_to_point(365/2, 15.5)\n",
        "        ), stretch = True)\n",
        "\n",
        "        winter_rect = Rectangle()\n",
        "        winter_rect.set_stroke(width = 0)\n",
        "        winter_rect.set_fill(BLUE, opacity = 0.25)\n",
        "        winter_rect.replace(Line(\n",
        "            self.coords_to_point(365/2, 15.5),\n",
        "            self.coords_to_point(365, 0),\n",
        "        ), stretch = True)\n",
        "\n",
        "\n",
        "        summer_words, winter_words = [\n",
        "            OldTexText(\"%s \\\\\\\\ months\"%s).move_to(rect)\n",
        "            for s, rect in [\n",
        "                (\"Summer\", summer_rect),\n",
        "                (\"Winter\", winter_rect),\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        for rect, words in (summer_rect, summer_words), (winter_rect, winter_words):\n",
        "            self.play(\n",
        "                FadeIn(rect),\n",
        "                Write(words, run_time = 2)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def mention_constants(self):\n",
        "        #2.7\\\\sin(2\\\\pi t/365) + 12.4\n",
        "        constants = VGroup(*[\n",
        "            VGroup(*self.graph_label[i:j])\n",
        "            for i, j in [(0, 3), (7, 9), (11, 14), (16, 20)]\n",
        "        ])\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda c : c.scale(0.9).shift(SMALL_BUFF*DOWN).set_color(RED),\n",
        "                constant,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(there_and_back, a, a+0.7)\n",
        "            )\n",
        "            for constant, a in zip(\n",
        "                constants, \n",
        "                np.linspace(0, 0.3, len(constants))\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "class AskAboutAverageOfContinuousVariables(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"The average \\\\dots of a \\\\\\\\ continuous thing?\",\n",
        "            target_mode = \"sassy\",\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"confused\")\n",
        "        self.play(self.teacher.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class AverageOfFiniteSet(Scene):\n",
        "    CONFIG = {\n",
        "        \"lengths\" : [1, 4, 2, 5]\n",
        "    }\n",
        "    def construct(self):\n",
        "        lengths = self.lengths\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, length*RIGHT)\n",
        "            for length in lengths\n",
        "        ])\n",
        "        colors = Color(BLUE).range_to(RED, len(lengths))\n",
        "        lines.set_color_by_gradient(*colors)\n",
        "        lines.arrange(RIGHT)\n",
        "        lines.generate_target()\n",
        "        lines.target.arrange(RIGHT, buff = 0)\n",
        "        for mob in lines, lines.target:\n",
        "            mob.shift(UP)\n",
        "        brace = Brace(lines.target, UP)\n",
        "\n",
        "        labels = VGroup(*[\n",
        "            OldTex(str(d)).next_to(line, UP).set_color(line.get_color())\n",
        "            for d, line in zip(lengths, lines)\n",
        "        ])\n",
        "        plusses = [Tex(\"+\") for x in range(len(lengths)-1)]\n",
        "        symbols = VGroup(*\n",
        "            plusses + [Tex(\"=\")]\n",
        "        )\n",
        "        symbols.set_fill(opacity = 0)\n",
        "\n",
        "        labels.generate_target()\n",
        "        symbols.generate_target()\n",
        "        symbols.target.set_fill(opacity = 1)\n",
        "        sum_eq = VGroup(*it.chain(*list(zip(labels.target, symbols.target))))\n",
        "        sum_eq.arrange(RIGHT)\n",
        "        sum_eq.next_to(brace, UP)\n",
        "\n",
        "        sum_mob = OldTex(str(sum(lengths)))\n",
        "        sum_mob.next_to(sum_eq, RIGHT)\n",
        "\n",
        "        dividing_lines = VGroup(*[\n",
        "            DashedLine(p + MED_SMALL_BUFF*UP, p + MED_LARGE_BUFF*DOWN)\n",
        "            for alpha in np.linspace(0, 1, len(lengths)+1)\n",
        "            for p in [interpolate(\n",
        "                lines.target.get_left(),\n",
        "                lines.target.get_right(),\n",
        "                alpha\n",
        "            )]\n",
        "        ])\n",
        "\n",
        "        lower_braces = VGroup(*[\n",
        "            Brace(VGroup(*dividing_lines[i:i+2]), DOWN)\n",
        "            for i in range(len(lengths))\n",
        "        ])\n",
        "        averages = VGroup(*[\n",
        "            lb.get_text(\"$%d/%d$\"%(sum(lengths), len(lengths)))\n",
        "            for lb in lower_braces\n",
        "        ])\n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(averages[1], stretch = True)\n",
        "        circle.scale(1.5)\n",
        "\n",
        "        self.add(lines)\n",
        "        self.play(FadeIn(\n",
        "            labels,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            *list(map(MoveToTarget, [lines, labels, symbols])),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Write(sum_mob))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(dividing_lines, run_time = 2))\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, averages)),\n",
        "            list(map(GrowFromCenter, lower_braces))\n",
        "        ))\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait(2)\n",
        "\n",
        "class TryToAddInfinitelyManyPoints(AverageOfSineStart):\n",
        "    CONFIG = {\n",
        "        \"max_denominator\" : 40,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.try_to_add_infinitely_many_values()\n",
        "        self.show_continuum()\n",
        "        self.mention_integral()\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.setup_axes()\n",
        "        AverageOfSineStart.add_graph(self, run_time = 0)\n",
        "        self.add(self.get_graph_portion_between_bounds())\n",
        "        self.graph_label.to_edge(RIGHT)\n",
        "        self.graph_label.shift(DOWN)\n",
        "\n",
        "    def try_to_add_infinitely_many_values(self):\n",
        "        v_lines = VGroup(*[\n",
        "            self.get_vertical_line_to_graph(\n",
        "                numerator*np.pi/denominator, self.graph,\n",
        "                color = YELLOW,\n",
        "                stroke_width = 6./denominator\n",
        "            )\n",
        "            for denominator in range(self.max_denominator)\n",
        "            for numerator in range(1, denominator)\n",
        "            if fractions.gcd(numerator, denominator) == 1\n",
        "        ])\n",
        "        ghost_lines = v_lines.copy().set_stroke(GREY)\n",
        "\n",
        "        v_lines.generate_target()\n",
        "        start_lines = VGroup(*v_lines.target[:15])\n",
        "        end_lines = VGroup(*v_lines.target[15:])\n",
        "\n",
        "        plusses = VGroup(*[Tex(\"+\") for x in start_lines])\n",
        "        sum_eq = VGroup(*it.chain(*list(zip(start_lines, plusses))))\n",
        "        sum_eq.add(*end_lines)\n",
        "        sum_eq.arrange(RIGHT)\n",
        "        sum_eq.next_to(v_lines[0], UP, aligned_edge = LEFT)\n",
        "        sum_eq.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(start_lines.get_width())\n",
        "        h_line.set_color(WHITE)\n",
        "        h_line.next_to(sum_eq, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        infinity = OldTex(\"\\\\infty\")\n",
        "        infinity.next_to(h_line, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(\n",
        "            v_lines, \n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.add(ghost_lines, v_lines)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                v_lines,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Write(plusses)\n",
        "        )\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.play(Write(infinity))\n",
        "        self.wait()\n",
        "\n",
        "    def show_continuum(self):\n",
        "        arrow = Arrow(ORIGIN, UP+LEFT)\n",
        "        input_range = Line(*[\n",
        "            self.coords_to_point(bound, 0)\n",
        "            for bound in self.bounds\n",
        "        ])\n",
        "        VGroup(arrow, input_range).set_color(RED)\n",
        "\n",
        "        self.play(FadeIn(arrow))\n",
        "        self.play(\n",
        "            arrow.next_to, input_range.get_start(), \n",
        "            DOWN+RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        self.play(\n",
        "            arrow.next_to, input_range.copy().get_end(), \n",
        "            DOWN+RIGHT, SMALL_BUFF,\n",
        "            ShowCreation(input_range),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.play(\n",
        "            arrow.next_to, input_range.get_start(), \n",
        "            DOWN+RIGHT, SMALL_BUFF,\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(FadeOut(arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def mention_integral(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(3*LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"Use an integral!\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            target_mode = \"hooray\"\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        curr_bubble = randy.bubble\n",
        "        new_bubble = randy.get_bubble(\"Somehow...\")\n",
        "        self.play(\n",
        "            Transform(curr_bubble, new_bubble),\n",
        "            Transform(curr_bubble.content, new_bubble.content),\n",
        "            randy.change_mode, \"shruggie\",\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class FiniteSample(TryToAddInfinitelyManyPoints):\n",
        "    CONFIG = {\n",
        "        \"dx\" : 0.1,\n",
        "        \"graph_origin\" : 6*LEFT + 0.5*DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_graph()\n",
        "        self.show_finite_sample()\n",
        "\n",
        "    def show_finite_sample(self):\n",
        "        v_lines = self.get_sample_lines(dx = self.dx)\n",
        "        summed_v_lines = v_lines.copy()\n",
        "        plusses = VGroup(*[\n",
        "            OldTex(\"+\").scale(0.75)\n",
        "            for l in v_lines\n",
        "        ])\n",
        "        numerator = VGroup(*it.chain(*list(zip(summed_v_lines, plusses))))\n",
        "        for group in numerator, plusses:\n",
        "            group.remove(plusses[-1])\n",
        "        numerator.arrange(\n",
        "            RIGHT, \n",
        "            buff = SMALL_BUFF,\n",
        "            aligned_edge = DOWN\n",
        "        )\n",
        "        # numerator.set_width(FRAME_X_RADIUS)\n",
        "        numerator.scale(0.5)\n",
        "        numerator.move_to(self.coords_to_point(3*np.pi/2, 0))\n",
        "        numerator.to_edge(UP)\n",
        "        frac_line = OldTex(\"\\\\over \\\\,\")\n",
        "        frac_line.stretch_to_fit_width(numerator.get_width())\n",
        "        frac_line.next_to(numerator, DOWN)\n",
        "        denominator = OldTexText(\"(Num. samples)\")\n",
        "        denominator.next_to(frac_line, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(v_lines, run_time = 3))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                v_lines.copy(),\n",
        "                summed_v_lines,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Write(\n",
        "                plusses,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 1)\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(frac_line, run_time = 1))\n",
        "        self.play(Write(denominator))\n",
        "        self.wait()\n",
        "\n",
        "        self.plusses = plusses\n",
        "        self.average = VGroup(numerator, frac_line, denominator)\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_sample_lines(self, dx, color = YELLOW, stroke_width = 2):\n",
        "        return VGroup(*[\n",
        "            self.get_vertical_line_to_graph(\n",
        "                x, self.graph,\n",
        "                color = color,\n",
        "                stroke_width = stroke_width,\n",
        "            )\n",
        "            for x in np.arange(\n",
        "                self.bounds[0]+dx, \n",
        "                self.bounds[1], \n",
        "                dx\n",
        "            )\n",
        "        ])\n",
        "\n",
        "class FiniteSampleWithMoreSamplePoints(FiniteSample):\n",
        "    CONFIG = {\n",
        "        \"dx\" : 0.05\n",
        "    }\n",
        "\n",
        "class FeelsRelatedToAnIntegral(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Seems integral-ish...\",\n",
        "            target_mode = \"maybe\"\n",
        "        )\n",
        "        self.play(self.teacher.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class IntegralOfSine(FiniteSample):\n",
        "    CONFIG = {\n",
        "        \"thin_dx\" : 0.01,\n",
        "        \"rect_opacity\" : 0.75,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        FiniteSample.construct(self)\n",
        "        self.remove(self.y_axis_label_mob)\n",
        "        self.remove(*self.x_axis_labels[::2])\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.put_average_in_corner()\n",
        "        self.write_integral()\n",
        "        self.show_riemann_rectangles()\n",
        "        self.let_dx_approach_zero()\n",
        "        self.bring_back_average()\n",
        "        self.distribute_dx()\n",
        "        self.let_dx_approach_zero(restore = False)\n",
        "        self.write_area_over_width()\n",
        "        self.show_moving_v_line()\n",
        "\n",
        "    def put_average_in_corner(self):\n",
        "        self.average.save_state()\n",
        "        self.plusses.set_stroke(width = 0.5)\n",
        "        self.play(\n",
        "            self.average.scale, 0.75,\n",
        "            self.average.to_corner, DOWN+RIGHT,\n",
        "        )\n",
        "\n",
        "    def write_integral(self):\n",
        "        integral = OldTex(\"\\\\int_0^\\\\pi\", \"\\\\sin(x)\", \"\\\\,dx\")\n",
        "        integral.move_to(self.graph_portion_between_bounds)\n",
        "        integral.to_edge(UP)\n",
        "\n",
        "        self.play(Write(integral))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.integral = integral\n",
        "\n",
        "    def show_riemann_rectangles(self):\n",
        "        kwargs = {\n",
        "            \"dx\" : self.dx,\n",
        "            \"x_min\" : self.bounds[0],\n",
        "            \"x_max\" : self.bounds[1],\n",
        "            \"fill_opacity\" : self.rect_opacity,\n",
        "        }\n",
        "        rects = self.get_riemann_rectangles(self.graph, **kwargs)\n",
        "        rects.set_stroke(YELLOW, width = 1)\n",
        "        flat_rects = self.get_riemann_rectangles(\n",
        "            self.get_graph(lambda x : 0),\n",
        "            **kwargs\n",
        "        )\n",
        "        thin_kwargs = dict(kwargs)\n",
        "        thin_kwargs[\"dx\"] = self.thin_dx\n",
        "        thin_kwargs[\"stroke_width\"] = 0\n",
        "        self.thin_rects = self.get_riemann_rectangles(\n",
        "            self.graph,\n",
        "            **thin_kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "        start_index = 20\n",
        "        end_index = start_index + 5\n",
        "        low_opacity = 0.5\n",
        "        high_opacity = 1\n",
        "\n",
        "        start_rect = rects[start_index]\n",
        "        side_brace = Brace(start_rect, LEFT, buff = SMALL_BUFF)\n",
        "        bottom_brace = Brace(start_rect, DOWN, buff = SMALL_BUFF)\n",
        "        sin_x = OldTex(\"\\\\sin(x)\")\n",
        "        sin_x.next_to(side_brace, LEFT, SMALL_BUFF)\n",
        "        dx = bottom_brace.get_text(\"$dx$\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.transform_between_riemann_rects(\n",
        "            flat_rects, rects,\n",
        "            replace_mobject_with_target_in_scene = True,\n",
        "        )\n",
        "        self.remove(self.v_lines)\n",
        "        self.wait()\n",
        "\n",
        "        rects.save_state()\n",
        "        self.play(*it.chain(\n",
        "            [\n",
        "                ApplyMethod(\n",
        "                    rect.set_style_data, BLACK, 1,\n",
        "                    None, #Fill color\n",
        "                    high_opacity if rect is start_rect else low_opacity\n",
        "                )\n",
        "                for rect in rects\n",
        "            ],\n",
        "            list(map(GrowFromCenter, [side_brace, bottom_brace])),\n",
        "            list(map(Write, [sin_x, dx])),\n",
        "        ))\n",
        "        self.wait()\n",
        "        for i in range(start_index+1, end_index):\n",
        "            self.play(\n",
        "                rects[i-1].set_fill, None, low_opacity,\n",
        "                rects[i].set_fill, None, high_opacity,\n",
        "                side_brace.set_height, rects[i].get_height(),\n",
        "                side_brace.next_to, rects[i], LEFT, SMALL_BUFF,\n",
        "                bottom_brace.next_to, rects[i], DOWN, SMALL_BUFF,\n",
        "                MaintainPositionRelativeTo(sin_x, side_brace),\n",
        "                MaintainPositionRelativeTo(dx, bottom_brace),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            rects.restore,\n",
        "            *list(map(FadeOut, [sin_x, dx, side_brace, bottom_brace]))\n",
        "        )\n",
        "\n",
        "        self.rects = rects\n",
        "        self.dx_brace = bottom_brace\n",
        "        self.dx_label = dx\n",
        "\n",
        "    def let_dx_approach_zero(self, restore = True):\n",
        "        start_state = self.rects.copy()\n",
        "        self.transform_between_riemann_rects(\n",
        "            self.rects, self.thin_rects,\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        if restore:\n",
        "            self.transform_between_riemann_rects(\n",
        "                self.rects, start_state.copy(),\n",
        "                run_time = 2,\n",
        "            )\n",
        "            self.remove(self.rects)\n",
        "            self.rects = start_state\n",
        "            self.rects.set_fill(opacity = 1)\n",
        "            self.play(\n",
        "                self.rects.set_fill, None,\n",
        "                    self.rect_opacity,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def bring_back_average(self):\n",
        "        num_samples = self.average[-1]\n",
        "\n",
        "        example_dx = OldTex(\"0.1\")\n",
        "        example_dx.move_to(self.dx_label)\n",
        "\n",
        "        input_range = Line(*[\n",
        "            self.coords_to_point(bound, 0)\n",
        "            for bound in self.bounds\n",
        "        ])\n",
        "        input_range.set_color(RED)\n",
        "\n",
        "        #Bring back average\n",
        "        self.play(\n",
        "            self.average.restore,\n",
        "            self.average.center,\n",
        "            self.average.to_edge, UP,\n",
        "            self.integral.to_edge, DOWN,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(self.dx_brace),\n",
        "            Write(self.dx_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(self.dx_label),\n",
        "            FadeIn(example_dx)\n",
        "        )\n",
        "        self.play(Indicate(example_dx))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(input_range))\n",
        "        self.play(FadeOut(input_range))\n",
        "        self.wait()\n",
        "\n",
        "        #Ask how many there are\n",
        "        num_samples_copy = num_samples.copy()\n",
        "        v_lines = self.v_lines\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda l : l.shift(0.5*UP).set_color(GREEN),\n",
        "                line,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back, a, a+0.3\n",
        "                ),\n",
        "                run_time = 3,\n",
        "            )\n",
        "            for line, a in zip(\n",
        "                self.v_lines, \n",
        "                np.linspace(0, 0.7, len(self.v_lines))\n",
        "            )\n",
        "        ] + [\n",
        "            num_samples_copy.set_color, GREEN\n",
        "        ])\n",
        "        self.play(FadeOut(v_lines))\n",
        "        self.wait()\n",
        "\n",
        "        #Count number of samples\n",
        "        num_samples_copy.generate_target()\n",
        "        num_samples_copy.target.shift(DOWN + 0.5*LEFT)\n",
        "        rhs = OldTex(\"\\\\approx\", \"\\\\pi\", \"/\", \"0.1\")\n",
        "        rhs.next_to(num_samples_copy.target, RIGHT)\n",
        "        self.play(\n",
        "            MoveToTarget(num_samples_copy),\n",
        "            Write(rhs.get_part_by_tex(\"approx\")),\n",
        "        )\n",
        "        self.play(ShowCreation(input_range))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.x_axis_labels[1].copy(), \n",
        "            rhs.get_part_by_tex(\"pi\")\n",
        "        ))\n",
        "        self.play(FadeOut(input_range))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                example_dx.copy(), \n",
        "                rhs.get_part_by_tex(\"0.1\")\n",
        "            ),\n",
        "            Write(rhs.get_part_by_tex(\"/\"))\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Substitute number of samples\n",
        "        self.play(ReplacementTransform(\n",
        "            example_dx, self.dx_label\n",
        "        ))\n",
        "        dx = rhs.get_part_by_tex(\"0.1\") \n",
        "        self.play(Transform(\n",
        "            dx, OldTex(\"dx\").move_to(dx)\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        approx = rhs.get_part_by_tex(\"approx\")\n",
        "        rhs.remove(approx)\n",
        "        self.play(\n",
        "            FadeOut(num_samples),\n",
        "            FadeOut(num_samples_copy),\n",
        "            FadeOut(approx),\n",
        "            rhs.next_to, self.average[1], DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.pi_over_dx = rhs\n",
        "\n",
        "    def distribute_dx(self):\n",
        "        numerator, frac_line, denominator = self.average\n",
        "        pi, over, dx = self.pi_over_dx\n",
        "        integral = self.integral\n",
        "\n",
        "        dx.generate_target()\n",
        "        lp, rp = parens = OldTex(\"()\")\n",
        "        parens.set_height(numerator.get_height())\n",
        "        lp.next_to(numerator, LEFT)\n",
        "        rp.next_to(numerator, RIGHT)\n",
        "        dx.target.next_to(rp, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(dx, path_arc = np.pi/2),\n",
        "            Write(parens),\n",
        "            frac_line.stretch_to_fit_width, \n",
        "                parens.get_width() + dx.get_width(),\n",
        "            frac_line.shift, dx.get_width()*RIGHT/2,\n",
        "            FadeOut(over)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        average = VGroup(parens, numerator, dx, frac_line, pi)\n",
        "        integral.generate_target()\n",
        "        over_pi = OldTex(\"\\\\frac{\\\\phantom{\\\\int \\\\sin(x)\\\\dx}}{\\\\pi}\")\n",
        "        integral.target.set_width(over_pi.get_width())\n",
        "        integral.target.next_to(over_pi, UP)\n",
        "        integral_over_pi = VGroup(integral.target, over_pi)\n",
        "        integral_over_pi.to_corner(UP+RIGHT)\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        arrow.next_to(integral.target, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            average.scale, 0.9,\n",
        "            average.next_to, arrow, LEFT,\n",
        "            average.shift_onto_screen,\n",
        "            ShowCreation(arrow),\n",
        "            Write(over_pi),\n",
        "            MoveToTarget(integral, run_time = 2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [self.dx_label, self.dx_brace])))\n",
        "\n",
        "        self.integral_over_pi = VGroup(integral, over_pi)\n",
        "        self.average = average\n",
        "        self.average_arrow = arrow\n",
        "\n",
        "    def write_area_over_width(self):\n",
        "        self.play(\n",
        "            self.integral_over_pi.shift, 2*LEFT,\n",
        "            *list(map(FadeOut, [self.average, self.average_arrow]))\n",
        "        )\n",
        "\n",
        "        average_height = OldTexText(\"Average height = \")\n",
        "        area_over_width = OldTex(\n",
        "            \"{\\\\text{Area}\", \"\\\\over\\\\,\", \"\\\\text{Width}}\", \"=\"\n",
        "        )\n",
        "        area_over_width.get_part_by_tex(\"Area\").set_color_by_gradient(\n",
        "            BLUE, GREEN\n",
        "        )\n",
        "        area_over_width.next_to(self.integral_over_pi[1][0], LEFT)\n",
        "        average_height.next_to(area_over_width, LEFT)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [average_height, area_over_width])))\n",
        "        self.wait()\n",
        "\n",
        "    def show_moving_v_line(self):\n",
        "        mean = np.mean(self.bounds)\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            mean, self.graph,\n",
        "            line_class = DashedLine,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        for count in range(2):\n",
        "            for x in self.bounds + [mean]:\n",
        "                self.play(self.get_v_line_change_anim(\n",
        "                    v_line, self.graph, x,\n",
        "                    run_time = 3\n",
        "                ))\n",
        "\n",
        "class Approx31(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\"\\\\approx 31\")\n",
        "        tex.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        tex.to_edge(LEFT)\n",
        "        self.play(Write(tex))\n",
        "        self.wait(3)\n",
        "\n",
        "class LetsSolveThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        expression = OldTex(\n",
        "            \"{\\\\int_0^\\\\pi \", \" \\\\sin(x)\", \"\\\\,dx \\\\over \\\\pi}\"\n",
        "        )\n",
        "        expression.to_corner(UP+LEFT)\n",
        "        question = OldTexText(\n",
        "            \"What's the antiderivative \\\\\\\\ of\",\n",
        "            \"$\\\\sin(x)$\",\n",
        "            \"?\"\n",
        "        )\n",
        "        for tex_mob in expression, question:\n",
        "            tex_mob.set_color_by_tex(\"sin\", BLUE)\n",
        "        self.add(expression)\n",
        "\n",
        "        self.teacher_says(\"Let's compute it.\")\n",
        "        self.wait()\n",
        "        self.student_thinks(question)\n",
        "        self.wait(2)\n",
        "\n",
        "class Antiderivative(AverageOfSineStart):\n",
        "    CONFIG = {\n",
        "        \"antideriv_color\" : GREEN,\n",
        "        \"deriv_color\" : BLUE,\n",
        "        \"riemann_rect_dx\" : 0.01,\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"graph_origin\" : 4*LEFT + DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_x_axis_labels()\n",
        "        self.negate_derivative_of_cosine()\n",
        "        self.walk_through_slopes()\n",
        "        self.apply_ftoc()\n",
        "        self.show_difference_in_antiderivative()\n",
        "        self.comment_on_area()\n",
        "        self.divide_by_pi()\n",
        "        self.set_color_antiderivative_fraction()\n",
        "        self.show_slope()\n",
        "        self.bring_back_derivative()\n",
        "        self.show_tangent_slope()\n",
        "\n",
        "    def add_x_axis_labels(self):\n",
        "        AverageOfSineStart.add_x_axis_labels(self)\n",
        "        self.remove(*self.x_axis_labels[::2])\n",
        "\n",
        "    def negate_derivative_of_cosine(self):\n",
        "        cos, neg_cos, sin, neg_sin = graphs = [\n",
        "            self.get_graph(func)\n",
        "            for func in [\n",
        "                np.cos, \n",
        "                lambda x : -np.cos(x), \n",
        "                np.sin,\n",
        "                lambda x : -np.sin(x),\n",
        "            ]\n",
        "        ]\n",
        "        VGroup(cos, neg_cos).set_color(self.antideriv_color)\n",
        "        VGroup(sin, neg_sin).set_color(self.deriv_color)\n",
        "        labels = [\"\\\\cos(x)\", \"-\\\\cos(x)\", \"\\\\sin(x)\", \"-\\\\sin(x)\"]\n",
        "        x_vals = [2*np.pi, 2*np.pi, 5*np.pi/2, 5*np.pi/2]\n",
        "        vects = [UP, DOWN, UP, DOWN]\n",
        "        for graph, label, x_val, vect in zip(graphs, labels, x_vals, vects):\n",
        "            graph.label = self.get_graph_label(\n",
        "                graph, label,\n",
        "                x_val = x_val,\n",
        "                direction = vect,\n",
        "                buff = SMALL_BUFF\n",
        "            ) \n",
        "\n",
        "        derivs = []\n",
        "        for F, f in (\"\\\\cos\", \"-\\\\sin\"), (\"-\\\\cos\", \"\\\\sin\"):\n",
        "            deriv = OldTex(\n",
        "                \"{d(\", F, \")\", \"\\\\over\\\\,\", \"dx}\", \"(x)\", \n",
        "                \"=\", f, \"(x)\"\n",
        "            )\n",
        "            deriv.set_color_by_tex(F, self.antideriv_color)\n",
        "            deriv.set_color_by_tex(f, self.deriv_color)\n",
        "            deriv.to_edge(UP)\n",
        "            derivs.append(deriv)\n",
        "        cos_deriv, neg_cos_deriv = derivs\n",
        "\n",
        "        self.add(cos_deriv)\n",
        "        for graph in cos, neg_sin:\n",
        "            self.play(\n",
        "                ShowCreation(graph, rate_func = smooth),\n",
        "                Write(\n",
        "                    graph.label, \n",
        "                    rate_func = squish_rate_func(smooth, 0.3, 1)\n",
        "                ),\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(*pair)\n",
        "            for pair in [\n",
        "                (derivs),\n",
        "                (cos, neg_cos),\n",
        "                (cos.label, neg_cos.label),\n",
        "                (neg_sin, sin),\n",
        "                (neg_sin.label, sin.label),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        self.neg_cos = neg_cos\n",
        "        self.sin = sin\n",
        "        self.deriv = neg_cos_deriv\n",
        "\n",
        "    def walk_through_slopes(self):\n",
        "        neg_cos = self.neg_cos\n",
        "        sin = self.sin\n",
        "\n",
        "        faders = sin, sin.label\n",
        "        for mob in faders:\n",
        "            mob.save_state()\n",
        "        sin_copy = self.get_graph(\n",
        "            np.sin,\n",
        "            x_min = 0,\n",
        "            x_max = 2*np.pi,\n",
        "            color = BLUE,\n",
        "        )\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            0, neg_cos,\n",
        "            line_class = DashedLine,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            0, neg_cos,\n",
        "            dx = 0.001,\n",
        "            secant_line_color = YELLOW\n",
        "        )\n",
        "        def quad_smooth(t):\n",
        "            return 0.25*(np.floor(4*t) + smooth((4*t) % 1))\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(m.fade, 0.6)\n",
        "            for m in faders\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShowCreation, ss_group)), run_time = 2)\n",
        "        kwargs = {\n",
        "            \"run_time\" : 20,\n",
        "            \"rate_func\" : quad_smooth,\n",
        "        }\n",
        "        v_line_anim = self.get_v_line_change_anim(\n",
        "            v_line, sin_copy, 2*np.pi,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_x = 2*np.pi,\n",
        "            added_anims = [\n",
        "                ShowCreation(sin_copy, **kwargs),\n",
        "                v_line_anim\n",
        "            ],\n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            *list(map(FadeOut, [ss_group, v_line, sin_copy]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ss_group = ss_group\n",
        "\n",
        "    def apply_ftoc(self):\n",
        "        deriv = self.deriv\n",
        "        integral = OldTex(\n",
        "            \"\\\\int\", \"^\\\\pi\", \"_0\", \"\\\\sin(x)\", \"\\\\,dx\"\n",
        "        )\n",
        "        rhs = OldTex(\n",
        "            \"=\", \"\\\\big(\", \"-\\\\cos\", \"(\", \"\\\\pi\", \")\", \"\\\\big)\",\n",
        "            \"-\", \"\\\\big(\", \"-\\\\cos\", \"(\", \"0\", \")\", \"\\\\big)\",\n",
        "        )\n",
        "        rhs.next_to(integral, RIGHT)\n",
        "        equation = VGroup(integral, rhs)\n",
        "        equation.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n",
        "        (start_pi, end_pi), (start_zero, end_zero) = start_end_pairs = [\n",
        "            [\n",
        "                m.get_part_by_tex(tex) \n",
        "                for m in (integral, rhs)\n",
        "            ]\n",
        "            for tex in (\"\\\\pi\", \"0\")\n",
        "        ]\n",
        "\n",
        "        for tex_mob in integral, rhs:\n",
        "            tex_mob.set_color_by_tex(\"sin\", self.deriv_color)\n",
        "            tex_mob.set_color_by_tex(\"cos\", self.antideriv_color)\n",
        "            tex_mob.set_color_by_tex(\"0\", YELLOW)\n",
        "            tex_mob.set_color_by_tex(\"\\\\pi\", YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(integral),\n",
        "            self.deriv.scale, 0.5,\n",
        "            self.deriv.center,\n",
        "            self.deriv.to_edge, LEFT, MED_SMALL_BUFF,\n",
        "            self.deriv.shift, UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            VGroup(*[part for part in rhs if part not in [end_pi, end_zero]]),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        for start, end in start_end_pairs:\n",
        "            self.play(ReplacementTransform(\n",
        "                start.copy(), end,\n",
        "                path_arc = np.pi/6,\n",
        "                run_time = 2\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        self.integral = integral\n",
        "        self.rhs = rhs\n",
        "\n",
        "    def show_difference_in_antiderivative(self):\n",
        "        pi_point, zero_point = points = [\n",
        "            self.input_to_graph_point(x, self.neg_cos)\n",
        "            for x in reversed(self.bounds)\n",
        "        ]\n",
        "        interim_point = pi_point[0]*RIGHT + zero_point[1]*UP\n",
        "        pi_dot, zero_dot = dots = [\n",
        "            Dot(point, color = YELLOW)\n",
        "            for point in points\n",
        "        ]\n",
        "        v_line = DashedLine(pi_point, interim_point)\n",
        "        h_line = DashedLine(interim_point, zero_point)\n",
        "        v_line_brace = Brace(v_line, RIGHT)\n",
        "        two_height_label = v_line_brace.get_text(\n",
        "            \"$2$\", buff = SMALL_BUFF\n",
        "        )\n",
        "        two_height_label.add_background_rectangle()\n",
        "\n",
        "        pi = self.x_axis_labels[1]\n",
        "        #Horrible hack\n",
        "        black_pi = pi.copy().set_color(BLACK)\n",
        "        self.add(black_pi, pi)\n",
        "\n",
        "        cos_tex = self.rhs.get_part_by_tex(\"cos\")\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            cos_tex.copy(), pi_dot\n",
        "        ))\n",
        "        self.wait()\n",
        "        moving_dot = pi_dot.copy()\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            # Animation(pi),\n",
        "            pi.shift, 0.8*pi.get_width()*(LEFT+UP),\n",
        "            moving_dot.move_to, interim_point,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            ReplacementTransform(moving_dot, zero_dot)\n",
        "        )\n",
        "        self.play(GrowFromCenter(v_line_brace))\n",
        "        self.wait(2)\n",
        "        self.play(Write(two_height_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.v_line = v_line\n",
        "        self.h_line = h_line\n",
        "        self.pi_dot = pi_dot\n",
        "        self.zero_dot = zero_dot\n",
        "        self.v_line_brace = v_line_brace\n",
        "        self.two_height_label = two_height_label\n",
        "\n",
        "    def comment_on_area(self):\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            self.sin, \n",
        "            dx = self.riemann_rect_dx,\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = 0.7,\n",
        "            x_min = self.bounds[0],\n",
        "            x_max = self.bounds[1],\n",
        "        )\n",
        "        area_two = OldTex(\"2\").replace(\n",
        "            self.two_height_label\n",
        "        )\n",
        "\n",
        "        self.play(Write(rects))\n",
        "        self.wait()\n",
        "        self.play(area_two.move_to, rects)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.rects = rects\n",
        "        self.area_two = area_two\n",
        "\n",
        "    def divide_by_pi(self):\n",
        "        integral = self.integral\n",
        "        rhs = self.rhs\n",
        "        equals = rhs[0]\n",
        "        rhs_without_eq = VGroup(*rhs[1:])\n",
        "        frac_lines = VGroup(*[\n",
        "            OldTex(\"\\\\over\\\\,\").stretch_to_fit_width(\n",
        "                mob.get_width()\n",
        "            ).move_to(mob)\n",
        "            for mob in (integral, rhs_without_eq)\n",
        "        ])\n",
        "        frac_lines.shift(\n",
        "            (integral.get_height()/2 + SMALL_BUFF)*DOWN\n",
        "        )\n",
        "        pi_minus_zeros = VGroup(*[\n",
        "            OldTex(\"\\\\pi\", \"-\", \"0\").next_to(line, DOWN)\n",
        "            for line in frac_lines\n",
        "        ])\n",
        "        for tex_mob in pi_minus_zeros:\n",
        "            for tex in \"pi\", \"0\":\n",
        "                tex_mob.set_color_by_tex(tex, YELLOW)\n",
        "\n",
        "        answer = OldTex(\" = \\\\frac{2}{\\\\pi}\")\n",
        "        answer.next_to(\n",
        "            frac_lines, RIGHT,\n",
        "            align_using_submobjects = True\n",
        "        )\n",
        "        answer.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            equals.next_to, frac_lines[0].copy(), RIGHT,\n",
        "            rhs_without_eq.next_to, frac_lines[1].copy(), UP,\n",
        "            *list(map(Write, frac_lines))\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                integral.get_part_by_tex(tex).copy(),\n",
        "                pi_minus_zeros[0].get_part_by_tex(tex)\n",
        "            )\n",
        "            for tex in (\"\\\\pi\",\"0\")\n",
        "        ] + [\n",
        "            Write(pi_minus_zeros[0].get_part_by_tex(\"-\"))\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                rhs.get_part_by_tex(\n",
        "                    tex, substring = False\n",
        "                ).copy(),\n",
        "                pi_minus_zeros[1].get_part_by_tex(tex)\n",
        "            )\n",
        "            for tex in (\"\\\\pi\", \"-\", \"0\")\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        full_equation = VGroup(\n",
        "            integral, frac_lines, rhs, pi_minus_zeros\n",
        "        )\n",
        "        background_rect = BackgroundRectangle(full_equation, fill_opacity = 1)\n",
        "        background_rect.stretch_in_place(1.2, dim = 1)\n",
        "        full_equation.add_to_back(background_rect)\n",
        "        self.play(\n",
        "            full_equation.shift, \n",
        "            (answer.get_width()+MED_LARGE_BUFF)*LEFT\n",
        "        )\n",
        "        self.play(Write(answer))\n",
        "        self.wait()\n",
        "\n",
        "        self.antiderivative_fraction = VGroup(\n",
        "            rhs_without_eq,\n",
        "            frac_lines[1],\n",
        "            pi_minus_zeros[1]\n",
        "        )\n",
        "        self.integral_fraction = VGroup(\n",
        "            integral,\n",
        "            frac_lines[0],\n",
        "            pi_minus_zeros[0],\n",
        "            equals\n",
        "        )\n",
        "\n",
        "    def set_color_antiderivative_fraction(self):\n",
        "        fraction = self.antiderivative_fraction\n",
        "        big_rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.75,\n",
        "        )\n",
        "        big_rect.set_width(FRAME_WIDTH)\n",
        "        big_rect.set_height(FRAME_HEIGHT)\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            FadeIn(morty),\n",
        "            Animation(fraction)\n",
        "        )\n",
        "        self.play(morty.change, \"raise_right_hand\", fraction)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(big_rect),\n",
        "            FadeOut(morty),\n",
        "            Animation(fraction)\n",
        "        )\n",
        "\n",
        "    def show_slope(self):\n",
        "        line = Line(\n",
        "            self.zero_dot.get_center(),\n",
        "            self.pi_dot.get_center(),\n",
        "        )\n",
        "        line.set_color(RED)\n",
        "        line.scale(1.2)\n",
        "\n",
        "        new_v_line = self.v_line.copy().set_color(RED)\n",
        "        new_h_line = self.h_line.copy().set_color(RED)\n",
        "\n",
        "        pi = OldTex(\"\\\\pi\")\n",
        "        pi.next_to(self.h_line, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.rects),\n",
        "            FadeOut(self.area_two)\n",
        "        )\n",
        "        self.play(ShowCreation(new_v_line))\n",
        "        self.play(\n",
        "            ShowCreation(new_h_line),\n",
        "            Write(pi)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(line, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def bring_back_derivative(self):\n",
        "        self.play(\n",
        "            FadeOut(self.integral_fraction),\n",
        "            self.deriv.scale, 1.7,\n",
        "            self.deriv.to_corner, UP+LEFT, MED_LARGE_BUFF,\n",
        "            self.deriv.shift, MED_SMALL_BUFF*DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_tangent_slope(self):\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            0, self.neg_cos,\n",
        "            dx = 0.001,\n",
        "            secant_line_color = YELLOW,\n",
        "            secant_line_length = 4,\n",
        "        )\n",
        "\n",
        "        self.play(*list(map(ShowCreation, ss_group)), run_time = 2)\n",
        "        for count in range(2):\n",
        "            for x in reversed(self.bounds):\n",
        "                self.animate_secant_slope_group_change(\n",
        "                    ss_group,\n",
        "                    target_x = x,\n",
        "                    run_time = 6,\n",
        "                )\n",
        "\n",
        "class GeneralAverage(AverageOfContinuousVariable):\n",
        "    CONFIG = {\n",
        "        \"bounds\" : [1, 6],\n",
        "        \"bound_colors\" : [GREEN, RED],\n",
        "        \"graph_origin\" : 5*LEFT + 2*DOWN,\n",
        "        \"num_rect_iterations\" : 4,\n",
        "        \"max_dx\" : 0.25,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_graph()\n",
        "        self.ask_about_average()\n",
        "        self.show_signed_area()\n",
        "        self.put_area_away()\n",
        "        self.show_finite_sample()\n",
        "        self.show_improving_samples()\n",
        "\n",
        "    def add_graph(self):\n",
        "        graph = self.get_graph(self.func)\n",
        "        graph_label = self.get_graph_label(graph, \"f(x)\")\n",
        "        v_lines = VGroup(*[\n",
        "            self.get_vertical_line_to_graph(\n",
        "                x, graph, line_class = DashedLine\n",
        "            )\n",
        "            for x in self.bounds\n",
        "        ])\n",
        "        for line, color in zip(v_lines, self.bound_colors):\n",
        "            line.set_color(color)\n",
        "        labels = list(map(Tex, \"ab\"))\n",
        "        for line, label in zip(v_lines, labels):\n",
        "            vect = line.get_start()-line.get_end()\n",
        "            label.next_to(line, vect/get_norm(vect))\n",
        "            label.set_color(line.get_color())\n",
        "\n",
        "        self.y_axis_label_mob.shift(0.7*LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(\n",
        "                graph_label, \n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        for line, label in zip(v_lines, labels):\n",
        "            self.play(\n",
        "                Write(label),\n",
        "                ShowCreation(line)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "        self.bounds_labels = labels\n",
        "        self.bound_lines = v_lines\n",
        "\n",
        "    def ask_about_average(self):\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.bounds[0], self.graph, \n",
        "            line_class = DashedLine,\n",
        "            color = WHITE\n",
        "        )\n",
        "        average = OldTexText(\"Average = \")\n",
        "        fraction = OldTex(\n",
        "            \"{\\\\displaystyle \\\\int\", \"^b\", \"_a\", \"f(x)\", \"\\\\,dx\",\n",
        "            \"\\\\over\", \"b\", \"-\", \"a}\"\n",
        "        )\n",
        "        for color, tex in zip(self.bound_colors, \"ab\"):\n",
        "            fraction.set_color_by_tex(tex, color)\n",
        "        fraction.set_color_by_tex(\"displaystyle\", WHITE)\n",
        "        integral = VGroup(*fraction[:5])\n",
        "        denominator = VGroup(*fraction[5:])\n",
        "        average.next_to(fraction.get_part_by_tex(\"over\"), LEFT)\n",
        "        group = VGroup(average, fraction)\n",
        "        group.center().to_edge(UP).shift(LEFT)\n",
        "\n",
        "        self.count = 0\n",
        "        def next_v_line_anim():\n",
        "            target = self.bounds[0] if self.count%2 == 1 else self.bounds[1]\n",
        "            self.count += 1\n",
        "            return self.get_v_line_change_anim(\n",
        "                v_line, self.graph, target,\n",
        "                run_time = 4,\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            next_v_line_anim(),\n",
        "            Write(average, run_time = 2),\n",
        "        )\n",
        "        self.play(\n",
        "            next_v_line_anim(),\n",
        "            Write(\n",
        "                VGroup(*[\n",
        "                    fraction.get_part_by_tex(tex)\n",
        "                    for tex in (\"int\", \"f(x)\", \"dx\", \"over\")\n",
        "                ]),\n",
        "                rate_func = squish_rate_func(smooth, 0.25, 0.75),\n",
        "                run_time = 4\n",
        "            ),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    label.copy(),\n",
        "                    fraction.get_part_by_tex(tex, substring = False),\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for label, tex in zip(\n",
        "                    self.bounds_labels, \n",
        "                    [\"_a\", \"^b\"]\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            next_v_line_anim(),\n",
        "            Write(\n",
        "                fraction.get_part_by_tex(\"-\"),\n",
        "                run_time = 4,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 0.75),\n",
        "            ),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    label.copy(),\n",
        "                    fraction.get_part_by_tex(tex, substring = False),\n",
        "                    run_time = 4,\n",
        "                    rate_func = squish_rate_func(smooth, 0.25, 0.75)\n",
        "                )\n",
        "                for label, tex in zip(\n",
        "                    self.bounds_labels, \n",
        "                    [\"a}\", \"b\"]\n",
        "                )\n",
        "            ]\n",
        "\n",
        "        )\n",
        "        self.play(next_v_line_anim())\n",
        "        self.play(FadeOut(v_line))\n",
        "\n",
        "        self.average_expression = VGroup(average, fraction)\n",
        "\n",
        "    def show_signed_area(self):\n",
        "        rect_list = self.get_riemann_rectangles_list(\n",
        "            self.graph,\n",
        "            self.num_rect_iterations,\n",
        "            max_dx = self.max_dx,\n",
        "            x_min = self.bounds[0],\n",
        "            x_max = self.bounds[1],\n",
        "            end_color = BLUE,\n",
        "            fill_opacity = 0.75,\n",
        "            stroke_width = 0.25,\n",
        "        )\n",
        "        rects = rect_list[0]\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.move_to(self.coords_to_point(2, 2))\n",
        "        minus = OldTex(\"-\")\n",
        "        minus.move_to(self.coords_to_point(5.24, -1))\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            rects, \n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        for new_rects in rect_list[1:]:\n",
        "            self.transform_between_riemann_rects(rects, new_rects)\n",
        "        self.play(Write(plus))\n",
        "        self.play(Write(minus))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.area = VGroup(rects, plus, minus)\n",
        "\n",
        "    def put_area_away(self):\n",
        "        self.play(\n",
        "            FadeOut(self.area),\n",
        "            self.average_expression.scale, 0.75,\n",
        "            self.average_expression.to_corner, DOWN+RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_finite_sample(self):\n",
        "        v_lines = self.get_vertical_lines_to_graph(\n",
        "            self.graph,\n",
        "            x_min = self.bounds[0],\n",
        "            x_max = self.bounds[1],\n",
        "            color = GREEN\n",
        "        )\n",
        "        for line in v_lines:\n",
        "            if self.y_axis.point_to_number(line.get_end()) < 0:\n",
        "                line.set_color(RED)\n",
        "            line.save_state()\n",
        "\n",
        "        line_pair = VGroup(*v_lines[6:8])\n",
        "        brace = Brace(line_pair, DOWN)\n",
        "        dx = brace.get_text(\"$dx$\")\n",
        "\n",
        "        num_samples = OldTexText(\"Num. samples\")\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        rhs = OldTex(\"{b\", \"-\", \"a\", \"\\\\over\", \"dx}\")\n",
        "        for tex, color in zip(\"ab\", self.bound_colors):\n",
        "            rhs.set_color_by_tex(tex, color)\n",
        "        expression = VGroup(num_samples, approx, rhs)\n",
        "        expression.arrange(RIGHT)\n",
        "        expression.next_to(self.y_axis, RIGHT)\n",
        "        rhs_copy = rhs.copy()\n",
        "\n",
        "        f_brace = Brace(line_pair, LEFT, buff = 0)\n",
        "        f_x = f_brace.get_text(\"$f(x)$\")\n",
        "        add_up_f_over = OldTex(\"\\\\text{Add up $f(x)$}\", \"\\\\over\")\n",
        "        add_up_f_over.next_to(num_samples, UP)\n",
        "        add_up_f_over.to_edge(UP)\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(v_lines, run_time = 2))\n",
        "        self.play(*list(map(Write, [brace, dx])))\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(num_samples, approx, *rhs[:-1])))\n",
        "        self.play(ReplacementTransform(\n",
        "            dx.copy(), rhs.get_part_by_tex(\"dx\")\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(add_up_f_over),\n",
        "            *[\n",
        "                ApplyFunction(\n",
        "                    lambda m : m.fade().set_stroke(width = 2),\n",
        "                    v_line\n",
        "                )\n",
        "                for v_line in v_lines\n",
        "            ]\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda m : m.restore().set_stroke(width = 5),\n",
        "                v_line,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(\n",
        "                    there_and_back, a, a+0.2\n",
        "                )\n",
        "            )\n",
        "            for v_line, a in zip(v_lines, np.linspace(0, 0.8, len(v_lines)))\n",
        "        ])\n",
        "        self.play(*[vl.restore for vl in v_lines])\n",
        "        self.play(rhs_copy.next_to, add_up_f_over, DOWN)\n",
        "        self.wait(2)\n",
        "        frac_line = add_up_f_over[1]\n",
        "        self.play(\n",
        "            FadeOut(rhs_copy.get_part_by_tex(\"over\")),\n",
        "            rhs_copy.get_part_by_tex(\"dx\").next_to,\n",
        "                add_up_f_over[0], RIGHT, SMALL_BUFF,\n",
        "            frac_line.scale_about_point, 1.2, frac_line.get_left(),\n",
        "            frac_line.stretch_to_fit_height, frac_line.get_height(),\n",
        "        )\n",
        "        rhs_copy.remove(rhs_copy.get_part_by_tex(\"over\"))\n",
        "        self.wait(2)\n",
        "\n",
        "        int_fraction = self.average_expression[1].copy()\n",
        "        int_fraction.generate_target()\n",
        "        int_fraction.target.next_to(add_up_f_over, RIGHT, LARGE_BUFF)\n",
        "        int_fraction.target.shift_onto_screen()\n",
        "        double_arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        double_arrow.next_to(\n",
        "            int_fraction.target.get_part_by_tex(\"over\"), LEFT\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(int_fraction),\n",
        "            VGroup(add_up_f_over, rhs_copy).shift, 0.4*DOWN\n",
        "        )\n",
        "        self.play(Write(double_arrow))\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            dx, brace, num_samples, approx, rhs\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def show_improving_samples(self):\n",
        "        stroke_width = self.v_lines[0].get_stroke_width()\n",
        "        new_v_lines_list = [\n",
        "            self.get_vertical_lines_to_graph(\n",
        "                self.graph,\n",
        "                x_min = self.bounds[0],\n",
        "                x_max = self.bounds[1],\n",
        "                num_lines = len(self.v_lines)*(2**n),\n",
        "                color = GREEN,\n",
        "                stroke_width = float(stroke_width)/n\n",
        "            )\n",
        "            for n in range(1, 4)\n",
        "        ]\n",
        "        for new_v_lines in new_v_lines_list:\n",
        "            for line in new_v_lines:\n",
        "                if self.y_axis.point_to_number(line.get_end()) < 0:\n",
        "                    line.set_color(RED)\n",
        "\n",
        "        for new_v_lines in new_v_lines_list:\n",
        "            self.play(Transform(\n",
        "                self.v_lines, new_v_lines,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def func(self, x):\n",
        "        return 0.09*(x+1)*(x-4)*(x-8)\n",
        "\n",
        "class GeneralAntiderivative(GeneralAverage):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.setup_axes()\n",
        "        self.add_graph()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.fade_existing_graph()\n",
        "        self.add_fraction()\n",
        "        self.add_antiderivative_graph()\n",
        "        self.show_average_in_terms_of_F()\n",
        "        self.draw_slope()\n",
        "        self.show_tangent_line_slopes()\n",
        "\n",
        "    def fade_existing_graph(self):\n",
        "        self.graph.fade(0.3)\n",
        "        self.graph_label.fade(0.3)\n",
        "        self.bound_lines.fade(0.3)\n",
        "\n",
        "    def add_fraction(self):\n",
        "        fraction = OldTex(\n",
        "            \"{\\\\displaystyle \\\\int\", \"^b\", \"_a\", \"f(x)\", \"\\\\,dx\",\n",
        "            \"\\\\over\", \"b\", \"-\", \"a}\"\n",
        "        )\n",
        "        for tex, color in zip(\"ab\", self.bound_colors):\n",
        "            fraction.set_color_by_tex(tex, color)\n",
        "        fraction.set_color_by_tex(\"display\", WHITE)\n",
        "\n",
        "        fraction.scale(0.8)\n",
        "        fraction.next_to(self.y_axis, RIGHT)\n",
        "        fraction.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        self.add(fraction)\n",
        "\n",
        "        self.fraction = fraction\n",
        "\n",
        "    def add_antiderivative_graph(self):\n",
        "        x_max = 9.7\n",
        "        antideriv_graph = self.get_graph(\n",
        "            lambda x : scipy.integrate.quad(\n",
        "                self.graph.underlying_function,\n",
        "                1, x\n",
        "            )[0],\n",
        "            color = YELLOW,\n",
        "            x_max = x_max,\n",
        "        )\n",
        "        antideriv_graph_label = self.get_graph_label(\n",
        "            antideriv_graph, \"F(x)\",\n",
        "            x_val = x_max\n",
        "        )\n",
        "\n",
        "        deriv = OldTex(\n",
        "            \"{dF\", \"\\\\over\", \"dx}\", \"(x)\", \"=\", \"f(x)\"\n",
        "        )\n",
        "        deriv.set_color_by_tex(\"dF\", antideriv_graph.get_color())\n",
        "        deriv.set_color_by_tex(\"f(x)\", BLUE)\n",
        "        deriv.next_to(\n",
        "            antideriv_graph_label, DOWN, MED_LARGE_BUFF, LEFT\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(antideriv_graph),\n",
        "            Write(\n",
        "                antideriv_graph_label, \n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(deriv))\n",
        "        self.wait()\n",
        "\n",
        "        self.antideriv_graph = antideriv_graph\n",
        "\n",
        "    def show_average_in_terms_of_F(self):\n",
        "        new_fraction = OldTex(\n",
        "            \"=\", \n",
        "            \"{F\", \"(\", \"b\", \")\", \"-\", \"F\", \"(\", \"a\", \")\",\n",
        "            \"\\\\over\",\n",
        "            \"b\", \"-\", \"a}\"\n",
        "        )\n",
        "        for tex, color in zip(\"abF\", self.bound_colors+[YELLOW]):\n",
        "            new_fraction.set_color_by_tex(tex, color)\n",
        "        new_fraction.next_to(\n",
        "            self.fraction.get_part_by_tex(\"over\"), RIGHT,\n",
        "            align_using_submobjects = True\n",
        "        )   \n",
        "\n",
        "        to_write = VGroup(*it.chain(*[\n",
        "            new_fraction.get_parts_by_tex(tex)\n",
        "            for tex in \"=F()-\"\n",
        "        ]))\n",
        "        to_write.remove(new_fraction.get_parts_by_tex(\"-\")[-1])\n",
        "\n",
        "        numerator = VGroup(*new_fraction[1:10])\n",
        "        denominator = VGroup(*new_fraction[-3:])\n",
        "\n",
        "        self.play(Write(to_write))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                label.copy(),\n",
        "                new_fraction.get_part_by_tex(tex),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.7)\n",
        "            )\n",
        "            for label, tex, a in zip(\n",
        "                self.bounds_labels, \"ab\", [0, 0.3]\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.show_change_in_height(numerator.copy())\n",
        "        self.shift_antideriv_graph_up_and_down()\n",
        "        self.play(Write(VGroup(*new_fraction[-4:])))\n",
        "        self.wait()\n",
        "\n",
        "        h_line_brace = Brace(self.h_line, DOWN)\n",
        "        denominator_copy = denominator.copy()\n",
        "        a_label = self.bounds_labels[0]\n",
        "        self.play(\n",
        "            GrowFromCenter(h_line_brace),\n",
        "            a_label.shift, 0.7*a_label.get_width()*LEFT,\n",
        "            a_label.shift, 2.2*a_label.get_height()*UP,\n",
        "        )\n",
        "        self.play(\n",
        "            denominator_copy.next_to, h_line_brace, \n",
        "            DOWN, SMALL_BUFF\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_change_in_height(self, numerator):\n",
        "        numerator.add_to_back(BackgroundRectangle(numerator))\n",
        "        a_point, b_point = points = [\n",
        "            self.input_to_graph_point(x, self.antideriv_graph)\n",
        "            for x in self.bounds\n",
        "        ]\n",
        "        interim_point = b_point[0]*RIGHT + a_point[1]*UP\n",
        "\n",
        "        v_line = Line(b_point, interim_point)\n",
        "        h_line = Line(interim_point, a_point)\n",
        "        VGroup(v_line, h_line).set_color(WHITE)\n",
        "        brace = Brace(v_line, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        graph_within_bounds = self.get_graph(\n",
        "            self.antideriv_graph.underlying_function,\n",
        "            x_min = self.bounds[0], \n",
        "            x_max = self.bounds[1],\n",
        "            color = self.antideriv_graph.get_color()\n",
        "        )\n",
        "\n",
        "        b_label = self.bounds_labels[1]\n",
        "        self.play(\n",
        "            self.antideriv_graph.fade, 0.7,\n",
        "            Animation(graph_within_bounds)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            b_label.shift, b_label.get_width()*RIGHT,\n",
        "            b_label.shift, 1.75*b_label.get_height()*DOWN,\n",
        "        )\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.play(\n",
        "            numerator.scale, 0.75,\n",
        "            numerator.next_to, brace.copy(), RIGHT, SMALL_BUFF,\n",
        "            GrowFromCenter(brace),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.antideriv_graph.add(\n",
        "            graph_within_bounds, v_line, h_line, numerator, brace\n",
        "        )\n",
        "        self.h_line = h_line\n",
        "        self.graph_points_at_bounds = points\n",
        "\n",
        "    def shift_antideriv_graph_up_and_down(self):\n",
        "        for vect in 2*UP, 3*DOWN, UP:\n",
        "            self.play(\n",
        "                self.antideriv_graph.shift, vect,\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def draw_slope(self):\n",
        "        line = Line(*self.graph_points_at_bounds)\n",
        "        line.set_color(PINK)\n",
        "        line.scale(1.3)\n",
        "\n",
        "        self.play(ShowCreation(line, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "    def show_tangent_line_slopes(self):\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            x = self.bounds[0],\n",
        "            graph = self.antideriv_graph,\n",
        "            dx = 0.001,\n",
        "            secant_line_color = BLUE,\n",
        "            secant_line_length = 2,\n",
        "        )\n",
        "\n",
        "        self.play(*list(map(ShowCreation, ss_group)))\n",
        "        for x in range(2):\n",
        "            for bound in reversed(self.bounds):\n",
        "                self.animate_secant_slope_group_change(\n",
        "                    ss_group,\n",
        "                    target_x = bound,\n",
        "                    run_time = 5,\n",
        "                )\n",
        "\n",
        "class LastVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Chapter 8: Integrals\")\n",
        "        title.to_edge(UP)\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_stroke(WHITE)\n",
        "        rect.set_height(1.5*FRAME_Y_RADIUS)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.play(Write(title), ShowCreation(rect))\n",
        "        self.wait(5)\n",
        "\n",
        "class ASecondIntegralSensation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        finite_average = OldTex(\"{1+5+4+2 \\\\over 4}\")\n",
        "        numbers = VGroup(*finite_average[0:7:2])\n",
        "        plusses = VGroup(*finite_average[1:7:2])\n",
        "        denominator = VGroup(*finite_average[7:])\n",
        "        finite_average.to_corner(UP+LEFT)\n",
        "        finite_average.to_edge(LEFT)\n",
        "\n",
        "        continuum = UnitInterval(\n",
        "            color = GREY,\n",
        "            unit_size = 6\n",
        "        )\n",
        "        continuum.next_to(finite_average, RIGHT, 2)\n",
        "        line = Line(continuum.get_left(), continuum.get_right())\n",
        "        line.set_color(YELLOW)\n",
        "        arrow = Arrow(DOWN+RIGHT, ORIGIN)\n",
        "        arrow.next_to(line.get_start(), DOWN+RIGHT, SMALL_BUFF)\n",
        "\n",
        "        sigma_to_integral = OldTex(\n",
        "            \"\\\\sum \\\\Leftrightarrow \\\\int\"\n",
        "        )\n",
        "        sigma_to_integral.next_to(\n",
        "            self.teacher.get_corner(UP+LEFT), UP, MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"A second integral \\\\\\\\ sensation\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"erm\"]*3)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(numbers),\n",
        "            RemovePiCreatureBubble(self.teacher),\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = numbers\n",
        "        )\n",
        "        self.play(Write(plusses))\n",
        "        self.wait()\n",
        "        self.play(Write(denominator))\n",
        "        self.wait()\n",
        "\n",
        "        self.play_student_changes(\n",
        "            *[\"confused\"]*3,\n",
        "            look_at = continuum,\n",
        "            added_anims = [Write(continuum, run_time = 2)]\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        arrow.save_state()\n",
        "        self.play(\n",
        "            arrow.next_to, line.copy().get_end(), DOWN+RIGHT, SMALL_BUFF,\n",
        "            ShowCreation(line),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [arrow])))\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = sigma_to_integral,\n",
        "            added_anims = [\n",
        "                Write(sigma_to_integral),\n",
        "                self.teacher.change_mode, \"raise_right_hand\"\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class Chapter9PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek Dai\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Zac Wentzell\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mark Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -0.2,\n",
        "        \"x_max\" : 3.5,\n",
        "        \"x_leftmost_tick\" : 0,\n",
        "        \"x_tick_frequency\" : np.pi/4,\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_min\" : -0.75,\n",
        "        \"y_max\" : 0.75,\n",
        "        \"y_axis_height\" : 4.5,\n",
        "        \"y_tick_frequency\" : 0.25,\n",
        "        \"y_axis_label\" : \"\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.remove(self.axes)\n",
        "\n",
        "        sine = self.get_graph(np.sin)\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            sine,\n",
        "            x_min = 0,\n",
        "            x_max = np.pi,\n",
        "            dx = 0.01,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        sine.add_to_back(rects)\n",
        "        sine.add(self.axes.copy())\n",
        "        sine.to_corner(UP+LEFT, buff = SMALL_BUFF)\n",
        "        sine.scale(0.9)\n",
        "\n",
        "        area = OldTexText(\"Area\")\n",
        "        area.scale(3)\n",
        "        area.move_to(rects)\n",
        "\n",
        "        cosine = self.get_graph(lambda x : -np.cos(x))\n",
        "        cosine.set_stroke(GREEN, 8)\n",
        "        line = self.get_secant_slope_group(\n",
        "            0.75*np.pi, cosine, \n",
        "            dx = 0.01\n",
        "        ).secant_line\n",
        "        line.set_stroke(PINK, 7)\n",
        "        cosine.add(line)\n",
        "        cosine.add(self.axes.copy())\n",
        "        cosine.scale(0.7)\n",
        "        cosine.to_corner(DOWN+RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        slope = OldTexText(\"Slope\")\n",
        "        slope.scale(3)\n",
        "        # slope.next_to(cosine, LEFT, buff = 0)\n",
        "        # slope.to_edge(DOWN)\n",
        "        slope.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        double_arrow = DoubleArrow(\n",
        "            area.get_bottom(),\n",
        "            slope.get_left(),\n",
        "            color = YELLOW,\n",
        "            tip_length = 0.75,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        double_arrow.set_stroke(width = 18)\n",
        "\n",
        "        triangle = Polygon(\n",
        "            ORIGIN, UP, UP+RIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLUE_E,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        triangle.stretch_to_fit_width(FRAME_WIDTH)\n",
        "        triangle.stretch_to_fit_height(FRAME_HEIGHT)\n",
        "        triangle.to_corner(UP+LEFT, buff = 0)\n",
        "\n",
        "        alt_triangle = triangle.copy()\n",
        "        alt_triangle.rotate(np.pi)\n",
        "        alt_triangle.set_fill(BLACK, 1)\n",
        "\n",
        "        self.add(\n",
        "            triangle, sine, area, \n",
        "            alt_triangle, cosine, slope, \n",
        "            double_arrow,\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}