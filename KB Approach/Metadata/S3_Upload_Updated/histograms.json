{
    "topic": "demonstrates the concept of creating a histogram using Manim animation library. The class",
    "code": [
        "from manim_imports_ext import *\n",
        "from random import *\n",
        "\n",
        "def text_range(start,stop,step): # a range as a list of strings\n",
        "    numbers = np.arange(start,stop,step)\n",
        "    labels = []\n",
        "    for x in numbers:\n",
        "        labels.append(str(x))\n",
        "    return labels\n",
        "\n",
        "\n",
        "class Histogram(VMobject):\n",
        "\n",
        "    CONFIG = {\n",
        "        \"start_color\" : RED,\n",
        "        \"end_color\" : BLUE,\n",
        "        \"x_scale\" : 1.0,\n",
        "        \"y_scale\" : 1.0,\n",
        "        \"x_labels\" : \"auto\", # widths, mids, auto, none, [...]\n",
        "        \"y_labels\" : \"auto\", # auto, none, [...]\n",
        "        \"y_label_position\" : \"top\", # \"center\"\n",
        "        \"x_min\" : 0,\n",
        "        \"bar_stroke_width\" : 5,\n",
        "        \"outline_stroke_width\" : 0,\n",
        "        \"stroke_color\" : WHITE\n",
        "    }\n",
        "\n",
        "    def __init__(self, x_values, y_values, mode = \"widths\", **kwargs):\n",
        "        # mode = \"widths\" : x_values means the widths of the bars\n",
        "        # mode = \"posts\"  : x_values means the delimiters btw the bars \n",
        "\n",
        "        digest_config(self, kwargs)\n",
        "\n",
        "        if mode == \"widths\" and len(x_values) != len(y_values):\n",
        "            raise Exception(\"Array lengths do not match up!\")\n",
        "        elif mode == \"posts\" and len(x_values) != len(y_values) + 1:\n",
        "            raise Exception(\"Array lengths do not match up!\")\n",
        "\n",
        "\n",
        "        self.y_values = y_values\n",
        "        self.x_values = x_values\n",
        "        self.mode = mode\n",
        "        self.process_values()\n",
        "\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        \n",
        "\n",
        "    def process_values(self):\n",
        "\n",
        "         # preliminaries\n",
        "        self.y_values = np.array(self.y_values)\n",
        "\n",
        "        if self.mode == \"widths\":\n",
        "            self.widths = self.x_values\n",
        "            self.posts = np.cumsum(self.widths)\n",
        "            self.posts = np.insert(self.posts, 0, 0)\n",
        "            self.posts += self.x_min\n",
        "            self.x_max = self.posts[-1]\n",
        "        elif self.mode == \"posts\":\n",
        "            self.posts = self.x_values\n",
        "            self.widths = self.x_values[1:] - self.x_values[:-1]\n",
        "            self.x_min = self.posts[0]\n",
        "            self.x_max = self.posts[-1]\n",
        "        else:\n",
        "            raise Exception(\"Invalid mode or no mode specified!\")\n",
        "\n",
        "        self.x_mids = 0.5 * (self.posts[:-1] + self.posts[1:])\n",
        "\n",
        "        self.widths_scaled = self.x_scale * self.widths\n",
        "        self.posts_scaled = self.x_scale * self.posts\n",
        "        self.x_min_scaled = self.x_scale * self.x_min\n",
        "        self.x_max_scaled = self.x_scale * self.x_max\n",
        "\n",
        "        self.y_values_scaled = self.y_scale * self.y_values\n",
        "\n",
        "\n",
        "\n",
        "    def init_points(self):\n",
        "\n",
        "        self.process_values()\n",
        "        for submob in self.submobjects:\n",
        "            self.remove(submob)\n",
        "\n",
        "        def empty_string_array(n):\n",
        "            arr = []\n",
        "            for i in range(n):\n",
        "                arr.append(\"\")\n",
        "            return arr\n",
        "\n",
        "        def num_arr_to_string_arr(arr): # converts number array to string array\n",
        "            ret_arr = []\n",
        "            for x in arr:\n",
        "                if x == np.floor(x):\n",
        "                    new_x = int(np.floor(x))\n",
        "                else:\n",
        "                    new_x = x\n",
        "                ret_arr.append(str(new_x))\n",
        "            return ret_arr\n",
        "\n",
        "        previous_bar = ORIGIN\n",
        "        self.bars = VGroup()\n",
        "        self.x_labels_group = VGroup()\n",
        "        self.y_labels_group = VGroup()\n",
        "        outline_points = []\n",
        "\n",
        "        if self.x_labels == \"widths\":\n",
        "            self.x_labels = num_arr_to_string_arr(self.widths)\n",
        "        elif self.x_labels == \"mids\":\n",
        "            self.x_labels = num_arr_to_string_arr(self.x_mids)\n",
        "        elif self.x_labels == \"auto\":\n",
        "            self.x_labels = num_arr_to_string_arr(self.x_mids)\n",
        "        elif self.x_labels == \"none\":\n",
        "            self.x_labels = empty_string_array(len(self.widths))\n",
        "\n",
        "        if self.y_labels == \"auto\":\n",
        "            self.y_labels = num_arr_to_string_arr(self.y_values)\n",
        "        elif self.y_labels == \"none\":\n",
        "            self.y_labels = empty_string_array(len(self.y_values))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        for (i,x) in enumerate(self.x_mids):\n",
        "\n",
        "            bar = Rectangle(\n",
        "                width = self.widths_scaled[i],\n",
        "                height = self.y_values_scaled[i],\n",
        "                stroke_width = self.bar_stroke_width,\n",
        "                stroke_color = self.stroke_color,\n",
        "            )\n",
        "            if bar.height == 0:\n",
        "                bar.height = 0.01\n",
        "                bar.init_points()\n",
        "\n",
        "            t = float(x - self.x_min)/(self.x_max - self.x_min)\n",
        "            bar_color = interpolate_color(\n",
        "                self.start_color,\n",
        "                self.end_color,\n",
        "                t\n",
        "            )\n",
        "            bar.set_fill(color = bar_color, opacity = 1)\n",
        "            bar.next_to(previous_bar,RIGHT,buff = 0, aligned_edge = DOWN)\n",
        "            \n",
        "            self.bars.add(bar)\n",
        "\n",
        "            x_label = OldTexText(self.x_labels[i])\n",
        "            x_label.next_to(bar,DOWN)\n",
        "            self.x_labels_group.add(x_label)\n",
        "\n",
        "            y_label = OldTexText(self.y_labels[i])\n",
        "            if self.y_label_position == \"top\":\n",
        "                y_label.next_to(bar, UP)\n",
        "            elif self.y_label_position == \"center\":\n",
        "                y_label.move_to(bar)\n",
        "            else:\n",
        "                raise Exception(\"y_label_position must be top or center\")\n",
        "            self.y_labels_group.add(y_label)\n",
        "\n",
        "            if i == 0:\n",
        "                # start with the lower left\n",
        "                outline_points.append(bar.get_anchors()[-2])\n",
        "\n",
        "            # upper two points of each bar\n",
        "            outline_points.append(bar.get_anchors()[0])\n",
        "            outline_points.append(bar.get_anchors()[1])\n",
        "\n",
        "            previous_bar = bar\n",
        "        # close the outline\n",
        "            # lower right\n",
        "        outline_points.append(bar.get_anchors()[2])\n",
        "            # lower left\n",
        "        outline_points.append(outline_points[0])\n",
        "\n",
        "        self.outline = Polygon(*outline_points,\n",
        "            stroke_width = self.outline_stroke_width,\n",
        "            stroke_color = self.stroke_color)\n",
        "        self.add(self.bars, self.x_labels_group, self.y_labels_group, self.outline)\n",
        "\n",
        "        self.move_to(ORIGIN)\n",
        "\n",
        "    def get_lower_left_point(self):\n",
        "        return self.bars[0].get_anchors()[-2]\n",
        "\n",
        "\n",
        "\n",
        "class BuildUpHistogram(Animation):\n",
        "\n",
        "    def __init__(self, hist, **kwargs):\n",
        "        self.histogram = hist\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class FlashThroughHistogram(Animation):\n",
        "    CONFIG = {\n",
        "        \"cell_color\" : WHITE,\n",
        "        \"cell_opacity\" : 0.8,\n",
        "        \"hist_opacity\" : 0.2\n",
        "    }\n",
        "\n",
        "    def __init__(self, mobject,\n",
        "        direction = \"horizontal\",\n",
        "        mode = \"random\",\n",
        "        **kwargs):\n",
        "\n",
        "        digest_config(self, kwargs)\n",
        "\n",
        "        self.cell_height = mobject.y_scale\n",
        "        self.prototype_cell = Rectangle(\n",
        "            width = 1,\n",
        "            height = self.cell_height,\n",
        "            fill_color = self.cell_color,\n",
        "            fill_opacity = self.cell_opacity,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "\n",
        "        x_values = mobject.x_values\n",
        "        y_values = mobject.y_values\n",
        "\n",
        "        self.mode = mode\n",
        "        self.direction = direction\n",
        "\n",
        "        self.generate_cell_indices(x_values,y_values)\n",
        "        Animation.__init__(self,mobject,**kwargs)\n",
        "\n",
        "\n",
        "\n",
        "    def generate_cell_indices(self,x_values,y_values):\n",
        "\n",
        "        self.cell_indices = []\n",
        "        for (i,x) in enumerate(x_values):\n",
        "\n",
        "            nb_cells = int(np.floor(y_values[i]))\n",
        "            for j in range(nb_cells):\n",
        "                self.cell_indices.append((i, j))\n",
        "\n",
        "        self.reordered_cell_indices = self.cell_indices\n",
        "        if self.mode == \"random\":\n",
        "            shuffle(self.reordered_cell_indices)\n",
        "\n",
        "\n",
        "    def cell_for_index(self,i,j):\n",
        "\n",
        "        if self.direction == \"vertical\":\n",
        "            width = self.mobject.x_scale\n",
        "            height = self.mobject.y_scale\n",
        "            x = (i + 0.5) * self.mobject.x_scale\n",
        "            y = (j + 0.5) * self.mobject.y_scale\n",
        "            center = self.mobject.get_lower_left_point() + x * RIGHT + y * UP\n",
        "        \n",
        "        elif self.direction == \"horizontal\":\n",
        "            width = self.mobject.x_scale / self.mobject.y_values[i]\n",
        "            height = self.mobject.y_scale * self.mobject.y_values[i]\n",
        "            x = i * self.mobject.x_scale + (j + 0.5) * width\n",
        "            y = height / 2\n",
        "            center = self.mobject.get_lower_left_point() + x * RIGHT + y * UP\n",
        "\n",
        "        cell = Rectangle(width = width, height = height)\n",
        "        cell.move_to(center)\n",
        "        return cell\n",
        "\n",
        "\n",
        "    def interpolate_mobject(self,t):\n",
        "\n",
        "        if t == 0:\n",
        "            self.mobject.add(self.prototype_cell)\n",
        "\n",
        "        flash_nb = int(t * (len(self.cell_indices))) - 1\n",
        "        (i,j) = self.reordered_cell_indices[flash_nb]\n",
        "        cell = self.cell_for_index(i,j)\n",
        "        self.prototype_cell.width = cell.get_width()\n",
        "        self.prototype_cell.height = cell.get_height()\n",
        "        self.prototype_cell.init_points()\n",
        "        self.prototype_cell.move_to(cell.get_center())\n",
        "\n",
        "        if t == 1:\n",
        "           self.mobject.remove(self.prototype_cell)\n",
        "\n",
        "\n",
        "    def clean_up_from_scene(self, scene = None):\n",
        "        Animation.clean_up_from_scene(self, scene)\n",
        "        self.update(1)\n",
        "        if scene is not None:\n",
        "            if self.is_remover():\n",
        "                scene.remove(self.prototype_cell)\n",
        "            else:\n",
        "                scene.add(self.prototype_cell)\n",
        "        return self\n",
        "\n",
        "\n",
        "\n",
        "class OutlineableBars(VGroup):\n",
        "\n",
        "    # A group of bars (rectangles), together with\n",
        "    # a method that draws an outline around them,\n",
        "    # assuming the bars are arranged in a histogram\n",
        "    # (aligned at the bottom without gaps).\n",
        "\n",
        "    # We use this to morph a row of bricks into a histogram.\n",
        "\n",
        "    CONFIG = {\n",
        "        \"outline_stroke_width\" : 3,\n",
        "        \"stroke_color\" : WHITE\n",
        "    }\n",
        "    def create_outline(self, animated = False, **kwargs):\n",
        "\n",
        "        outline_points = []\n",
        "\n",
        "        for (i, bar) in enumerate(self.submobjects):\n",
        "            \n",
        "            if i == 0:\n",
        "                # start with the lower left\n",
        "                outline_points.append(bar.get_corner(DOWN + LEFT))\n",
        "\n",
        "            # upper two points of each bar\n",
        "            outline_points.append(bar.get_corner(UP + LEFT))\n",
        "            outline_points.append(bar.get_corner(UP + RIGHT))\n",
        "\n",
        "            previous_bar = bar\n",
        "        # close the outline\n",
        "            # lower right\n",
        "        outline_points.append(previous_bar.get_corner(DOWN + RIGHT))\n",
        "            # lower left\n",
        "        outline_points.append(outline_points[0])\n",
        "\n",
        "        self.outline = Polygon(*outline_points,\n",
        "            stroke_width = self.outline_stroke_width,\n",
        "            stroke_color = self.stroke_color)\n",
        "\n",
        "        if animated:\n",
        "            self.play(FadeIn(self.outline, **kwargs))\n",
        "        return self.outline\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}