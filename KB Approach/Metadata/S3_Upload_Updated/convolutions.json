{
    "topic": "demonstrates the concept of a box blur filter, which is a technique used in image",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def box_blur(n):\n",
        "    return np.ones((n, n)) / (n**2)\n",
        "\n",
        "\n",
        "class ConvolutionIntroduction(InteractiveScene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        # Setup the pixel grids\n",
        "        image = Image.open(get_full_raster_image_path(\"Mario\"))\n",
        "\n",
        "        arr = np.array(image)\n",
        "        skip = 40\n",
        "        arr = arr[skip::skip, 0::skip, :3]\n",
        "        height, width = arr.shape[:2]\n",
        "\n",
        "        pixel_array = VGroup(*[\n",
        "            Square(fill_color=rgb_to_hex(arr[i, j] / 255), fill_opacity=1)\n",
        "            for i in range(height)\n",
        "            for j in range(width)\n",
        "        ])\n",
        "        pixel_array.arrange_in_grid(height, width, buff=0)\n",
        "        pixel_array.set_height(6)\n",
        "        pixel_array.set_stroke(WHITE, 1)\n",
        "        pixel_array.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        new_array = pixel_array.copy()\n",
        "        new_array.next_to(pixel_array, RIGHT, buff=2)\n",
        "        new_array.set_fill(BLACK, 0)\n",
        "\n",
        "        self.add(pixel_array)\n",
        "        self.add(new_array)\n",
        "\n",
        "        # Setup kernel\n",
        "        def get_kernel_array(kernel, pixel_array=pixel_array, tex=None):\n",
        "            kernel_array = VGroup()\n",
        "            for row in kernel:\n",
        "                for x in row:\n",
        "                    square = pixel_array[0].copy()\n",
        "                    square.set_fill(BLACK, 0)\n",
        "                    square.set_stroke(BLUE, 2)\n",
        "                    if tex:\n",
        "                        value = OldTex(tex)\n",
        "                    else:\n",
        "                        value = DecimalNumber(x, num_decimal_places=3)\n",
        "                    value.set_width(square.get_width() * 0.7)\n",
        "                    value.set_backstroke(BLACK, 3)\n",
        "                    value.move_to(square)\n",
        "                    square.add(value)\n",
        "                    kernel_array.add(square)\n",
        "            kernel_array.arrange_in_grid(*kernel.shape, buff=0)\n",
        "            kernel_array.move_to(pixel_array[0])\n",
        "            return kernel_array\n",
        "\n",
        "        kernel = box_blur(3)\n",
        "        kernel_array = get_kernel_array(kernel, tex=\"1 / 9\")\n",
        "        self.add(kernel_array)\n",
        "\n",
        "        # Define step\n",
        "        right_rect = new_array[0].copy()\n",
        "        right_rect.set_stroke(BLUE, 2)\n",
        "        self.add(right_rect)\n",
        "\n",
        "        def step(pos=0):\n",
        "            i = pos // width\n",
        "            j = pos % width\n",
        "\n",
        "            h, w = kernel.shape\n",
        "            pixels = np.array([\n",
        "                square.data[\"fill_rgba\"][0]\n",
        "                for square in pixel_array\n",
        "            ]).reshape((height, width, 4))\n",
        "\n",
        "            rgba = sum([\n",
        "                kernel[k, l] * pixels[i - k, j - l]\n",
        "                for k in range(-(w // 2), w // 2 + 1)\n",
        "                for l in range(-(h // 2), h // 2 + 1)\n",
        "                if (0 <= i - k < pixels.shape[0]) and (0 <= j - l < pixels.shape[1])\n",
        "            ])\n",
        "\n",
        "            kernel_array.move_to(pixel_array[pos])\n",
        "            right_rect.move_to(new_array[pos])\n",
        "            new_array[pos].data[\"fill_rgba\"][0] = rgba\n",
        "\n",
        "        def walk(start, stop, time=5, surface=None):\n",
        "            for n in range(start, stop):\n",
        "                step(n)\n",
        "                if surface is not None:\n",
        "                    surface.move_to(kernel_array, IN)\n",
        "                self.wait(time / (stop - start), ignore_presenter_mode=True)\n",
        "\n",
        "        # Setup zooming\n",
        "        def zoom_to_kernel():\n",
        "            self.play(\n",
        "                frame.animate.set_height(1.5 * kernel_array.get_height()).move_to(kernel_array),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        def zoom_to_new_pixel():\n",
        "            self.play(\n",
        "                frame.animate.set_height(1.5 * kernel_array.get_height()).move_to(right_rect),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        def reset_frame():\n",
        "            self.play(frame.animate.to_default_state())\n",
        "\n",
        "        # Example walking\n",
        "        last_i = 0\n",
        "        next_i = 151\n",
        "        walk(last_i, next_i, 5)\n",
        "        self.wait()\n",
        "        zoom_to_kernel()\n",
        "        self.wait()\n",
        "        reset_frame()\n",
        "        zoom_to_new_pixel()\n",
        "        self.wait()\n",
        "        reset_frame()\n",
        "\n",
        "        last_i = next_i\n",
        "        next_i = 390\n",
        "        walk(151, next_i, 2)\n",
        "        self.wait(0.5)\n",
        "        zoom_to_kernel()\n",
        "        self.wait()\n",
        "        # reset_frame()\n",
        "        zoom_to_new_pixel()\n",
        "        self.wait()\n",
        "        reset_frame()\n",
        "\n",
        "        last_i = next_i\n",
        "        next_i = len(pixel_array)\n",
        "        walk(last_i, next_i, 10)\n",
        "        self.wait()\n",
        "\n",
        "        # Gauss kernel\n",
        "        gauss_kernel = np.array([\n",
        "            [0.00296902, 0.0133062, 0.0219382, 0.0133062, .00296902],\n",
        "            [0.0133062, 0.0596343, 0.0983203, 0.0596343, 0.0133062],\n",
        "            [0.0219382, 0.0983203, 0.162103, 0.0983203, 0.0219382],\n",
        "            [0.0133062, 0.0596343, 0.0983203, 0.0596343, 0.0133062],\n",
        "            [0.00296902, 0.0133062, 0.0219382, 0.0133062, 0.00296902],\n",
        "        ])  # Oh good, hard coded, I hope you feel happy with yourself.\n",
        "        gauss_array = get_kernel_array(gauss_kernel)\n",
        "        kernel_array.set_submobjects(gauss_array)\n",
        "\n",
        "        kernel = gauss_kernel\n",
        "        new_array.set_fill(BLACK, 0)\n",
        "\n",
        "        walk(0, 206, time=5)\n",
        "        # walk(0, 200, time=10)\n",
        "        self.wait()\n",
        "        zoom_to_kernel()\n",
        "        self.wait()\n",
        "\n",
        "        # Gauss surface\n",
        "        gaussian = ParametricSurface(\n",
        "            lambda u, v: [u, v, np.exp(-(u**2) - v**2)],\n",
        "            u_range=(-3, 3),\n",
        "            v_range=(-3, 3),\n",
        "            resolution=(101, 101),\n",
        "        )\n",
        "        gaussian.set_color(BLUE, 0.8)\n",
        "        gaussian.match_width(kernel_array)\n",
        "        gaussian.stretch(2, 2)\n",
        "\n",
        "        def update_surface(surface, kernel_array=kernel_array):\n",
        "            surface.move_to(kernel_array, IN)\n",
        "\n",
        "        update_surface(gaussian)\n",
        "        self.play(\n",
        "            FadeIn(gaussian),\n",
        "            frame.animate.reorient(10, 70),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_height(8).reorient(0, 60).set_x(-1),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # More walking\n",
        "        walk(200, len(pixel_array), time=10, surface=gaussian)\n",
        "        self.wait()\n",
        "        self.play(frame.animate.to_default_state(), run_time=2)\n",
        "        self.wait()\n"
    ]
}